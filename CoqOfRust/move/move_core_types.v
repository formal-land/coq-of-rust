(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module abi.
  (*
  Enum ScriptABI
  {
    ty_params := [];
    variants :=
      [
        {
          name := "TransactionScript";
          item := StructTuple [ Ty.path "move_core_types::abi::TransactionScriptABI" ];
          discriminant := None;
        };
        {
          name := "ScriptFunction";
          item := StructTuple [ Ty.path "move_core_types::abi::ScriptFunctionABI" ];
          discriminant := None;
        }
      ];
  }
  *)
  
  Module Impl_core_clone_Clone_for_move_core_types_abi_ScriptABI.
    Definition Self : Ty.t := Ty.path "move_core_types::abi::ScriptABI".
    
    (* Clone *)
    Definition clone (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::abi::ScriptABI::TransactionScript",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_core_types::abi::ScriptABI::TransactionScript"
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.path "move_core_types::abi::TransactionScriptABI",
                              [],
                              "clone",
                              []
                            |),
                            [ M.read (| __self_0 |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::abi::ScriptABI::ScriptFunction",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_core_types::abi::ScriptABI::ScriptFunction"
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.path "move_core_types::abi::ScriptFunctionABI",
                              [],
                              "clone",
                              []
                            |),
                            [ M.read (| __self_0 |) ]
                          |)
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_move_core_types_abi_ScriptABI.
  
  Module Impl_core_fmt_Debug_for_move_core_types_abi_ScriptABI.
    Definition Self : Ty.t := Ty.path "move_core_types::abi::ScriptABI".
    
    (* Debug *)
    Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::abi::ScriptABI::TransactionScript",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_tuple_field1_finish",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.read (| mk_str "TransactionScript" |);
                          (* Unsize *) M.pointer_coercion __self_0
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::abi::ScriptABI::ScriptFunction",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_tuple_field1_finish",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.read (| mk_str "ScriptFunction" |);
                          (* Unsize *) M.pointer_coercion __self_0
                        ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_move_core_types_abi_ScriptABI.
  
  Module Impl_core_hash_Hash_for_move_core_types_abi_ScriptABI.
    Definition Self : Ty.t := Ty.path "move_core_types::abi::ScriptABI".
    
    (* Hash *)
    Definition hash (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ __H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let state := M.alloc (| state |) in
          M.read (|
            let __self_tag :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [ Ty.path "move_core_types::abi::ScriptABI" ]
                  |),
                  [ M.read (| self |) ]
                |)
              |) in
            let _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (| "core::hash::Hash", Ty.path "isize", [], "hash", [ __H ] |),
                  [ __self_tag; M.read (| state |) ]
                |)
              |) in
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::abi::ScriptABI::TransactionScript",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.path "move_core_types::abi::TransactionScriptABI",
                          [],
                          "hash",
                          [ __H ]
                        |),
                        [ M.read (| __self_0 |); M.read (| state |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::abi::ScriptABI::ScriptFunction",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.path "move_core_types::abi::ScriptFunctionABI",
                          [],
                          "hash",
                          [ __H ]
                        |),
                        [ M.read (| __self_0 |); M.read (| state |) ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::hash::Hash"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("hash", InstanceField.Method hash) ].
  End Impl_core_hash_Hash_for_move_core_types_abi_ScriptABI.
  
  Module Impl_core_marker_StructuralEq_for_move_core_types_abi_ScriptABI.
    Definition Self : Ty.t := Ty.path "move_core_types::abi::ScriptABI".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralEq_for_move_core_types_abi_ScriptABI.
  
  Module Impl_core_cmp_Eq_for_move_core_types_abi_ScriptABI.
    Definition Self : Ty.t := Ty.path "move_core_types::abi::ScriptABI".
    
    (* Eq *)
    Definition assert_receiver_is_total_eq (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Value.DeclaredButUndefined,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      Value.DeclaredButUndefined,
                      [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_move_core_types_abi_ScriptABI.
  
  Module Impl_core_marker_StructuralPartialEq_for_move_core_types_abi_ScriptABI.
    Definition Self : Ty.t := Ty.path "move_core_types::abi::ScriptABI".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_move_core_types_abi_ScriptABI.
  
  Module Impl_core_cmp_PartialEq_for_move_core_types_abi_ScriptABI.
    Definition Self : Ty.t := Ty.path "move_core_types::abi::ScriptABI".
    
    (* PartialEq *)
    Definition eq (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            let __self_tag :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [ Ty.path "move_core_types::abi::ScriptABI" ]
                  |),
                  [ M.read (| self |) ]
                |)
              |) in
            let __arg1_tag :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [ Ty.path "move_core_types::abi::ScriptABI" ]
                  |),
                  [ M.read (| other |) ]
                |)
              |) in
            M.alloc (|
              LogicalOp.and (|
                BinOp.Pure.eq (M.read (| __self_tag |)) (M.read (| __arg1_tag |)),
                ltac:(M.monadic
                  (M.read (|
                    M.match_operator (|
                      M.alloc (| Value.Tuple [ M.read (| self |); M.read (| other |) ] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.get_tuple_field γ 0 in
                            let γ0_1 := M.get_tuple_field γ 1 in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ0_0,
                                "move_core_types::abi::ScriptABI::TransactionScript",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ0_1,
                                "move_core_types::abi::ScriptABI::TransactionScript",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.path "move_core_types::abi::TransactionScriptABI",
                                  [ Ty.path "move_core_types::abi::TransactionScriptABI" ],
                                  "eq",
                                  []
                                |),
                                [ M.read (| __self_0 |); M.read (| __arg1_0 |) ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.get_tuple_field γ 0 in
                            let γ0_1 := M.get_tuple_field γ 1 in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ0_0,
                                "move_core_types::abi::ScriptABI::ScriptFunction",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ0_1,
                                "move_core_types::abi::ScriptABI::ScriptFunction",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.path "move_core_types::abi::ScriptFunctionABI",
                                  [ Ty.path "move_core_types::abi::ScriptFunctionABI" ],
                                  "eq",
                                  []
                                |),
                                [ M.read (| __self_0 |); M.read (| __arg1_0 |) ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              M.never_to_any (|
                                M.call_closure (|
                                  M.get_function (| "core::intrinsics::unreachable", [] |),
                                  []
                                |)
                              |)
                            |)))
                      ]
                    |)
                  |)))
              |)
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_for_move_core_types_abi_ScriptABI.
  
  Module underscore.
    Module Impl_serde_ser_Serialize_for_move_core_types_abi_ScriptABI.
      Definition Self : Ty.t := Ty.path "move_core_types::abi::ScriptABI".
      
      (* Serialize *)
      Definition serialize (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ __S ], [ self; __serializer ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let __serializer := M.alloc (| __serializer |) in
            M.read (|
              M.match_operator (|
                M.read (| self |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.get_struct_tuple_field_or_break_match (|
                          γ,
                          "move_core_types::abi::ScriptABI::TransactionScript",
                          0
                        |) in
                      let __field0 := M.alloc (| γ0_0 |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "serde::ser::Serializer",
                            __S,
                            [],
                            "serialize_newtype_variant",
                            [ Ty.path "move_core_types::abi::TransactionScriptABI" ]
                          |),
                          [
                            M.read (| __serializer |);
                            M.read (| mk_str "ScriptABI" |);
                            Value.Integer Integer.U32 0;
                            M.read (| mk_str "TransactionScript" |);
                            M.read (| __field0 |)
                          ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.get_struct_tuple_field_or_break_match (|
                          γ,
                          "move_core_types::abi::ScriptABI::ScriptFunction",
                          0
                        |) in
                      let __field0 := M.alloc (| γ0_0 |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "serde::ser::Serializer",
                            __S,
                            [],
                            "serialize_newtype_variant",
                            [ Ty.path "move_core_types::abi::ScriptFunctionABI" ]
                          |),
                          [
                            M.read (| __serializer |);
                            M.read (| mk_str "ScriptABI" |);
                            Value.Integer Integer.U32 1;
                            M.read (| mk_str "ScriptFunction" |);
                            M.read (| __field0 |)
                          ]
                        |)
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "serde::ser::Serialize"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("serialize", InstanceField.Method serialize) ].
    End Impl_serde_ser_Serialize_for_move_core_types_abi_ScriptABI.
  End underscore.
  
  Module Wrap_underscore_2.
  Module underscore.
    Module Impl_serde_de_Deserialize_for_move_core_types_abi_ScriptABI.
      Definition Self : Ty.t := Ty.path "move_core_types::abi::ScriptABI".
      
      (* Deserialize *)
      Definition deserialize (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ __D ], [ __deserializer ] =>
          ltac:(M.monadic
            (let __deserializer := M.alloc (| __deserializer |) in
            M.call_closure (|
              M.get_trait_method (|
                "serde::de::Deserializer",
                __D,
                [],
                "deserialize_enum",
                [ Ty.path "move_core_types::abi::_'1::deserialize::__Visitor" ]
              |),
              [
                M.read (| __deserializer |);
                M.read (| mk_str "ScriptABI" |);
                M.read (|
                  M.get_constant (| "move_core_types::abi::_'1::deserialize::VARIANTS" |)
                |);
                Value.StructRecord
                  "move_core_types::abi::_'1::deserialize::__Visitor"
                  [
                    ("marker", Value.StructTuple "core::marker::PhantomData" []);
                    ("lifetime", Value.StructTuple "core::marker::PhantomData" [])
                  ]
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "serde::de::Deserialize"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("deserialize", InstanceField.Method deserialize) ].
    End Impl_serde_de_Deserialize_for_move_core_types_abi_ScriptABI.
  End underscore.
  End Wrap_underscore_2.
  Import Wrap_underscore_2.
  
  (* StructRecord
    {
      name := "ScriptFunctionABI";
      ty_params := [];
      fields :=
        [
          ("name", Ty.path "alloc::string::String");
          ("module_name", Ty.path "move_core_types::language_storage::ModuleId");
          ("doc", Ty.path "alloc::string::String");
          ("ty_args",
            Ty.apply
              (Ty.path "alloc::vec::Vec")
              [ Ty.path "move_core_types::abi::TypeArgumentABI"; Ty.path "alloc::alloc::Global" ]);
          ("args",
            Ty.apply
              (Ty.path "alloc::vec::Vec")
              [ Ty.path "move_core_types::abi::ArgumentABI"; Ty.path "alloc::alloc::Global" ])
        ];
    } *)
  
  Module Impl_core_clone_Clone_for_move_core_types_abi_ScriptFunctionABI.
    Definition Self : Ty.t := Ty.path "move_core_types::abi::ScriptFunctionABI".
    
    (* Clone *)
    Definition clone (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.StructRecord
            "move_core_types::abi::ScriptFunctionABI"
            [
              ("name",
                M.call_closure (|
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.path "alloc::string::String",
                    [],
                    "clone",
                    []
                  |),
                  [
                    M.get_struct_record_field
                      (M.read (| self |))
                      "move_core_types::abi::ScriptFunctionABI"
                      "name"
                  ]
                |));
              ("module_name",
                M.call_closure (|
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.path "move_core_types::language_storage::ModuleId",
                    [],
                    "clone",
                    []
                  |),
                  [
                    M.get_struct_record_field
                      (M.read (| self |))
                      "move_core_types::abi::ScriptFunctionABI"
                      "module_name"
                  ]
                |));
              ("doc",
                M.call_closure (|
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.path "alloc::string::String",
                    [],
                    "clone",
                    []
                  |),
                  [
                    M.get_struct_record_field
                      (M.read (| self |))
                      "move_core_types::abi::ScriptFunctionABI"
                      "doc"
                  ]
                |));
              ("ty_args",
                M.call_closure (|
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      [
                        Ty.path "move_core_types::abi::TypeArgumentABI";
                        Ty.path "alloc::alloc::Global"
                      ],
                    [],
                    "clone",
                    []
                  |),
                  [
                    M.get_struct_record_field
                      (M.read (| self |))
                      "move_core_types::abi::ScriptFunctionABI"
                      "ty_args"
                  ]
                |));
              ("args",
                M.call_closure (|
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      [ Ty.path "move_core_types::abi::ArgumentABI"; Ty.path "alloc::alloc::Global"
                      ],
                    [],
                    "clone",
                    []
                  |),
                  [
                    M.get_struct_record_field
                      (M.read (| self |))
                      "move_core_types::abi::ScriptFunctionABI"
                      "args"
                  ]
                |))
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_move_core_types_abi_ScriptFunctionABI.
  
  Module Impl_core_fmt_Debug_for_move_core_types_abi_ScriptFunctionABI.
    Definition Self : Ty.t := Ty.path "move_core_types::abi::ScriptFunctionABI".
    
    (* Debug *)
    Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.path "core::fmt::Formatter",
              "debug_struct_field5_finish",
              []
            |),
            [
              M.read (| f |);
              M.read (| mk_str "ScriptFunctionABI" |);
              M.read (| mk_str "name" |);
              (* Unsize *)
              M.pointer_coercion
                (M.get_struct_record_field
                  (M.read (| self |))
                  "move_core_types::abi::ScriptFunctionABI"
                  "name");
              M.read (| mk_str "module_name" |);
              (* Unsize *)
              M.pointer_coercion
                (M.get_struct_record_field
                  (M.read (| self |))
                  "move_core_types::abi::ScriptFunctionABI"
                  "module_name");
              M.read (| mk_str "doc" |);
              (* Unsize *)
              M.pointer_coercion
                (M.get_struct_record_field
                  (M.read (| self |))
                  "move_core_types::abi::ScriptFunctionABI"
                  "doc");
              M.read (| mk_str "ty_args" |);
              (* Unsize *)
              M.pointer_coercion
                (M.get_struct_record_field
                  (M.read (| self |))
                  "move_core_types::abi::ScriptFunctionABI"
                  "ty_args");
              M.read (| mk_str "args" |);
              (* Unsize *)
              M.pointer_coercion
                (M.alloc (|
                  M.get_struct_record_field
                    (M.read (| self |))
                    "move_core_types::abi::ScriptFunctionABI"
                    "args"
                |))
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_move_core_types_abi_ScriptFunctionABI.
  
  Module Impl_core_hash_Hash_for_move_core_types_abi_ScriptFunctionABI.
    Definition Self : Ty.t := Ty.path "move_core_types::abi::ScriptFunctionABI".
    
    (* Hash *)
    Definition hash (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ __H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let state := M.alloc (| state |) in
          M.read (|
            let _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "core::hash::Hash",
                    Ty.path "alloc::string::String",
                    [],
                    "hash",
                    [ __H ]
                  |),
                  [
                    M.get_struct_record_field
                      (M.read (| self |))
                      "move_core_types::abi::ScriptFunctionABI"
                      "name";
                    M.read (| state |)
                  ]
                |)
              |) in
            let _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "core::hash::Hash",
                    Ty.path "move_core_types::language_storage::ModuleId",
                    [],
                    "hash",
                    [ __H ]
                  |),
                  [
                    M.get_struct_record_field
                      (M.read (| self |))
                      "move_core_types::abi::ScriptFunctionABI"
                      "module_name";
                    M.read (| state |)
                  ]
                |)
              |) in
            let _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "core::hash::Hash",
                    Ty.path "alloc::string::String",
                    [],
                    "hash",
                    [ __H ]
                  |),
                  [
                    M.get_struct_record_field
                      (M.read (| self |))
                      "move_core_types::abi::ScriptFunctionABI"
                      "doc";
                    M.read (| state |)
                  ]
                |)
              |) in
            let _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "core::hash::Hash",
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      [
                        Ty.path "move_core_types::abi::TypeArgumentABI";
                        Ty.path "alloc::alloc::Global"
                      ],
                    [],
                    "hash",
                    [ __H ]
                  |),
                  [
                    M.get_struct_record_field
                      (M.read (| self |))
                      "move_core_types::abi::ScriptFunctionABI"
                      "ty_args";
                    M.read (| state |)
                  ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                M.get_trait_method (|
                  "core::hash::Hash",
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    [ Ty.path "move_core_types::abi::ArgumentABI"; Ty.path "alloc::alloc::Global" ],
                  [],
                  "hash",
                  [ __H ]
                |),
                [
                  M.get_struct_record_field
                    (M.read (| self |))
                    "move_core_types::abi::ScriptFunctionABI"
                    "args";
                  M.read (| state |)
                ]
              |)
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::hash::Hash"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("hash", InstanceField.Method hash) ].
  End Impl_core_hash_Hash_for_move_core_types_abi_ScriptFunctionABI.
  
  Module Impl_core_marker_StructuralEq_for_move_core_types_abi_ScriptFunctionABI.
    Definition Self : Ty.t := Ty.path "move_core_types::abi::ScriptFunctionABI".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralEq_for_move_core_types_abi_ScriptFunctionABI.
  
  Module Impl_core_cmp_Eq_for_move_core_types_abi_ScriptFunctionABI.
    Definition Self : Ty.t := Ty.path "move_core_types::abi::ScriptFunctionABI".
    
    (* Eq *)
    Definition assert_receiver_is_total_eq (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Value.DeclaredButUndefined,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      Value.DeclaredButUndefined,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              Value.DeclaredButUndefined,
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (M.match_operator (|
                                      Value.DeclaredButUndefined,
                                      [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                                    |)))
                              ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_move_core_types_abi_ScriptFunctionABI.
  
  Module Impl_core_marker_StructuralPartialEq_for_move_core_types_abi_ScriptFunctionABI.
    Definition Self : Ty.t := Ty.path "move_core_types::abi::ScriptFunctionABI".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_move_core_types_abi_ScriptFunctionABI.
  
  Module Impl_core_cmp_PartialEq_for_move_core_types_abi_ScriptFunctionABI.
    Definition Self : Ty.t := Ty.path "move_core_types::abi::ScriptFunctionABI".
    
    (* PartialEq *)
    Definition eq (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          LogicalOp.and (|
            LogicalOp.and (|
              LogicalOp.and (|
                LogicalOp.and (|
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::cmp::PartialEq",
                      Ty.path "alloc::string::String",
                      [ Ty.path "alloc::string::String" ],
                      "eq",
                      []
                    |),
                    [
                      M.get_struct_record_field
                        (M.read (| self |))
                        "move_core_types::abi::ScriptFunctionABI"
                        "name";
                      M.get_struct_record_field
                        (M.read (| other |))
                        "move_core_types::abi::ScriptFunctionABI"
                        "name"
                    ]
                  |),
                  ltac:(M.monadic
                    (M.call_closure (|
                      M.get_trait_method (|
                        "core::cmp::PartialEq",
                        Ty.path "move_core_types::language_storage::ModuleId",
                        [ Ty.path "move_core_types::language_storage::ModuleId" ],
                        "eq",
                        []
                      |),
                      [
                        M.get_struct_record_field
                          (M.read (| self |))
                          "move_core_types::abi::ScriptFunctionABI"
                          "module_name";
                        M.get_struct_record_field
                          (M.read (| other |))
                          "move_core_types::abi::ScriptFunctionABI"
                          "module_name"
                      ]
                    |)))
                |),
                ltac:(M.monadic
                  (M.call_closure (|
                    M.get_trait_method (|
                      "core::cmp::PartialEq",
                      Ty.path "alloc::string::String",
                      [ Ty.path "alloc::string::String" ],
                      "eq",
                      []
                    |),
                    [
                      M.get_struct_record_field
                        (M.read (| self |))
                        "move_core_types::abi::ScriptFunctionABI"
                        "doc";
                      M.get_struct_record_field
                        (M.read (| other |))
                        "move_core_types::abi::ScriptFunctionABI"
                        "doc"
                    ]
                  |)))
              |),
              ltac:(M.monadic
                (M.call_closure (|
                  M.get_trait_method (|
                    "core::cmp::PartialEq",
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      [
                        Ty.path "move_core_types::abi::TypeArgumentABI";
                        Ty.path "alloc::alloc::Global"
                      ],
                    [
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        [
                          Ty.path "move_core_types::abi::TypeArgumentABI";
                          Ty.path "alloc::alloc::Global"
                        ]
                    ],
                    "eq",
                    []
                  |),
                  [
                    M.get_struct_record_field
                      (M.read (| self |))
                      "move_core_types::abi::ScriptFunctionABI"
                      "ty_args";
                    M.get_struct_record_field
                      (M.read (| other |))
                      "move_core_types::abi::ScriptFunctionABI"
                      "ty_args"
                  ]
                |)))
            |),
            ltac:(M.monadic
              (M.call_closure (|
                M.get_trait_method (|
                  "core::cmp::PartialEq",
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    [ Ty.path "move_core_types::abi::ArgumentABI"; Ty.path "alloc::alloc::Global" ],
                  [
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      [ Ty.path "move_core_types::abi::ArgumentABI"; Ty.path "alloc::alloc::Global"
                      ]
                  ],
                  "eq",
                  []
                |),
                [
                  M.get_struct_record_field
                    (M.read (| self |))
                    "move_core_types::abi::ScriptFunctionABI"
                    "args";
                  M.get_struct_record_field
                    (M.read (| other |))
                    "move_core_types::abi::ScriptFunctionABI"
                    "args"
                ]
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_for_move_core_types_abi_ScriptFunctionABI.
  
  Module Wrap_underscore_3.
  Module underscore.
    Module Impl_serde_ser_Serialize_for_move_core_types_abi_ScriptFunctionABI.
      Definition Self : Ty.t := Ty.path "move_core_types::abi::ScriptFunctionABI".
      
      (* Serialize *)
      Definition serialize (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ __S ], [ self; __serializer ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let __serializer := M.alloc (| __serializer |) in
            M.read (|
              let __serde_state :=
                M.copy (|
                  M.match_operator (|
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "serde::ser::Serializer",
                          __S,
                          [],
                          "serialize_struct",
                          []
                        |),
                        [
                          M.read (| __serializer |);
                          M.read (| mk_str "ScriptFunctionABI" |);
                          BinOp.Panic.add (|
                            BinOp.Panic.add (|
                              BinOp.Panic.add (|
                                BinOp.Panic.add (|
                                  BinOp.Panic.add (|
                                    M.rust_cast (Value.Bool false),
                                    Value.Integer Integer.Usize 1
                                  |),
                                  Value.Integer Integer.Usize 1
                                |),
                                Value.Integer Integer.Usize 1
                              |),
                              Value.Integer Integer.Usize 1
                            |),
                            Value.Integer Integer.Usize 1
                          |)
                        ]
                      |)
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.get_struct_tuple_field_or_break_match (|
                              γ,
                              "core::result::Result::Ok",
                              0
                            |) in
                          let __val := M.copy (| γ0_0 |) in
                          __val));
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.get_struct_tuple_field_or_break_match (|
                              γ,
                              "core::result::Result::Err",
                              0
                            |) in
                          let __err := M.copy (| γ0_0 |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  Value.StructTuple
                                    "core::result::Result::Err"
                                    [ M.read (| __err |) ]
                                |)
                              |)
                            |)
                          |)))
                    ]
                  |)
                |) in
              let _ :=
                M.match_operator (|
                  M.alloc (|
                    M.call_closure (|
                      M.get_trait_method (|
                        "serde::ser::SerializeStruct",
                        Ty.associated,
                        [],
                        "serialize_field",
                        [ Ty.path "alloc::string::String" ]
                      |),
                      [
                        __serde_state;
                        M.read (| mk_str "name" |);
                        M.get_struct_record_field
                          (M.read (| self |))
                          "move_core_types::abi::ScriptFunctionABI"
                          "name"
                      ]
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.get_struct_tuple_field_or_break_match (|
                            γ,
                            "core::result::Result::Ok",
                            0
                          |) in
                        let __val := M.copy (| γ0_0 |) in
                        __val));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.get_struct_tuple_field_or_break_match (|
                            γ,
                            "core::result::Result::Err",
                            0
                          |) in
                        let __err := M.copy (| γ0_0 |) in
                        M.alloc (|
                          M.never_to_any (|
                            M.read (|
                              M.return_ (|
                                Value.StructTuple "core::result::Result::Err" [ M.read (| __err |) ]
                              |)
                            |)
                          |)
                        |)))
                  ]
                |) in
              let _ :=
                M.match_operator (|
                  M.alloc (|
                    M.call_closure (|
                      M.get_trait_method (|
                        "serde::ser::SerializeStruct",
                        Ty.associated,
                        [],
                        "serialize_field",
                        [ Ty.path "move_core_types::language_storage::ModuleId" ]
                      |),
                      [
                        __serde_state;
                        M.read (| mk_str "module_name" |);
                        M.get_struct_record_field
                          (M.read (| self |))
                          "move_core_types::abi::ScriptFunctionABI"
                          "module_name"
                      ]
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.get_struct_tuple_field_or_break_match (|
                            γ,
                            "core::result::Result::Ok",
                            0
                          |) in
                        let __val := M.copy (| γ0_0 |) in
                        __val));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.get_struct_tuple_field_or_break_match (|
                            γ,
                            "core::result::Result::Err",
                            0
                          |) in
                        let __err := M.copy (| γ0_0 |) in
                        M.alloc (|
                          M.never_to_any (|
                            M.read (|
                              M.return_ (|
                                Value.StructTuple "core::result::Result::Err" [ M.read (| __err |) ]
                              |)
                            |)
                          |)
                        |)))
                  ]
                |) in
              let _ :=
                M.match_operator (|
                  M.alloc (|
                    M.call_closure (|
                      M.get_trait_method (|
                        "serde::ser::SerializeStruct",
                        Ty.associated,
                        [],
                        "serialize_field",
                        [ Ty.path "alloc::string::String" ]
                      |),
                      [
                        __serde_state;
                        M.read (| mk_str "doc" |);
                        M.get_struct_record_field
                          (M.read (| self |))
                          "move_core_types::abi::ScriptFunctionABI"
                          "doc"
                      ]
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.get_struct_tuple_field_or_break_match (|
                            γ,
                            "core::result::Result::Ok",
                            0
                          |) in
                        let __val := M.copy (| γ0_0 |) in
                        __val));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.get_struct_tuple_field_or_break_match (|
                            γ,
                            "core::result::Result::Err",
                            0
                          |) in
                        let __err := M.copy (| γ0_0 |) in
                        M.alloc (|
                          M.never_to_any (|
                            M.read (|
                              M.return_ (|
                                Value.StructTuple "core::result::Result::Err" [ M.read (| __err |) ]
                              |)
                            |)
                          |)
                        |)))
                  ]
                |) in
              let _ :=
                M.match_operator (|
                  M.alloc (|
                    M.call_closure (|
                      M.get_trait_method (|
                        "serde::ser::SerializeStruct",
                        Ty.associated,
                        [],
                        "serialize_field",
                        [
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            [
                              Ty.path "move_core_types::abi::TypeArgumentABI";
                              Ty.path "alloc::alloc::Global"
                            ]
                        ]
                      |),
                      [
                        __serde_state;
                        M.read (| mk_str "ty_args" |);
                        M.get_struct_record_field
                          (M.read (| self |))
                          "move_core_types::abi::ScriptFunctionABI"
                          "ty_args"
                      ]
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.get_struct_tuple_field_or_break_match (|
                            γ,
                            "core::result::Result::Ok",
                            0
                          |) in
                        let __val := M.copy (| γ0_0 |) in
                        __val));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.get_struct_tuple_field_or_break_match (|
                            γ,
                            "core::result::Result::Err",
                            0
                          |) in
                        let __err := M.copy (| γ0_0 |) in
                        M.alloc (|
                          M.never_to_any (|
                            M.read (|
                              M.return_ (|
                                Value.StructTuple "core::result::Result::Err" [ M.read (| __err |) ]
                              |)
                            |)
                          |)
                        |)))
                  ]
                |) in
              let _ :=
                M.match_operator (|
                  M.alloc (|
                    M.call_closure (|
                      M.get_trait_method (|
                        "serde::ser::SerializeStruct",
                        Ty.associated,
                        [],
                        "serialize_field",
                        [
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            [
                              Ty.path "move_core_types::abi::ArgumentABI";
                              Ty.path "alloc::alloc::Global"
                            ]
                        ]
                      |),
                      [
                        __serde_state;
                        M.read (| mk_str "args" |);
                        M.get_struct_record_field
                          (M.read (| self |))
                          "move_core_types::abi::ScriptFunctionABI"
                          "args"
                      ]
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.get_struct_tuple_field_or_break_match (|
                            γ,
                            "core::result::Result::Ok",
                            0
                          |) in
                        let __val := M.copy (| γ0_0 |) in
                        __val));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.get_struct_tuple_field_or_break_match (|
                            γ,
                            "core::result::Result::Err",
                            0
                          |) in
                        let __err := M.copy (| γ0_0 |) in
                        M.alloc (|
                          M.never_to_any (|
                            M.read (|
                              M.return_ (|
                                Value.StructTuple "core::result::Result::Err" [ M.read (| __err |) ]
                              |)
                            |)
                          |)
                        |)))
                  ]
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "serde::ser::SerializeStruct",
                    Ty.associated,
                    [],
                    "end",
                    []
                  |),
                  [ M.read (| __serde_state |) ]
                |)
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "serde::ser::Serialize"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("serialize", InstanceField.Method serialize) ].
    End Impl_serde_ser_Serialize_for_move_core_types_abi_ScriptFunctionABI.
  End underscore.
  End Wrap_underscore_3.
  Import Wrap_underscore_3.
  
  Module Wrap_underscore_4.
  Module underscore.
    Module Impl_serde_de_Deserialize_for_move_core_types_abi_ScriptFunctionABI.
      Definition Self : Ty.t := Ty.path "move_core_types::abi::ScriptFunctionABI".
      
      (* Deserialize *)
      Definition deserialize (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ __D ], [ __deserializer ] =>
          ltac:(M.monadic
            (let __deserializer := M.alloc (| __deserializer |) in
            M.call_closure (|
              M.get_trait_method (|
                "serde::de::Deserializer",
                __D,
                [],
                "deserialize_struct",
                [ Ty.path "move_core_types::abi::_'3::deserialize::__Visitor" ]
              |),
              [
                M.read (| __deserializer |);
                M.read (| mk_str "ScriptFunctionABI" |);
                M.read (| M.get_constant (| "move_core_types::abi::_'3::deserialize::FIELDS" |) |);
                Value.StructRecord
                  "move_core_types::abi::_'3::deserialize::__Visitor"
                  [
                    ("marker", Value.StructTuple "core::marker::PhantomData" []);
                    ("lifetime", Value.StructTuple "core::marker::PhantomData" [])
                  ]
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "serde::de::Deserialize"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("deserialize", InstanceField.Method deserialize) ].
    End Impl_serde_de_Deserialize_for_move_core_types_abi_ScriptFunctionABI.
  End underscore.
  End Wrap_underscore_4.
  Import Wrap_underscore_4.
  
  (* StructRecord
    {
      name := "TransactionScriptABI";
      ty_params := [];
      fields :=
        [
          ("name", Ty.path "alloc::string::String");
          ("doc", Ty.path "alloc::string::String");
          ("code",
            Ty.apply (Ty.path "alloc::vec::Vec") [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]);
          ("ty_args",
            Ty.apply
              (Ty.path "alloc::vec::Vec")
              [ Ty.path "move_core_types::abi::TypeArgumentABI"; Ty.path "alloc::alloc::Global" ]);
          ("args",
            Ty.apply
              (Ty.path "alloc::vec::Vec")
              [ Ty.path "move_core_types::abi::ArgumentABI"; Ty.path "alloc::alloc::Global" ])
        ];
    } *)
  
  Module Impl_core_clone_Clone_for_move_core_types_abi_TransactionScriptABI.
    Definition Self : Ty.t := Ty.path "move_core_types::abi::TransactionScriptABI".
    
    (* Clone *)
    Definition clone (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.StructRecord
            "move_core_types::abi::TransactionScriptABI"
            [
              ("name",
                M.call_closure (|
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.path "alloc::string::String",
                    [],
                    "clone",
                    []
                  |),
                  [
                    M.get_struct_record_field
                      (M.read (| self |))
                      "move_core_types::abi::TransactionScriptABI"
                      "name"
                  ]
                |));
              ("doc",
                M.call_closure (|
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.path "alloc::string::String",
                    [],
                    "clone",
                    []
                  |),
                  [
                    M.get_struct_record_field
                      (M.read (| self |))
                      "move_core_types::abi::TransactionScriptABI"
                      "doc"
                  ]
                |));
              ("code",
                M.call_closure (|
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                    [],
                    "clone",
                    []
                  |),
                  [
                    M.get_struct_record_field
                      (M.read (| self |))
                      "move_core_types::abi::TransactionScriptABI"
                      "code"
                  ]
                |));
              ("ty_args",
                M.call_closure (|
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      [
                        Ty.path "move_core_types::abi::TypeArgumentABI";
                        Ty.path "alloc::alloc::Global"
                      ],
                    [],
                    "clone",
                    []
                  |),
                  [
                    M.get_struct_record_field
                      (M.read (| self |))
                      "move_core_types::abi::TransactionScriptABI"
                      "ty_args"
                  ]
                |));
              ("args",
                M.call_closure (|
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      [ Ty.path "move_core_types::abi::ArgumentABI"; Ty.path "alloc::alloc::Global"
                      ],
                    [],
                    "clone",
                    []
                  |),
                  [
                    M.get_struct_record_field
                      (M.read (| self |))
                      "move_core_types::abi::TransactionScriptABI"
                      "args"
                  ]
                |))
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_move_core_types_abi_TransactionScriptABI.
  
  Module Impl_core_fmt_Debug_for_move_core_types_abi_TransactionScriptABI.
    Definition Self : Ty.t := Ty.path "move_core_types::abi::TransactionScriptABI".
    
    (* Debug *)
    Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.path "core::fmt::Formatter",
              "debug_struct_field5_finish",
              []
            |),
            [
              M.read (| f |);
              M.read (| mk_str "TransactionScriptABI" |);
              M.read (| mk_str "name" |);
              (* Unsize *)
              M.pointer_coercion
                (M.get_struct_record_field
                  (M.read (| self |))
                  "move_core_types::abi::TransactionScriptABI"
                  "name");
              M.read (| mk_str "doc" |);
              (* Unsize *)
              M.pointer_coercion
                (M.get_struct_record_field
                  (M.read (| self |))
                  "move_core_types::abi::TransactionScriptABI"
                  "doc");
              M.read (| mk_str "code" |);
              (* Unsize *)
              M.pointer_coercion
                (M.get_struct_record_field
                  (M.read (| self |))
                  "move_core_types::abi::TransactionScriptABI"
                  "code");
              M.read (| mk_str "ty_args" |);
              (* Unsize *)
              M.pointer_coercion
                (M.get_struct_record_field
                  (M.read (| self |))
                  "move_core_types::abi::TransactionScriptABI"
                  "ty_args");
              M.read (| mk_str "args" |);
              (* Unsize *)
              M.pointer_coercion
                (M.alloc (|
                  M.get_struct_record_field
                    (M.read (| self |))
                    "move_core_types::abi::TransactionScriptABI"
                    "args"
                |))
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_move_core_types_abi_TransactionScriptABI.
  
  Module Impl_core_hash_Hash_for_move_core_types_abi_TransactionScriptABI.
    Definition Self : Ty.t := Ty.path "move_core_types::abi::TransactionScriptABI".
    
    (* Hash *)
    Definition hash (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ __H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let state := M.alloc (| state |) in
          M.read (|
            let _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "core::hash::Hash",
                    Ty.path "alloc::string::String",
                    [],
                    "hash",
                    [ __H ]
                  |),
                  [
                    M.get_struct_record_field
                      (M.read (| self |))
                      "move_core_types::abi::TransactionScriptABI"
                      "name";
                    M.read (| state |)
                  ]
                |)
              |) in
            let _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "core::hash::Hash",
                    Ty.path "alloc::string::String",
                    [],
                    "hash",
                    [ __H ]
                  |),
                  [
                    M.get_struct_record_field
                      (M.read (| self |))
                      "move_core_types::abi::TransactionScriptABI"
                      "doc";
                    M.read (| state |)
                  ]
                |)
              |) in
            let _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "core::hash::Hash",
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                    [],
                    "hash",
                    [ __H ]
                  |),
                  [
                    M.get_struct_record_field
                      (M.read (| self |))
                      "move_core_types::abi::TransactionScriptABI"
                      "code";
                    M.read (| state |)
                  ]
                |)
              |) in
            let _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "core::hash::Hash",
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      [
                        Ty.path "move_core_types::abi::TypeArgumentABI";
                        Ty.path "alloc::alloc::Global"
                      ],
                    [],
                    "hash",
                    [ __H ]
                  |),
                  [
                    M.get_struct_record_field
                      (M.read (| self |))
                      "move_core_types::abi::TransactionScriptABI"
                      "ty_args";
                    M.read (| state |)
                  ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                M.get_trait_method (|
                  "core::hash::Hash",
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    [ Ty.path "move_core_types::abi::ArgumentABI"; Ty.path "alloc::alloc::Global" ],
                  [],
                  "hash",
                  [ __H ]
                |),
                [
                  M.get_struct_record_field
                    (M.read (| self |))
                    "move_core_types::abi::TransactionScriptABI"
                    "args";
                  M.read (| state |)
                ]
              |)
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::hash::Hash"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("hash", InstanceField.Method hash) ].
  End Impl_core_hash_Hash_for_move_core_types_abi_TransactionScriptABI.
  
  Module Impl_core_marker_StructuralEq_for_move_core_types_abi_TransactionScriptABI.
    Definition Self : Ty.t := Ty.path "move_core_types::abi::TransactionScriptABI".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralEq_for_move_core_types_abi_TransactionScriptABI.
  
  Module Impl_core_cmp_Eq_for_move_core_types_abi_TransactionScriptABI.
    Definition Self : Ty.t := Ty.path "move_core_types::abi::TransactionScriptABI".
    
    (* Eq *)
    Definition assert_receiver_is_total_eq (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Value.DeclaredButUndefined,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      Value.DeclaredButUndefined,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              Value.DeclaredButUndefined,
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (M.match_operator (|
                                      Value.DeclaredButUndefined,
                                      [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                                    |)))
                              ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_move_core_types_abi_TransactionScriptABI.
  
  Module Impl_core_marker_StructuralPartialEq_for_move_core_types_abi_TransactionScriptABI.
    Definition Self : Ty.t := Ty.path "move_core_types::abi::TransactionScriptABI".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_move_core_types_abi_TransactionScriptABI.
  
  Module Impl_core_cmp_PartialEq_for_move_core_types_abi_TransactionScriptABI.
    Definition Self : Ty.t := Ty.path "move_core_types::abi::TransactionScriptABI".
    
    (* PartialEq *)
    Definition eq (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          LogicalOp.and (|
            LogicalOp.and (|
              LogicalOp.and (|
                LogicalOp.and (|
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::cmp::PartialEq",
                      Ty.path "alloc::string::String",
                      [ Ty.path "alloc::string::String" ],
                      "eq",
                      []
                    |),
                    [
                      M.get_struct_record_field
                        (M.read (| self |))
                        "move_core_types::abi::TransactionScriptABI"
                        "name";
                      M.get_struct_record_field
                        (M.read (| other |))
                        "move_core_types::abi::TransactionScriptABI"
                        "name"
                    ]
                  |),
                  ltac:(M.monadic
                    (M.call_closure (|
                      M.get_trait_method (|
                        "core::cmp::PartialEq",
                        Ty.path "alloc::string::String",
                        [ Ty.path "alloc::string::String" ],
                        "eq",
                        []
                      |),
                      [
                        M.get_struct_record_field
                          (M.read (| self |))
                          "move_core_types::abi::TransactionScriptABI"
                          "doc";
                        M.get_struct_record_field
                          (M.read (| other |))
                          "move_core_types::abi::TransactionScriptABI"
                          "doc"
                      ]
                    |)))
                |),
                ltac:(M.monadic
                  (M.call_closure (|
                    M.get_trait_method (|
                      "core::cmp::PartialEq",
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                      [
                        Ty.apply
                          (Ty.path "alloc::vec::Vec")
                          [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                      ],
                      "eq",
                      []
                    |),
                    [
                      M.get_struct_record_field
                        (M.read (| self |))
                        "move_core_types::abi::TransactionScriptABI"
                        "code";
                      M.get_struct_record_field
                        (M.read (| other |))
                        "move_core_types::abi::TransactionScriptABI"
                        "code"
                    ]
                  |)))
              |),
              ltac:(M.monadic
                (M.call_closure (|
                  M.get_trait_method (|
                    "core::cmp::PartialEq",
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      [
                        Ty.path "move_core_types::abi::TypeArgumentABI";
                        Ty.path "alloc::alloc::Global"
                      ],
                    [
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        [
                          Ty.path "move_core_types::abi::TypeArgumentABI";
                          Ty.path "alloc::alloc::Global"
                        ]
                    ],
                    "eq",
                    []
                  |),
                  [
                    M.get_struct_record_field
                      (M.read (| self |))
                      "move_core_types::abi::TransactionScriptABI"
                      "ty_args";
                    M.get_struct_record_field
                      (M.read (| other |))
                      "move_core_types::abi::TransactionScriptABI"
                      "ty_args"
                  ]
                |)))
            |),
            ltac:(M.monadic
              (M.call_closure (|
                M.get_trait_method (|
                  "core::cmp::PartialEq",
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    [ Ty.path "move_core_types::abi::ArgumentABI"; Ty.path "alloc::alloc::Global" ],
                  [
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      [ Ty.path "move_core_types::abi::ArgumentABI"; Ty.path "alloc::alloc::Global"
                      ]
                  ],
                  "eq",
                  []
                |),
                [
                  M.get_struct_record_field
                    (M.read (| self |))
                    "move_core_types::abi::TransactionScriptABI"
                    "args";
                  M.get_struct_record_field
                    (M.read (| other |))
                    "move_core_types::abi::TransactionScriptABI"
                    "args"
                ]
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_for_move_core_types_abi_TransactionScriptABI.
  
  Module Wrap_underscore_5.
  Module underscore.
    Module Impl_serde_ser_Serialize_for_move_core_types_abi_TransactionScriptABI.
      Definition Self : Ty.t := Ty.path "move_core_types::abi::TransactionScriptABI".
      
      (* Serialize *)
      Definition serialize (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ __S ], [ self; __serializer ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let __serializer := M.alloc (| __serializer |) in
            M.read (|
              let __serde_state :=
                M.copy (|
                  M.match_operator (|
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "serde::ser::Serializer",
                          __S,
                          [],
                          "serialize_struct",
                          []
                        |),
                        [
                          M.read (| __serializer |);
                          M.read (| mk_str "TransactionScriptABI" |);
                          BinOp.Panic.add (|
                            BinOp.Panic.add (|
                              BinOp.Panic.add (|
                                BinOp.Panic.add (|
                                  BinOp.Panic.add (|
                                    M.rust_cast (Value.Bool false),
                                    Value.Integer Integer.Usize 1
                                  |),
                                  Value.Integer Integer.Usize 1
                                |),
                                Value.Integer Integer.Usize 1
                              |),
                              Value.Integer Integer.Usize 1
                            |),
                            Value.Integer Integer.Usize 1
                          |)
                        ]
                      |)
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.get_struct_tuple_field_or_break_match (|
                              γ,
                              "core::result::Result::Ok",
                              0
                            |) in
                          let __val := M.copy (| γ0_0 |) in
                          __val));
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.get_struct_tuple_field_or_break_match (|
                              γ,
                              "core::result::Result::Err",
                              0
                            |) in
                          let __err := M.copy (| γ0_0 |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  Value.StructTuple
                                    "core::result::Result::Err"
                                    [ M.read (| __err |) ]
                                |)
                              |)
                            |)
                          |)))
                    ]
                  |)
                |) in
              let _ :=
                M.match_operator (|
                  M.alloc (|
                    M.call_closure (|
                      M.get_trait_method (|
                        "serde::ser::SerializeStruct",
                        Ty.associated,
                        [],
                        "serialize_field",
                        [ Ty.path "alloc::string::String" ]
                      |),
                      [
                        __serde_state;
                        M.read (| mk_str "name" |);
                        M.get_struct_record_field
                          (M.read (| self |))
                          "move_core_types::abi::TransactionScriptABI"
                          "name"
                      ]
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.get_struct_tuple_field_or_break_match (|
                            γ,
                            "core::result::Result::Ok",
                            0
                          |) in
                        let __val := M.copy (| γ0_0 |) in
                        __val));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.get_struct_tuple_field_or_break_match (|
                            γ,
                            "core::result::Result::Err",
                            0
                          |) in
                        let __err := M.copy (| γ0_0 |) in
                        M.alloc (|
                          M.never_to_any (|
                            M.read (|
                              M.return_ (|
                                Value.StructTuple "core::result::Result::Err" [ M.read (| __err |) ]
                              |)
                            |)
                          |)
                        |)))
                  ]
                |) in
              let _ :=
                M.match_operator (|
                  M.alloc (|
                    M.call_closure (|
                      M.get_trait_method (|
                        "serde::ser::SerializeStruct",
                        Ty.associated,
                        [],
                        "serialize_field",
                        [ Ty.path "alloc::string::String" ]
                      |),
                      [
                        __serde_state;
                        M.read (| mk_str "doc" |);
                        M.get_struct_record_field
                          (M.read (| self |))
                          "move_core_types::abi::TransactionScriptABI"
                          "doc"
                      ]
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.get_struct_tuple_field_or_break_match (|
                            γ,
                            "core::result::Result::Ok",
                            0
                          |) in
                        let __val := M.copy (| γ0_0 |) in
                        __val));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.get_struct_tuple_field_or_break_match (|
                            γ,
                            "core::result::Result::Err",
                            0
                          |) in
                        let __err := M.copy (| γ0_0 |) in
                        M.alloc (|
                          M.never_to_any (|
                            M.read (|
                              M.return_ (|
                                Value.StructTuple "core::result::Result::Err" [ M.read (| __err |) ]
                              |)
                            |)
                          |)
                        |)))
                  ]
                |) in
              let _ :=
                M.match_operator (|
                  M.alloc (|
                    M.call_closure (|
                      M.get_trait_method (|
                        "serde::ser::SerializeStruct",
                        Ty.associated,
                        [],
                        "serialize_field",
                        [ Ty.path "move_core_types::abi::_'4::serialize::__SerializeWith" ]
                      |),
                      [
                        __serde_state;
                        M.read (| mk_str "code" |);
                        M.alloc (|
                          Value.StructRecord
                            "move_core_types::abi::_'4::serialize::__SerializeWith"
                            [
                              ("values",
                                Value.Tuple
                                  [
                                    M.get_struct_record_field
                                      (M.read (| self |))
                                      "move_core_types::abi::TransactionScriptABI"
                                      "code"
                                  ]);
                              ("phantom", Value.StructTuple "core::marker::PhantomData" [])
                            ]
                        |)
                      ]
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.get_struct_tuple_field_or_break_match (|
                            γ,
                            "core::result::Result::Ok",
                            0
                          |) in
                        let __val := M.copy (| γ0_0 |) in
                        __val));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.get_struct_tuple_field_or_break_match (|
                            γ,
                            "core::result::Result::Err",
                            0
                          |) in
                        let __err := M.copy (| γ0_0 |) in
                        M.alloc (|
                          M.never_to_any (|
                            M.read (|
                              M.return_ (|
                                Value.StructTuple "core::result::Result::Err" [ M.read (| __err |) ]
                              |)
                            |)
                          |)
                        |)))
                  ]
                |) in
              let _ :=
                M.match_operator (|
                  M.alloc (|
                    M.call_closure (|
                      M.get_trait_method (|
                        "serde::ser::SerializeStruct",
                        Ty.associated,
                        [],
                        "serialize_field",
                        [
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            [
                              Ty.path "move_core_types::abi::TypeArgumentABI";
                              Ty.path "alloc::alloc::Global"
                            ]
                        ]
                      |),
                      [
                        __serde_state;
                        M.read (| mk_str "ty_args" |);
                        M.get_struct_record_field
                          (M.read (| self |))
                          "move_core_types::abi::TransactionScriptABI"
                          "ty_args"
                      ]
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.get_struct_tuple_field_or_break_match (|
                            γ,
                            "core::result::Result::Ok",
                            0
                          |) in
                        let __val := M.copy (| γ0_0 |) in
                        __val));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.get_struct_tuple_field_or_break_match (|
                            γ,
                            "core::result::Result::Err",
                            0
                          |) in
                        let __err := M.copy (| γ0_0 |) in
                        M.alloc (|
                          M.never_to_any (|
                            M.read (|
                              M.return_ (|
                                Value.StructTuple "core::result::Result::Err" [ M.read (| __err |) ]
                              |)
                            |)
                          |)
                        |)))
                  ]
                |) in
              let _ :=
                M.match_operator (|
                  M.alloc (|
                    M.call_closure (|
                      M.get_trait_method (|
                        "serde::ser::SerializeStruct",
                        Ty.associated,
                        [],
                        "serialize_field",
                        [
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            [
                              Ty.path "move_core_types::abi::ArgumentABI";
                              Ty.path "alloc::alloc::Global"
                            ]
                        ]
                      |),
                      [
                        __serde_state;
                        M.read (| mk_str "args" |);
                        M.get_struct_record_field
                          (M.read (| self |))
                          "move_core_types::abi::TransactionScriptABI"
                          "args"
                      ]
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.get_struct_tuple_field_or_break_match (|
                            γ,
                            "core::result::Result::Ok",
                            0
                          |) in
                        let __val := M.copy (| γ0_0 |) in
                        __val));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.get_struct_tuple_field_or_break_match (|
                            γ,
                            "core::result::Result::Err",
                            0
                          |) in
                        let __err := M.copy (| γ0_0 |) in
                        M.alloc (|
                          M.never_to_any (|
                            M.read (|
                              M.return_ (|
                                Value.StructTuple "core::result::Result::Err" [ M.read (| __err |) ]
                              |)
                            |)
                          |)
                        |)))
                  ]
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "serde::ser::SerializeStruct",
                    Ty.associated,
                    [],
                    "end",
                    []
                  |),
                  [ M.read (| __serde_state |) ]
                |)
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "serde::ser::Serialize"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("serialize", InstanceField.Method serialize) ].
    End Impl_serde_ser_Serialize_for_move_core_types_abi_TransactionScriptABI.
  End underscore.
  End Wrap_underscore_5.
  Import Wrap_underscore_5.
  
  Module Wrap_underscore_6.
  Module underscore.
    Module Impl_serde_de_Deserialize_for_move_core_types_abi_TransactionScriptABI.
      Definition Self : Ty.t := Ty.path "move_core_types::abi::TransactionScriptABI".
      
      (* Deserialize *)
      Definition deserialize (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ __D ], [ __deserializer ] =>
          ltac:(M.monadic
            (let __deserializer := M.alloc (| __deserializer |) in
            M.call_closure (|
              M.get_trait_method (|
                "serde::de::Deserializer",
                __D,
                [],
                "deserialize_struct",
                [ Ty.path "move_core_types::abi::_'5::deserialize::__Visitor" ]
              |),
              [
                M.read (| __deserializer |);
                M.read (| mk_str "TransactionScriptABI" |);
                M.read (| M.get_constant (| "move_core_types::abi::_'5::deserialize::FIELDS" |) |);
                Value.StructRecord
                  "move_core_types::abi::_'5::deserialize::__Visitor"
                  [
                    ("marker", Value.StructTuple "core::marker::PhantomData" []);
                    ("lifetime", Value.StructTuple "core::marker::PhantomData" [])
                  ]
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "serde::de::Deserialize"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("deserialize", InstanceField.Method deserialize) ].
    End Impl_serde_de_Deserialize_for_move_core_types_abi_TransactionScriptABI.
  End underscore.
  End Wrap_underscore_6.
  Import Wrap_underscore_6.
  
  (* StructRecord
    {
      name := "ArgumentABI";
      ty_params := [];
      fields :=
        [
          ("name", Ty.path "alloc::string::String");
          ("type_tag", Ty.path "move_core_types::language_storage::TypeTag")
        ];
    } *)
  
  Module Impl_core_clone_Clone_for_move_core_types_abi_ArgumentABI.
    Definition Self : Ty.t := Ty.path "move_core_types::abi::ArgumentABI".
    
    (* Clone *)
    Definition clone (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.StructRecord
            "move_core_types::abi::ArgumentABI"
            [
              ("name",
                M.call_closure (|
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.path "alloc::string::String",
                    [],
                    "clone",
                    []
                  |),
                  [
                    M.get_struct_record_field
                      (M.read (| self |))
                      "move_core_types::abi::ArgumentABI"
                      "name"
                  ]
                |));
              ("type_tag",
                M.call_closure (|
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.path "move_core_types::language_storage::TypeTag",
                    [],
                    "clone",
                    []
                  |),
                  [
                    M.get_struct_record_field
                      (M.read (| self |))
                      "move_core_types::abi::ArgumentABI"
                      "type_tag"
                  ]
                |))
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_move_core_types_abi_ArgumentABI.
  
  Module Impl_core_fmt_Debug_for_move_core_types_abi_ArgumentABI.
    Definition Self : Ty.t := Ty.path "move_core_types::abi::ArgumentABI".
    
    (* Debug *)
    Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.path "core::fmt::Formatter",
              "debug_struct_field2_finish",
              []
            |),
            [
              M.read (| f |);
              M.read (| mk_str "ArgumentABI" |);
              M.read (| mk_str "name" |);
              (* Unsize *)
              M.pointer_coercion
                (M.get_struct_record_field
                  (M.read (| self |))
                  "move_core_types::abi::ArgumentABI"
                  "name");
              M.read (| mk_str "type_tag" |);
              (* Unsize *)
              M.pointer_coercion
                (M.alloc (|
                  M.get_struct_record_field
                    (M.read (| self |))
                    "move_core_types::abi::ArgumentABI"
                    "type_tag"
                |))
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_move_core_types_abi_ArgumentABI.
  
  Module Impl_core_hash_Hash_for_move_core_types_abi_ArgumentABI.
    Definition Self : Ty.t := Ty.path "move_core_types::abi::ArgumentABI".
    
    (* Hash *)
    Definition hash (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ __H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let state := M.alloc (| state |) in
          M.read (|
            let _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "core::hash::Hash",
                    Ty.path "alloc::string::String",
                    [],
                    "hash",
                    [ __H ]
                  |),
                  [
                    M.get_struct_record_field
                      (M.read (| self |))
                      "move_core_types::abi::ArgumentABI"
                      "name";
                    M.read (| state |)
                  ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                M.get_trait_method (|
                  "core::hash::Hash",
                  Ty.path "move_core_types::language_storage::TypeTag",
                  [],
                  "hash",
                  [ __H ]
                |),
                [
                  M.get_struct_record_field
                    (M.read (| self |))
                    "move_core_types::abi::ArgumentABI"
                    "type_tag";
                  M.read (| state |)
                ]
              |)
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::hash::Hash"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("hash", InstanceField.Method hash) ].
  End Impl_core_hash_Hash_for_move_core_types_abi_ArgumentABI.
  
  Module Impl_core_marker_StructuralEq_for_move_core_types_abi_ArgumentABI.
    Definition Self : Ty.t := Ty.path "move_core_types::abi::ArgumentABI".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralEq_for_move_core_types_abi_ArgumentABI.
  
  Module Impl_core_cmp_Eq_for_move_core_types_abi_ArgumentABI.
    Definition Self : Ty.t := Ty.path "move_core_types::abi::ArgumentABI".
    
    (* Eq *)
    Definition assert_receiver_is_total_eq (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Value.DeclaredButUndefined,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      Value.DeclaredButUndefined,
                      [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_move_core_types_abi_ArgumentABI.
  
  Module Impl_core_marker_StructuralPartialEq_for_move_core_types_abi_ArgumentABI.
    Definition Self : Ty.t := Ty.path "move_core_types::abi::ArgumentABI".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_move_core_types_abi_ArgumentABI.
  
  Module Impl_core_cmp_PartialEq_for_move_core_types_abi_ArgumentABI.
    Definition Self : Ty.t := Ty.path "move_core_types::abi::ArgumentABI".
    
    (* PartialEq *)
    Definition eq (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          LogicalOp.and (|
            M.call_closure (|
              M.get_trait_method (|
                "core::cmp::PartialEq",
                Ty.path "alloc::string::String",
                [ Ty.path "alloc::string::String" ],
                "eq",
                []
              |),
              [
                M.get_struct_record_field
                  (M.read (| self |))
                  "move_core_types::abi::ArgumentABI"
                  "name";
                M.get_struct_record_field
                  (M.read (| other |))
                  "move_core_types::abi::ArgumentABI"
                  "name"
              ]
            |),
            ltac:(M.monadic
              (M.call_closure (|
                M.get_trait_method (|
                  "core::cmp::PartialEq",
                  Ty.path "move_core_types::language_storage::TypeTag",
                  [ Ty.path "move_core_types::language_storage::TypeTag" ],
                  "eq",
                  []
                |),
                [
                  M.get_struct_record_field
                    (M.read (| self |))
                    "move_core_types::abi::ArgumentABI"
                    "type_tag";
                  M.get_struct_record_field
                    (M.read (| other |))
                    "move_core_types::abi::ArgumentABI"
                    "type_tag"
                ]
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_for_move_core_types_abi_ArgumentABI.
  
  Module Wrap_underscore_7.
  Module underscore.
    Module Impl_serde_ser_Serialize_for_move_core_types_abi_ArgumentABI.
      Definition Self : Ty.t := Ty.path "move_core_types::abi::ArgumentABI".
      
      (* Serialize *)
      Definition serialize (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ __S ], [ self; __serializer ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let __serializer := M.alloc (| __serializer |) in
            M.read (|
              let __serde_state :=
                M.copy (|
                  M.match_operator (|
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "serde::ser::Serializer",
                          __S,
                          [],
                          "serialize_struct",
                          []
                        |),
                        [
                          M.read (| __serializer |);
                          M.read (| mk_str "ArgumentABI" |);
                          BinOp.Panic.add (|
                            BinOp.Panic.add (|
                              M.rust_cast (Value.Bool false),
                              Value.Integer Integer.Usize 1
                            |),
                            Value.Integer Integer.Usize 1
                          |)
                        ]
                      |)
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.get_struct_tuple_field_or_break_match (|
                              γ,
                              "core::result::Result::Ok",
                              0
                            |) in
                          let __val := M.copy (| γ0_0 |) in
                          __val));
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.get_struct_tuple_field_or_break_match (|
                              γ,
                              "core::result::Result::Err",
                              0
                            |) in
                          let __err := M.copy (| γ0_0 |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  Value.StructTuple
                                    "core::result::Result::Err"
                                    [ M.read (| __err |) ]
                                |)
                              |)
                            |)
                          |)))
                    ]
                  |)
                |) in
              let _ :=
                M.match_operator (|
                  M.alloc (|
                    M.call_closure (|
                      M.get_trait_method (|
                        "serde::ser::SerializeStruct",
                        Ty.associated,
                        [],
                        "serialize_field",
                        [ Ty.path "alloc::string::String" ]
                      |),
                      [
                        __serde_state;
                        M.read (| mk_str "name" |);
                        M.get_struct_record_field
                          (M.read (| self |))
                          "move_core_types::abi::ArgumentABI"
                          "name"
                      ]
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.get_struct_tuple_field_or_break_match (|
                            γ,
                            "core::result::Result::Ok",
                            0
                          |) in
                        let __val := M.copy (| γ0_0 |) in
                        __val));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.get_struct_tuple_field_or_break_match (|
                            γ,
                            "core::result::Result::Err",
                            0
                          |) in
                        let __err := M.copy (| γ0_0 |) in
                        M.alloc (|
                          M.never_to_any (|
                            M.read (|
                              M.return_ (|
                                Value.StructTuple "core::result::Result::Err" [ M.read (| __err |) ]
                              |)
                            |)
                          |)
                        |)))
                  ]
                |) in
              let _ :=
                M.match_operator (|
                  M.alloc (|
                    M.call_closure (|
                      M.get_trait_method (|
                        "serde::ser::SerializeStruct",
                        Ty.associated,
                        [],
                        "serialize_field",
                        [ Ty.path "move_core_types::language_storage::TypeTag" ]
                      |),
                      [
                        __serde_state;
                        M.read (| mk_str "type_tag" |);
                        M.get_struct_record_field
                          (M.read (| self |))
                          "move_core_types::abi::ArgumentABI"
                          "type_tag"
                      ]
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.get_struct_tuple_field_or_break_match (|
                            γ,
                            "core::result::Result::Ok",
                            0
                          |) in
                        let __val := M.copy (| γ0_0 |) in
                        __val));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.get_struct_tuple_field_or_break_match (|
                            γ,
                            "core::result::Result::Err",
                            0
                          |) in
                        let __err := M.copy (| γ0_0 |) in
                        M.alloc (|
                          M.never_to_any (|
                            M.read (|
                              M.return_ (|
                                Value.StructTuple "core::result::Result::Err" [ M.read (| __err |) ]
                              |)
                            |)
                          |)
                        |)))
                  ]
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "serde::ser::SerializeStruct",
                    Ty.associated,
                    [],
                    "end",
                    []
                  |),
                  [ M.read (| __serde_state |) ]
                |)
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "serde::ser::Serialize"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("serialize", InstanceField.Method serialize) ].
    End Impl_serde_ser_Serialize_for_move_core_types_abi_ArgumentABI.
  End underscore.
  End Wrap_underscore_7.
  Import Wrap_underscore_7.
  
  Module Wrap_underscore_8.
  Module underscore.
    Module Impl_serde_de_Deserialize_for_move_core_types_abi_ArgumentABI.
      Definition Self : Ty.t := Ty.path "move_core_types::abi::ArgumentABI".
      
      (* Deserialize *)
      Definition deserialize (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ __D ], [ __deserializer ] =>
          ltac:(M.monadic
            (let __deserializer := M.alloc (| __deserializer |) in
            M.call_closure (|
              M.get_trait_method (|
                "serde::de::Deserializer",
                __D,
                [],
                "deserialize_struct",
                [ Ty.path "move_core_types::abi::_'7::deserialize::__Visitor" ]
              |),
              [
                M.read (| __deserializer |);
                M.read (| mk_str "ArgumentABI" |);
                M.read (| M.get_constant (| "move_core_types::abi::_'7::deserialize::FIELDS" |) |);
                Value.StructRecord
                  "move_core_types::abi::_'7::deserialize::__Visitor"
                  [
                    ("marker", Value.StructTuple "core::marker::PhantomData" []);
                    ("lifetime", Value.StructTuple "core::marker::PhantomData" [])
                  ]
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "serde::de::Deserialize"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("deserialize", InstanceField.Method deserialize) ].
    End Impl_serde_de_Deserialize_for_move_core_types_abi_ArgumentABI.
  End underscore.
  End Wrap_underscore_8.
  Import Wrap_underscore_8.
  
  (* StructRecord
    {
      name := "TypeArgumentABI";
      ty_params := [];
      fields := [ ("name", Ty.path "alloc::string::String") ];
    } *)
  
  Module Impl_core_clone_Clone_for_move_core_types_abi_TypeArgumentABI.
    Definition Self : Ty.t := Ty.path "move_core_types::abi::TypeArgumentABI".
    
    (* Clone *)
    Definition clone (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.StructRecord
            "move_core_types::abi::TypeArgumentABI"
            [
              ("name",
                M.call_closure (|
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.path "alloc::string::String",
                    [],
                    "clone",
                    []
                  |),
                  [
                    M.get_struct_record_field
                      (M.read (| self |))
                      "move_core_types::abi::TypeArgumentABI"
                      "name"
                  ]
                |))
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_move_core_types_abi_TypeArgumentABI.
  
  Module Impl_core_fmt_Debug_for_move_core_types_abi_TypeArgumentABI.
    Definition Self : Ty.t := Ty.path "move_core_types::abi::TypeArgumentABI".
    
    (* Debug *)
    Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.path "core::fmt::Formatter",
              "debug_struct_field1_finish",
              []
            |),
            [
              M.read (| f |);
              M.read (| mk_str "TypeArgumentABI" |);
              M.read (| mk_str "name" |);
              (* Unsize *)
              M.pointer_coercion
                (M.alloc (|
                  M.get_struct_record_field
                    (M.read (| self |))
                    "move_core_types::abi::TypeArgumentABI"
                    "name"
                |))
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_move_core_types_abi_TypeArgumentABI.
  
  Module Impl_core_hash_Hash_for_move_core_types_abi_TypeArgumentABI.
    Definition Self : Ty.t := Ty.path "move_core_types::abi::TypeArgumentABI".
    
    (* Hash *)
    Definition hash (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ __H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let state := M.alloc (| state |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::hash::Hash",
              Ty.path "alloc::string::String",
              [],
              "hash",
              [ __H ]
            |),
            [
              M.get_struct_record_field
                (M.read (| self |))
                "move_core_types::abi::TypeArgumentABI"
                "name";
              M.read (| state |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::hash::Hash"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("hash", InstanceField.Method hash) ].
  End Impl_core_hash_Hash_for_move_core_types_abi_TypeArgumentABI.
  
  Module Impl_core_marker_StructuralEq_for_move_core_types_abi_TypeArgumentABI.
    Definition Self : Ty.t := Ty.path "move_core_types::abi::TypeArgumentABI".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralEq_for_move_core_types_abi_TypeArgumentABI.
  
  Module Impl_core_cmp_Eq_for_move_core_types_abi_TypeArgumentABI.
    Definition Self : Ty.t := Ty.path "move_core_types::abi::TypeArgumentABI".
    
    (* Eq *)
    Definition assert_receiver_is_total_eq (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Value.DeclaredButUndefined,
              [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_move_core_types_abi_TypeArgumentABI.
  
  Module Impl_core_marker_StructuralPartialEq_for_move_core_types_abi_TypeArgumentABI.
    Definition Self : Ty.t := Ty.path "move_core_types::abi::TypeArgumentABI".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_move_core_types_abi_TypeArgumentABI.
  
  Module Impl_core_cmp_PartialEq_for_move_core_types_abi_TypeArgumentABI.
    Definition Self : Ty.t := Ty.path "move_core_types::abi::TypeArgumentABI".
    
    (* PartialEq *)
    Definition eq (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::cmp::PartialEq",
              Ty.path "alloc::string::String",
              [ Ty.path "alloc::string::String" ],
              "eq",
              []
            |),
            [
              M.get_struct_record_field
                (M.read (| self |))
                "move_core_types::abi::TypeArgumentABI"
                "name";
              M.get_struct_record_field
                (M.read (| other |))
                "move_core_types::abi::TypeArgumentABI"
                "name"
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_for_move_core_types_abi_TypeArgumentABI.
  
  Module Wrap_underscore_9.
  Module underscore.
    Module Impl_serde_ser_Serialize_for_move_core_types_abi_TypeArgumentABI.
      Definition Self : Ty.t := Ty.path "move_core_types::abi::TypeArgumentABI".
      
      (* Serialize *)
      Definition serialize (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ __S ], [ self; __serializer ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let __serializer := M.alloc (| __serializer |) in
            M.read (|
              let __serde_state :=
                M.copy (|
                  M.match_operator (|
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "serde::ser::Serializer",
                          __S,
                          [],
                          "serialize_struct",
                          []
                        |),
                        [
                          M.read (| __serializer |);
                          M.read (| mk_str "TypeArgumentABI" |);
                          BinOp.Panic.add (|
                            M.rust_cast (Value.Bool false),
                            Value.Integer Integer.Usize 1
                          |)
                        ]
                      |)
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.get_struct_tuple_field_or_break_match (|
                              γ,
                              "core::result::Result::Ok",
                              0
                            |) in
                          let __val := M.copy (| γ0_0 |) in
                          __val));
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.get_struct_tuple_field_or_break_match (|
                              γ,
                              "core::result::Result::Err",
                              0
                            |) in
                          let __err := M.copy (| γ0_0 |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  Value.StructTuple
                                    "core::result::Result::Err"
                                    [ M.read (| __err |) ]
                                |)
                              |)
                            |)
                          |)))
                    ]
                  |)
                |) in
              let _ :=
                M.match_operator (|
                  M.alloc (|
                    M.call_closure (|
                      M.get_trait_method (|
                        "serde::ser::SerializeStruct",
                        Ty.associated,
                        [],
                        "serialize_field",
                        [ Ty.path "alloc::string::String" ]
                      |),
                      [
                        __serde_state;
                        M.read (| mk_str "name" |);
                        M.get_struct_record_field
                          (M.read (| self |))
                          "move_core_types::abi::TypeArgumentABI"
                          "name"
                      ]
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.get_struct_tuple_field_or_break_match (|
                            γ,
                            "core::result::Result::Ok",
                            0
                          |) in
                        let __val := M.copy (| γ0_0 |) in
                        __val));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.get_struct_tuple_field_or_break_match (|
                            γ,
                            "core::result::Result::Err",
                            0
                          |) in
                        let __err := M.copy (| γ0_0 |) in
                        M.alloc (|
                          M.never_to_any (|
                            M.read (|
                              M.return_ (|
                                Value.StructTuple "core::result::Result::Err" [ M.read (| __err |) ]
                              |)
                            |)
                          |)
                        |)))
                  ]
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "serde::ser::SerializeStruct",
                    Ty.associated,
                    [],
                    "end",
                    []
                  |),
                  [ M.read (| __serde_state |) ]
                |)
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "serde::ser::Serialize"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("serialize", InstanceField.Method serialize) ].
    End Impl_serde_ser_Serialize_for_move_core_types_abi_TypeArgumentABI.
  End underscore.
  End Wrap_underscore_9.
  Import Wrap_underscore_9.
  
  Module Wrap_underscore_10.
  Module underscore.
    Module Impl_serde_de_Deserialize_for_move_core_types_abi_TypeArgumentABI.
      Definition Self : Ty.t := Ty.path "move_core_types::abi::TypeArgumentABI".
      
      (* Deserialize *)
      Definition deserialize (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ __D ], [ __deserializer ] =>
          ltac:(M.monadic
            (let __deserializer := M.alloc (| __deserializer |) in
            M.call_closure (|
              M.get_trait_method (|
                "serde::de::Deserializer",
                __D,
                [],
                "deserialize_struct",
                [ Ty.path "move_core_types::abi::_'9::deserialize::__Visitor" ]
              |),
              [
                M.read (| __deserializer |);
                M.read (| mk_str "TypeArgumentABI" |);
                M.read (| M.get_constant (| "move_core_types::abi::_'9::deserialize::FIELDS" |) |);
                Value.StructRecord
                  "move_core_types::abi::_'9::deserialize::__Visitor"
                  [
                    ("marker", Value.StructTuple "core::marker::PhantomData" []);
                    ("lifetime", Value.StructTuple "core::marker::PhantomData" [])
                  ]
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "serde::de::Deserialize"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("deserialize", InstanceField.Method deserialize) ].
    End Impl_serde_de_Deserialize_for_move_core_types_abi_TypeArgumentABI.
  End underscore.
  End Wrap_underscore_10.
  Import Wrap_underscore_10.
  
  Module Impl_move_core_types_abi_TransactionScriptABI.
    Definition Self : Ty.t := Ty.path "move_core_types::abi::TransactionScriptABI".
    
    (*
        pub fn new(
            name: String,
            doc: String,
            code: Vec<u8>,
            ty_args: Vec<TypeArgumentABI>,
            args: Vec<ArgumentABI>,
        ) -> Self {
            Self {
                name,
                doc,
                code,
                ty_args,
                args,
            }
        }
    *)
    Definition new (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ name; doc; code; ty_args; args ] =>
        ltac:(M.monadic
          (let name := M.alloc (| name |) in
          let doc := M.alloc (| doc |) in
          let code := M.alloc (| code |) in
          let ty_args := M.alloc (| ty_args |) in
          let args := M.alloc (| args |) in
          Value.StructRecord
            "move_core_types::abi::TransactionScriptABI"
            [
              ("name", M.read (| name |));
              ("doc", M.read (| doc |));
              ("code", M.read (| code |));
              ("ty_args", M.read (| ty_args |));
              ("args", M.read (| args |))
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_new : M.IsAssociatedFunction Self "new" new.
    
    (*
        pub fn name(&self) -> &str {
            &self.name
        }
    *)
    Definition name (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::ops::deref::Deref",
              Ty.path "alloc::string::String",
              [],
              "deref",
              []
            |),
            [
              M.get_struct_record_field
                (M.read (| self |))
                "move_core_types::abi::TransactionScriptABI"
                "name"
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_name : M.IsAssociatedFunction Self "name" name.
    
    (*
        pub fn doc(&self) -> &str {
            &self.doc
        }
    *)
    Definition doc (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::ops::deref::Deref",
              Ty.path "alloc::string::String",
              [],
              "deref",
              []
            |),
            [
              M.get_struct_record_field
                (M.read (| self |))
                "move_core_types::abi::TransactionScriptABI"
                "doc"
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_doc : M.IsAssociatedFunction Self "doc" doc.
    
    (*
        pub fn code(&self) -> &[u8] {
            &self.code
        }
    *)
    Definition code (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::ops::deref::Deref",
              Ty.apply (Ty.path "alloc::vec::Vec") [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
              [],
              "deref",
              []
            |),
            [
              M.get_struct_record_field
                (M.read (| self |))
                "move_core_types::abi::TransactionScriptABI"
                "code"
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_code : M.IsAssociatedFunction Self "code" code.
    
    (*
        pub fn ty_args(&self) -> &[TypeArgumentABI] {
            &self.ty_args
        }
    *)
    Definition ty_args (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::ops::deref::Deref",
              Ty.apply
                (Ty.path "alloc::vec::Vec")
                [ Ty.path "move_core_types::abi::TypeArgumentABI"; Ty.path "alloc::alloc::Global" ],
              [],
              "deref",
              []
            |),
            [
              M.get_struct_record_field
                (M.read (| self |))
                "move_core_types::abi::TransactionScriptABI"
                "ty_args"
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_ty_args : M.IsAssociatedFunction Self "ty_args" ty_args.
    
    (*
        pub fn args(&self) -> &[ArgumentABI] {
            &self.args
        }
    *)
    Definition args (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::ops::deref::Deref",
              Ty.apply
                (Ty.path "alloc::vec::Vec")
                [ Ty.path "move_core_types::abi::ArgumentABI"; Ty.path "alloc::alloc::Global" ],
              [],
              "deref",
              []
            |),
            [
              M.get_struct_record_field
                (M.read (| self |))
                "move_core_types::abi::TransactionScriptABI"
                "args"
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_args : M.IsAssociatedFunction Self "args" args.
  End Impl_move_core_types_abi_TransactionScriptABI.
  
  Module Impl_move_core_types_abi_ScriptFunctionABI.
    Definition Self : Ty.t := Ty.path "move_core_types::abi::ScriptFunctionABI".
    
    (*
        pub fn new(
            name: String,
            module_name: ModuleId,
            doc: String,
            ty_args: Vec<TypeArgumentABI>,
            args: Vec<ArgumentABI>,
        ) -> Self {
            Self {
                name,
                module_name,
                doc,
                ty_args,
                args,
            }
        }
    *)
    Definition new (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ name; module_name; doc; ty_args; args ] =>
        ltac:(M.monadic
          (let name := M.alloc (| name |) in
          let module_name := M.alloc (| module_name |) in
          let doc := M.alloc (| doc |) in
          let ty_args := M.alloc (| ty_args |) in
          let args := M.alloc (| args |) in
          Value.StructRecord
            "move_core_types::abi::ScriptFunctionABI"
            [
              ("name", M.read (| name |));
              ("module_name", M.read (| module_name |));
              ("doc", M.read (| doc |));
              ("ty_args", M.read (| ty_args |));
              ("args", M.read (| args |))
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_new : M.IsAssociatedFunction Self "new" new.
    
    (*
        pub fn name(&self) -> &str {
            &self.name
        }
    *)
    Definition name (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::ops::deref::Deref",
              Ty.path "alloc::string::String",
              [],
              "deref",
              []
            |),
            [
              M.get_struct_record_field
                (M.read (| self |))
                "move_core_types::abi::ScriptFunctionABI"
                "name"
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_name : M.IsAssociatedFunction Self "name" name.
    
    (*
        pub fn module_name(&self) -> &ModuleId {
            &self.module_name
        }
    *)
    Definition module_name (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.get_struct_record_field
            (M.read (| self |))
            "move_core_types::abi::ScriptFunctionABI"
            "module_name"))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_module_name : M.IsAssociatedFunction Self "module_name" module_name.
    
    (*
        pub fn doc(&self) -> &str {
            &self.doc
        }
    *)
    Definition doc (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::ops::deref::Deref",
              Ty.path "alloc::string::String",
              [],
              "deref",
              []
            |),
            [
              M.get_struct_record_field
                (M.read (| self |))
                "move_core_types::abi::ScriptFunctionABI"
                "doc"
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_doc : M.IsAssociatedFunction Self "doc" doc.
    
    (*
        pub fn ty_args(&self) -> &[TypeArgumentABI] {
            &self.ty_args
        }
    *)
    Definition ty_args (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::ops::deref::Deref",
              Ty.apply
                (Ty.path "alloc::vec::Vec")
                [ Ty.path "move_core_types::abi::TypeArgumentABI"; Ty.path "alloc::alloc::Global" ],
              [],
              "deref",
              []
            |),
            [
              M.get_struct_record_field
                (M.read (| self |))
                "move_core_types::abi::ScriptFunctionABI"
                "ty_args"
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_ty_args : M.IsAssociatedFunction Self "ty_args" ty_args.
    
    (*
        pub fn args(&self) -> &[ArgumentABI] {
            &self.args
        }
    *)
    Definition args (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::ops::deref::Deref",
              Ty.apply
                (Ty.path "alloc::vec::Vec")
                [ Ty.path "move_core_types::abi::ArgumentABI"; Ty.path "alloc::alloc::Global" ],
              [],
              "deref",
              []
            |),
            [
              M.get_struct_record_field
                (M.read (| self |))
                "move_core_types::abi::ScriptFunctionABI"
                "args"
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_args : M.IsAssociatedFunction Self "args" args.
  End Impl_move_core_types_abi_ScriptFunctionABI.
  
  Module Impl_move_core_types_abi_ScriptABI.
    Definition Self : Ty.t := Ty.path "move_core_types::abi::ScriptABI".
    
    (*
        pub fn is_script_fun_abi(&self) -> bool {
            matches!(self, Self::ScriptFunction(_))
        }
    *)
    Definition is_script_fun_abi (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::abi::ScriptABI::ScriptFunction",
                        0
                      |) in
                    M.alloc (| Value.Bool true |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Bool false |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_is_script_fun_abi :
      M.IsAssociatedFunction Self "is_script_fun_abi" is_script_fun_abi.
    
    (*
        pub fn is_transaction_script_abi(&self) -> bool {
            matches!(self, Self::TransactionScript(_))
        }
    *)
    Definition is_transaction_script_abi (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::abi::ScriptABI::TransactionScript",
                        0
                      |) in
                    M.alloc (| Value.Bool true |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Bool false |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_is_transaction_script_abi :
      M.IsAssociatedFunction Self "is_transaction_script_abi" is_transaction_script_abi.
    
    (*
        pub fn name(&self) -> &str {
            match self {
                Self::TransactionScript(abi) => abi.name(),
                Self::ScriptFunction(abi) => abi.name(),
            }
        }
    *)
    Definition name (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::abi::ScriptABI::TransactionScript",
                        0
                      |) in
                    let abi := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "move_core_types::abi::TransactionScriptABI",
                          "name",
                          []
                        |),
                        [ M.read (| abi |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::abi::ScriptABI::ScriptFunction",
                        0
                      |) in
                    let abi := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "move_core_types::abi::ScriptFunctionABI",
                          "name",
                          []
                        |),
                        [ M.read (| abi |) ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_name : M.IsAssociatedFunction Self "name" name.
    
    (*
        pub fn doc(&self) -> &str {
            match self {
                Self::TransactionScript(abi) => abi.doc(),
                Self::ScriptFunction(abi) => abi.doc(),
            }
        }
    *)
    Definition doc (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::abi::ScriptABI::TransactionScript",
                        0
                      |) in
                    let abi := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "move_core_types::abi::TransactionScriptABI",
                          "doc",
                          []
                        |),
                        [ M.read (| abi |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::abi::ScriptABI::ScriptFunction",
                        0
                      |) in
                    let abi := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "move_core_types::abi::ScriptFunctionABI",
                          "doc",
                          []
                        |),
                        [ M.read (| abi |) ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_doc : M.IsAssociatedFunction Self "doc" doc.
    
    (*
        pub fn ty_args(&self) -> &[TypeArgumentABI] {
            match self {
                Self::TransactionScript(abi) => abi.ty_args(),
                Self::ScriptFunction(abi) => abi.ty_args(),
            }
        }
    *)
    Definition ty_args (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::abi::ScriptABI::TransactionScript",
                        0
                      |) in
                    let abi := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "move_core_types::abi::TransactionScriptABI",
                          "ty_args",
                          []
                        |),
                        [ M.read (| abi |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::abi::ScriptABI::ScriptFunction",
                        0
                      |) in
                    let abi := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "move_core_types::abi::ScriptFunctionABI",
                          "ty_args",
                          []
                        |),
                        [ M.read (| abi |) ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_ty_args : M.IsAssociatedFunction Self "ty_args" ty_args.
    
    (*
        pub fn args(&self) -> &[ArgumentABI] {
            match self {
                Self::TransactionScript(abi) => abi.args(),
                Self::ScriptFunction(abi) => abi.args(),
            }
        }
    *)
    Definition args (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::abi::ScriptABI::TransactionScript",
                        0
                      |) in
                    let abi := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "move_core_types::abi::TransactionScriptABI",
                          "args",
                          []
                        |),
                        [ M.read (| abi |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::abi::ScriptABI::ScriptFunction",
                        0
                      |) in
                    let abi := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "move_core_types::abi::ScriptFunctionABI",
                          "args",
                          []
                        |),
                        [ M.read (| abi |) ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_args : M.IsAssociatedFunction Self "args" args.
  End Impl_move_core_types_abi_ScriptABI.
  
  Module Impl_move_core_types_abi_ArgumentABI.
    Definition Self : Ty.t := Ty.path "move_core_types::abi::ArgumentABI".
    
    (*
        pub fn new(name: String, type_tag: TypeTag) -> Self {
            Self { name, type_tag }
        }
    *)
    Definition new (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ name; type_tag ] =>
        ltac:(M.monadic
          (let name := M.alloc (| name |) in
          let type_tag := M.alloc (| type_tag |) in
          Value.StructRecord
            "move_core_types::abi::ArgumentABI"
            [ ("name", M.read (| name |)); ("type_tag", M.read (| type_tag |)) ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_new : M.IsAssociatedFunction Self "new" new.
    
    (*
        pub fn name(&self) -> &str {
            &self.name
        }
    *)
    Definition name (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::ops::deref::Deref",
              Ty.path "alloc::string::String",
              [],
              "deref",
              []
            |),
            [
              M.get_struct_record_field
                (M.read (| self |))
                "move_core_types::abi::ArgumentABI"
                "name"
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_name : M.IsAssociatedFunction Self "name" name.
    
    (*
        pub fn type_tag(&self) -> &TypeTag {
            &self.type_tag
        }
    *)
    Definition type_tag (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.get_struct_record_field
            (M.read (| self |))
            "move_core_types::abi::ArgumentABI"
            "type_tag"))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_type_tag : M.IsAssociatedFunction Self "type_tag" type_tag.
  End Impl_move_core_types_abi_ArgumentABI.
  
  Module Impl_move_core_types_abi_TypeArgumentABI.
    Definition Self : Ty.t := Ty.path "move_core_types::abi::TypeArgumentABI".
    
    (*
        pub fn new(name: String) -> Self {
            Self { name }
        }
    *)
    Definition new (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ name ] =>
        ltac:(M.monadic
          (let name := M.alloc (| name |) in
          Value.StructRecord
            "move_core_types::abi::TypeArgumentABI"
            [ ("name", M.read (| name |)) ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_new : M.IsAssociatedFunction Self "new" new.
    
    (*
        pub fn name(&self) -> &str {
            &self.name
        }
    *)
    Definition name (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::ops::deref::Deref",
              Ty.path "alloc::string::String",
              [],
              "deref",
              []
            |),
            [
              M.get_struct_record_field
                (M.read (| self |))
                "move_core_types::abi::TypeArgumentABI"
                "name"
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_name : M.IsAssociatedFunction Self "name" name.
  End Impl_move_core_types_abi_TypeArgumentABI.
End abi.

Module account_address.
  (* StructTuple
    {
      name := "AccountAddress";
      ty_params := [];
      fields := [ Ty.apply (Ty.path "array") [ Ty.path "u8" ] ];
    } *)
  
  Module Impl_core_cmp_Ord_for_move_core_types_account_address_AccountAddress.
    Definition Self : Ty.t := Ty.path "move_core_types::account_address::AccountAddress".
    
    (* Ord *)
    Definition cmp (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::cmp::Ord",
              Ty.apply (Ty.path "array") [ Ty.path "u8" ],
              [],
              "cmp",
              []
            |),
            [
              M.get_struct_tuple_field
                (M.read (| self |))
                "move_core_types::account_address::AccountAddress"
                0;
              M.get_struct_tuple_field
                (M.read (| other |))
                "move_core_types::account_address::AccountAddress"
                0
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Ord"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("cmp", InstanceField.Method cmp) ].
  End Impl_core_cmp_Ord_for_move_core_types_account_address_AccountAddress.
  
  Module Impl_core_cmp_PartialOrd_for_move_core_types_account_address_AccountAddress.
    Definition Self : Ty.t := Ty.path "move_core_types::account_address::AccountAddress".
    
    (* PartialOrd *)
    Definition partial_cmp (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::cmp::PartialOrd",
              Ty.apply (Ty.path "array") [ Ty.path "u8" ],
              [ Ty.apply (Ty.path "array") [ Ty.path "u8" ] ],
              "partial_cmp",
              []
            |),
            [
              M.get_struct_tuple_field
                (M.read (| self |))
                "move_core_types::account_address::AccountAddress"
                0;
              M.get_struct_tuple_field
                (M.read (| other |))
                "move_core_types::account_address::AccountAddress"
                0
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialOrd"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("partial_cmp", InstanceField.Method partial_cmp) ].
  End Impl_core_cmp_PartialOrd_for_move_core_types_account_address_AccountAddress.
  
  Module Impl_core_marker_StructuralEq_for_move_core_types_account_address_AccountAddress.
    Definition Self : Ty.t := Ty.path "move_core_types::account_address::AccountAddress".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralEq_for_move_core_types_account_address_AccountAddress.
  
  Module Impl_core_cmp_Eq_for_move_core_types_account_address_AccountAddress.
    Definition Self : Ty.t := Ty.path "move_core_types::account_address::AccountAddress".
    
    (* Eq *)
    Definition assert_receiver_is_total_eq (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Value.DeclaredButUndefined,
              [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_move_core_types_account_address_AccountAddress.
  
  Module Impl_core_marker_StructuralPartialEq_for_move_core_types_account_address_AccountAddress.
    Definition Self : Ty.t := Ty.path "move_core_types::account_address::AccountAddress".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_move_core_types_account_address_AccountAddress.
  
  Module Impl_core_cmp_PartialEq_for_move_core_types_account_address_AccountAddress.
    Definition Self : Ty.t := Ty.path "move_core_types::account_address::AccountAddress".
    
    (* PartialEq *)
    Definition eq (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::cmp::PartialEq",
              Ty.apply (Ty.path "array") [ Ty.path "u8" ],
              [ Ty.apply (Ty.path "array") [ Ty.path "u8" ] ],
              "eq",
              []
            |),
            [
              M.get_struct_tuple_field
                (M.read (| self |))
                "move_core_types::account_address::AccountAddress"
                0;
              M.get_struct_tuple_field
                (M.read (| other |))
                "move_core_types::account_address::AccountAddress"
                0
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_for_move_core_types_account_address_AccountAddress.
  
  Module Impl_core_hash_Hash_for_move_core_types_account_address_AccountAddress.
    Definition Self : Ty.t := Ty.path "move_core_types::account_address::AccountAddress".
    
    (* Hash *)
    Definition hash (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ __H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let state := M.alloc (| state |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::hash::Hash",
              Ty.apply (Ty.path "array") [ Ty.path "u8" ],
              [],
              "hash",
              [ __H ]
            |),
            [
              M.get_struct_tuple_field
                (M.read (| self |))
                "move_core_types::account_address::AccountAddress"
                0;
              M.read (| state |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::hash::Hash"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("hash", InstanceField.Method hash) ].
  End Impl_core_hash_Hash_for_move_core_types_account_address_AccountAddress.
  
  Module Impl_core_clone_Clone_for_move_core_types_account_address_AccountAddress.
    Definition Self : Ty.t := Ty.path "move_core_types::account_address::AccountAddress".
    
    (* Clone *)
    Definition clone (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Value.DeclaredButUndefined,
              [ fun γ => ltac:(M.monadic (M.read (| self |))) ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_move_core_types_account_address_AccountAddress.
  
  Module Impl_core_marker_Copy_for_move_core_types_account_address_AccountAddress.
    Definition Self : Ty.t := Ty.path "move_core_types::account_address::AccountAddress".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::Copy"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_Copy_for_move_core_types_account_address_AccountAddress.
  
  Module Impl_move_core_types_account_address_AccountAddress.
    Definition Self : Ty.t := Ty.path "move_core_types::account_address::AccountAddress".
    
    (*
        pub const fn new(address: [u8; Self::LENGTH]) -> Self {
            Self(address)
        }
    *)
    Definition new (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ address ] =>
        ltac:(M.monadic
          (let address := M.alloc (| address |) in
          Value.StructTuple
            "move_core_types::account_address::AccountAddress"
            [ M.read (| address |) ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_new : M.IsAssociatedFunction Self "new" new.
    
    (*
        pub const LENGTH: usize = if cfg!(feature = "address20") {
            20
        } else if cfg!(feature = "address32") {
            32
        } else {
            16
        };
    *)
    (* Ty.path "usize" *)
    Definition value_LENGTH : Value.t :=
      M.run
        ltac:(M.monadic
          (M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ := M.use (M.alloc (| Value.Bool false |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (| Value.Integer Integer.Usize 20 |)));
              fun γ =>
                ltac:(M.monadic
                  (M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ := M.use (M.alloc (| Value.Bool false |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (| Value.Integer Integer.Usize 32 |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Integer Integer.Usize 16 |)))
                    ]
                  |)))
            ]
          |))).
    
    Axiom AssociatedConstant_value_LENGTH : M.IsAssociatedConstant Self "value_LENGTH" value_LENGTH.
    
    (*     pub const ZERO: Self = Self([0u8; Self::LENGTH]); *)
    (* Ty.path "move_core_types::account_address::AccountAddress" *)
    Definition value_ZERO : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            Value.StructTuple
              "move_core_types::account_address::AccountAddress"
              [ repeat (Value.Integer Integer.U8 0) 16 ]
          |))).
    
    Axiom AssociatedConstant_value_ZERO : M.IsAssociatedConstant Self "value_ZERO" value_ZERO.
    
    (*     pub const ONE: Self = Self::get_hex_address_one(); *)
    (* Ty.path "move_core_types::account_address::AccountAddress" *)
    Definition value_ONE : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "move_core_types::account_address::AccountAddress",
                "get_hex_address_one",
                []
              |),
              []
            |)
          |))).
    
    Axiom AssociatedConstant_value_ONE : M.IsAssociatedConstant Self "value_ONE" value_ONE.
    
    (*     pub const TWO: Self = Self::get_hex_address_two(); *)
    (* Ty.path "move_core_types::account_address::AccountAddress" *)
    Definition value_TWO : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.path "move_core_types::account_address::AccountAddress",
                "get_hex_address_two",
                []
              |),
              []
            |)
          |))).
    
    Axiom AssociatedConstant_value_TWO : M.IsAssociatedConstant Self "value_TWO" value_TWO.
    
    (*
        const fn get_hex_address_one() -> Self {
            let mut addr = [0u8; AccountAddress::LENGTH];
            addr[AccountAddress::LENGTH - 1] = 1u8;
            Self(addr)
        }
    *)
    Definition get_hex_address_one (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [] =>
        ltac:(M.monadic
          (M.read (|
            let addr := M.alloc (| repeat (Value.Integer Integer.U8 0) 16 |) in
            let _ :=
              M.write (|
                M.get_array_field (|
                  addr,
                  M.alloc (|
                    BinOp.Panic.sub (|
                      M.read (| M.get_constant (| "move_core_types::account_address::LENGTH" |) |),
                      Value.Integer Integer.Usize 1
                    |)
                  |)
                |),
                Value.Integer Integer.U8 1
              |) in
            M.alloc (|
              Value.StructTuple
                "move_core_types::account_address::AccountAddress"
                [ M.read (| addr |) ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_get_hex_address_one :
      M.IsAssociatedFunction Self "get_hex_address_one" get_hex_address_one.
    
    (*
        const fn get_hex_address_two() -> Self {
            let mut addr = [0u8; AccountAddress::LENGTH];
            addr[AccountAddress::LENGTH - 1] = 2u8;
            Self(addr)
        }
    *)
    Definition get_hex_address_two (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [] =>
        ltac:(M.monadic
          (M.read (|
            let addr := M.alloc (| repeat (Value.Integer Integer.U8 0) 16 |) in
            let _ :=
              M.write (|
                M.get_array_field (|
                  addr,
                  M.alloc (|
                    BinOp.Panic.sub (|
                      M.read (| M.get_constant (| "move_core_types::account_address::LENGTH" |) |),
                      Value.Integer Integer.Usize 1
                    |)
                  |)
                |),
                Value.Integer Integer.U8 2
              |) in
            M.alloc (|
              Value.StructTuple
                "move_core_types::account_address::AccountAddress"
                [ M.read (| addr |) ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_get_hex_address_two :
      M.IsAssociatedFunction Self "get_hex_address_two" get_hex_address_two.
    
    (*
        pub fn random() -> Self {
            let mut rng = OsRng;
            let buf: [u8; Self::LENGTH] = rng.gen();
            Self(buf)
        }
    *)
    Definition random (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [] =>
        ltac:(M.monadic
          (M.read (|
            let rng := M.alloc (| Value.StructTuple "rand_core::os::OsRng" [] |) in
            let buf :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "rand::rng::Rng",
                    Ty.path "rand_core::os::OsRng",
                    [],
                    "gen",
                    [ Ty.apply (Ty.path "array") [ Ty.path "u8" ] ]
                  |),
                  [ rng ]
                |)
              |) in
            M.alloc (|
              Value.StructTuple
                "move_core_types::account_address::AccountAddress"
                [ M.read (| buf |) ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_random : M.IsAssociatedFunction Self "random" random.
    
    (*
        pub fn to_canonical_string(&self) -> String {
            hex::encode(self.0)
        }
    *)
    Definition to_canonical_string (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_function (| "hex::encode", [ Ty.apply (Ty.path "array") [ Ty.path "u8" ] ] |),
            [
              M.read (|
                M.get_struct_tuple_field
                  (M.read (| self |))
                  "move_core_types::account_address::AccountAddress"
                  0
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_to_canonical_string :
      M.IsAssociatedFunction Self "to_canonical_string" to_canonical_string.
    
    (*
        pub fn short_str_lossless(&self) -> String {
            let hex_str = hex::encode(self.0).trim_start_matches('0').to_string();
            if hex_str.is_empty() {
                "0".to_string()
            } else {
                hex_str
            }
        }
    *)
    Definition short_str_lossless (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let hex_str :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "alloc::string::ToString",
                    Ty.path "str",
                    [],
                    "to_string",
                    []
                  |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "str",
                        "trim_start_matches",
                        [ Ty.path "char" ]
                      |),
                      [
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::ops::deref::Deref",
                            Ty.path "alloc::string::String",
                            [],
                            "deref",
                            []
                          |),
                          [
                            M.alloc (|
                              M.call_closure (|
                                M.get_function (|
                                  "hex::encode",
                                  [ Ty.apply (Ty.path "array") [ Ty.path "u8" ] ]
                                |),
                                [
                                  M.read (|
                                    M.get_struct_tuple_field
                                      (M.read (| self |))
                                      "move_core_types::account_address::AccountAddress"
                                      0
                                  |)
                                ]
                              |)
                            |)
                          ]
                        |);
                        Value.UnicodeChar 48
                      ]
                    |)
                  ]
                |)
              |) in
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "alloc::string::String",
                              "is_empty",
                              []
                            |),
                            [ hex_str ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "alloc::string::ToString",
                          Ty.path "str",
                          [],
                          "to_string",
                          []
                        |),
                        [ M.read (| mk_str "0" |) ]
                      |)
                    |)));
                fun γ => ltac:(M.monadic hex_str)
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_short_str_lossless :
      M.IsAssociatedFunction Self "short_str_lossless" short_str_lossless.
    
    (*
        pub fn to_vec(&self) -> Vec<u8> {
            self.0.to_vec()
        }
    *)
    Definition to_vec (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply (Ty.path "slice") [ Ty.path "u8" ],
              "to_vec",
              []
            |),
            [
              (* Unsize *)
              M.pointer_coercion
                (M.get_struct_tuple_field
                  (M.read (| self |))
                  "move_core_types::account_address::AccountAddress"
                  0)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_to_vec : M.IsAssociatedFunction Self "to_vec" to_vec.
    
    (*
        pub fn into_bytes(self) -> [u8; Self::LENGTH] {
            self.0
        }
    *)
    Definition into_bytes (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.get_struct_tuple_field self "move_core_types::account_address::AccountAddress" 0
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_into_bytes : M.IsAssociatedFunction Self "into_bytes" into_bytes.
    
    (*
        pub fn from_hex_literal(literal: &str) -> Result<Self, AccountAddressParseError> {
            if !literal.starts_with("0x") {
                return Err(AccountAddressParseError);
            }
    
            let hex_len = literal.len() - 2;
    
            // If the string is too short, pad it
            if hex_len < Self::LENGTH * 2 {
                let mut hex_str = String::with_capacity(Self::LENGTH * 2);
                for _ in 0..Self::LENGTH * 2 - hex_len {
                    hex_str.push('0');
                }
                hex_str.push_str(&literal[2..]);
                AccountAddress::from_hex(hex_str)
            } else {
                AccountAddress::from_hex(&literal[2..])
            }
        }
    *)
    Definition from_hex_literal (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ literal ] =>
        ltac:(M.monadic
          (let literal := M.alloc (| literal |) in
          M.read (|
            let _ :=
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            UnOp.Pure.not
                              (M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "str",
                                  "starts_with",
                                  [ Ty.apply (Ty.path "&") [ Ty.path "str" ] ]
                                |),
                                [ M.read (| literal |); M.read (| mk_str "0x" |) ]
                              |))
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        M.never_to_any (|
                          M.read (|
                            M.return_ (|
                              Value.StructTuple
                                "core::result::Result::Err"
                                [
                                  Value.StructTuple
                                    "move_core_types::account_address::AccountAddressParseError"
                                    []
                                ]
                            |)
                          |)
                        |)
                      |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            let hex_len :=
              M.alloc (|
                BinOp.Panic.sub (|
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "str", "len", [] |),
                    [ M.read (| literal |) ]
                  |),
                  Value.Integer Integer.Usize 2
                |)
              |) in
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          BinOp.Pure.lt
                            (M.read (| hex_len |))
                            (BinOp.Panic.mul (|
                              M.read (|
                                M.get_constant (| "move_core_types::account_address::LENGTH" |)
                              |),
                              Value.Integer Integer.Usize 2
                            |))
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    let hex_str :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.path "alloc::string::String",
                            "with_capacity",
                            []
                          |),
                          [
                            BinOp.Panic.mul (|
                              M.read (|
                                M.get_constant (| "move_core_types::account_address::LENGTH" |)
                              |),
                              Value.Integer Integer.Usize 2
                            |)
                          ]
                        |)
                      |) in
                    let _ :=
                      M.use
                        (M.match_operator (|
                          M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::iter::traits::collect::IntoIterator",
                                Ty.apply (Ty.path "core::ops::range::Range") [ Ty.path "usize" ],
                                [],
                                "into_iter",
                                []
                              |),
                              [
                                Value.StructRecord
                                  "core::ops::range::Range"
                                  [
                                    ("start", Value.Integer Integer.Usize 0);
                                    ("end_",
                                      BinOp.Panic.sub (|
                                        BinOp.Panic.mul (|
                                          M.read (|
                                            M.get_constant (|
                                              "move_core_types::account_address::LENGTH"
                                            |)
                                          |),
                                          Value.Integer Integer.Usize 2
                                        |),
                                        M.read (| hex_len |)
                                      |))
                                  ]
                              ]
                            |)
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let iter := M.copy (| γ |) in
                                M.loop (|
                                  ltac:(M.monadic
                                    (let _ :=
                                      M.match_operator (|
                                        M.alloc (|
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::iter::traits::iterator::Iterator",
                                              Ty.apply
                                                (Ty.path "core::ops::range::Range")
                                                [ Ty.path "usize" ],
                                              [],
                                              "next",
                                              []
                                            |),
                                            [ iter ]
                                          |)
                                        |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (M.alloc (|
                                                M.never_to_any (| M.read (| M.break (||) |) |)
                                              |)));
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let γ0_0 :=
                                                M.get_struct_tuple_field_or_break_match (|
                                                  γ,
                                                  "core::option::Option::Some",
                                                  0
                                                |) in
                                              let _ :=
                                                M.alloc (|
                                                  M.call_closure (|
                                                    M.get_associated_function (|
                                                      Ty.path "alloc::string::String",
                                                      "push",
                                                      []
                                                    |),
                                                    [ hex_str; Value.UnicodeChar 48 ]
                                                  |)
                                                |) in
                                              M.alloc (| Value.Tuple [] |)))
                                        ]
                                      |) in
                                    M.alloc (| Value.Tuple [] |)))
                                |)))
                          ]
                        |)) in
                    let _ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.path "alloc::string::String",
                            "push_str",
                            []
                          |),
                          [
                            hex_str;
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::ops::index::Index",
                                Ty.path "str",
                                [
                                  Ty.apply
                                    (Ty.path "core::ops::range::RangeFrom")
                                    [ Ty.path "usize" ]
                                ],
                                "index",
                                []
                              |),
                              [
                                M.read (| literal |);
                                Value.StructRecord
                                  "core::ops::range::RangeFrom"
                                  [ ("start", Value.Integer Integer.Usize 2) ]
                              ]
                            |)
                          ]
                        |)
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "move_core_types::account_address::AccountAddress",
                          "from_hex",
                          [ Ty.path "alloc::string::String" ]
                        |),
                        [ M.read (| hex_str |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "move_core_types::account_address::AccountAddress",
                          "from_hex",
                          [ Ty.apply (Ty.path "&") [ Ty.path "str" ] ]
                        |),
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::ops::index::Index",
                              Ty.path "str",
                              [ Ty.apply (Ty.path "core::ops::range::RangeFrom") [ Ty.path "usize" ]
                              ],
                              "index",
                              []
                            |),
                            [
                              M.read (| literal |);
                              Value.StructRecord
                                "core::ops::range::RangeFrom"
                                [ ("start", Value.Integer Integer.Usize 2) ]
                            ]
                          |)
                        ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_from_hex_literal :
      M.IsAssociatedFunction Self "from_hex_literal" from_hex_literal.
    
    (*
        pub fn to_hex_literal(&self) -> String {
            format!("0x{}", self.short_str_lossless())
        }
    *)
    Definition to_hex_literal (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let res :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (| "alloc::fmt::format", [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (| Ty.path "core::fmt::Arguments", "new_v1", [] |),
                      [
                        (* Unsize *)
                        M.pointer_coercion (M.alloc (| Value.Array [ M.read (| mk_str "0x" |) ] |));
                        (* Unsize *)
                        M.pointer_coercion
                          (M.alloc (|
                            Value.Array
                              [
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.path "core::fmt::rt::Argument",
                                    "new_display",
                                    [ Ty.path "alloc::string::String" ]
                                  |),
                                  [
                                    M.alloc (|
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.path
                                            "move_core_types::account_address::AccountAddress",
                                          "short_str_lossless",
                                          []
                                        |),
                                        [ M.read (| self |) ]
                                      |)
                                    |)
                                  ]
                                |)
                              ]
                          |))
                      ]
                    |)
                  ]
                |)
              |) in
            res
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_to_hex_literal :
      M.IsAssociatedFunction Self "to_hex_literal" to_hex_literal.
    
    (*
        pub fn from_hex<T: AsRef<[u8]>>(hex: T) -> Result<Self, AccountAddressParseError> {
            <[u8; Self::LENGTH]>::from_hex(hex)
                .map_err(|_| AccountAddressParseError)
                .map(Self)
        }
    *)
    Definition from_hex (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ T ], [ hex ] =>
        ltac:(M.monadic
          (let hex := M.alloc (| hex |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply
                (Ty.path "core::result::Result")
                [
                  Ty.apply (Ty.path "array") [ Ty.path "u8" ];
                  Ty.path "move_core_types::account_address::AccountAddressParseError"
                ],
              "map",
              [
                Ty.path "move_core_types::account_address::AccountAddress";
                Ty.function
                  [ Ty.apply (Ty.path "array") [ Ty.path "u8" ] ]
                  (Ty.path "move_core_types::account_address::AccountAddress")
              ]
            |),
            [
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    [
                      Ty.apply (Ty.path "array") [ Ty.path "u8" ];
                      Ty.path "hex::error::FromHexError"
                    ],
                  "map_err",
                  [
                    Ty.path "move_core_types::account_address::AccountAddressParseError";
                    Ty.function
                      [ Ty.tuple [ Ty.path "hex::error::FromHexError" ] ]
                      (Ty.path "move_core_types::account_address::AccountAddressParseError")
                  ]
                |),
                [
                  M.call_closure (|
                    M.get_trait_method (|
                      "hex::FromHex",
                      Ty.apply (Ty.path "array") [ Ty.path "u8" ],
                      [],
                      "from_hex",
                      [ T ]
                    |),
                    [ M.read (| hex |) ]
                  |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (Value.StructTuple
                                    "move_core_types::account_address::AccountAddressParseError"
                                    []))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |);
              M.constructor_as_closure "move_core_types::account_address::AccountAddress"
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_from_hex : M.IsAssociatedFunction Self "from_hex" from_hex.
    
    (*
        pub fn to_hex(&self) -> String {
            format!("{:x}", self)
        }
    *)
    Definition to_hex (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let res :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (| "alloc::fmt::format", [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (| Ty.path "core::fmt::Arguments", "new_v1", [] |),
                      [
                        (* Unsize *)
                        M.pointer_coercion (M.alloc (| Value.Array [ M.read (| mk_str "" |) ] |));
                        (* Unsize *)
                        M.pointer_coercion
                          (M.alloc (|
                            Value.Array
                              [
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.path "core::fmt::rt::Argument",
                                    "new_lower_hex",
                                    [
                                      Ty.apply
                                        (Ty.path "&")
                                        [ Ty.path "move_core_types::account_address::AccountAddress"
                                        ]
                                    ]
                                  |),
                                  [ self ]
                                |)
                              ]
                          |))
                      ]
                    |)
                  ]
                |)
              |) in
            res
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_to_hex : M.IsAssociatedFunction Self "to_hex" to_hex.
    
    (*
        pub fn from_bytes<T: AsRef<[u8]>>(bytes: T) -> Result<Self, AccountAddressParseError> {
            <[u8; Self::LENGTH]>::try_from(bytes.as_ref())
                .map_err(|_| AccountAddressParseError)
                .map(Self)
        }
    *)
    Definition from_bytes (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ T ], [ bytes ] =>
        ltac:(M.monadic
          (let bytes := M.alloc (| bytes |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply
                (Ty.path "core::result::Result")
                [
                  Ty.apply (Ty.path "array") [ Ty.path "u8" ];
                  Ty.path "move_core_types::account_address::AccountAddressParseError"
                ],
              "map",
              [
                Ty.path "move_core_types::account_address::AccountAddress";
                Ty.function
                  [ Ty.apply (Ty.path "array") [ Ty.path "u8" ] ]
                  (Ty.path "move_core_types::account_address::AccountAddress")
              ]
            |),
            [
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    [
                      Ty.apply (Ty.path "array") [ Ty.path "u8" ];
                      Ty.path "core::array::TryFromSliceError"
                    ],
                  "map_err",
                  [
                    Ty.path "move_core_types::account_address::AccountAddressParseError";
                    Ty.function
                      [ Ty.tuple [ Ty.path "core::array::TryFromSliceError" ] ]
                      (Ty.path "move_core_types::account_address::AccountAddressParseError")
                  ]
                |),
                [
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::convert::TryFrom",
                      Ty.apply (Ty.path "array") [ Ty.path "u8" ],
                      [ Ty.apply (Ty.path "&") [ Ty.apply (Ty.path "slice") [ Ty.path "u8" ] ] ],
                      "try_from",
                      []
                    |),
                    [
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::convert::AsRef",
                          T,
                          [ Ty.apply (Ty.path "slice") [ Ty.path "u8" ] ],
                          "as_ref",
                          []
                        |),
                        [ bytes ]
                      |)
                    ]
                  |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (Value.StructTuple
                                    "move_core_types::account_address::AccountAddressParseError"
                                    []))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |);
              M.constructor_as_closure "move_core_types::account_address::AccountAddress"
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_from_bytes : M.IsAssociatedFunction Self "from_bytes" from_bytes.
  End Impl_move_core_types_account_address_AccountAddress.
  
  Module Impl_core_convert_AsRef_slice_u8_for_move_core_types_account_address_AccountAddress.
    Definition Self : Ty.t := Ty.path "move_core_types::account_address::AccountAddress".
    
    (*
        fn as_ref(&self) -> &[u8] {
            &self.0
        }
    *)
    Definition as_ref (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          (* Unsize *)
          M.pointer_coercion
            (M.get_struct_tuple_field
              (M.read (| self |))
              "move_core_types::account_address::AccountAddress"
              0)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::convert::AsRef"
        Self
        (* Trait polymorphic types *) [ (* T *) Ty.apply (Ty.path "slice") [ Ty.path "u8" ] ]
        (* Instance *) [ ("as_ref", InstanceField.Method as_ref) ].
  End Impl_core_convert_AsRef_slice_u8_for_move_core_types_account_address_AccountAddress.
  
  Module Impl_core_ops_deref_Deref_for_move_core_types_account_address_AccountAddress.
    Definition Self : Ty.t := Ty.path "move_core_types::account_address::AccountAddress".
    
    (*     type Target = [u8; Self::LENGTH]; *)
    Definition _Target : Ty.t := Ty.apply (Ty.path "array") [ Ty.path "u8" ].
    
    (*
        fn deref(&self) -> &Self::Target {
            &self.0
        }
    *)
    Definition deref (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.get_struct_tuple_field
            (M.read (| self |))
            "move_core_types::account_address::AccountAddress"
            0))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::ops::deref::Deref"
        Self
        (* Trait polymorphic types *) []
        (* Instance *)
        [ ("Target", InstanceField.Ty _Target); ("deref", InstanceField.Method deref) ].
  End Impl_core_ops_deref_Deref_for_move_core_types_account_address_AccountAddress.
  
  Module Impl_core_fmt_Display_for_move_core_types_account_address_AccountAddress.
    Definition Self : Ty.t := Ty.path "move_core_types::account_address::AccountAddress".
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter) -> std::fmt::Result {
            write!(f, "{:x}", self)
        }
    *)
    Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_fmt", [] |),
            [
              M.read (| f |);
              M.call_closure (|
                M.get_associated_function (| Ty.path "core::fmt::Arguments", "new_v1", [] |),
                [
                  (* Unsize *)
                  M.pointer_coercion (M.alloc (| Value.Array [ M.read (| mk_str "" |) ] |));
                  (* Unsize *)
                  M.pointer_coercion
                    (M.alloc (|
                      Value.Array
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::rt::Argument",
                              "new_lower_hex",
                              [
                                Ty.apply
                                  (Ty.path "&")
                                  [ Ty.path "move_core_types::account_address::AccountAddress" ]
                              ]
                            |),
                            [ self ]
                          |)
                        ]
                    |))
                ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Display"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Display_for_move_core_types_account_address_AccountAddress.
  
  Module Impl_core_fmt_Debug_for_move_core_types_account_address_AccountAddress.
    Definition Self : Ty.t := Ty.path "move_core_types::account_address::AccountAddress".
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            write!(f, "{:x}", self)
        }
    *)
    Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_fmt", [] |),
            [
              M.read (| f |);
              M.call_closure (|
                M.get_associated_function (| Ty.path "core::fmt::Arguments", "new_v1", [] |),
                [
                  (* Unsize *)
                  M.pointer_coercion (M.alloc (| Value.Array [ M.read (| mk_str "" |) ] |));
                  (* Unsize *)
                  M.pointer_coercion
                    (M.alloc (|
                      Value.Array
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::rt::Argument",
                              "new_lower_hex",
                              [
                                Ty.apply
                                  (Ty.path "&")
                                  [ Ty.path "move_core_types::account_address::AccountAddress" ]
                              ]
                            |),
                            [ self ]
                          |)
                        ]
                    |))
                ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_move_core_types_account_address_AccountAddress.
  
  Module Impl_core_fmt_LowerHex_for_move_core_types_account_address_AccountAddress.
    Definition Self : Ty.t := Ty.path "move_core_types::account_address::AccountAddress".
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            if f.alternate() {
                write!(f, "0x")?;
            }
    
            for byte in &self.0 {
                write!(f, "{:02x}", byte)?;
            }
    
            Ok(())
        }
    *)
    Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.read (|
            let _ :=
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::fmt::Formatter",
                                "alternate",
                                []
                              |),
                              [ M.read (| f |) ]
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      let _ :=
                        M.match_operator (|
                          M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::ops::try_trait::Try",
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                                [],
                                "branch",
                                []
                              |),
                              [
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.path "core::fmt::Formatter",
                                    "write_fmt",
                                    []
                                  |),
                                  [
                                    M.read (| f |);
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.path "core::fmt::Arguments",
                                        "new_const",
                                        []
                                      |),
                                      [
                                        (* Unsize *)
                                        M.pointer_coercion
                                          (M.alloc (| Value.Array [ M.read (| mk_str "0x" |) ] |))
                                      ]
                                    |)
                                  ]
                                |)
                              ]
                            |)
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.get_struct_tuple_field_or_break_match (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Break",
                                    0
                                  |) in
                                let residual := M.copy (| γ0_0 |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      M.return_ (|
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::ops::try_trait::FromResidual",
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                                            [
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                [
                                                  Ty.path "core::convert::Infallible";
                                                  Ty.path "core::fmt::Error"
                                                ]
                                            ],
                                            "from_residual",
                                            []
                                          |),
                                          [ M.read (| residual |) ]
                                        |)
                                      |)
                                    |)
                                  |)
                                |)));
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.get_struct_tuple_field_or_break_match (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Continue",
                                    0
                                  |) in
                                let val := M.copy (| γ0_0 |) in
                                val))
                          ]
                        |) in
                      M.alloc (| Value.Tuple [] |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            let _ :=
              M.use
                (M.match_operator (|
                  M.alloc (|
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::iter::traits::collect::IntoIterator",
                        Ty.apply (Ty.path "&") [ Ty.apply (Ty.path "array") [ Ty.path "u8" ] ],
                        [],
                        "into_iter",
                        []
                      |),
                      [
                        M.get_struct_tuple_field
                          (M.read (| self |))
                          "move_core_types::account_address::AccountAddress"
                          0
                      ]
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let iter := M.copy (| γ |) in
                        M.loop (|
                          ltac:(M.monadic
                            (let _ :=
                              M.match_operator (|
                                M.alloc (|
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::iter::traits::iterator::Iterator",
                                      Ty.apply (Ty.path "core::slice::iter::Iter") [ Ty.path "u8" ],
                                      [],
                                      "next",
                                      []
                                    |),
                                    [ iter ]
                                  |)
                                |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (M.alloc (|
                                        M.never_to_any (| M.read (| M.break (||) |) |)
                                      |)));
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ0_0 :=
                                        M.get_struct_tuple_field_or_break_match (|
                                          γ,
                                          "core::option::Option::Some",
                                          0
                                        |) in
                                      let byte := M.copy (| γ0_0 |) in
                                      let _ :=
                                        M.match_operator (|
                                          M.alloc (|
                                            M.call_closure (|
                                              M.get_trait_method (|
                                                "core::ops::try_trait::Try",
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                                                [],
                                                "branch",
                                                []
                                              |),
                                              [
                                                M.call_closure (|
                                                  M.get_associated_function (|
                                                    Ty.path "core::fmt::Formatter",
                                                    "write_fmt",
                                                    []
                                                  |),
                                                  [
                                                    M.read (| f |);
                                                    M.call_closure (|
                                                      M.get_associated_function (|
                                                        Ty.path "core::fmt::Arguments",
                                                        "new_v1_formatted",
                                                        []
                                                      |),
                                                      [
                                                        (* Unsize *)
                                                        M.pointer_coercion
                                                          (M.alloc (|
                                                            Value.Array [ M.read (| mk_str "" |) ]
                                                          |));
                                                        (* Unsize *)
                                                        M.pointer_coercion
                                                          (M.alloc (|
                                                            Value.Array
                                                              [
                                                                M.call_closure (|
                                                                  M.get_associated_function (|
                                                                    Ty.path
                                                                      "core::fmt::rt::Argument",
                                                                    "new_lower_hex",
                                                                    [
                                                                      Ty.apply
                                                                        (Ty.path "&")
                                                                        [ Ty.path "u8" ]
                                                                    ]
                                                                  |),
                                                                  [ byte ]
                                                                |)
                                                              ]
                                                          |));
                                                        (* Unsize *)
                                                        M.pointer_coercion
                                                          (M.alloc (|
                                                            Value.Array
                                                              [
                                                                M.call_closure (|
                                                                  M.get_associated_function (|
                                                                    Ty.path
                                                                      "core::fmt::rt::Placeholder",
                                                                    "new",
                                                                    []
                                                                  |),
                                                                  [
                                                                    Value.Integer Integer.Usize 0;
                                                                    Value.UnicodeChar 32;
                                                                    Value.StructTuple
                                                                      "core::fmt::rt::Alignment::Unknown"
                                                                      [];
                                                                    Value.Integer Integer.U32 8;
                                                                    Value.StructTuple
                                                                      "core::fmt::rt::Count::Implied"
                                                                      [];
                                                                    Value.StructTuple
                                                                      "core::fmt::rt::Count::Is"
                                                                      [
                                                                        Value.Integer
                                                                          Integer.Usize
                                                                          2
                                                                      ]
                                                                  ]
                                                                |)
                                                              ]
                                                          |));
                                                        M.call_closure (|
                                                          M.get_associated_function (|
                                                            Ty.path "core::fmt::rt::UnsafeArg",
                                                            "new",
                                                            []
                                                          |),
                                                          []
                                                        |)
                                                      ]
                                                    |)
                                                  ]
                                                |)
                                              ]
                                            |)
                                          |),
                                          [
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let γ0_0 :=
                                                  M.get_struct_tuple_field_or_break_match (|
                                                    γ,
                                                    "core::ops::control_flow::ControlFlow::Break",
                                                    0
                                                  |) in
                                                let residual := M.copy (| γ0_0 |) in
                                                M.alloc (|
                                                  M.never_to_any (|
                                                    M.read (|
                                                      M.return_ (|
                                                        M.call_closure (|
                                                          M.get_trait_method (|
                                                            "core::ops::try_trait::FromResidual",
                                                            Ty.apply
                                                              (Ty.path "core::result::Result")
                                                              [
                                                                Ty.tuple [];
                                                                Ty.path "core::fmt::Error"
                                                              ],
                                                            [
                                                              Ty.apply
                                                                (Ty.path "core::result::Result")
                                                                [
                                                                  Ty.path
                                                                    "core::convert::Infallible";
                                                                  Ty.path "core::fmt::Error"
                                                                ]
                                                            ],
                                                            "from_residual",
                                                            []
                                                          |),
                                                          [ M.read (| residual |) ]
                                                        |)
                                                      |)
                                                    |)
                                                  |)
                                                |)));
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let γ0_0 :=
                                                  M.get_struct_tuple_field_or_break_match (|
                                                    γ,
                                                    "core::ops::control_flow::ControlFlow::Continue",
                                                    0
                                                  |) in
                                                let val := M.copy (| γ0_0 |) in
                                                val))
                                          ]
                                        |) in
                                      M.alloc (| Value.Tuple [] |)))
                                ]
                              |) in
                            M.alloc (| Value.Tuple [] |)))
                        |)))
                  ]
                |)) in
            M.alloc (| Value.StructTuple "core::result::Result::Ok" [ Value.Tuple [] ] |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::LowerHex"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_LowerHex_for_move_core_types_account_address_AccountAddress.
  
  Module Impl_core_fmt_UpperHex_for_move_core_types_account_address_AccountAddress.
    Definition Self : Ty.t := Ty.path "move_core_types::account_address::AccountAddress".
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            if f.alternate() {
                write!(f, "0x")?;
            }
    
            for byte in &self.0 {
                write!(f, "{:02X}", byte)?;
            }
    
            Ok(())
        }
    *)
    Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.read (|
            let _ :=
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::fmt::Formatter",
                                "alternate",
                                []
                              |),
                              [ M.read (| f |) ]
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      let _ :=
                        M.match_operator (|
                          M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::ops::try_trait::Try",
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                                [],
                                "branch",
                                []
                              |),
                              [
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.path "core::fmt::Formatter",
                                    "write_fmt",
                                    []
                                  |),
                                  [
                                    M.read (| f |);
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.path "core::fmt::Arguments",
                                        "new_const",
                                        []
                                      |),
                                      [
                                        (* Unsize *)
                                        M.pointer_coercion
                                          (M.alloc (| Value.Array [ M.read (| mk_str "0x" |) ] |))
                                      ]
                                    |)
                                  ]
                                |)
                              ]
                            |)
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.get_struct_tuple_field_or_break_match (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Break",
                                    0
                                  |) in
                                let residual := M.copy (| γ0_0 |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      M.return_ (|
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::ops::try_trait::FromResidual",
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                                            [
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                [
                                                  Ty.path "core::convert::Infallible";
                                                  Ty.path "core::fmt::Error"
                                                ]
                                            ],
                                            "from_residual",
                                            []
                                          |),
                                          [ M.read (| residual |) ]
                                        |)
                                      |)
                                    |)
                                  |)
                                |)));
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.get_struct_tuple_field_or_break_match (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Continue",
                                    0
                                  |) in
                                let val := M.copy (| γ0_0 |) in
                                val))
                          ]
                        |) in
                      M.alloc (| Value.Tuple [] |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            let _ :=
              M.use
                (M.match_operator (|
                  M.alloc (|
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::iter::traits::collect::IntoIterator",
                        Ty.apply (Ty.path "&") [ Ty.apply (Ty.path "array") [ Ty.path "u8" ] ],
                        [],
                        "into_iter",
                        []
                      |),
                      [
                        M.get_struct_tuple_field
                          (M.read (| self |))
                          "move_core_types::account_address::AccountAddress"
                          0
                      ]
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let iter := M.copy (| γ |) in
                        M.loop (|
                          ltac:(M.monadic
                            (let _ :=
                              M.match_operator (|
                                M.alloc (|
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::iter::traits::iterator::Iterator",
                                      Ty.apply (Ty.path "core::slice::iter::Iter") [ Ty.path "u8" ],
                                      [],
                                      "next",
                                      []
                                    |),
                                    [ iter ]
                                  |)
                                |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (M.alloc (|
                                        M.never_to_any (| M.read (| M.break (||) |) |)
                                      |)));
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ0_0 :=
                                        M.get_struct_tuple_field_or_break_match (|
                                          γ,
                                          "core::option::Option::Some",
                                          0
                                        |) in
                                      let byte := M.copy (| γ0_0 |) in
                                      let _ :=
                                        M.match_operator (|
                                          M.alloc (|
                                            M.call_closure (|
                                              M.get_trait_method (|
                                                "core::ops::try_trait::Try",
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                                                [],
                                                "branch",
                                                []
                                              |),
                                              [
                                                M.call_closure (|
                                                  M.get_associated_function (|
                                                    Ty.path "core::fmt::Formatter",
                                                    "write_fmt",
                                                    []
                                                  |),
                                                  [
                                                    M.read (| f |);
                                                    M.call_closure (|
                                                      M.get_associated_function (|
                                                        Ty.path "core::fmt::Arguments",
                                                        "new_v1_formatted",
                                                        []
                                                      |),
                                                      [
                                                        (* Unsize *)
                                                        M.pointer_coercion
                                                          (M.alloc (|
                                                            Value.Array [ M.read (| mk_str "" |) ]
                                                          |));
                                                        (* Unsize *)
                                                        M.pointer_coercion
                                                          (M.alloc (|
                                                            Value.Array
                                                              [
                                                                M.call_closure (|
                                                                  M.get_associated_function (|
                                                                    Ty.path
                                                                      "core::fmt::rt::Argument",
                                                                    "new_upper_hex",
                                                                    [
                                                                      Ty.apply
                                                                        (Ty.path "&")
                                                                        [ Ty.path "u8" ]
                                                                    ]
                                                                  |),
                                                                  [ byte ]
                                                                |)
                                                              ]
                                                          |));
                                                        (* Unsize *)
                                                        M.pointer_coercion
                                                          (M.alloc (|
                                                            Value.Array
                                                              [
                                                                M.call_closure (|
                                                                  M.get_associated_function (|
                                                                    Ty.path
                                                                      "core::fmt::rt::Placeholder",
                                                                    "new",
                                                                    []
                                                                  |),
                                                                  [
                                                                    Value.Integer Integer.Usize 0;
                                                                    Value.UnicodeChar 32;
                                                                    Value.StructTuple
                                                                      "core::fmt::rt::Alignment::Unknown"
                                                                      [];
                                                                    Value.Integer Integer.U32 8;
                                                                    Value.StructTuple
                                                                      "core::fmt::rt::Count::Implied"
                                                                      [];
                                                                    Value.StructTuple
                                                                      "core::fmt::rt::Count::Is"
                                                                      [
                                                                        Value.Integer
                                                                          Integer.Usize
                                                                          2
                                                                      ]
                                                                  ]
                                                                |)
                                                              ]
                                                          |));
                                                        M.call_closure (|
                                                          M.get_associated_function (|
                                                            Ty.path "core::fmt::rt::UnsafeArg",
                                                            "new",
                                                            []
                                                          |),
                                                          []
                                                        |)
                                                      ]
                                                    |)
                                                  ]
                                                |)
                                              ]
                                            |)
                                          |),
                                          [
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let γ0_0 :=
                                                  M.get_struct_tuple_field_or_break_match (|
                                                    γ,
                                                    "core::ops::control_flow::ControlFlow::Break",
                                                    0
                                                  |) in
                                                let residual := M.copy (| γ0_0 |) in
                                                M.alloc (|
                                                  M.never_to_any (|
                                                    M.read (|
                                                      M.return_ (|
                                                        M.call_closure (|
                                                          M.get_trait_method (|
                                                            "core::ops::try_trait::FromResidual",
                                                            Ty.apply
                                                              (Ty.path "core::result::Result")
                                                              [
                                                                Ty.tuple [];
                                                                Ty.path "core::fmt::Error"
                                                              ],
                                                            [
                                                              Ty.apply
                                                                (Ty.path "core::result::Result")
                                                                [
                                                                  Ty.path
                                                                    "core::convert::Infallible";
                                                                  Ty.path "core::fmt::Error"
                                                                ]
                                                            ],
                                                            "from_residual",
                                                            []
                                                          |),
                                                          [ M.read (| residual |) ]
                                                        |)
                                                      |)
                                                    |)
                                                  |)
                                                |)));
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let γ0_0 :=
                                                  M.get_struct_tuple_field_or_break_match (|
                                                    γ,
                                                    "core::ops::control_flow::ControlFlow::Continue",
                                                    0
                                                  |) in
                                                let val := M.copy (| γ0_0 |) in
                                                val))
                                          ]
                                        |) in
                                      M.alloc (| Value.Tuple [] |)))
                                ]
                              |) in
                            M.alloc (| Value.Tuple [] |)))
                        |)))
                  ]
                |)) in
            M.alloc (| Value.StructTuple "core::result::Result::Ok" [ Value.Tuple [] ] |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::UpperHex"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_UpperHex_for_move_core_types_account_address_AccountAddress.
  
  Module Impl_core_convert_From_array_u8_for_move_core_types_account_address_AccountAddress.
    Definition Self : Ty.t := Ty.path "move_core_types::account_address::AccountAddress".
    
    (*
        fn from(bytes: [u8; AccountAddress::LENGTH]) -> Self {
            Self::new(bytes)
        }
    *)
    Definition from (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ bytes ] =>
        ltac:(M.monadic
          (let bytes := M.alloc (| bytes |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.path "move_core_types::account_address::AccountAddress",
              "new",
              []
            |),
            [ M.read (| bytes |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::convert::From"
        Self
        (* Trait polymorphic types *) [ (* T *) Ty.apply (Ty.path "array") [ Ty.path "u8" ] ]
        (* Instance *) [ ("from", InstanceField.Method from) ].
  End Impl_core_convert_From_array_u8_for_move_core_types_account_address_AccountAddress.
  
  Module Impl_core_convert_TryFrom_ref__slice_u8_for_move_core_types_account_address_AccountAddress.
    Definition Self : Ty.t := Ty.path "move_core_types::account_address::AccountAddress".
    
    (*     type Error = AccountAddressParseError; *)
    Definition _Error : Ty.t :=
      Ty.path "move_core_types::account_address::AccountAddressParseError".
    
    (*
        fn try_from(bytes: &[u8]) -> Result<AccountAddress, AccountAddressParseError> {
            Self::from_bytes(bytes)
        }
    *)
    Definition try_from (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ bytes ] =>
        ltac:(M.monadic
          (let bytes := M.alloc (| bytes |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.path "move_core_types::account_address::AccountAddress",
              "from_bytes",
              [ Ty.apply (Ty.path "&") [ Ty.apply (Ty.path "slice") [ Ty.path "u8" ] ] ]
            |),
            [ M.read (| bytes |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::convert::TryFrom"
        Self
        (* Trait polymorphic types *)
        [ (* T *) Ty.apply (Ty.path "&") [ Ty.apply (Ty.path "slice") [ Ty.path "u8" ] ] ]
        (* Instance *)
        [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
  End Impl_core_convert_TryFrom_ref__slice_u8_for_move_core_types_account_address_AccountAddress.
  
  Module Impl_core_convert_TryFrom_alloc_vec_Vec_u8_alloc_alloc_Global_for_move_core_types_account_address_AccountAddress.
    Definition Self : Ty.t := Ty.path "move_core_types::account_address::AccountAddress".
    
    (*     type Error = AccountAddressParseError; *)
    Definition _Error : Ty.t :=
      Ty.path "move_core_types::account_address::AccountAddressParseError".
    
    (*
        fn try_from(bytes: Vec<u8>) -> Result<AccountAddress, AccountAddressParseError> {
            Self::from_bytes(bytes)
        }
    *)
    Definition try_from (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ bytes ] =>
        ltac:(M.monadic
          (let bytes := M.alloc (| bytes |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.path "move_core_types::account_address::AccountAddress",
              "from_bytes",
              [
                Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
              ]
            |),
            [ M.read (| bytes |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::convert::TryFrom"
        Self
        (* Trait polymorphic types *)
        [
          (* T *)
          Ty.apply (Ty.path "alloc::vec::Vec") [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
        ]
        (* Instance *)
        [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
  End Impl_core_convert_TryFrom_alloc_vec_Vec_u8_alloc_alloc_Global_for_move_core_types_account_address_AccountAddress.
  
  Module Impl_core_convert_From_move_core_types_account_address_AccountAddress_for_alloc_vec_Vec_u8_alloc_alloc_Global.
    Definition Self : Ty.t :=
      Ty.apply (Ty.path "alloc::vec::Vec") [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn from(addr: AccountAddress) -> Vec<u8> {
            addr.0.to_vec()
        }
    *)
    Definition from (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ addr ] =>
        ltac:(M.monadic
          (let addr := M.alloc (| addr |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply (Ty.path "slice") [ Ty.path "u8" ],
              "to_vec",
              []
            |),
            [
              (* Unsize *)
              M.pointer_coercion
                (M.get_struct_tuple_field addr "move_core_types::account_address::AccountAddress" 0)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::convert::From"
        Self
        (* Trait polymorphic types *)
        [ (* T *) Ty.path "move_core_types::account_address::AccountAddress" ]
        (* Instance *) [ ("from", InstanceField.Method from) ].
  End Impl_core_convert_From_move_core_types_account_address_AccountAddress_for_alloc_vec_Vec_u8_alloc_alloc_Global.
  
  Module Impl_core_convert_From_ref__move_core_types_account_address_AccountAddress_for_alloc_vec_Vec_u8_alloc_alloc_Global.
    Definition Self : Ty.t :=
      Ty.apply (Ty.path "alloc::vec::Vec") [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn from(addr: &AccountAddress) -> Vec<u8> {
            addr.0.to_vec()
        }
    *)
    Definition from (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ addr ] =>
        ltac:(M.monadic
          (let addr := M.alloc (| addr |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply (Ty.path "slice") [ Ty.path "u8" ],
              "to_vec",
              []
            |),
            [
              (* Unsize *)
              M.pointer_coercion
                (M.get_struct_tuple_field
                  (M.read (| addr |))
                  "move_core_types::account_address::AccountAddress"
                  0)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::convert::From"
        Self
        (* Trait polymorphic types *)
        [
          (* T *)
          Ty.apply (Ty.path "&") [ Ty.path "move_core_types::account_address::AccountAddress" ]
        ]
        (* Instance *) [ ("from", InstanceField.Method from) ].
  End Impl_core_convert_From_ref__move_core_types_account_address_AccountAddress_for_alloc_vec_Vec_u8_alloc_alloc_Global.
  
  Module Impl_core_convert_From_move_core_types_account_address_AccountAddress_for_array_u8.
    Definition Self : Ty.t := Ty.apply (Ty.path "array") [ Ty.path "u8" ].
    
    (*
        fn from(addr: AccountAddress) -> Self {
            addr.0
        }
    *)
    Definition from (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ addr ] =>
        ltac:(M.monadic
          (let addr := M.alloc (| addr |) in
          M.read (|
            M.get_struct_tuple_field addr "move_core_types::account_address::AccountAddress" 0
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::convert::From"
        Self
        (* Trait polymorphic types *)
        [ (* T *) Ty.path "move_core_types::account_address::AccountAddress" ]
        (* Instance *) [ ("from", InstanceField.Method from) ].
  End Impl_core_convert_From_move_core_types_account_address_AccountAddress_for_array_u8.
  
  Module Impl_core_convert_From_ref__move_core_types_account_address_AccountAddress_for_array_u8.
    Definition Self : Ty.t := Ty.apply (Ty.path "array") [ Ty.path "u8" ].
    
    (*
        fn from(addr: &AccountAddress) -> Self {
            addr.0
        }
    *)
    Definition from (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ addr ] =>
        ltac:(M.monadic
          (let addr := M.alloc (| addr |) in
          M.read (|
            M.get_struct_tuple_field
              (M.read (| addr |))
              "move_core_types::account_address::AccountAddress"
              0
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::convert::From"
        Self
        (* Trait polymorphic types *)
        [
          (* T *)
          Ty.apply (Ty.path "&") [ Ty.path "move_core_types::account_address::AccountAddress" ]
        ]
        (* Instance *) [ ("from", InstanceField.Method from) ].
  End Impl_core_convert_From_ref__move_core_types_account_address_AccountAddress_for_array_u8.
  
  Module Impl_core_convert_From_ref__move_core_types_account_address_AccountAddress_for_alloc_string_String.
    Definition Self : Ty.t := Ty.path "alloc::string::String".
    
    (*
        fn from(addr: &AccountAddress) -> String {
            ::hex::encode(addr.as_ref())
        }
    *)
    Definition from (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ addr ] =>
        ltac:(M.monadic
          (let addr := M.alloc (| addr |) in
          M.call_closure (|
            M.get_function (|
              "hex::encode",
              [ Ty.apply (Ty.path "&") [ Ty.apply (Ty.path "slice") [ Ty.path "u8" ] ] ]
            |),
            [
              M.call_closure (|
                M.get_trait_method (|
                  "core::convert::AsRef",
                  Ty.path "move_core_types::account_address::AccountAddress",
                  [ Ty.apply (Ty.path "slice") [ Ty.path "u8" ] ],
                  "as_ref",
                  []
                |),
                [ M.read (| addr |) ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::convert::From"
        Self
        (* Trait polymorphic types *)
        [
          (* T *)
          Ty.apply (Ty.path "&") [ Ty.path "move_core_types::account_address::AccountAddress" ]
        ]
        (* Instance *) [ ("from", InstanceField.Method from) ].
  End Impl_core_convert_From_ref__move_core_types_account_address_AccountAddress_for_alloc_string_String.
  
  Module Impl_core_convert_TryFrom_alloc_string_String_for_move_core_types_account_address_AccountAddress.
    Definition Self : Ty.t := Ty.path "move_core_types::account_address::AccountAddress".
    
    (*     type Error = AccountAddressParseError; *)
    Definition _Error : Ty.t :=
      Ty.path "move_core_types::account_address::AccountAddressParseError".
    
    (*
        fn try_from(s: String) -> Result<AccountAddress, AccountAddressParseError> {
            Self::from_hex(s)
        }
    *)
    Definition try_from (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ s ] =>
        ltac:(M.monadic
          (let s := M.alloc (| s |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.path "move_core_types::account_address::AccountAddress",
              "from_hex",
              [ Ty.path "alloc::string::String" ]
            |),
            [ M.read (| s |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::convert::TryFrom"
        Self
        (* Trait polymorphic types *) [ (* T *) Ty.path "alloc::string::String" ]
        (* Instance *)
        [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
  End Impl_core_convert_TryFrom_alloc_string_String_for_move_core_types_account_address_AccountAddress.
  
  Module Impl_core_str_traits_FromStr_for_move_core_types_account_address_AccountAddress.
    Definition Self : Ty.t := Ty.path "move_core_types::account_address::AccountAddress".
    
    (*     type Err = AccountAddressParseError; *)
    Definition _Err : Ty.t := Ty.path "move_core_types::account_address::AccountAddressParseError".
    
    (*
        fn from_str(s: &str) -> Result<Self, AccountAddressParseError> {
            // Accept 0xADDRESS or ADDRESS
            if let Ok(address) = AccountAddress::from_hex_literal(s) {
                Ok(address)
            } else {
                Self::from_hex(s)
            }
        }
    *)
    Definition from_str (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ s ] =>
        ltac:(M.monadic
          (let s := M.alloc (| s |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.path "move_core_types::account_address::AccountAddress",
                            "from_hex_literal",
                            []
                          |),
                          [ M.read (| s |) ]
                        |)
                      |) in
                    let γ0_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "core::result::Result::Ok",
                        0
                      |) in
                    let address := M.copy (| γ0_0 |) in
                    M.alloc (|
                      Value.StructTuple "core::result::Result::Ok" [ M.read (| address |) ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "move_core_types::account_address::AccountAddress",
                          "from_hex",
                          [ Ty.apply (Ty.path "&") [ Ty.path "str" ] ]
                        |),
                        [ M.read (| s |) ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::str::traits::FromStr"
        Self
        (* Trait polymorphic types *) []
        (* Instance *)
        [ ("Err", InstanceField.Ty _Err); ("from_str", InstanceField.Method from_str) ].
  End Impl_core_str_traits_FromStr_for_move_core_types_account_address_AccountAddress.
  
  Module Impl_serde_de_Deserialize_for_move_core_types_account_address_AccountAddress.
    Definition Self : Ty.t := Ty.path "move_core_types::account_address::AccountAddress".
    
    (*
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: Deserializer<'de>,
        {
            if deserializer.is_human_readable() {
                let s = <String>::deserialize(deserializer)?;
                AccountAddress::from_str(&s).map_err(D::Error::custom)
            } else {
                // In order to preserve the Serde data model and help analysis tools,
                // make sure to wrap our value in a container with the same name
                // as the original type.
                #[derive(::serde::Deserialize)]
                #[serde(rename = "AccountAddress")]
                struct Value([u8; AccountAddress::LENGTH]);
    
                let value = Value::deserialize(deserializer)?;
                Ok(AccountAddress::new(value.0))
            }
        }
    *)
    Definition deserialize (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ D ], [ deserializer ] =>
        ltac:(M.monadic
          (let deserializer := M.alloc (| deserializer |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (|
                              "serde::de::Deserializer",
                              D,
                              [],
                              "is_human_readable",
                              []
                            |),
                            [ deserializer ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    let s :=
                      M.copy (|
                        M.match_operator (|
                          M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::ops::try_trait::Try",
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  [ Ty.path "alloc::string::String"; Ty.associated ],
                                [],
                                "branch",
                                []
                              |),
                              [
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "serde::de::Deserialize",
                                    Ty.path "alloc::string::String",
                                    [],
                                    "deserialize",
                                    [ D ]
                                  |),
                                  [ M.read (| deserializer |) ]
                                |)
                              ]
                            |)
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.get_struct_tuple_field_or_break_match (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Break",
                                    0
                                  |) in
                                let residual := M.copy (| γ0_0 |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      M.return_ (|
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::ops::try_trait::FromResidual",
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              [
                                                Ty.path
                                                  "move_core_types::account_address::AccountAddress";
                                                Ty.associated
                                              ],
                                            [
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                [ Ty.path "core::convert::Infallible"; Ty.associated
                                                ]
                                            ],
                                            "from_residual",
                                            []
                                          |),
                                          [ M.read (| residual |) ]
                                        |)
                                      |)
                                    |)
                                  |)
                                |)));
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.get_struct_tuple_field_or_break_match (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Continue",
                                    0
                                  |) in
                                let val := M.copy (| γ0_0 |) in
                                val))
                          ]
                        |)
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "core::result::Result")
                            [
                              Ty.path "move_core_types::account_address::AccountAddress";
                              Ty.path "move_core_types::account_address::AccountAddressParseError"
                            ],
                          "map_err",
                          [
                            Ty.associated;
                            Ty.function
                              [ Ty.path "move_core_types::account_address::AccountAddressParseError"
                              ]
                              Ty.associated
                          ]
                        |),
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::str::traits::FromStr",
                              Ty.path "move_core_types::account_address::AccountAddress",
                              [],
                              "from_str",
                              []
                            |),
                            [
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::ops::deref::Deref",
                                  Ty.path "alloc::string::String",
                                  [],
                                  "deref",
                                  []
                                |),
                                [ s ]
                              |)
                            ]
                          |);
                          M.get_trait_method (|
                            "serde::de::Error",
                            Ty.associated,
                            [],
                            "custom",
                            [ Ty.path "move_core_types::account_address::AccountAddressParseError" ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let value :=
                      M.copy (|
                        M.match_operator (|
                          M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::ops::try_trait::Try",
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  [
                                    Ty.path "move_core_types::account_address::deserialize::Value";
                                    Ty.associated
                                  ],
                                [],
                                "branch",
                                []
                              |),
                              [
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "serde::de::Deserialize",
                                    Ty.path "move_core_types::account_address::deserialize::Value",
                                    [],
                                    "deserialize",
                                    [ D ]
                                  |),
                                  [ M.read (| deserializer |) ]
                                |)
                              ]
                            |)
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.get_struct_tuple_field_or_break_match (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Break",
                                    0
                                  |) in
                                let residual := M.copy (| γ0_0 |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      M.return_ (|
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::ops::try_trait::FromResidual",
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              [
                                                Ty.path
                                                  "move_core_types::account_address::AccountAddress";
                                                Ty.associated
                                              ],
                                            [
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                [ Ty.path "core::convert::Infallible"; Ty.associated
                                                ]
                                            ],
                                            "from_residual",
                                            []
                                          |),
                                          [ M.read (| residual |) ]
                                        |)
                                      |)
                                    |)
                                  |)
                                |)));
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.get_struct_tuple_field_or_break_match (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Continue",
                                    0
                                  |) in
                                let val := M.copy (| γ0_0 |) in
                                val))
                          ]
                        |)
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "move_core_types::account_address::AccountAddress",
                              "new",
                              []
                            |),
                            [
                              M.read (|
                                M.get_struct_tuple_field
                                  value
                                  "move_core_types::account_address::deserialize::Value"
                                  0
                              |)
                            ]
                          |)
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "serde::de::Deserialize"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("deserialize", InstanceField.Method deserialize) ].
  End Impl_serde_de_Deserialize_for_move_core_types_account_address_AccountAddress.
  
  Module Impl_serde_ser_Serialize_for_move_core_types_account_address_AccountAddress.
    Definition Self : Ty.t := Ty.path "move_core_types::account_address::AccountAddress".
    
    (*
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: Serializer,
        {
            if serializer.is_human_readable() {
                self.to_hex().serialize(serializer)
            } else {
                // See comment in deserialize.
                serializer.serialize_newtype_struct("AccountAddress", &self.0)
            }
        }
    *)
    Definition serialize (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ _ as S ], [ self; serializer ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let serializer := M.alloc (| serializer |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (|
                              "serde::ser::Serializer",
                              S,
                              [],
                              "is_human_readable",
                              []
                            |),
                            [ serializer ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "serde::ser::Serialize",
                          Ty.path "alloc::string::String",
                          [],
                          "serialize",
                          [ S ]
                        |),
                        [
                          M.alloc (|
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "move_core_types::account_address::AccountAddress",
                                "to_hex",
                                []
                              |),
                              [ M.read (| self |) ]
                            |)
                          |);
                          M.read (| serializer |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "serde::ser::Serializer",
                          S,
                          [],
                          "serialize_newtype_struct",
                          [ Ty.apply (Ty.path "array") [ Ty.path "u8" ] ]
                        |),
                        [
                          M.read (| serializer |);
                          M.read (| mk_str "AccountAddress" |);
                          M.get_struct_tuple_field
                            (M.read (| self |))
                            "move_core_types::account_address::AccountAddress"
                            0
                        ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "serde::ser::Serialize"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("serialize", InstanceField.Method serialize) ].
  End Impl_serde_ser_Serialize_for_move_core_types_account_address_AccountAddress.
  
  (* StructTuple
    {
      name := "AccountAddressParseError";
      ty_params := [];
      fields := [];
    } *)
  
  Module Impl_core_clone_Clone_for_move_core_types_account_address_AccountAddressParseError.
    Definition Self : Ty.t := Ty.path "move_core_types::account_address::AccountAddressParseError".
    
    (* Clone *)
    Definition clone (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (| M.read (| self |) |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_move_core_types_account_address_AccountAddressParseError.
  
  Module Impl_core_marker_Copy_for_move_core_types_account_address_AccountAddressParseError.
    Definition Self : Ty.t := Ty.path "move_core_types::account_address::AccountAddressParseError".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::Copy"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_Copy_for_move_core_types_account_address_AccountAddressParseError.
  
  Module Impl_core_fmt_Debug_for_move_core_types_account_address_AccountAddressParseError.
    Definition Self : Ty.t := Ty.path "move_core_types::account_address::AccountAddressParseError".
    
    (* Debug *)
    Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_str", [] |),
            [ M.read (| f |); M.read (| mk_str "AccountAddressParseError" |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_move_core_types_account_address_AccountAddressParseError.
  
  Module Impl_core_fmt_Display_for_move_core_types_account_address_AccountAddressParseError.
    Definition Self : Ty.t := Ty.path "move_core_types::account_address::AccountAddressParseError".
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter) -> std::fmt::Result {
            write!(
                f,
                "Unable to parse AccountAddress (must be hex string of length {})",
                AccountAddress::LENGTH
            )
        }
    *)
    Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_fmt", [] |),
            [
              M.read (| f |);
              M.call_closure (|
                M.get_associated_function (| Ty.path "core::fmt::Arguments", "new_v1", [] |),
                [
                  (* Unsize *)
                  M.pointer_coercion
                    (M.alloc (|
                      Value.Array
                        [
                          M.read (|
                            mk_str "Unable to parse AccountAddress (must be hex string of length "
                          |);
                          M.read (| mk_str ")" |)
                        ]
                    |));
                  (* Unsize *)
                  M.pointer_coercion
                    (M.alloc (|
                      Value.Array
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::rt::Argument",
                              "new_display",
                              [ Ty.path "usize" ]
                            |),
                            [ M.get_constant (| "move_core_types::account_address::LENGTH" |) ]
                          |)
                        ]
                    |))
                ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Display"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Display_for_move_core_types_account_address_AccountAddressParseError.
  
  Module Impl_core_error_Error_for_move_core_types_account_address_AccountAddressParseError.
    Definition Self : Ty.t := Ty.path "move_core_types::account_address::AccountAddressParseError".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::error::Error"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_error_Error_for_move_core_types_account_address_AccountAddressParseError.
End account_address.

Module effects.
  (*
  Enum Op
  {
    ty_params := [ "T" ];
    variants :=
      [
        {
          name := "New";
          item := StructTuple [ T ];
          discriminant := None;
        };
        {
          name := "Modify";
          item := StructTuple [ T ];
          discriminant := None;
        };
        {
          name := "Delete";
          item := StructTuple [];
          discriminant := None;
        }
      ];
  }
  *)
  
  Module Impl_core_fmt_Debug_for_move_core_types_effects_Op_T.
    Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "move_core_types::effects::Op") [ T ].
    
    (* Debug *)
    Definition fmt (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::effects::Op::New",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_tuple_field1_finish",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.read (| mk_str "New" |);
                          (* Unsize *) M.pointer_coercion __self_0
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::effects::Op::Modify",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_tuple_field1_finish",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.read (| mk_str "Modify" |);
                          (* Unsize *) M.pointer_coercion __self_0
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| mk_str "Delete" |) ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::fmt::Debug"
        (Self T)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method (fmt T)) ].
  End Impl_core_fmt_Debug_for_move_core_types_effects_Op_T.
  
  Module Impl_core_clone_Clone_for_move_core_types_effects_Op_T.
    Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "move_core_types::effects::Op") [ T ].
    
    (* Clone *)
    Definition clone (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::effects::Op::New",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_core_types::effects::Op::New"
                        [
                          M.call_closure (|
                            M.get_trait_method (| "core::clone::Clone", T, [], "clone", [] |),
                            [ M.read (| __self_0 |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::effects::Op::Modify",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_core_types::effects::Op::Modify"
                        [
                          M.call_closure (|
                            M.get_trait_method (| "core::clone::Clone", T, [], "clone", [] |),
                            [ M.read (| __self_0 |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (| Value.StructTuple "move_core_types::effects::Op::Delete" [] |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::clone::Clone"
        (Self T)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("clone", InstanceField.Method (clone T)) ].
  End Impl_core_clone_Clone_for_move_core_types_effects_Op_T.
  
  Module Impl_core_marker_StructuralEq_for_move_core_types_effects_Op_T.
    Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "move_core_types::effects::Op") [ T ].
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::marker::StructuralEq"
        (Self T)
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralEq_for_move_core_types_effects_Op_T.
  
  Module Impl_core_cmp_Eq_for_move_core_types_effects_Op_T.
    Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "move_core_types::effects::Op") [ T ].
    
    (* Eq *)
    Definition assert_receiver_is_total_eq (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Value.DeclaredButUndefined,
              [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::cmp::Eq"
        (Self T)
        (* Trait polymorphic types *) []
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method (assert_receiver_is_total_eq T)) ].
  End Impl_core_cmp_Eq_for_move_core_types_effects_Op_T.
  
  Module Impl_core_marker_StructuralPartialEq_for_move_core_types_effects_Op_T.
    Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "move_core_types::effects::Op") [ T ].
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        (Self T)
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_move_core_types_effects_Op_T.
  
  Module Impl_core_cmp_PartialEq_for_move_core_types_effects_Op_T.
    Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "move_core_types::effects::Op") [ T ].
    
    (* PartialEq *)
    Definition eq (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            let __self_tag :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [ Ty.apply (Ty.path "move_core_types::effects::Op") [ T ] ]
                  |),
                  [ M.read (| self |) ]
                |)
              |) in
            let __arg1_tag :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [ Ty.apply (Ty.path "move_core_types::effects::Op") [ T ] ]
                  |),
                  [ M.read (| other |) ]
                |)
              |) in
            M.alloc (|
              LogicalOp.and (|
                BinOp.Pure.eq (M.read (| __self_tag |)) (M.read (| __arg1_tag |)),
                ltac:(M.monadic
                  (M.read (|
                    M.match_operator (|
                      M.alloc (| Value.Tuple [ M.read (| self |); M.read (| other |) ] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.get_tuple_field γ 0 in
                            let γ0_1 := M.get_tuple_field γ 1 in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ0_0,
                                "move_core_types::effects::Op::New",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ0_1,
                                "move_core_types::effects::Op::New",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (| "core::cmp::PartialEq", T, [ T ], "eq", [] |),
                                [ M.read (| __self_0 |); M.read (| __arg1_0 |) ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.get_tuple_field γ 0 in
                            let γ0_1 := M.get_tuple_field γ 1 in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ0_0,
                                "move_core_types::effects::Op::Modify",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ0_1,
                                "move_core_types::effects::Op::Modify",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (| "core::cmp::PartialEq", T, [ T ], "eq", [] |),
                                [ M.read (| __self_0 |); M.read (| __arg1_0 |) ]
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Bool true |)))
                      ]
                    |)
                  |)))
              |)
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (Self T)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("eq", InstanceField.Method (eq T)) ].
  End Impl_core_cmp_PartialEq_for_move_core_types_effects_Op_T.
  
  Module Impl_core_cmp_Ord_for_move_core_types_effects_Op_T.
    Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "move_core_types::effects::Op") [ T ].
    
    (* Ord *)
    Definition cmp (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            let __self_tag :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [ Ty.apply (Ty.path "move_core_types::effects::Op") [ T ] ]
                  |),
                  [ M.read (| self |) ]
                |)
              |) in
            let __arg1_tag :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [ Ty.apply (Ty.path "move_core_types::effects::Op") [ T ] ]
                  |),
                  [ M.read (| other |) ]
                |)
              |) in
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (| "core::cmp::Ord", Ty.path "isize", [], "cmp", [] |),
                  [ __self_tag; __arg1_tag ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      M.alloc (| Value.Tuple [ M.read (| self |); M.read (| other |) ] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.get_tuple_field γ 0 in
                            let γ0_1 := M.get_tuple_field γ 1 in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ0_0,
                                "move_core_types::effects::Op::New",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ0_1,
                                "move_core_types::effects::Op::New",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (| "core::cmp::Ord", T, [], "cmp", [] |),
                                [ M.read (| __self_0 |); M.read (| __arg1_0 |) ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.get_tuple_field γ 0 in
                            let γ0_1 := M.get_tuple_field γ 1 in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ0_0,
                                "move_core_types::effects::Op::Modify",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ0_1,
                                "move_core_types::effects::Op::Modify",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (| "core::cmp::Ord", T, [], "cmp", [] |),
                                [ M.read (| __self_0 |); M.read (| __arg1_0 |) ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (| Value.StructTuple "core::cmp::Ordering::Equal" [] |)))
                      ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let cmp := M.copy (| γ |) in
                    cmp))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::cmp::Ord"
        (Self T)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("cmp", InstanceField.Method (cmp T)) ].
  End Impl_core_cmp_Ord_for_move_core_types_effects_Op_T.
  
  Module Impl_core_cmp_PartialOrd_for_move_core_types_effects_Op_T.
    Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "move_core_types::effects::Op") [ T ].
    
    (* PartialOrd *)
    Definition partial_cmp (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            let __self_tag :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [ Ty.apply (Ty.path "move_core_types::effects::Op") [ T ] ]
                  |),
                  [ M.read (| self |) ]
                |)
              |) in
            let __arg1_tag :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [ Ty.apply (Ty.path "move_core_types::effects::Op") [ T ] ]
                  |),
                  [ M.read (| other |) ]
                |)
              |) in
            M.match_operator (|
              M.alloc (| Value.Tuple [ M.read (| self |); M.read (| other |) ] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.get_tuple_field γ 0 in
                    let γ0_1 := M.get_tuple_field γ 1 in
                    let γ0_0 := M.read (| γ0_0 |) in
                    let γ2_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ0_0,
                        "move_core_types::effects::Op::New",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ2_0 |) in
                    let γ0_1 := M.read (| γ0_1 |) in
                    let γ2_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ0_1,
                        "move_core_types::effects::Op::New",
                        0
                      |) in
                    let __arg1_0 := M.alloc (| γ2_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::cmp::PartialOrd",
                          T,
                          [ T ],
                          "partial_cmp",
                          []
                        |),
                        [ M.read (| __self_0 |); M.read (| __arg1_0 |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.get_tuple_field γ 0 in
                    let γ0_1 := M.get_tuple_field γ 1 in
                    let γ0_0 := M.read (| γ0_0 |) in
                    let γ2_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ0_0,
                        "move_core_types::effects::Op::Modify",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ2_0 |) in
                    let γ0_1 := M.read (| γ0_1 |) in
                    let γ2_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ0_1,
                        "move_core_types::effects::Op::Modify",
                        0
                      |) in
                    let __arg1_0 := M.alloc (| γ2_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::cmp::PartialOrd",
                          T,
                          [ T ],
                          "partial_cmp",
                          []
                        |),
                        [ M.read (| __self_0 |); M.read (| __arg1_0 |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::cmp::PartialOrd",
                          Ty.path "isize",
                          [ Ty.path "isize" ],
                          "partial_cmp",
                          []
                        |),
                        [ __self_tag; __arg1_tag ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "core::cmp::PartialOrd"
        (Self T)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("partial_cmp", InstanceField.Method (partial_cmp T)) ].
  End Impl_core_cmp_PartialOrd_for_move_core_types_effects_Op_T.
  
  Module Impl_move_core_types_effects_Op_T.
    Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "move_core_types::effects::Op") [ T ].
    
    (*
        pub fn as_ref(&self) -> Op<&T> {
            use Op::*;
    
            match self {
                New(data) => New(data),
                Modify(data) => Modify(data),
                Delete => Delete,
            }
        }
    *)
    Definition as_ref (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::effects::Op::New",
                        0
                      |) in
                    let data := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple "move_core_types::effects::Op::New" [ M.read (| data |) ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::effects::Op::Modify",
                        0
                      |) in
                    let data := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple "move_core_types::effects::Op::Modify" [ M.read (| data |) ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (| Value.StructTuple "move_core_types::effects::Op::Delete" [] |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_as_ref :
      forall (T : Ty.t),
      M.IsAssociatedFunction (Self T) "as_ref" (as_ref T).
    
    (*
        pub fn map<F, U>(self, f: F) -> Op<U>
        where
            F: FnOnce(T) -> U,
        {
            use Op::*;
    
            match self {
                New(data) => New(f(data)),
                Modify(data) => Modify(f(data)),
                Delete => Delete,
            }
        }
    *)
    Definition map (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [ F; U ], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::effects::Op::New",
                        0
                      |) in
                    let data := M.copy (| γ0_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_core_types::effects::Op::New"
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::ops::function::FnOnce",
                              F,
                              [ Ty.tuple [ T ] ],
                              "call_once",
                              []
                            |),
                            [ M.read (| f |); Value.Tuple [ M.read (| data |) ] ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::effects::Op::Modify",
                        0
                      |) in
                    let data := M.copy (| γ0_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_core_types::effects::Op::Modify"
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::ops::function::FnOnce",
                              F,
                              [ Ty.tuple [ T ] ],
                              "call_once",
                              []
                            |),
                            [ M.read (| f |); Value.Tuple [ M.read (| data |) ] ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (| Value.StructTuple "move_core_types::effects::Op::Delete" [] |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_map : forall (T : Ty.t), M.IsAssociatedFunction (Self T) "map" (map T).
    
    (*
        pub fn ok(self) -> Option<T> {
            use Op::*;
    
            match self {
                New(data) | Modify(data) => Some(data),
                Delete => None,
            }
        }
    *)
    Definition ok (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.find_or_pattern (|
                      γ,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ,
                                "move_core_types::effects::Op::New",
                                0
                              |) in
                            let data := M.copy (| γ0_0 |) in
                            Value.Tuple [ data ]));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ,
                                "move_core_types::effects::Op::Modify",
                                0
                              |) in
                            let data := M.copy (| γ0_0 |) in
                            Value.Tuple [ data ]))
                      ],
                      M.closure
                        (fun γ =>
                          ltac:(M.monadic
                            match γ with
                            | [ data ] =>
                              M.alloc (|
                                Value.StructTuple "core::option::Option::Some" [ M.read (| data |) ]
                              |)
                            | _ => M.impossible (||)
                            end))
                    |)));
                fun γ =>
                  ltac:(M.monadic (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_ok : forall (T : Ty.t), M.IsAssociatedFunction (Self T) "ok" (ok T).
  End Impl_move_core_types_effects_Op_T.
  
  (* StructRecord
    {
      name := "AccountChangeSet";
      ty_params := [];
      fields :=
        [
          ("modules",
            Ty.apply
              (Ty.path "alloc::collections::btree::map::BTreeMap")
              [
                Ty.path "move_core_types::identifier::Identifier";
                Ty.apply
                  (Ty.path "move_core_types::effects::Op")
                  [
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                  ];
                Ty.path "alloc::alloc::Global"
              ]);
          ("resources",
            Ty.apply
              (Ty.path "alloc::collections::btree::map::BTreeMap")
              [
                Ty.path "move_core_types::language_storage::StructTag";
                Ty.apply
                  (Ty.path "move_core_types::effects::Op")
                  [
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                  ];
                Ty.path "alloc::alloc::Global"
              ])
        ];
    } *)
  
  Module Impl_core_fmt_Debug_for_move_core_types_effects_AccountChangeSet.
    Definition Self : Ty.t := Ty.path "move_core_types::effects::AccountChangeSet".
    
    (* Debug *)
    Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.path "core::fmt::Formatter",
              "debug_struct_field2_finish",
              []
            |),
            [
              M.read (| f |);
              M.read (| mk_str "AccountChangeSet" |);
              M.read (| mk_str "modules" |);
              (* Unsize *)
              M.pointer_coercion
                (M.get_struct_record_field
                  (M.read (| self |))
                  "move_core_types::effects::AccountChangeSet"
                  "modules");
              M.read (| mk_str "resources" |);
              (* Unsize *)
              M.pointer_coercion
                (M.alloc (|
                  M.get_struct_record_field
                    (M.read (| self |))
                    "move_core_types::effects::AccountChangeSet"
                    "resources"
                |))
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_move_core_types_effects_AccountChangeSet.
  
  Module Impl_core_clone_Clone_for_move_core_types_effects_AccountChangeSet.
    Definition Self : Ty.t := Ty.path "move_core_types::effects::AccountChangeSet".
    
    (* Clone *)
    Definition clone (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.StructRecord
            "move_core_types::effects::AccountChangeSet"
            [
              ("modules",
                M.call_closure (|
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.apply
                      (Ty.path "alloc::collections::btree::map::BTreeMap")
                      [
                        Ty.path "move_core_types::identifier::Identifier";
                        Ty.apply
                          (Ty.path "move_core_types::effects::Op")
                          [
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                          ];
                        Ty.path "alloc::alloc::Global"
                      ],
                    [],
                    "clone",
                    []
                  |),
                  [
                    M.get_struct_record_field
                      (M.read (| self |))
                      "move_core_types::effects::AccountChangeSet"
                      "modules"
                  ]
                |));
              ("resources",
                M.call_closure (|
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.apply
                      (Ty.path "alloc::collections::btree::map::BTreeMap")
                      [
                        Ty.path "move_core_types::language_storage::StructTag";
                        Ty.apply
                          (Ty.path "move_core_types::effects::Op")
                          [
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                          ];
                        Ty.path "alloc::alloc::Global"
                      ],
                    [],
                    "clone",
                    []
                  |),
                  [
                    M.get_struct_record_field
                      (M.read (| self |))
                      "move_core_types::effects::AccountChangeSet"
                      "resources"
                  ]
                |))
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_move_core_types_effects_AccountChangeSet.
  
  Module Impl_core_marker_StructuralEq_for_move_core_types_effects_AccountChangeSet.
    Definition Self : Ty.t := Ty.path "move_core_types::effects::AccountChangeSet".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralEq_for_move_core_types_effects_AccountChangeSet.
  
  Module Impl_core_cmp_Eq_for_move_core_types_effects_AccountChangeSet.
    Definition Self : Ty.t := Ty.path "move_core_types::effects::AccountChangeSet".
    
    (* Eq *)
    Definition assert_receiver_is_total_eq (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Value.DeclaredButUndefined,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      Value.DeclaredButUndefined,
                      [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_move_core_types_effects_AccountChangeSet.
  
  Module Impl_core_marker_StructuralPartialEq_for_move_core_types_effects_AccountChangeSet.
    Definition Self : Ty.t := Ty.path "move_core_types::effects::AccountChangeSet".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_move_core_types_effects_AccountChangeSet.
  
  Module Impl_core_cmp_PartialEq_for_move_core_types_effects_AccountChangeSet.
    Definition Self : Ty.t := Ty.path "move_core_types::effects::AccountChangeSet".
    
    (* PartialEq *)
    Definition eq (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          LogicalOp.and (|
            M.call_closure (|
              M.get_trait_method (|
                "core::cmp::PartialEq",
                Ty.apply
                  (Ty.path "alloc::collections::btree::map::BTreeMap")
                  [
                    Ty.path "move_core_types::identifier::Identifier";
                    Ty.apply
                      (Ty.path "move_core_types::effects::Op")
                      [
                        Ty.apply
                          (Ty.path "alloc::vec::Vec")
                          [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                      ];
                    Ty.path "alloc::alloc::Global"
                  ],
                [
                  Ty.apply
                    (Ty.path "alloc::collections::btree::map::BTreeMap")
                    [
                      Ty.path "move_core_types::identifier::Identifier";
                      Ty.apply
                        (Ty.path "move_core_types::effects::Op")
                        [
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                        ];
                      Ty.path "alloc::alloc::Global"
                    ]
                ],
                "eq",
                []
              |),
              [
                M.get_struct_record_field
                  (M.read (| self |))
                  "move_core_types::effects::AccountChangeSet"
                  "modules";
                M.get_struct_record_field
                  (M.read (| other |))
                  "move_core_types::effects::AccountChangeSet"
                  "modules"
              ]
            |),
            ltac:(M.monadic
              (M.call_closure (|
                M.get_trait_method (|
                  "core::cmp::PartialEq",
                  Ty.apply
                    (Ty.path "alloc::collections::btree::map::BTreeMap")
                    [
                      Ty.path "move_core_types::language_storage::StructTag";
                      Ty.apply
                        (Ty.path "move_core_types::effects::Op")
                        [
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                        ];
                      Ty.path "alloc::alloc::Global"
                    ],
                  [
                    Ty.apply
                      (Ty.path "alloc::collections::btree::map::BTreeMap")
                      [
                        Ty.path "move_core_types::language_storage::StructTag";
                        Ty.apply
                          (Ty.path "move_core_types::effects::Op")
                          [
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                          ];
                        Ty.path "alloc::alloc::Global"
                      ]
                  ],
                  "eq",
                  []
                |),
                [
                  M.get_struct_record_field
                    (M.read (| self |))
                    "move_core_types::effects::AccountChangeSet"
                    "resources";
                  M.get_struct_record_field
                    (M.read (| other |))
                    "move_core_types::effects::AccountChangeSet"
                    "resources"
                ]
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_for_move_core_types_effects_AccountChangeSet.
  
  Module Impl_core_cmp_Ord_for_move_core_types_effects_AccountChangeSet.
    Definition Self : Ty.t := Ty.path "move_core_types::effects::AccountChangeSet".
    
    (* Ord *)
    Definition cmp (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "core::cmp::Ord",
                    Ty.apply
                      (Ty.path "alloc::collections::btree::map::BTreeMap")
                      [
                        Ty.path "move_core_types::identifier::Identifier";
                        Ty.apply
                          (Ty.path "move_core_types::effects::Op")
                          [
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                          ];
                        Ty.path "alloc::alloc::Global"
                      ],
                    [],
                    "cmp",
                    []
                  |),
                  [
                    M.get_struct_record_field
                      (M.read (| self |))
                      "move_core_types::effects::AccountChangeSet"
                      "modules";
                    M.get_struct_record_field
                      (M.read (| other |))
                      "move_core_types::effects::AccountChangeSet"
                      "modules"
                  ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::cmp::Ord",
                          Ty.apply
                            (Ty.path "alloc::collections::btree::map::BTreeMap")
                            [
                              Ty.path "move_core_types::language_storage::StructTag";
                              Ty.apply
                                (Ty.path "move_core_types::effects::Op")
                                [
                                  Ty.apply
                                    (Ty.path "alloc::vec::Vec")
                                    [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                                ];
                              Ty.path "alloc::alloc::Global"
                            ],
                          [],
                          "cmp",
                          []
                        |),
                        [
                          M.get_struct_record_field
                            (M.read (| self |))
                            "move_core_types::effects::AccountChangeSet"
                            "resources";
                          M.get_struct_record_field
                            (M.read (| other |))
                            "move_core_types::effects::AccountChangeSet"
                            "resources"
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let cmp := M.copy (| γ |) in
                    cmp))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Ord"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("cmp", InstanceField.Method cmp) ].
  End Impl_core_cmp_Ord_for_move_core_types_effects_AccountChangeSet.
  
  Module Impl_core_cmp_PartialOrd_for_move_core_types_effects_AccountChangeSet.
    Definition Self : Ty.t := Ty.path "move_core_types::effects::AccountChangeSet".
    
    (* PartialOrd *)
    Definition partial_cmp (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "core::cmp::PartialOrd",
                    Ty.apply
                      (Ty.path "alloc::collections::btree::map::BTreeMap")
                      [
                        Ty.path "move_core_types::identifier::Identifier";
                        Ty.apply
                          (Ty.path "move_core_types::effects::Op")
                          [
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                          ];
                        Ty.path "alloc::alloc::Global"
                      ],
                    [
                      Ty.apply
                        (Ty.path "alloc::collections::btree::map::BTreeMap")
                        [
                          Ty.path "move_core_types::identifier::Identifier";
                          Ty.apply
                            (Ty.path "move_core_types::effects::Op")
                            [
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                            ];
                          Ty.path "alloc::alloc::Global"
                        ]
                    ],
                    "partial_cmp",
                    []
                  |),
                  [
                    M.get_struct_record_field
                      (M.read (| self |))
                      "move_core_types::effects::AccountChangeSet"
                      "modules";
                    M.get_struct_record_field
                      (M.read (| other |))
                      "move_core_types::effects::AccountChangeSet"
                      "modules"
                  ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::cmp::PartialOrd",
                          Ty.apply
                            (Ty.path "alloc::collections::btree::map::BTreeMap")
                            [
                              Ty.path "move_core_types::language_storage::StructTag";
                              Ty.apply
                                (Ty.path "move_core_types::effects::Op")
                                [
                                  Ty.apply
                                    (Ty.path "alloc::vec::Vec")
                                    [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                                ];
                              Ty.path "alloc::alloc::Global"
                            ],
                          [
                            Ty.apply
                              (Ty.path "alloc::collections::btree::map::BTreeMap")
                              [
                                Ty.path "move_core_types::language_storage::StructTag";
                                Ty.apply
                                  (Ty.path "move_core_types::effects::Op")
                                  [
                                    Ty.apply
                                      (Ty.path "alloc::vec::Vec")
                                      [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                                  ];
                                Ty.path "alloc::alloc::Global"
                              ]
                          ],
                          "partial_cmp",
                          []
                        |),
                        [
                          M.get_struct_record_field
                            (M.read (| self |))
                            "move_core_types::effects::AccountChangeSet"
                            "resources";
                          M.get_struct_record_field
                            (M.read (| other |))
                            "move_core_types::effects::AccountChangeSet"
                            "resources"
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let cmp := M.copy (| γ |) in
                    cmp))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialOrd"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("partial_cmp", InstanceField.Method partial_cmp) ].
  End Impl_core_cmp_PartialOrd_for_move_core_types_effects_AccountChangeSet.
  
  (*
  fn squash<K, V>(map: &mut BTreeMap<K, Op<V>>, other: BTreeMap<K, Op<V>>) -> Result<()>
  where
      K: Ord,
  {
      use btree_map::Entry::*;
      use Op::*;
  
      for (key, op) in other.into_iter() {
          match map.entry(key) {
              Occupied(mut entry) => {
                  let r = entry.get_mut();
                  match (r.as_ref(), op) {
                      (Modify(_) | New(_), New(_)) | (Delete, Delete | Modify(_)) => {
                          bail!("The given change sets cannot be squashed")
                      }
                      (Modify(_), Modify(data)) => *r = Modify(data),
                      (New(_), Modify(data)) => *r = New(data),
                      (Modify(_), Delete) => *r = Delete,
                      (Delete, New(data)) => *r = Modify(data),
                      (New(_), Delete) => {
                          entry.remove();
                      }
                  }
              }
              Vacant(entry) => {
                  entry.insert(op);
              }
          }
      }
  
      Ok(())
  }
  *)
  Definition squash (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [ K; V ], [ map; other ] =>
      ltac:(M.monadic
        (let map := M.alloc (| map |) in
        let other := M.alloc (| other |) in
        M.read (|
          let _ :=
            M.use
              (M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::iter::traits::collect::IntoIterator",
                      Ty.apply
                        (Ty.path "alloc::collections::btree::map::IntoIter")
                        [
                          K;
                          Ty.apply (Ty.path "move_core_types::effects::Op") [ V ];
                          Ty.path "alloc::alloc::Global"
                        ],
                      [],
                      "into_iter",
                      []
                    |),
                    [
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::iter::traits::collect::IntoIterator",
                          Ty.apply
                            (Ty.path "alloc::collections::btree::map::BTreeMap")
                            [
                              K;
                              Ty.apply (Ty.path "move_core_types::effects::Op") [ V ];
                              Ty.path "alloc::alloc::Global"
                            ],
                          [],
                          "into_iter",
                          []
                        |),
                        [ M.read (| other |) ]
                      |)
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let iter := M.copy (| γ |) in
                      M.loop (|
                        ltac:(M.monadic
                          (let _ :=
                            M.match_operator (|
                              M.alloc (|
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::iter::traits::iterator::Iterator",
                                    Ty.apply
                                      (Ty.path "alloc::collections::btree::map::IntoIter")
                                      [
                                        K;
                                        Ty.apply (Ty.path "move_core_types::effects::Op") [ V ];
                                        Ty.path "alloc::alloc::Global"
                                      ],
                                    [],
                                    "next",
                                    []
                                  |),
                                  [ iter ]
                                |)
                              |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (M.alloc (| M.never_to_any (| M.read (| M.break (||) |) |) |)));
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ0_0 :=
                                      M.get_struct_tuple_field_or_break_match (|
                                        γ,
                                        "core::option::Option::Some",
                                        0
                                      |) in
                                    let γ1_0 := M.get_tuple_field γ0_0 0 in
                                    let γ1_1 := M.get_tuple_field γ0_0 1 in
                                    let key := M.copy (| γ1_0 |) in
                                    let op := M.copy (| γ1_1 |) in
                                    M.match_operator (|
                                      M.alloc (|
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.apply
                                              (Ty.path "alloc::collections::btree::map::BTreeMap")
                                              [
                                                K;
                                                Ty.apply
                                                  (Ty.path "move_core_types::effects::Op")
                                                  [ V ];
                                                Ty.path "alloc::alloc::Global"
                                              ],
                                            "entry",
                                            []
                                          |),
                                          [ M.read (| map |); M.read (| key |) ]
                                        |)
                                      |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.get_struct_tuple_field_or_break_match (|
                                                γ,
                                                "alloc::collections::btree::map::entry::Entry::Occupied",
                                                0
                                              |) in
                                            let entry := M.copy (| γ0_0 |) in
                                            let r :=
                                              M.alloc (|
                                                M.call_closure (|
                                                  M.get_associated_function (|
                                                    Ty.apply
                                                      (Ty.path
                                                        "alloc::collections::btree::map::entry::OccupiedEntry")
                                                      [
                                                        K;
                                                        Ty.apply
                                                          (Ty.path "move_core_types::effects::Op")
                                                          [ V ];
                                                        Ty.path "alloc::alloc::Global"
                                                      ],
                                                    "get_mut",
                                                    []
                                                  |),
                                                  [ entry ]
                                                |)
                                              |) in
                                            M.match_operator (|
                                              M.alloc (|
                                                Value.Tuple
                                                  [
                                                    M.call_closure (|
                                                      M.get_associated_function (|
                                                        Ty.apply
                                                          (Ty.path "move_core_types::effects::Op")
                                                          [ V ],
                                                        "as_ref",
                                                        []
                                                      |),
                                                      [ M.read (| r |) ]
                                                    |);
                                                    M.read (| op |)
                                                  ]
                                              |),
                                              [
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (M.find_or_pattern (|
                                                      γ,
                                                      [
                                                        fun γ =>
                                                          ltac:(M.monadic
                                                            (let γ0_0 := M.get_tuple_field γ 0 in
                                                            let γ0_1 := M.get_tuple_field γ 1 in
                                                            M.find_or_pattern (|
                                                              γ0_0,
                                                              [
                                                                fun γ =>
                                                                  ltac:(M.monadic
                                                                    (let γ0_0 :=
                                                                      M.get_struct_tuple_field_or_break_match (|
                                                                        γ,
                                                                        "move_core_types::effects::Op::Modify",
                                                                        0
                                                                      |) in
                                                                    Value.Tuple []));
                                                                fun γ =>
                                                                  ltac:(M.monadic
                                                                    (let γ0_0 :=
                                                                      M.get_struct_tuple_field_or_break_match (|
                                                                        γ,
                                                                        "move_core_types::effects::Op::New",
                                                                        0
                                                                      |) in
                                                                    Value.Tuple []))
                                                              ],
                                                              M.closure
                                                                (fun γ =>
                                                                  ltac:(M.monadic
                                                                    match γ with
                                                                    | [] =>
                                                                      let γ1_0 :=
                                                                        M.get_struct_tuple_field_or_break_match (|
                                                                          γ0_1,
                                                                          "move_core_types::effects::Op::New",
                                                                          0
                                                                        |) in
                                                                      Value.Tuple []
                                                                    | _ => M.impossible (||)
                                                                    end))
                                                            |)));
                                                        fun γ =>
                                                          ltac:(M.monadic
                                                            (let γ0_0 := M.get_tuple_field γ 0 in
                                                            let γ0_1 := M.get_tuple_field γ 1 in
                                                            M.find_or_pattern (|
                                                              γ0_1,
                                                              [
                                                                fun γ =>
                                                                  ltac:(M.monadic (Value.Tuple []));
                                                                fun γ =>
                                                                  ltac:(M.monadic
                                                                    (let γ0_0 :=
                                                                      M.get_struct_tuple_field_or_break_match (|
                                                                        γ,
                                                                        "move_core_types::effects::Op::Modify",
                                                                        0
                                                                      |) in
                                                                    Value.Tuple []))
                                                              ],
                                                              M.closure
                                                                (fun γ =>
                                                                  ltac:(M.monadic
                                                                    match γ with
                                                                    | [] => Value.Tuple []
                                                                    | _ => M.impossible (||)
                                                                    end))
                                                            |)))
                                                      ],
                                                      M.closure
                                                        (fun γ =>
                                                          ltac:(M.monadic
                                                            match γ with
                                                            | [] =>
                                                              M.alloc (|
                                                                M.never_to_any (|
                                                                  M.read (|
                                                                    M.return_ (|
                                                                      Value.StructTuple
                                                                        "core::result::Result::Err"
                                                                        [
                                                                          M.read (|
                                                                            let error :=
                                                                              M.alloc (|
                                                                                M.call_closure (|
                                                                                  M.get_function (|
                                                                                    "anyhow::private::format_err",
                                                                                    []
                                                                                  |),
                                                                                  [
                                                                                    M.call_closure (|
                                                                                      M.get_associated_function (|
                                                                                        Ty.path
                                                                                          "core::fmt::Arguments",
                                                                                        "new_const",
                                                                                        []
                                                                                      |),
                                                                                      [
                                                                                        (* Unsize *)
                                                                                        M.pointer_coercion
                                                                                          (M.alloc (|
                                                                                            Value.Array
                                                                                              [
                                                                                                M.read (|
                                                                                                  mk_str
                                                                                                    "The given change sets cannot be squashed"
                                                                                                |)
                                                                                              ]
                                                                                          |))
                                                                                      ]
                                                                                    |)
                                                                                  ]
                                                                                |)
                                                                              |) in
                                                                            error
                                                                          |)
                                                                        ]
                                                                    |)
                                                                  |)
                                                                |)
                                                              |)
                                                            | _ => M.impossible (||)
                                                            end))
                                                    |)));
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (let γ0_0 := M.get_tuple_field γ 0 in
                                                    let γ0_1 := M.get_tuple_field γ 1 in
                                                    let γ1_0 :=
                                                      M.get_struct_tuple_field_or_break_match (|
                                                        γ0_0,
                                                        "move_core_types::effects::Op::Modify",
                                                        0
                                                      |) in
                                                    let γ1_0 :=
                                                      M.get_struct_tuple_field_or_break_match (|
                                                        γ0_1,
                                                        "move_core_types::effects::Op::Modify",
                                                        0
                                                      |) in
                                                    let data := M.copy (| γ1_0 |) in
                                                    M.write (|
                                                      M.read (| r |),
                                                      Value.StructTuple
                                                        "move_core_types::effects::Op::Modify"
                                                        [ M.read (| data |) ]
                                                    |)));
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (let γ0_0 := M.get_tuple_field γ 0 in
                                                    let γ0_1 := M.get_tuple_field γ 1 in
                                                    let γ1_0 :=
                                                      M.get_struct_tuple_field_or_break_match (|
                                                        γ0_0,
                                                        "move_core_types::effects::Op::New",
                                                        0
                                                      |) in
                                                    let γ1_0 :=
                                                      M.get_struct_tuple_field_or_break_match (|
                                                        γ0_1,
                                                        "move_core_types::effects::Op::Modify",
                                                        0
                                                      |) in
                                                    let data := M.copy (| γ1_0 |) in
                                                    M.write (|
                                                      M.read (| r |),
                                                      Value.StructTuple
                                                        "move_core_types::effects::Op::New"
                                                        [ M.read (| data |) ]
                                                    |)));
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (let γ0_0 := M.get_tuple_field γ 0 in
                                                    let γ0_1 := M.get_tuple_field γ 1 in
                                                    let γ1_0 :=
                                                      M.get_struct_tuple_field_or_break_match (|
                                                        γ0_0,
                                                        "move_core_types::effects::Op::Modify",
                                                        0
                                                      |) in
                                                    M.write (|
                                                      M.read (| r |),
                                                      Value.StructTuple
                                                        "move_core_types::effects::Op::Delete"
                                                        []
                                                    |)));
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (let γ0_0 := M.get_tuple_field γ 0 in
                                                    let γ0_1 := M.get_tuple_field γ 1 in
                                                    let γ1_0 :=
                                                      M.get_struct_tuple_field_or_break_match (|
                                                        γ0_1,
                                                        "move_core_types::effects::Op::New",
                                                        0
                                                      |) in
                                                    let data := M.copy (| γ1_0 |) in
                                                    M.write (|
                                                      M.read (| r |),
                                                      Value.StructTuple
                                                        "move_core_types::effects::Op::Modify"
                                                        [ M.read (| data |) ]
                                                    |)));
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (let γ0_0 := M.get_tuple_field γ 0 in
                                                    let γ0_1 := M.get_tuple_field γ 1 in
                                                    let γ1_0 :=
                                                      M.get_struct_tuple_field_or_break_match (|
                                                        γ0_0,
                                                        "move_core_types::effects::Op::New",
                                                        0
                                                      |) in
                                                    let _ :=
                                                      M.alloc (|
                                                        M.call_closure (|
                                                          M.get_associated_function (|
                                                            Ty.apply
                                                              (Ty.path
                                                                "alloc::collections::btree::map::entry::OccupiedEntry")
                                                              [
                                                                K;
                                                                Ty.apply
                                                                  (Ty.path
                                                                    "move_core_types::effects::Op")
                                                                  [ V ];
                                                                Ty.path "alloc::alloc::Global"
                                                              ],
                                                            "remove",
                                                            []
                                                          |),
                                                          [ M.read (| entry |) ]
                                                        |)
                                                      |) in
                                                    M.alloc (| Value.Tuple [] |)))
                                              ]
                                            |)));
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.get_struct_tuple_field_or_break_match (|
                                                γ,
                                                "alloc::collections::btree::map::entry::Entry::Vacant",
                                                0
                                              |) in
                                            let entry := M.copy (| γ0_0 |) in
                                            let _ :=
                                              M.alloc (|
                                                M.call_closure (|
                                                  M.get_associated_function (|
                                                    Ty.apply
                                                      (Ty.path
                                                        "alloc::collections::btree::map::entry::VacantEntry")
                                                      [
                                                        K;
                                                        Ty.apply
                                                          (Ty.path "move_core_types::effects::Op")
                                                          [ V ];
                                                        Ty.path "alloc::alloc::Global"
                                                      ],
                                                    "insert",
                                                    []
                                                  |),
                                                  [ M.read (| entry |); M.read (| op |) ]
                                                |)
                                              |) in
                                            M.alloc (| Value.Tuple [] |)))
                                      ]
                                    |)))
                              ]
                            |) in
                          M.alloc (| Value.Tuple [] |)))
                      |)))
                ]
              |)) in
          M.alloc (| Value.StructTuple "core::result::Result::Ok" [ Value.Tuple [] ] |)
        |)))
    | _, _ => M.impossible
    end.
  
  Module Impl_move_core_types_effects_AccountChangeSet.
    Definition Self : Ty.t := Ty.path "move_core_types::effects::AccountChangeSet".
    
    (*
        pub fn from_modules_resources(
            modules: BTreeMap<Identifier, Op<Vec<u8>>>,
            resources: BTreeMap<StructTag, Op<Vec<u8>>>,
        ) -> Self {
            Self { modules, resources }
        }
    *)
    Definition from_modules_resources (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ modules; resources ] =>
        ltac:(M.monadic
          (let modules := M.alloc (| modules |) in
          let resources := M.alloc (| resources |) in
          Value.StructRecord
            "move_core_types::effects::AccountChangeSet"
            [ ("modules", M.read (| modules |)); ("resources", M.read (| resources |)) ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_from_modules_resources :
      M.IsAssociatedFunction Self "from_modules_resources" from_modules_resources.
    
    (*
        pub fn new() -> Self {
            Self {
                modules: BTreeMap::new(),
                resources: BTreeMap::new(),
            }
        }
    *)
    Definition new (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [] =>
        ltac:(M.monadic
          (Value.StructRecord
            "move_core_types::effects::AccountChangeSet"
            [
              ("modules",
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloc::collections::btree::map::BTreeMap")
                      [
                        Ty.path "move_core_types::identifier::Identifier";
                        Ty.apply
                          (Ty.path "move_core_types::effects::Op")
                          [
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                          ];
                        Ty.path "alloc::alloc::Global"
                      ],
                    "new",
                    []
                  |),
                  []
                |));
              ("resources",
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloc::collections::btree::map::BTreeMap")
                      [
                        Ty.path "move_core_types::language_storage::StructTag";
                        Ty.apply
                          (Ty.path "move_core_types::effects::Op")
                          [
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                          ];
                        Ty.path "alloc::alloc::Global"
                      ],
                    "new",
                    []
                  |),
                  []
                |))
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_new : M.IsAssociatedFunction Self "new" new.
    
    (*
        pub fn add_module_op(&mut self, name: Identifier, op: Op<Vec<u8>>) -> Result<()> {
            use btree_map::Entry::*;
    
            match self.modules.entry(name) {
                Occupied(entry) => bail!("Module {} already exists", entry.key()),
                Vacant(entry) => {
                    entry.insert(op);
                }
            }
    
            Ok(())
        }
    *)
    Definition add_module_op (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; name; op ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let name := M.alloc (| name |) in
          let op := M.alloc (| op |) in
          M.read (|
            let _ :=
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::collections::btree::map::BTreeMap")
                        [
                          Ty.path "move_core_types::identifier::Identifier";
                          Ty.apply
                            (Ty.path "move_core_types::effects::Op")
                            [
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                            ];
                          Ty.path "alloc::alloc::Global"
                        ],
                      "entry",
                      []
                    |),
                    [
                      M.get_struct_record_field
                        (M.read (| self |))
                        "move_core_types::effects::AccountChangeSet"
                        "modules";
                      M.read (| name |)
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.get_struct_tuple_field_or_break_match (|
                          γ,
                          "alloc::collections::btree::map::entry::Entry::Occupied",
                          0
                        |) in
                      let entry := M.copy (| γ0_0 |) in
                      M.alloc (|
                        M.never_to_any (|
                          M.read (|
                            M.return_ (|
                              Value.StructTuple
                                "core::result::Result::Err"
                                [
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.path "anyhow::Error",
                                      "msg",
                                      [ Ty.path "alloc::string::String" ]
                                    |),
                                    [
                                      M.read (|
                                        let res :=
                                          M.alloc (|
                                            M.call_closure (|
                                              M.get_function (| "alloc::fmt::format", [] |),
                                              [
                                                M.call_closure (|
                                                  M.get_associated_function (|
                                                    Ty.path "core::fmt::Arguments",
                                                    "new_v1",
                                                    []
                                                  |),
                                                  [
                                                    (* Unsize *)
                                                    M.pointer_coercion
                                                      (M.alloc (|
                                                        Value.Array
                                                          [
                                                            M.read (| mk_str "Module " |);
                                                            M.read (| mk_str " already exists" |)
                                                          ]
                                                      |));
                                                    (* Unsize *)
                                                    M.pointer_coercion
                                                      (M.alloc (|
                                                        Value.Array
                                                          [
                                                            M.call_closure (|
                                                              M.get_associated_function (|
                                                                Ty.path "core::fmt::rt::Argument",
                                                                "new_display",
                                                                [
                                                                  Ty.apply
                                                                    (Ty.path "&")
                                                                    [
                                                                      Ty.path
                                                                        "move_core_types::identifier::Identifier"
                                                                    ]
                                                                ]
                                                              |),
                                                              [
                                                                M.alloc (|
                                                                  M.call_closure (|
                                                                    M.get_associated_function (|
                                                                      Ty.apply
                                                                        (Ty.path
                                                                          "alloc::collections::btree::map::entry::OccupiedEntry")
                                                                        [
                                                                          Ty.path
                                                                            "move_core_types::identifier::Identifier";
                                                                          Ty.apply
                                                                            (Ty.path
                                                                              "move_core_types::effects::Op")
                                                                            [
                                                                              Ty.apply
                                                                                (Ty.path
                                                                                  "alloc::vec::Vec")
                                                                                [
                                                                                  Ty.path "u8";
                                                                                  Ty.path
                                                                                    "alloc::alloc::Global"
                                                                                ]
                                                                            ];
                                                                          Ty.path
                                                                            "alloc::alloc::Global"
                                                                        ],
                                                                      "key",
                                                                      []
                                                                    |),
                                                                    [ entry ]
                                                                  |)
                                                                |)
                                                              ]
                                                            |)
                                                          ]
                                                      |))
                                                  ]
                                                |)
                                              ]
                                            |)
                                          |) in
                                        res
                                      |)
                                    ]
                                  |)
                                ]
                            |)
                          |)
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.get_struct_tuple_field_or_break_match (|
                          γ,
                          "alloc::collections::btree::map::entry::Entry::Vacant",
                          0
                        |) in
                      let entry := M.copy (| γ0_0 |) in
                      let _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "alloc::collections::btree::map::entry::VacantEntry")
                                [
                                  Ty.path "move_core_types::identifier::Identifier";
                                  Ty.apply
                                    (Ty.path "move_core_types::effects::Op")
                                    [
                                      Ty.apply
                                        (Ty.path "alloc::vec::Vec")
                                        [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                                    ];
                                  Ty.path "alloc::alloc::Global"
                                ],
                              "insert",
                              []
                            |),
                            [ M.read (| entry |); M.read (| op |) ]
                          |)
                        |) in
                      M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            M.alloc (| Value.StructTuple "core::result::Result::Ok" [ Value.Tuple [] ] |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_add_module_op :
      M.IsAssociatedFunction Self "add_module_op" add_module_op.
    
    (*
        pub fn add_resource_op(&mut self, struct_tag: StructTag, op: Op<Vec<u8>>) -> Result<()> {
            use btree_map::Entry::*;
    
            match self.resources.entry(struct_tag) {
                Occupied(entry) => bail!("Resource {} already exists", entry.key()),
                Vacant(entry) => {
                    entry.insert(op);
                }
            }
    
            Ok(())
        }
    *)
    Definition add_resource_op (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; struct_tag; op ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let struct_tag := M.alloc (| struct_tag |) in
          let op := M.alloc (| op |) in
          M.read (|
            let _ :=
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::collections::btree::map::BTreeMap")
                        [
                          Ty.path "move_core_types::language_storage::StructTag";
                          Ty.apply
                            (Ty.path "move_core_types::effects::Op")
                            [
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                            ];
                          Ty.path "alloc::alloc::Global"
                        ],
                      "entry",
                      []
                    |),
                    [
                      M.get_struct_record_field
                        (M.read (| self |))
                        "move_core_types::effects::AccountChangeSet"
                        "resources";
                      M.read (| struct_tag |)
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.get_struct_tuple_field_or_break_match (|
                          γ,
                          "alloc::collections::btree::map::entry::Entry::Occupied",
                          0
                        |) in
                      let entry := M.copy (| γ0_0 |) in
                      M.alloc (|
                        M.never_to_any (|
                          M.read (|
                            M.return_ (|
                              Value.StructTuple
                                "core::result::Result::Err"
                                [
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.path "anyhow::Error",
                                      "msg",
                                      [ Ty.path "alloc::string::String" ]
                                    |),
                                    [
                                      M.read (|
                                        let res :=
                                          M.alloc (|
                                            M.call_closure (|
                                              M.get_function (| "alloc::fmt::format", [] |),
                                              [
                                                M.call_closure (|
                                                  M.get_associated_function (|
                                                    Ty.path "core::fmt::Arguments",
                                                    "new_v1",
                                                    []
                                                  |),
                                                  [
                                                    (* Unsize *)
                                                    M.pointer_coercion
                                                      (M.alloc (|
                                                        Value.Array
                                                          [
                                                            M.read (| mk_str "Resource " |);
                                                            M.read (| mk_str " already exists" |)
                                                          ]
                                                      |));
                                                    (* Unsize *)
                                                    M.pointer_coercion
                                                      (M.alloc (|
                                                        Value.Array
                                                          [
                                                            M.call_closure (|
                                                              M.get_associated_function (|
                                                                Ty.path "core::fmt::rt::Argument",
                                                                "new_display",
                                                                [
                                                                  Ty.apply
                                                                    (Ty.path "&")
                                                                    [
                                                                      Ty.path
                                                                        "move_core_types::language_storage::StructTag"
                                                                    ]
                                                                ]
                                                              |),
                                                              [
                                                                M.alloc (|
                                                                  M.call_closure (|
                                                                    M.get_associated_function (|
                                                                      Ty.apply
                                                                        (Ty.path
                                                                          "alloc::collections::btree::map::entry::OccupiedEntry")
                                                                        [
                                                                          Ty.path
                                                                            "move_core_types::language_storage::StructTag";
                                                                          Ty.apply
                                                                            (Ty.path
                                                                              "move_core_types::effects::Op")
                                                                            [
                                                                              Ty.apply
                                                                                (Ty.path
                                                                                  "alloc::vec::Vec")
                                                                                [
                                                                                  Ty.path "u8";
                                                                                  Ty.path
                                                                                    "alloc::alloc::Global"
                                                                                ]
                                                                            ];
                                                                          Ty.path
                                                                            "alloc::alloc::Global"
                                                                        ],
                                                                      "key",
                                                                      []
                                                                    |),
                                                                    [ entry ]
                                                                  |)
                                                                |)
                                                              ]
                                                            |)
                                                          ]
                                                      |))
                                                  ]
                                                |)
                                              ]
                                            |)
                                          |) in
                                        res
                                      |)
                                    ]
                                  |)
                                ]
                            |)
                          |)
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.get_struct_tuple_field_or_break_match (|
                          γ,
                          "alloc::collections::btree::map::entry::Entry::Vacant",
                          0
                        |) in
                      let entry := M.copy (| γ0_0 |) in
                      let _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "alloc::collections::btree::map::entry::VacantEntry")
                                [
                                  Ty.path "move_core_types::language_storage::StructTag";
                                  Ty.apply
                                    (Ty.path "move_core_types::effects::Op")
                                    [
                                      Ty.apply
                                        (Ty.path "alloc::vec::Vec")
                                        [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                                    ];
                                  Ty.path "alloc::alloc::Global"
                                ],
                              "insert",
                              []
                            |),
                            [ M.read (| entry |); M.read (| op |) ]
                          |)
                        |) in
                      M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            M.alloc (| Value.StructTuple "core::result::Result::Ok" [ Value.Tuple [] ] |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_add_resource_op :
      M.IsAssociatedFunction Self "add_resource_op" add_resource_op.
    
    (*
        pub fn into_inner(
            self,
        ) -> (
            BTreeMap<Identifier, Op<Vec<u8>>>,
            BTreeMap<StructTag, Op<Vec<u8>>>,
        ) {
            (self.modules, self.resources)
        }
    *)
    Definition into_inner (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.Tuple
            [
              M.read (|
                M.get_struct_record_field
                  self
                  "move_core_types::effects::AccountChangeSet"
                  "modules"
              |);
              M.read (|
                M.get_struct_record_field
                  self
                  "move_core_types::effects::AccountChangeSet"
                  "resources"
              |)
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_into_inner : M.IsAssociatedFunction Self "into_inner" into_inner.
    
    (*
        pub fn into_resources(self) -> BTreeMap<StructTag, Op<Vec<u8>>> {
            self.resources
        }
    *)
    Definition into_resources (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.get_struct_record_field self "move_core_types::effects::AccountChangeSet" "resources"
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_into_resources :
      M.IsAssociatedFunction Self "into_resources" into_resources.
    
    (*
        pub fn into_modules(self) -> BTreeMap<Identifier, Op<Vec<u8>>> {
            self.modules
        }
    *)
    Definition into_modules (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.get_struct_record_field self "move_core_types::effects::AccountChangeSet" "modules"
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_into_modules : M.IsAssociatedFunction Self "into_modules" into_modules.
    
    (*
        pub fn modules(&self) -> &BTreeMap<Identifier, Op<Vec<u8>>> {
            &self.modules
        }
    *)
    Definition modules (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.get_struct_record_field
            (M.read (| self |))
            "move_core_types::effects::AccountChangeSet"
            "modules"))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_modules : M.IsAssociatedFunction Self "modules" modules.
    
    (*
        pub fn resources(&self) -> &BTreeMap<StructTag, Op<Vec<u8>>> {
            &self.resources
        }
    *)
    Definition resources (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.get_struct_record_field
            (M.read (| self |))
            "move_core_types::effects::AccountChangeSet"
            "resources"))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_resources : M.IsAssociatedFunction Self "resources" resources.
    
    (*
        pub fn is_empty(&self) -> bool {
            self.modules.is_empty() && self.resources.is_empty()
        }
    *)
    Definition is_empty (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          LogicalOp.and (|
            M.call_closure (|
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "alloc::collections::btree::map::BTreeMap")
                  [
                    Ty.path "move_core_types::identifier::Identifier";
                    Ty.apply
                      (Ty.path "move_core_types::effects::Op")
                      [
                        Ty.apply
                          (Ty.path "alloc::vec::Vec")
                          [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                      ];
                    Ty.path "alloc::alloc::Global"
                  ],
                "is_empty",
                []
              |),
              [
                M.get_struct_record_field
                  (M.read (| self |))
                  "move_core_types::effects::AccountChangeSet"
                  "modules"
              ]
            |),
            ltac:(M.monadic
              (M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::collections::btree::map::BTreeMap")
                    [
                      Ty.path "move_core_types::language_storage::StructTag";
                      Ty.apply
                        (Ty.path "move_core_types::effects::Op")
                        [
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                        ];
                      Ty.path "alloc::alloc::Global"
                    ],
                  "is_empty",
                  []
                |),
                [
                  M.get_struct_record_field
                    (M.read (| self |))
                    "move_core_types::effects::AccountChangeSet"
                    "resources"
                ]
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_is_empty : M.IsAssociatedFunction Self "is_empty" is_empty.
    
    (*
        pub fn squash(&mut self, other: Self) -> Result<()> {
            squash(&mut self.modules, other.modules)?;
            squash(&mut self.resources, other.resources)
        }
    *)
    Definition squash (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            let _ :=
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::try_trait::Try",
                      Ty.apply
                        (Ty.path "core::result::Result")
                        [ Ty.tuple []; Ty.path "anyhow::Error" ],
                      [],
                      "branch",
                      []
                    |),
                    [
                      M.call_closure (|
                        M.get_function (|
                          "move_core_types::effects::squash",
                          [
                            Ty.path "move_core_types::identifier::Identifier";
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                          ]
                        |),
                        [
                          M.get_struct_record_field
                            (M.read (| self |))
                            "move_core_types::effects::AccountChangeSet"
                            "modules";
                          M.read (|
                            M.get_struct_record_field
                              other
                              "move_core_types::effects::AccountChangeSet"
                              "modules"
                          |)
                        ]
                      |)
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.get_struct_tuple_field_or_break_match (|
                          γ,
                          "core::ops::control_flow::ControlFlow::Break",
                          0
                        |) in
                      let residual := M.copy (| γ0_0 |) in
                      M.alloc (|
                        M.never_to_any (|
                          M.read (|
                            M.return_ (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::ops::try_trait::FromResidual",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    [ Ty.tuple []; Ty.path "anyhow::Error" ],
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      [ Ty.path "core::convert::Infallible"; Ty.path "anyhow::Error"
                                      ]
                                  ],
                                  "from_residual",
                                  []
                                |),
                                [ M.read (| residual |) ]
                              |)
                            |)
                          |)
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.get_struct_tuple_field_or_break_match (|
                          γ,
                          "core::ops::control_flow::ControlFlow::Continue",
                          0
                        |) in
                      let val := M.copy (| γ0_0 |) in
                      val))
                ]
              |) in
            M.alloc (|
              M.call_closure (|
                M.get_function (|
                  "move_core_types::effects::squash",
                  [
                    Ty.path "move_core_types::language_storage::StructTag";
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                  ]
                |),
                [
                  M.get_struct_record_field
                    (M.read (| self |))
                    "move_core_types::effects::AccountChangeSet"
                    "resources";
                  M.read (|
                    M.get_struct_record_field
                      other
                      "move_core_types::effects::AccountChangeSet"
                      "resources"
                  |)
                ]
              |)
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_squash : M.IsAssociatedFunction Self "squash" squash.
  End Impl_move_core_types_effects_AccountChangeSet.
  
  (* StructRecord
    {
      name := "ChangeSet";
      ty_params := [];
      fields :=
        [
          ("accounts",
            Ty.apply
              (Ty.path "alloc::collections::btree::map::BTreeMap")
              [
                Ty.path "move_core_types::account_address::AccountAddress";
                Ty.path "move_core_types::effects::AccountChangeSet";
                Ty.path "alloc::alloc::Global"
              ])
        ];
    } *)
  
  Module Impl_core_fmt_Debug_for_move_core_types_effects_ChangeSet.
    Definition Self : Ty.t := Ty.path "move_core_types::effects::ChangeSet".
    
    (* Debug *)
    Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.path "core::fmt::Formatter",
              "debug_struct_field1_finish",
              []
            |),
            [
              M.read (| f |);
              M.read (| mk_str "ChangeSet" |);
              M.read (| mk_str "accounts" |);
              (* Unsize *)
              M.pointer_coercion
                (M.alloc (|
                  M.get_struct_record_field
                    (M.read (| self |))
                    "move_core_types::effects::ChangeSet"
                    "accounts"
                |))
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_move_core_types_effects_ChangeSet.
  
  Module Impl_core_clone_Clone_for_move_core_types_effects_ChangeSet.
    Definition Self : Ty.t := Ty.path "move_core_types::effects::ChangeSet".
    
    (* Clone *)
    Definition clone (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.StructRecord
            "move_core_types::effects::ChangeSet"
            [
              ("accounts",
                M.call_closure (|
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.apply
                      (Ty.path "alloc::collections::btree::map::BTreeMap")
                      [
                        Ty.path "move_core_types::account_address::AccountAddress";
                        Ty.path "move_core_types::effects::AccountChangeSet";
                        Ty.path "alloc::alloc::Global"
                      ],
                    [],
                    "clone",
                    []
                  |),
                  [
                    M.get_struct_record_field
                      (M.read (| self |))
                      "move_core_types::effects::ChangeSet"
                      "accounts"
                  ]
                |))
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_move_core_types_effects_ChangeSet.
  
  Module Impl_core_marker_StructuralEq_for_move_core_types_effects_ChangeSet.
    Definition Self : Ty.t := Ty.path "move_core_types::effects::ChangeSet".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralEq_for_move_core_types_effects_ChangeSet.
  
  Module Impl_core_cmp_Eq_for_move_core_types_effects_ChangeSet.
    Definition Self : Ty.t := Ty.path "move_core_types::effects::ChangeSet".
    
    (* Eq *)
    Definition assert_receiver_is_total_eq (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Value.DeclaredButUndefined,
              [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_move_core_types_effects_ChangeSet.
  
  Module Impl_core_marker_StructuralPartialEq_for_move_core_types_effects_ChangeSet.
    Definition Self : Ty.t := Ty.path "move_core_types::effects::ChangeSet".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_move_core_types_effects_ChangeSet.
  
  Module Impl_core_cmp_PartialEq_for_move_core_types_effects_ChangeSet.
    Definition Self : Ty.t := Ty.path "move_core_types::effects::ChangeSet".
    
    (* PartialEq *)
    Definition eq (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::cmp::PartialEq",
              Ty.apply
                (Ty.path "alloc::collections::btree::map::BTreeMap")
                [
                  Ty.path "move_core_types::account_address::AccountAddress";
                  Ty.path "move_core_types::effects::AccountChangeSet";
                  Ty.path "alloc::alloc::Global"
                ],
              [
                Ty.apply
                  (Ty.path "alloc::collections::btree::map::BTreeMap")
                  [
                    Ty.path "move_core_types::account_address::AccountAddress";
                    Ty.path "move_core_types::effects::AccountChangeSet";
                    Ty.path "alloc::alloc::Global"
                  ]
              ],
              "eq",
              []
            |),
            [
              M.get_struct_record_field
                (M.read (| self |))
                "move_core_types::effects::ChangeSet"
                "accounts";
              M.get_struct_record_field
                (M.read (| other |))
                "move_core_types::effects::ChangeSet"
                "accounts"
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_for_move_core_types_effects_ChangeSet.
  
  Module Impl_core_cmp_Ord_for_move_core_types_effects_ChangeSet.
    Definition Self : Ty.t := Ty.path "move_core_types::effects::ChangeSet".
    
    (* Ord *)
    Definition cmp (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::cmp::Ord",
              Ty.apply
                (Ty.path "alloc::collections::btree::map::BTreeMap")
                [
                  Ty.path "move_core_types::account_address::AccountAddress";
                  Ty.path "move_core_types::effects::AccountChangeSet";
                  Ty.path "alloc::alloc::Global"
                ],
              [],
              "cmp",
              []
            |),
            [
              M.get_struct_record_field
                (M.read (| self |))
                "move_core_types::effects::ChangeSet"
                "accounts";
              M.get_struct_record_field
                (M.read (| other |))
                "move_core_types::effects::ChangeSet"
                "accounts"
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Ord"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("cmp", InstanceField.Method cmp) ].
  End Impl_core_cmp_Ord_for_move_core_types_effects_ChangeSet.
  
  Module Impl_core_cmp_PartialOrd_for_move_core_types_effects_ChangeSet.
    Definition Self : Ty.t := Ty.path "move_core_types::effects::ChangeSet".
    
    (* PartialOrd *)
    Definition partial_cmp (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::cmp::PartialOrd",
              Ty.apply
                (Ty.path "alloc::collections::btree::map::BTreeMap")
                [
                  Ty.path "move_core_types::account_address::AccountAddress";
                  Ty.path "move_core_types::effects::AccountChangeSet";
                  Ty.path "alloc::alloc::Global"
                ],
              [
                Ty.apply
                  (Ty.path "alloc::collections::btree::map::BTreeMap")
                  [
                    Ty.path "move_core_types::account_address::AccountAddress";
                    Ty.path "move_core_types::effects::AccountChangeSet";
                    Ty.path "alloc::alloc::Global"
                  ]
              ],
              "partial_cmp",
              []
            |),
            [
              M.get_struct_record_field
                (M.read (| self |))
                "move_core_types::effects::ChangeSet"
                "accounts";
              M.get_struct_record_field
                (M.read (| other |))
                "move_core_types::effects::ChangeSet"
                "accounts"
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialOrd"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("partial_cmp", InstanceField.Method partial_cmp) ].
  End Impl_core_cmp_PartialOrd_for_move_core_types_effects_ChangeSet.
  
  Module Impl_move_core_types_effects_ChangeSet.
    Definition Self : Ty.t := Ty.path "move_core_types::effects::ChangeSet".
    
    (*
        pub fn new() -> Self {
            Self {
                accounts: BTreeMap::new(),
            }
        }
    *)
    Definition new (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [] =>
        ltac:(M.monadic
          (Value.StructRecord
            "move_core_types::effects::ChangeSet"
            [
              ("accounts",
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloc::collections::btree::map::BTreeMap")
                      [
                        Ty.path "move_core_types::account_address::AccountAddress";
                        Ty.path "move_core_types::effects::AccountChangeSet";
                        Ty.path "alloc::alloc::Global"
                      ],
                    "new",
                    []
                  |),
                  []
                |))
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_new : M.IsAssociatedFunction Self "new" new.
    
    (*
        pub fn add_account_changeset(
            &mut self,
            addr: AccountAddress,
            account_changeset: AccountChangeSet,
        ) -> Result<()> {
            match self.accounts.entry(addr) {
                btree_map::Entry::Occupied(_) => bail!(
                    "Failed to add account change set. Account {} already exists.",
                    addr
                ),
                btree_map::Entry::Vacant(entry) => {
                    entry.insert(account_changeset);
                }
            }
    
            Ok(())
        }
    *)
    Definition add_account_changeset (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; addr; account_changeset ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let addr := M.alloc (| addr |) in
          let account_changeset := M.alloc (| account_changeset |) in
          M.read (|
            let _ :=
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::collections::btree::map::BTreeMap")
                        [
                          Ty.path "move_core_types::account_address::AccountAddress";
                          Ty.path "move_core_types::effects::AccountChangeSet";
                          Ty.path "alloc::alloc::Global"
                        ],
                      "entry",
                      []
                    |),
                    [
                      M.get_struct_record_field
                        (M.read (| self |))
                        "move_core_types::effects::ChangeSet"
                        "accounts";
                      M.read (| addr |)
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.get_struct_tuple_field_or_break_match (|
                          γ,
                          "alloc::collections::btree::map::entry::Entry::Occupied",
                          0
                        |) in
                      M.alloc (|
                        M.never_to_any (|
                          M.read (|
                            M.return_ (|
                              Value.StructTuple
                                "core::result::Result::Err"
                                [
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.path "anyhow::Error",
                                      "msg",
                                      [ Ty.path "alloc::string::String" ]
                                    |),
                                    [
                                      M.read (|
                                        let res :=
                                          M.alloc (|
                                            M.call_closure (|
                                              M.get_function (| "alloc::fmt::format", [] |),
                                              [
                                                M.call_closure (|
                                                  M.get_associated_function (|
                                                    Ty.path "core::fmt::Arguments",
                                                    "new_v1",
                                                    []
                                                  |),
                                                  [
                                                    (* Unsize *)
                                                    M.pointer_coercion
                                                      (M.alloc (|
                                                        Value.Array
                                                          [
                                                            M.read (|
                                                              mk_str
                                                                "Failed to add account change set. Account "
                                                            |);
                                                            M.read (| mk_str " already exists." |)
                                                          ]
                                                      |));
                                                    (* Unsize *)
                                                    M.pointer_coercion
                                                      (M.alloc (|
                                                        Value.Array
                                                          [
                                                            M.call_closure (|
                                                              M.get_associated_function (|
                                                                Ty.path "core::fmt::rt::Argument",
                                                                "new_display",
                                                                [
                                                                  Ty.path
                                                                    "move_core_types::account_address::AccountAddress"
                                                                ]
                                                              |),
                                                              [ addr ]
                                                            |)
                                                          ]
                                                      |))
                                                  ]
                                                |)
                                              ]
                                            |)
                                          |) in
                                        res
                                      |)
                                    ]
                                  |)
                                ]
                            |)
                          |)
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.get_struct_tuple_field_or_break_match (|
                          γ,
                          "alloc::collections::btree::map::entry::Entry::Vacant",
                          0
                        |) in
                      let entry := M.copy (| γ0_0 |) in
                      let _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "alloc::collections::btree::map::entry::VacantEntry")
                                [
                                  Ty.path "move_core_types::account_address::AccountAddress";
                                  Ty.path "move_core_types::effects::AccountChangeSet";
                                  Ty.path "alloc::alloc::Global"
                                ],
                              "insert",
                              []
                            |),
                            [ M.read (| entry |); M.read (| account_changeset |) ]
                          |)
                        |) in
                      M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            M.alloc (| Value.StructTuple "core::result::Result::Ok" [ Value.Tuple [] ] |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_add_account_changeset :
      M.IsAssociatedFunction Self "add_account_changeset" add_account_changeset.
    
    (*
        pub fn accounts(&self) -> &BTreeMap<AccountAddress, AccountChangeSet> {
            &self.accounts
        }
    *)
    Definition accounts (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.get_struct_record_field
            (M.read (| self |))
            "move_core_types::effects::ChangeSet"
            "accounts"))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_accounts : M.IsAssociatedFunction Self "accounts" accounts.
    
    (*
        pub fn into_inner(self) -> BTreeMap<AccountAddress, AccountChangeSet> {
            self.accounts
        }
    *)
    Definition into_inner (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.get_struct_record_field self "move_core_types::effects::ChangeSet" "accounts"
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_into_inner : M.IsAssociatedFunction Self "into_inner" into_inner.
    
    (*
        fn get_or_insert_account_changeset(&mut self, addr: AccountAddress) -> &mut AccountChangeSet {
            match self.accounts.entry(addr) {
                btree_map::Entry::Occupied(entry) => entry.into_mut(),
                btree_map::Entry::Vacant(entry) => entry.insert(AccountChangeSet::new()),
            }
        }
    *)
    Definition get_or_insert_account_changeset (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; addr ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let addr := M.alloc (| addr |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloc::collections::btree::map::BTreeMap")
                      [
                        Ty.path "move_core_types::account_address::AccountAddress";
                        Ty.path "move_core_types::effects::AccountChangeSet";
                        Ty.path "alloc::alloc::Global"
                      ],
                    "entry",
                    []
                  |),
                  [
                    M.get_struct_record_field
                      (M.read (| self |))
                      "move_core_types::effects::ChangeSet"
                      "accounts";
                    M.read (| addr |)
                  ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "alloc::collections::btree::map::entry::Entry::Occupied",
                        0
                      |) in
                    let entry := M.copy (| γ0_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::collections::btree::map::entry::OccupiedEntry")
                            [
                              Ty.path "move_core_types::account_address::AccountAddress";
                              Ty.path "move_core_types::effects::AccountChangeSet";
                              Ty.path "alloc::alloc::Global"
                            ],
                          "into_mut",
                          []
                        |),
                        [ M.read (| entry |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "alloc::collections::btree::map::entry::Entry::Vacant",
                        0
                      |) in
                    let entry := M.copy (| γ0_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::collections::btree::map::entry::VacantEntry")
                            [
                              Ty.path "move_core_types::account_address::AccountAddress";
                              Ty.path "move_core_types::effects::AccountChangeSet";
                              Ty.path "alloc::alloc::Global"
                            ],
                          "insert",
                          []
                        |),
                        [
                          M.read (| entry |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "move_core_types::effects::AccountChangeSet",
                              "new",
                              []
                            |),
                            []
                          |)
                        ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_get_or_insert_account_changeset :
      M.IsAssociatedFunction Self "get_or_insert_account_changeset" get_or_insert_account_changeset.
    
    (*
        pub fn add_module_op(&mut self, module_id: ModuleId, op: Op<Vec<u8>>) -> Result<()> {
            let account = self.get_or_insert_account_changeset( *module_id.address());
            account.add_module_op(module_id.name().to_owned(), op)
        }
    *)
    Definition add_module_op (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; module_id; op ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let module_id := M.alloc (| module_id |) in
          let op := M.alloc (| op |) in
          M.read (|
            let account :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.path "move_core_types::effects::ChangeSet",
                    "get_or_insert_account_changeset",
                    []
                  |),
                  [
                    M.read (| self |);
                    M.read (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "move_core_types::language_storage::ModuleId",
                          "address",
                          []
                        |),
                        [ module_id ]
                      |)
                    |)
                  ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.path "move_core_types::effects::AccountChangeSet",
                  "add_module_op",
                  []
                |),
                [
                  M.read (| account |);
                  M.call_closure (|
                    M.get_trait_method (|
                      "alloc::borrow::ToOwned",
                      Ty.path "move_core_types::identifier::IdentStr",
                      [],
                      "to_owned",
                      []
                    |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "move_core_types::language_storage::ModuleId",
                          "name",
                          []
                        |),
                        [ module_id ]
                      |)
                    ]
                  |);
                  M.read (| op |)
                ]
              |)
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_add_module_op :
      M.IsAssociatedFunction Self "add_module_op" add_module_op.
    
    (*
        pub fn add_resource_op(
            &mut self,
            addr: AccountAddress,
            struct_tag: StructTag,
            op: Op<Vec<u8>>,
        ) -> Result<()> {
            let account = self.get_or_insert_account_changeset(addr);
            account.add_resource_op(struct_tag, op)
        }
    *)
    Definition add_resource_op (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; addr; struct_tag; op ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let addr := M.alloc (| addr |) in
          let struct_tag := M.alloc (| struct_tag |) in
          let op := M.alloc (| op |) in
          M.read (|
            let account :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.path "move_core_types::effects::ChangeSet",
                    "get_or_insert_account_changeset",
                    []
                  |),
                  [ M.read (| self |); M.read (| addr |) ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.path "move_core_types::effects::AccountChangeSet",
                  "add_resource_op",
                  []
                |),
                [ M.read (| account |); M.read (| struct_tag |); M.read (| op |) ]
              |)
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_add_resource_op :
      M.IsAssociatedFunction Self "add_resource_op" add_resource_op.
    
    (*
        pub fn squash(&mut self, other: Self) -> Result<()> {
            for (addr, other_account_changeset) in other.accounts {
                match self.accounts.entry(addr) {
                    btree_map::Entry::Occupied(mut entry) => {
                        entry.get_mut().squash(other_account_changeset)?;
                    }
                    btree_map::Entry::Vacant(entry) => {
                        entry.insert(other_account_changeset);
                    }
                }
            }
            Ok(())
        }
    *)
    Definition squash (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            let _ :=
              M.use
                (M.match_operator (|
                  M.alloc (|
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::iter::traits::collect::IntoIterator",
                        Ty.apply
                          (Ty.path "alloc::collections::btree::map::BTreeMap")
                          [
                            Ty.path "move_core_types::account_address::AccountAddress";
                            Ty.path "move_core_types::effects::AccountChangeSet";
                            Ty.path "alloc::alloc::Global"
                          ],
                        [],
                        "into_iter",
                        []
                      |),
                      [
                        M.read (|
                          M.get_struct_record_field
                            other
                            "move_core_types::effects::ChangeSet"
                            "accounts"
                        |)
                      ]
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let iter := M.copy (| γ |) in
                        M.loop (|
                          ltac:(M.monadic
                            (let _ :=
                              M.match_operator (|
                                M.alloc (|
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::iter::traits::iterator::Iterator",
                                      Ty.apply
                                        (Ty.path "alloc::collections::btree::map::IntoIter")
                                        [
                                          Ty.path
                                            "move_core_types::account_address::AccountAddress";
                                          Ty.path "move_core_types::effects::AccountChangeSet";
                                          Ty.path "alloc::alloc::Global"
                                        ],
                                      [],
                                      "next",
                                      []
                                    |),
                                    [ iter ]
                                  |)
                                |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (M.alloc (|
                                        M.never_to_any (| M.read (| M.break (||) |) |)
                                      |)));
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ0_0 :=
                                        M.get_struct_tuple_field_or_break_match (|
                                          γ,
                                          "core::option::Option::Some",
                                          0
                                        |) in
                                      let γ1_0 := M.get_tuple_field γ0_0 0 in
                                      let γ1_1 := M.get_tuple_field γ0_0 1 in
                                      let addr := M.copy (| γ1_0 |) in
                                      let other_account_changeset := M.copy (| γ1_1 |) in
                                      M.match_operator (|
                                        M.alloc (|
                                          M.call_closure (|
                                            M.get_associated_function (|
                                              Ty.apply
                                                (Ty.path "alloc::collections::btree::map::BTreeMap")
                                                [
                                                  Ty.path
                                                    "move_core_types::account_address::AccountAddress";
                                                  Ty.path
                                                    "move_core_types::effects::AccountChangeSet";
                                                  Ty.path "alloc::alloc::Global"
                                                ],
                                              "entry",
                                              []
                                            |),
                                            [
                                              M.get_struct_record_field
                                                (M.read (| self |))
                                                "move_core_types::effects::ChangeSet"
                                                "accounts";
                                              M.read (| addr |)
                                            ]
                                          |)
                                        |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let γ0_0 :=
                                                M.get_struct_tuple_field_or_break_match (|
                                                  γ,
                                                  "alloc::collections::btree::map::entry::Entry::Occupied",
                                                  0
                                                |) in
                                              let entry := M.copy (| γ0_0 |) in
                                              let _ :=
                                                M.match_operator (|
                                                  M.alloc (|
                                                    M.call_closure (|
                                                      M.get_trait_method (|
                                                        "core::ops::try_trait::Try",
                                                        Ty.apply
                                                          (Ty.path "core::result::Result")
                                                          [ Ty.tuple []; Ty.path "anyhow::Error" ],
                                                        [],
                                                        "branch",
                                                        []
                                                      |),
                                                      [
                                                        M.call_closure (|
                                                          M.get_associated_function (|
                                                            Ty.path
                                                              "move_core_types::effects::AccountChangeSet",
                                                            "squash",
                                                            []
                                                          |),
                                                          [
                                                            M.call_closure (|
                                                              M.get_associated_function (|
                                                                Ty.apply
                                                                  (Ty.path
                                                                    "alloc::collections::btree::map::entry::OccupiedEntry")
                                                                  [
                                                                    Ty.path
                                                                      "move_core_types::account_address::AccountAddress";
                                                                    Ty.path
                                                                      "move_core_types::effects::AccountChangeSet";
                                                                    Ty.path "alloc::alloc::Global"
                                                                  ],
                                                                "get_mut",
                                                                []
                                                              |),
                                                              [ entry ]
                                                            |);
                                                            M.read (| other_account_changeset |)
                                                          ]
                                                        |)
                                                      ]
                                                    |)
                                                  |),
                                                  [
                                                    fun γ =>
                                                      ltac:(M.monadic
                                                        (let γ0_0 :=
                                                          M.get_struct_tuple_field_or_break_match (|
                                                            γ,
                                                            "core::ops::control_flow::ControlFlow::Break",
                                                            0
                                                          |) in
                                                        let residual := M.copy (| γ0_0 |) in
                                                        M.alloc (|
                                                          M.never_to_any (|
                                                            M.read (|
                                                              M.return_ (|
                                                                M.call_closure (|
                                                                  M.get_trait_method (|
                                                                    "core::ops::try_trait::FromResidual",
                                                                    Ty.apply
                                                                      (Ty.path
                                                                        "core::result::Result")
                                                                      [
                                                                        Ty.tuple [];
                                                                        Ty.path "anyhow::Error"
                                                                      ],
                                                                    [
                                                                      Ty.apply
                                                                        (Ty.path
                                                                          "core::result::Result")
                                                                        [
                                                                          Ty.path
                                                                            "core::convert::Infallible";
                                                                          Ty.path "anyhow::Error"
                                                                        ]
                                                                    ],
                                                                    "from_residual",
                                                                    []
                                                                  |),
                                                                  [ M.read (| residual |) ]
                                                                |)
                                                              |)
                                                            |)
                                                          |)
                                                        |)));
                                                    fun γ =>
                                                      ltac:(M.monadic
                                                        (let γ0_0 :=
                                                          M.get_struct_tuple_field_or_break_match (|
                                                            γ,
                                                            "core::ops::control_flow::ControlFlow::Continue",
                                                            0
                                                          |) in
                                                        let val := M.copy (| γ0_0 |) in
                                                        val))
                                                  ]
                                                |) in
                                              M.alloc (| Value.Tuple [] |)));
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let γ0_0 :=
                                                M.get_struct_tuple_field_or_break_match (|
                                                  γ,
                                                  "alloc::collections::btree::map::entry::Entry::Vacant",
                                                  0
                                                |) in
                                              let entry := M.copy (| γ0_0 |) in
                                              let _ :=
                                                M.alloc (|
                                                  M.call_closure (|
                                                    M.get_associated_function (|
                                                      Ty.apply
                                                        (Ty.path
                                                          "alloc::collections::btree::map::entry::VacantEntry")
                                                        [
                                                          Ty.path
                                                            "move_core_types::account_address::AccountAddress";
                                                          Ty.path
                                                            "move_core_types::effects::AccountChangeSet";
                                                          Ty.path "alloc::alloc::Global"
                                                        ],
                                                      "insert",
                                                      []
                                                    |),
                                                    [
                                                      M.read (| entry |);
                                                      M.read (| other_account_changeset |)
                                                    ]
                                                  |)
                                                |) in
                                              M.alloc (| Value.Tuple [] |)))
                                        ]
                                      |)))
                                ]
                              |) in
                            M.alloc (| Value.Tuple [] |)))
                        |)))
                  ]
                |)) in
            M.alloc (| Value.StructTuple "core::result::Result::Ok" [ Value.Tuple [] ] |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_squash : M.IsAssociatedFunction Self "squash" squash.
    
    (*
        pub fn into_modules(self) -> impl Iterator<Item = (ModuleId, Op<Vec<u8>>)> {
            self.accounts.into_iter().flat_map(|(addr, account)| {
                account
                    .modules
                    .into_iter()
                    .map(move |(module_name, blob_opt)| (ModuleId::new(addr, module_name), blob_opt))
            })
        }
    *)
    Definition into_modules (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::iter::traits::iterator::Iterator",
              Ty.apply
                (Ty.path "alloc::collections::btree::map::IntoIter")
                [
                  Ty.path "move_core_types::account_address::AccountAddress";
                  Ty.path "move_core_types::effects::AccountChangeSet";
                  Ty.path "alloc::alloc::Global"
                ],
              [],
              "flat_map",
              [
                Ty.apply
                  (Ty.path "core::iter::adapters::map::Map")
                  [
                    Ty.apply
                      (Ty.path "alloc::collections::btree::map::IntoIter")
                      [
                        Ty.path "move_core_types::identifier::Identifier";
                        Ty.apply
                          (Ty.path "move_core_types::effects::Op")
                          [
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                          ];
                        Ty.path "alloc::alloc::Global"
                      ];
                    Ty.function
                      [
                        Ty.tuple
                          [
                            Ty.tuple
                              [
                                Ty.path "move_core_types::identifier::Identifier";
                                Ty.apply
                                  (Ty.path "move_core_types::effects::Op")
                                  [
                                    Ty.apply
                                      (Ty.path "alloc::vec::Vec")
                                      [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                                  ]
                              ]
                          ]
                      ]
                      (Ty.tuple
                        [
                          Ty.path "move_core_types::language_storage::ModuleId";
                          Ty.apply
                            (Ty.path "move_core_types::effects::Op")
                            [
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                            ]
                        ])
                  ];
                Ty.function
                  [
                    Ty.tuple
                      [
                        Ty.tuple
                          [
                            Ty.path "move_core_types::account_address::AccountAddress";
                            Ty.path "move_core_types::effects::AccountChangeSet"
                          ]
                      ]
                  ]
                  (Ty.apply
                    (Ty.path "core::iter::adapters::map::Map")
                    [
                      Ty.apply
                        (Ty.path "alloc::collections::btree::map::IntoIter")
                        [
                          Ty.path "move_core_types::identifier::Identifier";
                          Ty.apply
                            (Ty.path "move_core_types::effects::Op")
                            [
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                            ];
                          Ty.path "alloc::alloc::Global"
                        ];
                      Ty.function
                        [
                          Ty.tuple
                            [
                              Ty.tuple
                                [
                                  Ty.path "move_core_types::identifier::Identifier";
                                  Ty.apply
                                    (Ty.path "move_core_types::effects::Op")
                                    [
                                      Ty.apply
                                        (Ty.path "alloc::vec::Vec")
                                        [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                                    ]
                                ]
                            ]
                        ]
                        (Ty.tuple
                          [
                            Ty.path "move_core_types::language_storage::ModuleId";
                            Ty.apply
                              (Ty.path "move_core_types::effects::Op")
                              [
                                Ty.apply
                                  (Ty.path "alloc::vec::Vec")
                                  [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                              ]
                          ])
                    ])
              ]
            |),
            [
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::collect::IntoIterator",
                  Ty.apply
                    (Ty.path "alloc::collections::btree::map::BTreeMap")
                    [
                      Ty.path "move_core_types::account_address::AccountAddress";
                      Ty.path "move_core_types::effects::AccountChangeSet";
                      Ty.path "alloc::alloc::Global"
                    ],
                  [],
                  "into_iter",
                  []
                |),
                [
                  M.read (|
                    M.get_struct_record_field self "move_core_types::effects::ChangeSet" "accounts"
                  |)
                ]
              |);
              M.closure
                (fun γ =>
                  ltac:(M.monadic
                    match γ with
                    | [ α0 ] =>
                      M.match_operator (|
                        M.alloc (| α0 |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 := M.get_tuple_field γ 0 in
                              let γ0_1 := M.get_tuple_field γ 1 in
                              let addr := M.copy (| γ0_0 |) in
                              let account := M.copy (| γ0_1 |) in
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::iter::traits::iterator::Iterator",
                                  Ty.apply
                                    (Ty.path "alloc::collections::btree::map::IntoIter")
                                    [
                                      Ty.path "move_core_types::identifier::Identifier";
                                      Ty.apply
                                        (Ty.path "move_core_types::effects::Op")
                                        [
                                          Ty.apply
                                            (Ty.path "alloc::vec::Vec")
                                            [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                                        ];
                                      Ty.path "alloc::alloc::Global"
                                    ],
                                  [],
                                  "map",
                                  [
                                    Ty.tuple
                                      [
                                        Ty.path "move_core_types::language_storage::ModuleId";
                                        Ty.apply
                                          (Ty.path "move_core_types::effects::Op")
                                          [
                                            Ty.apply
                                              (Ty.path "alloc::vec::Vec")
                                              [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                                          ]
                                      ];
                                    Ty.function
                                      [
                                        Ty.tuple
                                          [
                                            Ty.tuple
                                              [
                                                Ty.path "move_core_types::identifier::Identifier";
                                                Ty.apply
                                                  (Ty.path "move_core_types::effects::Op")
                                                  [
                                                    Ty.apply
                                                      (Ty.path "alloc::vec::Vec")
                                                      [ Ty.path "u8"; Ty.path "alloc::alloc::Global"
                                                      ]
                                                  ]
                                              ]
                                          ]
                                      ]
                                      (Ty.tuple
                                        [
                                          Ty.path "move_core_types::language_storage::ModuleId";
                                          Ty.apply
                                            (Ty.path "move_core_types::effects::Op")
                                            [
                                              Ty.apply
                                                (Ty.path "alloc::vec::Vec")
                                                [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                                            ]
                                        ])
                                  ]
                                |),
                                [
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::iter::traits::collect::IntoIterator",
                                      Ty.apply
                                        (Ty.path "alloc::collections::btree::map::BTreeMap")
                                        [
                                          Ty.path "move_core_types::identifier::Identifier";
                                          Ty.apply
                                            (Ty.path "move_core_types::effects::Op")
                                            [
                                              Ty.apply
                                                (Ty.path "alloc::vec::Vec")
                                                [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                                            ];
                                          Ty.path "alloc::alloc::Global"
                                        ],
                                      [],
                                      "into_iter",
                                      []
                                    |),
                                    [
                                      M.read (|
                                        M.get_struct_record_field
                                          account
                                          "move_core_types::effects::AccountChangeSet"
                                          "modules"
                                      |)
                                    ]
                                  |);
                                  M.closure
                                    (fun γ =>
                                      ltac:(M.monadic
                                        match γ with
                                        | [ α0 ] =>
                                          M.match_operator (|
                                            M.alloc (| α0 |),
                                            [
                                              fun γ =>
                                                ltac:(M.monadic
                                                  (let γ0_0 := M.get_tuple_field γ 0 in
                                                  let γ0_1 := M.get_tuple_field γ 1 in
                                                  let module_name := M.copy (| γ0_0 |) in
                                                  let blob_opt := M.copy (| γ0_1 |) in
                                                  Value.Tuple
                                                    [
                                                      M.call_closure (|
                                                        M.get_associated_function (|
                                                          Ty.path
                                                            "move_core_types::language_storage::ModuleId",
                                                          "new",
                                                          []
                                                        |),
                                                        [
                                                          M.read (| addr |);
                                                          M.read (| module_name |)
                                                        ]
                                                      |);
                                                      M.read (| blob_opt |)
                                                    ]))
                                            ]
                                          |)
                                        | _ => M.impossible (||)
                                        end))
                                ]
                              |)))
                        ]
                      |)
                    | _ => M.impossible (||)
                    end))
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_into_modules : M.IsAssociatedFunction Self "into_modules" into_modules.
    
    (*
        pub fn modules(&self) -> impl Iterator<Item = (AccountAddress, &Identifier, Op<&[u8]>)> {
            self.accounts.iter().flat_map(|(addr, account)| {
                let addr = *addr;
                account
                    .modules
                    .iter()
                    .map(move |(module_name, op)| (addr, module_name, op.as_ref().map(|v| v.as_ref())))
            })
        }
    *)
    Definition modules (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::iter::traits::iterator::Iterator",
              Ty.apply
                (Ty.path "alloc::collections::btree::map::Iter")
                [
                  Ty.path "move_core_types::account_address::AccountAddress";
                  Ty.path "move_core_types::effects::AccountChangeSet"
                ],
              [],
              "flat_map",
              [
                Ty.apply
                  (Ty.path "core::iter::adapters::map::Map")
                  [
                    Ty.apply
                      (Ty.path "alloc::collections::btree::map::Iter")
                      [
                        Ty.path "move_core_types::identifier::Identifier";
                        Ty.apply
                          (Ty.path "move_core_types::effects::Op")
                          [
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                          ]
                      ];
                    Ty.function
                      [
                        Ty.tuple
                          [
                            Ty.tuple
                              [
                                Ty.apply
                                  (Ty.path "&")
                                  [ Ty.path "move_core_types::identifier::Identifier" ];
                                Ty.apply
                                  (Ty.path "&")
                                  [
                                    Ty.apply
                                      (Ty.path "move_core_types::effects::Op")
                                      [
                                        Ty.apply
                                          (Ty.path "alloc::vec::Vec")
                                          [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                                      ]
                                  ]
                              ]
                          ]
                      ]
                      (Ty.tuple
                        [
                          Ty.path "move_core_types::account_address::AccountAddress";
                          Ty.apply
                            (Ty.path "&")
                            [ Ty.path "move_core_types::identifier::Identifier" ];
                          Ty.apply
                            (Ty.path "move_core_types::effects::Op")
                            [ Ty.apply (Ty.path "&") [ Ty.apply (Ty.path "slice") [ Ty.path "u8" ] ]
                            ]
                        ])
                  ];
                Ty.function
                  [
                    Ty.tuple
                      [
                        Ty.tuple
                          [
                            Ty.apply
                              (Ty.path "&")
                              [ Ty.path "move_core_types::account_address::AccountAddress" ];
                            Ty.apply
                              (Ty.path "&")
                              [ Ty.path "move_core_types::effects::AccountChangeSet" ]
                          ]
                      ]
                  ]
                  (Ty.apply
                    (Ty.path "core::iter::adapters::map::Map")
                    [
                      Ty.apply
                        (Ty.path "alloc::collections::btree::map::Iter")
                        [
                          Ty.path "move_core_types::identifier::Identifier";
                          Ty.apply
                            (Ty.path "move_core_types::effects::Op")
                            [
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                            ]
                        ];
                      Ty.function
                        [
                          Ty.tuple
                            [
                              Ty.tuple
                                [
                                  Ty.apply
                                    (Ty.path "&")
                                    [ Ty.path "move_core_types::identifier::Identifier" ];
                                  Ty.apply
                                    (Ty.path "&")
                                    [
                                      Ty.apply
                                        (Ty.path "move_core_types::effects::Op")
                                        [
                                          Ty.apply
                                            (Ty.path "alloc::vec::Vec")
                                            [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                                        ]
                                    ]
                                ]
                            ]
                        ]
                        (Ty.tuple
                          [
                            Ty.path "move_core_types::account_address::AccountAddress";
                            Ty.apply
                              (Ty.path "&")
                              [ Ty.path "move_core_types::identifier::Identifier" ];
                            Ty.apply
                              (Ty.path "move_core_types::effects::Op")
                              [
                                Ty.apply
                                  (Ty.path "&")
                                  [ Ty.apply (Ty.path "slice") [ Ty.path "u8" ] ]
                              ]
                          ])
                    ])
              ]
            |),
            [
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::collections::btree::map::BTreeMap")
                    [
                      Ty.path "move_core_types::account_address::AccountAddress";
                      Ty.path "move_core_types::effects::AccountChangeSet";
                      Ty.path "alloc::alloc::Global"
                    ],
                  "iter",
                  []
                |),
                [
                  M.get_struct_record_field
                    (M.read (| self |))
                    "move_core_types::effects::ChangeSet"
                    "accounts"
                ]
              |);
              M.closure
                (fun γ =>
                  ltac:(M.monadic
                    match γ with
                    | [ α0 ] =>
                      M.match_operator (|
                        M.alloc (| α0 |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 := M.get_tuple_field γ 0 in
                              let γ0_1 := M.get_tuple_field γ 1 in
                              let addr := M.copy (| γ0_0 |) in
                              let account := M.copy (| γ0_1 |) in
                              M.read (|
                                let addr := M.copy (| M.read (| addr |) |) in
                                M.alloc (|
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::iter::traits::iterator::Iterator",
                                      Ty.apply
                                        (Ty.path "alloc::collections::btree::map::Iter")
                                        [
                                          Ty.path "move_core_types::identifier::Identifier";
                                          Ty.apply
                                            (Ty.path "move_core_types::effects::Op")
                                            [
                                              Ty.apply
                                                (Ty.path "alloc::vec::Vec")
                                                [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                                            ]
                                        ],
                                      [],
                                      "map",
                                      [
                                        Ty.tuple
                                          [
                                            Ty.path
                                              "move_core_types::account_address::AccountAddress";
                                            Ty.apply
                                              (Ty.path "&")
                                              [ Ty.path "move_core_types::identifier::Identifier" ];
                                            Ty.apply
                                              (Ty.path "move_core_types::effects::Op")
                                              [
                                                Ty.apply
                                                  (Ty.path "&")
                                                  [ Ty.apply (Ty.path "slice") [ Ty.path "u8" ] ]
                                              ]
                                          ];
                                        Ty.function
                                          [
                                            Ty.tuple
                                              [
                                                Ty.tuple
                                                  [
                                                    Ty.apply
                                                      (Ty.path "&")
                                                      [
                                                        Ty.path
                                                          "move_core_types::identifier::Identifier"
                                                      ];
                                                    Ty.apply
                                                      (Ty.path "&")
                                                      [
                                                        Ty.apply
                                                          (Ty.path "move_core_types::effects::Op")
                                                          [
                                                            Ty.apply
                                                              (Ty.path "alloc::vec::Vec")
                                                              [
                                                                Ty.path "u8";
                                                                Ty.path "alloc::alloc::Global"
                                                              ]
                                                          ]
                                                      ]
                                                  ]
                                              ]
                                          ]
                                          (Ty.tuple
                                            [
                                              Ty.path
                                                "move_core_types::account_address::AccountAddress";
                                              Ty.apply
                                                (Ty.path "&")
                                                [ Ty.path "move_core_types::identifier::Identifier"
                                                ];
                                              Ty.apply
                                                (Ty.path "move_core_types::effects::Op")
                                                [
                                                  Ty.apply
                                                    (Ty.path "&")
                                                    [ Ty.apply (Ty.path "slice") [ Ty.path "u8" ] ]
                                                ]
                                            ])
                                      ]
                                    |),
                                    [
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "alloc::collections::btree::map::BTreeMap")
                                            [
                                              Ty.path "move_core_types::identifier::Identifier";
                                              Ty.apply
                                                (Ty.path "move_core_types::effects::Op")
                                                [
                                                  Ty.apply
                                                    (Ty.path "alloc::vec::Vec")
                                                    [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                                                ];
                                              Ty.path "alloc::alloc::Global"
                                            ],
                                          "iter",
                                          []
                                        |),
                                        [
                                          M.get_struct_record_field
                                            (M.read (| account |))
                                            "move_core_types::effects::AccountChangeSet"
                                            "modules"
                                        ]
                                      |);
                                      M.closure
                                        (fun γ =>
                                          ltac:(M.monadic
                                            match γ with
                                            | [ α0 ] =>
                                              M.match_operator (|
                                                M.alloc (| α0 |),
                                                [
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (let γ0_0 := M.get_tuple_field γ 0 in
                                                      let γ0_1 := M.get_tuple_field γ 1 in
                                                      let module_name := M.copy (| γ0_0 |) in
                                                      let op := M.copy (| γ0_1 |) in
                                                      Value.Tuple
                                                        [
                                                          M.read (| addr |);
                                                          M.read (| module_name |);
                                                          M.call_closure (|
                                                            M.get_associated_function (|
                                                              Ty.apply
                                                                (Ty.path
                                                                  "move_core_types::effects::Op")
                                                                [
                                                                  Ty.apply
                                                                    (Ty.path "&")
                                                                    [
                                                                      Ty.apply
                                                                        (Ty.path "alloc::vec::Vec")
                                                                        [
                                                                          Ty.path "u8";
                                                                          Ty.path
                                                                            "alloc::alloc::Global"
                                                                        ]
                                                                    ]
                                                                ],
                                                              "map",
                                                              [
                                                                Ty.function
                                                                  [
                                                                    Ty.tuple
                                                                      [
                                                                        Ty.apply
                                                                          (Ty.path "&")
                                                                          [
                                                                            Ty.apply
                                                                              (Ty.path
                                                                                "alloc::vec::Vec")
                                                                              [
                                                                                Ty.path "u8";
                                                                                Ty.path
                                                                                  "alloc::alloc::Global"
                                                                              ]
                                                                          ]
                                                                      ]
                                                                  ]
                                                                  (Ty.apply
                                                                    (Ty.path "&")
                                                                    [
                                                                      Ty.apply
                                                                        (Ty.path "slice")
                                                                        [ Ty.path "u8" ]
                                                                    ]);
                                                                Ty.apply
                                                                  (Ty.path "&")
                                                                  [
                                                                    Ty.apply
                                                                      (Ty.path "slice")
                                                                      [ Ty.path "u8" ]
                                                                  ]
                                                              ]
                                                            |),
                                                            [
                                                              M.call_closure (|
                                                                M.get_associated_function (|
                                                                  Ty.apply
                                                                    (Ty.path
                                                                      "move_core_types::effects::Op")
                                                                    [
                                                                      Ty.apply
                                                                        (Ty.path "alloc::vec::Vec")
                                                                        [
                                                                          Ty.path "u8";
                                                                          Ty.path
                                                                            "alloc::alloc::Global"
                                                                        ]
                                                                    ],
                                                                  "as_ref",
                                                                  []
                                                                |),
                                                                [ M.read (| op |) ]
                                                              |);
                                                              M.closure
                                                                (fun γ =>
                                                                  ltac:(M.monadic
                                                                    match γ with
                                                                    | [ α0 ] =>
                                                                      M.match_operator (|
                                                                        M.alloc (| α0 |),
                                                                        [
                                                                          fun γ =>
                                                                            ltac:(M.monadic
                                                                              (let v :=
                                                                                M.copy (| γ |) in
                                                                              M.call_closure (|
                                                                                M.get_trait_method (|
                                                                                  "core::convert::AsRef",
                                                                                  Ty.apply
                                                                                    (Ty.path
                                                                                      "alloc::vec::Vec")
                                                                                    [
                                                                                      Ty.path "u8";
                                                                                      Ty.path
                                                                                        "alloc::alloc::Global"
                                                                                    ],
                                                                                  [
                                                                                    Ty.apply
                                                                                      (Ty.path
                                                                                        "slice")
                                                                                      [ Ty.path "u8"
                                                                                      ]
                                                                                  ],
                                                                                  "as_ref",
                                                                                  []
                                                                                |),
                                                                                [ M.read (| v |) ]
                                                                              |)))
                                                                        ]
                                                                      |)
                                                                    | _ => M.impossible (||)
                                                                    end))
                                                            ]
                                                          |)
                                                        ]))
                                                ]
                                              |)
                                            | _ => M.impossible (||)
                                            end))
                                    ]
                                  |)
                                |)
                              |)))
                        ]
                      |)
                    | _ => M.impossible (||)
                    end))
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_modules : M.IsAssociatedFunction Self "modules" modules.
    
    (*
        pub fn resources(&self) -> impl Iterator<Item = (AccountAddress, &StructTag, Op<&[u8]>)> {
            self.accounts.iter().flat_map(|(addr, account)| {
                let addr = *addr;
                account
                    .resources
                    .iter()
                    .map(move |(struct_tag, op)| (addr, struct_tag, op.as_ref().map(|v| v.as_ref())))
            })
        }
    *)
    Definition resources (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::iter::traits::iterator::Iterator",
              Ty.apply
                (Ty.path "alloc::collections::btree::map::Iter")
                [
                  Ty.path "move_core_types::account_address::AccountAddress";
                  Ty.path "move_core_types::effects::AccountChangeSet"
                ],
              [],
              "flat_map",
              [
                Ty.apply
                  (Ty.path "core::iter::adapters::map::Map")
                  [
                    Ty.apply
                      (Ty.path "alloc::collections::btree::map::Iter")
                      [
                        Ty.path "move_core_types::language_storage::StructTag";
                        Ty.apply
                          (Ty.path "move_core_types::effects::Op")
                          [
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                          ]
                      ];
                    Ty.function
                      [
                        Ty.tuple
                          [
                            Ty.tuple
                              [
                                Ty.apply
                                  (Ty.path "&")
                                  [ Ty.path "move_core_types::language_storage::StructTag" ];
                                Ty.apply
                                  (Ty.path "&")
                                  [
                                    Ty.apply
                                      (Ty.path "move_core_types::effects::Op")
                                      [
                                        Ty.apply
                                          (Ty.path "alloc::vec::Vec")
                                          [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                                      ]
                                  ]
                              ]
                          ]
                      ]
                      (Ty.tuple
                        [
                          Ty.path "move_core_types::account_address::AccountAddress";
                          Ty.apply
                            (Ty.path "&")
                            [ Ty.path "move_core_types::language_storage::StructTag" ];
                          Ty.apply
                            (Ty.path "move_core_types::effects::Op")
                            [ Ty.apply (Ty.path "&") [ Ty.apply (Ty.path "slice") [ Ty.path "u8" ] ]
                            ]
                        ])
                  ];
                Ty.function
                  [
                    Ty.tuple
                      [
                        Ty.tuple
                          [
                            Ty.apply
                              (Ty.path "&")
                              [ Ty.path "move_core_types::account_address::AccountAddress" ];
                            Ty.apply
                              (Ty.path "&")
                              [ Ty.path "move_core_types::effects::AccountChangeSet" ]
                          ]
                      ]
                  ]
                  (Ty.apply
                    (Ty.path "core::iter::adapters::map::Map")
                    [
                      Ty.apply
                        (Ty.path "alloc::collections::btree::map::Iter")
                        [
                          Ty.path "move_core_types::language_storage::StructTag";
                          Ty.apply
                            (Ty.path "move_core_types::effects::Op")
                            [
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                            ]
                        ];
                      Ty.function
                        [
                          Ty.tuple
                            [
                              Ty.tuple
                                [
                                  Ty.apply
                                    (Ty.path "&")
                                    [ Ty.path "move_core_types::language_storage::StructTag" ];
                                  Ty.apply
                                    (Ty.path "&")
                                    [
                                      Ty.apply
                                        (Ty.path "move_core_types::effects::Op")
                                        [
                                          Ty.apply
                                            (Ty.path "alloc::vec::Vec")
                                            [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                                        ]
                                    ]
                                ]
                            ]
                        ]
                        (Ty.tuple
                          [
                            Ty.path "move_core_types::account_address::AccountAddress";
                            Ty.apply
                              (Ty.path "&")
                              [ Ty.path "move_core_types::language_storage::StructTag" ];
                            Ty.apply
                              (Ty.path "move_core_types::effects::Op")
                              [
                                Ty.apply
                                  (Ty.path "&")
                                  [ Ty.apply (Ty.path "slice") [ Ty.path "u8" ] ]
                              ]
                          ])
                    ])
              ]
            |),
            [
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::collections::btree::map::BTreeMap")
                    [
                      Ty.path "move_core_types::account_address::AccountAddress";
                      Ty.path "move_core_types::effects::AccountChangeSet";
                      Ty.path "alloc::alloc::Global"
                    ],
                  "iter",
                  []
                |),
                [
                  M.get_struct_record_field
                    (M.read (| self |))
                    "move_core_types::effects::ChangeSet"
                    "accounts"
                ]
              |);
              M.closure
                (fun γ =>
                  ltac:(M.monadic
                    match γ with
                    | [ α0 ] =>
                      M.match_operator (|
                        M.alloc (| α0 |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 := M.get_tuple_field γ 0 in
                              let γ0_1 := M.get_tuple_field γ 1 in
                              let addr := M.copy (| γ0_0 |) in
                              let account := M.copy (| γ0_1 |) in
                              M.read (|
                                let addr := M.copy (| M.read (| addr |) |) in
                                M.alloc (|
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::iter::traits::iterator::Iterator",
                                      Ty.apply
                                        (Ty.path "alloc::collections::btree::map::Iter")
                                        [
                                          Ty.path "move_core_types::language_storage::StructTag";
                                          Ty.apply
                                            (Ty.path "move_core_types::effects::Op")
                                            [
                                              Ty.apply
                                                (Ty.path "alloc::vec::Vec")
                                                [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                                            ]
                                        ],
                                      [],
                                      "map",
                                      [
                                        Ty.tuple
                                          [
                                            Ty.path
                                              "move_core_types::account_address::AccountAddress";
                                            Ty.apply
                                              (Ty.path "&")
                                              [
                                                Ty.path
                                                  "move_core_types::language_storage::StructTag"
                                              ];
                                            Ty.apply
                                              (Ty.path "move_core_types::effects::Op")
                                              [
                                                Ty.apply
                                                  (Ty.path "&")
                                                  [ Ty.apply (Ty.path "slice") [ Ty.path "u8" ] ]
                                              ]
                                          ];
                                        Ty.function
                                          [
                                            Ty.tuple
                                              [
                                                Ty.tuple
                                                  [
                                                    Ty.apply
                                                      (Ty.path "&")
                                                      [
                                                        Ty.path
                                                          "move_core_types::language_storage::StructTag"
                                                      ];
                                                    Ty.apply
                                                      (Ty.path "&")
                                                      [
                                                        Ty.apply
                                                          (Ty.path "move_core_types::effects::Op")
                                                          [
                                                            Ty.apply
                                                              (Ty.path "alloc::vec::Vec")
                                                              [
                                                                Ty.path "u8";
                                                                Ty.path "alloc::alloc::Global"
                                                              ]
                                                          ]
                                                      ]
                                                  ]
                                              ]
                                          ]
                                          (Ty.tuple
                                            [
                                              Ty.path
                                                "move_core_types::account_address::AccountAddress";
                                              Ty.apply
                                                (Ty.path "&")
                                                [
                                                  Ty.path
                                                    "move_core_types::language_storage::StructTag"
                                                ];
                                              Ty.apply
                                                (Ty.path "move_core_types::effects::Op")
                                                [
                                                  Ty.apply
                                                    (Ty.path "&")
                                                    [ Ty.apply (Ty.path "slice") [ Ty.path "u8" ] ]
                                                ]
                                            ])
                                      ]
                                    |),
                                    [
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "alloc::collections::btree::map::BTreeMap")
                                            [
                                              Ty.path
                                                "move_core_types::language_storage::StructTag";
                                              Ty.apply
                                                (Ty.path "move_core_types::effects::Op")
                                                [
                                                  Ty.apply
                                                    (Ty.path "alloc::vec::Vec")
                                                    [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                                                ];
                                              Ty.path "alloc::alloc::Global"
                                            ],
                                          "iter",
                                          []
                                        |),
                                        [
                                          M.get_struct_record_field
                                            (M.read (| account |))
                                            "move_core_types::effects::AccountChangeSet"
                                            "resources"
                                        ]
                                      |);
                                      M.closure
                                        (fun γ =>
                                          ltac:(M.monadic
                                            match γ with
                                            | [ α0 ] =>
                                              M.match_operator (|
                                                M.alloc (| α0 |),
                                                [
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (let γ0_0 := M.get_tuple_field γ 0 in
                                                      let γ0_1 := M.get_tuple_field γ 1 in
                                                      let struct_tag := M.copy (| γ0_0 |) in
                                                      let op := M.copy (| γ0_1 |) in
                                                      Value.Tuple
                                                        [
                                                          M.read (| addr |);
                                                          M.read (| struct_tag |);
                                                          M.call_closure (|
                                                            M.get_associated_function (|
                                                              Ty.apply
                                                                (Ty.path
                                                                  "move_core_types::effects::Op")
                                                                [
                                                                  Ty.apply
                                                                    (Ty.path "&")
                                                                    [
                                                                      Ty.apply
                                                                        (Ty.path "alloc::vec::Vec")
                                                                        [
                                                                          Ty.path "u8";
                                                                          Ty.path
                                                                            "alloc::alloc::Global"
                                                                        ]
                                                                    ]
                                                                ],
                                                              "map",
                                                              [
                                                                Ty.function
                                                                  [
                                                                    Ty.tuple
                                                                      [
                                                                        Ty.apply
                                                                          (Ty.path "&")
                                                                          [
                                                                            Ty.apply
                                                                              (Ty.path
                                                                                "alloc::vec::Vec")
                                                                              [
                                                                                Ty.path "u8";
                                                                                Ty.path
                                                                                  "alloc::alloc::Global"
                                                                              ]
                                                                          ]
                                                                      ]
                                                                  ]
                                                                  (Ty.apply
                                                                    (Ty.path "&")
                                                                    [
                                                                      Ty.apply
                                                                        (Ty.path "slice")
                                                                        [ Ty.path "u8" ]
                                                                    ]);
                                                                Ty.apply
                                                                  (Ty.path "&")
                                                                  [
                                                                    Ty.apply
                                                                      (Ty.path "slice")
                                                                      [ Ty.path "u8" ]
                                                                  ]
                                                              ]
                                                            |),
                                                            [
                                                              M.call_closure (|
                                                                M.get_associated_function (|
                                                                  Ty.apply
                                                                    (Ty.path
                                                                      "move_core_types::effects::Op")
                                                                    [
                                                                      Ty.apply
                                                                        (Ty.path "alloc::vec::Vec")
                                                                        [
                                                                          Ty.path "u8";
                                                                          Ty.path
                                                                            "alloc::alloc::Global"
                                                                        ]
                                                                    ],
                                                                  "as_ref",
                                                                  []
                                                                |),
                                                                [ M.read (| op |) ]
                                                              |);
                                                              M.closure
                                                                (fun γ =>
                                                                  ltac:(M.monadic
                                                                    match γ with
                                                                    | [ α0 ] =>
                                                                      M.match_operator (|
                                                                        M.alloc (| α0 |),
                                                                        [
                                                                          fun γ =>
                                                                            ltac:(M.monadic
                                                                              (let v :=
                                                                                M.copy (| γ |) in
                                                                              M.call_closure (|
                                                                                M.get_trait_method (|
                                                                                  "core::convert::AsRef",
                                                                                  Ty.apply
                                                                                    (Ty.path
                                                                                      "alloc::vec::Vec")
                                                                                    [
                                                                                      Ty.path "u8";
                                                                                      Ty.path
                                                                                        "alloc::alloc::Global"
                                                                                    ],
                                                                                  [
                                                                                    Ty.apply
                                                                                      (Ty.path
                                                                                        "slice")
                                                                                      [ Ty.path "u8"
                                                                                      ]
                                                                                  ],
                                                                                  "as_ref",
                                                                                  []
                                                                                |),
                                                                                [ M.read (| v |) ]
                                                                              |)))
                                                                        ]
                                                                      |)
                                                                    | _ => M.impossible (||)
                                                                    end))
                                                            ]
                                                          |)
                                                        ]))
                                                ]
                                              |)
                                            | _ => M.impossible (||)
                                            end))
                                    ]
                                  |)
                                |)
                              |)))
                        ]
                      |)
                    | _ => M.impossible (||)
                    end))
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_resources : M.IsAssociatedFunction Self "resources" resources.
  End Impl_move_core_types_effects_ChangeSet.
  
  Axiom Event :
    (Ty.path "move_core_types::effects::Event") =
      (Ty.tuple
        [
          Ty.apply (Ty.path "alloc::vec::Vec") [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ];
          Ty.path "u64";
          Ty.path "move_core_types::language_storage::TypeTag";
          Ty.apply (Ty.path "alloc::vec::Vec") [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
        ]).
End effects.

Module errmap.
  (* StructRecord
    {
      name := "ErrorDescription";
      ty_params := [];
      fields :=
        [
          ("code_name", Ty.path "alloc::string::String");
          ("code_description", Ty.path "alloc::string::String")
        ];
    } *)
  
  Module Impl_core_fmt_Debug_for_move_core_types_errmap_ErrorDescription.
    Definition Self : Ty.t := Ty.path "move_core_types::errmap::ErrorDescription".
    
    (* Debug *)
    Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.path "core::fmt::Formatter",
              "debug_struct_field2_finish",
              []
            |),
            [
              M.read (| f |);
              M.read (| mk_str "ErrorDescription" |);
              M.read (| mk_str "code_name" |);
              (* Unsize *)
              M.pointer_coercion
                (M.get_struct_record_field
                  (M.read (| self |))
                  "move_core_types::errmap::ErrorDescription"
                  "code_name");
              M.read (| mk_str "code_description" |);
              (* Unsize *)
              M.pointer_coercion
                (M.alloc (|
                  M.get_struct_record_field
                    (M.read (| self |))
                    "move_core_types::errmap::ErrorDescription"
                    "code_description"
                |))
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_move_core_types_errmap_ErrorDescription.
  
  Module Impl_core_clone_Clone_for_move_core_types_errmap_ErrorDescription.
    Definition Self : Ty.t := Ty.path "move_core_types::errmap::ErrorDescription".
    
    (* Clone *)
    Definition clone (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.StructRecord
            "move_core_types::errmap::ErrorDescription"
            [
              ("code_name",
                M.call_closure (|
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.path "alloc::string::String",
                    [],
                    "clone",
                    []
                  |),
                  [
                    M.get_struct_record_field
                      (M.read (| self |))
                      "move_core_types::errmap::ErrorDescription"
                      "code_name"
                  ]
                |));
              ("code_description",
                M.call_closure (|
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.path "alloc::string::String",
                    [],
                    "clone",
                    []
                  |),
                  [
                    M.get_struct_record_field
                      (M.read (| self |))
                      "move_core_types::errmap::ErrorDescription"
                      "code_description"
                  ]
                |))
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_move_core_types_errmap_ErrorDescription.
  
  Module underscore.
    Module Impl_serde_ser_Serialize_for_move_core_types_errmap_ErrorDescription.
      Definition Self : Ty.t := Ty.path "move_core_types::errmap::ErrorDescription".
      
      (* Serialize *)
      Definition serialize (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ __S ], [ self; __serializer ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let __serializer := M.alloc (| __serializer |) in
            M.read (|
              let __serde_state :=
                M.copy (|
                  M.match_operator (|
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "serde::ser::Serializer",
                          __S,
                          [],
                          "serialize_struct",
                          []
                        |),
                        [
                          M.read (| __serializer |);
                          M.read (| mk_str "ErrorDescription" |);
                          BinOp.Panic.add (|
                            BinOp.Panic.add (|
                              M.rust_cast (Value.Bool false),
                              Value.Integer Integer.Usize 1
                            |),
                            Value.Integer Integer.Usize 1
                          |)
                        ]
                      |)
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.get_struct_tuple_field_or_break_match (|
                              γ,
                              "core::result::Result::Ok",
                              0
                            |) in
                          let __val := M.copy (| γ0_0 |) in
                          __val));
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.get_struct_tuple_field_or_break_match (|
                              γ,
                              "core::result::Result::Err",
                              0
                            |) in
                          let __err := M.copy (| γ0_0 |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  Value.StructTuple
                                    "core::result::Result::Err"
                                    [ M.read (| __err |) ]
                                |)
                              |)
                            |)
                          |)))
                    ]
                  |)
                |) in
              let _ :=
                M.match_operator (|
                  M.alloc (|
                    M.call_closure (|
                      M.get_trait_method (|
                        "serde::ser::SerializeStruct",
                        Ty.associated,
                        [],
                        "serialize_field",
                        [ Ty.path "alloc::string::String" ]
                      |),
                      [
                        __serde_state;
                        M.read (| mk_str "code_name" |);
                        M.get_struct_record_field
                          (M.read (| self |))
                          "move_core_types::errmap::ErrorDescription"
                          "code_name"
                      ]
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.get_struct_tuple_field_or_break_match (|
                            γ,
                            "core::result::Result::Ok",
                            0
                          |) in
                        let __val := M.copy (| γ0_0 |) in
                        __val));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.get_struct_tuple_field_or_break_match (|
                            γ,
                            "core::result::Result::Err",
                            0
                          |) in
                        let __err := M.copy (| γ0_0 |) in
                        M.alloc (|
                          M.never_to_any (|
                            M.read (|
                              M.return_ (|
                                Value.StructTuple "core::result::Result::Err" [ M.read (| __err |) ]
                              |)
                            |)
                          |)
                        |)))
                  ]
                |) in
              let _ :=
                M.match_operator (|
                  M.alloc (|
                    M.call_closure (|
                      M.get_trait_method (|
                        "serde::ser::SerializeStruct",
                        Ty.associated,
                        [],
                        "serialize_field",
                        [ Ty.path "alloc::string::String" ]
                      |),
                      [
                        __serde_state;
                        M.read (| mk_str "code_description" |);
                        M.get_struct_record_field
                          (M.read (| self |))
                          "move_core_types::errmap::ErrorDescription"
                          "code_description"
                      ]
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.get_struct_tuple_field_or_break_match (|
                            γ,
                            "core::result::Result::Ok",
                            0
                          |) in
                        let __val := M.copy (| γ0_0 |) in
                        __val));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.get_struct_tuple_field_or_break_match (|
                            γ,
                            "core::result::Result::Err",
                            0
                          |) in
                        let __err := M.copy (| γ0_0 |) in
                        M.alloc (|
                          M.never_to_any (|
                            M.read (|
                              M.return_ (|
                                Value.StructTuple "core::result::Result::Err" [ M.read (| __err |) ]
                              |)
                            |)
                          |)
                        |)))
                  ]
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "serde::ser::SerializeStruct",
                    Ty.associated,
                    [],
                    "end",
                    []
                  |),
                  [ M.read (| __serde_state |) ]
                |)
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "serde::ser::Serialize"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("serialize", InstanceField.Method serialize) ].
    End Impl_serde_ser_Serialize_for_move_core_types_errmap_ErrorDescription.
  End underscore.
  
  Module Wrap_underscore_2.
  Module underscore.
    Module Impl_serde_de_Deserialize_for_move_core_types_errmap_ErrorDescription.
      Definition Self : Ty.t := Ty.path "move_core_types::errmap::ErrorDescription".
      
      (* Deserialize *)
      Definition deserialize (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ __D ], [ __deserializer ] =>
          ltac:(M.monadic
            (let __deserializer := M.alloc (| __deserializer |) in
            M.call_closure (|
              M.get_trait_method (|
                "serde::de::Deserializer",
                __D,
                [],
                "deserialize_struct",
                [ Ty.path "move_core_types::errmap::_'1::deserialize::__Visitor" ]
              |),
              [
                M.read (| __deserializer |);
                M.read (| mk_str "ErrorDescription" |);
                M.read (|
                  M.get_constant (| "move_core_types::errmap::_'1::deserialize::FIELDS" |)
                |);
                Value.StructRecord
                  "move_core_types::errmap::_'1::deserialize::__Visitor"
                  [
                    ("marker", Value.StructTuple "core::marker::PhantomData" []);
                    ("lifetime", Value.StructTuple "core::marker::PhantomData" [])
                  ]
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "serde::de::Deserialize"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("deserialize", InstanceField.Method deserialize) ].
    End Impl_serde_de_Deserialize_for_move_core_types_errmap_ErrorDescription.
  End underscore.
  End Wrap_underscore_2.
  Import Wrap_underscore_2.
  
  (* StructRecord
    {
      name := "ErrorMapping";
      ty_params := [];
      fields :=
        [
          ("error_categories",
            Ty.apply
              (Ty.path "alloc::collections::btree::map::BTreeMap")
              [
                Ty.path "u64";
                Ty.path "move_core_types::errmap::ErrorDescription";
                Ty.path "alloc::alloc::Global"
              ]);
          ("module_error_maps",
            Ty.apply
              (Ty.path "alloc::collections::btree::map::BTreeMap")
              [
                Ty.path "move_core_types::language_storage::ModuleId";
                Ty.apply
                  (Ty.path "alloc::collections::btree::map::BTreeMap")
                  [
                    Ty.path "u64";
                    Ty.path "move_core_types::errmap::ErrorDescription";
                    Ty.path "alloc::alloc::Global"
                  ];
                Ty.path "alloc::alloc::Global"
              ])
        ];
    } *)
  
  Module Impl_core_fmt_Debug_for_move_core_types_errmap_ErrorMapping.
    Definition Self : Ty.t := Ty.path "move_core_types::errmap::ErrorMapping".
    
    (* Debug *)
    Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.path "core::fmt::Formatter",
              "debug_struct_field2_finish",
              []
            |),
            [
              M.read (| f |);
              M.read (| mk_str "ErrorMapping" |);
              M.read (| mk_str "error_categories" |);
              (* Unsize *)
              M.pointer_coercion
                (M.get_struct_record_field
                  (M.read (| self |))
                  "move_core_types::errmap::ErrorMapping"
                  "error_categories");
              M.read (| mk_str "module_error_maps" |);
              (* Unsize *)
              M.pointer_coercion
                (M.alloc (|
                  M.get_struct_record_field
                    (M.read (| self |))
                    "move_core_types::errmap::ErrorMapping"
                    "module_error_maps"
                |))
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_move_core_types_errmap_ErrorMapping.
  
  Module Impl_core_clone_Clone_for_move_core_types_errmap_ErrorMapping.
    Definition Self : Ty.t := Ty.path "move_core_types::errmap::ErrorMapping".
    
    (* Clone *)
    Definition clone (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.StructRecord
            "move_core_types::errmap::ErrorMapping"
            [
              ("error_categories",
                M.call_closure (|
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.apply
                      (Ty.path "alloc::collections::btree::map::BTreeMap")
                      [
                        Ty.path "u64";
                        Ty.path "move_core_types::errmap::ErrorDescription";
                        Ty.path "alloc::alloc::Global"
                      ],
                    [],
                    "clone",
                    []
                  |),
                  [
                    M.get_struct_record_field
                      (M.read (| self |))
                      "move_core_types::errmap::ErrorMapping"
                      "error_categories"
                  ]
                |));
              ("module_error_maps",
                M.call_closure (|
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.apply
                      (Ty.path "alloc::collections::btree::map::BTreeMap")
                      [
                        Ty.path "move_core_types::language_storage::ModuleId";
                        Ty.apply
                          (Ty.path "alloc::collections::btree::map::BTreeMap")
                          [
                            Ty.path "u64";
                            Ty.path "move_core_types::errmap::ErrorDescription";
                            Ty.path "alloc::alloc::Global"
                          ];
                        Ty.path "alloc::alloc::Global"
                      ],
                    [],
                    "clone",
                    []
                  |),
                  [
                    M.get_struct_record_field
                      (M.read (| self |))
                      "move_core_types::errmap::ErrorMapping"
                      "module_error_maps"
                  ]
                |))
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_move_core_types_errmap_ErrorMapping.
  
  Module Wrap_underscore_3.
  Module underscore.
    Module Impl_serde_ser_Serialize_for_move_core_types_errmap_ErrorMapping.
      Definition Self : Ty.t := Ty.path "move_core_types::errmap::ErrorMapping".
      
      (* Serialize *)
      Definition serialize (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ __S ], [ self; __serializer ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let __serializer := M.alloc (| __serializer |) in
            M.read (|
              let __serde_state :=
                M.copy (|
                  M.match_operator (|
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "serde::ser::Serializer",
                          __S,
                          [],
                          "serialize_struct",
                          []
                        |),
                        [
                          M.read (| __serializer |);
                          M.read (| mk_str "ErrorMapping" |);
                          BinOp.Panic.add (|
                            BinOp.Panic.add (|
                              M.rust_cast (Value.Bool false),
                              Value.Integer Integer.Usize 1
                            |),
                            Value.Integer Integer.Usize 1
                          |)
                        ]
                      |)
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.get_struct_tuple_field_or_break_match (|
                              γ,
                              "core::result::Result::Ok",
                              0
                            |) in
                          let __val := M.copy (| γ0_0 |) in
                          __val));
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.get_struct_tuple_field_or_break_match (|
                              γ,
                              "core::result::Result::Err",
                              0
                            |) in
                          let __err := M.copy (| γ0_0 |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  Value.StructTuple
                                    "core::result::Result::Err"
                                    [ M.read (| __err |) ]
                                |)
                              |)
                            |)
                          |)))
                    ]
                  |)
                |) in
              let _ :=
                M.match_operator (|
                  M.alloc (|
                    M.call_closure (|
                      M.get_trait_method (|
                        "serde::ser::SerializeStruct",
                        Ty.associated,
                        [],
                        "serialize_field",
                        [
                          Ty.apply
                            (Ty.path "alloc::collections::btree::map::BTreeMap")
                            [
                              Ty.path "u64";
                              Ty.path "move_core_types::errmap::ErrorDescription";
                              Ty.path "alloc::alloc::Global"
                            ]
                        ]
                      |),
                      [
                        __serde_state;
                        M.read (| mk_str "error_categories" |);
                        M.get_struct_record_field
                          (M.read (| self |))
                          "move_core_types::errmap::ErrorMapping"
                          "error_categories"
                      ]
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.get_struct_tuple_field_or_break_match (|
                            γ,
                            "core::result::Result::Ok",
                            0
                          |) in
                        let __val := M.copy (| γ0_0 |) in
                        __val));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.get_struct_tuple_field_or_break_match (|
                            γ,
                            "core::result::Result::Err",
                            0
                          |) in
                        let __err := M.copy (| γ0_0 |) in
                        M.alloc (|
                          M.never_to_any (|
                            M.read (|
                              M.return_ (|
                                Value.StructTuple "core::result::Result::Err" [ M.read (| __err |) ]
                              |)
                            |)
                          |)
                        |)))
                  ]
                |) in
              let _ :=
                M.match_operator (|
                  M.alloc (|
                    M.call_closure (|
                      M.get_trait_method (|
                        "serde::ser::SerializeStruct",
                        Ty.associated,
                        [],
                        "serialize_field",
                        [
                          Ty.apply
                            (Ty.path "alloc::collections::btree::map::BTreeMap")
                            [
                              Ty.path "move_core_types::language_storage::ModuleId";
                              Ty.apply
                                (Ty.path "alloc::collections::btree::map::BTreeMap")
                                [
                                  Ty.path "u64";
                                  Ty.path "move_core_types::errmap::ErrorDescription";
                                  Ty.path "alloc::alloc::Global"
                                ];
                              Ty.path "alloc::alloc::Global"
                            ]
                        ]
                      |),
                      [
                        __serde_state;
                        M.read (| mk_str "module_error_maps" |);
                        M.get_struct_record_field
                          (M.read (| self |))
                          "move_core_types::errmap::ErrorMapping"
                          "module_error_maps"
                      ]
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.get_struct_tuple_field_or_break_match (|
                            γ,
                            "core::result::Result::Ok",
                            0
                          |) in
                        let __val := M.copy (| γ0_0 |) in
                        __val));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.get_struct_tuple_field_or_break_match (|
                            γ,
                            "core::result::Result::Err",
                            0
                          |) in
                        let __err := M.copy (| γ0_0 |) in
                        M.alloc (|
                          M.never_to_any (|
                            M.read (|
                              M.return_ (|
                                Value.StructTuple "core::result::Result::Err" [ M.read (| __err |) ]
                              |)
                            |)
                          |)
                        |)))
                  ]
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "serde::ser::SerializeStruct",
                    Ty.associated,
                    [],
                    "end",
                    []
                  |),
                  [ M.read (| __serde_state |) ]
                |)
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "serde::ser::Serialize"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("serialize", InstanceField.Method serialize) ].
    End Impl_serde_ser_Serialize_for_move_core_types_errmap_ErrorMapping.
  End underscore.
  End Wrap_underscore_3.
  Import Wrap_underscore_3.
  
  Module Wrap_underscore_4.
  Module underscore.
    Module Impl_serde_de_Deserialize_for_move_core_types_errmap_ErrorMapping.
      Definition Self : Ty.t := Ty.path "move_core_types::errmap::ErrorMapping".
      
      (* Deserialize *)
      Definition deserialize (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ __D ], [ __deserializer ] =>
          ltac:(M.monadic
            (let __deserializer := M.alloc (| __deserializer |) in
            M.call_closure (|
              M.get_trait_method (|
                "serde::de::Deserializer",
                __D,
                [],
                "deserialize_struct",
                [ Ty.path "move_core_types::errmap::_'3::deserialize::__Visitor" ]
              |),
              [
                M.read (| __deserializer |);
                M.read (| mk_str "ErrorMapping" |);
                M.read (|
                  M.get_constant (| "move_core_types::errmap::_'3::deserialize::FIELDS" |)
                |);
                Value.StructRecord
                  "move_core_types::errmap::_'3::deserialize::__Visitor"
                  [
                    ("marker", Value.StructTuple "core::marker::PhantomData" []);
                    ("lifetime", Value.StructTuple "core::marker::PhantomData" [])
                  ]
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "serde::de::Deserialize"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("deserialize", InstanceField.Method deserialize) ].
    End Impl_serde_de_Deserialize_for_move_core_types_errmap_ErrorMapping.
  End underscore.
  End Wrap_underscore_4.
  Import Wrap_underscore_4.
  
  Module Impl_core_default_Default_for_move_core_types_errmap_ErrorMapping.
    Definition Self : Ty.t := Ty.path "move_core_types::errmap::ErrorMapping".
    
    (* Default *)
    Definition default (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [] =>
        ltac:(M.monadic
          (Value.StructRecord
            "move_core_types::errmap::ErrorMapping"
            [
              ("error_categories",
                M.call_closure (|
                  M.get_trait_method (|
                    "core::default::Default",
                    Ty.apply
                      (Ty.path "alloc::collections::btree::map::BTreeMap")
                      [
                        Ty.path "u64";
                        Ty.path "move_core_types::errmap::ErrorDescription";
                        Ty.path "alloc::alloc::Global"
                      ],
                    [],
                    "default",
                    []
                  |),
                  []
                |));
              ("module_error_maps",
                M.call_closure (|
                  M.get_trait_method (|
                    "core::default::Default",
                    Ty.apply
                      (Ty.path "alloc::collections::btree::map::BTreeMap")
                      [
                        Ty.path "move_core_types::language_storage::ModuleId";
                        Ty.apply
                          (Ty.path "alloc::collections::btree::map::BTreeMap")
                          [
                            Ty.path "u64";
                            Ty.path "move_core_types::errmap::ErrorDescription";
                            Ty.path "alloc::alloc::Global"
                          ];
                        Ty.path "alloc::alloc::Global"
                      ],
                    [],
                    "default",
                    []
                  |),
                  []
                |))
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::default::Default"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("default", InstanceField.Method default) ].
  End Impl_core_default_Default_for_move_core_types_errmap_ErrorMapping.
  
  Module Impl_move_core_types_errmap_ErrorMapping.
    Definition Self : Ty.t := Ty.path "move_core_types::errmap::ErrorMapping".
    
    (*
        pub fn add_error_category(
            &mut self,
            category_id: u64,
            description: ErrorDescription,
        ) -> Result<()> {
            if let Some(previous_entry) = self.error_categories.insert(category_id, description) {
                bail!(format!(
                    "Entry for category {} already taken by: {:#?}",
                    category_id, previous_entry
                ))
            }
            Ok(())
        }
    *)
    Definition add_error_category (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; category_id; description ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let category_id := M.alloc (| category_id |) in
          let description := M.alloc (| description |) in
          M.read (|
            let _ :=
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "alloc::collections::btree::map::BTreeMap")
                                [
                                  Ty.path "u64";
                                  Ty.path "move_core_types::errmap::ErrorDescription";
                                  Ty.path "alloc::alloc::Global"
                                ],
                              "insert",
                              []
                            |),
                            [
                              M.get_struct_record_field
                                (M.read (| self |))
                                "move_core_types::errmap::ErrorMapping"
                                "error_categories";
                              M.read (| category_id |);
                              M.read (| description |)
                            ]
                          |)
                        |) in
                      let γ0_0 :=
                        M.get_struct_tuple_field_or_break_match (|
                          γ,
                          "core::option::Option::Some",
                          0
                        |) in
                      let previous_entry := M.copy (| γ0_0 |) in
                      M.alloc (|
                        M.never_to_any (|
                          M.read (|
                            M.return_ (|
                              Value.StructTuple
                                "core::result::Result::Err"
                                [
                                  M.read (|
                                    let error :=
                                      M.copy (|
                                        M.match_operator (|
                                          let res :=
                                            M.alloc (|
                                              M.call_closure (|
                                                M.get_function (| "alloc::fmt::format", [] |),
                                                [
                                                  M.call_closure (|
                                                    M.get_associated_function (|
                                                      Ty.path "core::fmt::Arguments",
                                                      "new_v1_formatted",
                                                      []
                                                    |),
                                                    [
                                                      (* Unsize *)
                                                      M.pointer_coercion
                                                        (M.alloc (|
                                                          Value.Array
                                                            [
                                                              M.read (|
                                                                mk_str "Entry for category "
                                                              |);
                                                              M.read (|
                                                                mk_str " already taken by: "
                                                              |)
                                                            ]
                                                        |));
                                                      (* Unsize *)
                                                      M.pointer_coercion
                                                        (M.alloc (|
                                                          Value.Array
                                                            [
                                                              M.call_closure (|
                                                                M.get_associated_function (|
                                                                  Ty.path "core::fmt::rt::Argument",
                                                                  "new_display",
                                                                  [ Ty.path "u64" ]
                                                                |),
                                                                [ category_id ]
                                                              |);
                                                              M.call_closure (|
                                                                M.get_associated_function (|
                                                                  Ty.path "core::fmt::rt::Argument",
                                                                  "new_debug",
                                                                  [
                                                                    Ty.path
                                                                      "move_core_types::errmap::ErrorDescription"
                                                                  ]
                                                                |),
                                                                [ previous_entry ]
                                                              |)
                                                            ]
                                                        |));
                                                      (* Unsize *)
                                                      M.pointer_coercion
                                                        (M.alloc (|
                                                          Value.Array
                                                            [
                                                              M.call_closure (|
                                                                M.get_associated_function (|
                                                                  Ty.path
                                                                    "core::fmt::rt::Placeholder",
                                                                  "new",
                                                                  []
                                                                |),
                                                                [
                                                                  Value.Integer Integer.Usize 0;
                                                                  Value.UnicodeChar 32;
                                                                  Value.StructTuple
                                                                    "core::fmt::rt::Alignment::Unknown"
                                                                    [];
                                                                  Value.Integer Integer.U32 0;
                                                                  Value.StructTuple
                                                                    "core::fmt::rt::Count::Implied"
                                                                    [];
                                                                  Value.StructTuple
                                                                    "core::fmt::rt::Count::Implied"
                                                                    []
                                                                ]
                                                              |);
                                                              M.call_closure (|
                                                                M.get_associated_function (|
                                                                  Ty.path
                                                                    "core::fmt::rt::Placeholder",
                                                                  "new",
                                                                  []
                                                                |),
                                                                [
                                                                  Value.Integer Integer.Usize 1;
                                                                  Value.UnicodeChar 32;
                                                                  Value.StructTuple
                                                                    "core::fmt::rt::Alignment::Unknown"
                                                                    [];
                                                                  Value.Integer Integer.U32 4;
                                                                  Value.StructTuple
                                                                    "core::fmt::rt::Count::Implied"
                                                                    [];
                                                                  Value.StructTuple
                                                                    "core::fmt::rt::Count::Implied"
                                                                    []
                                                                ]
                                                              |)
                                                            ]
                                                        |));
                                                      M.call_closure (|
                                                        M.get_associated_function (|
                                                          Ty.path "core::fmt::rt::UnsafeArg",
                                                          "new",
                                                          []
                                                        |),
                                                        []
                                                      |)
                                                    ]
                                                  |)
                                                ]
                                              |)
                                            |) in
                                          res,
                                          [
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let error := M.copy (| γ |) in
                                                M.alloc (|
                                                  M.call_closure (|
                                                    M.get_associated_function (|
                                                      Ty.path "anyhow::kind::Adhoc",
                                                      "new",
                                                      [ Ty.path "alloc::string::String" ]
                                                    |),
                                                    [
                                                      M.call_closure (|
                                                        M.get_trait_method (|
                                                          "anyhow::kind::AdhocKind",
                                                          Ty.apply
                                                            (Ty.path "&")
                                                            [ Ty.path "alloc::string::String" ],
                                                          [],
                                                          "anyhow_kind",
                                                          []
                                                        |),
                                                        [ M.alloc (| error |) ]
                                                      |);
                                                      M.read (| error |)
                                                    ]
                                                  |)
                                                |)))
                                          ]
                                        |)
                                      |) in
                                    error
                                  |)
                                ]
                            |)
                          |)
                        |)
                      |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            M.alloc (| Value.StructTuple "core::result::Result::Ok" [ Value.Tuple [] ] |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_add_error_category :
      M.IsAssociatedFunction Self "add_error_category" add_error_category.
    
    (*
        pub fn add_module_error(
            &mut self,
            module_id: ModuleId,
            abort_code: u64,
            description: ErrorDescription,
        ) -> Result<()> {
            let module_error_map = self.module_error_maps.entry(module_id.clone()).or_default();
            if let Some(previous_entry) = module_error_map.insert(abort_code, description) {
                bail!(format!(
                    "Duplicate entry for abort code {} found in {}, previous entry: {:#?}",
                    abort_code, module_id, previous_entry
                ))
            }
            Ok(())
        }
    *)
    Definition add_module_error (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; module_id; abort_code; description ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let module_id := M.alloc (| module_id |) in
          let abort_code := M.alloc (| abort_code |) in
          let description := M.alloc (| description |) in
          M.read (|
            let module_error_map :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloc::collections::btree::map::entry::Entry")
                      [
                        Ty.path "move_core_types::language_storage::ModuleId";
                        Ty.apply
                          (Ty.path "alloc::collections::btree::map::BTreeMap")
                          [
                            Ty.path "u64";
                            Ty.path "move_core_types::errmap::ErrorDescription";
                            Ty.path "alloc::alloc::Global"
                          ];
                        Ty.path "alloc::alloc::Global"
                      ],
                    "or_default",
                    []
                  |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::collections::btree::map::BTreeMap")
                          [
                            Ty.path "move_core_types::language_storage::ModuleId";
                            Ty.apply
                              (Ty.path "alloc::collections::btree::map::BTreeMap")
                              [
                                Ty.path "u64";
                                Ty.path "move_core_types::errmap::ErrorDescription";
                                Ty.path "alloc::alloc::Global"
                              ];
                            Ty.path "alloc::alloc::Global"
                          ],
                        "entry",
                        []
                      |),
                      [
                        M.get_struct_record_field
                          (M.read (| self |))
                          "move_core_types::errmap::ErrorMapping"
                          "module_error_maps";
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::clone::Clone",
                            Ty.path "move_core_types::language_storage::ModuleId",
                            [],
                            "clone",
                            []
                          |),
                          [ module_id ]
                        |)
                      ]
                    |)
                  ]
                |)
              |) in
            let _ :=
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "alloc::collections::btree::map::BTreeMap")
                                [
                                  Ty.path "u64";
                                  Ty.path "move_core_types::errmap::ErrorDescription";
                                  Ty.path "alloc::alloc::Global"
                                ],
                              "insert",
                              []
                            |),
                            [
                              M.read (| module_error_map |);
                              M.read (| abort_code |);
                              M.read (| description |)
                            ]
                          |)
                        |) in
                      let γ0_0 :=
                        M.get_struct_tuple_field_or_break_match (|
                          γ,
                          "core::option::Option::Some",
                          0
                        |) in
                      let previous_entry := M.copy (| γ0_0 |) in
                      M.alloc (|
                        M.never_to_any (|
                          M.read (|
                            M.return_ (|
                              Value.StructTuple
                                "core::result::Result::Err"
                                [
                                  M.read (|
                                    let error :=
                                      M.copy (|
                                        M.match_operator (|
                                          let res :=
                                            M.alloc (|
                                              M.call_closure (|
                                                M.get_function (| "alloc::fmt::format", [] |),
                                                [
                                                  M.call_closure (|
                                                    M.get_associated_function (|
                                                      Ty.path "core::fmt::Arguments",
                                                      "new_v1_formatted",
                                                      []
                                                    |),
                                                    [
                                                      (* Unsize *)
                                                      M.pointer_coercion
                                                        (M.alloc (|
                                                          Value.Array
                                                            [
                                                              M.read (|
                                                                mk_str
                                                                  "Duplicate entry for abort code "
                                                              |);
                                                              M.read (| mk_str " found in " |);
                                                              M.read (|
                                                                mk_str ", previous entry: "
                                                              |)
                                                            ]
                                                        |));
                                                      (* Unsize *)
                                                      M.pointer_coercion
                                                        (M.alloc (|
                                                          Value.Array
                                                            [
                                                              M.call_closure (|
                                                                M.get_associated_function (|
                                                                  Ty.path "core::fmt::rt::Argument",
                                                                  "new_display",
                                                                  [ Ty.path "u64" ]
                                                                |),
                                                                [ abort_code ]
                                                              |);
                                                              M.call_closure (|
                                                                M.get_associated_function (|
                                                                  Ty.path "core::fmt::rt::Argument",
                                                                  "new_display",
                                                                  [
                                                                    Ty.path
                                                                      "move_core_types::language_storage::ModuleId"
                                                                  ]
                                                                |),
                                                                [ module_id ]
                                                              |);
                                                              M.call_closure (|
                                                                M.get_associated_function (|
                                                                  Ty.path "core::fmt::rt::Argument",
                                                                  "new_debug",
                                                                  [
                                                                    Ty.path
                                                                      "move_core_types::errmap::ErrorDescription"
                                                                  ]
                                                                |),
                                                                [ previous_entry ]
                                                              |)
                                                            ]
                                                        |));
                                                      (* Unsize *)
                                                      M.pointer_coercion
                                                        (M.alloc (|
                                                          Value.Array
                                                            [
                                                              M.call_closure (|
                                                                M.get_associated_function (|
                                                                  Ty.path
                                                                    "core::fmt::rt::Placeholder",
                                                                  "new",
                                                                  []
                                                                |),
                                                                [
                                                                  Value.Integer Integer.Usize 0;
                                                                  Value.UnicodeChar 32;
                                                                  Value.StructTuple
                                                                    "core::fmt::rt::Alignment::Unknown"
                                                                    [];
                                                                  Value.Integer Integer.U32 0;
                                                                  Value.StructTuple
                                                                    "core::fmt::rt::Count::Implied"
                                                                    [];
                                                                  Value.StructTuple
                                                                    "core::fmt::rt::Count::Implied"
                                                                    []
                                                                ]
                                                              |);
                                                              M.call_closure (|
                                                                M.get_associated_function (|
                                                                  Ty.path
                                                                    "core::fmt::rt::Placeholder",
                                                                  "new",
                                                                  []
                                                                |),
                                                                [
                                                                  Value.Integer Integer.Usize 1;
                                                                  Value.UnicodeChar 32;
                                                                  Value.StructTuple
                                                                    "core::fmt::rt::Alignment::Unknown"
                                                                    [];
                                                                  Value.Integer Integer.U32 0;
                                                                  Value.StructTuple
                                                                    "core::fmt::rt::Count::Implied"
                                                                    [];
                                                                  Value.StructTuple
                                                                    "core::fmt::rt::Count::Implied"
                                                                    []
                                                                ]
                                                              |);
                                                              M.call_closure (|
                                                                M.get_associated_function (|
                                                                  Ty.path
                                                                    "core::fmt::rt::Placeholder",
                                                                  "new",
                                                                  []
                                                                |),
                                                                [
                                                                  Value.Integer Integer.Usize 2;
                                                                  Value.UnicodeChar 32;
                                                                  Value.StructTuple
                                                                    "core::fmt::rt::Alignment::Unknown"
                                                                    [];
                                                                  Value.Integer Integer.U32 4;
                                                                  Value.StructTuple
                                                                    "core::fmt::rt::Count::Implied"
                                                                    [];
                                                                  Value.StructTuple
                                                                    "core::fmt::rt::Count::Implied"
                                                                    []
                                                                ]
                                                              |)
                                                            ]
                                                        |));
                                                      M.call_closure (|
                                                        M.get_associated_function (|
                                                          Ty.path "core::fmt::rt::UnsafeArg",
                                                          "new",
                                                          []
                                                        |),
                                                        []
                                                      |)
                                                    ]
                                                  |)
                                                ]
                                              |)
                                            |) in
                                          res,
                                          [
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let error := M.copy (| γ |) in
                                                M.alloc (|
                                                  M.call_closure (|
                                                    M.get_associated_function (|
                                                      Ty.path "anyhow::kind::Adhoc",
                                                      "new",
                                                      [ Ty.path "alloc::string::String" ]
                                                    |),
                                                    [
                                                      M.call_closure (|
                                                        M.get_trait_method (|
                                                          "anyhow::kind::AdhocKind",
                                                          Ty.apply
                                                            (Ty.path "&")
                                                            [ Ty.path "alloc::string::String" ],
                                                          [],
                                                          "anyhow_kind",
                                                          []
                                                        |),
                                                        [ M.alloc (| error |) ]
                                                      |);
                                                      M.read (| error |)
                                                    ]
                                                  |)
                                                |)))
                                          ]
                                        |)
                                      |) in
                                    error
                                  |)
                                ]
                            |)
                          |)
                        |)
                      |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            M.alloc (| Value.StructTuple "core::result::Result::Ok" [ Value.Tuple [] ] |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_add_module_error :
      M.IsAssociatedFunction Self "add_module_error" add_module_error.
    
    (*
        pub fn from_file<P: AsRef<Path>>(path: P) -> Self {
            let mut bytes = Vec::new();
            File::open(path).unwrap().read_to_end(&mut bytes).unwrap();
            bcs::from_bytes(&bytes).unwrap()
        }
    *)
    Definition from_file (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ P ], [ path ] =>
        ltac:(M.monadic
          (let path := M.alloc (| path |) in
          M.read (|
            let bytes :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                    "new",
                    []
                  |),
                  []
                |)
              |) in
            let _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::result::Result")
                      [ Ty.path "usize"; Ty.path "std::io::error::Error" ],
                    "unwrap",
                    []
                  |),
                  [
                    M.call_closure (|
                      M.get_trait_method (|
                        "std::io::Read",
                        Ty.path "std::fs::File",
                        [],
                        "read_to_end",
                        []
                      |),
                      [
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "core::result::Result")
                                [ Ty.path "std::fs::File"; Ty.path "std::io::error::Error" ],
                              "unwrap",
                              []
                            |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "std::fs::File",
                                  "open",
                                  [ P ]
                                |),
                                [ M.read (| path |) ]
                              |)
                            ]
                          |)
                        |);
                        bytes
                      ]
                    |)
                  ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    [ Ty.path "move_core_types::errmap::ErrorMapping"; Ty.path "bcs::error::Error"
                    ],
                  "unwrap",
                  []
                |),
                [
                  M.call_closure (|
                    M.get_function (|
                      "bcs::de::from_bytes",
                      [ Ty.path "move_core_types::errmap::ErrorMapping" ]
                    |),
                    [
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::ops::deref::Deref",
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                          [],
                          "deref",
                          []
                        |),
                        [ bytes ]
                      |)
                    ]
                  |)
                ]
              |)
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_from_file : M.IsAssociatedFunction Self "from_file" from_file.
    
    (*
        pub fn to_file<P: AsRef<Path>>(&self, path: P) {
            let bytes = bcs::to_bytes(self).unwrap();
            let mut file = File::create(path).unwrap();
            file.write_all(&bytes).unwrap();
        }
    *)
    Definition to_file (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ P ], [ self; path ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let path := M.alloc (| path |) in
          M.read (|
            let bytes :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::result::Result")
                      [
                        Ty.apply
                          (Ty.path "alloc::vec::Vec")
                          [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ];
                        Ty.path "bcs::error::Error"
                      ],
                    "unwrap",
                    []
                  |),
                  [
                    M.call_closure (|
                      M.get_function (|
                        "bcs::ser::to_bytes",
                        [ Ty.path "move_core_types::errmap::ErrorMapping" ]
                      |),
                      [ M.read (| self |) ]
                    |)
                  ]
                |)
              |) in
            let file :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::result::Result")
                      [ Ty.path "std::fs::File"; Ty.path "std::io::error::Error" ],
                    "unwrap",
                    []
                  |),
                  [
                    M.call_closure (|
                      M.get_associated_function (| Ty.path "std::fs::File", "create", [ P ] |),
                      [ M.read (| path |) ]
                    |)
                  ]
                |)
              |) in
            let _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::result::Result")
                      [ Ty.tuple []; Ty.path "std::io::error::Error" ],
                    "unwrap",
                    []
                  |),
                  [
                    M.call_closure (|
                      M.get_trait_method (|
                        "std::io::Write",
                        Ty.path "std::fs::File",
                        [],
                        "write_all",
                        []
                      |),
                      [
                        file;
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::ops::deref::Deref",
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                            [],
                            "deref",
                            []
                          |),
                          [ bytes ]
                        |)
                      ]
                    |)
                  ]
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_to_file : M.IsAssociatedFunction Self "to_file" to_file.
    
    (*
        pub fn get_explanation(&self, module: &ModuleId, output_code: u64) -> Option<ErrorDescription> {
            self.module_error_maps
                .get(module)
                .and_then(|module_map| module_map.get(&output_code).cloned())
        }
    *)
    Definition get_explanation (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; module; output_code ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let module := M.alloc (| module |) in
          let output_code := M.alloc (| output_code |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply
                (Ty.path "core::option::Option")
                [
                  Ty.apply
                    (Ty.path "&")
                    [
                      Ty.apply
                        (Ty.path "alloc::collections::btree::map::BTreeMap")
                        [
                          Ty.path "u64";
                          Ty.path "move_core_types::errmap::ErrorDescription";
                          Ty.path "alloc::alloc::Global"
                        ]
                    ]
                ],
              "and_then",
              [
                Ty.path "move_core_types::errmap::ErrorDescription";
                Ty.function
                  [
                    Ty.tuple
                      [
                        Ty.apply
                          (Ty.path "&")
                          [
                            Ty.apply
                              (Ty.path "alloc::collections::btree::map::BTreeMap")
                              [
                                Ty.path "u64";
                                Ty.path "move_core_types::errmap::ErrorDescription";
                                Ty.path "alloc::alloc::Global"
                              ]
                          ]
                      ]
                  ]
                  (Ty.apply
                    (Ty.path "core::option::Option")
                    [ Ty.path "move_core_types::errmap::ErrorDescription" ])
              ]
            |),
            [
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::collections::btree::map::BTreeMap")
                    [
                      Ty.path "move_core_types::language_storage::ModuleId";
                      Ty.apply
                        (Ty.path "alloc::collections::btree::map::BTreeMap")
                        [
                          Ty.path "u64";
                          Ty.path "move_core_types::errmap::ErrorDescription";
                          Ty.path "alloc::alloc::Global"
                        ];
                      Ty.path "alloc::alloc::Global"
                    ],
                  "get",
                  [ Ty.path "move_core_types::language_storage::ModuleId" ]
                |),
                [
                  M.get_struct_record_field
                    (M.read (| self |))
                    "move_core_types::errmap::ErrorMapping"
                    "module_error_maps";
                  M.read (| module |)
                ]
              |);
              M.closure
                (fun γ =>
                  ltac:(M.monadic
                    match γ with
                    | [ α0 ] =>
                      M.match_operator (|
                        M.alloc (| α0 |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let module_map := M.copy (| γ |) in
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::option::Option")
                                    [
                                      Ty.apply
                                        (Ty.path "&")
                                        [ Ty.path "move_core_types::errmap::ErrorDescription" ]
                                    ],
                                  "cloned",
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "alloc::collections::btree::map::BTreeMap")
                                        [
                                          Ty.path "u64";
                                          Ty.path "move_core_types::errmap::ErrorDescription";
                                          Ty.path "alloc::alloc::Global"
                                        ],
                                      "get",
                                      [ Ty.path "u64" ]
                                    |),
                                    [ M.read (| module_map |); output_code ]
                                  |)
                                ]
                              |)))
                        ]
                      |)
                    | _ => M.impossible (||)
                    end))
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_get_explanation :
      M.IsAssociatedFunction Self "get_explanation" get_explanation.
  End Impl_move_core_types_errmap_ErrorMapping.
End errmap.

Module gas_algebra.
  (*
  Enum InternalGasUnit
  {
    ty_params := [];
    variants := [];
  }
  *)
  
  (*
  Enum Byte
  {
    ty_params := [];
    variants := [];
  }
  *)
  
  (*
  Enum KibiByte
  {
    ty_params := [];
    variants := [];
  }
  *)
  
  (*
  Enum MebiByte
  {
    ty_params := [];
    variants := [];
  }
  *)
  
  (*
  Enum GibiByte
  {
    ty_params := [];
    variants := [];
  }
  *)
  
  (*
  Enum AbstractMemoryUnit
  {
    ty_params := [];
    variants := [];
  }
  *)
  
  (*
  Enum Arg
  {
    ty_params := [];
    variants := [];
  }
  *)
  
  (* StructRecord
    {
      name := "UnitDiv";
      ty_params := [ "U1"; "U2" ];
      fields :=
        [ ("phantom", Ty.apply (Ty.path "core::marker::PhantomData") [ Ty.tuple [ U1; U2 ] ]) ];
    } *)
  
  (* StructRecord
    {
      name := "GasQuantity";
      ty_params := [ "U" ];
      fields :=
        [ ("val", Ty.path "u64"); ("phantom", Ty.apply (Ty.path "core::marker::PhantomData") [ U ])
        ];
    } *)
  
  Module underscore.
    Module Impl_serde_ser_Serialize_for_move_core_types_gas_algebra_GasQuantity_U.
      Definition Self (U : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "move_core_types::gas_algebra::GasQuantity") [ U ].
      
      (* Serialize *)
      Definition serialize (U : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self U in
        match τ, α with
        | [ __S ], [ self; __serializer ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let __serializer := M.alloc (| __serializer |) in
            M.read (|
              let __serde_state :=
                M.copy (|
                  M.match_operator (|
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "serde::ser::Serializer",
                          __S,
                          [],
                          "serialize_struct",
                          []
                        |),
                        [
                          M.read (| __serializer |);
                          M.read (| mk_str "GasQuantity" |);
                          BinOp.Panic.add (|
                            BinOp.Panic.add (|
                              M.rust_cast (Value.Bool false),
                              Value.Integer Integer.Usize 1
                            |),
                            Value.Integer Integer.Usize 1
                          |)
                        ]
                      |)
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.get_struct_tuple_field_or_break_match (|
                              γ,
                              "core::result::Result::Ok",
                              0
                            |) in
                          let __val := M.copy (| γ0_0 |) in
                          __val));
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.get_struct_tuple_field_or_break_match (|
                              γ,
                              "core::result::Result::Err",
                              0
                            |) in
                          let __err := M.copy (| γ0_0 |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  Value.StructTuple
                                    "core::result::Result::Err"
                                    [ M.read (| __err |) ]
                                |)
                              |)
                            |)
                          |)))
                    ]
                  |)
                |) in
              let _ :=
                M.match_operator (|
                  M.alloc (|
                    M.call_closure (|
                      M.get_trait_method (|
                        "serde::ser::SerializeStruct",
                        Ty.associated,
                        [],
                        "serialize_field",
                        [ Ty.path "u64" ]
                      |),
                      [
                        __serde_state;
                        M.read (| mk_str "val" |);
                        M.get_struct_record_field
                          (M.read (| self |))
                          "move_core_types::gas_algebra::GasQuantity"
                          "val"
                      ]
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.get_struct_tuple_field_or_break_match (|
                            γ,
                            "core::result::Result::Ok",
                            0
                          |) in
                        let __val := M.copy (| γ0_0 |) in
                        __val));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.get_struct_tuple_field_or_break_match (|
                            γ,
                            "core::result::Result::Err",
                            0
                          |) in
                        let __err := M.copy (| γ0_0 |) in
                        M.alloc (|
                          M.never_to_any (|
                            M.read (|
                              M.return_ (|
                                Value.StructTuple "core::result::Result::Err" [ M.read (| __err |) ]
                              |)
                            |)
                          |)
                        |)))
                  ]
                |) in
              let _ :=
                M.match_operator (|
                  M.alloc (|
                    M.call_closure (|
                      M.get_trait_method (|
                        "serde::ser::SerializeStruct",
                        Ty.associated,
                        [],
                        "serialize_field",
                        [ Ty.apply (Ty.path "core::marker::PhantomData") [ U ] ]
                      |),
                      [
                        __serde_state;
                        M.read (| mk_str "phantom" |);
                        M.get_struct_record_field
                          (M.read (| self |))
                          "move_core_types::gas_algebra::GasQuantity"
                          "phantom"
                      ]
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.get_struct_tuple_field_or_break_match (|
                            γ,
                            "core::result::Result::Ok",
                            0
                          |) in
                        let __val := M.copy (| γ0_0 |) in
                        __val));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.get_struct_tuple_field_or_break_match (|
                            γ,
                            "core::result::Result::Err",
                            0
                          |) in
                        let __err := M.copy (| γ0_0 |) in
                        M.alloc (|
                          M.never_to_any (|
                            M.read (|
                              M.return_ (|
                                Value.StructTuple "core::result::Result::Err" [ M.read (| __err |) ]
                              |)
                            |)
                          |)
                        |)))
                  ]
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "serde::ser::SerializeStruct",
                    Ty.associated,
                    [],
                    "end",
                    []
                  |),
                  [ M.read (| __serde_state |) ]
                |)
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (U : Ty.t),
        M.IsTraitInstance
          "serde::ser::Serialize"
          (Self U)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("serialize", InstanceField.Method (serialize U)) ].
    End Impl_serde_ser_Serialize_for_move_core_types_gas_algebra_GasQuantity_U.
  End underscore.
  
  Module Wrap_underscore_2.
  Module underscore.
    Module Impl_serde_de_Deserialize_for_move_core_types_gas_algebra_GasQuantity_U.
      Definition Self (U : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "move_core_types::gas_algebra::GasQuantity") [ U ].
      
      (* Deserialize *)
      Definition deserialize (U : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self U in
        match τ, α with
        | [ __D ], [ __deserializer ] =>
          ltac:(M.monadic
            (let __deserializer := M.alloc (| __deserializer |) in
            M.call_closure (|
              M.get_trait_method (|
                "serde::de::Deserializer",
                __D,
                [],
                "deserialize_struct",
                [
                  Ty.apply
                    (Ty.path "move_core_types::gas_algebra::_'1::deserialize::__Visitor")
                    [ U ]
                ]
              |),
              [
                M.read (| __deserializer |);
                M.read (| mk_str "GasQuantity" |);
                M.read (|
                  M.get_constant (| "move_core_types::gas_algebra::_'1::deserialize::FIELDS" |)
                |);
                Value.StructRecord
                  "move_core_types::gas_algebra::_'1::deserialize::__Visitor"
                  [
                    ("marker", Value.StructTuple "core::marker::PhantomData" []);
                    ("lifetime", Value.StructTuple "core::marker::PhantomData" [])
                  ]
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        forall (U : Ty.t),
        M.IsTraitInstance
          "serde::de::Deserialize"
          (Self U)
          (* Trait polymorphic types *) []
          (* Instance *) [ ("deserialize", InstanceField.Method (deserialize U)) ].
    End Impl_serde_de_Deserialize_for_move_core_types_gas_algebra_GasQuantity_U.
  End underscore.
  End Wrap_underscore_2.
  Import Wrap_underscore_2.
  
  Axiom InternalGas :
    (Ty.path "move_core_types::gas_algebra::InternalGas") =
      (Ty.apply
        (Ty.path "move_core_types::gas_algebra::GasQuantity")
        [ Ty.path "move_core_types::gas_algebra::InternalGasUnit" ]).
  
  Axiom NumBytes :
    (Ty.path "move_core_types::gas_algebra::NumBytes") =
      (Ty.apply
        (Ty.path "move_core_types::gas_algebra::GasQuantity")
        [ Ty.path "move_core_types::gas_algebra::Byte" ]).
  
  Axiom NumArgs :
    (Ty.path "move_core_types::gas_algebra::NumArgs") =
      (Ty.apply
        (Ty.path "move_core_types::gas_algebra::GasQuantity")
        [ Ty.path "move_core_types::gas_algebra::Arg" ]).
  
  Axiom AbstractMemorySize :
    (Ty.path "move_core_types::gas_algebra::AbstractMemorySize") =
      (Ty.apply
        (Ty.path "move_core_types::gas_algebra::GasQuantity")
        [ Ty.path "move_core_types::gas_algebra::AbstractMemoryUnit" ]).
  
  Axiom InternalGasPerByte :
    (Ty.path "move_core_types::gas_algebra::InternalGasPerByte") =
      (Ty.apply
        (Ty.path "move_core_types::gas_algebra::GasQuantity")
        [
          Ty.apply
            (Ty.path "move_core_types::gas_algebra::UnitDiv")
            [
              Ty.path "move_core_types::gas_algebra::InternalGasUnit";
              Ty.path "move_core_types::gas_algebra::Byte"
            ]
        ]).
  
  Axiom InternalGasPerAbstractMemoryUnit :
    (Ty.path "move_core_types::gas_algebra::InternalGasPerAbstractMemoryUnit") =
      (Ty.apply
        (Ty.path "move_core_types::gas_algebra::GasQuantity")
        [
          Ty.apply
            (Ty.path "move_core_types::gas_algebra::UnitDiv")
            [
              Ty.path "move_core_types::gas_algebra::InternalGasUnit";
              Ty.path "move_core_types::gas_algebra::AbstractMemoryUnit"
            ]
        ]).
  
  Axiom InternalGasPerArg :
    (Ty.path "move_core_types::gas_algebra::InternalGasPerArg") =
      (Ty.apply
        (Ty.path "move_core_types::gas_algebra::GasQuantity")
        [
          Ty.apply
            (Ty.path "move_core_types::gas_algebra::UnitDiv")
            [
              Ty.path "move_core_types::gas_algebra::InternalGasUnit";
              Ty.path "move_core_types::gas_algebra::Arg"
            ]
        ]).
  
  Module Impl_move_core_types_gas_algebra_GasQuantity_U.
    Definition Self (U : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "move_core_types::gas_algebra::GasQuantity") [ U ].
    
    (*
        pub const fn new(val: u64) -> Self {
            Self {
                val,
                phantom: PhantomData,
            }
        }
    *)
    Definition new (U : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self U in
      match τ, α with
      | [], [ val ] =>
        ltac:(M.monadic
          (let val := M.alloc (| val |) in
          Value.StructRecord
            "move_core_types::gas_algebra::GasQuantity"
            [
              ("val", M.read (| val |));
              ("phantom", Value.StructTuple "core::marker::PhantomData" [])
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_new : forall (U : Ty.t), M.IsAssociatedFunction (Self U) "new" (new U).
    
    (*
        pub const fn zero() -> Self {
            Self::new(0)
        }
    *)
    Definition zero (U : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self U in
      match τ, α with
      | [], [] =>
        ltac:(M.monadic
          (M.call_closure (|
            M.get_associated_function (|
              Ty.apply (Ty.path "move_core_types::gas_algebra::GasQuantity") [ U ],
              "new",
              []
            |),
            [ Value.Integer Integer.U64 0 ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_zero :
      forall (U : Ty.t),
      M.IsAssociatedFunction (Self U) "zero" (zero U).
    
    (*
        pub const fn one() -> Self {
            Self::new(1)
        }
    *)
    Definition one (U : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self U in
      match τ, α with
      | [], [] =>
        ltac:(M.monadic
          (M.call_closure (|
            M.get_associated_function (|
              Ty.apply (Ty.path "move_core_types::gas_algebra::GasQuantity") [ U ],
              "new",
              []
            |),
            [ Value.Integer Integer.U64 1 ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_one : forall (U : Ty.t), M.IsAssociatedFunction (Self U) "one" (one U).
    
    (*
        pub const fn is_zero(&self) -> bool {
            self.val == 0
        }
    *)
    Definition is_zero (U : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self U in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          BinOp.Pure.eq
            (M.read (|
              M.get_struct_record_field
                (M.read (| self |))
                "move_core_types::gas_algebra::GasQuantity"
                "val"
            |))
            (Value.Integer Integer.U64 0)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_is_zero :
      forall (U : Ty.t),
      M.IsAssociatedFunction (Self U) "is_zero" (is_zero U).
  End Impl_move_core_types_gas_algebra_GasQuantity_U.
  
  Module Impl_core_convert_From_u64_for_move_core_types_gas_algebra_GasQuantity_U.
    Definition Self (U : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "move_core_types::gas_algebra::GasQuantity") [ U ].
    
    (*
        fn from(val: u64) -> Self {
            Self::new(val)
        }
    *)
    Definition from (U : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self U in
      match τ, α with
      | [], [ val ] =>
        ltac:(M.monadic
          (let val := M.alloc (| val |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply (Ty.path "move_core_types::gas_algebra::GasQuantity") [ U ],
              "new",
              []
            |),
            [ M.read (| val |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (U : Ty.t),
      M.IsTraitInstance
        "core::convert::From"
        (Self U)
        (* Trait polymorphic types *) [ (* T *) Ty.path "u64" ]
        (* Instance *) [ ("from", InstanceField.Method (from U)) ].
  End Impl_core_convert_From_u64_for_move_core_types_gas_algebra_GasQuantity_U.
  
  Module Impl_core_convert_From_move_core_types_gas_algebra_GasQuantity_U_for_u64.
    Definition Self (U : Ty.t) : Ty.t := Ty.path "u64".
    
    (*
        fn from(gas: GasQuantity<U>) -> Self {
            gas.val
        }
    *)
    Definition from (U : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self U in
      match τ, α with
      | [], [ gas ] =>
        ltac:(M.monadic
          (let gas := M.alloc (| gas |) in
          M.read (|
            M.get_struct_record_field gas "move_core_types::gas_algebra::GasQuantity" "val"
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (U : Ty.t),
      M.IsTraitInstance
        "core::convert::From"
        (Self U)
        (* Trait polymorphic types *)
        [ (* T *) Ty.apply (Ty.path "move_core_types::gas_algebra::GasQuantity") [ U ] ]
        (* Instance *) [ ("from", InstanceField.Method (from U)) ].
  End Impl_core_convert_From_move_core_types_gas_algebra_GasQuantity_U_for_u64.
  
  Module Impl_core_clone_Clone_for_move_core_types_gas_algebra_GasQuantity_U.
    Definition Self (U : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "move_core_types::gas_algebra::GasQuantity") [ U ].
    
    (*
        fn clone(&self) -> Self {
            Self::new(self.val)
        }
    *)
    Definition clone (U : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self U in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply (Ty.path "move_core_types::gas_algebra::GasQuantity") [ U ],
              "new",
              []
            |),
            [
              M.read (|
                M.get_struct_record_field
                  (M.read (| self |))
                  "move_core_types::gas_algebra::GasQuantity"
                  "val"
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (U : Ty.t),
      M.IsTraitInstance
        "core::clone::Clone"
        (Self U)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("clone", InstanceField.Method (clone U)) ].
  End Impl_core_clone_Clone_for_move_core_types_gas_algebra_GasQuantity_U.
  
  Module Impl_core_marker_Copy_for_move_core_types_gas_algebra_GasQuantity_U.
    Definition Self (U : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "move_core_types::gas_algebra::GasQuantity") [ U ].
    
    Axiom Implements :
      forall (U : Ty.t),
      M.IsTraitInstance
        "core::marker::Copy"
        (Self U)
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_Copy_for_move_core_types_gas_algebra_GasQuantity_U.
  
  Module Impl_core_fmt_Display_for_move_core_types_gas_algebra_GasQuantity_U.
    Definition Self (U : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "move_core_types::gas_algebra::GasQuantity") [ U ].
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            write!(f, "{}", self.val)
        }
    *)
    Definition fmt (U : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self U in
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_fmt", [] |),
            [
              M.read (| f |);
              M.call_closure (|
                M.get_associated_function (| Ty.path "core::fmt::Arguments", "new_v1", [] |),
                [
                  (* Unsize *)
                  M.pointer_coercion (M.alloc (| Value.Array [ M.read (| mk_str "" |) ] |));
                  (* Unsize *)
                  M.pointer_coercion
                    (M.alloc (|
                      Value.Array
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::rt::Argument",
                              "new_display",
                              [ Ty.path "u64" ]
                            |),
                            [
                              M.get_struct_record_field
                                (M.read (| self |))
                                "move_core_types::gas_algebra::GasQuantity"
                                "val"
                            ]
                          |)
                        ]
                    |))
                ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (U : Ty.t),
      M.IsTraitInstance
        "core::fmt::Display"
        (Self U)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method (fmt U)) ].
  End Impl_core_fmt_Display_for_move_core_types_gas_algebra_GasQuantity_U.
  
  Module Impl_core_fmt_Debug_for_move_core_types_gas_algebra_GasQuantity_U.
    Definition Self (U : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "move_core_types::gas_algebra::GasQuantity") [ U ].
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            write!(f, "{} ({})", self.val, std::any::type_name::<U>())
        }
    *)
    Definition fmt (U : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self U in
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_fmt", [] |),
            [
              M.read (| f |);
              M.call_closure (|
                M.get_associated_function (| Ty.path "core::fmt::Arguments", "new_v1", [] |),
                [
                  (* Unsize *)
                  M.pointer_coercion
                    (M.alloc (|
                      Value.Array
                        [ M.read (| mk_str "" |); M.read (| mk_str " (" |); M.read (| mk_str ")" |)
                        ]
                    |));
                  (* Unsize *)
                  M.pointer_coercion
                    (M.alloc (|
                      Value.Array
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::rt::Argument",
                              "new_display",
                              [ Ty.path "u64" ]
                            |),
                            [
                              M.get_struct_record_field
                                (M.read (| self |))
                                "move_core_types::gas_algebra::GasQuantity"
                                "val"
                            ]
                          |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::rt::Argument",
                              "new_display",
                              [ Ty.apply (Ty.path "&") [ Ty.path "str" ] ]
                            |),
                            [
                              M.alloc (|
                                M.call_closure (|
                                  M.get_function (| "core::any::type_name", [ U ] |),
                                  []
                                |)
                              |)
                            ]
                          |)
                        ]
                    |))
                ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (U : Ty.t),
      M.IsTraitInstance
        "core::fmt::Debug"
        (Self U)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method (fmt U)) ].
  End Impl_core_fmt_Debug_for_move_core_types_gas_algebra_GasQuantity_U.
  
  Module Wrap_Impl_move_core_types_gas_algebra_GasQuantity_U_2.
  Module Impl_move_core_types_gas_algebra_GasQuantity_U.
    Definition Self (U : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "move_core_types::gas_algebra::GasQuantity") [ U ].
    
    (*
        fn cmp_impl(&self, other: &Self) -> Ordering {
            self.val.cmp(&other.val)
        }
    *)
    Definition cmp_impl (U : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self U in
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_trait_method (| "core::cmp::Ord", Ty.path "u64", [], "cmp", [] |),
            [
              M.get_struct_record_field
                (M.read (| self |))
                "move_core_types::gas_algebra::GasQuantity"
                "val";
              M.get_struct_record_field
                (M.read (| other |))
                "move_core_types::gas_algebra::GasQuantity"
                "val"
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_cmp_impl :
      forall (U : Ty.t),
      M.IsAssociatedFunction (Self U) "cmp_impl" (cmp_impl U).
  End Impl_move_core_types_gas_algebra_GasQuantity_U.
  End Wrap_Impl_move_core_types_gas_algebra_GasQuantity_U_2.
  Import Wrap_Impl_move_core_types_gas_algebra_GasQuantity_U_2.
  
  Module Impl_core_cmp_PartialEq_for_move_core_types_gas_algebra_GasQuantity_U.
    Definition Self (U : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "move_core_types::gas_algebra::GasQuantity") [ U ].
    
    (*
        fn eq(&self, other: &Self) -> bool {
            matches!(self.cmp_impl(other), Ordering::Equal)
        }
    *)
    Definition eq (U : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self U in
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "move_core_types::gas_algebra::GasQuantity") [ U ],
                    "cmp_impl",
                    []
                  |),
                  [ M.read (| self |); M.read (| other |) ]
                |)
              |),
              [
                fun γ => ltac:(M.monadic (M.alloc (| Value.Bool true |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Bool false |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (U : Ty.t),
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (Self U)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("eq", InstanceField.Method (eq U)) ].
  End Impl_core_cmp_PartialEq_for_move_core_types_gas_algebra_GasQuantity_U.
  
  Module Impl_core_cmp_Eq_for_move_core_types_gas_algebra_GasQuantity_U.
    Definition Self (U : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "move_core_types::gas_algebra::GasQuantity") [ U ].
    
    Axiom Implements :
      forall (U : Ty.t),
      M.IsTraitInstance "core::cmp::Eq" (Self U) (* Trait polymorphic types *) [] (* Instance *) [].
  End Impl_core_cmp_Eq_for_move_core_types_gas_algebra_GasQuantity_U.
  
  Module Impl_core_cmp_PartialOrd_for_move_core_types_gas_algebra_GasQuantity_U.
    Definition Self (U : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "move_core_types::gas_algebra::GasQuantity") [ U ].
    
    (*
        fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
            Some(self.cmp_impl(other))
        }
    *)
    Definition partial_cmp (U : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self U in
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          Value.StructTuple
            "core::option::Option::Some"
            [
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply (Ty.path "move_core_types::gas_algebra::GasQuantity") [ U ],
                  "cmp_impl",
                  []
                |),
                [ M.read (| self |); M.read (| other |) ]
              |)
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (U : Ty.t),
      M.IsTraitInstance
        "core::cmp::PartialOrd"
        (Self U)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("partial_cmp", InstanceField.Method (partial_cmp U)) ].
  End Impl_core_cmp_PartialOrd_for_move_core_types_gas_algebra_GasQuantity_U.
  
  Module Impl_core_cmp_Ord_for_move_core_types_gas_algebra_GasQuantity_U.
    Definition Self (U : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "move_core_types::gas_algebra::GasQuantity") [ U ].
    
    (*
        fn cmp(&self, other: &Self) -> Ordering {
            self.cmp_impl(other)
        }
    *)
    Definition cmp (U : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self U in
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply (Ty.path "move_core_types::gas_algebra::GasQuantity") [ U ],
              "cmp_impl",
              []
            |),
            [ M.read (| self |); M.read (| other |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (U : Ty.t),
      M.IsTraitInstance
        "core::cmp::Ord"
        (Self U)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("cmp", InstanceField.Method (cmp U)) ].
  End Impl_core_cmp_Ord_for_move_core_types_gas_algebra_GasQuantity_U.
  
  Module Impl_core_ops_arith_Add_move_core_types_gas_algebra_GasQuantity_U_for_move_core_types_gas_algebra_GasQuantity_U.
    Definition Self (U : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "move_core_types::gas_algebra::GasQuantity") [ U ].
    
    (*     type Output = Self; *)
    Definition _Output (U : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "move_core_types::gas_algebra::GasQuantity") [ U ].
    
    (*
        fn add(self, rhs: Self) -> Self::Output {
            Self::new(self.val.saturating_add(rhs.val))
        }
    *)
    Definition add (U : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self U in
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply (Ty.path "move_core_types::gas_algebra::GasQuantity") [ U ],
              "new",
              []
            |),
            [
              M.call_closure (|
                M.get_associated_function (| Ty.path "u64", "saturating_add", [] |),
                [
                  M.read (|
                    M.get_struct_record_field self "move_core_types::gas_algebra::GasQuantity" "val"
                  |);
                  M.read (|
                    M.get_struct_record_field rhs "move_core_types::gas_algebra::GasQuantity" "val"
                  |)
                ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (U : Ty.t),
      M.IsTraitInstance
        "core::ops::arith::Add"
        (Self U)
        (* Trait polymorphic types *)
        [ (* Rhs *) Ty.apply (Ty.path "move_core_types::gas_algebra::GasQuantity") [ U ] ]
        (* Instance *)
        [ ("Output", InstanceField.Ty (_Output U)); ("add", InstanceField.Method (add U)) ].
  End Impl_core_ops_arith_Add_move_core_types_gas_algebra_GasQuantity_U_for_move_core_types_gas_algebra_GasQuantity_U.
  
  Module Impl_core_ops_arith_AddAssign_move_core_types_gas_algebra_GasQuantity_U_for_move_core_types_gas_algebra_GasQuantity_U.
    Definition Self (U : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "move_core_types::gas_algebra::GasQuantity") [ U ].
    
    (*
        fn add_assign(&mut self, rhs: GasQuantity<U>) {
            *self = *self + rhs
        }
    *)
    Definition add_assign (U : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self U in
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.write (|
              M.read (| self |),
              M.call_closure (|
                M.get_trait_method (|
                  "core::ops::arith::Add",
                  Ty.apply (Ty.path "move_core_types::gas_algebra::GasQuantity") [ U ],
                  [ Ty.apply (Ty.path "move_core_types::gas_algebra::GasQuantity") [ U ] ],
                  "add",
                  []
                |),
                [ M.read (| M.read (| self |) |); M.read (| rhs |) ]
              |)
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (U : Ty.t),
      M.IsTraitInstance
        "core::ops::arith::AddAssign"
        (Self U)
        (* Trait polymorphic types *)
        [ (* Rhs *) Ty.apply (Ty.path "move_core_types::gas_algebra::GasQuantity") [ U ] ]
        (* Instance *) [ ("add_assign", InstanceField.Method (add_assign U)) ].
  End Impl_core_ops_arith_AddAssign_move_core_types_gas_algebra_GasQuantity_U_for_move_core_types_gas_algebra_GasQuantity_U.
  
  Module Wrap_Impl_move_core_types_gas_algebra_GasQuantity_U_3.
  Module Impl_move_core_types_gas_algebra_GasQuantity_U.
    Definition Self (U : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "move_core_types::gas_algebra::GasQuantity") [ U ].
    
    (*
        pub fn checked_sub(self, other: Self) -> Option<Self> {
            self.val.checked_sub(other.val).map(Self::new)
        }
    *)
    Definition checked_sub (U : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self U in
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply (Ty.path "core::option::Option") [ Ty.path "u64" ],
              "map",
              [
                Ty.apply (Ty.path "move_core_types::gas_algebra::GasQuantity") [ U ];
                Ty.function
                  [ Ty.path "u64" ]
                  (Ty.apply (Ty.path "move_core_types::gas_algebra::GasQuantity") [ U ])
              ]
            |),
            [
              M.call_closure (|
                M.get_associated_function (| Ty.path "u64", "checked_sub", [] |),
                [
                  M.read (|
                    M.get_struct_record_field self "move_core_types::gas_algebra::GasQuantity" "val"
                  |);
                  M.read (|
                    M.get_struct_record_field
                      other
                      "move_core_types::gas_algebra::GasQuantity"
                      "val"
                  |)
                ]
              |);
              M.get_associated_function (|
                Ty.apply (Ty.path "move_core_types::gas_algebra::GasQuantity") [ U ],
                "new",
                []
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_sub :
      forall (U : Ty.t),
      M.IsAssociatedFunction (Self U) "checked_sub" (checked_sub U).
  End Impl_move_core_types_gas_algebra_GasQuantity_U.
  End Wrap_Impl_move_core_types_gas_algebra_GasQuantity_U_3.
  Import Wrap_Impl_move_core_types_gas_algebra_GasQuantity_U_3.
  
  (*
  fn mul_impl<U1, U2>(x: GasQuantity<U2>, y: GasQuantity<UnitDiv<U1, U2>>) -> GasQuantity<U1> {
      GasQuantity::new(x.val.saturating_mul(y.val))
  }
  *)
  Definition mul_impl (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [ U1; U2 ], [ x; y ] =>
      ltac:(M.monadic
        (let x := M.alloc (| x |) in
        let y := M.alloc (| y |) in
        M.call_closure (|
          M.get_associated_function (|
            Ty.apply (Ty.path "move_core_types::gas_algebra::GasQuantity") [ U1 ],
            "new",
            []
          |),
          [
            M.call_closure (|
              M.get_associated_function (| Ty.path "u64", "saturating_mul", [] |),
              [
                M.read (|
                  M.get_struct_record_field x "move_core_types::gas_algebra::GasQuantity" "val"
                |);
                M.read (|
                  M.get_struct_record_field y "move_core_types::gas_algebra::GasQuantity" "val"
                |)
              ]
            |)
          ]
        |)))
    | _, _ => M.impossible
    end.
  
  Module Impl_core_ops_arith_Mul_move_core_types_gas_algebra_GasQuantity_move_core_types_gas_algebra_UnitDiv_U1_U2_for_move_core_types_gas_algebra_GasQuantity_U2.
    Definition Self (U1 U2 : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "move_core_types::gas_algebra::GasQuantity") [ U2 ].
    
    (*     type Output = GasQuantity<U1>; *)
    Definition _Output (U1 U2 : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "move_core_types::gas_algebra::GasQuantity") [ U1 ].
    
    (*
        fn mul(self, rhs: GasQuantity<UnitDiv<U1, U2>>) -> Self::Output {
            mul_impl(self, rhs)
        }
    *)
    Definition mul (U1 U2 : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self U1 U2 in
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "move_core_types::gas_algebra::mul_impl", [ U1; U2 ] |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (U1 U2 : Ty.t),
      M.IsTraitInstance
        "core::ops::arith::Mul"
        (Self U1 U2)
        (* Trait polymorphic types *)
        [
          (* Rhs *)
          Ty.apply
            (Ty.path "move_core_types::gas_algebra::GasQuantity")
            [ Ty.apply (Ty.path "move_core_types::gas_algebra::UnitDiv") [ U1; U2 ] ]
        ]
        (* Instance *)
        [ ("Output", InstanceField.Ty (_Output U1 U2)); ("mul", InstanceField.Method (mul U1 U2)) ].
  End Impl_core_ops_arith_Mul_move_core_types_gas_algebra_GasQuantity_move_core_types_gas_algebra_UnitDiv_U1_U2_for_move_core_types_gas_algebra_GasQuantity_U2.
  
  Module Impl_core_ops_arith_Mul_move_core_types_gas_algebra_GasQuantity_U2_for_move_core_types_gas_algebra_GasQuantity_move_core_types_gas_algebra_UnitDiv_U1_U2.
    Definition Self (U1 U2 : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "move_core_types::gas_algebra::GasQuantity")
        [ Ty.apply (Ty.path "move_core_types::gas_algebra::UnitDiv") [ U1; U2 ] ].
    
    (*     type Output = GasQuantity<U1>; *)
    Definition _Output (U1 U2 : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "move_core_types::gas_algebra::GasQuantity") [ U1 ].
    
    (*
        fn mul(self, rhs: GasQuantity<U2>) -> Self::Output {
            mul_impl(rhs, self)
        }
    *)
    Definition mul (U1 U2 : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self U1 U2 in
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_function (| "move_core_types::gas_algebra::mul_impl", [ U1; U2 ] |),
            [ M.read (| rhs |); M.read (| self |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (U1 U2 : Ty.t),
      M.IsTraitInstance
        "core::ops::arith::Mul"
        (Self U1 U2)
        (* Trait polymorphic types *)
        [ (* Rhs *) Ty.apply (Ty.path "move_core_types::gas_algebra::GasQuantity") [ U2 ] ]
        (* Instance *)
        [ ("Output", InstanceField.Ty (_Output U1 U2)); ("mul", InstanceField.Method (mul U1 U2)) ].
  End Impl_core_ops_arith_Mul_move_core_types_gas_algebra_GasQuantity_U2_for_move_core_types_gas_algebra_GasQuantity_move_core_types_gas_algebra_UnitDiv_U1_U2.
  
  (*
  fn apply_ratio_round_down(val: u64, nominator: u64, denominator: u64) -> u64 {
      assert_ne!(nominator, 0);
      assert_ne!(denominator, 0);
  
      let res = val as u128 * nominator as u128 / denominator as u128;
      if res > u64::MAX as u128 {
          u64::MAX
      } else {
          res as u64
      }
  }
  *)
  Definition apply_ratio_round_down (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ val; nominator; denominator ] =>
      ltac:(M.monadic
        (let val := M.alloc (| val |) in
        let nominator := M.alloc (| nominator |) in
        let denominator := M.alloc (| denominator |) in
        M.read (|
          let _ :=
            M.match_operator (|
              M.alloc (| Value.Tuple [ nominator; M.alloc (| Value.Integer Integer.U64 0 |) ] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.get_tuple_field γ 0 in
                    let γ0_1 := M.get_tuple_field γ 1 in
                    let left_val := M.copy (| γ0_0 |) in
                    let right_val := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  BinOp.Pure.eq
                                    (M.read (| M.read (| left_val |) |))
                                    (M.read (| M.read (| right_val |) |))
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  let kind :=
                                    M.alloc (|
                                      Value.StructTuple "core::panicking::AssertKind::Ne" []
                                    |) in
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_function (|
                                        "core::panicking::assert_failed",
                                        [ Ty.path "u64"; Ty.path "u64" ]
                                      |),
                                      [
                                        M.read (| kind |);
                                        M.read (| left_val |);
                                        M.read (| right_val |);
                                        Value.StructTuple "core::option::Option::None" []
                                      ]
                                    |)
                                  |)
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |)))
              ]
            |) in
          let _ :=
            M.match_operator (|
              M.alloc (| Value.Tuple [ denominator; M.alloc (| Value.Integer Integer.U64 0 |) ] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.get_tuple_field γ 0 in
                    let γ0_1 := M.get_tuple_field γ 1 in
                    let left_val := M.copy (| γ0_0 |) in
                    let right_val := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  BinOp.Pure.eq
                                    (M.read (| M.read (| left_val |) |))
                                    (M.read (| M.read (| right_val |) |))
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  let kind :=
                                    M.alloc (|
                                      Value.StructTuple "core::panicking::AssertKind::Ne" []
                                    |) in
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_function (|
                                        "core::panicking::assert_failed",
                                        [ Ty.path "u64"; Ty.path "u64" ]
                                      |),
                                      [
                                        M.read (| kind |);
                                        M.read (| left_val |);
                                        M.read (| right_val |);
                                        Value.StructTuple "core::option::Option::None" []
                                      ]
                                    |)
                                  |)
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |)))
              ]
            |) in
          let res :=
            M.alloc (|
              BinOp.Panic.div (|
                BinOp.Panic.mul (|
                  M.rust_cast (M.read (| val |)),
                  M.rust_cast (M.read (| nominator |))
                |),
                M.rust_cast (M.read (| denominator |))
              |)
            |) in
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        BinOp.Pure.gt
                          (M.read (| res |))
                          (M.rust_cast (M.read (| M.get_constant (| "core::num::MAX" |) |)))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.get_constant (| "core::num::MAX" |)));
              fun γ => ltac:(M.monadic (M.alloc (| M.rust_cast (M.read (| res |)) |)))
            ]
          |)
        |)))
    | _, _ => M.impossible
    end.
  
  (*
  fn apply_ratio_round_up(val: u64, nominator: u64, denominator: u64) -> u64 {
      assert_ne!(nominator, 0);
      assert_ne!(denominator, 0);
  
      let n = val as u128 * nominator as u128;
      let d = denominator as u128;
  
      let res = n / d + if n % d == 0 { 0 } else { 1 };
      if res > u64::MAX as u128 {
          u64::MAX
      } else {
          res as u64
      }
  }
  *)
  Definition apply_ratio_round_up (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ val; nominator; denominator ] =>
      ltac:(M.monadic
        (let val := M.alloc (| val |) in
        let nominator := M.alloc (| nominator |) in
        let denominator := M.alloc (| denominator |) in
        M.read (|
          let _ :=
            M.match_operator (|
              M.alloc (| Value.Tuple [ nominator; M.alloc (| Value.Integer Integer.U64 0 |) ] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.get_tuple_field γ 0 in
                    let γ0_1 := M.get_tuple_field γ 1 in
                    let left_val := M.copy (| γ0_0 |) in
                    let right_val := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  BinOp.Pure.eq
                                    (M.read (| M.read (| left_val |) |))
                                    (M.read (| M.read (| right_val |) |))
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  let kind :=
                                    M.alloc (|
                                      Value.StructTuple "core::panicking::AssertKind::Ne" []
                                    |) in
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_function (|
                                        "core::panicking::assert_failed",
                                        [ Ty.path "u64"; Ty.path "u64" ]
                                      |),
                                      [
                                        M.read (| kind |);
                                        M.read (| left_val |);
                                        M.read (| right_val |);
                                        Value.StructTuple "core::option::Option::None" []
                                      ]
                                    |)
                                  |)
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |)))
              ]
            |) in
          let _ :=
            M.match_operator (|
              M.alloc (| Value.Tuple [ denominator; M.alloc (| Value.Integer Integer.U64 0 |) ] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.get_tuple_field γ 0 in
                    let γ0_1 := M.get_tuple_field γ 1 in
                    let left_val := M.copy (| γ0_0 |) in
                    let right_val := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  BinOp.Pure.eq
                                    (M.read (| M.read (| left_val |) |))
                                    (M.read (| M.read (| right_val |) |))
                                |)) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  let kind :=
                                    M.alloc (|
                                      Value.StructTuple "core::panicking::AssertKind::Ne" []
                                    |) in
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_function (|
                                        "core::panicking::assert_failed",
                                        [ Ty.path "u64"; Ty.path "u64" ]
                                      |),
                                      [
                                        M.read (| kind |);
                                        M.read (| left_val |);
                                        M.read (| right_val |);
                                        Value.StructTuple "core::option::Option::None" []
                                      ]
                                    |)
                                  |)
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |)))
              ]
            |) in
          let n :=
            M.alloc (|
              BinOp.Panic.mul (|
                M.rust_cast (M.read (| val |)),
                M.rust_cast (M.read (| nominator |))
              |)
            |) in
          let d := M.alloc (| M.rust_cast (M.read (| denominator |)) |) in
          let res :=
            M.alloc (|
              BinOp.Panic.add (|
                BinOp.Panic.div (| M.read (| n |), M.read (| d |) |),
                M.read (|
                  M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                BinOp.Pure.eq
                                  (BinOp.Panic.rem (| M.read (| n |), M.read (| d |) |))
                                  (Value.Integer Integer.U128 0)
                              |)) in
                          let _ :=
                            M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (| Value.Integer Integer.U128 0 |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Integer Integer.U128 1 |)))
                    ]
                  |)
                |)
              |)
            |) in
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        BinOp.Pure.gt
                          (M.read (| res |))
                          (M.rust_cast (M.read (| M.get_constant (| "core::num::MAX" |) |)))
                      |)) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.get_constant (| "core::num::MAX" |)));
              fun γ => ltac:(M.monadic (M.alloc (| M.rust_cast (M.read (| res |)) |)))
            ]
          |)
        |)))
    | _, _ => M.impossible
    end.
  
  (* Trait *)
  (* Empty module 'ToUnit' *)
  
  (* Trait *)
  (* Empty module 'ToUnitFractional' *)
  
  Module Wrap_Impl_move_core_types_gas_algebra_GasQuantity_U_4.
  Module Impl_move_core_types_gas_algebra_GasQuantity_U.
    Definition Self (U : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "move_core_types::gas_algebra::GasQuantity") [ U ].
    
    (*
        pub fn to_unit<T>(self) -> GasQuantity<T>
        where
            U: ToUnit<T>,
        {
            assert_ne!(U::MULTIPLIER, 0);
    
            GasQuantity::new(self.val.saturating_mul(U::MULTIPLIER))
        }
    *)
    Definition to_unit (U : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self U in
      match τ, α with
      | [ T ], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let _ :=
              M.match_operator (|
                M.alloc (|
                  Value.Tuple
                    [
                      M.get_constant (| "move_core_types::gas_algebra::ToUnit::MULTIPLIER" |);
                      M.alloc (| Value.Integer Integer.U64 0 |)
                    ]
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.get_tuple_field γ 0 in
                      let γ0_1 := M.get_tuple_field γ 1 in
                      let left_val := M.copy (| γ0_0 |) in
                      let right_val := M.copy (| γ0_1 |) in
                      M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    BinOp.Pure.eq
                                      (M.read (| M.read (| left_val |) |))
                                      (M.read (| M.read (| right_val |) |))
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    let kind :=
                                      M.alloc (|
                                        Value.StructTuple "core::panicking::AssertKind::Ne" []
                                      |) in
                                    M.alloc (|
                                      M.call_closure (|
                                        M.get_function (|
                                          "core::panicking::assert_failed",
                                          [ Ty.path "u64"; Ty.path "u64" ]
                                        |),
                                        [
                                          M.read (| kind |);
                                          M.read (| left_val |);
                                          M.read (| right_val |);
                                          Value.StructTuple "core::option::Option::None" []
                                        ]
                                      |)
                                    |)
                                  |)
                                |)
                              |)));
                          fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                        ]
                      |)))
                ]
              |) in
            M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply (Ty.path "move_core_types::gas_algebra::GasQuantity") [ T ],
                  "new",
                  []
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "u64", "saturating_mul", [] |),
                    [
                      M.read (|
                        M.get_struct_record_field
                          self
                          "move_core_types::gas_algebra::GasQuantity"
                          "val"
                      |);
                      M.read (|
                        M.get_constant (| "move_core_types::gas_algebra::ToUnit::MULTIPLIER" |)
                      |)
                    ]
                  |)
                ]
              |)
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_to_unit :
      forall (U : Ty.t),
      M.IsAssociatedFunction (Self U) "to_unit" (to_unit U).
    
    (*
        pub fn to_unit_round_down<T>(self) -> GasQuantity<T>
        where
            U: ToUnitFractional<T>,
        {
            GasQuantity::new(apply_ratio_round_down(
                self.val,
                U::NOMINATOR,
                U::DENOMINATOR,
            ))
        }
    *)
    Definition to_unit_round_down (U : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self U in
      match τ, α with
      | [ T ], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply (Ty.path "move_core_types::gas_algebra::GasQuantity") [ T ],
              "new",
              []
            |),
            [
              M.call_closure (|
                M.get_function (| "move_core_types::gas_algebra::apply_ratio_round_down", [] |),
                [
                  M.read (|
                    M.get_struct_record_field self "move_core_types::gas_algebra::GasQuantity" "val"
                  |);
                  M.read (|
                    M.get_constant (| "move_core_types::gas_algebra::ToUnitFractional::NOMINATOR" |)
                  |);
                  M.read (|
                    M.get_constant (|
                      "move_core_types::gas_algebra::ToUnitFractional::DENOMINATOR"
                    |)
                  |)
                ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_to_unit_round_down :
      forall (U : Ty.t),
      M.IsAssociatedFunction (Self U) "to_unit_round_down" (to_unit_round_down U).
    
    (*
        pub fn to_unit_round_up<T>(self) -> GasQuantity<T>
        where
            U: ToUnitFractional<T>,
        {
            GasQuantity::new(apply_ratio_round_up(self.val, U::NOMINATOR, U::DENOMINATOR))
        }
    *)
    Definition to_unit_round_up (U : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self U in
      match τ, α with
      | [ T ], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply (Ty.path "move_core_types::gas_algebra::GasQuantity") [ T ],
              "new",
              []
            |),
            [
              M.call_closure (|
                M.get_function (| "move_core_types::gas_algebra::apply_ratio_round_up", [] |),
                [
                  M.read (|
                    M.get_struct_record_field self "move_core_types::gas_algebra::GasQuantity" "val"
                  |);
                  M.read (|
                    M.get_constant (| "move_core_types::gas_algebra::ToUnitFractional::NOMINATOR" |)
                  |);
                  M.read (|
                    M.get_constant (|
                      "move_core_types::gas_algebra::ToUnitFractional::DENOMINATOR"
                    |)
                  |)
                ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_to_unit_round_up :
      forall (U : Ty.t),
      M.IsAssociatedFunction (Self U) "to_unit_round_up" (to_unit_round_up U).
  End Impl_move_core_types_gas_algebra_GasQuantity_U.
  End Wrap_Impl_move_core_types_gas_algebra_GasQuantity_U_4.
  Import Wrap_Impl_move_core_types_gas_algebra_GasQuantity_U_4.
  
  Module Impl_move_core_types_gas_algebra_ToUnit_move_core_types_gas_algebra_Byte_for_move_core_types_gas_algebra_KibiByte.
    Definition Self : Ty.t := Ty.path "move_core_types::gas_algebra::KibiByte".
    
    (*     const MULTIPLIER: u64 = 1024; *)
    (* Ty.path "u64" *)
    Definition value_MULTIPLIER : Value.t :=
      M.run ltac:(M.monadic (M.alloc (| Value.Integer Integer.U64 1024 |))).
    
    Axiom Implements :
      M.IsTraitInstance
        "move_core_types::gas_algebra::ToUnit"
        Self
        (* Trait polymorphic types *) [ (* U *) Ty.path "move_core_types::gas_algebra::Byte" ]
        (* Instance *) [ ("value_MULTIPLIER", InstanceField.Constant value_MULTIPLIER) ].
  End Impl_move_core_types_gas_algebra_ToUnit_move_core_types_gas_algebra_Byte_for_move_core_types_gas_algebra_KibiByte.
  
  Module Impl_move_core_types_gas_algebra_ToUnit_move_core_types_gas_algebra_Byte_for_move_core_types_gas_algebra_MebiByte.
    Definition Self : Ty.t := Ty.path "move_core_types::gas_algebra::MebiByte".
    
    (*     const MULTIPLIER: u64 = 1024 * 1024; *)
    (* Ty.path "u64" *)
    Definition value_MULTIPLIER : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            BinOp.Panic.mul (| Value.Integer Integer.U64 1024, Value.Integer Integer.U64 1024 |)
          |))).
    
    Axiom Implements :
      M.IsTraitInstance
        "move_core_types::gas_algebra::ToUnit"
        Self
        (* Trait polymorphic types *) [ (* U *) Ty.path "move_core_types::gas_algebra::Byte" ]
        (* Instance *) [ ("value_MULTIPLIER", InstanceField.Constant value_MULTIPLIER) ].
  End Impl_move_core_types_gas_algebra_ToUnit_move_core_types_gas_algebra_Byte_for_move_core_types_gas_algebra_MebiByte.
  
  Module Impl_move_core_types_gas_algebra_ToUnit_move_core_types_gas_algebra_Byte_for_move_core_types_gas_algebra_GibiByte.
    Definition Self : Ty.t := Ty.path "move_core_types::gas_algebra::GibiByte".
    
    (*     const MULTIPLIER: u64 = 1024 * 1024 * 1024; *)
    (* Ty.path "u64" *)
    Definition value_MULTIPLIER : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            BinOp.Panic.mul (|
              BinOp.Panic.mul (| Value.Integer Integer.U64 1024, Value.Integer Integer.U64 1024 |),
              Value.Integer Integer.U64 1024
            |)
          |))).
    
    Axiom Implements :
      M.IsTraitInstance
        "move_core_types::gas_algebra::ToUnit"
        Self
        (* Trait polymorphic types *) [ (* U *) Ty.path "move_core_types::gas_algebra::Byte" ]
        (* Instance *) [ ("value_MULTIPLIER", InstanceField.Constant value_MULTIPLIER) ].
  End Impl_move_core_types_gas_algebra_ToUnit_move_core_types_gas_algebra_Byte_for_move_core_types_gas_algebra_GibiByte.
  
  Module Impl_move_core_types_gas_algebra_ToUnit_move_core_types_gas_algebra_KibiByte_for_move_core_types_gas_algebra_MebiByte.
    Definition Self : Ty.t := Ty.path "move_core_types::gas_algebra::MebiByte".
    
    (*     const MULTIPLIER: u64 = 1024; *)
    (* Ty.path "u64" *)
    Definition value_MULTIPLIER : Value.t :=
      M.run ltac:(M.monadic (M.alloc (| Value.Integer Integer.U64 1024 |))).
    
    Axiom Implements :
      M.IsTraitInstance
        "move_core_types::gas_algebra::ToUnit"
        Self
        (* Trait polymorphic types *) [ (* U *) Ty.path "move_core_types::gas_algebra::KibiByte" ]
        (* Instance *) [ ("value_MULTIPLIER", InstanceField.Constant value_MULTIPLIER) ].
  End Impl_move_core_types_gas_algebra_ToUnit_move_core_types_gas_algebra_KibiByte_for_move_core_types_gas_algebra_MebiByte.
  
  Module Impl_move_core_types_gas_algebra_ToUnit_move_core_types_gas_algebra_KibiByte_for_move_core_types_gas_algebra_GibiByte.
    Definition Self : Ty.t := Ty.path "move_core_types::gas_algebra::GibiByte".
    
    (*     const MULTIPLIER: u64 = 1024 * 1024; *)
    (* Ty.path "u64" *)
    Definition value_MULTIPLIER : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            BinOp.Panic.mul (| Value.Integer Integer.U64 1024, Value.Integer Integer.U64 1024 |)
          |))).
    
    Axiom Implements :
      M.IsTraitInstance
        "move_core_types::gas_algebra::ToUnit"
        Self
        (* Trait polymorphic types *) [ (* U *) Ty.path "move_core_types::gas_algebra::KibiByte" ]
        (* Instance *) [ ("value_MULTIPLIER", InstanceField.Constant value_MULTIPLIER) ].
  End Impl_move_core_types_gas_algebra_ToUnit_move_core_types_gas_algebra_KibiByte_for_move_core_types_gas_algebra_GibiByte.
  
  Module Impl_move_core_types_gas_algebra_ToUnit_move_core_types_gas_algebra_MebiByte_for_move_core_types_gas_algebra_GibiByte.
    Definition Self : Ty.t := Ty.path "move_core_types::gas_algebra::GibiByte".
    
    (*     const MULTIPLIER: u64 = 1024; *)
    (* Ty.path "u64" *)
    Definition value_MULTIPLIER : Value.t :=
      M.run ltac:(M.monadic (M.alloc (| Value.Integer Integer.U64 1024 |))).
    
    Axiom Implements :
      M.IsTraitInstance
        "move_core_types::gas_algebra::ToUnit"
        Self
        (* Trait polymorphic types *) [ (* U *) Ty.path "move_core_types::gas_algebra::MebiByte" ]
        (* Instance *) [ ("value_MULTIPLIER", InstanceField.Constant value_MULTIPLIER) ].
  End Impl_move_core_types_gas_algebra_ToUnit_move_core_types_gas_algebra_MebiByte_for_move_core_types_gas_algebra_GibiByte.
  
  Module Impl_move_core_types_gas_algebra_ToUnitFractional_move_core_types_gas_algebra_KibiByte_for_move_core_types_gas_algebra_Byte.
    Definition Self : Ty.t := Ty.path "move_core_types::gas_algebra::Byte".
    
    (*     const NOMINATOR: u64 = 1; *)
    (* Ty.path "u64" *)
    Definition value_NOMINATOR : Value.t :=
      M.run ltac:(M.monadic (M.alloc (| Value.Integer Integer.U64 1 |))).
    
    (*     const DENOMINATOR: u64 = 1024; *)
    (* Ty.path "u64" *)
    Definition value_DENOMINATOR : Value.t :=
      M.run ltac:(M.monadic (M.alloc (| Value.Integer Integer.U64 1024 |))).
    
    Axiom Implements :
      M.IsTraitInstance
        "move_core_types::gas_algebra::ToUnitFractional"
        Self
        (* Trait polymorphic types *) [ (* U *) Ty.path "move_core_types::gas_algebra::KibiByte" ]
        (* Instance *)
        [
          ("value_NOMINATOR", InstanceField.Constant value_NOMINATOR);
          ("value_DENOMINATOR", InstanceField.Constant value_DENOMINATOR)
        ].
  End Impl_move_core_types_gas_algebra_ToUnitFractional_move_core_types_gas_algebra_KibiByte_for_move_core_types_gas_algebra_Byte.
  
  Module Impl_move_core_types_gas_algebra_ToUnitFractional_move_core_types_gas_algebra_MebiByte_for_move_core_types_gas_algebra_KibiByte.
    Definition Self : Ty.t := Ty.path "move_core_types::gas_algebra::KibiByte".
    
    (*     const NOMINATOR: u64 = 1; *)
    (* Ty.path "u64" *)
    Definition value_NOMINATOR : Value.t :=
      M.run ltac:(M.monadic (M.alloc (| Value.Integer Integer.U64 1 |))).
    
    (*     const DENOMINATOR: u64 = 1024; *)
    (* Ty.path "u64" *)
    Definition value_DENOMINATOR : Value.t :=
      M.run ltac:(M.monadic (M.alloc (| Value.Integer Integer.U64 1024 |))).
    
    Axiom Implements :
      M.IsTraitInstance
        "move_core_types::gas_algebra::ToUnitFractional"
        Self
        (* Trait polymorphic types *) [ (* U *) Ty.path "move_core_types::gas_algebra::MebiByte" ]
        (* Instance *)
        [
          ("value_NOMINATOR", InstanceField.Constant value_NOMINATOR);
          ("value_DENOMINATOR", InstanceField.Constant value_DENOMINATOR)
        ].
  End Impl_move_core_types_gas_algebra_ToUnitFractional_move_core_types_gas_algebra_MebiByte_for_move_core_types_gas_algebra_KibiByte.
  
  Module Impl_move_core_types_gas_algebra_ToUnitFractional_move_core_types_gas_algebra_MebiByte_for_move_core_types_gas_algebra_Byte.
    Definition Self : Ty.t := Ty.path "move_core_types::gas_algebra::Byte".
    
    (*     const NOMINATOR: u64 = 1; *)
    (* Ty.path "u64" *)
    Definition value_NOMINATOR : Value.t :=
      M.run ltac:(M.monadic (M.alloc (| Value.Integer Integer.U64 1 |))).
    
    (*     const DENOMINATOR: u64 = 1024 * 1024; *)
    (* Ty.path "u64" *)
    Definition value_DENOMINATOR : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            BinOp.Panic.mul (| Value.Integer Integer.U64 1024, Value.Integer Integer.U64 1024 |)
          |))).
    
    Axiom Implements :
      M.IsTraitInstance
        "move_core_types::gas_algebra::ToUnitFractional"
        Self
        (* Trait polymorphic types *) [ (* U *) Ty.path "move_core_types::gas_algebra::MebiByte" ]
        (* Instance *)
        [
          ("value_NOMINATOR", InstanceField.Constant value_NOMINATOR);
          ("value_DENOMINATOR", InstanceField.Constant value_DENOMINATOR)
        ].
  End Impl_move_core_types_gas_algebra_ToUnitFractional_move_core_types_gas_algebra_MebiByte_for_move_core_types_gas_algebra_Byte.
  
  Module Impl_move_core_types_gas_algebra_ToUnitFractional_move_core_types_gas_algebra_GibiByte_for_move_core_types_gas_algebra_MebiByte.
    Definition Self : Ty.t := Ty.path "move_core_types::gas_algebra::MebiByte".
    
    (*     const NOMINATOR: u64 = 1; *)
    (* Ty.path "u64" *)
    Definition value_NOMINATOR : Value.t :=
      M.run ltac:(M.monadic (M.alloc (| Value.Integer Integer.U64 1 |))).
    
    (*     const DENOMINATOR: u64 = 1024; *)
    (* Ty.path "u64" *)
    Definition value_DENOMINATOR : Value.t :=
      M.run ltac:(M.monadic (M.alloc (| Value.Integer Integer.U64 1024 |))).
    
    Axiom Implements :
      M.IsTraitInstance
        "move_core_types::gas_algebra::ToUnitFractional"
        Self
        (* Trait polymorphic types *) [ (* U *) Ty.path "move_core_types::gas_algebra::GibiByte" ]
        (* Instance *)
        [
          ("value_NOMINATOR", InstanceField.Constant value_NOMINATOR);
          ("value_DENOMINATOR", InstanceField.Constant value_DENOMINATOR)
        ].
  End Impl_move_core_types_gas_algebra_ToUnitFractional_move_core_types_gas_algebra_GibiByte_for_move_core_types_gas_algebra_MebiByte.
  
  Module Impl_move_core_types_gas_algebra_ToUnitFractional_move_core_types_gas_algebra_GibiByte_for_move_core_types_gas_algebra_KibiByte.
    Definition Self : Ty.t := Ty.path "move_core_types::gas_algebra::KibiByte".
    
    (*     const NOMINATOR: u64 = 1; *)
    (* Ty.path "u64" *)
    Definition value_NOMINATOR : Value.t :=
      M.run ltac:(M.monadic (M.alloc (| Value.Integer Integer.U64 1 |))).
    
    (*     const DENOMINATOR: u64 = 1024 * 1024; *)
    (* Ty.path "u64" *)
    Definition value_DENOMINATOR : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            BinOp.Panic.mul (| Value.Integer Integer.U64 1024, Value.Integer Integer.U64 1024 |)
          |))).
    
    Axiom Implements :
      M.IsTraitInstance
        "move_core_types::gas_algebra::ToUnitFractional"
        Self
        (* Trait polymorphic types *) [ (* U *) Ty.path "move_core_types::gas_algebra::GibiByte" ]
        (* Instance *)
        [
          ("value_NOMINATOR", InstanceField.Constant value_NOMINATOR);
          ("value_DENOMINATOR", InstanceField.Constant value_DENOMINATOR)
        ].
  End Impl_move_core_types_gas_algebra_ToUnitFractional_move_core_types_gas_algebra_GibiByte_for_move_core_types_gas_algebra_KibiByte.
  
  Module Impl_move_core_types_gas_algebra_ToUnitFractional_move_core_types_gas_algebra_GibiByte_for_move_core_types_gas_algebra_Byte.
    Definition Self : Ty.t := Ty.path "move_core_types::gas_algebra::Byte".
    
    (*     const NOMINATOR: u64 = 1; *)
    (* Ty.path "u64" *)
    Definition value_NOMINATOR : Value.t :=
      M.run ltac:(M.monadic (M.alloc (| Value.Integer Integer.U64 1 |))).
    
    (*     const DENOMINATOR: u64 = 1024 * 1024 * 1024; *)
    (* Ty.path "u64" *)
    Definition value_DENOMINATOR : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            BinOp.Panic.mul (|
              BinOp.Panic.mul (| Value.Integer Integer.U64 1024, Value.Integer Integer.U64 1024 |),
              Value.Integer Integer.U64 1024
            |)
          |))).
    
    Axiom Implements :
      M.IsTraitInstance
        "move_core_types::gas_algebra::ToUnitFractional"
        Self
        (* Trait polymorphic types *) [ (* U *) Ty.path "move_core_types::gas_algebra::GibiByte" ]
        (* Instance *)
        [
          ("value_NOMINATOR", InstanceField.Constant value_NOMINATOR);
          ("value_DENOMINATOR", InstanceField.Constant value_DENOMINATOR)
        ].
  End Impl_move_core_types_gas_algebra_ToUnitFractional_move_core_types_gas_algebra_GibiByte_for_move_core_types_gas_algebra_Byte.
  
  (* Trait *)
  (* Empty module 'ToUnitWithParams' *)
  
  (* Trait *)
  (* Empty module 'ToUnitFractionalWithParams' *)
  
  Module Wrap_Impl_move_core_types_gas_algebra_GasQuantity_U_5.
  Module Impl_move_core_types_gas_algebra_GasQuantity_U.
    Definition Self (U : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "move_core_types::gas_algebra::GasQuantity") [ U ].
    
    (*
        pub fn to_unit_with_params<T>(
            self,
            params: &<U as ToUnitWithParams<T>>::Params,
        ) -> GasQuantity<T>
        where
            U: ToUnitWithParams<T>,
        {
            let multiplier = <U as ToUnitWithParams<T>>::multiplier(params);
            assert_ne!(multiplier, 0);
            GasQuantity::new(self.val.saturating_mul(multiplier))
        }
    *)
    Definition to_unit_with_params (U : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self U in
      match τ, α with
      | [ T ], [ self; params ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let params := M.alloc (| params |) in
          M.read (|
            let multiplier :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "move_core_types::gas_algebra::ToUnitWithParams",
                    U,
                    [ T ],
                    "multiplier",
                    []
                  |),
                  [ M.read (| params |) ]
                |)
              |) in
            let _ :=
              M.match_operator (|
                M.alloc (| Value.Tuple [ multiplier; M.alloc (| Value.Integer Integer.U64 0 |) ] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.get_tuple_field γ 0 in
                      let γ0_1 := M.get_tuple_field γ 1 in
                      let left_val := M.copy (| γ0_0 |) in
                      let right_val := M.copy (| γ0_1 |) in
                      M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    BinOp.Pure.eq
                                      (M.read (| M.read (| left_val |) |))
                                      (M.read (| M.read (| right_val |) |))
                                  |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    let kind :=
                                      M.alloc (|
                                        Value.StructTuple "core::panicking::AssertKind::Ne" []
                                      |) in
                                    M.alloc (|
                                      M.call_closure (|
                                        M.get_function (|
                                          "core::panicking::assert_failed",
                                          [ Ty.path "u64"; Ty.path "u64" ]
                                        |),
                                        [
                                          M.read (| kind |);
                                          M.read (| left_val |);
                                          M.read (| right_val |);
                                          Value.StructTuple "core::option::Option::None" []
                                        ]
                                      |)
                                    |)
                                  |)
                                |)
                              |)));
                          fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                        ]
                      |)))
                ]
              |) in
            M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply (Ty.path "move_core_types::gas_algebra::GasQuantity") [ T ],
                  "new",
                  []
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "u64", "saturating_mul", [] |),
                    [
                      M.read (|
                        M.get_struct_record_field
                          self
                          "move_core_types::gas_algebra::GasQuantity"
                          "val"
                      |);
                      M.read (| multiplier |)
                    ]
                  |)
                ]
              |)
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_to_unit_with_params :
      forall (U : Ty.t),
      M.IsAssociatedFunction (Self U) "to_unit_with_params" (to_unit_with_params U).
    
    (*
        pub fn to_unit_round_down_with_params<T>(
            self,
            params: &<U as ToUnitFractionalWithParams<T>>::Params,
        ) -> GasQuantity<T>
        where
            U: ToUnitFractionalWithParams<T>,
        {
            let (n, d) = <U as ToUnitFractionalWithParams<T>>::ratio(params);
            GasQuantity::new(apply_ratio_round_down(self.val, n, d))
        }
    *)
    Definition to_unit_round_down_with_params (U : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self U in
      match τ, α with
      | [ T ], [ self; params ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let params := M.alloc (| params |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "move_core_types::gas_algebra::ToUnitFractionalWithParams",
                    U,
                    [ T ],
                    "ratio",
                    []
                  |),
                  [ M.read (| params |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.get_tuple_field γ 0 in
                    let γ0_1 := M.get_tuple_field γ 1 in
                    let n := M.copy (| γ0_0 |) in
                    let d := M.copy (| γ0_1 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "move_core_types::gas_algebra::GasQuantity") [ T ],
                          "new",
                          []
                        |),
                        [
                          M.call_closure (|
                            M.get_function (|
                              "move_core_types::gas_algebra::apply_ratio_round_down",
                              []
                            |),
                            [
                              M.read (|
                                M.get_struct_record_field
                                  self
                                  "move_core_types::gas_algebra::GasQuantity"
                                  "val"
                              |);
                              M.read (| n |);
                              M.read (| d |)
                            ]
                          |)
                        ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_to_unit_round_down_with_params :
      forall (U : Ty.t),
      M.IsAssociatedFunction
        (Self U)
        "to_unit_round_down_with_params"
        (to_unit_round_down_with_params U).
    
    (*
        pub fn to_unit_round_up_with_params<T>(
            self,
            params: &<U as ToUnitFractionalWithParams<T>>::Params,
        ) -> GasQuantity<T>
        where
            U: ToUnitFractionalWithParams<T>,
        {
            let (n, d) = <U as ToUnitFractionalWithParams<T>>::ratio(params);
            GasQuantity::new(apply_ratio_round_up(self.val, n, d))
        }
    *)
    Definition to_unit_round_up_with_params (U : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self U in
      match τ, α with
      | [ T ], [ self; params ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let params := M.alloc (| params |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "move_core_types::gas_algebra::ToUnitFractionalWithParams",
                    U,
                    [ T ],
                    "ratio",
                    []
                  |),
                  [ M.read (| params |) ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.get_tuple_field γ 0 in
                    let γ0_1 := M.get_tuple_field γ 1 in
                    let n := M.copy (| γ0_0 |) in
                    let d := M.copy (| γ0_1 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "move_core_types::gas_algebra::GasQuantity") [ T ],
                          "new",
                          []
                        |),
                        [
                          M.call_closure (|
                            M.get_function (|
                              "move_core_types::gas_algebra::apply_ratio_round_up",
                              []
                            |),
                            [
                              M.read (|
                                M.get_struct_record_field
                                  self
                                  "move_core_types::gas_algebra::GasQuantity"
                                  "val"
                              |);
                              M.read (| n |);
                              M.read (| d |)
                            ]
                          |)
                        ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_to_unit_round_up_with_params :
      forall (U : Ty.t),
      M.IsAssociatedFunction
        (Self U)
        "to_unit_round_up_with_params"
        (to_unit_round_up_with_params U).
  End Impl_move_core_types_gas_algebra_GasQuantity_U.
  End Wrap_Impl_move_core_types_gas_algebra_GasQuantity_U_5.
  Import Wrap_Impl_move_core_types_gas_algebra_GasQuantity_U_5.
End gas_algebra.

Module identifier.
  (*
  pub const fn is_valid_identifier_char(c: char) -> bool {
      matches!(c, '_' | 'a'..='z' | 'A'..='Z' | '0'..='9')
  }
  *)
  Definition is_valid_identifier_char (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ c ] =>
      ltac:(M.monadic
        (let c := M.alloc (| c |) in
        M.read (|
          M.match_operator (|
            c,
            [
              fun γ =>
                ltac:(M.monadic
                  (M.find_or_pattern (|
                    γ,
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let _ :=
                            M.is_constant_or_break_match (|
                              M.read (| γ |),
                              Value.UnicodeChar 95
                            |) in
                          Value.Tuple []));
                      fun γ => ltac:(M.monadic (Value.Tuple []));
                      fun γ => ltac:(M.monadic (Value.Tuple []));
                      fun γ => ltac:(M.monadic (Value.Tuple []))
                    ],
                    M.closure
                      (fun γ =>
                        ltac:(M.monadic
                          match γ with
                          | [] => M.alloc (| Value.Bool true |)
                          | _ => M.impossible (||)
                          end))
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Bool false |)))
            ]
          |)
        |)))
    | _, _ => M.impossible
    end.
  
  (*
  const fn all_bytes_valid(b: &[u8], start_offset: usize) -> bool {
      let mut i = start_offset;
      // TODO(philiphayes): use for loop instead of while loop when it's stable in const fn's.
      while i < b.len() {
          if !is_valid_identifier_char(b[i] as char) {
              return false;
          }
          i += 1;
      }
      true
  }
  *)
  Definition all_bytes_valid (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ b; start_offset ] =>
      ltac:(M.monadic
        (let b := M.alloc (| b |) in
        let start_offset := M.alloc (| start_offset |) in
        M.read (|
          let i := M.copy (| start_offset |) in
          let _ :=
            M.loop (|
              ltac:(M.monadic
                (M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              BinOp.Pure.lt
                                (M.read (| i |))
                                (M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply (Ty.path "slice") [ Ty.path "u8" ],
                                    "len",
                                    []
                                  |),
                                  [ M.read (| b |) ]
                                |))
                            |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        let _ :=
                          M.match_operator (|
                            M.alloc (| Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ :=
                                    M.use
                                      (M.alloc (|
                                        UnOp.Pure.not
                                          (M.call_closure (|
                                            M.get_function (|
                                              "move_core_types::identifier::is_valid_identifier_char",
                                              []
                                            |),
                                            [
                                              M.rust_cast
                                                (M.read (|
                                                  M.get_array_field (| M.read (| b |), i |)
                                                |))
                                            ]
                                          |))
                                      |)) in
                                  let _ :=
                                    M.is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (| M.return_ (| Value.Bool false |) |)
                                    |)
                                  |)));
                              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                            ]
                          |) in
                        let _ :=
                          let β := i in
                          M.write (|
                            β,
                            BinOp.Panic.add (| M.read (| β |), Value.Integer Integer.Usize 1 |)
                          |) in
                        M.alloc (| Value.Tuple [] |)));
                    fun γ =>
                      ltac:(M.monadic
                        (M.alloc (|
                          M.never_to_any (|
                            M.read (|
                              let _ :=
                                M.alloc (| M.never_to_any (| M.read (| M.break (||) |) |) |) in
                              M.alloc (| Value.Tuple [] |)
                            |)
                          |)
                        |)))
                  ]
                |)))
            |) in
          M.alloc (| Value.Bool true |)
        |)))
    | _, _ => M.impossible
    end.
  
  (*
  pub const fn is_valid(s: &str) -> bool {
      // Rust const fn's don't currently support slicing or indexing &str's, so we
      // have to operate on the underlying byte slice. This is not a problem as
      // valid identifiers are (currently) ASCII-only.
      let b = s.as_bytes();
      match b {
          b"<SELF>" => true,
          [b'a'..=b'z', ..] | [b'A'..=b'Z', ..] => all_bytes_valid(b, 1),
          [b'_', ..] if b.len() > 1 => all_bytes_valid(b, 1),
          _ => false,
      }
  }
  *)
  Definition is_valid (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ s ] =>
      ltac:(M.monadic
        (let s := M.alloc (| s |) in
        M.read (|
          let b :=
            M.alloc (|
              M.call_closure (|
                M.get_associated_function (| Ty.path "str", "as_bytes", [] |),
                [ M.read (| s |) ]
              |)
            |) in
          M.match_operator (|
            b,
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ := M.read (| γ |) in
                  let γ1_0 := M.get_slice_index_or_break_match (| γ, 0 |) in
                  let γ1_1 := M.get_slice_index_or_break_match (| γ, 1 |) in
                  let γ1_2 := M.get_slice_index_or_break_match (| γ, 2 |) in
                  let γ1_3 := M.get_slice_index_or_break_match (| γ, 3 |) in
                  let γ1_4 := M.get_slice_index_or_break_match (| γ, 4 |) in
                  let γ1_5 := M.get_slice_index_or_break_match (| γ, 5 |) in
                  let _ :=
                    M.is_constant_or_break_match (|
                      M.read (| γ1_0 |),
                      Value.Integer Integer.U8 60
                    |) in
                  let _ :=
                    M.is_constant_or_break_match (|
                      M.read (| γ1_1 |),
                      Value.Integer Integer.U8 83
                    |) in
                  let _ :=
                    M.is_constant_or_break_match (|
                      M.read (| γ1_2 |),
                      Value.Integer Integer.U8 69
                    |) in
                  let _ :=
                    M.is_constant_or_break_match (|
                      M.read (| γ1_3 |),
                      Value.Integer Integer.U8 76
                    |) in
                  let _ :=
                    M.is_constant_or_break_match (|
                      M.read (| γ1_4 |),
                      Value.Integer Integer.U8 70
                    |) in
                  let _ :=
                    M.is_constant_or_break_match (|
                      M.read (| γ1_5 |),
                      Value.Integer Integer.U8 62
                    |) in
                  M.alloc (| Value.Bool true |)));
              fun γ =>
                ltac:(M.monadic
                  (M.find_or_pattern (|
                    γ,
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ := M.read (| γ |) in
                          let γ1_0 := M.get_slice_index_or_break_match (| γ, 0 |) in
                          let γ1_rest := M.get_slice_rest_or_break_match (| γ, 1, 0 |) in
                          Value.Tuple []));
                      fun γ =>
                        ltac:(M.monadic
                          (let γ := M.read (| γ |) in
                          let γ1_0 := M.get_slice_index_or_break_match (| γ, 0 |) in
                          let γ1_rest := M.get_slice_rest_or_break_match (| γ, 1, 0 |) in
                          Value.Tuple []))
                    ],
                    M.closure
                      (fun γ =>
                        ltac:(M.monadic
                          match γ with
                          | [] =>
                            M.alloc (|
                              M.call_closure (|
                                M.get_function (|
                                  "move_core_types::identifier::all_bytes_valid",
                                  []
                                |),
                                [ M.read (| b |); Value.Integer Integer.Usize 1 ]
                              |)
                            |)
                          | _ => M.impossible (||)
                          end))
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let γ := M.read (| γ |) in
                  let γ1_0 := M.get_slice_index_or_break_match (| γ, 0 |) in
                  let γ1_rest := M.get_slice_rest_or_break_match (| γ, 1, 0 |) in
                  let _ :=
                    M.is_constant_or_break_match (|
                      M.read (| γ1_0 |),
                      Value.Integer Integer.U8 95
                    |) in
                  let γ :=
                    M.alloc (|
                      BinOp.Pure.gt
                        (M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply (Ty.path "slice") [ Ty.path "u8" ],
                            "len",
                            []
                          |),
                          [ M.read (| b |) ]
                        |))
                        (Value.Integer Integer.Usize 1)
                    |) in
                  let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.call_closure (|
                      M.get_function (| "move_core_types::identifier::all_bytes_valid", [] |),
                      [ M.read (| b |); Value.Integer Integer.Usize 1 ]
                    |)
                  |)));
              fun γ => ltac:(M.monadic (M.alloc (| Value.Bool false |)))
            ]
          |)
        |)))
    | _, _ => M.impossible
    end.
  
  (* StructTuple
    {
      name := "Identifier";
      ty_params := [];
      fields :=
        [ Ty.apply (Ty.path "alloc::boxed::Box") [ Ty.path "str"; Ty.path "alloc::alloc::Global" ]
        ];
    } *)
  
  Module Impl_core_clone_Clone_for_move_core_types_identifier_Identifier.
    Definition Self : Ty.t := Ty.path "move_core_types::identifier::Identifier".
    
    (* Clone *)
    Definition clone (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.StructTuple
            "move_core_types::identifier::Identifier"
            [
              M.call_closure (|
                M.get_trait_method (|
                  "core::clone::Clone",
                  Ty.apply
                    (Ty.path "alloc::boxed::Box")
                    [ Ty.path "str"; Ty.path "alloc::alloc::Global" ],
                  [],
                  "clone",
                  []
                |),
                [
                  M.get_struct_tuple_field
                    (M.read (| self |))
                    "move_core_types::identifier::Identifier"
                    0
                ]
              |)
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_move_core_types_identifier_Identifier.
  
  Module Impl_core_fmt_Debug_for_move_core_types_identifier_Identifier.
    Definition Self : Ty.t := Ty.path "move_core_types::identifier::Identifier".
    
    (* Debug *)
    Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.path "core::fmt::Formatter",
              "debug_tuple_field1_finish",
              []
            |),
            [
              M.read (| f |);
              M.read (| mk_str "Identifier" |);
              (* Unsize *)
              M.pointer_coercion
                (M.alloc (|
                  M.get_struct_tuple_field
                    (M.read (| self |))
                    "move_core_types::identifier::Identifier"
                    0
                |))
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_move_core_types_identifier_Identifier.
  
  Module Impl_core_marker_StructuralEq_for_move_core_types_identifier_Identifier.
    Definition Self : Ty.t := Ty.path "move_core_types::identifier::Identifier".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralEq_for_move_core_types_identifier_Identifier.
  
  Module Impl_core_cmp_Eq_for_move_core_types_identifier_Identifier.
    Definition Self : Ty.t := Ty.path "move_core_types::identifier::Identifier".
    
    (* Eq *)
    Definition assert_receiver_is_total_eq (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Value.DeclaredButUndefined,
              [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_move_core_types_identifier_Identifier.
  
  Module Impl_core_hash_Hash_for_move_core_types_identifier_Identifier.
    Definition Self : Ty.t := Ty.path "move_core_types::identifier::Identifier".
    
    (* Hash *)
    Definition hash (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ __H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let state := M.alloc (| state |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::hash::Hash",
              Ty.apply
                (Ty.path "alloc::boxed::Box")
                [ Ty.path "str"; Ty.path "alloc::alloc::Global" ],
              [],
              "hash",
              [ __H ]
            |),
            [
              M.get_struct_tuple_field
                (M.read (| self |))
                "move_core_types::identifier::Identifier"
                0;
              M.read (| state |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::hash::Hash"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("hash", InstanceField.Method hash) ].
  End Impl_core_hash_Hash_for_move_core_types_identifier_Identifier.
  
  Module Impl_core_cmp_Ord_for_move_core_types_identifier_Identifier.
    Definition Self : Ty.t := Ty.path "move_core_types::identifier::Identifier".
    
    (* Ord *)
    Definition cmp (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::cmp::Ord",
              Ty.apply
                (Ty.path "alloc::boxed::Box")
                [ Ty.path "str"; Ty.path "alloc::alloc::Global" ],
              [],
              "cmp",
              []
            |),
            [
              M.get_struct_tuple_field
                (M.read (| self |))
                "move_core_types::identifier::Identifier"
                0;
              M.get_struct_tuple_field
                (M.read (| other |))
                "move_core_types::identifier::Identifier"
                0
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Ord"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("cmp", InstanceField.Method cmp) ].
  End Impl_core_cmp_Ord_for_move_core_types_identifier_Identifier.
  
  Module Impl_core_marker_StructuralPartialEq_for_move_core_types_identifier_Identifier.
    Definition Self : Ty.t := Ty.path "move_core_types::identifier::Identifier".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_move_core_types_identifier_Identifier.
  
  Module Impl_core_cmp_PartialEq_for_move_core_types_identifier_Identifier.
    Definition Self : Ty.t := Ty.path "move_core_types::identifier::Identifier".
    
    (* PartialEq *)
    Definition eq (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::cmp::PartialEq",
              Ty.apply
                (Ty.path "alloc::boxed::Box")
                [ Ty.path "str"; Ty.path "alloc::alloc::Global" ],
              [
                Ty.apply
                  (Ty.path "alloc::boxed::Box")
                  [ Ty.path "str"; Ty.path "alloc::alloc::Global" ]
              ],
              "eq",
              []
            |),
            [
              M.get_struct_tuple_field
                (M.read (| self |))
                "move_core_types::identifier::Identifier"
                0;
              M.get_struct_tuple_field
                (M.read (| other |))
                "move_core_types::identifier::Identifier"
                0
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_for_move_core_types_identifier_Identifier.
  
  Module Impl_core_cmp_PartialOrd_for_move_core_types_identifier_Identifier.
    Definition Self : Ty.t := Ty.path "move_core_types::identifier::Identifier".
    
    (* PartialOrd *)
    Definition partial_cmp (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::cmp::PartialOrd",
              Ty.apply
                (Ty.path "alloc::boxed::Box")
                [ Ty.path "str"; Ty.path "alloc::alloc::Global" ],
              [
                Ty.apply
                  (Ty.path "alloc::boxed::Box")
                  [ Ty.path "str"; Ty.path "alloc::alloc::Global" ]
              ],
              "partial_cmp",
              []
            |),
            [
              M.get_struct_tuple_field
                (M.read (| self |))
                "move_core_types::identifier::Identifier"
                0;
              M.get_struct_tuple_field
                (M.read (| other |))
                "move_core_types::identifier::Identifier"
                0
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialOrd"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("partial_cmp", InstanceField.Method partial_cmp) ].
  End Impl_core_cmp_PartialOrd_for_move_core_types_identifier_Identifier.
  
  Module underscore.
    Module Impl_serde_ser_Serialize_for_move_core_types_identifier_Identifier.
      Definition Self : Ty.t := Ty.path "move_core_types::identifier::Identifier".
      
      (* Serialize *)
      Definition serialize (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ __S ], [ self; __serializer ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let __serializer := M.alloc (| __serializer |) in
            M.call_closure (|
              M.get_trait_method (|
                "serde::ser::Serializer",
                __S,
                [],
                "serialize_newtype_struct",
                [
                  Ty.apply
                    (Ty.path "alloc::boxed::Box")
                    [ Ty.path "str"; Ty.path "alloc::alloc::Global" ]
                ]
              |),
              [
                M.read (| __serializer |);
                M.read (| mk_str "Identifier" |);
                M.get_struct_tuple_field
                  (M.read (| self |))
                  "move_core_types::identifier::Identifier"
                  0
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "serde::ser::Serialize"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("serialize", InstanceField.Method serialize) ].
    End Impl_serde_ser_Serialize_for_move_core_types_identifier_Identifier.
  End underscore.
  
  Module Wrap_underscore_2.
  Module underscore.
    Module Impl_serde_de_Deserialize_for_move_core_types_identifier_Identifier.
      Definition Self : Ty.t := Ty.path "move_core_types::identifier::Identifier".
      
      (* Deserialize *)
      Definition deserialize (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ __D ], [ __deserializer ] =>
          ltac:(M.monadic
            (let __deserializer := M.alloc (| __deserializer |) in
            M.call_closure (|
              M.get_trait_method (|
                "serde::de::Deserializer",
                __D,
                [],
                "deserialize_newtype_struct",
                [ Ty.path "move_core_types::identifier::_'2::deserialize::__Visitor" ]
              |),
              [
                M.read (| __deserializer |);
                M.read (| mk_str "Identifier" |);
                Value.StructRecord
                  "move_core_types::identifier::_'2::deserialize::__Visitor"
                  [
                    ("marker", Value.StructTuple "core::marker::PhantomData" []);
                    ("lifetime", Value.StructTuple "core::marker::PhantomData" [])
                  ]
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "serde::de::Deserialize"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("deserialize", InstanceField.Method deserialize) ].
    End Impl_serde_de_Deserialize_for_move_core_types_identifier_Identifier.
  End underscore.
  End Wrap_underscore_2.
  Import Wrap_underscore_2.
  
  Module Impl_move_core_types_identifier_Identifier.
    Definition Self : Ty.t := Ty.path "move_core_types::identifier::Identifier".
    
    (*
        pub fn new(s: impl Into<Box<str>>) -> Result<Self> {
            let s = s.into();
            if Self::is_valid(&s) {
                Ok(Self(s))
            } else {
                bail!("Invalid identifier '{}'", s);
            }
        }
    *)
    Definition new (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ impl_Into_Box_str__ ], [ s ] =>
        ltac:(M.monadic
          (let s := M.alloc (| s |) in
          M.read (|
            let s :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "core::convert::Into",
                    impl_Into_Box_str__,
                    [
                      Ty.apply
                        (Ty.path "alloc::boxed::Box")
                        [ Ty.path "str"; Ty.path "alloc::alloc::Global" ]
                    ],
                    "into",
                    []
                  |),
                  [ M.read (| s |) ]
                |)
              |) in
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "move_core_types::identifier::Identifier",
                              "is_valid",
                              [
                                Ty.apply
                                  (Ty.path "&")
                                  [
                                    Ty.apply
                                      (Ty.path "alloc::boxed::Box")
                                      [ Ty.path "str"; Ty.path "alloc::alloc::Global" ]
                                  ]
                              ]
                            |),
                            [ s ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::identifier::Identifier"
                            [ M.read (| s |) ]
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.never_to_any (|
                        M.read (|
                          M.return_ (|
                            Value.StructTuple
                              "core::result::Result::Err"
                              [
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.path "anyhow::Error",
                                    "msg",
                                    [ Ty.path "alloc::string::String" ]
                                  |),
                                  [
                                    M.read (|
                                      let res :=
                                        M.alloc (|
                                          M.call_closure (|
                                            M.get_function (| "alloc::fmt::format", [] |),
                                            [
                                              M.call_closure (|
                                                M.get_associated_function (|
                                                  Ty.path "core::fmt::Arguments",
                                                  "new_v1",
                                                  []
                                                |),
                                                [
                                                  (* Unsize *)
                                                  M.pointer_coercion
                                                    (M.alloc (|
                                                      Value.Array
                                                        [
                                                          M.read (|
                                                            mk_str "Invalid identifier '"
                                                          |);
                                                          M.read (| mk_str "'" |)
                                                        ]
                                                    |));
                                                  (* Unsize *)
                                                  M.pointer_coercion
                                                    (M.alloc (|
                                                      Value.Array
                                                        [
                                                          M.call_closure (|
                                                            M.get_associated_function (|
                                                              Ty.path "core::fmt::rt::Argument",
                                                              "new_display",
                                                              [
                                                                Ty.apply
                                                                  (Ty.path "alloc::boxed::Box")
                                                                  [
                                                                    Ty.path "str";
                                                                    Ty.path "alloc::alloc::Global"
                                                                  ]
                                                              ]
                                                            |),
                                                            [ s ]
                                                          |)
                                                        ]
                                                    |))
                                                ]
                                              |)
                                            ]
                                          |)
                                        |) in
                                      res
                                    |)
                                  ]
                                |)
                              ]
                          |)
                        |)
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_new : M.IsAssociatedFunction Self "new" new.
    
    (*
        pub fn is_valid(s: impl AsRef<str>) -> bool {
            is_valid(s.as_ref())
        }
    *)
    Definition is_valid (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ impl_AsRef_str_ ], [ s ] =>
        ltac:(M.monadic
          (let s := M.alloc (| s |) in
          M.call_closure (|
            M.get_function (| "move_core_types::identifier::is_valid", [] |),
            [
              M.call_closure (|
                M.get_trait_method (|
                  "core::convert::AsRef",
                  impl_AsRef_str_,
                  [ Ty.path "str" ],
                  "as_ref",
                  []
                |),
                [ s ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_is_valid : M.IsAssociatedFunction Self "is_valid" is_valid.
    
    (*
        pub fn is_self(&self) -> bool {
            &*self.0 == "<SELF>"
        }
    *)
    Definition is_self (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::cmp::PartialEq",
              Ty.apply (Ty.path "&") [ Ty.path "str" ],
              [ Ty.apply (Ty.path "&") [ Ty.path "str" ] ],
              "eq",
              []
            |),
            [
              M.alloc (|
                M.read (|
                  M.get_struct_tuple_field
                    (M.read (| self |))
                    "move_core_types::identifier::Identifier"
                    0
                |)
              |);
              mk_str "<SELF>"
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_is_self : M.IsAssociatedFunction Self "is_self" is_self.
    
    (*
        pub fn from_utf8(vec: Vec<u8>) -> Result<Self> {
            let s = String::from_utf8(vec)?;
            Self::new(s)
        }
    *)
    Definition from_utf8 (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ vec ] =>
        ltac:(M.monadic
          (let vec := M.alloc (| vec |) in
          M.read (|
            let s :=
              M.copy (|
                M.match_operator (|
                  M.alloc (|
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::ops::try_trait::Try",
                        Ty.apply
                          (Ty.path "core::result::Result")
                          [ Ty.path "alloc::string::String"; Ty.path "alloc::string::FromUtf8Error"
                          ],
                        [],
                        "branch",
                        []
                      |),
                      [
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.path "alloc::string::String",
                            "from_utf8",
                            []
                          |),
                          [ M.read (| vec |) ]
                        |)
                      ]
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.get_struct_tuple_field_or_break_match (|
                            γ,
                            "core::ops::control_flow::ControlFlow::Break",
                            0
                          |) in
                        let residual := M.copy (| γ0_0 |) in
                        M.alloc (|
                          M.never_to_any (|
                            M.read (|
                              M.return_ (|
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::ops::try_trait::FromResidual",
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      [
                                        Ty.path "move_core_types::identifier::Identifier";
                                        Ty.path "anyhow::Error"
                                      ],
                                    [
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        [
                                          Ty.path "core::convert::Infallible";
                                          Ty.path "alloc::string::FromUtf8Error"
                                        ]
                                    ],
                                    "from_residual",
                                    []
                                  |),
                                  [ M.read (| residual |) ]
                                |)
                              |)
                            |)
                          |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.get_struct_tuple_field_or_break_match (|
                            γ,
                            "core::ops::control_flow::ControlFlow::Continue",
                            0
                          |) in
                        let val := M.copy (| γ0_0 |) in
                        val))
                  ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.path "move_core_types::identifier::Identifier",
                  "new",
                  [ Ty.path "alloc::string::String" ]
                |),
                [ M.read (| s |) ]
              |)
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_from_utf8 : M.IsAssociatedFunction Self "from_utf8" from_utf8.
    
    (*
        pub fn as_ident_str(&self) -> &IdentStr {
            self
        }
    *)
    Definition as_ident_str (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::ops::deref::Deref",
              Ty.path "move_core_types::identifier::Identifier",
              [],
              "deref",
              []
            |),
            [ M.read (| self |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_as_ident_str : M.IsAssociatedFunction Self "as_ident_str" as_ident_str.
    
    (*
        pub fn into_string(self) -> String {
            self.0.into()
        }
    *)
    Definition into_string (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::convert::Into",
              Ty.apply
                (Ty.path "alloc::boxed::Box")
                [ Ty.path "str"; Ty.path "alloc::alloc::Global" ],
              [ Ty.path "alloc::string::String" ],
              "into",
              []
            |),
            [ M.read (| M.get_struct_tuple_field self "move_core_types::identifier::Identifier" 0 |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_into_string : M.IsAssociatedFunction Self "into_string" into_string.
    
    (*
        pub fn into_bytes(self) -> Vec<u8> {
            self.into_string().into_bytes()
        }
    *)
    Definition into_bytes (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "alloc::string::String", "into_bytes", [] |),
            [
              M.call_closure (|
                M.get_associated_function (|
                  Ty.path "move_core_types::identifier::Identifier",
                  "into_string",
                  []
                |),
                [ M.read (| self |) ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_into_bytes : M.IsAssociatedFunction Self "into_bytes" into_bytes.
  End Impl_move_core_types_identifier_Identifier.
  
  Module Impl_core_str_traits_FromStr_for_move_core_types_identifier_Identifier.
    Definition Self : Ty.t := Ty.path "move_core_types::identifier::Identifier".
    
    (*     type Err = anyhow::Error; *)
    Definition _Err : Ty.t := Ty.path "anyhow::Error".
    
    (*
        fn from_str(data: &str) -> Result<Self> {
            Self::new(data)
        }
    *)
    Definition from_str (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ data ] =>
        ltac:(M.monadic
          (let data := M.alloc (| data |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.path "move_core_types::identifier::Identifier",
              "new",
              [ Ty.apply (Ty.path "&") [ Ty.path "str" ] ]
            |),
            [ M.read (| data |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::str::traits::FromStr"
        Self
        (* Trait polymorphic types *) []
        (* Instance *)
        [ ("Err", InstanceField.Ty _Err); ("from_str", InstanceField.Method from_str) ].
  End Impl_core_str_traits_FromStr_for_move_core_types_identifier_Identifier.
  
  Module Impl_core_convert_From_ref__move_core_types_identifier_IdentStr_for_move_core_types_identifier_Identifier.
    Definition Self : Ty.t := Ty.path "move_core_types::identifier::Identifier".
    
    (*
        fn from(ident_str: &IdentStr) -> Self {
            ident_str.to_owned()
        }
    *)
    Definition from (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ ident_str ] =>
        ltac:(M.monadic
          (let ident_str := M.alloc (| ident_str |) in
          M.call_closure (|
            M.get_trait_method (|
              "alloc::borrow::ToOwned",
              Ty.path "move_core_types::identifier::IdentStr",
              [],
              "to_owned",
              []
            |),
            [ M.read (| ident_str |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::convert::From"
        Self
        (* Trait polymorphic types *)
        [ (* T *) Ty.apply (Ty.path "&") [ Ty.path "move_core_types::identifier::IdentStr" ] ]
        (* Instance *) [ ("from", InstanceField.Method from) ].
  End Impl_core_convert_From_ref__move_core_types_identifier_IdentStr_for_move_core_types_identifier_Identifier.
  
  Module Impl_core_convert_AsRef_move_core_types_identifier_IdentStr_for_move_core_types_identifier_Identifier.
    Definition Self : Ty.t := Ty.path "move_core_types::identifier::Identifier".
    
    (*
        fn as_ref(&self) -> &IdentStr {
            self
        }
    *)
    Definition as_ref (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::ops::deref::Deref",
              Ty.path "move_core_types::identifier::Identifier",
              [],
              "deref",
              []
            |),
            [ M.read (| self |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::convert::AsRef"
        Self
        (* Trait polymorphic types *) [ (* T *) Ty.path "move_core_types::identifier::IdentStr" ]
        (* Instance *) [ ("as_ref", InstanceField.Method as_ref) ].
  End Impl_core_convert_AsRef_move_core_types_identifier_IdentStr_for_move_core_types_identifier_Identifier.
  
  Module Impl_core_ops_deref_Deref_for_move_core_types_identifier_Identifier.
    Definition Self : Ty.t := Ty.path "move_core_types::identifier::Identifier".
    
    (*     type Target = IdentStr; *)
    Definition _Target : Ty.t := Ty.path "move_core_types::identifier::IdentStr".
    
    (*
        fn deref(&self) -> &IdentStr {
            // Identifier and IdentStr maintain the same invariants, so it is safe to
            // convert.
            IdentStr::ref_cast(&self.0)
        }
    *)
    Definition deref (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_trait_method (|
              "ref_cast::RefCast",
              Ty.path "move_core_types::identifier::IdentStr",
              [],
              "ref_cast",
              []
            |),
            [
              M.read (|
                M.get_struct_tuple_field
                  (M.read (| self |))
                  "move_core_types::identifier::Identifier"
                  0
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::ops::deref::Deref"
        Self
        (* Trait polymorphic types *) []
        (* Instance *)
        [ ("Target", InstanceField.Ty _Target); ("deref", InstanceField.Method deref) ].
  End Impl_core_ops_deref_Deref_for_move_core_types_identifier_Identifier.
  
  Module Impl_core_fmt_Display_for_move_core_types_identifier_Identifier.
    Definition Self : Ty.t := Ty.path "move_core_types::identifier::Identifier".
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            write!(f, "{}", &self.0)
        }
    *)
    Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_fmt", [] |),
            [
              M.read (| f |);
              M.call_closure (|
                M.get_associated_function (| Ty.path "core::fmt::Arguments", "new_v1", [] |),
                [
                  (* Unsize *)
                  M.pointer_coercion (M.alloc (| Value.Array [ M.read (| mk_str "" |) ] |));
                  (* Unsize *)
                  M.pointer_coercion
                    (M.alloc (|
                      Value.Array
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::rt::Argument",
                              "new_display",
                              [
                                Ty.apply
                                  (Ty.path "&")
                                  [
                                    Ty.apply
                                      (Ty.path "alloc::boxed::Box")
                                      [ Ty.path "str"; Ty.path "alloc::alloc::Global" ]
                                  ]
                              ]
                            |),
                            [
                              M.alloc (|
                                M.get_struct_tuple_field
                                  (M.read (| self |))
                                  "move_core_types::identifier::Identifier"
                                  0
                              |)
                            ]
                          |)
                        ]
                    |))
                ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Display"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Display_for_move_core_types_identifier_Identifier.
  
  (* StructTuple
    {
      name := "IdentStr";
      ty_params := [];
      fields := [ Ty.path "str" ];
    } *)
  
  Module Impl_core_fmt_Debug_for_move_core_types_identifier_IdentStr.
    Definition Self : Ty.t := Ty.path "move_core_types::identifier::IdentStr".
    
    (* Debug *)
    Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.path "core::fmt::Formatter",
              "debug_tuple_field1_finish",
              []
            |),
            [
              M.read (| f |);
              M.read (| mk_str "IdentStr" |);
              (* Unsize *)
              M.pointer_coercion
                (M.alloc (|
                  M.get_struct_tuple_field
                    (M.read (| self |))
                    "move_core_types::identifier::IdentStr"
                    0
                |))
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_move_core_types_identifier_IdentStr.
  
  Module Impl_core_marker_StructuralEq_for_move_core_types_identifier_IdentStr.
    Definition Self : Ty.t := Ty.path "move_core_types::identifier::IdentStr".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralEq_for_move_core_types_identifier_IdentStr.
  
  Module Impl_core_cmp_Eq_for_move_core_types_identifier_IdentStr.
    Definition Self : Ty.t := Ty.path "move_core_types::identifier::IdentStr".
    
    (* Eq *)
    Definition assert_receiver_is_total_eq (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Value.DeclaredButUndefined,
              [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_move_core_types_identifier_IdentStr.
  
  Module Impl_core_hash_Hash_for_move_core_types_identifier_IdentStr.
    Definition Self : Ty.t := Ty.path "move_core_types::identifier::IdentStr".
    
    (* Hash *)
    Definition hash (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ __H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let state := M.alloc (| state |) in
          M.call_closure (|
            M.get_trait_method (| "core::hash::Hash", Ty.path "str", [], "hash", [ __H ] |),
            [
              M.get_struct_tuple_field
                (M.read (| self |))
                "move_core_types::identifier::IdentStr"
                0;
              M.read (| state |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::hash::Hash"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("hash", InstanceField.Method hash) ].
  End Impl_core_hash_Hash_for_move_core_types_identifier_IdentStr.
  
  Module Impl_core_cmp_Ord_for_move_core_types_identifier_IdentStr.
    Definition Self : Ty.t := Ty.path "move_core_types::identifier::IdentStr".
    
    (* Ord *)
    Definition cmp (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_trait_method (| "core::cmp::Ord", Ty.path "str", [], "cmp", [] |),
            [
              M.get_struct_tuple_field
                (M.read (| self |))
                "move_core_types::identifier::IdentStr"
                0;
              M.get_struct_tuple_field
                (M.read (| other |))
                "move_core_types::identifier::IdentStr"
                0
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Ord"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("cmp", InstanceField.Method cmp) ].
  End Impl_core_cmp_Ord_for_move_core_types_identifier_IdentStr.
  
  Module Impl_core_marker_StructuralPartialEq_for_move_core_types_identifier_IdentStr.
    Definition Self : Ty.t := Ty.path "move_core_types::identifier::IdentStr".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_move_core_types_identifier_IdentStr.
  
  Module Impl_core_cmp_PartialEq_for_move_core_types_identifier_IdentStr.
    Definition Self : Ty.t := Ty.path "move_core_types::identifier::IdentStr".
    
    (* PartialEq *)
    Definition eq (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::cmp::PartialEq",
              Ty.path "str",
              [ Ty.path "str" ],
              "eq",
              []
            |),
            [
              M.get_struct_tuple_field
                (M.read (| self |))
                "move_core_types::identifier::IdentStr"
                0;
              M.get_struct_tuple_field
                (M.read (| other |))
                "move_core_types::identifier::IdentStr"
                0
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_for_move_core_types_identifier_IdentStr.
  
  Module Impl_core_cmp_PartialOrd_for_move_core_types_identifier_IdentStr.
    Definition Self : Ty.t := Ty.path "move_core_types::identifier::IdentStr".
    
    (* PartialOrd *)
    Definition partial_cmp (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::cmp::PartialOrd",
              Ty.path "str",
              [ Ty.path "str" ],
              "partial_cmp",
              []
            |),
            [
              M.get_struct_tuple_field
                (M.read (| self |))
                "move_core_types::identifier::IdentStr"
                0;
              M.get_struct_tuple_field
                (M.read (| other |))
                "move_core_types::identifier::IdentStr"
                0
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialOrd"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("partial_cmp", InstanceField.Method partial_cmp) ].
  End Impl_core_cmp_PartialOrd_for_move_core_types_identifier_IdentStr.
  
  Module Impl_ref_cast_RefCast_for_move_core_types_identifier_IdentStr.
    Definition Self : Ty.t := Ty.path "move_core_types::identifier::IdentStr".
    
    (* RefCast *)
    Definition _From : Ty.t := Ty.path "str".
    
    (* RefCast *)
    Definition ref_cast (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ _from ] =>
        ltac:(M.monadic
          (let _from := M.alloc (| _from |) in
          M.read (|
            let _ :=
              let _ :=
                M.alloc (|
                  M.call_closure (|
                    M.get_function (|
                      "ref_cast::layout::assert_layout",
                      [ Ty.path "move_core_types::identifier::IdentStr"; Ty.path "str" ]
                    |),
                    [
                      M.read (| mk_str "IdentStr" |);
                      M.read (| M.get_constant (| "ref_cast::layout::LayoutUnsized::SIZE" |) |);
                      M.read (| M.get_constant (| "ref_cast::layout::LayoutUnsized::SIZE" |) |);
                      M.read (| M.get_constant (| "ref_cast::layout::LayoutUnsized::ALIGN" |) |);
                      M.read (| M.get_constant (| "ref_cast::layout::LayoutUnsized::ALIGN" |) |)
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |) in
            M.alloc (| M.rust_cast (M.read (| M.use (M.alloc (| M.read (| _from |) |)) |)) |)
          |)))
      | _, _ => M.impossible
      end.
    
    (* RefCast *)
    Definition ref_cast_mut (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ _from ] =>
        ltac:(M.monadic
          (let _from := M.alloc (| _from |) in
          M.read (|
            let _ :=
              let _ :=
                M.alloc (|
                  M.call_closure (|
                    M.get_function (|
                      "ref_cast::layout::assert_layout",
                      [ Ty.path "move_core_types::identifier::IdentStr"; Ty.path "str" ]
                    |),
                    [
                      M.read (| mk_str "IdentStr" |);
                      M.read (| M.get_constant (| "ref_cast::layout::LayoutUnsized::SIZE" |) |);
                      M.read (| M.get_constant (| "ref_cast::layout::LayoutUnsized::SIZE" |) |);
                      M.read (| M.get_constant (| "ref_cast::layout::LayoutUnsized::ALIGN" |) |);
                      M.read (| M.get_constant (| "ref_cast::layout::LayoutUnsized::ALIGN" |) |)
                    ]
                  |)
                |) in
              M.alloc (| Value.Tuple [] |) in
            M.alloc (| M.rust_cast (M.read (| M.use (M.alloc (| M.read (| _from |) |)) |)) |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "ref_cast::RefCast"
        Self
        (* Trait polymorphic types *) []
        (* Instance *)
        [
          ("From", InstanceField.Ty _From);
          ("ref_cast", InstanceField.Method ref_cast);
          ("ref_cast_mut", InstanceField.Method ref_cast_mut)
        ].
  End Impl_ref_cast_RefCast_for_move_core_types_identifier_IdentStr.
  
  Module Impl_move_core_types_identifier_IdentStr.
    Definition Self : Ty.t := Ty.path "move_core_types::identifier::IdentStr".
    
    (*
        pub fn new(s: &str) -> Result<&IdentStr> {
            if Self::is_valid(s) {
                Ok(IdentStr::ref_cast(s))
            } else {
                bail!("Invalid identifier '{}'", s);
            }
        }
    *)
    Definition new (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ s ] =>
        ltac:(M.monadic
          (let s := M.alloc (| s |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "move_core_types::identifier::IdentStr",
                              "is_valid",
                              [ Ty.apply (Ty.path "&") [ Ty.path "str" ] ]
                            |),
                            [ M.read (| s |) ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "ref_cast::RefCast",
                              Ty.path "move_core_types::identifier::IdentStr",
                              [],
                              "ref_cast",
                              []
                            |),
                            [ M.read (| s |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.never_to_any (|
                        M.read (|
                          M.return_ (|
                            Value.StructTuple
                              "core::result::Result::Err"
                              [
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.path "anyhow::Error",
                                    "msg",
                                    [ Ty.path "alloc::string::String" ]
                                  |),
                                  [
                                    M.read (|
                                      let res :=
                                        M.alloc (|
                                          M.call_closure (|
                                            M.get_function (| "alloc::fmt::format", [] |),
                                            [
                                              M.call_closure (|
                                                M.get_associated_function (|
                                                  Ty.path "core::fmt::Arguments",
                                                  "new_v1",
                                                  []
                                                |),
                                                [
                                                  (* Unsize *)
                                                  M.pointer_coercion
                                                    (M.alloc (|
                                                      Value.Array
                                                        [
                                                          M.read (|
                                                            mk_str "Invalid identifier '"
                                                          |);
                                                          M.read (| mk_str "'" |)
                                                        ]
                                                    |));
                                                  (* Unsize *)
                                                  M.pointer_coercion
                                                    (M.alloc (|
                                                      Value.Array
                                                        [
                                                          M.call_closure (|
                                                            M.get_associated_function (|
                                                              Ty.path "core::fmt::rt::Argument",
                                                              "new_display",
                                                              [
                                                                Ty.apply
                                                                  (Ty.path "&")
                                                                  [ Ty.path "str" ]
                                                              ]
                                                            |),
                                                            [ s ]
                                                          |)
                                                        ]
                                                    |))
                                                ]
                                              |)
                                            ]
                                          |)
                                        |) in
                                      res
                                    |)
                                  ]
                                |)
                              ]
                          |)
                        |)
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_new : M.IsAssociatedFunction Self "new" new.
    
    (*
        pub fn is_valid(s: impl AsRef<str>) -> bool {
            is_valid(s.as_ref())
        }
    *)
    Definition is_valid (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ impl_AsRef_str_ ], [ s ] =>
        ltac:(M.monadic
          (let s := M.alloc (| s |) in
          M.call_closure (|
            M.get_function (| "move_core_types::identifier::is_valid", [] |),
            [
              M.call_closure (|
                M.get_trait_method (|
                  "core::convert::AsRef",
                  impl_AsRef_str_,
                  [ Ty.path "str" ],
                  "as_ref",
                  []
                |),
                [ s ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_is_valid : M.IsAssociatedFunction Self "is_valid" is_valid.
    
    (*
        pub fn len(&self) -> usize {
            self.0.len()
        }
    *)
    Definition len (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "str", "len", [] |),
            [ M.get_struct_tuple_field (M.read (| self |)) "move_core_types::identifier::IdentStr" 0
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_len : M.IsAssociatedFunction Self "len" len.
    
    (*
        pub fn is_empty(&self) -> bool {
            self.0.is_empty()
        }
    *)
    Definition is_empty (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "str", "is_empty", [] |),
            [ M.get_struct_tuple_field (M.read (| self |)) "move_core_types::identifier::IdentStr" 0
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_is_empty : M.IsAssociatedFunction Self "is_empty" is_empty.
    
    (*
        pub fn as_str(&self) -> &str {
            &self.0
        }
    *)
    Definition as_str (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.get_struct_tuple_field (M.read (| self |)) "move_core_types::identifier::IdentStr" 0))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_as_str : M.IsAssociatedFunction Self "as_str" as_str.
    
    (*
        pub fn as_bytes(&self) -> &[u8] {
            self.0.as_bytes()
        }
    *)
    Definition as_bytes (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "str", "as_bytes", [] |),
            [ M.get_struct_tuple_field (M.read (| self |)) "move_core_types::identifier::IdentStr" 0
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_as_bytes : M.IsAssociatedFunction Self "as_bytes" as_bytes.
  End Impl_move_core_types_identifier_IdentStr.
  
  Module Impl_core_borrow_Borrow_move_core_types_identifier_IdentStr_for_move_core_types_identifier_Identifier.
    Definition Self : Ty.t := Ty.path "move_core_types::identifier::Identifier".
    
    (*
        fn borrow(&self) -> &IdentStr {
            self
        }
    *)
    Definition borrow (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::ops::deref::Deref",
              Ty.path "move_core_types::identifier::Identifier",
              [],
              "deref",
              []
            |),
            [ M.read (| self |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::borrow::Borrow"
        Self
        (* Trait polymorphic types *)
        [ (* Borrowed *) Ty.path "move_core_types::identifier::IdentStr" ]
        (* Instance *) [ ("borrow", InstanceField.Method borrow) ].
  End Impl_core_borrow_Borrow_move_core_types_identifier_IdentStr_for_move_core_types_identifier_Identifier.
  
  Module Impl_alloc_borrow_ToOwned_for_move_core_types_identifier_IdentStr.
    Definition Self : Ty.t := Ty.path "move_core_types::identifier::IdentStr".
    
    (*     type Owned = Identifier; *)
    Definition _Owned : Ty.t := Ty.path "move_core_types::identifier::Identifier".
    
    (*
        fn to_owned(&self) -> Identifier {
            Identifier(self.0.into())
        }
    *)
    Definition to_owned (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.StructTuple
            "move_core_types::identifier::Identifier"
            [
              M.call_closure (|
                M.get_trait_method (|
                  "core::convert::Into",
                  Ty.apply (Ty.path "&") [ Ty.path "str" ],
                  [
                    Ty.apply
                      (Ty.path "alloc::boxed::Box")
                      [ Ty.path "str"; Ty.path "alloc::alloc::Global" ]
                  ],
                  "into",
                  []
                |),
                [
                  M.get_struct_tuple_field
                    (M.read (| self |))
                    "move_core_types::identifier::IdentStr"
                    0
                ]
              |)
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "alloc::borrow::ToOwned"
        Self
        (* Trait polymorphic types *) []
        (* Instance *)
        [ ("Owned", InstanceField.Ty _Owned); ("to_owned", InstanceField.Method to_owned) ].
  End Impl_alloc_borrow_ToOwned_for_move_core_types_identifier_IdentStr.
  
  Module Impl_core_fmt_Display_for_move_core_types_identifier_IdentStr.
    Definition Self : Ty.t := Ty.path "move_core_types::identifier::IdentStr".
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            write!(f, "{}", &self.0)
        }
    *)
    Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_fmt", [] |),
            [
              M.read (| f |);
              M.call_closure (|
                M.get_associated_function (| Ty.path "core::fmt::Arguments", "new_v1", [] |),
                [
                  (* Unsize *)
                  M.pointer_coercion (M.alloc (| Value.Array [ M.read (| mk_str "" |) ] |));
                  (* Unsize *)
                  M.pointer_coercion
                    (M.alloc (|
                      Value.Array
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::rt::Argument",
                              "new_display",
                              [ Ty.apply (Ty.path "&") [ Ty.path "str" ] ]
                            |),
                            [
                              M.alloc (|
                                M.get_struct_tuple_field
                                  (M.read (| self |))
                                  "move_core_types::identifier::IdentStr"
                                  0
                              |)
                            ]
                          |)
                        ]
                    |))
                ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Display"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Display_for_move_core_types_identifier_IdentStr.
  
  Definition underscore : Value.t :=
    M.run
      ltac:(M.monadic
        (M.alloc (|
          (* ClosureFnPointer(Normal) *)
          M.pointer_coercion
            (M.closure
              (fun γ =>
                ltac:(M.monadic
                  match γ with
                  | [ α0 ] =>
                    M.match_operator (|
                      M.alloc (| α0 |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (M.read (|
                              let _ :=
                                M.alloc (|
                                  M.call_closure (|
                                    M.read (|
                                      (* Unimplemented parent_kind *) M.alloc (| Value.Tuple [] |)
                                    |),
                                    []
                                  |)
                                |) in
                              M.alloc (| Value.Tuple [] |)
                            |)))
                      ]
                    |)
                  | _ => M.impossible (||)
                  end)))
        |))).
End identifier.

Module language_storage.
  Definition value_CODE_TAG : Value.t :=
    M.run ltac:(M.monadic (M.alloc (| Value.Integer Integer.U8 0 |))).
  
  Definition value_RESOURCE_TAG : Value.t :=
    M.run ltac:(M.monadic (M.alloc (| Value.Integer Integer.U8 1 |))).
  
  Definition value_CORE_CODE_ADDRESS : Value.t :=
    M.run ltac:(M.monadic (M.get_constant (| "move_core_types::account_address::ONE" |))).
  
  (*
  Enum TypeTag
  {
    ty_params := [];
    variants :=
      [
        {
          name := "Bool";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "U8";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "U64";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "U128";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "Address";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "Signer";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "Vector";
          item :=
            StructTuple
              [
                Ty.apply
                  (Ty.path "alloc::boxed::Box")
                  [
                    Ty.path "move_core_types::language_storage::TypeTag";
                    Ty.path "alloc::alloc::Global"
                  ]
              ];
          discriminant := None;
        };
        {
          name := "Struct";
          item :=
            StructTuple
              [
                Ty.apply
                  (Ty.path "alloc::boxed::Box")
                  [
                    Ty.path "move_core_types::language_storage::StructTag";
                    Ty.path "alloc::alloc::Global"
                  ]
              ];
          discriminant := None;
        };
        {
          name := "U16";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "U32";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "U256";
          item := StructTuple [];
          discriminant := None;
        }
      ];
  }
  *)
  
  Module underscore.
    Module Impl_serde_ser_Serialize_for_move_core_types_language_storage_TypeTag.
      Definition Self : Ty.t := Ty.path "move_core_types::language_storage::TypeTag".
      
      (* Serialize *)
      Definition serialize (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ __S ], [ self; __serializer ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let __serializer := M.alloc (| __serializer |) in
            M.read (|
              M.match_operator (|
                M.read (| self |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "serde::ser::Serializer",
                            __S,
                            [],
                            "serialize_unit_variant",
                            []
                          |),
                          [
                            M.read (| __serializer |);
                            M.read (| mk_str "TypeTag" |);
                            Value.Integer Integer.U32 0;
                            M.read (| mk_str "bool" |)
                          ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "serde::ser::Serializer",
                            __S,
                            [],
                            "serialize_unit_variant",
                            []
                          |),
                          [
                            M.read (| __serializer |);
                            M.read (| mk_str "TypeTag" |);
                            Value.Integer Integer.U32 1;
                            M.read (| mk_str "u8" |)
                          ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "serde::ser::Serializer",
                            __S,
                            [],
                            "serialize_unit_variant",
                            []
                          |),
                          [
                            M.read (| __serializer |);
                            M.read (| mk_str "TypeTag" |);
                            Value.Integer Integer.U32 2;
                            M.read (| mk_str "u64" |)
                          ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "serde::ser::Serializer",
                            __S,
                            [],
                            "serialize_unit_variant",
                            []
                          |),
                          [
                            M.read (| __serializer |);
                            M.read (| mk_str "TypeTag" |);
                            Value.Integer Integer.U32 3;
                            M.read (| mk_str "u128" |)
                          ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "serde::ser::Serializer",
                            __S,
                            [],
                            "serialize_unit_variant",
                            []
                          |),
                          [
                            M.read (| __serializer |);
                            M.read (| mk_str "TypeTag" |);
                            Value.Integer Integer.U32 4;
                            M.read (| mk_str "address" |)
                          ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "serde::ser::Serializer",
                            __S,
                            [],
                            "serialize_unit_variant",
                            []
                          |),
                          [
                            M.read (| __serializer |);
                            M.read (| mk_str "TypeTag" |);
                            Value.Integer Integer.U32 5;
                            M.read (| mk_str "signer" |)
                          ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.get_struct_tuple_field_or_break_match (|
                          γ,
                          "move_core_types::language_storage::TypeTag::Vector",
                          0
                        |) in
                      let __field0 := M.alloc (| γ0_0 |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "serde::ser::Serializer",
                            __S,
                            [],
                            "serialize_newtype_variant",
                            [
                              Ty.apply
                                (Ty.path "alloc::boxed::Box")
                                [
                                  Ty.path "move_core_types::language_storage::TypeTag";
                                  Ty.path "alloc::alloc::Global"
                                ]
                            ]
                          |),
                          [
                            M.read (| __serializer |);
                            M.read (| mk_str "TypeTag" |);
                            Value.Integer Integer.U32 6;
                            M.read (| mk_str "vector" |);
                            M.read (| __field0 |)
                          ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.get_struct_tuple_field_or_break_match (|
                          γ,
                          "move_core_types::language_storage::TypeTag::Struct",
                          0
                        |) in
                      let __field0 := M.alloc (| γ0_0 |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "serde::ser::Serializer",
                            __S,
                            [],
                            "serialize_newtype_variant",
                            [
                              Ty.apply
                                (Ty.path "alloc::boxed::Box")
                                [
                                  Ty.path "move_core_types::language_storage::StructTag";
                                  Ty.path "alloc::alloc::Global"
                                ]
                            ]
                          |),
                          [
                            M.read (| __serializer |);
                            M.read (| mk_str "TypeTag" |);
                            Value.Integer Integer.U32 7;
                            M.read (| mk_str "struct" |);
                            M.read (| __field0 |)
                          ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "serde::ser::Serializer",
                            __S,
                            [],
                            "serialize_unit_variant",
                            []
                          |),
                          [
                            M.read (| __serializer |);
                            M.read (| mk_str "TypeTag" |);
                            Value.Integer Integer.U32 8;
                            M.read (| mk_str "u16" |)
                          ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "serde::ser::Serializer",
                            __S,
                            [],
                            "serialize_unit_variant",
                            []
                          |),
                          [
                            M.read (| __serializer |);
                            M.read (| mk_str "TypeTag" |);
                            Value.Integer Integer.U32 9;
                            M.read (| mk_str "u32" |)
                          ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "serde::ser::Serializer",
                            __S,
                            [],
                            "serialize_unit_variant",
                            []
                          |),
                          [
                            M.read (| __serializer |);
                            M.read (| mk_str "TypeTag" |);
                            Value.Integer Integer.U32 10;
                            M.read (| mk_str "u256" |)
                          ]
                        |)
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "serde::ser::Serialize"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("serialize", InstanceField.Method serialize) ].
    End Impl_serde_ser_Serialize_for_move_core_types_language_storage_TypeTag.
  End underscore.
  
  Module Wrap_underscore_2.
  Module underscore.
    Module Impl_serde_de_Deserialize_for_move_core_types_language_storage_TypeTag.
      Definition Self : Ty.t := Ty.path "move_core_types::language_storage::TypeTag".
      
      (* Deserialize *)
      Definition deserialize (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ __D ], [ __deserializer ] =>
          ltac:(M.monadic
            (let __deserializer := M.alloc (| __deserializer |) in
            M.call_closure (|
              M.get_trait_method (|
                "serde::de::Deserializer",
                __D,
                [],
                "deserialize_enum",
                [ Ty.path "move_core_types::language_storage::_'1::deserialize::__Visitor" ]
              |),
              [
                M.read (| __deserializer |);
                M.read (| mk_str "TypeTag" |);
                M.read (|
                  M.get_constant (|
                    "move_core_types::language_storage::_'1::deserialize::VARIANTS"
                  |)
                |);
                Value.StructRecord
                  "move_core_types::language_storage::_'1::deserialize::__Visitor"
                  [
                    ("marker", Value.StructTuple "core::marker::PhantomData" []);
                    ("lifetime", Value.StructTuple "core::marker::PhantomData" [])
                  ]
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "serde::de::Deserialize"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("deserialize", InstanceField.Method deserialize) ].
    End Impl_serde_de_Deserialize_for_move_core_types_language_storage_TypeTag.
  End underscore.
  End Wrap_underscore_2.
  Import Wrap_underscore_2.
  
  Module Impl_core_fmt_Debug_for_move_core_types_language_storage_TypeTag.
    Definition Self : Ty.t := Ty.path "move_core_types::language_storage::TypeTag".
    
    (* Debug *)
    Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| mk_str "Bool" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| mk_str "U8" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| mk_str "U64" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| mk_str "U128" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| mk_str "Address" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| mk_str "Signer" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::language_storage::TypeTag::Vector",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_tuple_field1_finish",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.read (| mk_str "Vector" |);
                          (* Unsize *) M.pointer_coercion __self_0
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::language_storage::TypeTag::Struct",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_tuple_field1_finish",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.read (| mk_str "Struct" |);
                          (* Unsize *) M.pointer_coercion __self_0
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| mk_str "U16" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| mk_str "U32" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| mk_str "U256" |) ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_move_core_types_language_storage_TypeTag.
  
  Module Impl_core_marker_StructuralPartialEq_for_move_core_types_language_storage_TypeTag.
    Definition Self : Ty.t := Ty.path "move_core_types::language_storage::TypeTag".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_move_core_types_language_storage_TypeTag.
  
  Module Impl_core_cmp_PartialEq_for_move_core_types_language_storage_TypeTag.
    Definition Self : Ty.t := Ty.path "move_core_types::language_storage::TypeTag".
    
    (* PartialEq *)
    Definition eq (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            let __self_tag :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [ Ty.path "move_core_types::language_storage::TypeTag" ]
                  |),
                  [ M.read (| self |) ]
                |)
              |) in
            let __arg1_tag :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [ Ty.path "move_core_types::language_storage::TypeTag" ]
                  |),
                  [ M.read (| other |) ]
                |)
              |) in
            M.alloc (|
              LogicalOp.and (|
                BinOp.Pure.eq (M.read (| __self_tag |)) (M.read (| __arg1_tag |)),
                ltac:(M.monadic
                  (M.read (|
                    M.match_operator (|
                      M.alloc (| Value.Tuple [ M.read (| self |); M.read (| other |) ] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.get_tuple_field γ 0 in
                            let γ0_1 := M.get_tuple_field γ 1 in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ0_0,
                                "move_core_types::language_storage::TypeTag::Vector",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ0_1,
                                "move_core_types::language_storage::TypeTag::Vector",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.apply
                                    (Ty.path "alloc::boxed::Box")
                                    [
                                      Ty.path "move_core_types::language_storage::TypeTag";
                                      Ty.path "alloc::alloc::Global"
                                    ],
                                  [
                                    Ty.apply
                                      (Ty.path "alloc::boxed::Box")
                                      [
                                        Ty.path "move_core_types::language_storage::TypeTag";
                                        Ty.path "alloc::alloc::Global"
                                      ]
                                  ],
                                  "eq",
                                  []
                                |),
                                [ M.read (| __self_0 |); M.read (| __arg1_0 |) ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.get_tuple_field γ 0 in
                            let γ0_1 := M.get_tuple_field γ 1 in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ0_0,
                                "move_core_types::language_storage::TypeTag::Struct",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ0_1,
                                "move_core_types::language_storage::TypeTag::Struct",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.apply
                                    (Ty.path "alloc::boxed::Box")
                                    [
                                      Ty.path "move_core_types::language_storage::StructTag";
                                      Ty.path "alloc::alloc::Global"
                                    ],
                                  [
                                    Ty.apply
                                      (Ty.path "alloc::boxed::Box")
                                      [
                                        Ty.path "move_core_types::language_storage::StructTag";
                                        Ty.path "alloc::alloc::Global"
                                      ]
                                  ],
                                  "eq",
                                  []
                                |),
                                [ M.read (| __self_0 |); M.read (| __arg1_0 |) ]
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Bool true |)))
                      ]
                    |)
                  |)))
              |)
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_for_move_core_types_language_storage_TypeTag.
  
  Module Impl_core_hash_Hash_for_move_core_types_language_storage_TypeTag.
    Definition Self : Ty.t := Ty.path "move_core_types::language_storage::TypeTag".
    
    (* Hash *)
    Definition hash (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ __H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let state := M.alloc (| state |) in
          M.read (|
            let __self_tag :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [ Ty.path "move_core_types::language_storage::TypeTag" ]
                  |),
                  [ M.read (| self |) ]
                |)
              |) in
            let _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (| "core::hash::Hash", Ty.path "isize", [], "hash", [ __H ] |),
                  [ __self_tag; M.read (| state |) ]
                |)
              |) in
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::language_storage::TypeTag::Vector",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.apply
                            (Ty.path "alloc::boxed::Box")
                            [
                              Ty.path "move_core_types::language_storage::TypeTag";
                              Ty.path "alloc::alloc::Global"
                            ],
                          [],
                          "hash",
                          [ __H ]
                        |),
                        [ M.read (| __self_0 |); M.read (| state |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::language_storage::TypeTag::Struct",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.apply
                            (Ty.path "alloc::boxed::Box")
                            [
                              Ty.path "move_core_types::language_storage::StructTag";
                              Ty.path "alloc::alloc::Global"
                            ],
                          [],
                          "hash",
                          [ __H ]
                        |),
                        [ M.read (| __self_0 |); M.read (| state |) ]
                      |)
                    |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::hash::Hash"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("hash", InstanceField.Method hash) ].
  End Impl_core_hash_Hash_for_move_core_types_language_storage_TypeTag.
  
  Module Impl_core_marker_StructuralEq_for_move_core_types_language_storage_TypeTag.
    Definition Self : Ty.t := Ty.path "move_core_types::language_storage::TypeTag".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralEq_for_move_core_types_language_storage_TypeTag.
  
  Module Impl_core_cmp_Eq_for_move_core_types_language_storage_TypeTag.
    Definition Self : Ty.t := Ty.path "move_core_types::language_storage::TypeTag".
    
    (* Eq *)
    Definition assert_receiver_is_total_eq (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Value.DeclaredButUndefined,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      Value.DeclaredButUndefined,
                      [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_move_core_types_language_storage_TypeTag.
  
  Module Impl_core_clone_Clone_for_move_core_types_language_storage_TypeTag.
    Definition Self : Ty.t := Ty.path "move_core_types::language_storage::TypeTag".
    
    (* Clone *)
    Definition clone (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (|
                      Value.StructTuple "move_core_types::language_storage::TypeTag::Bool" []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (|
                      Value.StructTuple "move_core_types::language_storage::TypeTag::U8" []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (|
                      Value.StructTuple "move_core_types::language_storage::TypeTag::U64" []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (|
                      Value.StructTuple "move_core_types::language_storage::TypeTag::U128" []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (|
                      Value.StructTuple "move_core_types::language_storage::TypeTag::Address" []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (|
                      Value.StructTuple "move_core_types::language_storage::TypeTag::Signer" []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::language_storage::TypeTag::Vector",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_core_types::language_storage::TypeTag::Vector"
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.apply
                                (Ty.path "alloc::boxed::Box")
                                [
                                  Ty.path "move_core_types::language_storage::TypeTag";
                                  Ty.path "alloc::alloc::Global"
                                ],
                              [],
                              "clone",
                              []
                            |),
                            [ M.read (| __self_0 |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::language_storage::TypeTag::Struct",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_core_types::language_storage::TypeTag::Struct"
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.apply
                                (Ty.path "alloc::boxed::Box")
                                [
                                  Ty.path "move_core_types::language_storage::StructTag";
                                  Ty.path "alloc::alloc::Global"
                                ],
                              [],
                              "clone",
                              []
                            |),
                            [ M.read (| __self_0 |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (|
                      Value.StructTuple "move_core_types::language_storage::TypeTag::U16" []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (|
                      Value.StructTuple "move_core_types::language_storage::TypeTag::U32" []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (|
                      Value.StructTuple "move_core_types::language_storage::TypeTag::U256" []
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_move_core_types_language_storage_TypeTag.
  
  Module Impl_core_cmp_PartialOrd_for_move_core_types_language_storage_TypeTag.
    Definition Self : Ty.t := Ty.path "move_core_types::language_storage::TypeTag".
    
    (* PartialOrd *)
    Definition partial_cmp (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            let __self_tag :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [ Ty.path "move_core_types::language_storage::TypeTag" ]
                  |),
                  [ M.read (| self |) ]
                |)
              |) in
            let __arg1_tag :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [ Ty.path "move_core_types::language_storage::TypeTag" ]
                  |),
                  [ M.read (| other |) ]
                |)
              |) in
            M.match_operator (|
              M.alloc (| Value.Tuple [ M.read (| self |); M.read (| other |) ] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.get_tuple_field γ 0 in
                    let γ0_1 := M.get_tuple_field γ 1 in
                    let γ0_0 := M.read (| γ0_0 |) in
                    let γ2_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ0_0,
                        "move_core_types::language_storage::TypeTag::Vector",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ2_0 |) in
                    let γ0_1 := M.read (| γ0_1 |) in
                    let γ2_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ0_1,
                        "move_core_types::language_storage::TypeTag::Vector",
                        0
                      |) in
                    let __arg1_0 := M.alloc (| γ2_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::cmp::PartialOrd",
                          Ty.apply
                            (Ty.path "alloc::boxed::Box")
                            [
                              Ty.path "move_core_types::language_storage::TypeTag";
                              Ty.path "alloc::alloc::Global"
                            ],
                          [
                            Ty.apply
                              (Ty.path "alloc::boxed::Box")
                              [
                                Ty.path "move_core_types::language_storage::TypeTag";
                                Ty.path "alloc::alloc::Global"
                              ]
                          ],
                          "partial_cmp",
                          []
                        |),
                        [ M.read (| __self_0 |); M.read (| __arg1_0 |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.get_tuple_field γ 0 in
                    let γ0_1 := M.get_tuple_field γ 1 in
                    let γ0_0 := M.read (| γ0_0 |) in
                    let γ2_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ0_0,
                        "move_core_types::language_storage::TypeTag::Struct",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ2_0 |) in
                    let γ0_1 := M.read (| γ0_1 |) in
                    let γ2_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ0_1,
                        "move_core_types::language_storage::TypeTag::Struct",
                        0
                      |) in
                    let __arg1_0 := M.alloc (| γ2_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::cmp::PartialOrd",
                          Ty.apply
                            (Ty.path "alloc::boxed::Box")
                            [
                              Ty.path "move_core_types::language_storage::StructTag";
                              Ty.path "alloc::alloc::Global"
                            ],
                          [
                            Ty.apply
                              (Ty.path "alloc::boxed::Box")
                              [
                                Ty.path "move_core_types::language_storage::StructTag";
                                Ty.path "alloc::alloc::Global"
                              ]
                          ],
                          "partial_cmp",
                          []
                        |),
                        [ M.read (| __self_0 |); M.read (| __arg1_0 |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::cmp::PartialOrd",
                          Ty.path "isize",
                          [ Ty.path "isize" ],
                          "partial_cmp",
                          []
                        |),
                        [ __self_tag; __arg1_tag ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialOrd"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("partial_cmp", InstanceField.Method partial_cmp) ].
  End Impl_core_cmp_PartialOrd_for_move_core_types_language_storage_TypeTag.
  
  Module Impl_core_cmp_Ord_for_move_core_types_language_storage_TypeTag.
    Definition Self : Ty.t := Ty.path "move_core_types::language_storage::TypeTag".
    
    (* Ord *)
    Definition cmp (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            let __self_tag :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [ Ty.path "move_core_types::language_storage::TypeTag" ]
                  |),
                  [ M.read (| self |) ]
                |)
              |) in
            let __arg1_tag :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [ Ty.path "move_core_types::language_storage::TypeTag" ]
                  |),
                  [ M.read (| other |) ]
                |)
              |) in
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (| "core::cmp::Ord", Ty.path "isize", [], "cmp", [] |),
                  [ __self_tag; __arg1_tag ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      M.alloc (| Value.Tuple [ M.read (| self |); M.read (| other |) ] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.get_tuple_field γ 0 in
                            let γ0_1 := M.get_tuple_field γ 1 in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ0_0,
                                "move_core_types::language_storage::TypeTag::Vector",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ0_1,
                                "move_core_types::language_storage::TypeTag::Vector",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::cmp::Ord",
                                  Ty.apply
                                    (Ty.path "alloc::boxed::Box")
                                    [
                                      Ty.path "move_core_types::language_storage::TypeTag";
                                      Ty.path "alloc::alloc::Global"
                                    ],
                                  [],
                                  "cmp",
                                  []
                                |),
                                [ M.read (| __self_0 |); M.read (| __arg1_0 |) ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.get_tuple_field γ 0 in
                            let γ0_1 := M.get_tuple_field γ 1 in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ0_0,
                                "move_core_types::language_storage::TypeTag::Struct",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ0_1,
                                "move_core_types::language_storage::TypeTag::Struct",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::cmp::Ord",
                                  Ty.apply
                                    (Ty.path "alloc::boxed::Box")
                                    [
                                      Ty.path "move_core_types::language_storage::StructTag";
                                      Ty.path "alloc::alloc::Global"
                                    ],
                                  [],
                                  "cmp",
                                  []
                                |),
                                [ M.read (| __self_0 |); M.read (| __arg1_0 |) ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (| Value.StructTuple "core::cmp::Ordering::Equal" [] |)))
                      ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let cmp := M.copy (| γ |) in
                    cmp))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Ord"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("cmp", InstanceField.Method cmp) ].
  End Impl_core_cmp_Ord_for_move_core_types_language_storage_TypeTag.
  
  Module Impl_move_core_types_language_storage_TypeTag.
    Definition Self : Ty.t := Ty.path "move_core_types::language_storage::TypeTag".
    
    (*
        pub fn to_canonical_string(&self) -> String {
            use TypeTag::*;
            match self {
                Bool => "bool".to_owned(),
                U8 => "u8".to_owned(),
                U16 => "u16".to_owned(),
                U32 => "u32".to_owned(),
                U64 => "u64".to_owned(),
                U128 => "u128".to_owned(),
                U256 => "u256".to_owned(),
                Address => "address".to_owned(),
                Signer => "signer".to_owned(),
                Vector(t) => format!("vector<{}>", t.to_canonical_string()),
                Struct(s) => s.to_canonical_string(),
            }
        }
    *)
    Definition to_canonical_string (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "alloc::borrow::ToOwned",
                          Ty.path "str",
                          [],
                          "to_owned",
                          []
                        |),
                        [ M.read (| mk_str "bool" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "alloc::borrow::ToOwned",
                          Ty.path "str",
                          [],
                          "to_owned",
                          []
                        |),
                        [ M.read (| mk_str "u8" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "alloc::borrow::ToOwned",
                          Ty.path "str",
                          [],
                          "to_owned",
                          []
                        |),
                        [ M.read (| mk_str "u16" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "alloc::borrow::ToOwned",
                          Ty.path "str",
                          [],
                          "to_owned",
                          []
                        |),
                        [ M.read (| mk_str "u32" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "alloc::borrow::ToOwned",
                          Ty.path "str",
                          [],
                          "to_owned",
                          []
                        |),
                        [ M.read (| mk_str "u64" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "alloc::borrow::ToOwned",
                          Ty.path "str",
                          [],
                          "to_owned",
                          []
                        |),
                        [ M.read (| mk_str "u128" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "alloc::borrow::ToOwned",
                          Ty.path "str",
                          [],
                          "to_owned",
                          []
                        |),
                        [ M.read (| mk_str "u256" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "alloc::borrow::ToOwned",
                          Ty.path "str",
                          [],
                          "to_owned",
                          []
                        |),
                        [ M.read (| mk_str "address" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "alloc::borrow::ToOwned",
                          Ty.path "str",
                          [],
                          "to_owned",
                          []
                        |),
                        [ M.read (| mk_str "signer" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::language_storage::TypeTag::Vector",
                        0
                      |) in
                    let t := M.alloc (| γ1_0 |) in
                    let res :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_function (| "alloc::fmt::format", [] |),
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::fmt::Arguments",
                                "new_v1",
                                []
                              |),
                              [
                                (* Unsize *)
                                M.pointer_coercion
                                  (M.alloc (|
                                    Value.Array
                                      [ M.read (| mk_str "vector<" |); M.read (| mk_str ">" |) ]
                                  |));
                                (* Unsize *)
                                M.pointer_coercion
                                  (M.alloc (|
                                    Value.Array
                                      [
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.path "core::fmt::rt::Argument",
                                            "new_display",
                                            [ Ty.path "alloc::string::String" ]
                                          |),
                                          [
                                            M.alloc (|
                                              M.call_closure (|
                                                M.get_associated_function (|
                                                  Ty.path
                                                    "move_core_types::language_storage::TypeTag",
                                                  "to_canonical_string",
                                                  []
                                                |),
                                                [ M.read (| M.read (| t |) |) ]
                                              |)
                                            |)
                                          ]
                                        |)
                                      ]
                                  |))
                              ]
                            |)
                          ]
                        |)
                      |) in
                    res));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::language_storage::TypeTag::Struct",
                        0
                      |) in
                    let s := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "move_core_types::language_storage::StructTag",
                          "to_canonical_string",
                          []
                        |),
                        [ M.read (| M.read (| s |) |) ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_to_canonical_string :
      M.IsAssociatedFunction Self "to_canonical_string" to_canonical_string.
  End Impl_move_core_types_language_storage_TypeTag.
  
  Module Impl_core_str_traits_FromStr_for_move_core_types_language_storage_TypeTag.
    Definition Self : Ty.t := Ty.path "move_core_types::language_storage::TypeTag".
    
    (*     type Err = anyhow::Error; *)
    Definition _Err : Ty.t := Ty.path "anyhow::Error".
    
    (*
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            parse_type_tag(s)
        }
    *)
    Definition from_str (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ s ] =>
        ltac:(M.monadic
          (let s := M.alloc (| s |) in
          M.call_closure (|
            M.get_function (| "move_core_types::parser::parse_type_tag", [] |),
            [ M.read (| s |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::str::traits::FromStr"
        Self
        (* Trait polymorphic types *) []
        (* Instance *)
        [ ("Err", InstanceField.Ty _Err); ("from_str", InstanceField.Method from_str) ].
  End Impl_core_str_traits_FromStr_for_move_core_types_language_storage_TypeTag.
  
  (* StructRecord
    {
      name := "StructTag";
      ty_params := [];
      fields :=
        [
          ("address", Ty.path "move_core_types::account_address::AccountAddress");
          ("module", Ty.path "move_core_types::identifier::Identifier");
          ("name", Ty.path "move_core_types::identifier::Identifier");
          ("type_params",
            Ty.apply
              (Ty.path "alloc::vec::Vec")
              [ Ty.path "move_core_types::language_storage::TypeTag"; Ty.path "alloc::alloc::Global"
              ])
        ];
    } *)
  
  Module Wrap_underscore_3.
  Module underscore.
    Module Impl_serde_ser_Serialize_for_move_core_types_language_storage_StructTag.
      Definition Self : Ty.t := Ty.path "move_core_types::language_storage::StructTag".
      
      (* Serialize *)
      Definition serialize (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ __S ], [ self; __serializer ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let __serializer := M.alloc (| __serializer |) in
            M.read (|
              let __serde_state :=
                M.copy (|
                  M.match_operator (|
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "serde::ser::Serializer",
                          __S,
                          [],
                          "serialize_struct",
                          []
                        |),
                        [
                          M.read (| __serializer |);
                          M.read (| mk_str "StructTag" |);
                          BinOp.Panic.add (|
                            BinOp.Panic.add (|
                              BinOp.Panic.add (|
                                BinOp.Panic.add (|
                                  M.rust_cast (Value.Bool false),
                                  Value.Integer Integer.Usize 1
                                |),
                                Value.Integer Integer.Usize 1
                              |),
                              Value.Integer Integer.Usize 1
                            |),
                            Value.Integer Integer.Usize 1
                          |)
                        ]
                      |)
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.get_struct_tuple_field_or_break_match (|
                              γ,
                              "core::result::Result::Ok",
                              0
                            |) in
                          let __val := M.copy (| γ0_0 |) in
                          __val));
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.get_struct_tuple_field_or_break_match (|
                              γ,
                              "core::result::Result::Err",
                              0
                            |) in
                          let __err := M.copy (| γ0_0 |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  Value.StructTuple
                                    "core::result::Result::Err"
                                    [ M.read (| __err |) ]
                                |)
                              |)
                            |)
                          |)))
                    ]
                  |)
                |) in
              let _ :=
                M.match_operator (|
                  M.alloc (|
                    M.call_closure (|
                      M.get_trait_method (|
                        "serde::ser::SerializeStruct",
                        Ty.associated,
                        [],
                        "serialize_field",
                        [ Ty.path "move_core_types::account_address::AccountAddress" ]
                      |),
                      [
                        __serde_state;
                        M.read (| mk_str "address" |);
                        M.get_struct_record_field
                          (M.read (| self |))
                          "move_core_types::language_storage::StructTag"
                          "address"
                      ]
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.get_struct_tuple_field_or_break_match (|
                            γ,
                            "core::result::Result::Ok",
                            0
                          |) in
                        let __val := M.copy (| γ0_0 |) in
                        __val));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.get_struct_tuple_field_or_break_match (|
                            γ,
                            "core::result::Result::Err",
                            0
                          |) in
                        let __err := M.copy (| γ0_0 |) in
                        M.alloc (|
                          M.never_to_any (|
                            M.read (|
                              M.return_ (|
                                Value.StructTuple "core::result::Result::Err" [ M.read (| __err |) ]
                              |)
                            |)
                          |)
                        |)))
                  ]
                |) in
              let _ :=
                M.match_operator (|
                  M.alloc (|
                    M.call_closure (|
                      M.get_trait_method (|
                        "serde::ser::SerializeStruct",
                        Ty.associated,
                        [],
                        "serialize_field",
                        [ Ty.path "move_core_types::identifier::Identifier" ]
                      |),
                      [
                        __serde_state;
                        M.read (| mk_str "module" |);
                        M.get_struct_record_field
                          (M.read (| self |))
                          "move_core_types::language_storage::StructTag"
                          "module"
                      ]
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.get_struct_tuple_field_or_break_match (|
                            γ,
                            "core::result::Result::Ok",
                            0
                          |) in
                        let __val := M.copy (| γ0_0 |) in
                        __val));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.get_struct_tuple_field_or_break_match (|
                            γ,
                            "core::result::Result::Err",
                            0
                          |) in
                        let __err := M.copy (| γ0_0 |) in
                        M.alloc (|
                          M.never_to_any (|
                            M.read (|
                              M.return_ (|
                                Value.StructTuple "core::result::Result::Err" [ M.read (| __err |) ]
                              |)
                            |)
                          |)
                        |)))
                  ]
                |) in
              let _ :=
                M.match_operator (|
                  M.alloc (|
                    M.call_closure (|
                      M.get_trait_method (|
                        "serde::ser::SerializeStruct",
                        Ty.associated,
                        [],
                        "serialize_field",
                        [ Ty.path "move_core_types::identifier::Identifier" ]
                      |),
                      [
                        __serde_state;
                        M.read (| mk_str "name" |);
                        M.get_struct_record_field
                          (M.read (| self |))
                          "move_core_types::language_storage::StructTag"
                          "name"
                      ]
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.get_struct_tuple_field_or_break_match (|
                            γ,
                            "core::result::Result::Ok",
                            0
                          |) in
                        let __val := M.copy (| γ0_0 |) in
                        __val));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.get_struct_tuple_field_or_break_match (|
                            γ,
                            "core::result::Result::Err",
                            0
                          |) in
                        let __err := M.copy (| γ0_0 |) in
                        M.alloc (|
                          M.never_to_any (|
                            M.read (|
                              M.return_ (|
                                Value.StructTuple "core::result::Result::Err" [ M.read (| __err |) ]
                              |)
                            |)
                          |)
                        |)))
                  ]
                |) in
              let _ :=
                M.match_operator (|
                  M.alloc (|
                    M.call_closure (|
                      M.get_trait_method (|
                        "serde::ser::SerializeStruct",
                        Ty.associated,
                        [],
                        "serialize_field",
                        [
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            [
                              Ty.path "move_core_types::language_storage::TypeTag";
                              Ty.path "alloc::alloc::Global"
                            ]
                        ]
                      |),
                      [
                        __serde_state;
                        M.read (| mk_str "type_args" |);
                        M.get_struct_record_field
                          (M.read (| self |))
                          "move_core_types::language_storage::StructTag"
                          "type_params"
                      ]
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.get_struct_tuple_field_or_break_match (|
                            γ,
                            "core::result::Result::Ok",
                            0
                          |) in
                        let __val := M.copy (| γ0_0 |) in
                        __val));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.get_struct_tuple_field_or_break_match (|
                            γ,
                            "core::result::Result::Err",
                            0
                          |) in
                        let __err := M.copy (| γ0_0 |) in
                        M.alloc (|
                          M.never_to_any (|
                            M.read (|
                              M.return_ (|
                                Value.StructTuple "core::result::Result::Err" [ M.read (| __err |) ]
                              |)
                            |)
                          |)
                        |)))
                  ]
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "serde::ser::SerializeStruct",
                    Ty.associated,
                    [],
                    "end",
                    []
                  |),
                  [ M.read (| __serde_state |) ]
                |)
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "serde::ser::Serialize"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("serialize", InstanceField.Method serialize) ].
    End Impl_serde_ser_Serialize_for_move_core_types_language_storage_StructTag.
  End underscore.
  End Wrap_underscore_3.
  Import Wrap_underscore_3.
  
  Module Wrap_underscore_4.
  Module underscore.
    Module Impl_serde_de_Deserialize_for_move_core_types_language_storage_StructTag.
      Definition Self : Ty.t := Ty.path "move_core_types::language_storage::StructTag".
      
      (* Deserialize *)
      Definition deserialize (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ __D ], [ __deserializer ] =>
          ltac:(M.monadic
            (let __deserializer := M.alloc (| __deserializer |) in
            M.call_closure (|
              M.get_trait_method (|
                "serde::de::Deserializer",
                __D,
                [],
                "deserialize_struct",
                [ Ty.path "move_core_types::language_storage::_'3::deserialize::__Visitor" ]
              |),
              [
                M.read (| __deserializer |);
                M.read (| mk_str "StructTag" |);
                M.read (|
                  M.get_constant (| "move_core_types::language_storage::_'3::deserialize::FIELDS" |)
                |);
                Value.StructRecord
                  "move_core_types::language_storage::_'3::deserialize::__Visitor"
                  [
                    ("marker", Value.StructTuple "core::marker::PhantomData" []);
                    ("lifetime", Value.StructTuple "core::marker::PhantomData" [])
                  ]
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "serde::de::Deserialize"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("deserialize", InstanceField.Method deserialize) ].
    End Impl_serde_de_Deserialize_for_move_core_types_language_storage_StructTag.
  End underscore.
  End Wrap_underscore_4.
  Import Wrap_underscore_4.
  
  Module Impl_core_fmt_Debug_for_move_core_types_language_storage_StructTag.
    Definition Self : Ty.t := Ty.path "move_core_types::language_storage::StructTag".
    
    (* Debug *)
    Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.path "core::fmt::Formatter",
              "debug_struct_field4_finish",
              []
            |),
            [
              M.read (| f |);
              M.read (| mk_str "StructTag" |);
              M.read (| mk_str "address" |);
              (* Unsize *)
              M.pointer_coercion
                (M.get_struct_record_field
                  (M.read (| self |))
                  "move_core_types::language_storage::StructTag"
                  "address");
              M.read (| mk_str "module" |);
              (* Unsize *)
              M.pointer_coercion
                (M.get_struct_record_field
                  (M.read (| self |))
                  "move_core_types::language_storage::StructTag"
                  "module");
              M.read (| mk_str "name" |);
              (* Unsize *)
              M.pointer_coercion
                (M.get_struct_record_field
                  (M.read (| self |))
                  "move_core_types::language_storage::StructTag"
                  "name");
              M.read (| mk_str "type_params" |);
              (* Unsize *)
              M.pointer_coercion
                (M.alloc (|
                  M.get_struct_record_field
                    (M.read (| self |))
                    "move_core_types::language_storage::StructTag"
                    "type_params"
                |))
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_move_core_types_language_storage_StructTag.
  
  Module Impl_core_marker_StructuralPartialEq_for_move_core_types_language_storage_StructTag.
    Definition Self : Ty.t := Ty.path "move_core_types::language_storage::StructTag".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_move_core_types_language_storage_StructTag.
  
  Module Impl_core_cmp_PartialEq_for_move_core_types_language_storage_StructTag.
    Definition Self : Ty.t := Ty.path "move_core_types::language_storage::StructTag".
    
    (* PartialEq *)
    Definition eq (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          LogicalOp.and (|
            LogicalOp.and (|
              LogicalOp.and (|
                M.call_closure (|
                  M.get_trait_method (|
                    "core::cmp::PartialEq",
                    Ty.path "move_core_types::account_address::AccountAddress",
                    [ Ty.path "move_core_types::account_address::AccountAddress" ],
                    "eq",
                    []
                  |),
                  [
                    M.get_struct_record_field
                      (M.read (| self |))
                      "move_core_types::language_storage::StructTag"
                      "address";
                    M.get_struct_record_field
                      (M.read (| other |))
                      "move_core_types::language_storage::StructTag"
                      "address"
                  ]
                |),
                ltac:(M.monadic
                  (M.call_closure (|
                    M.get_trait_method (|
                      "core::cmp::PartialEq",
                      Ty.path "move_core_types::identifier::Identifier",
                      [ Ty.path "move_core_types::identifier::Identifier" ],
                      "eq",
                      []
                    |),
                    [
                      M.get_struct_record_field
                        (M.read (| self |))
                        "move_core_types::language_storage::StructTag"
                        "module";
                      M.get_struct_record_field
                        (M.read (| other |))
                        "move_core_types::language_storage::StructTag"
                        "module"
                    ]
                  |)))
              |),
              ltac:(M.monadic
                (M.call_closure (|
                  M.get_trait_method (|
                    "core::cmp::PartialEq",
                    Ty.path "move_core_types::identifier::Identifier",
                    [ Ty.path "move_core_types::identifier::Identifier" ],
                    "eq",
                    []
                  |),
                  [
                    M.get_struct_record_field
                      (M.read (| self |))
                      "move_core_types::language_storage::StructTag"
                      "name";
                    M.get_struct_record_field
                      (M.read (| other |))
                      "move_core_types::language_storage::StructTag"
                      "name"
                  ]
                |)))
            |),
            ltac:(M.monadic
              (M.call_closure (|
                M.get_trait_method (|
                  "core::cmp::PartialEq",
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    [
                      Ty.path "move_core_types::language_storage::TypeTag";
                      Ty.path "alloc::alloc::Global"
                    ],
                  [
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      [
                        Ty.path "move_core_types::language_storage::TypeTag";
                        Ty.path "alloc::alloc::Global"
                      ]
                  ],
                  "eq",
                  []
                |),
                [
                  M.get_struct_record_field
                    (M.read (| self |))
                    "move_core_types::language_storage::StructTag"
                    "type_params";
                  M.get_struct_record_field
                    (M.read (| other |))
                    "move_core_types::language_storage::StructTag"
                    "type_params"
                ]
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_for_move_core_types_language_storage_StructTag.
  
  Module Impl_core_hash_Hash_for_move_core_types_language_storage_StructTag.
    Definition Self : Ty.t := Ty.path "move_core_types::language_storage::StructTag".
    
    (* Hash *)
    Definition hash (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ __H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let state := M.alloc (| state |) in
          M.read (|
            let _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "core::hash::Hash",
                    Ty.path "move_core_types::account_address::AccountAddress",
                    [],
                    "hash",
                    [ __H ]
                  |),
                  [
                    M.get_struct_record_field
                      (M.read (| self |))
                      "move_core_types::language_storage::StructTag"
                      "address";
                    M.read (| state |)
                  ]
                |)
              |) in
            let _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "core::hash::Hash",
                    Ty.path "move_core_types::identifier::Identifier",
                    [],
                    "hash",
                    [ __H ]
                  |),
                  [
                    M.get_struct_record_field
                      (M.read (| self |))
                      "move_core_types::language_storage::StructTag"
                      "module";
                    M.read (| state |)
                  ]
                |)
              |) in
            let _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "core::hash::Hash",
                    Ty.path "move_core_types::identifier::Identifier",
                    [],
                    "hash",
                    [ __H ]
                  |),
                  [
                    M.get_struct_record_field
                      (M.read (| self |))
                      "move_core_types::language_storage::StructTag"
                      "name";
                    M.read (| state |)
                  ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                M.get_trait_method (|
                  "core::hash::Hash",
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    [
                      Ty.path "move_core_types::language_storage::TypeTag";
                      Ty.path "alloc::alloc::Global"
                    ],
                  [],
                  "hash",
                  [ __H ]
                |),
                [
                  M.get_struct_record_field
                    (M.read (| self |))
                    "move_core_types::language_storage::StructTag"
                    "type_params";
                  M.read (| state |)
                ]
              |)
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::hash::Hash"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("hash", InstanceField.Method hash) ].
  End Impl_core_hash_Hash_for_move_core_types_language_storage_StructTag.
  
  Module Impl_core_marker_StructuralEq_for_move_core_types_language_storage_StructTag.
    Definition Self : Ty.t := Ty.path "move_core_types::language_storage::StructTag".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralEq_for_move_core_types_language_storage_StructTag.
  
  Module Impl_core_cmp_Eq_for_move_core_types_language_storage_StructTag.
    Definition Self : Ty.t := Ty.path "move_core_types::language_storage::StructTag".
    
    (* Eq *)
    Definition assert_receiver_is_total_eq (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Value.DeclaredButUndefined,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      Value.DeclaredButUndefined,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              Value.DeclaredButUndefined,
                              [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_move_core_types_language_storage_StructTag.
  
  Module Impl_core_clone_Clone_for_move_core_types_language_storage_StructTag.
    Definition Self : Ty.t := Ty.path "move_core_types::language_storage::StructTag".
    
    (* Clone *)
    Definition clone (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.StructRecord
            "move_core_types::language_storage::StructTag"
            [
              ("address",
                M.call_closure (|
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.path "move_core_types::account_address::AccountAddress",
                    [],
                    "clone",
                    []
                  |),
                  [
                    M.get_struct_record_field
                      (M.read (| self |))
                      "move_core_types::language_storage::StructTag"
                      "address"
                  ]
                |));
              ("module",
                M.call_closure (|
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.path "move_core_types::identifier::Identifier",
                    [],
                    "clone",
                    []
                  |),
                  [
                    M.get_struct_record_field
                      (M.read (| self |))
                      "move_core_types::language_storage::StructTag"
                      "module"
                  ]
                |));
              ("name",
                M.call_closure (|
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.path "move_core_types::identifier::Identifier",
                    [],
                    "clone",
                    []
                  |),
                  [
                    M.get_struct_record_field
                      (M.read (| self |))
                      "move_core_types::language_storage::StructTag"
                      "name"
                  ]
                |));
              ("type_params",
                M.call_closure (|
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      [
                        Ty.path "move_core_types::language_storage::TypeTag";
                        Ty.path "alloc::alloc::Global"
                      ],
                    [],
                    "clone",
                    []
                  |),
                  [
                    M.get_struct_record_field
                      (M.read (| self |))
                      "move_core_types::language_storage::StructTag"
                      "type_params"
                  ]
                |))
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_move_core_types_language_storage_StructTag.
  
  Module Impl_core_cmp_PartialOrd_for_move_core_types_language_storage_StructTag.
    Definition Self : Ty.t := Ty.path "move_core_types::language_storage::StructTag".
    
    (* PartialOrd *)
    Definition partial_cmp (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "core::cmp::PartialOrd",
                    Ty.path "move_core_types::account_address::AccountAddress",
                    [ Ty.path "move_core_types::account_address::AccountAddress" ],
                    "partial_cmp",
                    []
                  |),
                  [
                    M.get_struct_record_field
                      (M.read (| self |))
                      "move_core_types::language_storage::StructTag"
                      "address";
                    M.get_struct_record_field
                      (M.read (| other |))
                      "move_core_types::language_storage::StructTag"
                      "address"
                  ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    M.match_operator (|
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::cmp::PartialOrd",
                            Ty.path "move_core_types::identifier::Identifier",
                            [ Ty.path "move_core_types::identifier::Identifier" ],
                            "partial_cmp",
                            []
                          |),
                          [
                            M.get_struct_record_field
                              (M.read (| self |))
                              "move_core_types::language_storage::StructTag"
                              "module";
                            M.get_struct_record_field
                              (M.read (| other |))
                              "move_core_types::language_storage::StructTag"
                              "module"
                          ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ,
                                "core::option::Option::Some",
                                0
                              |) in
                            M.match_operator (|
                              M.alloc (|
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::cmp::PartialOrd",
                                    Ty.path "move_core_types::identifier::Identifier",
                                    [ Ty.path "move_core_types::identifier::Identifier" ],
                                    "partial_cmp",
                                    []
                                  |),
                                  [
                                    M.get_struct_record_field
                                      (M.read (| self |))
                                      "move_core_types::language_storage::StructTag"
                                      "name";
                                    M.get_struct_record_field
                                      (M.read (| other |))
                                      "move_core_types::language_storage::StructTag"
                                      "name"
                                  ]
                                |)
                              |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ0_0 :=
                                      M.get_struct_tuple_field_or_break_match (|
                                        γ,
                                        "core::option::Option::Some",
                                        0
                                      |) in
                                    M.alloc (|
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::cmp::PartialOrd",
                                          Ty.apply
                                            (Ty.path "alloc::vec::Vec")
                                            [
                                              Ty.path "move_core_types::language_storage::TypeTag";
                                              Ty.path "alloc::alloc::Global"
                                            ],
                                          [
                                            Ty.apply
                                              (Ty.path "alloc::vec::Vec")
                                              [
                                                Ty.path
                                                  "move_core_types::language_storage::TypeTag";
                                                Ty.path "alloc::alloc::Global"
                                              ]
                                          ],
                                          "partial_cmp",
                                          []
                                        |),
                                        [
                                          M.get_struct_record_field
                                            (M.read (| self |))
                                            "move_core_types::language_storage::StructTag"
                                            "type_params";
                                          M.get_struct_record_field
                                            (M.read (| other |))
                                            "move_core_types::language_storage::StructTag"
                                            "type_params"
                                        ]
                                      |)
                                    |)));
                                fun γ =>
                                  ltac:(M.monadic
                                    (let cmp := M.copy (| γ |) in
                                    cmp))
                              ]
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let cmp := M.copy (| γ |) in
                            cmp))
                      ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let cmp := M.copy (| γ |) in
                    cmp))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialOrd"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("partial_cmp", InstanceField.Method partial_cmp) ].
  End Impl_core_cmp_PartialOrd_for_move_core_types_language_storage_StructTag.
  
  Module Impl_core_cmp_Ord_for_move_core_types_language_storage_StructTag.
    Definition Self : Ty.t := Ty.path "move_core_types::language_storage::StructTag".
    
    (* Ord *)
    Definition cmp (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "core::cmp::Ord",
                    Ty.path "move_core_types::account_address::AccountAddress",
                    [],
                    "cmp",
                    []
                  |),
                  [
                    M.get_struct_record_field
                      (M.read (| self |))
                      "move_core_types::language_storage::StructTag"
                      "address";
                    M.get_struct_record_field
                      (M.read (| other |))
                      "move_core_types::language_storage::StructTag"
                      "address"
                  ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::cmp::Ord",
                            Ty.path "move_core_types::identifier::Identifier",
                            [],
                            "cmp",
                            []
                          |),
                          [
                            M.get_struct_record_field
                              (M.read (| self |))
                              "move_core_types::language_storage::StructTag"
                              "module";
                            M.get_struct_record_field
                              (M.read (| other |))
                              "move_core_types::language_storage::StructTag"
                              "module"
                          ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              M.alloc (|
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::cmp::Ord",
                                    Ty.path "move_core_types::identifier::Identifier",
                                    [],
                                    "cmp",
                                    []
                                  |),
                                  [
                                    M.get_struct_record_field
                                      (M.read (| self |))
                                      "move_core_types::language_storage::StructTag"
                                      "name";
                                    M.get_struct_record_field
                                      (M.read (| other |))
                                      "move_core_types::language_storage::StructTag"
                                      "name"
                                  ]
                                |)
                              |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (M.alloc (|
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::cmp::Ord",
                                          Ty.apply
                                            (Ty.path "alloc::vec::Vec")
                                            [
                                              Ty.path "move_core_types::language_storage::TypeTag";
                                              Ty.path "alloc::alloc::Global"
                                            ],
                                          [],
                                          "cmp",
                                          []
                                        |),
                                        [
                                          M.get_struct_record_field
                                            (M.read (| self |))
                                            "move_core_types::language_storage::StructTag"
                                            "type_params";
                                          M.get_struct_record_field
                                            (M.read (| other |))
                                            "move_core_types::language_storage::StructTag"
                                            "type_params"
                                        ]
                                      |)
                                    |)));
                                fun γ =>
                                  ltac:(M.monadic
                                    (let cmp := M.copy (| γ |) in
                                    cmp))
                              ]
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let cmp := M.copy (| γ |) in
                            cmp))
                      ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let cmp := M.copy (| γ |) in
                    cmp))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Ord"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("cmp", InstanceField.Method cmp) ].
  End Impl_core_cmp_Ord_for_move_core_types_language_storage_StructTag.
  
  Module Impl_move_core_types_language_storage_StructTag.
    Definition Self : Ty.t := Ty.path "move_core_types::language_storage::StructTag".
    
    (*
        pub fn access_vector(&self) -> Vec<u8> {
            let mut key = vec![RESOURCE_TAG];
            key.append(&mut bcs::to_bytes(self).unwrap());
            key
        }
    *)
    Definition access_vector (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let key :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "slice") [ Ty.path "u8" ],
                    "into_vec",
                    [ Ty.path "alloc::alloc::Global" ]
                  |),
                  [
                    (* Unsize *)
                    M.pointer_coercion
                      (M.read (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloc::boxed::Box")
                              [
                                Ty.apply (Ty.path "array") [ Ty.path "u8" ];
                                Ty.path "alloc::alloc::Global"
                              ],
                            "new",
                            []
                          |),
                          [
                            M.alloc (|
                              Value.Array
                                [
                                  M.read (|
                                    M.get_constant (|
                                      "move_core_types::language_storage::RESOURCE_TAG"
                                    |)
                                  |)
                                ]
                            |)
                          ]
                        |)
                      |))
                  ]
                |)
              |) in
            let _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                    "append",
                    []
                  |),
                  [
                    key;
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "core::result::Result")
                            [
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ];
                              Ty.path "bcs::error::Error"
                            ],
                          "unwrap",
                          []
                        |),
                        [
                          M.call_closure (|
                            M.get_function (|
                              "bcs::ser::to_bytes",
                              [ Ty.path "move_core_types::language_storage::StructTag" ]
                            |),
                            [ M.read (| self |) ]
                          |)
                        ]
                      |)
                    |)
                  ]
                |)
              |) in
            key
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_access_vector :
      M.IsAssociatedFunction Self "access_vector" access_vector.
    
    (*
        pub fn is_ascii_string(&self, move_std_addr: &AccountAddress) -> bool {
            self.address == *move_std_addr
                && self.module.as_str().eq("ascii")
                && self.name.as_str().eq("String")
        }
    *)
    Definition is_ascii_string (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; move_std_addr ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let move_std_addr := M.alloc (| move_std_addr |) in
          LogicalOp.and (|
            LogicalOp.and (|
              M.call_closure (|
                M.get_trait_method (|
                  "core::cmp::PartialEq",
                  Ty.path "move_core_types::account_address::AccountAddress",
                  [ Ty.path "move_core_types::account_address::AccountAddress" ],
                  "eq",
                  []
                |),
                [
                  M.get_struct_record_field
                    (M.read (| self |))
                    "move_core_types::language_storage::StructTag"
                    "address";
                  M.read (| move_std_addr |)
                ]
              |),
              ltac:(M.monadic
                (M.call_closure (|
                  M.get_trait_method (|
                    "core::cmp::PartialEq",
                    Ty.path "str",
                    [ Ty.path "str" ],
                    "eq",
                    []
                  |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "move_core_types::identifier::IdentStr",
                        "as_str",
                        []
                      |),
                      [
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::ops::deref::Deref",
                            Ty.path "move_core_types::identifier::Identifier",
                            [],
                            "deref",
                            []
                          |),
                          [
                            M.get_struct_record_field
                              (M.read (| self |))
                              "move_core_types::language_storage::StructTag"
                              "module"
                          ]
                        |)
                      ]
                    |);
                    M.read (| mk_str "ascii" |)
                  ]
                |)))
            |),
            ltac:(M.monadic
              (M.call_closure (|
                M.get_trait_method (|
                  "core::cmp::PartialEq",
                  Ty.path "str",
                  [ Ty.path "str" ],
                  "eq",
                  []
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "move_core_types::identifier::IdentStr",
                      "as_str",
                      []
                    |),
                    [
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::ops::deref::Deref",
                          Ty.path "move_core_types::identifier::Identifier",
                          [],
                          "deref",
                          []
                        |),
                        [
                          M.get_struct_record_field
                            (M.read (| self |))
                            "move_core_types::language_storage::StructTag"
                            "name"
                        ]
                      |)
                    ]
                  |);
                  M.read (| mk_str "String" |)
                ]
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_is_ascii_string :
      M.IsAssociatedFunction Self "is_ascii_string" is_ascii_string.
    
    (*
        pub fn is_std_string(&self, move_std_addr: &AccountAddress) -> bool {
            self.address == *move_std_addr
                && self.module.as_str().eq("string")
                && self.name.as_str().eq("String")
        }
    *)
    Definition is_std_string (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; move_std_addr ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let move_std_addr := M.alloc (| move_std_addr |) in
          LogicalOp.and (|
            LogicalOp.and (|
              M.call_closure (|
                M.get_trait_method (|
                  "core::cmp::PartialEq",
                  Ty.path "move_core_types::account_address::AccountAddress",
                  [ Ty.path "move_core_types::account_address::AccountAddress" ],
                  "eq",
                  []
                |),
                [
                  M.get_struct_record_field
                    (M.read (| self |))
                    "move_core_types::language_storage::StructTag"
                    "address";
                  M.read (| move_std_addr |)
                ]
              |),
              ltac:(M.monadic
                (M.call_closure (|
                  M.get_trait_method (|
                    "core::cmp::PartialEq",
                    Ty.path "str",
                    [ Ty.path "str" ],
                    "eq",
                    []
                  |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "move_core_types::identifier::IdentStr",
                        "as_str",
                        []
                      |),
                      [
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::ops::deref::Deref",
                            Ty.path "move_core_types::identifier::Identifier",
                            [],
                            "deref",
                            []
                          |),
                          [
                            M.get_struct_record_field
                              (M.read (| self |))
                              "move_core_types::language_storage::StructTag"
                              "module"
                          ]
                        |)
                      ]
                    |);
                    M.read (| mk_str "string" |)
                  ]
                |)))
            |),
            ltac:(M.monadic
              (M.call_closure (|
                M.get_trait_method (|
                  "core::cmp::PartialEq",
                  Ty.path "str",
                  [ Ty.path "str" ],
                  "eq",
                  []
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "move_core_types::identifier::IdentStr",
                      "as_str",
                      []
                    |),
                    [
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::ops::deref::Deref",
                          Ty.path "move_core_types::identifier::Identifier",
                          [],
                          "deref",
                          []
                        |),
                        [
                          M.get_struct_record_field
                            (M.read (| self |))
                            "move_core_types::language_storage::StructTag"
                            "name"
                        ]
                      |)
                    ]
                  |);
                  M.read (| mk_str "String" |)
                ]
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_is_std_string :
      M.IsAssociatedFunction Self "is_std_string" is_std_string.
    
    (*
        pub fn module_id(&self) -> ModuleId {
            ModuleId::new(self.address, self.module.to_owned())
        }
    *)
    Definition module_id (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.path "move_core_types::language_storage::ModuleId",
              "new",
              []
            |),
            [
              M.read (|
                M.get_struct_record_field
                  (M.read (| self |))
                  "move_core_types::language_storage::StructTag"
                  "address"
              |);
              M.call_closure (|
                M.get_trait_method (|
                  "alloc::borrow::ToOwned",
                  Ty.path "move_core_types::identifier::Identifier",
                  [],
                  "to_owned",
                  []
                |),
                [
                  M.get_struct_record_field
                    (M.read (| self |))
                    "move_core_types::language_storage::StructTag"
                    "module"
                ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_module_id : M.IsAssociatedFunction Self "module_id" module_id.
    
    (*
        pub fn to_canonical_string(&self) -> String {
            let mut generics = String::new();
            if let Some(first_ty) = self.type_params.first() {
                generics.push('<');
                generics.push_str(&first_ty.to_canonical_string());
                for ty in self.type_params.iter().skip(1) {
                    generics.push(',');
                    generics.push_str(&ty.to_canonical_string())
                }
                generics.push('>');
            }
            format!(
                "{}::{}::{}{}",
                self.address.to_canonical_string(),
                self.module,
                self.name,
                generics
            )
        }
    *)
    Definition to_canonical_string (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let generics :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "alloc::string::String", "new", [] |),
                  []
                |)
              |) in
            let _ :=
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "slice")
                                [ Ty.path "move_core_types::language_storage::TypeTag" ],
                              "first",
                              []
                            |),
                            [
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::ops::deref::Deref",
                                  Ty.apply
                                    (Ty.path "alloc::vec::Vec")
                                    [
                                      Ty.path "move_core_types::language_storage::TypeTag";
                                      Ty.path "alloc::alloc::Global"
                                    ],
                                  [],
                                  "deref",
                                  []
                                |),
                                [
                                  M.get_struct_record_field
                                    (M.read (| self |))
                                    "move_core_types::language_storage::StructTag"
                                    "type_params"
                                ]
                              |)
                            ]
                          |)
                        |) in
                      let γ0_0 :=
                        M.get_struct_tuple_field_or_break_match (|
                          γ,
                          "core::option::Option::Some",
                          0
                        |) in
                      let first_ty := M.copy (| γ0_0 |) in
                      let _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "alloc::string::String",
                              "push",
                              []
                            |),
                            [ generics; Value.UnicodeChar 60 ]
                          |)
                        |) in
                      let _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "alloc::string::String",
                              "push_str",
                              []
                            |),
                            [
                              generics;
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::ops::deref::Deref",
                                  Ty.path "alloc::string::String",
                                  [],
                                  "deref",
                                  []
                                |),
                                [
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.path "move_core_types::language_storage::TypeTag",
                                        "to_canonical_string",
                                        []
                                      |),
                                      [ M.read (| first_ty |) ]
                                    |)
                                  |)
                                ]
                              |)
                            ]
                          |)
                        |) in
                      let _ :=
                        M.use
                          (M.match_operator (|
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::iter::traits::collect::IntoIterator",
                                  Ty.apply
                                    (Ty.path "core::iter::adapters::skip::Skip")
                                    [
                                      Ty.apply
                                        (Ty.path "core::slice::iter::Iter")
                                        [ Ty.path "move_core_types::language_storage::TypeTag" ]
                                    ],
                                  [],
                                  "into_iter",
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::iter::traits::iterator::Iterator",
                                      Ty.apply
                                        (Ty.path "core::slice::iter::Iter")
                                        [ Ty.path "move_core_types::language_storage::TypeTag" ],
                                      [],
                                      "skip",
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "slice")
                                            [ Ty.path "move_core_types::language_storage::TypeTag"
                                            ],
                                          "iter",
                                          []
                                        |),
                                        [
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::deref::Deref",
                                              Ty.apply
                                                (Ty.path "alloc::vec::Vec")
                                                [
                                                  Ty.path
                                                    "move_core_types::language_storage::TypeTag";
                                                  Ty.path "alloc::alloc::Global"
                                                ],
                                              [],
                                              "deref",
                                              []
                                            |),
                                            [
                                              M.get_struct_record_field
                                                (M.read (| self |))
                                                "move_core_types::language_storage::StructTag"
                                                "type_params"
                                            ]
                                          |)
                                        ]
                                      |);
                                      Value.Integer Integer.Usize 1
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let iter := M.copy (| γ |) in
                                  M.loop (|
                                    ltac:(M.monadic
                                      (let _ :=
                                        M.match_operator (|
                                          M.alloc (|
                                            M.call_closure (|
                                              M.get_trait_method (|
                                                "core::iter::traits::iterator::Iterator",
                                                Ty.apply
                                                  (Ty.path "core::iter::adapters::skip::Skip")
                                                  [
                                                    Ty.apply
                                                      (Ty.path "core::slice::iter::Iter")
                                                      [
                                                        Ty.path
                                                          "move_core_types::language_storage::TypeTag"
                                                      ]
                                                  ],
                                                [],
                                                "next",
                                                []
                                              |),
                                              [ iter ]
                                            |)
                                          |),
                                          [
                                            fun γ =>
                                              ltac:(M.monadic
                                                (M.alloc (|
                                                  M.never_to_any (| M.read (| M.break (||) |) |)
                                                |)));
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let γ0_0 :=
                                                  M.get_struct_tuple_field_or_break_match (|
                                                    γ,
                                                    "core::option::Option::Some",
                                                    0
                                                  |) in
                                                let ty := M.copy (| γ0_0 |) in
                                                let _ :=
                                                  M.alloc (|
                                                    M.call_closure (|
                                                      M.get_associated_function (|
                                                        Ty.path "alloc::string::String",
                                                        "push",
                                                        []
                                                      |),
                                                      [ generics; Value.UnicodeChar 44 ]
                                                    |)
                                                  |) in
                                                M.alloc (|
                                                  M.call_closure (|
                                                    M.get_associated_function (|
                                                      Ty.path "alloc::string::String",
                                                      "push_str",
                                                      []
                                                    |),
                                                    [
                                                      generics;
                                                      M.call_closure (|
                                                        M.get_trait_method (|
                                                          "core::ops::deref::Deref",
                                                          Ty.path "alloc::string::String",
                                                          [],
                                                          "deref",
                                                          []
                                                        |),
                                                        [
                                                          M.alloc (|
                                                            M.call_closure (|
                                                              M.get_associated_function (|
                                                                Ty.path
                                                                  "move_core_types::language_storage::TypeTag",
                                                                "to_canonical_string",
                                                                []
                                                              |),
                                                              [ M.read (| ty |) ]
                                                            |)
                                                          |)
                                                        ]
                                                      |)
                                                    ]
                                                  |)
                                                |)))
                                          ]
                                        |) in
                                      M.alloc (| Value.Tuple [] |)))
                                  |)))
                            ]
                          |)) in
                      let _ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "alloc::string::String",
                              "push",
                              []
                            |),
                            [ generics; Value.UnicodeChar 62 ]
                          |)
                        |) in
                      M.alloc (| Value.Tuple [] |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            let res :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (| "alloc::fmt::format", [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (| Ty.path "core::fmt::Arguments", "new_v1", [] |),
                      [
                        (* Unsize *)
                        M.pointer_coercion
                          (M.alloc (|
                            Value.Array
                              [
                                M.read (| mk_str "" |);
                                M.read (| mk_str "::" |);
                                M.read (| mk_str "::" |);
                                M.read (| mk_str "" |)
                              ]
                          |));
                        (* Unsize *)
                        M.pointer_coercion
                          (M.alloc (|
                            Value.Array
                              [
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.path "core::fmt::rt::Argument",
                                    "new_display",
                                    [ Ty.path "alloc::string::String" ]
                                  |),
                                  [
                                    M.alloc (|
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.path
                                            "move_core_types::account_address::AccountAddress",
                                          "to_canonical_string",
                                          []
                                        |),
                                        [
                                          M.get_struct_record_field
                                            (M.read (| self |))
                                            "move_core_types::language_storage::StructTag"
                                            "address"
                                        ]
                                      |)
                                    |)
                                  ]
                                |);
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.path "core::fmt::rt::Argument",
                                    "new_display",
                                    [ Ty.path "move_core_types::identifier::Identifier" ]
                                  |),
                                  [
                                    M.get_struct_record_field
                                      (M.read (| self |))
                                      "move_core_types::language_storage::StructTag"
                                      "module"
                                  ]
                                |);
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.path "core::fmt::rt::Argument",
                                    "new_display",
                                    [ Ty.path "move_core_types::identifier::Identifier" ]
                                  |),
                                  [
                                    M.get_struct_record_field
                                      (M.read (| self |))
                                      "move_core_types::language_storage::StructTag"
                                      "name"
                                  ]
                                |);
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.path "core::fmt::rt::Argument",
                                    "new_display",
                                    [ Ty.path "alloc::string::String" ]
                                  |),
                                  [ generics ]
                                |)
                              ]
                          |))
                      ]
                    |)
                  ]
                |)
              |) in
            res
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_to_canonical_string :
      M.IsAssociatedFunction Self "to_canonical_string" to_canonical_string.
  End Impl_move_core_types_language_storage_StructTag.
  
  Module Impl_core_str_traits_FromStr_for_move_core_types_language_storage_StructTag.
    Definition Self : Ty.t := Ty.path "move_core_types::language_storage::StructTag".
    
    (*     type Err = anyhow::Error; *)
    Definition _Err : Ty.t := Ty.path "anyhow::Error".
    
    (*
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            parse_struct_tag(s)
        }
    *)
    Definition from_str (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ s ] =>
        ltac:(M.monadic
          (let s := M.alloc (| s |) in
          M.call_closure (|
            M.get_function (| "move_core_types::parser::parse_struct_tag", [] |),
            [ M.read (| s |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::str::traits::FromStr"
        Self
        (* Trait polymorphic types *) []
        (* Instance *)
        [ ("Err", InstanceField.Ty _Err); ("from_str", InstanceField.Method from_str) ].
  End Impl_core_str_traits_FromStr_for_move_core_types_language_storage_StructTag.
  
  (* StructRecord
    {
      name := "ResourceKey";
      ty_params := [];
      fields :=
        [
          ("address", Ty.path "move_core_types::account_address::AccountAddress");
          ("type_", Ty.path "move_core_types::language_storage::StructTag")
        ];
    } *)
  
  Module Wrap_underscore_5.
  Module underscore.
    Module Impl_serde_ser_Serialize_for_move_core_types_language_storage_ResourceKey.
      Definition Self : Ty.t := Ty.path "move_core_types::language_storage::ResourceKey".
      
      (* Serialize *)
      Definition serialize (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ __S ], [ self; __serializer ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let __serializer := M.alloc (| __serializer |) in
            M.read (|
              let __serde_state :=
                M.copy (|
                  M.match_operator (|
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "serde::ser::Serializer",
                          __S,
                          [],
                          "serialize_struct",
                          []
                        |),
                        [
                          M.read (| __serializer |);
                          M.read (| mk_str "ResourceKey" |);
                          BinOp.Panic.add (|
                            BinOp.Panic.add (|
                              M.rust_cast (Value.Bool false),
                              Value.Integer Integer.Usize 1
                            |),
                            Value.Integer Integer.Usize 1
                          |)
                        ]
                      |)
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.get_struct_tuple_field_or_break_match (|
                              γ,
                              "core::result::Result::Ok",
                              0
                            |) in
                          let __val := M.copy (| γ0_0 |) in
                          __val));
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.get_struct_tuple_field_or_break_match (|
                              γ,
                              "core::result::Result::Err",
                              0
                            |) in
                          let __err := M.copy (| γ0_0 |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  Value.StructTuple
                                    "core::result::Result::Err"
                                    [ M.read (| __err |) ]
                                |)
                              |)
                            |)
                          |)))
                    ]
                  |)
                |) in
              let _ :=
                M.match_operator (|
                  M.alloc (|
                    M.call_closure (|
                      M.get_trait_method (|
                        "serde::ser::SerializeStruct",
                        Ty.associated,
                        [],
                        "serialize_field",
                        [ Ty.path "move_core_types::account_address::AccountAddress" ]
                      |),
                      [
                        __serde_state;
                        M.read (| mk_str "address" |);
                        M.get_struct_record_field
                          (M.read (| self |))
                          "move_core_types::language_storage::ResourceKey"
                          "address"
                      ]
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.get_struct_tuple_field_or_break_match (|
                            γ,
                            "core::result::Result::Ok",
                            0
                          |) in
                        let __val := M.copy (| γ0_0 |) in
                        __val));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.get_struct_tuple_field_or_break_match (|
                            γ,
                            "core::result::Result::Err",
                            0
                          |) in
                        let __err := M.copy (| γ0_0 |) in
                        M.alloc (|
                          M.never_to_any (|
                            M.read (|
                              M.return_ (|
                                Value.StructTuple "core::result::Result::Err" [ M.read (| __err |) ]
                              |)
                            |)
                          |)
                        |)))
                  ]
                |) in
              let _ :=
                M.match_operator (|
                  M.alloc (|
                    M.call_closure (|
                      M.get_trait_method (|
                        "serde::ser::SerializeStruct",
                        Ty.associated,
                        [],
                        "serialize_field",
                        [ Ty.path "move_core_types::language_storage::StructTag" ]
                      |),
                      [
                        __serde_state;
                        M.read (| mk_str "type_" |);
                        M.get_struct_record_field
                          (M.read (| self |))
                          "move_core_types::language_storage::ResourceKey"
                          "type_"
                      ]
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.get_struct_tuple_field_or_break_match (|
                            γ,
                            "core::result::Result::Ok",
                            0
                          |) in
                        let __val := M.copy (| γ0_0 |) in
                        __val));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.get_struct_tuple_field_or_break_match (|
                            γ,
                            "core::result::Result::Err",
                            0
                          |) in
                        let __err := M.copy (| γ0_0 |) in
                        M.alloc (|
                          M.never_to_any (|
                            M.read (|
                              M.return_ (|
                                Value.StructTuple "core::result::Result::Err" [ M.read (| __err |) ]
                              |)
                            |)
                          |)
                        |)))
                  ]
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "serde::ser::SerializeStruct",
                    Ty.associated,
                    [],
                    "end",
                    []
                  |),
                  [ M.read (| __serde_state |) ]
                |)
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "serde::ser::Serialize"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("serialize", InstanceField.Method serialize) ].
    End Impl_serde_ser_Serialize_for_move_core_types_language_storage_ResourceKey.
  End underscore.
  End Wrap_underscore_5.
  Import Wrap_underscore_5.
  
  Module Wrap_underscore_6.
  Module underscore.
    Module Impl_serde_de_Deserialize_for_move_core_types_language_storage_ResourceKey.
      Definition Self : Ty.t := Ty.path "move_core_types::language_storage::ResourceKey".
      
      (* Deserialize *)
      Definition deserialize (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ __D ], [ __deserializer ] =>
          ltac:(M.monadic
            (let __deserializer := M.alloc (| __deserializer |) in
            M.call_closure (|
              M.get_trait_method (|
                "serde::de::Deserializer",
                __D,
                [],
                "deserialize_struct",
                [ Ty.path "move_core_types::language_storage::_'5::deserialize::__Visitor" ]
              |),
              [
                M.read (| __deserializer |);
                M.read (| mk_str "ResourceKey" |);
                M.read (|
                  M.get_constant (| "move_core_types::language_storage::_'5::deserialize::FIELDS" |)
                |);
                Value.StructRecord
                  "move_core_types::language_storage::_'5::deserialize::__Visitor"
                  [
                    ("marker", Value.StructTuple "core::marker::PhantomData" []);
                    ("lifetime", Value.StructTuple "core::marker::PhantomData" [])
                  ]
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "serde::de::Deserialize"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("deserialize", InstanceField.Method deserialize) ].
    End Impl_serde_de_Deserialize_for_move_core_types_language_storage_ResourceKey.
  End underscore.
  End Wrap_underscore_6.
  Import Wrap_underscore_6.
  
  Module Impl_core_fmt_Debug_for_move_core_types_language_storage_ResourceKey.
    Definition Self : Ty.t := Ty.path "move_core_types::language_storage::ResourceKey".
    
    (* Debug *)
    Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.path "core::fmt::Formatter",
              "debug_struct_field2_finish",
              []
            |),
            [
              M.read (| f |);
              M.read (| mk_str "ResourceKey" |);
              M.read (| mk_str "address" |);
              (* Unsize *)
              M.pointer_coercion
                (M.get_struct_record_field
                  (M.read (| self |))
                  "move_core_types::language_storage::ResourceKey"
                  "address");
              M.read (| mk_str "type_" |);
              (* Unsize *)
              M.pointer_coercion
                (M.alloc (|
                  M.get_struct_record_field
                    (M.read (| self |))
                    "move_core_types::language_storage::ResourceKey"
                    "type_"
                |))
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_move_core_types_language_storage_ResourceKey.
  
  Module Impl_core_marker_StructuralPartialEq_for_move_core_types_language_storage_ResourceKey.
    Definition Self : Ty.t := Ty.path "move_core_types::language_storage::ResourceKey".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_move_core_types_language_storage_ResourceKey.
  
  Module Impl_core_cmp_PartialEq_for_move_core_types_language_storage_ResourceKey.
    Definition Self : Ty.t := Ty.path "move_core_types::language_storage::ResourceKey".
    
    (* PartialEq *)
    Definition eq (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          LogicalOp.and (|
            M.call_closure (|
              M.get_trait_method (|
                "core::cmp::PartialEq",
                Ty.path "move_core_types::account_address::AccountAddress",
                [ Ty.path "move_core_types::account_address::AccountAddress" ],
                "eq",
                []
              |),
              [
                M.get_struct_record_field
                  (M.read (| self |))
                  "move_core_types::language_storage::ResourceKey"
                  "address";
                M.get_struct_record_field
                  (M.read (| other |))
                  "move_core_types::language_storage::ResourceKey"
                  "address"
              ]
            |),
            ltac:(M.monadic
              (M.call_closure (|
                M.get_trait_method (|
                  "core::cmp::PartialEq",
                  Ty.path "move_core_types::language_storage::StructTag",
                  [ Ty.path "move_core_types::language_storage::StructTag" ],
                  "eq",
                  []
                |),
                [
                  M.get_struct_record_field
                    (M.read (| self |))
                    "move_core_types::language_storage::ResourceKey"
                    "type_";
                  M.get_struct_record_field
                    (M.read (| other |))
                    "move_core_types::language_storage::ResourceKey"
                    "type_"
                ]
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_for_move_core_types_language_storage_ResourceKey.
  
  Module Impl_core_hash_Hash_for_move_core_types_language_storage_ResourceKey.
    Definition Self : Ty.t := Ty.path "move_core_types::language_storage::ResourceKey".
    
    (* Hash *)
    Definition hash (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ __H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let state := M.alloc (| state |) in
          M.read (|
            let _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "core::hash::Hash",
                    Ty.path "move_core_types::account_address::AccountAddress",
                    [],
                    "hash",
                    [ __H ]
                  |),
                  [
                    M.get_struct_record_field
                      (M.read (| self |))
                      "move_core_types::language_storage::ResourceKey"
                      "address";
                    M.read (| state |)
                  ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                M.get_trait_method (|
                  "core::hash::Hash",
                  Ty.path "move_core_types::language_storage::StructTag",
                  [],
                  "hash",
                  [ __H ]
                |),
                [
                  M.get_struct_record_field
                    (M.read (| self |))
                    "move_core_types::language_storage::ResourceKey"
                    "type_";
                  M.read (| state |)
                ]
              |)
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::hash::Hash"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("hash", InstanceField.Method hash) ].
  End Impl_core_hash_Hash_for_move_core_types_language_storage_ResourceKey.
  
  Module Impl_core_marker_StructuralEq_for_move_core_types_language_storage_ResourceKey.
    Definition Self : Ty.t := Ty.path "move_core_types::language_storage::ResourceKey".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralEq_for_move_core_types_language_storage_ResourceKey.
  
  Module Impl_core_cmp_Eq_for_move_core_types_language_storage_ResourceKey.
    Definition Self : Ty.t := Ty.path "move_core_types::language_storage::ResourceKey".
    
    (* Eq *)
    Definition assert_receiver_is_total_eq (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Value.DeclaredButUndefined,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      Value.DeclaredButUndefined,
                      [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_move_core_types_language_storage_ResourceKey.
  
  Module Impl_core_clone_Clone_for_move_core_types_language_storage_ResourceKey.
    Definition Self : Ty.t := Ty.path "move_core_types::language_storage::ResourceKey".
    
    (* Clone *)
    Definition clone (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.StructRecord
            "move_core_types::language_storage::ResourceKey"
            [
              ("address",
                M.call_closure (|
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.path "move_core_types::account_address::AccountAddress",
                    [],
                    "clone",
                    []
                  |),
                  [
                    M.get_struct_record_field
                      (M.read (| self |))
                      "move_core_types::language_storage::ResourceKey"
                      "address"
                  ]
                |));
              ("type_",
                M.call_closure (|
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.path "move_core_types::language_storage::StructTag",
                    [],
                    "clone",
                    []
                  |),
                  [
                    M.get_struct_record_field
                      (M.read (| self |))
                      "move_core_types::language_storage::ResourceKey"
                      "type_"
                  ]
                |))
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_move_core_types_language_storage_ResourceKey.
  
  Module Impl_core_cmp_PartialOrd_for_move_core_types_language_storage_ResourceKey.
    Definition Self : Ty.t := Ty.path "move_core_types::language_storage::ResourceKey".
    
    (* PartialOrd *)
    Definition partial_cmp (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "core::cmp::PartialOrd",
                    Ty.path "move_core_types::account_address::AccountAddress",
                    [ Ty.path "move_core_types::account_address::AccountAddress" ],
                    "partial_cmp",
                    []
                  |),
                  [
                    M.get_struct_record_field
                      (M.read (| self |))
                      "move_core_types::language_storage::ResourceKey"
                      "address";
                    M.get_struct_record_field
                      (M.read (| other |))
                      "move_core_types::language_storage::ResourceKey"
                      "address"
                  ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::cmp::PartialOrd",
                          Ty.path "move_core_types::language_storage::StructTag",
                          [ Ty.path "move_core_types::language_storage::StructTag" ],
                          "partial_cmp",
                          []
                        |),
                        [
                          M.get_struct_record_field
                            (M.read (| self |))
                            "move_core_types::language_storage::ResourceKey"
                            "type_";
                          M.get_struct_record_field
                            (M.read (| other |))
                            "move_core_types::language_storage::ResourceKey"
                            "type_"
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let cmp := M.copy (| γ |) in
                    cmp))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialOrd"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("partial_cmp", InstanceField.Method partial_cmp) ].
  End Impl_core_cmp_PartialOrd_for_move_core_types_language_storage_ResourceKey.
  
  Module Impl_core_cmp_Ord_for_move_core_types_language_storage_ResourceKey.
    Definition Self : Ty.t := Ty.path "move_core_types::language_storage::ResourceKey".
    
    (* Ord *)
    Definition cmp (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "core::cmp::Ord",
                    Ty.path "move_core_types::account_address::AccountAddress",
                    [],
                    "cmp",
                    []
                  |),
                  [
                    M.get_struct_record_field
                      (M.read (| self |))
                      "move_core_types::language_storage::ResourceKey"
                      "address";
                    M.get_struct_record_field
                      (M.read (| other |))
                      "move_core_types::language_storage::ResourceKey"
                      "address"
                  ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::cmp::Ord",
                          Ty.path "move_core_types::language_storage::StructTag",
                          [],
                          "cmp",
                          []
                        |),
                        [
                          M.get_struct_record_field
                            (M.read (| self |))
                            "move_core_types::language_storage::ResourceKey"
                            "type_";
                          M.get_struct_record_field
                            (M.read (| other |))
                            "move_core_types::language_storage::ResourceKey"
                            "type_"
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let cmp := M.copy (| γ |) in
                    cmp))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Ord"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("cmp", InstanceField.Method cmp) ].
  End Impl_core_cmp_Ord_for_move_core_types_language_storage_ResourceKey.
  
  Module Impl_move_core_types_language_storage_ResourceKey.
    Definition Self : Ty.t := Ty.path "move_core_types::language_storage::ResourceKey".
    
    (*
        pub fn address(&self) -> AccountAddress {
            self.address
        }
    *)
    Definition address (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.get_struct_record_field
              (M.read (| self |))
              "move_core_types::language_storage::ResourceKey"
              "address"
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_address : M.IsAssociatedFunction Self "address" address.
    
    (*
        pub fn type_(&self) -> &StructTag {
            &self.type_
        }
    *)
    Definition type_ (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.get_struct_record_field
            (M.read (| self |))
            "move_core_types::language_storage::ResourceKey"
            "type_"))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_type_ : M.IsAssociatedFunction Self "type_" type_.
  End Impl_move_core_types_language_storage_ResourceKey.
  
  Module Wrap_Impl_move_core_types_language_storage_ResourceKey_2.
  Module Impl_move_core_types_language_storage_ResourceKey.
    Definition Self : Ty.t := Ty.path "move_core_types::language_storage::ResourceKey".
    
    (*
        pub fn new(address: AccountAddress, type_: StructTag) -> Self {
            ResourceKey { address, type_ }
        }
    *)
    Definition new (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ address; type_ ] =>
        ltac:(M.monadic
          (let address := M.alloc (| address |) in
          let type_ := M.alloc (| type_ |) in
          Value.StructRecord
            "move_core_types::language_storage::ResourceKey"
            [ ("address", M.read (| address |)); ("type_", M.read (| type_ |)) ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_new : M.IsAssociatedFunction Self "new" new.
  End Impl_move_core_types_language_storage_ResourceKey.
  End Wrap_Impl_move_core_types_language_storage_ResourceKey_2.
  Import Wrap_Impl_move_core_types_language_storage_ResourceKey_2.
  
  (* StructRecord
    {
      name := "ModuleId";
      ty_params := [];
      fields :=
        [
          ("address", Ty.path "move_core_types::account_address::AccountAddress");
          ("name", Ty.path "move_core_types::identifier::Identifier")
        ];
    } *)
  
  Module Wrap_underscore_7.
  Module underscore.
    Module Impl_serde_ser_Serialize_for_move_core_types_language_storage_ModuleId.
      Definition Self : Ty.t := Ty.path "move_core_types::language_storage::ModuleId".
      
      (* Serialize *)
      Definition serialize (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ __S ], [ self; __serializer ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let __serializer := M.alloc (| __serializer |) in
            M.read (|
              let __serde_state :=
                M.copy (|
                  M.match_operator (|
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "serde::ser::Serializer",
                          __S,
                          [],
                          "serialize_struct",
                          []
                        |),
                        [
                          M.read (| __serializer |);
                          M.read (| mk_str "ModuleId" |);
                          BinOp.Panic.add (|
                            BinOp.Panic.add (|
                              M.rust_cast (Value.Bool false),
                              Value.Integer Integer.Usize 1
                            |),
                            Value.Integer Integer.Usize 1
                          |)
                        ]
                      |)
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.get_struct_tuple_field_or_break_match (|
                              γ,
                              "core::result::Result::Ok",
                              0
                            |) in
                          let __val := M.copy (| γ0_0 |) in
                          __val));
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.get_struct_tuple_field_or_break_match (|
                              γ,
                              "core::result::Result::Err",
                              0
                            |) in
                          let __err := M.copy (| γ0_0 |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  Value.StructTuple
                                    "core::result::Result::Err"
                                    [ M.read (| __err |) ]
                                |)
                              |)
                            |)
                          |)))
                    ]
                  |)
                |) in
              let _ :=
                M.match_operator (|
                  M.alloc (|
                    M.call_closure (|
                      M.get_trait_method (|
                        "serde::ser::SerializeStruct",
                        Ty.associated,
                        [],
                        "serialize_field",
                        [ Ty.path "move_core_types::account_address::AccountAddress" ]
                      |),
                      [
                        __serde_state;
                        M.read (| mk_str "address" |);
                        M.get_struct_record_field
                          (M.read (| self |))
                          "move_core_types::language_storage::ModuleId"
                          "address"
                      ]
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.get_struct_tuple_field_or_break_match (|
                            γ,
                            "core::result::Result::Ok",
                            0
                          |) in
                        let __val := M.copy (| γ0_0 |) in
                        __val));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.get_struct_tuple_field_or_break_match (|
                            γ,
                            "core::result::Result::Err",
                            0
                          |) in
                        let __err := M.copy (| γ0_0 |) in
                        M.alloc (|
                          M.never_to_any (|
                            M.read (|
                              M.return_ (|
                                Value.StructTuple "core::result::Result::Err" [ M.read (| __err |) ]
                              |)
                            |)
                          |)
                        |)))
                  ]
                |) in
              let _ :=
                M.match_operator (|
                  M.alloc (|
                    M.call_closure (|
                      M.get_trait_method (|
                        "serde::ser::SerializeStruct",
                        Ty.associated,
                        [],
                        "serialize_field",
                        [ Ty.path "move_core_types::identifier::Identifier" ]
                      |),
                      [
                        __serde_state;
                        M.read (| mk_str "name" |);
                        M.get_struct_record_field
                          (M.read (| self |))
                          "move_core_types::language_storage::ModuleId"
                          "name"
                      ]
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.get_struct_tuple_field_or_break_match (|
                            γ,
                            "core::result::Result::Ok",
                            0
                          |) in
                        let __val := M.copy (| γ0_0 |) in
                        __val));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.get_struct_tuple_field_or_break_match (|
                            γ,
                            "core::result::Result::Err",
                            0
                          |) in
                        let __err := M.copy (| γ0_0 |) in
                        M.alloc (|
                          M.never_to_any (|
                            M.read (|
                              M.return_ (|
                                Value.StructTuple "core::result::Result::Err" [ M.read (| __err |) ]
                              |)
                            |)
                          |)
                        |)))
                  ]
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "serde::ser::SerializeStruct",
                    Ty.associated,
                    [],
                    "end",
                    []
                  |),
                  [ M.read (| __serde_state |) ]
                |)
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "serde::ser::Serialize"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("serialize", InstanceField.Method serialize) ].
    End Impl_serde_ser_Serialize_for_move_core_types_language_storage_ModuleId.
  End underscore.
  End Wrap_underscore_7.
  Import Wrap_underscore_7.
  
  Module Wrap_underscore_8.
  Module underscore.
    Module Impl_serde_de_Deserialize_for_move_core_types_language_storage_ModuleId.
      Definition Self : Ty.t := Ty.path "move_core_types::language_storage::ModuleId".
      
      (* Deserialize *)
      Definition deserialize (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ __D ], [ __deserializer ] =>
          ltac:(M.monadic
            (let __deserializer := M.alloc (| __deserializer |) in
            M.call_closure (|
              M.get_trait_method (|
                "serde::de::Deserializer",
                __D,
                [],
                "deserialize_struct",
                [ Ty.path "move_core_types::language_storage::_'7::deserialize::__Visitor" ]
              |),
              [
                M.read (| __deserializer |);
                M.read (| mk_str "ModuleId" |);
                M.read (|
                  M.get_constant (| "move_core_types::language_storage::_'7::deserialize::FIELDS" |)
                |);
                Value.StructRecord
                  "move_core_types::language_storage::_'7::deserialize::__Visitor"
                  [
                    ("marker", Value.StructTuple "core::marker::PhantomData" []);
                    ("lifetime", Value.StructTuple "core::marker::PhantomData" [])
                  ]
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "serde::de::Deserialize"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("deserialize", InstanceField.Method deserialize) ].
    End Impl_serde_de_Deserialize_for_move_core_types_language_storage_ModuleId.
  End underscore.
  End Wrap_underscore_8.
  Import Wrap_underscore_8.
  
  Module Impl_core_fmt_Debug_for_move_core_types_language_storage_ModuleId.
    Definition Self : Ty.t := Ty.path "move_core_types::language_storage::ModuleId".
    
    (* Debug *)
    Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.path "core::fmt::Formatter",
              "debug_struct_field2_finish",
              []
            |),
            [
              M.read (| f |);
              M.read (| mk_str "ModuleId" |);
              M.read (| mk_str "address" |);
              (* Unsize *)
              M.pointer_coercion
                (M.get_struct_record_field
                  (M.read (| self |))
                  "move_core_types::language_storage::ModuleId"
                  "address");
              M.read (| mk_str "name" |);
              (* Unsize *)
              M.pointer_coercion
                (M.alloc (|
                  M.get_struct_record_field
                    (M.read (| self |))
                    "move_core_types::language_storage::ModuleId"
                    "name"
                |))
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_move_core_types_language_storage_ModuleId.
  
  Module Impl_core_marker_StructuralPartialEq_for_move_core_types_language_storage_ModuleId.
    Definition Self : Ty.t := Ty.path "move_core_types::language_storage::ModuleId".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_move_core_types_language_storage_ModuleId.
  
  Module Impl_core_cmp_PartialEq_for_move_core_types_language_storage_ModuleId.
    Definition Self : Ty.t := Ty.path "move_core_types::language_storage::ModuleId".
    
    (* PartialEq *)
    Definition eq (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          LogicalOp.and (|
            M.call_closure (|
              M.get_trait_method (|
                "core::cmp::PartialEq",
                Ty.path "move_core_types::account_address::AccountAddress",
                [ Ty.path "move_core_types::account_address::AccountAddress" ],
                "eq",
                []
              |),
              [
                M.get_struct_record_field
                  (M.read (| self |))
                  "move_core_types::language_storage::ModuleId"
                  "address";
                M.get_struct_record_field
                  (M.read (| other |))
                  "move_core_types::language_storage::ModuleId"
                  "address"
              ]
            |),
            ltac:(M.monadic
              (M.call_closure (|
                M.get_trait_method (|
                  "core::cmp::PartialEq",
                  Ty.path "move_core_types::identifier::Identifier",
                  [ Ty.path "move_core_types::identifier::Identifier" ],
                  "eq",
                  []
                |),
                [
                  M.get_struct_record_field
                    (M.read (| self |))
                    "move_core_types::language_storage::ModuleId"
                    "name";
                  M.get_struct_record_field
                    (M.read (| other |))
                    "move_core_types::language_storage::ModuleId"
                    "name"
                ]
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_for_move_core_types_language_storage_ModuleId.
  
  Module Impl_core_hash_Hash_for_move_core_types_language_storage_ModuleId.
    Definition Self : Ty.t := Ty.path "move_core_types::language_storage::ModuleId".
    
    (* Hash *)
    Definition hash (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ __H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let state := M.alloc (| state |) in
          M.read (|
            let _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "core::hash::Hash",
                    Ty.path "move_core_types::account_address::AccountAddress",
                    [],
                    "hash",
                    [ __H ]
                  |),
                  [
                    M.get_struct_record_field
                      (M.read (| self |))
                      "move_core_types::language_storage::ModuleId"
                      "address";
                    M.read (| state |)
                  ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                M.get_trait_method (|
                  "core::hash::Hash",
                  Ty.path "move_core_types::identifier::Identifier",
                  [],
                  "hash",
                  [ __H ]
                |),
                [
                  M.get_struct_record_field
                    (M.read (| self |))
                    "move_core_types::language_storage::ModuleId"
                    "name";
                  M.read (| state |)
                ]
              |)
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::hash::Hash"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("hash", InstanceField.Method hash) ].
  End Impl_core_hash_Hash_for_move_core_types_language_storage_ModuleId.
  
  Module Impl_core_marker_StructuralEq_for_move_core_types_language_storage_ModuleId.
    Definition Self : Ty.t := Ty.path "move_core_types::language_storage::ModuleId".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralEq_for_move_core_types_language_storage_ModuleId.
  
  Module Impl_core_cmp_Eq_for_move_core_types_language_storage_ModuleId.
    Definition Self : Ty.t := Ty.path "move_core_types::language_storage::ModuleId".
    
    (* Eq *)
    Definition assert_receiver_is_total_eq (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Value.DeclaredButUndefined,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      Value.DeclaredButUndefined,
                      [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_move_core_types_language_storage_ModuleId.
  
  Module Impl_core_clone_Clone_for_move_core_types_language_storage_ModuleId.
    Definition Self : Ty.t := Ty.path "move_core_types::language_storage::ModuleId".
    
    (* Clone *)
    Definition clone (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.StructRecord
            "move_core_types::language_storage::ModuleId"
            [
              ("address",
                M.call_closure (|
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.path "move_core_types::account_address::AccountAddress",
                    [],
                    "clone",
                    []
                  |),
                  [
                    M.get_struct_record_field
                      (M.read (| self |))
                      "move_core_types::language_storage::ModuleId"
                      "address"
                  ]
                |));
              ("name",
                M.call_closure (|
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.path "move_core_types::identifier::Identifier",
                    [],
                    "clone",
                    []
                  |),
                  [
                    M.get_struct_record_field
                      (M.read (| self |))
                      "move_core_types::language_storage::ModuleId"
                      "name"
                  ]
                |))
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_move_core_types_language_storage_ModuleId.
  
  Module Impl_core_cmp_PartialOrd_for_move_core_types_language_storage_ModuleId.
    Definition Self : Ty.t := Ty.path "move_core_types::language_storage::ModuleId".
    
    (* PartialOrd *)
    Definition partial_cmp (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "core::cmp::PartialOrd",
                    Ty.path "move_core_types::account_address::AccountAddress",
                    [ Ty.path "move_core_types::account_address::AccountAddress" ],
                    "partial_cmp",
                    []
                  |),
                  [
                    M.get_struct_record_field
                      (M.read (| self |))
                      "move_core_types::language_storage::ModuleId"
                      "address";
                    M.get_struct_record_field
                      (M.read (| other |))
                      "move_core_types::language_storage::ModuleId"
                      "address"
                  ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::cmp::PartialOrd",
                          Ty.path "move_core_types::identifier::Identifier",
                          [ Ty.path "move_core_types::identifier::Identifier" ],
                          "partial_cmp",
                          []
                        |),
                        [
                          M.get_struct_record_field
                            (M.read (| self |))
                            "move_core_types::language_storage::ModuleId"
                            "name";
                          M.get_struct_record_field
                            (M.read (| other |))
                            "move_core_types::language_storage::ModuleId"
                            "name"
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let cmp := M.copy (| γ |) in
                    cmp))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialOrd"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("partial_cmp", InstanceField.Method partial_cmp) ].
  End Impl_core_cmp_PartialOrd_for_move_core_types_language_storage_ModuleId.
  
  Module Impl_core_cmp_Ord_for_move_core_types_language_storage_ModuleId.
    Definition Self : Ty.t := Ty.path "move_core_types::language_storage::ModuleId".
    
    (* Ord *)
    Definition cmp (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "core::cmp::Ord",
                    Ty.path "move_core_types::account_address::AccountAddress",
                    [],
                    "cmp",
                    []
                  |),
                  [
                    M.get_struct_record_field
                      (M.read (| self |))
                      "move_core_types::language_storage::ModuleId"
                      "address";
                    M.get_struct_record_field
                      (M.read (| other |))
                      "move_core_types::language_storage::ModuleId"
                      "address"
                  ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::cmp::Ord",
                          Ty.path "move_core_types::identifier::Identifier",
                          [],
                          "cmp",
                          []
                        |),
                        [
                          M.get_struct_record_field
                            (M.read (| self |))
                            "move_core_types::language_storage::ModuleId"
                            "name";
                          M.get_struct_record_field
                            (M.read (| other |))
                            "move_core_types::language_storage::ModuleId"
                            "name"
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let cmp := M.copy (| γ |) in
                    cmp))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Ord"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("cmp", InstanceField.Method cmp) ].
  End Impl_core_cmp_Ord_for_move_core_types_language_storage_ModuleId.
  
  Module Impl_core_convert_From_move_core_types_language_storage_ModuleId_for_Tuple_move_core_types_account_address_AccountAddress_move_core_types_identifier_Identifier_.
    Definition Self : Ty.t :=
      Ty.tuple
        [
          Ty.path "move_core_types::account_address::AccountAddress";
          Ty.path "move_core_types::identifier::Identifier"
        ].
    
    (*
        fn from(module_id: ModuleId) -> Self {
            (module_id.address, module_id.name)
        }
    *)
    Definition from (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ module_id ] =>
        ltac:(M.monadic
          (let module_id := M.alloc (| module_id |) in
          Value.Tuple
            [
              M.read (|
                M.get_struct_record_field
                  module_id
                  "move_core_types::language_storage::ModuleId"
                  "address"
              |);
              M.read (|
                M.get_struct_record_field
                  module_id
                  "move_core_types::language_storage::ModuleId"
                  "name"
              |)
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::convert::From"
        Self
        (* Trait polymorphic types *)
        [ (* T *) Ty.path "move_core_types::language_storage::ModuleId" ]
        (* Instance *) [ ("from", InstanceField.Method from) ].
  End Impl_core_convert_From_move_core_types_language_storage_ModuleId_for_Tuple_move_core_types_account_address_AccountAddress_move_core_types_identifier_Identifier_.
  
  Module Impl_move_core_types_language_storage_ModuleId.
    Definition Self : Ty.t := Ty.path "move_core_types::language_storage::ModuleId".
    
    (*
        pub fn new(address: AccountAddress, name: Identifier) -> Self {
            ModuleId { address, name }
        }
    *)
    Definition new (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ address; name ] =>
        ltac:(M.monadic
          (let address := M.alloc (| address |) in
          let name := M.alloc (| name |) in
          Value.StructRecord
            "move_core_types::language_storage::ModuleId"
            [ ("address", M.read (| address |)); ("name", M.read (| name |)) ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_new : M.IsAssociatedFunction Self "new" new.
    
    (*
        pub fn name(&self) -> &IdentStr {
            &self.name
        }
    *)
    Definition name (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::ops::deref::Deref",
              Ty.path "move_core_types::identifier::Identifier",
              [],
              "deref",
              []
            |),
            [
              M.get_struct_record_field
                (M.read (| self |))
                "move_core_types::language_storage::ModuleId"
                "name"
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_name : M.IsAssociatedFunction Self "name" name.
    
    (*
        pub fn address(&self) -> &AccountAddress {
            &self.address
        }
    *)
    Definition address (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.get_struct_record_field
            (M.read (| self |))
            "move_core_types::language_storage::ModuleId"
            "address"))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_address : M.IsAssociatedFunction Self "address" address.
    
    (*
        pub fn access_vector(&self) -> Vec<u8> {
            let mut key = vec![CODE_TAG];
            key.append(&mut bcs::to_bytes(self).unwrap());
            key
        }
    *)
    Definition access_vector (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let key :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "slice") [ Ty.path "u8" ],
                    "into_vec",
                    [ Ty.path "alloc::alloc::Global" ]
                  |),
                  [
                    (* Unsize *)
                    M.pointer_coercion
                      (M.read (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloc::boxed::Box")
                              [
                                Ty.apply (Ty.path "array") [ Ty.path "u8" ];
                                Ty.path "alloc::alloc::Global"
                              ],
                            "new",
                            []
                          |),
                          [
                            M.alloc (|
                              Value.Array
                                [
                                  M.read (|
                                    M.get_constant (|
                                      "move_core_types::language_storage::CODE_TAG"
                                    |)
                                  |)
                                ]
                            |)
                          ]
                        |)
                      |))
                  ]
                |)
              |) in
            let _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                    "append",
                    []
                  |),
                  [
                    key;
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "core::result::Result")
                            [
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ];
                              Ty.path "bcs::error::Error"
                            ],
                          "unwrap",
                          []
                        |),
                        [
                          M.call_closure (|
                            M.get_function (|
                              "bcs::ser::to_bytes",
                              [ Ty.path "move_core_types::language_storage::ModuleId" ]
                            |),
                            [ M.read (| self |) ]
                          |)
                        ]
                      |)
                    |)
                  ]
                |)
              |) in
            key
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_access_vector :
      M.IsAssociatedFunction Self "access_vector" access_vector.
  End Impl_move_core_types_language_storage_ModuleId.
  
  Module Impl_core_fmt_Display_for_move_core_types_language_storage_ModuleId.
    Definition Self : Ty.t := Ty.path "move_core_types::language_storage::ModuleId".
    
    (*
        fn fmt(&self, f: &mut Formatter) -> std::fmt::Result {
            write!(f, "{}::{}", self.address, self.name)
        }
    *)
    Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_fmt", [] |),
            [
              M.read (| f |);
              M.call_closure (|
                M.get_associated_function (| Ty.path "core::fmt::Arguments", "new_v1", [] |),
                [
                  (* Unsize *)
                  M.pointer_coercion
                    (M.alloc (|
                      Value.Array [ M.read (| mk_str "" |); M.read (| mk_str "::" |) ]
                    |));
                  (* Unsize *)
                  M.pointer_coercion
                    (M.alloc (|
                      Value.Array
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::rt::Argument",
                              "new_display",
                              [ Ty.path "move_core_types::account_address::AccountAddress" ]
                            |),
                            [
                              M.get_struct_record_field
                                (M.read (| self |))
                                "move_core_types::language_storage::ModuleId"
                                "address"
                            ]
                          |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::rt::Argument",
                              "new_display",
                              [ Ty.path "move_core_types::identifier::Identifier" ]
                            |),
                            [
                              M.get_struct_record_field
                                (M.read (| self |))
                                "move_core_types::language_storage::ModuleId"
                                "name"
                            ]
                          |)
                        ]
                    |))
                ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Display"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Display_for_move_core_types_language_storage_ModuleId.
  
  Module Wrap_Impl_move_core_types_language_storage_ModuleId_2.
  Module Impl_move_core_types_language_storage_ModuleId.
    Definition Self : Ty.t := Ty.path "move_core_types::language_storage::ModuleId".
    
    (*
        pub fn short_str_lossless(&self) -> String {
            format!("0x{}::{}", self.address.short_str_lossless(), self.name)
        }
    *)
    Definition short_str_lossless (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let res :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (| "alloc::fmt::format", [] |),
                  [
                    M.call_closure (|
                      M.get_associated_function (| Ty.path "core::fmt::Arguments", "new_v1", [] |),
                      [
                        (* Unsize *)
                        M.pointer_coercion
                          (M.alloc (|
                            Value.Array [ M.read (| mk_str "0x" |); M.read (| mk_str "::" |) ]
                          |));
                        (* Unsize *)
                        M.pointer_coercion
                          (M.alloc (|
                            Value.Array
                              [
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.path "core::fmt::rt::Argument",
                                    "new_display",
                                    [ Ty.path "alloc::string::String" ]
                                  |),
                                  [
                                    M.alloc (|
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.path
                                            "move_core_types::account_address::AccountAddress",
                                          "short_str_lossless",
                                          []
                                        |),
                                        [
                                          M.get_struct_record_field
                                            (M.read (| self |))
                                            "move_core_types::language_storage::ModuleId"
                                            "address"
                                        ]
                                      |)
                                    |)
                                  ]
                                |);
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.path "core::fmt::rt::Argument",
                                    "new_display",
                                    [ Ty.path "move_core_types::identifier::Identifier" ]
                                  |),
                                  [
                                    M.get_struct_record_field
                                      (M.read (| self |))
                                      "move_core_types::language_storage::ModuleId"
                                      "name"
                                  ]
                                |)
                              ]
                          |))
                      ]
                    |)
                  ]
                |)
              |) in
            res
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_short_str_lossless :
      M.IsAssociatedFunction Self "short_str_lossless" short_str_lossless.
  End Impl_move_core_types_language_storage_ModuleId.
  End Wrap_Impl_move_core_types_language_storage_ModuleId_2.
  Import Wrap_Impl_move_core_types_language_storage_ModuleId_2.
  
  Module Impl_core_fmt_Display_for_move_core_types_language_storage_StructTag.
    Definition Self : Ty.t := Ty.path "move_core_types::language_storage::StructTag".
    
    (*
        fn fmt(&self, f: &mut Formatter) -> std::fmt::Result {
            write!(
                f,
                "0x{}::{}::{}",
                self.address.short_str_lossless(),
                self.module,
                self.name
            )?;
            if let Some(first_ty) = self.type_params.first() {
                write!(f, "<")?;
                write!(f, "{}", first_ty)?;
                for ty in self.type_params.iter().skip(1) {
                    write!(f, ", {}", ty)?;
                }
                write!(f, ">")?;
            }
            Ok(())
        }
    *)
    Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.read (|
            let _ :=
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::try_trait::Try",
                      Ty.apply
                        (Ty.path "core::result::Result")
                        [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                      [],
                      "branch",
                      []
                    |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_v1",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (| mk_str "0x" |);
                                      M.read (| mk_str "::" |);
                                      M.read (| mk_str "::" |)
                                    ]
                                |));
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.path "core::fmt::rt::Argument",
                                          "new_display",
                                          [ Ty.path "alloc::string::String" ]
                                        |),
                                        [
                                          M.alloc (|
                                            M.call_closure (|
                                              M.get_associated_function (|
                                                Ty.path
                                                  "move_core_types::account_address::AccountAddress",
                                                "short_str_lossless",
                                                []
                                              |),
                                              [
                                                M.get_struct_record_field
                                                  (M.read (| self |))
                                                  "move_core_types::language_storage::StructTag"
                                                  "address"
                                              ]
                                            |)
                                          |)
                                        ]
                                      |);
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.path "core::fmt::rt::Argument",
                                          "new_display",
                                          [ Ty.path "move_core_types::identifier::Identifier" ]
                                        |),
                                        [
                                          M.get_struct_record_field
                                            (M.read (| self |))
                                            "move_core_types::language_storage::StructTag"
                                            "module"
                                        ]
                                      |);
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.path "core::fmt::rt::Argument",
                                          "new_display",
                                          [ Ty.path "move_core_types::identifier::Identifier" ]
                                        |),
                                        [
                                          M.get_struct_record_field
                                            (M.read (| self |))
                                            "move_core_types::language_storage::StructTag"
                                            "name"
                                        ]
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.get_struct_tuple_field_or_break_match (|
                          γ,
                          "core::ops::control_flow::ControlFlow::Break",
                          0
                        |) in
                      let residual := M.copy (| γ0_0 |) in
                      M.alloc (|
                        M.never_to_any (|
                          M.read (|
                            M.return_ (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::ops::try_trait::FromResidual",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path "core::fmt::Error"
                                      ]
                                  ],
                                  "from_residual",
                                  []
                                |),
                                [ M.read (| residual |) ]
                              |)
                            |)
                          |)
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.get_struct_tuple_field_or_break_match (|
                          γ,
                          "core::ops::control_flow::ControlFlow::Continue",
                          0
                        |) in
                      let val := M.copy (| γ0_0 |) in
                      val))
                ]
              |) in
            let _ :=
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "slice")
                                [ Ty.path "move_core_types::language_storage::TypeTag" ],
                              "first",
                              []
                            |),
                            [
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::ops::deref::Deref",
                                  Ty.apply
                                    (Ty.path "alloc::vec::Vec")
                                    [
                                      Ty.path "move_core_types::language_storage::TypeTag";
                                      Ty.path "alloc::alloc::Global"
                                    ],
                                  [],
                                  "deref",
                                  []
                                |),
                                [
                                  M.get_struct_record_field
                                    (M.read (| self |))
                                    "move_core_types::language_storage::StructTag"
                                    "type_params"
                                ]
                              |)
                            ]
                          |)
                        |) in
                      let γ0_0 :=
                        M.get_struct_tuple_field_or_break_match (|
                          γ,
                          "core::option::Option::Some",
                          0
                        |) in
                      let first_ty := M.copy (| γ0_0 |) in
                      let _ :=
                        M.match_operator (|
                          M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::ops::try_trait::Try",
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                                [],
                                "branch",
                                []
                              |),
                              [
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.path "core::fmt::Formatter",
                                    "write_fmt",
                                    []
                                  |),
                                  [
                                    M.read (| f |);
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.path "core::fmt::Arguments",
                                        "new_const",
                                        []
                                      |),
                                      [
                                        (* Unsize *)
                                        M.pointer_coercion
                                          (M.alloc (| Value.Array [ M.read (| mk_str "<" |) ] |))
                                      ]
                                    |)
                                  ]
                                |)
                              ]
                            |)
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.get_struct_tuple_field_or_break_match (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Break",
                                    0
                                  |) in
                                let residual := M.copy (| γ0_0 |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      M.return_ (|
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::ops::try_trait::FromResidual",
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                                            [
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                [
                                                  Ty.path "core::convert::Infallible";
                                                  Ty.path "core::fmt::Error"
                                                ]
                                            ],
                                            "from_residual",
                                            []
                                          |),
                                          [ M.read (| residual |) ]
                                        |)
                                      |)
                                    |)
                                  |)
                                |)));
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.get_struct_tuple_field_or_break_match (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Continue",
                                    0
                                  |) in
                                let val := M.copy (| γ0_0 |) in
                                val))
                          ]
                        |) in
                      let _ :=
                        M.match_operator (|
                          M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::ops::try_trait::Try",
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                                [],
                                "branch",
                                []
                              |),
                              [
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.path "core::fmt::Formatter",
                                    "write_fmt",
                                    []
                                  |),
                                  [
                                    M.read (| f |);
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.path "core::fmt::Arguments",
                                        "new_v1",
                                        []
                                      |),
                                      [
                                        (* Unsize *)
                                        M.pointer_coercion
                                          (M.alloc (| Value.Array [ M.read (| mk_str "" |) ] |));
                                        (* Unsize *)
                                        M.pointer_coercion
                                          (M.alloc (|
                                            Value.Array
                                              [
                                                M.call_closure (|
                                                  M.get_associated_function (|
                                                    Ty.path "core::fmt::rt::Argument",
                                                    "new_display",
                                                    [
                                                      Ty.apply
                                                        (Ty.path "&")
                                                        [
                                                          Ty.path
                                                            "move_core_types::language_storage::TypeTag"
                                                        ]
                                                    ]
                                                  |),
                                                  [ first_ty ]
                                                |)
                                              ]
                                          |))
                                      ]
                                    |)
                                  ]
                                |)
                              ]
                            |)
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.get_struct_tuple_field_or_break_match (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Break",
                                    0
                                  |) in
                                let residual := M.copy (| γ0_0 |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      M.return_ (|
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::ops::try_trait::FromResidual",
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                                            [
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                [
                                                  Ty.path "core::convert::Infallible";
                                                  Ty.path "core::fmt::Error"
                                                ]
                                            ],
                                            "from_residual",
                                            []
                                          |),
                                          [ M.read (| residual |) ]
                                        |)
                                      |)
                                    |)
                                  |)
                                |)));
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.get_struct_tuple_field_or_break_match (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Continue",
                                    0
                                  |) in
                                let val := M.copy (| γ0_0 |) in
                                val))
                          ]
                        |) in
                      let _ :=
                        M.use
                          (M.match_operator (|
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::iter::traits::collect::IntoIterator",
                                  Ty.apply
                                    (Ty.path "core::iter::adapters::skip::Skip")
                                    [
                                      Ty.apply
                                        (Ty.path "core::slice::iter::Iter")
                                        [ Ty.path "move_core_types::language_storage::TypeTag" ]
                                    ],
                                  [],
                                  "into_iter",
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::iter::traits::iterator::Iterator",
                                      Ty.apply
                                        (Ty.path "core::slice::iter::Iter")
                                        [ Ty.path "move_core_types::language_storage::TypeTag" ],
                                      [],
                                      "skip",
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "slice")
                                            [ Ty.path "move_core_types::language_storage::TypeTag"
                                            ],
                                          "iter",
                                          []
                                        |),
                                        [
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::deref::Deref",
                                              Ty.apply
                                                (Ty.path "alloc::vec::Vec")
                                                [
                                                  Ty.path
                                                    "move_core_types::language_storage::TypeTag";
                                                  Ty.path "alloc::alloc::Global"
                                                ],
                                              [],
                                              "deref",
                                              []
                                            |),
                                            [
                                              M.get_struct_record_field
                                                (M.read (| self |))
                                                "move_core_types::language_storage::StructTag"
                                                "type_params"
                                            ]
                                          |)
                                        ]
                                      |);
                                      Value.Integer Integer.Usize 1
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let iter := M.copy (| γ |) in
                                  M.loop (|
                                    ltac:(M.monadic
                                      (let _ :=
                                        M.match_operator (|
                                          M.alloc (|
                                            M.call_closure (|
                                              M.get_trait_method (|
                                                "core::iter::traits::iterator::Iterator",
                                                Ty.apply
                                                  (Ty.path "core::iter::adapters::skip::Skip")
                                                  [
                                                    Ty.apply
                                                      (Ty.path "core::slice::iter::Iter")
                                                      [
                                                        Ty.path
                                                          "move_core_types::language_storage::TypeTag"
                                                      ]
                                                  ],
                                                [],
                                                "next",
                                                []
                                              |),
                                              [ iter ]
                                            |)
                                          |),
                                          [
                                            fun γ =>
                                              ltac:(M.monadic
                                                (M.alloc (|
                                                  M.never_to_any (| M.read (| M.break (||) |) |)
                                                |)));
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let γ0_0 :=
                                                  M.get_struct_tuple_field_or_break_match (|
                                                    γ,
                                                    "core::option::Option::Some",
                                                    0
                                                  |) in
                                                let ty := M.copy (| γ0_0 |) in
                                                let _ :=
                                                  M.match_operator (|
                                                    M.alloc (|
                                                      M.call_closure (|
                                                        M.get_trait_method (|
                                                          "core::ops::try_trait::Try",
                                                          Ty.apply
                                                            (Ty.path "core::result::Result")
                                                            [
                                                              Ty.tuple [];
                                                              Ty.path "core::fmt::Error"
                                                            ],
                                                          [],
                                                          "branch",
                                                          []
                                                        |),
                                                        [
                                                          M.call_closure (|
                                                            M.get_associated_function (|
                                                              Ty.path "core::fmt::Formatter",
                                                              "write_fmt",
                                                              []
                                                            |),
                                                            [
                                                              M.read (| f |);
                                                              M.call_closure (|
                                                                M.get_associated_function (|
                                                                  Ty.path "core::fmt::Arguments",
                                                                  "new_v1",
                                                                  []
                                                                |),
                                                                [
                                                                  (* Unsize *)
                                                                  M.pointer_coercion
                                                                    (M.alloc (|
                                                                      Value.Array
                                                                        [ M.read (| mk_str ", " |) ]
                                                                    |));
                                                                  (* Unsize *)
                                                                  M.pointer_coercion
                                                                    (M.alloc (|
                                                                      Value.Array
                                                                        [
                                                                          M.call_closure (|
                                                                            M.get_associated_function (|
                                                                              Ty.path
                                                                                "core::fmt::rt::Argument",
                                                                              "new_display",
                                                                              [
                                                                                Ty.apply
                                                                                  (Ty.path "&")
                                                                                  [
                                                                                    Ty.path
                                                                                      "move_core_types::language_storage::TypeTag"
                                                                                  ]
                                                                              ]
                                                                            |),
                                                                            [ ty ]
                                                                          |)
                                                                        ]
                                                                    |))
                                                                ]
                                                              |)
                                                            ]
                                                          |)
                                                        ]
                                                      |)
                                                    |),
                                                    [
                                                      fun γ =>
                                                        ltac:(M.monadic
                                                          (let γ0_0 :=
                                                            M.get_struct_tuple_field_or_break_match (|
                                                              γ,
                                                              "core::ops::control_flow::ControlFlow::Break",
                                                              0
                                                            |) in
                                                          let residual := M.copy (| γ0_0 |) in
                                                          M.alloc (|
                                                            M.never_to_any (|
                                                              M.read (|
                                                                M.return_ (|
                                                                  M.call_closure (|
                                                                    M.get_trait_method (|
                                                                      "core::ops::try_trait::FromResidual",
                                                                      Ty.apply
                                                                        (Ty.path
                                                                          "core::result::Result")
                                                                        [
                                                                          Ty.tuple [];
                                                                          Ty.path "core::fmt::Error"
                                                                        ],
                                                                      [
                                                                        Ty.apply
                                                                          (Ty.path
                                                                            "core::result::Result")
                                                                          [
                                                                            Ty.path
                                                                              "core::convert::Infallible";
                                                                            Ty.path
                                                                              "core::fmt::Error"
                                                                          ]
                                                                      ],
                                                                      "from_residual",
                                                                      []
                                                                    |),
                                                                    [ M.read (| residual |) ]
                                                                  |)
                                                                |)
                                                              |)
                                                            |)
                                                          |)));
                                                      fun γ =>
                                                        ltac:(M.monadic
                                                          (let γ0_0 :=
                                                            M.get_struct_tuple_field_or_break_match (|
                                                              γ,
                                                              "core::ops::control_flow::ControlFlow::Continue",
                                                              0
                                                            |) in
                                                          let val := M.copy (| γ0_0 |) in
                                                          val))
                                                    ]
                                                  |) in
                                                M.alloc (| Value.Tuple [] |)))
                                          ]
                                        |) in
                                      M.alloc (| Value.Tuple [] |)))
                                  |)))
                            ]
                          |)) in
                      let _ :=
                        M.match_operator (|
                          M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::ops::try_trait::Try",
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                                [],
                                "branch",
                                []
                              |),
                              [
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.path "core::fmt::Formatter",
                                    "write_fmt",
                                    []
                                  |),
                                  [
                                    M.read (| f |);
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.path "core::fmt::Arguments",
                                        "new_const",
                                        []
                                      |),
                                      [
                                        (* Unsize *)
                                        M.pointer_coercion
                                          (M.alloc (| Value.Array [ M.read (| mk_str ">" |) ] |))
                                      ]
                                    |)
                                  ]
                                |)
                              ]
                            |)
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.get_struct_tuple_field_or_break_match (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Break",
                                    0
                                  |) in
                                let residual := M.copy (| γ0_0 |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      M.return_ (|
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::ops::try_trait::FromResidual",
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                                            [
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                [
                                                  Ty.path "core::convert::Infallible";
                                                  Ty.path "core::fmt::Error"
                                                ]
                                            ],
                                            "from_residual",
                                            []
                                          |),
                                          [ M.read (| residual |) ]
                                        |)
                                      |)
                                    |)
                                  |)
                                |)));
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.get_struct_tuple_field_or_break_match (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Continue",
                                    0
                                  |) in
                                let val := M.copy (| γ0_0 |) in
                                val))
                          ]
                        |) in
                      M.alloc (| Value.Tuple [] |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            M.alloc (| Value.StructTuple "core::result::Result::Ok" [ Value.Tuple [] ] |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Display"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Display_for_move_core_types_language_storage_StructTag.
  
  Module Impl_core_fmt_Display_for_move_core_types_language_storage_TypeTag.
    Definition Self : Ty.t := Ty.path "move_core_types::language_storage::TypeTag".
    
    (*
        fn fmt(&self, f: &mut Formatter) -> std::fmt::Result {
            match self {
                TypeTag::Struct(s) => write!(f, "{}", s),
                TypeTag::Vector(ty) => write!(f, "vector<{}>", ty),
                TypeTag::U8 => write!(f, "u8"),
                TypeTag::U16 => write!(f, "u16"),
                TypeTag::U32 => write!(f, "u32"),
                TypeTag::U64 => write!(f, "u64"),
                TypeTag::U128 => write!(f, "u128"),
                TypeTag::U256 => write!(f, "u256"),
                TypeTag::Address => write!(f, "address"),
                TypeTag::Signer => write!(f, "signer"),
                TypeTag::Bool => write!(f, "bool"),
            }
        }
    *)
    Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::language_storage::TypeTag::Struct",
                        0
                      |) in
                    let s := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_v1",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (| Value.Array [ M.read (| mk_str "" |) ] |));
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.path "core::fmt::rt::Argument",
                                          "new_display",
                                          [
                                            Ty.apply
                                              (Ty.path "&")
                                              [
                                                Ty.apply
                                                  (Ty.path "alloc::boxed::Box")
                                                  [
                                                    Ty.path
                                                      "move_core_types::language_storage::StructTag";
                                                    Ty.path "alloc::alloc::Global"
                                                  ]
                                              ]
                                          ]
                                        |),
                                        [ s ]
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::language_storage::TypeTag::Vector",
                        0
                      |) in
                    let ty := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_v1",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [ M.read (| mk_str "vector<" |); M.read (| mk_str ">" |) ]
                                |));
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.path "core::fmt::rt::Argument",
                                          "new_display",
                                          [
                                            Ty.apply
                                              (Ty.path "&")
                                              [
                                                Ty.apply
                                                  (Ty.path "alloc::boxed::Box")
                                                  [
                                                    Ty.path
                                                      "move_core_types::language_storage::TypeTag";
                                                    Ty.path "alloc::alloc::Global"
                                                  ]
                                              ]
                                          ]
                                        |),
                                        [ ty ]
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (| Value.Array [ M.read (| mk_str "u8" |) ] |))
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (| Value.Array [ M.read (| mk_str "u16" |) ] |))
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (| Value.Array [ M.read (| mk_str "u32" |) ] |))
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (| Value.Array [ M.read (| mk_str "u64" |) ] |))
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (| Value.Array [ M.read (| mk_str "u128" |) ] |))
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (| Value.Array [ M.read (| mk_str "u256" |) ] |))
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (| Value.Array [ M.read (| mk_str "address" |) ] |))
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (| Value.Array [ M.read (| mk_str "signer" |) ] |))
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (| Value.Array [ M.read (| mk_str "bool" |) ] |))
                            ]
                          |)
                        ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Display"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Display_for_move_core_types_language_storage_TypeTag.
  
  Module Impl_core_fmt_Display_for_move_core_types_language_storage_ResourceKey.
    Definition Self : Ty.t := Ty.path "move_core_types::language_storage::ResourceKey".
    
    (*
        fn fmt(&self, f: &mut Formatter) -> std::fmt::Result {
            write!(f, "0x{}/{}", self.address.short_str_lossless(), self.type_)
        }
    *)
    Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_fmt", [] |),
            [
              M.read (| f |);
              M.call_closure (|
                M.get_associated_function (| Ty.path "core::fmt::Arguments", "new_v1", [] |),
                [
                  (* Unsize *)
                  M.pointer_coercion
                    (M.alloc (|
                      Value.Array [ M.read (| mk_str "0x" |); M.read (| mk_str "/" |) ]
                    |));
                  (* Unsize *)
                  M.pointer_coercion
                    (M.alloc (|
                      Value.Array
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::rt::Argument",
                              "new_display",
                              [ Ty.path "alloc::string::String" ]
                            |),
                            [
                              M.alloc (|
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.path "move_core_types::account_address::AccountAddress",
                                    "short_str_lossless",
                                    []
                                  |),
                                  [
                                    M.get_struct_record_field
                                      (M.read (| self |))
                                      "move_core_types::language_storage::ResourceKey"
                                      "address"
                                  ]
                                |)
                              |)
                            ]
                          |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::rt::Argument",
                              "new_display",
                              [ Ty.path "move_core_types::language_storage::StructTag" ]
                            |),
                            [
                              M.get_struct_record_field
                                (M.read (| self |))
                                "move_core_types::language_storage::ResourceKey"
                                "type_"
                            ]
                          |)
                        ]
                    |))
                ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Display"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Display_for_move_core_types_language_storage_ResourceKey.
  
  Module Impl_core_convert_From_move_core_types_language_storage_StructTag_for_move_core_types_language_storage_TypeTag.
    Definition Self : Ty.t := Ty.path "move_core_types::language_storage::TypeTag".
    
    (*
        fn from(t: StructTag) -> TypeTag {
            TypeTag::Struct(Box::new(t))
        }
    *)
    Definition from (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ t ] =>
        ltac:(M.monadic
          (let t := M.alloc (| t |) in
          Value.StructTuple
            "move_core_types::language_storage::TypeTag::Struct"
            [
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::boxed::Box")
                    [
                      Ty.path "move_core_types::language_storage::StructTag";
                      Ty.path "alloc::alloc::Global"
                    ],
                  "new",
                  []
                |),
                [ M.read (| t |) ]
              |)
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::convert::From"
        Self
        (* Trait polymorphic types *)
        [ (* T *) Ty.path "move_core_types::language_storage::StructTag" ]
        (* Instance *) [ ("from", InstanceField.Method from) ].
  End Impl_core_convert_From_move_core_types_language_storage_StructTag_for_move_core_types_language_storage_TypeTag.
End language_storage.

Module metadata.
  (* StructRecord
    {
      name := "Metadata";
      ty_params := [];
      fields :=
        [
          ("key",
            Ty.apply (Ty.path "alloc::vec::Vec") [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]);
          ("value",
            Ty.apply (Ty.path "alloc::vec::Vec") [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ])
        ];
    } *)
  
  Module Impl_core_clone_Clone_for_move_core_types_metadata_Metadata.
    Definition Self : Ty.t := Ty.path "move_core_types::metadata::Metadata".
    
    (* Clone *)
    Definition clone (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.StructRecord
            "move_core_types::metadata::Metadata"
            [
              ("key",
                M.call_closure (|
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                    [],
                    "clone",
                    []
                  |),
                  [
                    M.get_struct_record_field
                      (M.read (| self |))
                      "move_core_types::metadata::Metadata"
                      "key"
                  ]
                |));
              ("value",
                M.call_closure (|
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                    [],
                    "clone",
                    []
                  |),
                  [
                    M.get_struct_record_field
                      (M.read (| self |))
                      "move_core_types::metadata::Metadata"
                      "value"
                  ]
                |))
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_move_core_types_metadata_Metadata.
  
  Module Impl_core_marker_StructuralPartialEq_for_move_core_types_metadata_Metadata.
    Definition Self : Ty.t := Ty.path "move_core_types::metadata::Metadata".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_move_core_types_metadata_Metadata.
  
  Module Impl_core_cmp_PartialEq_for_move_core_types_metadata_Metadata.
    Definition Self : Ty.t := Ty.path "move_core_types::metadata::Metadata".
    
    (* PartialEq *)
    Definition eq (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          LogicalOp.and (|
            M.call_closure (|
              M.get_trait_method (|
                "core::cmp::PartialEq",
                Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                [
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                ],
                "eq",
                []
              |),
              [
                M.get_struct_record_field
                  (M.read (| self |))
                  "move_core_types::metadata::Metadata"
                  "key";
                M.get_struct_record_field
                  (M.read (| other |))
                  "move_core_types::metadata::Metadata"
                  "key"
              ]
            |),
            ltac:(M.monadic
              (M.call_closure (|
                M.get_trait_method (|
                  "core::cmp::PartialEq",
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                  [
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                  ],
                  "eq",
                  []
                |),
                [
                  M.get_struct_record_field
                    (M.read (| self |))
                    "move_core_types::metadata::Metadata"
                    "value";
                  M.get_struct_record_field
                    (M.read (| other |))
                    "move_core_types::metadata::Metadata"
                    "value"
                ]
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_for_move_core_types_metadata_Metadata.
  
  Module Impl_core_marker_StructuralEq_for_move_core_types_metadata_Metadata.
    Definition Self : Ty.t := Ty.path "move_core_types::metadata::Metadata".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralEq_for_move_core_types_metadata_Metadata.
  
  Module Impl_core_cmp_Eq_for_move_core_types_metadata_Metadata.
    Definition Self : Ty.t := Ty.path "move_core_types::metadata::Metadata".
    
    (* Eq *)
    Definition assert_receiver_is_total_eq (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Value.DeclaredButUndefined,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      Value.DeclaredButUndefined,
                      [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_move_core_types_metadata_Metadata.
  
  Module Impl_core_fmt_Debug_for_move_core_types_metadata_Metadata.
    Definition Self : Ty.t := Ty.path "move_core_types::metadata::Metadata".
    
    (* Debug *)
    Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.path "core::fmt::Formatter",
              "debug_struct_field2_finish",
              []
            |),
            [
              M.read (| f |);
              M.read (| mk_str "Metadata" |);
              M.read (| mk_str "key" |);
              (* Unsize *)
              M.pointer_coercion
                (M.get_struct_record_field
                  (M.read (| self |))
                  "move_core_types::metadata::Metadata"
                  "key");
              M.read (| mk_str "value" |);
              (* Unsize *)
              M.pointer_coercion
                (M.alloc (|
                  M.get_struct_record_field
                    (M.read (| self |))
                    "move_core_types::metadata::Metadata"
                    "value"
                |))
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_move_core_types_metadata_Metadata.
End metadata.

Module move_resource.
  (* Trait *)
  Module MoveStructType.
    Definition module_identifier (Self : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [] =>
        ltac:(M.monadic
          (M.call_closure (|
            M.get_trait_method (|
              "alloc::borrow::ToOwned",
              Ty.path "move_core_types::identifier::IdentStr",
              [],
              "to_owned",
              []
            |),
            [
              M.read (|
                M.get_constant (| "move_core_types::move_resource::MoveStructType::MODULE_NAME" |)
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom ProvidedMethod_module_identifier :
      M.IsProvidedMethod
        "move_core_types::move_resource::MoveStructType"
        "module_identifier"
        module_identifier.
    Definition struct_identifier (Self : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [] =>
        ltac:(M.monadic
          (M.call_closure (|
            M.get_trait_method (|
              "alloc::borrow::ToOwned",
              Ty.path "move_core_types::identifier::IdentStr",
              [],
              "to_owned",
              []
            |),
            [
              M.read (|
                M.get_constant (| "move_core_types::move_resource::MoveStructType::STRUCT_NAME" |)
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom ProvidedMethod_struct_identifier :
      M.IsProvidedMethod
        "move_core_types::move_resource::MoveStructType"
        "struct_identifier"
        struct_identifier.
    Definition type_params (Self : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [] =>
        ltac:(M.monadic
          (M.call_closure (|
            M.get_associated_function (|
              Ty.apply
                (Ty.path "alloc::vec::Vec")
                [
                  Ty.path "move_core_types::language_storage::TypeTag";
                  Ty.path "alloc::alloc::Global"
                ],
              "new",
              []
            |),
            []
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom ProvidedMethod_type_params :
      M.IsProvidedMethod "move_core_types::move_resource::MoveStructType" "type_params" type_params.
    Definition struct_tag (Self : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [] =>
        ltac:(M.monadic
          (Value.StructRecord
            "move_core_types::language_storage::StructTag"
            [
              ("address",
                M.read (|
                  M.get_constant (| "move_core_types::move_resource::MoveStructType::ADDRESS" |)
                |));
              ("name",
                M.call_closure (|
                  M.get_trait_method (|
                    "move_core_types::move_resource::MoveStructType",
                    Self,
                    [],
                    "struct_identifier",
                    []
                  |),
                  []
                |));
              ("module",
                M.call_closure (|
                  M.get_trait_method (|
                    "move_core_types::move_resource::MoveStructType",
                    Self,
                    [],
                    "module_identifier",
                    []
                  |),
                  []
                |));
              ("type_params",
                M.call_closure (|
                  M.get_trait_method (|
                    "move_core_types::move_resource::MoveStructType",
                    Self,
                    [],
                    "type_params",
                    []
                  |),
                  []
                |))
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom ProvidedMethod_struct_tag :
      M.IsProvidedMethod "move_core_types::move_resource::MoveStructType" "struct_tag" struct_tag.
  End MoveStructType.
  
  (* Trait *)
  Module MoveResource.
    Definition resource_path (Self : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [] =>
        ltac:(M.monadic
          (M.call_closure (|
            M.get_associated_function (|
              Ty.path "move_core_types::language_storage::StructTag",
              "access_vector",
              []
            |),
            [
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "move_core_types::move_resource::MoveStructType",
                    Self,
                    [],
                    "struct_tag",
                    []
                  |),
                  []
                |)
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom ProvidedMethod_resource_path :
      M.IsProvidedMethod
        "move_core_types::move_resource::MoveResource"
        "resource_path"
        resource_path.
  End MoveResource.
End move_resource.

Module parser.
  (*
  Enum Token
  {
    ty_params := [];
    variants :=
      [
        {
          name := "U8Type";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "U16Type";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "U32Type";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "U64Type";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "U128Type";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "U256Type";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "BoolType";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "AddressType";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "VectorType";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "SignerType";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "Whitespace";
          item := StructTuple [ Ty.path "alloc::string::String" ];
          discriminant := None;
        };
        {
          name := "Name";
          item := StructTuple [ Ty.path "alloc::string::String" ];
          discriminant := None;
        };
        {
          name := "Address";
          item := StructTuple [ Ty.path "alloc::string::String" ];
          discriminant := None;
        };
        {
          name := "U8";
          item := StructTuple [ Ty.path "alloc::string::String" ];
          discriminant := None;
        };
        {
          name := "U16";
          item := StructTuple [ Ty.path "alloc::string::String" ];
          discriminant := None;
        };
        {
          name := "U32";
          item := StructTuple [ Ty.path "alloc::string::String" ];
          discriminant := None;
        };
        {
          name := "U64";
          item := StructTuple [ Ty.path "alloc::string::String" ];
          discriminant := None;
        };
        {
          name := "U128";
          item := StructTuple [ Ty.path "alloc::string::String" ];
          discriminant := None;
        };
        {
          name := "U256";
          item := StructTuple [ Ty.path "alloc::string::String" ];
          discriminant := None;
        };
        {
          name := "Bytes";
          item := StructTuple [ Ty.path "alloc::string::String" ];
          discriminant := None;
        };
        {
          name := "True";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "False";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "ColonColon";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "Lt";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "Gt";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "Comma";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "EOF";
          item := StructTuple [];
          discriminant := None;
        }
      ];
  }
  *)
  
  Module Impl_core_marker_StructuralEq_for_move_core_types_parser_Token.
    Definition Self : Ty.t := Ty.path "move_core_types::parser::Token".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralEq_for_move_core_types_parser_Token.
  
  Module Impl_core_cmp_Eq_for_move_core_types_parser_Token.
    Definition Self : Ty.t := Ty.path "move_core_types::parser::Token".
    
    (* Eq *)
    Definition assert_receiver_is_total_eq (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Value.DeclaredButUndefined,
              [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_move_core_types_parser_Token.
  
  Module Impl_core_marker_StructuralPartialEq_for_move_core_types_parser_Token.
    Definition Self : Ty.t := Ty.path "move_core_types::parser::Token".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_move_core_types_parser_Token.
  
  Module Impl_core_cmp_PartialEq_for_move_core_types_parser_Token.
    Definition Self : Ty.t := Ty.path "move_core_types::parser::Token".
    
    (* PartialEq *)
    Definition eq (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            let __self_tag :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [ Ty.path "move_core_types::parser::Token" ]
                  |),
                  [ M.read (| self |) ]
                |)
              |) in
            let __arg1_tag :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [ Ty.path "move_core_types::parser::Token" ]
                  |),
                  [ M.read (| other |) ]
                |)
              |) in
            M.alloc (|
              LogicalOp.and (|
                BinOp.Pure.eq (M.read (| __self_tag |)) (M.read (| __arg1_tag |)),
                ltac:(M.monadic
                  (M.read (|
                    M.match_operator (|
                      M.alloc (| Value.Tuple [ M.read (| self |); M.read (| other |) ] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.get_tuple_field γ 0 in
                            let γ0_1 := M.get_tuple_field γ 1 in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ0_0,
                                "move_core_types::parser::Token::Whitespace",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ0_1,
                                "move_core_types::parser::Token::Whitespace",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.path "alloc::string::String",
                                  [ Ty.path "alloc::string::String" ],
                                  "eq",
                                  []
                                |),
                                [ M.read (| __self_0 |); M.read (| __arg1_0 |) ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.get_tuple_field γ 0 in
                            let γ0_1 := M.get_tuple_field γ 1 in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ0_0,
                                "move_core_types::parser::Token::Name",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ0_1,
                                "move_core_types::parser::Token::Name",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.path "alloc::string::String",
                                  [ Ty.path "alloc::string::String" ],
                                  "eq",
                                  []
                                |),
                                [ M.read (| __self_0 |); M.read (| __arg1_0 |) ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.get_tuple_field γ 0 in
                            let γ0_1 := M.get_tuple_field γ 1 in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ0_0,
                                "move_core_types::parser::Token::Address",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ0_1,
                                "move_core_types::parser::Token::Address",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.path "alloc::string::String",
                                  [ Ty.path "alloc::string::String" ],
                                  "eq",
                                  []
                                |),
                                [ M.read (| __self_0 |); M.read (| __arg1_0 |) ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.get_tuple_field γ 0 in
                            let γ0_1 := M.get_tuple_field γ 1 in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ0_0,
                                "move_core_types::parser::Token::U8",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ0_1,
                                "move_core_types::parser::Token::U8",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.path "alloc::string::String",
                                  [ Ty.path "alloc::string::String" ],
                                  "eq",
                                  []
                                |),
                                [ M.read (| __self_0 |); M.read (| __arg1_0 |) ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.get_tuple_field γ 0 in
                            let γ0_1 := M.get_tuple_field γ 1 in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ0_0,
                                "move_core_types::parser::Token::U16",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ0_1,
                                "move_core_types::parser::Token::U16",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.path "alloc::string::String",
                                  [ Ty.path "alloc::string::String" ],
                                  "eq",
                                  []
                                |),
                                [ M.read (| __self_0 |); M.read (| __arg1_0 |) ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.get_tuple_field γ 0 in
                            let γ0_1 := M.get_tuple_field γ 1 in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ0_0,
                                "move_core_types::parser::Token::U32",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ0_1,
                                "move_core_types::parser::Token::U32",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.path "alloc::string::String",
                                  [ Ty.path "alloc::string::String" ],
                                  "eq",
                                  []
                                |),
                                [ M.read (| __self_0 |); M.read (| __arg1_0 |) ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.get_tuple_field γ 0 in
                            let γ0_1 := M.get_tuple_field γ 1 in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ0_0,
                                "move_core_types::parser::Token::U64",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ0_1,
                                "move_core_types::parser::Token::U64",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.path "alloc::string::String",
                                  [ Ty.path "alloc::string::String" ],
                                  "eq",
                                  []
                                |),
                                [ M.read (| __self_0 |); M.read (| __arg1_0 |) ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.get_tuple_field γ 0 in
                            let γ0_1 := M.get_tuple_field γ 1 in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ0_0,
                                "move_core_types::parser::Token::U128",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ0_1,
                                "move_core_types::parser::Token::U128",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.path "alloc::string::String",
                                  [ Ty.path "alloc::string::String" ],
                                  "eq",
                                  []
                                |),
                                [ M.read (| __self_0 |); M.read (| __arg1_0 |) ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.get_tuple_field γ 0 in
                            let γ0_1 := M.get_tuple_field γ 1 in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ0_0,
                                "move_core_types::parser::Token::U256",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ0_1,
                                "move_core_types::parser::Token::U256",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.path "alloc::string::String",
                                  [ Ty.path "alloc::string::String" ],
                                  "eq",
                                  []
                                |),
                                [ M.read (| __self_0 |); M.read (| __arg1_0 |) ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.get_tuple_field γ 0 in
                            let γ0_1 := M.get_tuple_field γ 1 in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ0_0,
                                "move_core_types::parser::Token::Bytes",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ0_1,
                                "move_core_types::parser::Token::Bytes",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.path "alloc::string::String",
                                  [ Ty.path "alloc::string::String" ],
                                  "eq",
                                  []
                                |),
                                [ M.read (| __self_0 |); M.read (| __arg1_0 |) ]
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Bool true |)))
                      ]
                    |)
                  |)))
              |)
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_for_move_core_types_parser_Token.
  
  Module Impl_core_fmt_Debug_for_move_core_types_parser_Token.
    Definition Self : Ty.t := Ty.path "move_core_types::parser::Token".
    
    (* Debug *)
    Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| mk_str "U8Type" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| mk_str "U16Type" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| mk_str "U32Type" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| mk_str "U64Type" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| mk_str "U128Type" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| mk_str "U256Type" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| mk_str "BoolType" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| mk_str "AddressType" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| mk_str "VectorType" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| mk_str "SignerType" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::parser::Token::Whitespace",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_tuple_field1_finish",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.read (| mk_str "Whitespace" |);
                          (* Unsize *) M.pointer_coercion __self_0
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::parser::Token::Name",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_tuple_field1_finish",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.read (| mk_str "Name" |);
                          (* Unsize *) M.pointer_coercion __self_0
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::parser::Token::Address",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_tuple_field1_finish",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.read (| mk_str "Address" |);
                          (* Unsize *) M.pointer_coercion __self_0
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::parser::Token::U8",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_tuple_field1_finish",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.read (| mk_str "U8" |);
                          (* Unsize *) M.pointer_coercion __self_0
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::parser::Token::U16",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_tuple_field1_finish",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.read (| mk_str "U16" |);
                          (* Unsize *) M.pointer_coercion __self_0
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::parser::Token::U32",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_tuple_field1_finish",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.read (| mk_str "U32" |);
                          (* Unsize *) M.pointer_coercion __self_0
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::parser::Token::U64",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_tuple_field1_finish",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.read (| mk_str "U64" |);
                          (* Unsize *) M.pointer_coercion __self_0
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::parser::Token::U128",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_tuple_field1_finish",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.read (| mk_str "U128" |);
                          (* Unsize *) M.pointer_coercion __self_0
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::parser::Token::U256",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_tuple_field1_finish",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.read (| mk_str "U256" |);
                          (* Unsize *) M.pointer_coercion __self_0
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::parser::Token::Bytes",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_tuple_field1_finish",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.read (| mk_str "Bytes" |);
                          (* Unsize *) M.pointer_coercion __self_0
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| mk_str "True" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| mk_str "False" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| mk_str "ColonColon" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| mk_str "Lt" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| mk_str "Gt" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| mk_str "Comma" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| mk_str "EOF" |) ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_move_core_types_parser_Token.
  
  Module Impl_move_core_types_parser_Token.
    Definition Self : Ty.t := Ty.path "move_core_types::parser::Token".
    
    (*
        fn is_whitespace(&self) -> bool {
            matches!(self, Self::Whitespace(_))
        }
    *)
    Definition is_whitespace (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::parser::Token::Whitespace",
                        0
                      |) in
                    M.alloc (| Value.Bool true |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Bool false |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_is_whitespace :
      M.IsAssociatedFunction Self "is_whitespace" is_whitespace.
  End Impl_move_core_types_parser_Token.
  
  (*
  fn name_token(s: String) -> Token {
      match s.as_str() {
          "u8" => Token::U8Type,
          "u16" => Token::U16Type,
          "u32" => Token::U32Type,
          "u64" => Token::U64Type,
          "u128" => Token::U128Type,
          "u256" => Token::U256Type,
          "bool" => Token::BoolType,
          "address" => Token::AddressType,
          "vector" => Token::VectorType,
          "true" => Token::True,
          "false" => Token::False,
          "signer" => Token::SignerType,
          _ => Token::Name(s),
      }
  }
  *)
  Definition name_token (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ s ] =>
      ltac:(M.monadic
        (let s := M.alloc (| s |) in
        M.read (|
          M.match_operator (|
            M.alloc (|
              M.call_closure (|
                M.get_associated_function (| Ty.path "alloc::string::String", "as_str", [] |),
                [ s ]
              |)
            |),
            [
              fun γ =>
                ltac:(M.monadic
                  (M.alloc (| Value.StructTuple "move_core_types::parser::Token::U8Type" [] |)));
              fun γ =>
                ltac:(M.monadic
                  (M.alloc (| Value.StructTuple "move_core_types::parser::Token::U16Type" [] |)));
              fun γ =>
                ltac:(M.monadic
                  (M.alloc (| Value.StructTuple "move_core_types::parser::Token::U32Type" [] |)));
              fun γ =>
                ltac:(M.monadic
                  (M.alloc (| Value.StructTuple "move_core_types::parser::Token::U64Type" [] |)));
              fun γ =>
                ltac:(M.monadic
                  (M.alloc (| Value.StructTuple "move_core_types::parser::Token::U128Type" [] |)));
              fun γ =>
                ltac:(M.monadic
                  (M.alloc (| Value.StructTuple "move_core_types::parser::Token::U256Type" [] |)));
              fun γ =>
                ltac:(M.monadic
                  (M.alloc (| Value.StructTuple "move_core_types::parser::Token::BoolType" [] |)));
              fun γ =>
                ltac:(M.monadic
                  (M.alloc (|
                    Value.StructTuple "move_core_types::parser::Token::AddressType" []
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (M.alloc (|
                    Value.StructTuple "move_core_types::parser::Token::VectorType" []
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (M.alloc (| Value.StructTuple "move_core_types::parser::Token::True" [] |)));
              fun γ =>
                ltac:(M.monadic
                  (M.alloc (| Value.StructTuple "move_core_types::parser::Token::False" [] |)));
              fun γ =>
                ltac:(M.monadic
                  (M.alloc (|
                    Value.StructTuple "move_core_types::parser::Token::SignerType" []
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (M.alloc (|
                    Value.StructTuple "move_core_types::parser::Token::Name" [ M.read (| s |) ]
                  |)))
            ]
          |)
        |)))
    | _, _ => M.impossible
    end.
  
  (*
  fn next_number(initial: char, mut it: impl Iterator<Item = char>) -> Result<(Token, usize)> {
      let mut num = String::new();
      num.push(initial);
      loop {
          match it.next() {
              Some(c) if c.is_ascii_digit() || c == '_' => num.push(c),
              Some(c) if c.is_alphanumeric() => {
                  let mut suffix = String::new();
                  suffix.push(c);
                  loop {
                      match it.next() {
                          Some(c) if c.is_ascii_alphanumeric() => suffix.push(c),
                          _ => {
                              let len = num.len() + suffix.len();
                              let tok = match suffix.as_str() {
                                  "u8" => Token::U8(num),
                                  "u16" => Token::U16(num),
                                  "u32" => Token::U32(num),
                                  "u64" => Token::U64(num),
                                  "u128" => Token::U128(num),
                                  "u256" => Token::U256(num),
                                  _ => bail!("invalid suffix"),
                              };
                              return Ok((tok, len));
                          }
                      }
                  }
              }
              _ => {
                  let len = num.len();
                  return Ok((Token::U64(num), len));
              }
          }
      }
  }
  *)
  Definition next_number (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [ impl_Iterator_Item___char_ ], [ initial; it ] =>
      ltac:(M.monadic
        (let initial := M.alloc (| initial |) in
        let it := M.alloc (| it |) in
        M.read (|
          let num :=
            M.alloc (|
              M.call_closure (|
                M.get_associated_function (| Ty.path "alloc::string::String", "new", [] |),
                []
              |)
            |) in
          let _ :=
            M.alloc (|
              M.call_closure (|
                M.get_associated_function (| Ty.path "alloc::string::String", "push", [] |),
                [ num; M.read (| initial |) ]
              |)
            |) in
          M.alloc (|
            M.never_to_any (|
              M.read (|
                M.loop (|
                  ltac:(M.monadic
                    (M.match_operator (|
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::iter::traits::iterator::Iterator",
                            impl_Iterator_Item___char_,
                            [],
                            "next",
                            []
                          |),
                          [ it ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ,
                                "core::option::Option::Some",
                                0
                              |) in
                            let c := M.copy (| γ0_0 |) in
                            let γ :=
                              M.alloc (|
                                LogicalOp.or (|
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.path "char",
                                      "is_ascii_digit",
                                      []
                                    |),
                                    [ c ]
                                  |),
                                  ltac:(M.monadic
                                    (BinOp.Pure.eq (M.read (| c |)) (Value.UnicodeChar 95)))
                                |)
                              |) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "alloc::string::String",
                                  "push",
                                  []
                                |),
                                [ num; M.read (| c |) ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ,
                                "core::option::Option::Some",
                                0
                              |) in
                            let c := M.copy (| γ0_0 |) in
                            let γ :=
                              M.alloc (|
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.path "char",
                                    "is_alphanumeric",
                                    []
                                  |),
                                  [ M.read (| c |) ]
                                |)
                              |) in
                            let _ :=
                              M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            let suffix :=
                              M.alloc (|
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.path "alloc::string::String",
                                    "new",
                                    []
                                  |),
                                  []
                                |)
                              |) in
                            let _ :=
                              M.alloc (|
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.path "alloc::string::String",
                                    "push",
                                    []
                                  |),
                                  [ suffix; M.read (| c |) ]
                                |)
                              |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.loop (|
                                    ltac:(M.monadic
                                      (M.match_operator (|
                                        M.alloc (|
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::iter::traits::iterator::Iterator",
                                              impl_Iterator_Item___char_,
                                              [],
                                              "next",
                                              []
                                            |),
                                            [ it ]
                                          |)
                                        |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let γ0_0 :=
                                                M.get_struct_tuple_field_or_break_match (|
                                                  γ,
                                                  "core::option::Option::Some",
                                                  0
                                                |) in
                                              let c := M.copy (| γ0_0 |) in
                                              let γ :=
                                                M.alloc (|
                                                  M.call_closure (|
                                                    M.get_associated_function (|
                                                      Ty.path "char",
                                                      "is_ascii_alphanumeric",
                                                      []
                                                    |),
                                                    [ c ]
                                                  |)
                                                |) in
                                              let _ :=
                                                M.is_constant_or_break_match (|
                                                  M.read (| γ |),
                                                  Value.Bool true
                                                |) in
                                              M.alloc (|
                                                M.call_closure (|
                                                  M.get_associated_function (|
                                                    Ty.path "alloc::string::String",
                                                    "push",
                                                    []
                                                  |),
                                                  [ suffix; M.read (| c |) ]
                                                |)
                                              |)));
                                          fun γ =>
                                            ltac:(M.monadic
                                              (M.alloc (|
                                                M.never_to_any (|
                                                  M.read (|
                                                    let len :=
                                                      M.alloc (|
                                                        BinOp.Panic.add (|
                                                          M.call_closure (|
                                                            M.get_associated_function (|
                                                              Ty.path "alloc::string::String",
                                                              "len",
                                                              []
                                                            |),
                                                            [ num ]
                                                          |),
                                                          M.call_closure (|
                                                            M.get_associated_function (|
                                                              Ty.path "alloc::string::String",
                                                              "len",
                                                              []
                                                            |),
                                                            [ suffix ]
                                                          |)
                                                        |)
                                                      |) in
                                                    let tok :=
                                                      M.copy (|
                                                        M.match_operator (|
                                                          M.alloc (|
                                                            M.call_closure (|
                                                              M.get_associated_function (|
                                                                Ty.path "alloc::string::String",
                                                                "as_str",
                                                                []
                                                              |),
                                                              [ suffix ]
                                                            |)
                                                          |),
                                                          [
                                                            fun γ =>
                                                              ltac:(M.monadic
                                                                (M.alloc (|
                                                                  Value.StructTuple
                                                                    "move_core_types::parser::Token::U8"
                                                                    [ M.read (| num |) ]
                                                                |)));
                                                            fun γ =>
                                                              ltac:(M.monadic
                                                                (M.alloc (|
                                                                  Value.StructTuple
                                                                    "move_core_types::parser::Token::U16"
                                                                    [ M.read (| num |) ]
                                                                |)));
                                                            fun γ =>
                                                              ltac:(M.monadic
                                                                (M.alloc (|
                                                                  Value.StructTuple
                                                                    "move_core_types::parser::Token::U32"
                                                                    [ M.read (| num |) ]
                                                                |)));
                                                            fun γ =>
                                                              ltac:(M.monadic
                                                                (M.alloc (|
                                                                  Value.StructTuple
                                                                    "move_core_types::parser::Token::U64"
                                                                    [ M.read (| num |) ]
                                                                |)));
                                                            fun γ =>
                                                              ltac:(M.monadic
                                                                (M.alloc (|
                                                                  Value.StructTuple
                                                                    "move_core_types::parser::Token::U128"
                                                                    [ M.read (| num |) ]
                                                                |)));
                                                            fun γ =>
                                                              ltac:(M.monadic
                                                                (M.alloc (|
                                                                  Value.StructTuple
                                                                    "move_core_types::parser::Token::U256"
                                                                    [ M.read (| num |) ]
                                                                |)));
                                                            fun γ =>
                                                              ltac:(M.monadic
                                                                (M.alloc (|
                                                                  M.never_to_any (|
                                                                    M.read (|
                                                                      M.return_ (|
                                                                        Value.StructTuple
                                                                          "core::result::Result::Err"
                                                                          [
                                                                            M.read (|
                                                                              let error :=
                                                                                M.alloc (|
                                                                                  M.call_closure (|
                                                                                    M.get_function (|
                                                                                      "anyhow::private::format_err",
                                                                                      []
                                                                                    |),
                                                                                    [
                                                                                      M.call_closure (|
                                                                                        M.get_associated_function (|
                                                                                          Ty.path
                                                                                            "core::fmt::Arguments",
                                                                                          "new_const",
                                                                                          []
                                                                                        |),
                                                                                        [
                                                                                          (* Unsize *)
                                                                                          M.pointer_coercion
                                                                                            (M.alloc (|
                                                                                              Value.Array
                                                                                                [
                                                                                                  M.read (|
                                                                                                    mk_str
                                                                                                      "invalid suffix"
                                                                                                  |)
                                                                                                ]
                                                                                            |))
                                                                                        ]
                                                                                      |)
                                                                                    ]
                                                                                  |)
                                                                                |) in
                                                                              error
                                                                            |)
                                                                          ]
                                                                      |)
                                                                    |)
                                                                  |)
                                                                |)))
                                                          ]
                                                        |)
                                                      |) in
                                                    M.return_ (|
                                                      Value.StructTuple
                                                        "core::result::Result::Ok"
                                                        [
                                                          Value.Tuple
                                                            [ M.read (| tok |); M.read (| len |) ]
                                                        ]
                                                    |)
                                                  |)
                                                |)
                                              |)))
                                        ]
                                      |)))
                                  |)
                                |)
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  let len :=
                                    M.alloc (|
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.path "alloc::string::String",
                                          "len",
                                          []
                                        |),
                                        [ num ]
                                      |)
                                    |) in
                                  M.return_ (|
                                    Value.StructTuple
                                      "core::result::Result::Ok"
                                      [
                                        Value.Tuple
                                          [
                                            Value.StructTuple
                                              "move_core_types::parser::Token::U64"
                                              [ M.read (| num |) ];
                                            M.read (| len |)
                                          ]
                                      ]
                                  |)
                                |)
                              |)
                            |)))
                      ]
                    |)))
                |)
              |)
            |)
          |)
        |)))
    | _, _ => M.impossible
    end.
  
  (*
  fn next_token(s: &str) -> Result<Option<(Token, usize)>> {
      let mut it = s.chars().peekable();
      match it.next() {
          None => Ok(None),
          Some(c) => Ok(Some(match c {
              '<' => (Token::Lt, 1),
              '>' => (Token::Gt, 1),
              ',' => (Token::Comma, 1),
              ':' => match it.next() {
                  Some(':') => (Token::ColonColon, 2),
                  _ => bail!("unrecognized token"),
              },
              '0' if it.peek() == Some(&'x') || it.peek() == Some(&'X') => {
                  it.next().unwrap();
                  match it.next() {
                      Some(c) if c.is_ascii_hexdigit() => {
                          let mut r = String::new();
                          r.push('0');
                          r.push('x');
                          r.push(c);
                          for c in it {
                              if c.is_ascii_hexdigit() {
                                  r.push(c);
                              } else {
                                  break;
                              }
                          }
                          let len = r.len();
                          (Token::Address(r), len)
                      }
                      _ => bail!("unrecognized token"),
                  }
              }
              c if c.is_ascii_digit() => next_number(c, it)?,
              'b' if it.peek() == Some(&'"') => {
                  it.next().unwrap();
                  let mut r = String::new();
                  loop {
                      match it.next() {
                          Some('"') => break,
                          Some(c) if c.is_ascii() => r.push(c),
                          _ => bail!("unrecognized token"),
                      }
                  }
                  let len = r.len() + 3;
                  (Token::Bytes(hex::encode(r)), len)
              }
              'x' if it.peek() == Some(&'"') => {
                  it.next().unwrap();
                  let mut r = String::new();
                  loop {
                      match it.next() {
                          Some('"') => break,
                          Some(c) if c.is_ascii_hexdigit() => r.push(c),
                          _ => bail!("unrecognized token"),
                      }
                  }
                  let len = r.len() + 3;
                  (Token::Bytes(r), len)
              }
              c if c.is_ascii_whitespace() => {
                  let mut r = String::new();
                  r.push(c);
                  for c in it {
                      if c.is_ascii_whitespace() {
                          r.push(c);
                      } else {
                          break;
                      }
                  }
                  let len = r.len();
                  (Token::Whitespace(r), len)
              }
              c if c.is_ascii_alphabetic() => {
                  let mut r = String::new();
                  r.push(c);
                  for c in it {
                      if identifier::is_valid_identifier_char(c) {
                          r.push(c);
                      } else {
                          break;
                      }
                  }
                  let len = r.len();
                  (name_token(r), len)
              }
              _ => bail!("unrecognized token"),
          })),
      }
  }
  *)
  Definition next_token (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ s ] =>
      ltac:(M.monadic
        (let s := M.alloc (| s |) in
        M.read (|
          let it :=
            M.alloc (|
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  Ty.path "core::str::iter::Chars",
                  [],
                  "peekable",
                  []
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "str", "chars", [] |),
                    [ M.read (| s |) ]
                  |)
                ]
              |)
            |) in
          M.match_operator (|
            M.alloc (|
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  Ty.apply
                    (Ty.path "core::iter::adapters::peekable::Peekable")
                    [ Ty.path "core::str::iter::Chars" ],
                  [],
                  "next",
                  []
                |),
                [ it ]
              |)
            |),
            [
              fun γ =>
                ltac:(M.monadic
                  (M.alloc (|
                    Value.StructTuple
                      "core::result::Result::Ok"
                      [ Value.StructTuple "core::option::Option::None" [] ]
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let γ0_0 :=
                    M.get_struct_tuple_field_or_break_match (|
                      γ,
                      "core::option::Option::Some",
                      0
                    |) in
                  let c := M.copy (| γ0_0 |) in
                  M.alloc (|
                    Value.StructTuple
                      "core::result::Result::Ok"
                      [
                        Value.StructTuple
                          "core::option::Option::Some"
                          [
                            M.read (|
                              M.match_operator (|
                                c,
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let _ :=
                                        M.is_constant_or_break_match (|
                                          M.read (| γ |),
                                          Value.UnicodeChar 60
                                        |) in
                                      M.alloc (|
                                        Value.Tuple
                                          [
                                            Value.StructTuple
                                              "move_core_types::parser::Token::Lt"
                                              [];
                                            Value.Integer Integer.Usize 1
                                          ]
                                      |)));
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let _ :=
                                        M.is_constant_or_break_match (|
                                          M.read (| γ |),
                                          Value.UnicodeChar 62
                                        |) in
                                      M.alloc (|
                                        Value.Tuple
                                          [
                                            Value.StructTuple
                                              "move_core_types::parser::Token::Gt"
                                              [];
                                            Value.Integer Integer.Usize 1
                                          ]
                                      |)));
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let _ :=
                                        M.is_constant_or_break_match (|
                                          M.read (| γ |),
                                          Value.UnicodeChar 44
                                        |) in
                                      M.alloc (|
                                        Value.Tuple
                                          [
                                            Value.StructTuple
                                              "move_core_types::parser::Token::Comma"
                                              [];
                                            Value.Integer Integer.Usize 1
                                          ]
                                      |)));
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let _ :=
                                        M.is_constant_or_break_match (|
                                          M.read (| γ |),
                                          Value.UnicodeChar 58
                                        |) in
                                      M.match_operator (|
                                        M.alloc (|
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::iter::traits::iterator::Iterator",
                                              Ty.apply
                                                (Ty.path "core::iter::adapters::peekable::Peekable")
                                                [ Ty.path "core::str::iter::Chars" ],
                                              [],
                                              "next",
                                              []
                                            |),
                                            [ it ]
                                          |)
                                        |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let γ0_0 :=
                                                M.get_struct_tuple_field_or_break_match (|
                                                  γ,
                                                  "core::option::Option::Some",
                                                  0
                                                |) in
                                              let _ :=
                                                M.is_constant_or_break_match (|
                                                  M.read (| γ0_0 |),
                                                  Value.UnicodeChar 58
                                                |) in
                                              M.alloc (|
                                                Value.Tuple
                                                  [
                                                    Value.StructTuple
                                                      "move_core_types::parser::Token::ColonColon"
                                                      [];
                                                    Value.Integer Integer.Usize 2
                                                  ]
                                              |)));
                                          fun γ =>
                                            ltac:(M.monadic
                                              (M.alloc (|
                                                M.never_to_any (|
                                                  M.read (|
                                                    M.return_ (|
                                                      Value.StructTuple
                                                        "core::result::Result::Err"
                                                        [
                                                          M.read (|
                                                            let error :=
                                                              M.alloc (|
                                                                M.call_closure (|
                                                                  M.get_function (|
                                                                    "anyhow::private::format_err",
                                                                    []
                                                                  |),
                                                                  [
                                                                    M.call_closure (|
                                                                      M.get_associated_function (|
                                                                        Ty.path
                                                                          "core::fmt::Arguments",
                                                                        "new_const",
                                                                        []
                                                                      |),
                                                                      [
                                                                        (* Unsize *)
                                                                        M.pointer_coercion
                                                                          (M.alloc (|
                                                                            Value.Array
                                                                              [
                                                                                M.read (|
                                                                                  mk_str
                                                                                    "unrecognized token"
                                                                                |)
                                                                              ]
                                                                          |))
                                                                      ]
                                                                    |)
                                                                  ]
                                                                |)
                                                              |) in
                                                            error
                                                          |)
                                                        ]
                                                    |)
                                                  |)
                                                |)
                                              |)))
                                        ]
                                      |)));
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let _ :=
                                        M.is_constant_or_break_match (|
                                          M.read (| γ |),
                                          Value.UnicodeChar 48
                                        |) in
                                      let γ :=
                                        M.alloc (|
                                          LogicalOp.or (|
                                            M.call_closure (|
                                              M.get_trait_method (|
                                                "core::cmp::PartialEq",
                                                Ty.apply
                                                  (Ty.path "core::option::Option")
                                                  [ Ty.apply (Ty.path "&") [ Ty.path "char" ] ],
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::option::Option")
                                                    [ Ty.apply (Ty.path "&") [ Ty.path "char" ] ]
                                                ],
                                                "eq",
                                                []
                                              |),
                                              [
                                                M.alloc (|
                                                  M.call_closure (|
                                                    M.get_associated_function (|
                                                      Ty.apply
                                                        (Ty.path
                                                          "core::iter::adapters::peekable::Peekable")
                                                        [ Ty.path "core::str::iter::Chars" ],
                                                      "peek",
                                                      []
                                                    |),
                                                    [ it ]
                                                  |)
                                                |);
                                                M.alloc (|
                                                  Value.StructTuple
                                                    "core::option::Option::Some"
                                                    [ M.alloc (| Value.UnicodeChar 120 |) ]
                                                |)
                                              ]
                                            |),
                                            ltac:(M.monadic
                                              (M.call_closure (|
                                                M.get_trait_method (|
                                                  "core::cmp::PartialEq",
                                                  Ty.apply
                                                    (Ty.path "core::option::Option")
                                                    [ Ty.apply (Ty.path "&") [ Ty.path "char" ] ],
                                                  [
                                                    Ty.apply
                                                      (Ty.path "core::option::Option")
                                                      [ Ty.apply (Ty.path "&") [ Ty.path "char" ] ]
                                                  ],
                                                  "eq",
                                                  []
                                                |),
                                                [
                                                  M.alloc (|
                                                    M.call_closure (|
                                                      M.get_associated_function (|
                                                        Ty.apply
                                                          (Ty.path
                                                            "core::iter::adapters::peekable::Peekable")
                                                          [ Ty.path "core::str::iter::Chars" ],
                                                        "peek",
                                                        []
                                                      |),
                                                      [ it ]
                                                    |)
                                                  |);
                                                  M.alloc (|
                                                    Value.StructTuple
                                                      "core::option::Option::Some"
                                                      [ M.alloc (| Value.UnicodeChar 88 |) ]
                                                  |)
                                                ]
                                              |)))
                                          |)
                                        |) in
                                      let _ :=
                                        M.is_constant_or_break_match (|
                                          M.read (| γ |),
                                          Value.Bool true
                                        |) in
                                      let _ :=
                                        M.alloc (|
                                          M.call_closure (|
                                            M.get_associated_function (|
                                              Ty.apply
                                                (Ty.path "core::option::Option")
                                                [ Ty.path "char" ],
                                              "unwrap",
                                              []
                                            |),
                                            [
                                              M.call_closure (|
                                                M.get_trait_method (|
                                                  "core::iter::traits::iterator::Iterator",
                                                  Ty.apply
                                                    (Ty.path
                                                      "core::iter::adapters::peekable::Peekable")
                                                    [ Ty.path "core::str::iter::Chars" ],
                                                  [],
                                                  "next",
                                                  []
                                                |),
                                                [ it ]
                                              |)
                                            ]
                                          |)
                                        |) in
                                      M.match_operator (|
                                        M.alloc (|
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::iter::traits::iterator::Iterator",
                                              Ty.apply
                                                (Ty.path "core::iter::adapters::peekable::Peekable")
                                                [ Ty.path "core::str::iter::Chars" ],
                                              [],
                                              "next",
                                              []
                                            |),
                                            [ it ]
                                          |)
                                        |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let γ0_0 :=
                                                M.get_struct_tuple_field_or_break_match (|
                                                  γ,
                                                  "core::option::Option::Some",
                                                  0
                                                |) in
                                              let c := M.copy (| γ0_0 |) in
                                              let γ :=
                                                M.alloc (|
                                                  M.call_closure (|
                                                    M.get_associated_function (|
                                                      Ty.path "char",
                                                      "is_ascii_hexdigit",
                                                      []
                                                    |),
                                                    [ c ]
                                                  |)
                                                |) in
                                              let _ :=
                                                M.is_constant_or_break_match (|
                                                  M.read (| γ |),
                                                  Value.Bool true
                                                |) in
                                              let r :=
                                                M.alloc (|
                                                  M.call_closure (|
                                                    M.get_associated_function (|
                                                      Ty.path "alloc::string::String",
                                                      "new",
                                                      []
                                                    |),
                                                    []
                                                  |)
                                                |) in
                                              let _ :=
                                                M.alloc (|
                                                  M.call_closure (|
                                                    M.get_associated_function (|
                                                      Ty.path "alloc::string::String",
                                                      "push",
                                                      []
                                                    |),
                                                    [ r; Value.UnicodeChar 48 ]
                                                  |)
                                                |) in
                                              let _ :=
                                                M.alloc (|
                                                  M.call_closure (|
                                                    M.get_associated_function (|
                                                      Ty.path "alloc::string::String",
                                                      "push",
                                                      []
                                                    |),
                                                    [ r; Value.UnicodeChar 120 ]
                                                  |)
                                                |) in
                                              let _ :=
                                                M.alloc (|
                                                  M.call_closure (|
                                                    M.get_associated_function (|
                                                      Ty.path "alloc::string::String",
                                                      "push",
                                                      []
                                                    |),
                                                    [ r; M.read (| c |) ]
                                                  |)
                                                |) in
                                              let _ :=
                                                M.use
                                                  (M.match_operator (|
                                                    M.alloc (|
                                                      M.call_closure (|
                                                        M.get_trait_method (|
                                                          "core::iter::traits::collect::IntoIterator",
                                                          Ty.apply
                                                            (Ty.path
                                                              "core::iter::adapters::peekable::Peekable")
                                                            [ Ty.path "core::str::iter::Chars" ],
                                                          [],
                                                          "into_iter",
                                                          []
                                                        |),
                                                        [ M.read (| it |) ]
                                                      |)
                                                    |),
                                                    [
                                                      fun γ =>
                                                        ltac:(M.monadic
                                                          (let iter := M.copy (| γ |) in
                                                          M.loop (|
                                                            ltac:(M.monadic
                                                              (let _ :=
                                                                M.match_operator (|
                                                                  M.alloc (|
                                                                    M.call_closure (|
                                                                      M.get_trait_method (|
                                                                        "core::iter::traits::iterator::Iterator",
                                                                        Ty.apply
                                                                          (Ty.path
                                                                            "core::iter::adapters::peekable::Peekable")
                                                                          [
                                                                            Ty.path
                                                                              "core::str::iter::Chars"
                                                                          ],
                                                                        [],
                                                                        "next",
                                                                        []
                                                                      |),
                                                                      [ iter ]
                                                                    |)
                                                                  |),
                                                                  [
                                                                    fun γ =>
                                                                      ltac:(M.monadic
                                                                        (M.alloc (|
                                                                          M.never_to_any (|
                                                                            M.read (|
                                                                              M.break (||)
                                                                            |)
                                                                          |)
                                                                        |)));
                                                                    fun γ =>
                                                                      ltac:(M.monadic
                                                                        (let γ0_0 :=
                                                                          M.get_struct_tuple_field_or_break_match (|
                                                                            γ,
                                                                            "core::option::Option::Some",
                                                                            0
                                                                          |) in
                                                                        let c :=
                                                                          M.copy (| γ0_0 |) in
                                                                        M.match_operator (|
                                                                          M.alloc (|
                                                                            Value.Tuple []
                                                                          |),
                                                                          [
                                                                            fun γ =>
                                                                              ltac:(M.monadic
                                                                                (let γ :=
                                                                                  M.use
                                                                                    (M.alloc (|
                                                                                      M.call_closure (|
                                                                                        M.get_associated_function (|
                                                                                          Ty.path
                                                                                            "char",
                                                                                          "is_ascii_hexdigit",
                                                                                          []
                                                                                        |),
                                                                                        [ c ]
                                                                                      |)
                                                                                    |)) in
                                                                                let _ :=
                                                                                  M.is_constant_or_break_match (|
                                                                                    M.read (| γ |),
                                                                                    Value.Bool true
                                                                                  |) in
                                                                                let _ :=
                                                                                  M.alloc (|
                                                                                    M.call_closure (|
                                                                                      M.get_associated_function (|
                                                                                        Ty.path
                                                                                          "alloc::string::String",
                                                                                        "push",
                                                                                        []
                                                                                      |),
                                                                                      [
                                                                                        r;
                                                                                        M.read (|
                                                                                          c
                                                                                        |)
                                                                                      ]
                                                                                    |)
                                                                                  |) in
                                                                                M.alloc (|
                                                                                  Value.Tuple []
                                                                                |)));
                                                                            fun γ =>
                                                                              ltac:(M.monadic
                                                                                (M.alloc (|
                                                                                  M.never_to_any (|
                                                                                    M.read (|
                                                                                      M.break (||)
                                                                                    |)
                                                                                  |)
                                                                                |)))
                                                                          ]
                                                                        |)))
                                                                  ]
                                                                |) in
                                                              M.alloc (| Value.Tuple [] |)))
                                                          |)))
                                                    ]
                                                  |)) in
                                              let len :=
                                                M.alloc (|
                                                  M.call_closure (|
                                                    M.get_associated_function (|
                                                      Ty.path "alloc::string::String",
                                                      "len",
                                                      []
                                                    |),
                                                    [ r ]
                                                  |)
                                                |) in
                                              M.alloc (|
                                                Value.Tuple
                                                  [
                                                    Value.StructTuple
                                                      "move_core_types::parser::Token::Address"
                                                      [ M.read (| r |) ];
                                                    M.read (| len |)
                                                  ]
                                              |)));
                                          fun γ =>
                                            ltac:(M.monadic
                                              (M.alloc (|
                                                M.never_to_any (|
                                                  M.read (|
                                                    M.return_ (|
                                                      Value.StructTuple
                                                        "core::result::Result::Err"
                                                        [
                                                          M.read (|
                                                            let error :=
                                                              M.alloc (|
                                                                M.call_closure (|
                                                                  M.get_function (|
                                                                    "anyhow::private::format_err",
                                                                    []
                                                                  |),
                                                                  [
                                                                    M.call_closure (|
                                                                      M.get_associated_function (|
                                                                        Ty.path
                                                                          "core::fmt::Arguments",
                                                                        "new_const",
                                                                        []
                                                                      |),
                                                                      [
                                                                        (* Unsize *)
                                                                        M.pointer_coercion
                                                                          (M.alloc (|
                                                                            Value.Array
                                                                              [
                                                                                M.read (|
                                                                                  mk_str
                                                                                    "unrecognized token"
                                                                                |)
                                                                              ]
                                                                          |))
                                                                      ]
                                                                    |)
                                                                  ]
                                                                |)
                                                              |) in
                                                            error
                                                          |)
                                                        ]
                                                    |)
                                                  |)
                                                |)
                                              |)))
                                        ]
                                      |)));
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let c := M.copy (| γ |) in
                                      let γ :=
                                        M.alloc (|
                                          M.call_closure (|
                                            M.get_associated_function (|
                                              Ty.path "char",
                                              "is_ascii_digit",
                                              []
                                            |),
                                            [ c ]
                                          |)
                                        |) in
                                      let _ :=
                                        M.is_constant_or_break_match (|
                                          M.read (| γ |),
                                          Value.Bool true
                                        |) in
                                      M.match_operator (|
                                        M.alloc (|
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::try_trait::Try",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                [
                                                  Ty.tuple
                                                    [
                                                      Ty.path "move_core_types::parser::Token";
                                                      Ty.path "usize"
                                                    ];
                                                  Ty.path "anyhow::Error"
                                                ],
                                              [],
                                              "branch",
                                              []
                                            |),
                                            [
                                              M.call_closure (|
                                                M.get_function (|
                                                  "move_core_types::parser::next_number",
                                                  [
                                                    Ty.apply
                                                      (Ty.path
                                                        "core::iter::adapters::peekable::Peekable")
                                                      [ Ty.path "core::str::iter::Chars" ]
                                                  ]
                                                |),
                                                [ M.read (| c |); M.read (| it |) ]
                                              |)
                                            ]
                                          |)
                                        |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let γ0_0 :=
                                                M.get_struct_tuple_field_or_break_match (|
                                                  γ,
                                                  "core::ops::control_flow::ControlFlow::Break",
                                                  0
                                                |) in
                                              let residual := M.copy (| γ0_0 |) in
                                              M.alloc (|
                                                M.never_to_any (|
                                                  M.read (|
                                                    M.return_ (|
                                                      M.call_closure (|
                                                        M.get_trait_method (|
                                                          "core::ops::try_trait::FromResidual",
                                                          Ty.apply
                                                            (Ty.path "core::result::Result")
                                                            [
                                                              Ty.apply
                                                                (Ty.path "core::option::Option")
                                                                [
                                                                  Ty.tuple
                                                                    [
                                                                      Ty.path
                                                                        "move_core_types::parser::Token";
                                                                      Ty.path "usize"
                                                                    ]
                                                                ];
                                                              Ty.path "anyhow::Error"
                                                            ],
                                                          [
                                                            Ty.apply
                                                              (Ty.path "core::result::Result")
                                                              [
                                                                Ty.path "core::convert::Infallible";
                                                                Ty.path "anyhow::Error"
                                                              ]
                                                          ],
                                                          "from_residual",
                                                          []
                                                        |),
                                                        [ M.read (| residual |) ]
                                                      |)
                                                    |)
                                                  |)
                                                |)
                                              |)));
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let γ0_0 :=
                                                M.get_struct_tuple_field_or_break_match (|
                                                  γ,
                                                  "core::ops::control_flow::ControlFlow::Continue",
                                                  0
                                                |) in
                                              let val := M.copy (| γ0_0 |) in
                                              val))
                                        ]
                                      |)));
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let _ :=
                                        M.is_constant_or_break_match (|
                                          M.read (| γ |),
                                          Value.UnicodeChar 98
                                        |) in
                                      let γ :=
                                        M.alloc (|
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::cmp::PartialEq",
                                              Ty.apply
                                                (Ty.path "core::option::Option")
                                                [ Ty.apply (Ty.path "&") [ Ty.path "char" ] ],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::option::Option")
                                                  [ Ty.apply (Ty.path "&") [ Ty.path "char" ] ]
                                              ],
                                              "eq",
                                              []
                                            |),
                                            [
                                              M.alloc (|
                                                M.call_closure (|
                                                  M.get_associated_function (|
                                                    Ty.apply
                                                      (Ty.path
                                                        "core::iter::adapters::peekable::Peekable")
                                                      [ Ty.path "core::str::iter::Chars" ],
                                                    "peek",
                                                    []
                                                  |),
                                                  [ it ]
                                                |)
                                              |);
                                              M.alloc (|
                                                Value.StructTuple
                                                  "core::option::Option::Some"
                                                  [ M.alloc (| Value.UnicodeChar 34 |) ]
                                              |)
                                            ]
                                          |)
                                        |) in
                                      let _ :=
                                        M.is_constant_or_break_match (|
                                          M.read (| γ |),
                                          Value.Bool true
                                        |) in
                                      let _ :=
                                        M.alloc (|
                                          M.call_closure (|
                                            M.get_associated_function (|
                                              Ty.apply
                                                (Ty.path "core::option::Option")
                                                [ Ty.path "char" ],
                                              "unwrap",
                                              []
                                            |),
                                            [
                                              M.call_closure (|
                                                M.get_trait_method (|
                                                  "core::iter::traits::iterator::Iterator",
                                                  Ty.apply
                                                    (Ty.path
                                                      "core::iter::adapters::peekable::Peekable")
                                                    [ Ty.path "core::str::iter::Chars" ],
                                                  [],
                                                  "next",
                                                  []
                                                |),
                                                [ it ]
                                              |)
                                            ]
                                          |)
                                        |) in
                                      let r :=
                                        M.alloc (|
                                          M.call_closure (|
                                            M.get_associated_function (|
                                              Ty.path "alloc::string::String",
                                              "new",
                                              []
                                            |),
                                            []
                                          |)
                                        |) in
                                      let _ :=
                                        M.loop (|
                                          ltac:(M.monadic
                                            (M.match_operator (|
                                              M.alloc (|
                                                M.call_closure (|
                                                  M.get_trait_method (|
                                                    "core::iter::traits::iterator::Iterator",
                                                    Ty.apply
                                                      (Ty.path
                                                        "core::iter::adapters::peekable::Peekable")
                                                      [ Ty.path "core::str::iter::Chars" ],
                                                    [],
                                                    "next",
                                                    []
                                                  |),
                                                  [ it ]
                                                |)
                                              |),
                                              [
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (let γ0_0 :=
                                                      M.get_struct_tuple_field_or_break_match (|
                                                        γ,
                                                        "core::option::Option::Some",
                                                        0
                                                      |) in
                                                    let _ :=
                                                      M.is_constant_or_break_match (|
                                                        M.read (| γ0_0 |),
                                                        Value.UnicodeChar 34
                                                      |) in
                                                    M.alloc (|
                                                      M.never_to_any (| M.read (| M.break (||) |) |)
                                                    |)));
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (let γ0_0 :=
                                                      M.get_struct_tuple_field_or_break_match (|
                                                        γ,
                                                        "core::option::Option::Some",
                                                        0
                                                      |) in
                                                    let c := M.copy (| γ0_0 |) in
                                                    let γ :=
                                                      M.alloc (|
                                                        M.call_closure (|
                                                          M.get_associated_function (|
                                                            Ty.path "char",
                                                            "is_ascii",
                                                            []
                                                          |),
                                                          [ c ]
                                                        |)
                                                      |) in
                                                    let _ :=
                                                      M.is_constant_or_break_match (|
                                                        M.read (| γ |),
                                                        Value.Bool true
                                                      |) in
                                                    M.alloc (|
                                                      M.call_closure (|
                                                        M.get_associated_function (|
                                                          Ty.path "alloc::string::String",
                                                          "push",
                                                          []
                                                        |),
                                                        [ r; M.read (| c |) ]
                                                      |)
                                                    |)));
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (M.alloc (|
                                                      M.never_to_any (|
                                                        M.read (|
                                                          M.return_ (|
                                                            Value.StructTuple
                                                              "core::result::Result::Err"
                                                              [
                                                                M.read (|
                                                                  let error :=
                                                                    M.alloc (|
                                                                      M.call_closure (|
                                                                        M.get_function (|
                                                                          "anyhow::private::format_err",
                                                                          []
                                                                        |),
                                                                        [
                                                                          M.call_closure (|
                                                                            M.get_associated_function (|
                                                                              Ty.path
                                                                                "core::fmt::Arguments",
                                                                              "new_const",
                                                                              []
                                                                            |),
                                                                            [
                                                                              (* Unsize *)
                                                                              M.pointer_coercion
                                                                                (M.alloc (|
                                                                                  Value.Array
                                                                                    [
                                                                                      M.read (|
                                                                                        mk_str
                                                                                          "unrecognized token"
                                                                                      |)
                                                                                    ]
                                                                                |))
                                                                            ]
                                                                          |)
                                                                        ]
                                                                      |)
                                                                    |) in
                                                                  error
                                                                |)
                                                              ]
                                                          |)
                                                        |)
                                                      |)
                                                    |)))
                                              ]
                                            |)))
                                        |) in
                                      let len :=
                                        M.alloc (|
                                          BinOp.Panic.add (|
                                            M.call_closure (|
                                              M.get_associated_function (|
                                                Ty.path "alloc::string::String",
                                                "len",
                                                []
                                              |),
                                              [ r ]
                                            |),
                                            Value.Integer Integer.Usize 3
                                          |)
                                        |) in
                                      M.alloc (|
                                        Value.Tuple
                                          [
                                            Value.StructTuple
                                              "move_core_types::parser::Token::Bytes"
                                              [
                                                M.call_closure (|
                                                  M.get_function (|
                                                    "hex::encode",
                                                    [ Ty.path "alloc::string::String" ]
                                                  |),
                                                  [ M.read (| r |) ]
                                                |)
                                              ];
                                            M.read (| len |)
                                          ]
                                      |)));
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let _ :=
                                        M.is_constant_or_break_match (|
                                          M.read (| γ |),
                                          Value.UnicodeChar 120
                                        |) in
                                      let γ :=
                                        M.alloc (|
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::cmp::PartialEq",
                                              Ty.apply
                                                (Ty.path "core::option::Option")
                                                [ Ty.apply (Ty.path "&") [ Ty.path "char" ] ],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::option::Option")
                                                  [ Ty.apply (Ty.path "&") [ Ty.path "char" ] ]
                                              ],
                                              "eq",
                                              []
                                            |),
                                            [
                                              M.alloc (|
                                                M.call_closure (|
                                                  M.get_associated_function (|
                                                    Ty.apply
                                                      (Ty.path
                                                        "core::iter::adapters::peekable::Peekable")
                                                      [ Ty.path "core::str::iter::Chars" ],
                                                    "peek",
                                                    []
                                                  |),
                                                  [ it ]
                                                |)
                                              |);
                                              M.alloc (|
                                                Value.StructTuple
                                                  "core::option::Option::Some"
                                                  [ M.alloc (| Value.UnicodeChar 34 |) ]
                                              |)
                                            ]
                                          |)
                                        |) in
                                      let _ :=
                                        M.is_constant_or_break_match (|
                                          M.read (| γ |),
                                          Value.Bool true
                                        |) in
                                      let _ :=
                                        M.alloc (|
                                          M.call_closure (|
                                            M.get_associated_function (|
                                              Ty.apply
                                                (Ty.path "core::option::Option")
                                                [ Ty.path "char" ],
                                              "unwrap",
                                              []
                                            |),
                                            [
                                              M.call_closure (|
                                                M.get_trait_method (|
                                                  "core::iter::traits::iterator::Iterator",
                                                  Ty.apply
                                                    (Ty.path
                                                      "core::iter::adapters::peekable::Peekable")
                                                    [ Ty.path "core::str::iter::Chars" ],
                                                  [],
                                                  "next",
                                                  []
                                                |),
                                                [ it ]
                                              |)
                                            ]
                                          |)
                                        |) in
                                      let r :=
                                        M.alloc (|
                                          M.call_closure (|
                                            M.get_associated_function (|
                                              Ty.path "alloc::string::String",
                                              "new",
                                              []
                                            |),
                                            []
                                          |)
                                        |) in
                                      let _ :=
                                        M.loop (|
                                          ltac:(M.monadic
                                            (M.match_operator (|
                                              M.alloc (|
                                                M.call_closure (|
                                                  M.get_trait_method (|
                                                    "core::iter::traits::iterator::Iterator",
                                                    Ty.apply
                                                      (Ty.path
                                                        "core::iter::adapters::peekable::Peekable")
                                                      [ Ty.path "core::str::iter::Chars" ],
                                                    [],
                                                    "next",
                                                    []
                                                  |),
                                                  [ it ]
                                                |)
                                              |),
                                              [
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (let γ0_0 :=
                                                      M.get_struct_tuple_field_or_break_match (|
                                                        γ,
                                                        "core::option::Option::Some",
                                                        0
                                                      |) in
                                                    let _ :=
                                                      M.is_constant_or_break_match (|
                                                        M.read (| γ0_0 |),
                                                        Value.UnicodeChar 34
                                                      |) in
                                                    M.alloc (|
                                                      M.never_to_any (| M.read (| M.break (||) |) |)
                                                    |)));
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (let γ0_0 :=
                                                      M.get_struct_tuple_field_or_break_match (|
                                                        γ,
                                                        "core::option::Option::Some",
                                                        0
                                                      |) in
                                                    let c := M.copy (| γ0_0 |) in
                                                    let γ :=
                                                      M.alloc (|
                                                        M.call_closure (|
                                                          M.get_associated_function (|
                                                            Ty.path "char",
                                                            "is_ascii_hexdigit",
                                                            []
                                                          |),
                                                          [ c ]
                                                        |)
                                                      |) in
                                                    let _ :=
                                                      M.is_constant_or_break_match (|
                                                        M.read (| γ |),
                                                        Value.Bool true
                                                      |) in
                                                    M.alloc (|
                                                      M.call_closure (|
                                                        M.get_associated_function (|
                                                          Ty.path "alloc::string::String",
                                                          "push",
                                                          []
                                                        |),
                                                        [ r; M.read (| c |) ]
                                                      |)
                                                    |)));
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (M.alloc (|
                                                      M.never_to_any (|
                                                        M.read (|
                                                          M.return_ (|
                                                            Value.StructTuple
                                                              "core::result::Result::Err"
                                                              [
                                                                M.read (|
                                                                  let error :=
                                                                    M.alloc (|
                                                                      M.call_closure (|
                                                                        M.get_function (|
                                                                          "anyhow::private::format_err",
                                                                          []
                                                                        |),
                                                                        [
                                                                          M.call_closure (|
                                                                            M.get_associated_function (|
                                                                              Ty.path
                                                                                "core::fmt::Arguments",
                                                                              "new_const",
                                                                              []
                                                                            |),
                                                                            [
                                                                              (* Unsize *)
                                                                              M.pointer_coercion
                                                                                (M.alloc (|
                                                                                  Value.Array
                                                                                    [
                                                                                      M.read (|
                                                                                        mk_str
                                                                                          "unrecognized token"
                                                                                      |)
                                                                                    ]
                                                                                |))
                                                                            ]
                                                                          |)
                                                                        ]
                                                                      |)
                                                                    |) in
                                                                  error
                                                                |)
                                                              ]
                                                          |)
                                                        |)
                                                      |)
                                                    |)))
                                              ]
                                            |)))
                                        |) in
                                      let len :=
                                        M.alloc (|
                                          BinOp.Panic.add (|
                                            M.call_closure (|
                                              M.get_associated_function (|
                                                Ty.path "alloc::string::String",
                                                "len",
                                                []
                                              |),
                                              [ r ]
                                            |),
                                            Value.Integer Integer.Usize 3
                                          |)
                                        |) in
                                      M.alloc (|
                                        Value.Tuple
                                          [
                                            Value.StructTuple
                                              "move_core_types::parser::Token::Bytes"
                                              [ M.read (| r |) ];
                                            M.read (| len |)
                                          ]
                                      |)));
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let c := M.copy (| γ |) in
                                      let γ :=
                                        M.alloc (|
                                          M.call_closure (|
                                            M.get_associated_function (|
                                              Ty.path "char",
                                              "is_ascii_whitespace",
                                              []
                                            |),
                                            [ c ]
                                          |)
                                        |) in
                                      let _ :=
                                        M.is_constant_or_break_match (|
                                          M.read (| γ |),
                                          Value.Bool true
                                        |) in
                                      let r :=
                                        M.alloc (|
                                          M.call_closure (|
                                            M.get_associated_function (|
                                              Ty.path "alloc::string::String",
                                              "new",
                                              []
                                            |),
                                            []
                                          |)
                                        |) in
                                      let _ :=
                                        M.alloc (|
                                          M.call_closure (|
                                            M.get_associated_function (|
                                              Ty.path "alloc::string::String",
                                              "push",
                                              []
                                            |),
                                            [ r; M.read (| c |) ]
                                          |)
                                        |) in
                                      let _ :=
                                        M.use
                                          (M.match_operator (|
                                            M.alloc (|
                                              M.call_closure (|
                                                M.get_trait_method (|
                                                  "core::iter::traits::collect::IntoIterator",
                                                  Ty.apply
                                                    (Ty.path
                                                      "core::iter::adapters::peekable::Peekable")
                                                    [ Ty.path "core::str::iter::Chars" ],
                                                  [],
                                                  "into_iter",
                                                  []
                                                |),
                                                [ M.read (| it |) ]
                                              |)
                                            |),
                                            [
                                              fun γ =>
                                                ltac:(M.monadic
                                                  (let iter := M.copy (| γ |) in
                                                  M.loop (|
                                                    ltac:(M.monadic
                                                      (let _ :=
                                                        M.match_operator (|
                                                          M.alloc (|
                                                            M.call_closure (|
                                                              M.get_trait_method (|
                                                                "core::iter::traits::iterator::Iterator",
                                                                Ty.apply
                                                                  (Ty.path
                                                                    "core::iter::adapters::peekable::Peekable")
                                                                  [ Ty.path "core::str::iter::Chars"
                                                                  ],
                                                                [],
                                                                "next",
                                                                []
                                                              |),
                                                              [ iter ]
                                                            |)
                                                          |),
                                                          [
                                                            fun γ =>
                                                              ltac:(M.monadic
                                                                (M.alloc (|
                                                                  M.never_to_any (|
                                                                    M.read (| M.break (||) |)
                                                                  |)
                                                                |)));
                                                            fun γ =>
                                                              ltac:(M.monadic
                                                                (let γ0_0 :=
                                                                  M.get_struct_tuple_field_or_break_match (|
                                                                    γ,
                                                                    "core::option::Option::Some",
                                                                    0
                                                                  |) in
                                                                let c := M.copy (| γ0_0 |) in
                                                                M.match_operator (|
                                                                  M.alloc (| Value.Tuple [] |),
                                                                  [
                                                                    fun γ =>
                                                                      ltac:(M.monadic
                                                                        (let γ :=
                                                                          M.use
                                                                            (M.alloc (|
                                                                              M.call_closure (|
                                                                                M.get_associated_function (|
                                                                                  Ty.path "char",
                                                                                  "is_ascii_whitespace",
                                                                                  []
                                                                                |),
                                                                                [ c ]
                                                                              |)
                                                                            |)) in
                                                                        let _ :=
                                                                          M.is_constant_or_break_match (|
                                                                            M.read (| γ |),
                                                                            Value.Bool true
                                                                          |) in
                                                                        let _ :=
                                                                          M.alloc (|
                                                                            M.call_closure (|
                                                                              M.get_associated_function (|
                                                                                Ty.path
                                                                                  "alloc::string::String",
                                                                                "push",
                                                                                []
                                                                              |),
                                                                              [ r; M.read (| c |) ]
                                                                            |)
                                                                          |) in
                                                                        M.alloc (|
                                                                          Value.Tuple []
                                                                        |)));
                                                                    fun γ =>
                                                                      ltac:(M.monadic
                                                                        (M.alloc (|
                                                                          M.never_to_any (|
                                                                            M.read (|
                                                                              M.break (||)
                                                                            |)
                                                                          |)
                                                                        |)))
                                                                  ]
                                                                |)))
                                                          ]
                                                        |) in
                                                      M.alloc (| Value.Tuple [] |)))
                                                  |)))
                                            ]
                                          |)) in
                                      let len :=
                                        M.alloc (|
                                          M.call_closure (|
                                            M.get_associated_function (|
                                              Ty.path "alloc::string::String",
                                              "len",
                                              []
                                            |),
                                            [ r ]
                                          |)
                                        |) in
                                      M.alloc (|
                                        Value.Tuple
                                          [
                                            Value.StructTuple
                                              "move_core_types::parser::Token::Whitespace"
                                              [ M.read (| r |) ];
                                            M.read (| len |)
                                          ]
                                      |)));
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let c := M.copy (| γ |) in
                                      let γ :=
                                        M.alloc (|
                                          M.call_closure (|
                                            M.get_associated_function (|
                                              Ty.path "char",
                                              "is_ascii_alphabetic",
                                              []
                                            |),
                                            [ c ]
                                          |)
                                        |) in
                                      let _ :=
                                        M.is_constant_or_break_match (|
                                          M.read (| γ |),
                                          Value.Bool true
                                        |) in
                                      let r :=
                                        M.alloc (|
                                          M.call_closure (|
                                            M.get_associated_function (|
                                              Ty.path "alloc::string::String",
                                              "new",
                                              []
                                            |),
                                            []
                                          |)
                                        |) in
                                      let _ :=
                                        M.alloc (|
                                          M.call_closure (|
                                            M.get_associated_function (|
                                              Ty.path "alloc::string::String",
                                              "push",
                                              []
                                            |),
                                            [ r; M.read (| c |) ]
                                          |)
                                        |) in
                                      let _ :=
                                        M.use
                                          (M.match_operator (|
                                            M.alloc (|
                                              M.call_closure (|
                                                M.get_trait_method (|
                                                  "core::iter::traits::collect::IntoIterator",
                                                  Ty.apply
                                                    (Ty.path
                                                      "core::iter::adapters::peekable::Peekable")
                                                    [ Ty.path "core::str::iter::Chars" ],
                                                  [],
                                                  "into_iter",
                                                  []
                                                |),
                                                [ M.read (| it |) ]
                                              |)
                                            |),
                                            [
                                              fun γ =>
                                                ltac:(M.monadic
                                                  (let iter := M.copy (| γ |) in
                                                  M.loop (|
                                                    ltac:(M.monadic
                                                      (let _ :=
                                                        M.match_operator (|
                                                          M.alloc (|
                                                            M.call_closure (|
                                                              M.get_trait_method (|
                                                                "core::iter::traits::iterator::Iterator",
                                                                Ty.apply
                                                                  (Ty.path
                                                                    "core::iter::adapters::peekable::Peekable")
                                                                  [ Ty.path "core::str::iter::Chars"
                                                                  ],
                                                                [],
                                                                "next",
                                                                []
                                                              |),
                                                              [ iter ]
                                                            |)
                                                          |),
                                                          [
                                                            fun γ =>
                                                              ltac:(M.monadic
                                                                (M.alloc (|
                                                                  M.never_to_any (|
                                                                    M.read (| M.break (||) |)
                                                                  |)
                                                                |)));
                                                            fun γ =>
                                                              ltac:(M.monadic
                                                                (let γ0_0 :=
                                                                  M.get_struct_tuple_field_or_break_match (|
                                                                    γ,
                                                                    "core::option::Option::Some",
                                                                    0
                                                                  |) in
                                                                let c := M.copy (| γ0_0 |) in
                                                                M.match_operator (|
                                                                  M.alloc (| Value.Tuple [] |),
                                                                  [
                                                                    fun γ =>
                                                                      ltac:(M.monadic
                                                                        (let γ :=
                                                                          M.use
                                                                            (M.alloc (|
                                                                              M.call_closure (|
                                                                                M.get_function (|
                                                                                  "move_core_types::identifier::is_valid_identifier_char",
                                                                                  []
                                                                                |),
                                                                                [ M.read (| c |) ]
                                                                              |)
                                                                            |)) in
                                                                        let _ :=
                                                                          M.is_constant_or_break_match (|
                                                                            M.read (| γ |),
                                                                            Value.Bool true
                                                                          |) in
                                                                        let _ :=
                                                                          M.alloc (|
                                                                            M.call_closure (|
                                                                              M.get_associated_function (|
                                                                                Ty.path
                                                                                  "alloc::string::String",
                                                                                "push",
                                                                                []
                                                                              |),
                                                                              [ r; M.read (| c |) ]
                                                                            |)
                                                                          |) in
                                                                        M.alloc (|
                                                                          Value.Tuple []
                                                                        |)));
                                                                    fun γ =>
                                                                      ltac:(M.monadic
                                                                        (M.alloc (|
                                                                          M.never_to_any (|
                                                                            M.read (|
                                                                              M.break (||)
                                                                            |)
                                                                          |)
                                                                        |)))
                                                                  ]
                                                                |)))
                                                          ]
                                                        |) in
                                                      M.alloc (| Value.Tuple [] |)))
                                                  |)))
                                            ]
                                          |)) in
                                      let len :=
                                        M.alloc (|
                                          M.call_closure (|
                                            M.get_associated_function (|
                                              Ty.path "alloc::string::String",
                                              "len",
                                              []
                                            |),
                                            [ r ]
                                          |)
                                        |) in
                                      M.alloc (|
                                        Value.Tuple
                                          [
                                            M.call_closure (|
                                              M.get_function (|
                                                "move_core_types::parser::name_token",
                                                []
                                              |),
                                              [ M.read (| r |) ]
                                            |);
                                            M.read (| len |)
                                          ]
                                      |)));
                                  fun γ =>
                                    ltac:(M.monadic
                                      (M.alloc (|
                                        M.never_to_any (|
                                          M.read (|
                                            M.return_ (|
                                              Value.StructTuple
                                                "core::result::Result::Err"
                                                [
                                                  M.read (|
                                                    let error :=
                                                      M.alloc (|
                                                        M.call_closure (|
                                                          M.get_function (|
                                                            "anyhow::private::format_err",
                                                            []
                                                          |),
                                                          [
                                                            M.call_closure (|
                                                              M.get_associated_function (|
                                                                Ty.path "core::fmt::Arguments",
                                                                "new_const",
                                                                []
                                                              |),
                                                              [
                                                                (* Unsize *)
                                                                M.pointer_coercion
                                                                  (M.alloc (|
                                                                    Value.Array
                                                                      [
                                                                        M.read (|
                                                                          mk_str
                                                                            "unrecognized token"
                                                                        |)
                                                                      ]
                                                                  |))
                                                              ]
                                                            |)
                                                          ]
                                                        |)
                                                      |) in
                                                    error
                                                  |)
                                                ]
                                            |)
                                          |)
                                        |)
                                      |)))
                                ]
                              |)
                            |)
                          ]
                      ]
                  |)))
            ]
          |)
        |)))
    | _, _ => M.impossible
    end.
  
  (*
  fn tokenize(mut s: &str) -> Result<Vec<Token>> {
      let mut v = vec![];
      while let Some((tok, n)) = next_token(s)? {
          v.push(tok);
          s = &s[n..];
      }
      Ok(v)
  }
  *)
  Definition tokenize (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ s ] =>
      ltac:(M.monadic
        (let s := M.alloc (| s |) in
        M.read (|
          let v :=
            M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    [ Ty.path "move_core_types::parser::Token"; Ty.path "alloc::alloc::Global" ],
                  "new",
                  []
                |),
                []
              |)
            |) in
          let _ :=
            M.loop (|
              ltac:(M.monadic
                (M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.match_operator (|
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    [
                                      Ty.apply
                                        (Ty.path "core::option::Option")
                                        [
                                          Ty.tuple
                                            [
                                              Ty.path "move_core_types::parser::Token";
                                              Ty.path "usize"
                                            ]
                                        ];
                                      Ty.path "anyhow::Error"
                                    ],
                                  [],
                                  "branch",
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    M.get_function (| "move_core_types::parser::next_token", [] |),
                                    [ M.read (| s |) ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.get_struct_tuple_field_or_break_match (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                [
                                                  Ty.apply
                                                    (Ty.path "alloc::vec::Vec")
                                                    [
                                                      Ty.path "move_core_types::parser::Token";
                                                      Ty.path "alloc::alloc::Global"
                                                    ];
                                                  Ty.path "anyhow::Error"
                                                ],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "anyhow::Error"
                                                  ]
                                              ],
                                              "from_residual",
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.get_struct_tuple_field_or_break_match (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |) in
                        let γ0_0 :=
                          M.get_struct_tuple_field_or_break_match (|
                            γ,
                            "core::option::Option::Some",
                            0
                          |) in
                        let γ1_0 := M.get_tuple_field γ0_0 0 in
                        let γ1_1 := M.get_tuple_field γ0_0 1 in
                        let tok := M.copy (| γ1_0 |) in
                        let n := M.copy (| γ1_1 |) in
                        let _ :=
                          M.alloc (|
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "alloc::vec::Vec")
                                  [
                                    Ty.path "move_core_types::parser::Token";
                                    Ty.path "alloc::alloc::Global"
                                  ],
                                "push",
                                []
                              |),
                              [ v; M.read (| tok |) ]
                            |)
                          |) in
                        let _ :=
                          M.write (|
                            s,
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::ops::index::Index",
                                Ty.path "str",
                                [
                                  Ty.apply
                                    (Ty.path "core::ops::range::RangeFrom")
                                    [ Ty.path "usize" ]
                                ],
                                "index",
                                []
                              |),
                              [
                                M.read (| s |);
                                Value.StructRecord
                                  "core::ops::range::RangeFrom"
                                  [ ("start", M.read (| n |)) ]
                              ]
                            |)
                          |) in
                        M.alloc (| Value.Tuple [] |)));
                    fun γ =>
                      ltac:(M.monadic
                        (M.alloc (|
                          M.never_to_any (|
                            M.read (|
                              let _ :=
                                M.alloc (| M.never_to_any (| M.read (| M.break (||) |) |) |) in
                              M.alloc (| Value.Tuple [] |)
                            |)
                          |)
                        |)))
                  ]
                |)))
            |) in
          M.alloc (| Value.StructTuple "core::result::Result::Ok" [ M.read (| v |) ] |)
        |)))
    | _, _ => M.impossible
    end.
  
  (* StructRecord
    {
      name := "Parser";
      ty_params := [ "I" ];
      fields := [ ("it", Ty.apply (Ty.path "core::iter::adapters::peekable::Peekable") [ I ]) ];
    } *)
  
  Module Impl_move_core_types_parser_Parser_I.
    Definition Self (I : Ty.t) : Ty.t := Ty.apply (Ty.path "move_core_types::parser::Parser") [ I ].
    
    (*
        fn new<T: IntoIterator<Item = Token, IntoIter = I>>(v: T) -> Self {
            Self {
                it: v.into_iter().peekable(),
            }
        }
    *)
    Definition new (I : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self I in
      match τ, α with
      | [ T ], [ v ] =>
        ltac:(M.monadic
          (let v := M.alloc (| v |) in
          Value.StructRecord
            "move_core_types::parser::Parser"
            [
              ("it",
                M.call_closure (|
                  M.get_trait_method (|
                    "core::iter::traits::iterator::Iterator",
                    I,
                    [],
                    "peekable",
                    []
                  |),
                  [
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::iter::traits::collect::IntoIterator",
                        T,
                        [],
                        "into_iter",
                        []
                      |),
                      [ M.read (| v |) ]
                    |)
                  ]
                |))
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_new : forall (I : Ty.t), M.IsAssociatedFunction (Self I) "new" (new I).
    
    (*
        fn next(&mut self) -> Result<Token> {
            match self.it.next() {
                Some(tok) => Ok(tok),
                None => bail!("out of tokens, this should not happen"),
            }
        }
    *)
    Definition next (I : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self I in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "core::iter::traits::iterator::Iterator",
                    Ty.apply (Ty.path "core::iter::adapters::peekable::Peekable") [ I ],
                    [],
                    "next",
                    []
                  |),
                  [
                    M.get_struct_record_field
                      (M.read (| self |))
                      "move_core_types::parser::Parser"
                      "it"
                  ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let tok := M.copy (| γ0_0 |) in
                    M.alloc (|
                      Value.StructTuple "core::result::Result::Ok" [ M.read (| tok |) ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.never_to_any (|
                        M.read (|
                          M.return_ (|
                            Value.StructTuple
                              "core::result::Result::Err"
                              [
                                M.read (|
                                  let error :=
                                    M.alloc (|
                                      M.call_closure (|
                                        M.get_function (| "anyhow::private::format_err", [] |),
                                        [
                                          M.call_closure (|
                                            M.get_associated_function (|
                                              Ty.path "core::fmt::Arguments",
                                              "new_const",
                                              []
                                            |),
                                            [
                                              (* Unsize *)
                                              M.pointer_coercion
                                                (M.alloc (|
                                                  Value.Array
                                                    [
                                                      M.read (|
                                                        mk_str
                                                          "out of tokens, this should not happen"
                                                      |)
                                                    ]
                                                |))
                                            ]
                                          |)
                                        ]
                                      |)
                                    |) in
                                  error
                                |)
                              ]
                          |)
                        |)
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_next :
      forall (I : Ty.t),
      M.IsAssociatedFunction (Self I) "next" (next I).
    
    (*
        fn peek(&mut self) -> Option<&Token> {
            self.it.peek()
        }
    *)
    Definition peek (I : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self I in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply (Ty.path "core::iter::adapters::peekable::Peekable") [ I ],
              "peek",
              []
            |),
            [ M.get_struct_record_field (M.read (| self |)) "move_core_types::parser::Parser" "it" ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_peek :
      forall (I : Ty.t),
      M.IsAssociatedFunction (Self I) "peek" (peek I).
    
    (*
        fn consume(&mut self, tok: Token) -> Result<()> {
            let t = self.next()?;
            if t != tok {
                bail!("expected token {:?}, got {:?}", tok, t)
            }
            Ok(())
        }
    *)
    Definition consume (I : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self I in
      match τ, α with
      | [], [ self; tok ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let tok := M.alloc (| tok |) in
          M.read (|
            let t :=
              M.copy (|
                M.match_operator (|
                  M.alloc (|
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::ops::try_trait::Try",
                        Ty.apply
                          (Ty.path "core::result::Result")
                          [ Ty.path "move_core_types::parser::Token"; Ty.path "anyhow::Error" ],
                        [],
                        "branch",
                        []
                      |),
                      [
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply (Ty.path "move_core_types::parser::Parser") [ I ],
                            "next",
                            []
                          |),
                          [ M.read (| self |) ]
                        |)
                      ]
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.get_struct_tuple_field_or_break_match (|
                            γ,
                            "core::ops::control_flow::ControlFlow::Break",
                            0
                          |) in
                        let residual := M.copy (| γ0_0 |) in
                        M.alloc (|
                          M.never_to_any (|
                            M.read (|
                              M.return_ (|
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::ops::try_trait::FromResidual",
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      [ Ty.tuple []; Ty.path "anyhow::Error" ],
                                    [
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        [
                                          Ty.path "core::convert::Infallible";
                                          Ty.path "anyhow::Error"
                                        ]
                                    ],
                                    "from_residual",
                                    []
                                  |),
                                  [ M.read (| residual |) ]
                                |)
                              |)
                            |)
                          |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.get_struct_tuple_field_or_break_match (|
                            γ,
                            "core::ops::control_flow::ControlFlow::Continue",
                            0
                          |) in
                        let val := M.copy (| γ0_0 |) in
                        val))
                  ]
                |)
              |) in
            let _ :=
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::cmp::PartialEq",
                                Ty.path "move_core_types::parser::Token",
                                [ Ty.path "move_core_types::parser::Token" ],
                                "ne",
                                []
                              |),
                              [ t; tok ]
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        M.never_to_any (|
                          M.read (|
                            M.return_ (|
                              Value.StructTuple
                                "core::result::Result::Err"
                                [
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.path "anyhow::Error",
                                      "msg",
                                      [ Ty.path "alloc::string::String" ]
                                    |),
                                    [
                                      M.read (|
                                        let res :=
                                          M.alloc (|
                                            M.call_closure (|
                                              M.get_function (| "alloc::fmt::format", [] |),
                                              [
                                                M.call_closure (|
                                                  M.get_associated_function (|
                                                    Ty.path "core::fmt::Arguments",
                                                    "new_v1",
                                                    []
                                                  |),
                                                  [
                                                    (* Unsize *)
                                                    M.pointer_coercion
                                                      (M.alloc (|
                                                        Value.Array
                                                          [
                                                            M.read (| mk_str "expected token " |);
                                                            M.read (| mk_str ", got " |)
                                                          ]
                                                      |));
                                                    (* Unsize *)
                                                    M.pointer_coercion
                                                      (M.alloc (|
                                                        Value.Array
                                                          [
                                                            M.call_closure (|
                                                              M.get_associated_function (|
                                                                Ty.path "core::fmt::rt::Argument",
                                                                "new_debug",
                                                                [
                                                                  Ty.path
                                                                    "move_core_types::parser::Token"
                                                                ]
                                                              |),
                                                              [ tok ]
                                                            |);
                                                            M.call_closure (|
                                                              M.get_associated_function (|
                                                                Ty.path "core::fmt::rt::Argument",
                                                                "new_debug",
                                                                [
                                                                  Ty.path
                                                                    "move_core_types::parser::Token"
                                                                ]
                                                              |),
                                                              [ t ]
                                                            |)
                                                          ]
                                                      |))
                                                  ]
                                                |)
                                              ]
                                            |)
                                          |) in
                                        res
                                      |)
                                    ]
                                  |)
                                ]
                            |)
                          |)
                        |)
                      |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            M.alloc (| Value.StructTuple "core::result::Result::Ok" [ Value.Tuple [] ] |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_consume :
      forall (I : Ty.t),
      M.IsAssociatedFunction (Self I) "consume" (consume I).
    
    (*
        fn parse_comma_list<F, R>(
            &mut self,
            parse_list_item: F,
            end_token: Token,
            allow_trailing_comma: bool,
        ) -> Result<Vec<R>>
        where
            F: Fn(&mut Self) -> Result<R>,
            R: std::fmt::Debug,
        {
            let mut v = vec![];
            if !(self.peek() == Some(&end_token)) {
                loop {
                    v.push(parse_list_item(self)?);
                    if self.peek() == Some(&end_token) {
                        break;
                    }
                    self.consume(Token::Comma)?;
                    if self.peek() == Some(&end_token) && allow_trailing_comma {
                        break;
                    }
                }
            }
            Ok(v)
        }
    *)
    Definition parse_comma_list (I : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self I in
      match τ, α with
      | [ F; R ], [ self; parse_list_item; end_token; allow_trailing_comma ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let parse_list_item := M.alloc (| parse_list_item |) in
          let end_token := M.alloc (| end_token |) in
          let allow_trailing_comma := M.alloc (| allow_trailing_comma |) in
          M.read (|
            let v :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloc::vec::Vec") [ R; Ty.path "alloc::alloc::Global" ],
                    "new",
                    []
                  |),
                  []
                |)
              |) in
            let _ :=
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            UnOp.Pure.not
                              (M.call_closure (|
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.apply
                                    (Ty.path "core::option::Option")
                                    [
                                      Ty.apply
                                        (Ty.path "&")
                                        [ Ty.path "move_core_types::parser::Token" ]
                                    ],
                                  [
                                    Ty.apply
                                      (Ty.path "core::option::Option")
                                      [
                                        Ty.apply
                                          (Ty.path "&")
                                          [ Ty.path "move_core_types::parser::Token" ]
                                      ]
                                  ],
                                  "eq",
                                  []
                                |),
                                [
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.apply (Ty.path "move_core_types::parser::Parser") [ I ],
                                        "peek",
                                        []
                                      |),
                                      [ M.read (| self |) ]
                                    |)
                                  |);
                                  M.alloc (|
                                    Value.StructTuple "core::option::Option::Some" [ end_token ]
                                  |)
                                ]
                              |))
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.loop (|
                        ltac:(M.monadic
                          (let _ :=
                            M.alloc (|
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "alloc::vec::Vec")
                                    [ R; Ty.path "alloc::alloc::Global" ],
                                  "push",
                                  []
                                |),
                                [
                                  v;
                                  M.read (|
                                    M.match_operator (|
                                      M.alloc (|
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::ops::try_trait::Try",
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              [ R; Ty.path "anyhow::Error" ],
                                            [],
                                            "branch",
                                            []
                                          |),
                                          [
                                            M.call_closure (|
                                              M.get_trait_method (|
                                                "core::ops::function::Fn",
                                                F,
                                                [
                                                  Ty.tuple
                                                    [
                                                      Ty.apply
                                                        (Ty.path "&mut")
                                                        [
                                                          Ty.apply
                                                            (Ty.path
                                                              "move_core_types::parser::Parser")
                                                            [ I ]
                                                        ]
                                                    ]
                                                ],
                                                "call",
                                                []
                                              |),
                                              [ parse_list_item; Value.Tuple [ M.read (| self |) ] ]
                                            |)
                                          ]
                                        |)
                                      |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.get_struct_tuple_field_or_break_match (|
                                                γ,
                                                "core::ops::control_flow::ControlFlow::Break",
                                                0
                                              |) in
                                            let residual := M.copy (| γ0_0 |) in
                                            M.alloc (|
                                              M.never_to_any (|
                                                M.read (|
                                                  M.return_ (|
                                                    M.call_closure (|
                                                      M.get_trait_method (|
                                                        "core::ops::try_trait::FromResidual",
                                                        Ty.apply
                                                          (Ty.path "core::result::Result")
                                                          [
                                                            Ty.apply
                                                              (Ty.path "alloc::vec::Vec")
                                                              [ R; Ty.path "alloc::alloc::Global" ];
                                                            Ty.path "anyhow::Error"
                                                          ],
                                                        [
                                                          Ty.apply
                                                            (Ty.path "core::result::Result")
                                                            [
                                                              Ty.path "core::convert::Infallible";
                                                              Ty.path "anyhow::Error"
                                                            ]
                                                        ],
                                                        "from_residual",
                                                        []
                                                      |),
                                                      [ M.read (| residual |) ]
                                                    |)
                                                  |)
                                                |)
                                              |)
                                            |)));
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.get_struct_tuple_field_or_break_match (|
                                                γ,
                                                "core::ops::control_flow::ControlFlow::Continue",
                                                0
                                              |) in
                                            let val := M.copy (| γ0_0 |) in
                                            val))
                                      ]
                                    |)
                                  |)
                                ]
                              |)
                            |) in
                          let _ :=
                            M.match_operator (|
                              M.alloc (| Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ :=
                                      M.use
                                        (M.alloc (|
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::cmp::PartialEq",
                                              Ty.apply
                                                (Ty.path "core::option::Option")
                                                [
                                                  Ty.apply
                                                    (Ty.path "&")
                                                    [ Ty.path "move_core_types::parser::Token" ]
                                                ],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::option::Option")
                                                  [
                                                    Ty.apply
                                                      (Ty.path "&")
                                                      [ Ty.path "move_core_types::parser::Token" ]
                                                  ]
                                              ],
                                              "eq",
                                              []
                                            |),
                                            [
                                              M.alloc (|
                                                M.call_closure (|
                                                  M.get_associated_function (|
                                                    Ty.apply
                                                      (Ty.path "move_core_types::parser::Parser")
                                                      [ I ],
                                                    "peek",
                                                    []
                                                  |),
                                                  [ M.read (| self |) ]
                                                |)
                                              |);
                                              M.alloc (|
                                                Value.StructTuple
                                                  "core::option::Option::Some"
                                                  [ end_token ]
                                              |)
                                            ]
                                          |)
                                        |)) in
                                    let _ :=
                                      M.is_constant_or_break_match (|
                                        M.read (| γ |),
                                        Value.Bool true
                                      |) in
                                    M.alloc (| M.never_to_any (| M.read (| M.break (||) |) |) |)));
                                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                              ]
                            |) in
                          let _ :=
                            M.match_operator (|
                              M.alloc (|
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::ops::try_trait::Try",
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      [ Ty.tuple []; Ty.path "anyhow::Error" ],
                                    [],
                                    "branch",
                                    []
                                  |),
                                  [
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.apply (Ty.path "move_core_types::parser::Parser") [ I ],
                                        "consume",
                                        []
                                      |),
                                      [
                                        M.read (| self |);
                                        Value.StructTuple "move_core_types::parser::Token::Comma" []
                                      ]
                                    |)
                                  ]
                                |)
                              |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ0_0 :=
                                      M.get_struct_tuple_field_or_break_match (|
                                        γ,
                                        "core::ops::control_flow::ControlFlow::Break",
                                        0
                                      |) in
                                    let residual := M.copy (| γ0_0 |) in
                                    M.alloc (|
                                      M.never_to_any (|
                                        M.read (|
                                          M.return_ (|
                                            M.call_closure (|
                                              M.get_trait_method (|
                                                "core::ops::try_trait::FromResidual",
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  [
                                                    Ty.apply
                                                      (Ty.path "alloc::vec::Vec")
                                                      [ R; Ty.path "alloc::alloc::Global" ];
                                                    Ty.path "anyhow::Error"
                                                  ],
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::result::Result")
                                                    [
                                                      Ty.path "core::convert::Infallible";
                                                      Ty.path "anyhow::Error"
                                                    ]
                                                ],
                                                "from_residual",
                                                []
                                              |),
                                              [ M.read (| residual |) ]
                                            |)
                                          |)
                                        |)
                                      |)
                                    |)));
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ0_0 :=
                                      M.get_struct_tuple_field_or_break_match (|
                                        γ,
                                        "core::ops::control_flow::ControlFlow::Continue",
                                        0
                                      |) in
                                    let val := M.copy (| γ0_0 |) in
                                    val))
                              ]
                            |) in
                          M.match_operator (|
                            M.alloc (| Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ :=
                                    M.use
                                      (M.alloc (|
                                        LogicalOp.and (|
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::cmp::PartialEq",
                                              Ty.apply
                                                (Ty.path "core::option::Option")
                                                [
                                                  Ty.apply
                                                    (Ty.path "&")
                                                    [ Ty.path "move_core_types::parser::Token" ]
                                                ],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::option::Option")
                                                  [
                                                    Ty.apply
                                                      (Ty.path "&")
                                                      [ Ty.path "move_core_types::parser::Token" ]
                                                  ]
                                              ],
                                              "eq",
                                              []
                                            |),
                                            [
                                              M.alloc (|
                                                M.call_closure (|
                                                  M.get_associated_function (|
                                                    Ty.apply
                                                      (Ty.path "move_core_types::parser::Parser")
                                                      [ I ],
                                                    "peek",
                                                    []
                                                  |),
                                                  [ M.read (| self |) ]
                                                |)
                                              |);
                                              M.alloc (|
                                                Value.StructTuple
                                                  "core::option::Option::Some"
                                                  [ end_token ]
                                              |)
                                            ]
                                          |),
                                          ltac:(M.monadic (M.read (| allow_trailing_comma |)))
                                        |)
                                      |)) in
                                  let _ :=
                                    M.is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  M.alloc (| M.never_to_any (| M.read (| M.break (||) |) |) |)));
                              fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                            ]
                          |)))
                      |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            M.alloc (| Value.StructTuple "core::result::Result::Ok" [ M.read (| v |) ] |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_parse_comma_list :
      forall (I : Ty.t),
      M.IsAssociatedFunction (Self I) "parse_comma_list" (parse_comma_list I).
    
    (*
        fn parse_string(&mut self) -> Result<String> {
            Ok(match self.next()? {
                Token::Name(s) => s,
                tok => bail!("unexpected token {:?}, expected string", tok),
            })
        }
    *)
    Definition parse_string (I : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self I in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.StructTuple
            "core::result::Result::Ok"
            [
              M.read (|
                M.match_operator (|
                  M.match_operator (|
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::ops::try_trait::Try",
                          Ty.apply
                            (Ty.path "core::result::Result")
                            [ Ty.path "move_core_types::parser::Token"; Ty.path "anyhow::Error" ],
                          [],
                          "branch",
                          []
                        |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "move_core_types::parser::Parser") [ I ],
                              "next",
                              []
                            |),
                            [ M.read (| self |) ]
                          |)
                        ]
                      |)
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.get_struct_tuple_field_or_break_match (|
                              γ,
                              "core::ops::control_flow::ControlFlow::Break",
                              0
                            |) in
                          let residual := M.copy (| γ0_0 |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::ops::try_trait::FromResidual",
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        [ Ty.path "alloc::string::String"; Ty.path "anyhow::Error"
                                        ],
                                      [
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          [
                                            Ty.path "core::convert::Infallible";
                                            Ty.path "anyhow::Error"
                                          ]
                                      ],
                                      "from_residual",
                                      []
                                    |),
                                    [ M.read (| residual |) ]
                                  |)
                                |)
                              |)
                            |)
                          |)));
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.get_struct_tuple_field_or_break_match (|
                              γ,
                              "core::ops::control_flow::ControlFlow::Continue",
                              0
                            |) in
                          let val := M.copy (| γ0_0 |) in
                          val))
                    ]
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.get_struct_tuple_field_or_break_match (|
                            γ,
                            "move_core_types::parser::Token::Name",
                            0
                          |) in
                        let s := M.copy (| γ0_0 |) in
                        s));
                    fun γ =>
                      ltac:(M.monadic
                        (let tok := M.copy (| γ |) in
                        M.alloc (|
                          M.never_to_any (|
                            M.read (|
                              M.return_ (|
                                Value.StructTuple
                                  "core::result::Result::Err"
                                  [
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.path "anyhow::Error",
                                        "msg",
                                        [ Ty.path "alloc::string::String" ]
                                      |),
                                      [
                                        M.read (|
                                          let res :=
                                            M.alloc (|
                                              M.call_closure (|
                                                M.get_function (| "alloc::fmt::format", [] |),
                                                [
                                                  M.call_closure (|
                                                    M.get_associated_function (|
                                                      Ty.path "core::fmt::Arguments",
                                                      "new_v1",
                                                      []
                                                    |),
                                                    [
                                                      (* Unsize *)
                                                      M.pointer_coercion
                                                        (M.alloc (|
                                                          Value.Array
                                                            [
                                                              M.read (|
                                                                mk_str "unexpected token "
                                                              |);
                                                              M.read (|
                                                                mk_str ", expected string"
                                                              |)
                                                            ]
                                                        |));
                                                      (* Unsize *)
                                                      M.pointer_coercion
                                                        (M.alloc (|
                                                          Value.Array
                                                            [
                                                              M.call_closure (|
                                                                M.get_associated_function (|
                                                                  Ty.path "core::fmt::rt::Argument",
                                                                  "new_debug",
                                                                  [
                                                                    Ty.path
                                                                      "move_core_types::parser::Token"
                                                                  ]
                                                                |),
                                                                [ tok ]
                                                              |)
                                                            ]
                                                        |))
                                                    ]
                                                  |)
                                                ]
                                              |)
                                            |) in
                                          res
                                        |)
                                      ]
                                    |)
                                  ]
                              |)
                            |)
                          |)
                        |)))
                  ]
                |)
              |)
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_parse_string :
      forall (I : Ty.t),
      M.IsAssociatedFunction (Self I) "parse_string" (parse_string I).
    
    (*
        fn parse_type_tag(&mut self) -> Result<TypeTag> {
            Ok(match self.next()? {
                Token::U8Type => TypeTag::U8,
                Token::U16Type => TypeTag::U16,
                Token::U32Type => TypeTag::U32,
                Token::U64Type => TypeTag::U64,
                Token::U128Type => TypeTag::U128,
                Token::U256Type => TypeTag::U256,
                Token::BoolType => TypeTag::Bool,
                Token::AddressType => TypeTag::Address,
                Token::SignerType => TypeTag::Signer,
                Token::VectorType => {
                    self.consume(Token::Lt)?;
                    let ty = self.parse_type_tag()?;
                    self.consume(Token::Gt)?;
                    TypeTag::Vector(Box::new(ty))
                }
                Token::Address(addr) => {
                    self.consume(Token::ColonColon)?;
                    match self.next()? {
                        Token::Name(module) => {
                            self.consume(Token::ColonColon)?;
                            match self.next()? {
                                Token::Name(name) => {
                                    let ty_args = if self.peek() == Some(&Token::Lt) {
                                        self.next()?;
                                        let ty_args = self.parse_comma_list(
                                            |parser| parser.parse_type_tag(),
                                            Token::Gt,
                                            true,
                                        )?;
                                        self.consume(Token::Gt)?;
                                        ty_args
                                    } else {
                                        vec![]
                                    };
                                    TypeTag::Struct(Box::new(StructTag {
                                        address: AccountAddress::from_hex_literal(&addr)?,
                                        module: Identifier::new(module)?,
                                        name: Identifier::new(name)?,
                                        type_params: ty_args,
                                    }))
                                }
                                t => bail!("expected name, got {:?}", t),
                            }
                        }
                        t => bail!("expected name, got {:?}", t),
                    }
                }
                tok => bail!("unexpected token {:?}, expected type tag", tok),
            })
        }
    *)
    Definition parse_type_tag (I : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self I in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.StructTuple
            "core::result::Result::Ok"
            [
              M.read (|
                M.match_operator (|
                  M.match_operator (|
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::ops::try_trait::Try",
                          Ty.apply
                            (Ty.path "core::result::Result")
                            [ Ty.path "move_core_types::parser::Token"; Ty.path "anyhow::Error" ],
                          [],
                          "branch",
                          []
                        |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "move_core_types::parser::Parser") [ I ],
                              "next",
                              []
                            |),
                            [ M.read (| self |) ]
                          |)
                        ]
                      |)
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.get_struct_tuple_field_or_break_match (|
                              γ,
                              "core::ops::control_flow::ControlFlow::Break",
                              0
                            |) in
                          let residual := M.copy (| γ0_0 |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::ops::try_trait::FromResidual",
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        [
                                          Ty.path "move_core_types::language_storage::TypeTag";
                                          Ty.path "anyhow::Error"
                                        ],
                                      [
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          [
                                            Ty.path "core::convert::Infallible";
                                            Ty.path "anyhow::Error"
                                          ]
                                      ],
                                      "from_residual",
                                      []
                                    |),
                                    [ M.read (| residual |) ]
                                  |)
                                |)
                              |)
                            |)
                          |)));
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.get_struct_tuple_field_or_break_match (|
                              γ,
                              "core::ops::control_flow::ControlFlow::Continue",
                              0
                            |) in
                          let val := M.copy (| γ0_0 |) in
                          val))
                    ]
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (M.alloc (|
                          Value.StructTuple "move_core_types::language_storage::TypeTag::U8" []
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (M.alloc (|
                          Value.StructTuple "move_core_types::language_storage::TypeTag::U16" []
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (M.alloc (|
                          Value.StructTuple "move_core_types::language_storage::TypeTag::U32" []
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (M.alloc (|
                          Value.StructTuple "move_core_types::language_storage::TypeTag::U64" []
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (M.alloc (|
                          Value.StructTuple "move_core_types::language_storage::TypeTag::U128" []
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (M.alloc (|
                          Value.StructTuple "move_core_types::language_storage::TypeTag::U256" []
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (M.alloc (|
                          Value.StructTuple "move_core_types::language_storage::TypeTag::Bool" []
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (M.alloc (|
                          Value.StructTuple "move_core_types::language_storage::TypeTag::Address" []
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (M.alloc (|
                          Value.StructTuple "move_core_types::language_storage::TypeTag::Signer" []
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let _ :=
                          M.match_operator (|
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    [ Ty.tuple []; Ty.path "anyhow::Error" ],
                                  [],
                                  "branch",
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "move_core_types::parser::Parser") [ I ],
                                      "consume",
                                      []
                                    |),
                                    [
                                      M.read (| self |);
                                      Value.StructTuple "move_core_types::parser::Token::Lt" []
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.get_struct_tuple_field_or_break_match (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                [
                                                  Ty.path
                                                    "move_core_types::language_storage::TypeTag";
                                                  Ty.path "anyhow::Error"
                                                ],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "anyhow::Error"
                                                  ]
                                              ],
                                              "from_residual",
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.get_struct_tuple_field_or_break_match (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |) in
                        let ty :=
                          M.copy (|
                            M.match_operator (|
                              M.alloc (|
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::ops::try_trait::Try",
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      [
                                        Ty.path "move_core_types::language_storage::TypeTag";
                                        Ty.path "anyhow::Error"
                                      ],
                                    [],
                                    "branch",
                                    []
                                  |),
                                  [
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.apply (Ty.path "move_core_types::parser::Parser") [ I ],
                                        "parse_type_tag",
                                        []
                                      |),
                                      [ M.read (| self |) ]
                                    |)
                                  ]
                                |)
                              |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ0_0 :=
                                      M.get_struct_tuple_field_or_break_match (|
                                        γ,
                                        "core::ops::control_flow::ControlFlow::Break",
                                        0
                                      |) in
                                    let residual := M.copy (| γ0_0 |) in
                                    M.alloc (|
                                      M.never_to_any (|
                                        M.read (|
                                          M.return_ (|
                                            M.call_closure (|
                                              M.get_trait_method (|
                                                "core::ops::try_trait::FromResidual",
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  [
                                                    Ty.path
                                                      "move_core_types::language_storage::TypeTag";
                                                    Ty.path "anyhow::Error"
                                                  ],
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::result::Result")
                                                    [
                                                      Ty.path "core::convert::Infallible";
                                                      Ty.path "anyhow::Error"
                                                    ]
                                                ],
                                                "from_residual",
                                                []
                                              |),
                                              [ M.read (| residual |) ]
                                            |)
                                          |)
                                        |)
                                      |)
                                    |)));
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ0_0 :=
                                      M.get_struct_tuple_field_or_break_match (|
                                        γ,
                                        "core::ops::control_flow::ControlFlow::Continue",
                                        0
                                      |) in
                                    let val := M.copy (| γ0_0 |) in
                                    val))
                              ]
                            |)
                          |) in
                        let _ :=
                          M.match_operator (|
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    [ Ty.tuple []; Ty.path "anyhow::Error" ],
                                  [],
                                  "branch",
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "move_core_types::parser::Parser") [ I ],
                                      "consume",
                                      []
                                    |),
                                    [
                                      M.read (| self |);
                                      Value.StructTuple "move_core_types::parser::Token::Gt" []
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.get_struct_tuple_field_or_break_match (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                [
                                                  Ty.path
                                                    "move_core_types::language_storage::TypeTag";
                                                  Ty.path "anyhow::Error"
                                                ],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "anyhow::Error"
                                                  ]
                                              ],
                                              "from_residual",
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.get_struct_tuple_field_or_break_match (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |) in
                        M.alloc (|
                          Value.StructTuple
                            "move_core_types::language_storage::TypeTag::Vector"
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "alloc::boxed::Box")
                                    [
                                      Ty.path "move_core_types::language_storage::TypeTag";
                                      Ty.path "alloc::alloc::Global"
                                    ],
                                  "new",
                                  []
                                |),
                                [ M.read (| ty |) ]
                              |)
                            ]
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.get_struct_tuple_field_or_break_match (|
                            γ,
                            "move_core_types::parser::Token::Address",
                            0
                          |) in
                        let addr := M.copy (| γ0_0 |) in
                        let _ :=
                          M.match_operator (|
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    [ Ty.tuple []; Ty.path "anyhow::Error" ],
                                  [],
                                  "branch",
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "move_core_types::parser::Parser") [ I ],
                                      "consume",
                                      []
                                    |),
                                    [
                                      M.read (| self |);
                                      Value.StructTuple
                                        "move_core_types::parser::Token::ColonColon"
                                        []
                                    ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.get_struct_tuple_field_or_break_match (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                [
                                                  Ty.path
                                                    "move_core_types::language_storage::TypeTag";
                                                  Ty.path "anyhow::Error"
                                                ],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "anyhow::Error"
                                                  ]
                                              ],
                                              "from_residual",
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.get_struct_tuple_field_or_break_match (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |) in
                        M.match_operator (|
                          M.match_operator (|
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::ops::try_trait::Try",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    [
                                      Ty.path "move_core_types::parser::Token";
                                      Ty.path "anyhow::Error"
                                    ],
                                  [],
                                  "branch",
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "move_core_types::parser::Parser") [ I ],
                                      "next",
                                      []
                                    |),
                                    [ M.read (| self |) ]
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.get_struct_tuple_field_or_break_match (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Break",
                                      0
                                    |) in
                                  let residual := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                [
                                                  Ty.path
                                                    "move_core_types::language_storage::TypeTag";
                                                  Ty.path "anyhow::Error"
                                                ],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "anyhow::Error"
                                                  ]
                                              ],
                                              "from_residual",
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.get_struct_tuple_field_or_break_match (|
                                      γ,
                                      "core::ops::control_flow::ControlFlow::Continue",
                                      0
                                    |) in
                                  let val := M.copy (| γ0_0 |) in
                                  val))
                            ]
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.get_struct_tuple_field_or_break_match (|
                                    γ,
                                    "move_core_types::parser::Token::Name",
                                    0
                                  |) in
                                let module := M.copy (| γ0_0 |) in
                                let _ :=
                                  M.match_operator (|
                                    M.alloc (|
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::ops::try_trait::Try",
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            [ Ty.tuple []; Ty.path "anyhow::Error" ],
                                          [],
                                          "branch",
                                          []
                                        |),
                                        [
                                          M.call_closure (|
                                            M.get_associated_function (|
                                              Ty.apply
                                                (Ty.path "move_core_types::parser::Parser")
                                                [ I ],
                                              "consume",
                                              []
                                            |),
                                            [
                                              M.read (| self |);
                                              Value.StructTuple
                                                "move_core_types::parser::Token::ColonColon"
                                                []
                                            ]
                                          |)
                                        ]
                                      |)
                                    |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let γ0_0 :=
                                            M.get_struct_tuple_field_or_break_match (|
                                              γ,
                                              "core::ops::control_flow::ControlFlow::Break",
                                              0
                                            |) in
                                          let residual := M.copy (| γ0_0 |) in
                                          M.alloc (|
                                            M.never_to_any (|
                                              M.read (|
                                                M.return_ (|
                                                  M.call_closure (|
                                                    M.get_trait_method (|
                                                      "core::ops::try_trait::FromResidual",
                                                      Ty.apply
                                                        (Ty.path "core::result::Result")
                                                        [
                                                          Ty.path
                                                            "move_core_types::language_storage::TypeTag";
                                                          Ty.path "anyhow::Error"
                                                        ],
                                                      [
                                                        Ty.apply
                                                          (Ty.path "core::result::Result")
                                                          [
                                                            Ty.path "core::convert::Infallible";
                                                            Ty.path "anyhow::Error"
                                                          ]
                                                      ],
                                                      "from_residual",
                                                      []
                                                    |),
                                                    [ M.read (| residual |) ]
                                                  |)
                                                |)
                                              |)
                                            |)
                                          |)));
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let γ0_0 :=
                                            M.get_struct_tuple_field_or_break_match (|
                                              γ,
                                              "core::ops::control_flow::ControlFlow::Continue",
                                              0
                                            |) in
                                          let val := M.copy (| γ0_0 |) in
                                          val))
                                    ]
                                  |) in
                                M.match_operator (|
                                  M.match_operator (|
                                    M.alloc (|
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::ops::try_trait::Try",
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            [
                                              Ty.path "move_core_types::parser::Token";
                                              Ty.path "anyhow::Error"
                                            ],
                                          [],
                                          "branch",
                                          []
                                        |),
                                        [
                                          M.call_closure (|
                                            M.get_associated_function (|
                                              Ty.apply
                                                (Ty.path "move_core_types::parser::Parser")
                                                [ I ],
                                              "next",
                                              []
                                            |),
                                            [ M.read (| self |) ]
                                          |)
                                        ]
                                      |)
                                    |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let γ0_0 :=
                                            M.get_struct_tuple_field_or_break_match (|
                                              γ,
                                              "core::ops::control_flow::ControlFlow::Break",
                                              0
                                            |) in
                                          let residual := M.copy (| γ0_0 |) in
                                          M.alloc (|
                                            M.never_to_any (|
                                              M.read (|
                                                M.return_ (|
                                                  M.call_closure (|
                                                    M.get_trait_method (|
                                                      "core::ops::try_trait::FromResidual",
                                                      Ty.apply
                                                        (Ty.path "core::result::Result")
                                                        [
                                                          Ty.path
                                                            "move_core_types::language_storage::TypeTag";
                                                          Ty.path "anyhow::Error"
                                                        ],
                                                      [
                                                        Ty.apply
                                                          (Ty.path "core::result::Result")
                                                          [
                                                            Ty.path "core::convert::Infallible";
                                                            Ty.path "anyhow::Error"
                                                          ]
                                                      ],
                                                      "from_residual",
                                                      []
                                                    |),
                                                    [ M.read (| residual |) ]
                                                  |)
                                                |)
                                              |)
                                            |)
                                          |)));
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let γ0_0 :=
                                            M.get_struct_tuple_field_or_break_match (|
                                              γ,
                                              "core::ops::control_flow::ControlFlow::Continue",
                                              0
                                            |) in
                                          let val := M.copy (| γ0_0 |) in
                                          val))
                                    ]
                                  |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 :=
                                          M.get_struct_tuple_field_or_break_match (|
                                            γ,
                                            "move_core_types::parser::Token::Name",
                                            0
                                          |) in
                                        let name := M.copy (| γ0_0 |) in
                                        let ty_args :=
                                          M.copy (|
                                            M.match_operator (|
                                              M.alloc (| Value.Tuple [] |),
                                              [
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (let γ :=
                                                      M.use
                                                        (M.alloc (|
                                                          M.call_closure (|
                                                            M.get_trait_method (|
                                                              "core::cmp::PartialEq",
                                                              Ty.apply
                                                                (Ty.path "core::option::Option")
                                                                [
                                                                  Ty.apply
                                                                    (Ty.path "&")
                                                                    [
                                                                      Ty.path
                                                                        "move_core_types::parser::Token"
                                                                    ]
                                                                ],
                                                              [
                                                                Ty.apply
                                                                  (Ty.path "core::option::Option")
                                                                  [
                                                                    Ty.apply
                                                                      (Ty.path "&")
                                                                      [
                                                                        Ty.path
                                                                          "move_core_types::parser::Token"
                                                                      ]
                                                                  ]
                                                              ],
                                                              "eq",
                                                              []
                                                            |),
                                                            [
                                                              M.alloc (|
                                                                M.call_closure (|
                                                                  M.get_associated_function (|
                                                                    Ty.apply
                                                                      (Ty.path
                                                                        "move_core_types::parser::Parser")
                                                                      [ I ],
                                                                    "peek",
                                                                    []
                                                                  |),
                                                                  [ M.read (| self |) ]
                                                                |)
                                                              |);
                                                              M.alloc (|
                                                                Value.StructTuple
                                                                  "core::option::Option::Some"
                                                                  [
                                                                    M.alloc (|
                                                                      Value.StructTuple
                                                                        "move_core_types::parser::Token::Lt"
                                                                        []
                                                                    |)
                                                                  ]
                                                              |)
                                                            ]
                                                          |)
                                                        |)) in
                                                    let _ :=
                                                      M.is_constant_or_break_match (|
                                                        M.read (| γ |),
                                                        Value.Bool true
                                                      |) in
                                                    let _ :=
                                                      M.match_operator (|
                                                        M.alloc (|
                                                          M.call_closure (|
                                                            M.get_trait_method (|
                                                              "core::ops::try_trait::Try",
                                                              Ty.apply
                                                                (Ty.path "core::result::Result")
                                                                [
                                                                  Ty.path
                                                                    "move_core_types::parser::Token";
                                                                  Ty.path "anyhow::Error"
                                                                ],
                                                              [],
                                                              "branch",
                                                              []
                                                            |),
                                                            [
                                                              M.call_closure (|
                                                                M.get_associated_function (|
                                                                  Ty.apply
                                                                    (Ty.path
                                                                      "move_core_types::parser::Parser")
                                                                    [ I ],
                                                                  "next",
                                                                  []
                                                                |),
                                                                [ M.read (| self |) ]
                                                              |)
                                                            ]
                                                          |)
                                                        |),
                                                        [
                                                          fun γ =>
                                                            ltac:(M.monadic
                                                              (let γ0_0 :=
                                                                M.get_struct_tuple_field_or_break_match (|
                                                                  γ,
                                                                  "core::ops::control_flow::ControlFlow::Break",
                                                                  0
                                                                |) in
                                                              let residual := M.copy (| γ0_0 |) in
                                                              M.alloc (|
                                                                M.never_to_any (|
                                                                  M.read (|
                                                                    M.return_ (|
                                                                      M.call_closure (|
                                                                        M.get_trait_method (|
                                                                          "core::ops::try_trait::FromResidual",
                                                                          Ty.apply
                                                                            (Ty.path
                                                                              "core::result::Result")
                                                                            [
                                                                              Ty.path
                                                                                "move_core_types::language_storage::TypeTag";
                                                                              Ty.path
                                                                                "anyhow::Error"
                                                                            ],
                                                                          [
                                                                            Ty.apply
                                                                              (Ty.path
                                                                                "core::result::Result")
                                                                              [
                                                                                Ty.path
                                                                                  "core::convert::Infallible";
                                                                                Ty.path
                                                                                  "anyhow::Error"
                                                                              ]
                                                                          ],
                                                                          "from_residual",
                                                                          []
                                                                        |),
                                                                        [ M.read (| residual |) ]
                                                                      |)
                                                                    |)
                                                                  |)
                                                                |)
                                                              |)));
                                                          fun γ =>
                                                            ltac:(M.monadic
                                                              (let γ0_0 :=
                                                                M.get_struct_tuple_field_or_break_match (|
                                                                  γ,
                                                                  "core::ops::control_flow::ControlFlow::Continue",
                                                                  0
                                                                |) in
                                                              let val := M.copy (| γ0_0 |) in
                                                              val))
                                                        ]
                                                      |) in
                                                    let ty_args :=
                                                      M.copy (|
                                                        M.match_operator (|
                                                          M.alloc (|
                                                            M.call_closure (|
                                                              M.get_trait_method (|
                                                                "core::ops::try_trait::Try",
                                                                Ty.apply
                                                                  (Ty.path "core::result::Result")
                                                                  [
                                                                    Ty.apply
                                                                      (Ty.path "alloc::vec::Vec")
                                                                      [
                                                                        Ty.path
                                                                          "move_core_types::language_storage::TypeTag";
                                                                        Ty.path
                                                                          "alloc::alloc::Global"
                                                                      ];
                                                                    Ty.path "anyhow::Error"
                                                                  ],
                                                                [],
                                                                "branch",
                                                                []
                                                              |),
                                                              [
                                                                M.call_closure (|
                                                                  M.get_associated_function (|
                                                                    Ty.apply
                                                                      (Ty.path
                                                                        "move_core_types::parser::Parser")
                                                                      [ I ],
                                                                    "parse_comma_list",
                                                                    [
                                                                      Ty.function
                                                                        [
                                                                          Ty.tuple
                                                                            [
                                                                              Ty.apply
                                                                                (Ty.path "&mut")
                                                                                [
                                                                                  Ty.apply
                                                                                    (Ty.path
                                                                                      "move_core_types::parser::Parser")
                                                                                    [ I ]
                                                                                ]
                                                                            ]
                                                                        ]
                                                                        (Ty.apply
                                                                          (Ty.path
                                                                            "core::result::Result")
                                                                          [
                                                                            Ty.path
                                                                              "move_core_types::language_storage::TypeTag";
                                                                            Ty.path "anyhow::Error"
                                                                          ]);
                                                                      Ty.path
                                                                        "move_core_types::language_storage::TypeTag"
                                                                    ]
                                                                  |),
                                                                  [
                                                                    M.read (| self |);
                                                                    M.closure
                                                                      (fun γ =>
                                                                        ltac:(M.monadic
                                                                          match γ with
                                                                          | [ α0 ] =>
                                                                            M.match_operator (|
                                                                              M.alloc (| α0 |),
                                                                              [
                                                                                fun γ =>
                                                                                  ltac:(M.monadic
                                                                                    (let parser :=
                                                                                      M.copy (|
                                                                                        γ
                                                                                      |) in
                                                                                    M.call_closure (|
                                                                                      M.get_associated_function (|
                                                                                        Ty.apply
                                                                                          (Ty.path
                                                                                            "move_core_types::parser::Parser")
                                                                                          [ I ],
                                                                                        "parse_type_tag",
                                                                                        []
                                                                                      |),
                                                                                      [
                                                                                        M.read (|
                                                                                          parser
                                                                                        |)
                                                                                      ]
                                                                                    |)))
                                                                              ]
                                                                            |)
                                                                          | _ => M.impossible (||)
                                                                          end));
                                                                    Value.StructTuple
                                                                      "move_core_types::parser::Token::Gt"
                                                                      [];
                                                                    Value.Bool true
                                                                  ]
                                                                |)
                                                              ]
                                                            |)
                                                          |),
                                                          [
                                                            fun γ =>
                                                              ltac:(M.monadic
                                                                (let γ0_0 :=
                                                                  M.get_struct_tuple_field_or_break_match (|
                                                                    γ,
                                                                    "core::ops::control_flow::ControlFlow::Break",
                                                                    0
                                                                  |) in
                                                                let residual := M.copy (| γ0_0 |) in
                                                                M.alloc (|
                                                                  M.never_to_any (|
                                                                    M.read (|
                                                                      M.return_ (|
                                                                        M.call_closure (|
                                                                          M.get_trait_method (|
                                                                            "core::ops::try_trait::FromResidual",
                                                                            Ty.apply
                                                                              (Ty.path
                                                                                "core::result::Result")
                                                                              [
                                                                                Ty.path
                                                                                  "move_core_types::language_storage::TypeTag";
                                                                                Ty.path
                                                                                  "anyhow::Error"
                                                                              ],
                                                                            [
                                                                              Ty.apply
                                                                                (Ty.path
                                                                                  "core::result::Result")
                                                                                [
                                                                                  Ty.path
                                                                                    "core::convert::Infallible";
                                                                                  Ty.path
                                                                                    "anyhow::Error"
                                                                                ]
                                                                            ],
                                                                            "from_residual",
                                                                            []
                                                                          |),
                                                                          [ M.read (| residual |) ]
                                                                        |)
                                                                      |)
                                                                    |)
                                                                  |)
                                                                |)));
                                                            fun γ =>
                                                              ltac:(M.monadic
                                                                (let γ0_0 :=
                                                                  M.get_struct_tuple_field_or_break_match (|
                                                                    γ,
                                                                    "core::ops::control_flow::ControlFlow::Continue",
                                                                    0
                                                                  |) in
                                                                let val := M.copy (| γ0_0 |) in
                                                                val))
                                                          ]
                                                        |)
                                                      |) in
                                                    let _ :=
                                                      M.match_operator (|
                                                        M.alloc (|
                                                          M.call_closure (|
                                                            M.get_trait_method (|
                                                              "core::ops::try_trait::Try",
                                                              Ty.apply
                                                                (Ty.path "core::result::Result")
                                                                [
                                                                  Ty.tuple [];
                                                                  Ty.path "anyhow::Error"
                                                                ],
                                                              [],
                                                              "branch",
                                                              []
                                                            |),
                                                            [
                                                              M.call_closure (|
                                                                M.get_associated_function (|
                                                                  Ty.apply
                                                                    (Ty.path
                                                                      "move_core_types::parser::Parser")
                                                                    [ I ],
                                                                  "consume",
                                                                  []
                                                                |),
                                                                [
                                                                  M.read (| self |);
                                                                  Value.StructTuple
                                                                    "move_core_types::parser::Token::Gt"
                                                                    []
                                                                ]
                                                              |)
                                                            ]
                                                          |)
                                                        |),
                                                        [
                                                          fun γ =>
                                                            ltac:(M.monadic
                                                              (let γ0_0 :=
                                                                M.get_struct_tuple_field_or_break_match (|
                                                                  γ,
                                                                  "core::ops::control_flow::ControlFlow::Break",
                                                                  0
                                                                |) in
                                                              let residual := M.copy (| γ0_0 |) in
                                                              M.alloc (|
                                                                M.never_to_any (|
                                                                  M.read (|
                                                                    M.return_ (|
                                                                      M.call_closure (|
                                                                        M.get_trait_method (|
                                                                          "core::ops::try_trait::FromResidual",
                                                                          Ty.apply
                                                                            (Ty.path
                                                                              "core::result::Result")
                                                                            [
                                                                              Ty.path
                                                                                "move_core_types::language_storage::TypeTag";
                                                                              Ty.path
                                                                                "anyhow::Error"
                                                                            ],
                                                                          [
                                                                            Ty.apply
                                                                              (Ty.path
                                                                                "core::result::Result")
                                                                              [
                                                                                Ty.path
                                                                                  "core::convert::Infallible";
                                                                                Ty.path
                                                                                  "anyhow::Error"
                                                                              ]
                                                                          ],
                                                                          "from_residual",
                                                                          []
                                                                        |),
                                                                        [ M.read (| residual |) ]
                                                                      |)
                                                                    |)
                                                                  |)
                                                                |)
                                                              |)));
                                                          fun γ =>
                                                            ltac:(M.monadic
                                                              (let γ0_0 :=
                                                                M.get_struct_tuple_field_or_break_match (|
                                                                  γ,
                                                                  "core::ops::control_flow::ControlFlow::Continue",
                                                                  0
                                                                |) in
                                                              let val := M.copy (| γ0_0 |) in
                                                              val))
                                                        ]
                                                      |) in
                                                    ty_args));
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (M.alloc (|
                                                      M.call_closure (|
                                                        M.get_associated_function (|
                                                          Ty.apply
                                                            (Ty.path "alloc::vec::Vec")
                                                            [
                                                              Ty.path
                                                                "move_core_types::language_storage::TypeTag";
                                                              Ty.path "alloc::alloc::Global"
                                                            ],
                                                          "new",
                                                          []
                                                        |),
                                                        []
                                                      |)
                                                    |)))
                                              ]
                                            |)
                                          |) in
                                        M.alloc (|
                                          Value.StructTuple
                                            "move_core_types::language_storage::TypeTag::Struct"
                                            [
                                              M.call_closure (|
                                                M.get_associated_function (|
                                                  Ty.apply
                                                    (Ty.path "alloc::boxed::Box")
                                                    [
                                                      Ty.path
                                                        "move_core_types::language_storage::StructTag";
                                                      Ty.path "alloc::alloc::Global"
                                                    ],
                                                  "new",
                                                  []
                                                |),
                                                [
                                                  Value.StructRecord
                                                    "move_core_types::language_storage::StructTag"
                                                    [
                                                      ("address",
                                                        M.read (|
                                                          M.match_operator (|
                                                            M.alloc (|
                                                              M.call_closure (|
                                                                M.get_trait_method (|
                                                                  "core::ops::try_trait::Try",
                                                                  Ty.apply
                                                                    (Ty.path "core::result::Result")
                                                                    [
                                                                      Ty.path
                                                                        "move_core_types::account_address::AccountAddress";
                                                                      Ty.path
                                                                        "move_core_types::account_address::AccountAddressParseError"
                                                                    ],
                                                                  [],
                                                                  "branch",
                                                                  []
                                                                |),
                                                                [
                                                                  M.call_closure (|
                                                                    M.get_associated_function (|
                                                                      Ty.path
                                                                        "move_core_types::account_address::AccountAddress",
                                                                      "from_hex_literal",
                                                                      []
                                                                    |),
                                                                    [
                                                                      M.call_closure (|
                                                                        M.get_trait_method (|
                                                                          "core::ops::deref::Deref",
                                                                          Ty.path
                                                                            "alloc::string::String",
                                                                          [],
                                                                          "deref",
                                                                          []
                                                                        |),
                                                                        [ addr ]
                                                                      |)
                                                                    ]
                                                                  |)
                                                                ]
                                                              |)
                                                            |),
                                                            [
                                                              fun γ =>
                                                                ltac:(M.monadic
                                                                  (let γ0_0 :=
                                                                    M.get_struct_tuple_field_or_break_match (|
                                                                      γ,
                                                                      "core::ops::control_flow::ControlFlow::Break",
                                                                      0
                                                                    |) in
                                                                  let residual :=
                                                                    M.copy (| γ0_0 |) in
                                                                  M.alloc (|
                                                                    M.never_to_any (|
                                                                      M.read (|
                                                                        M.return_ (|
                                                                          M.call_closure (|
                                                                            M.get_trait_method (|
                                                                              "core::ops::try_trait::FromResidual",
                                                                              Ty.apply
                                                                                (Ty.path
                                                                                  "core::result::Result")
                                                                                [
                                                                                  Ty.path
                                                                                    "move_core_types::language_storage::TypeTag";
                                                                                  Ty.path
                                                                                    "anyhow::Error"
                                                                                ],
                                                                              [
                                                                                Ty.apply
                                                                                  (Ty.path
                                                                                    "core::result::Result")
                                                                                  [
                                                                                    Ty.path
                                                                                      "core::convert::Infallible";
                                                                                    Ty.path
                                                                                      "move_core_types::account_address::AccountAddressParseError"
                                                                                  ]
                                                                              ],
                                                                              "from_residual",
                                                                              []
                                                                            |),
                                                                            [ M.read (| residual |)
                                                                            ]
                                                                          |)
                                                                        |)
                                                                      |)
                                                                    |)
                                                                  |)));
                                                              fun γ =>
                                                                ltac:(M.monadic
                                                                  (let γ0_0 :=
                                                                    M.get_struct_tuple_field_or_break_match (|
                                                                      γ,
                                                                      "core::ops::control_flow::ControlFlow::Continue",
                                                                      0
                                                                    |) in
                                                                  let val := M.copy (| γ0_0 |) in
                                                                  val))
                                                            ]
                                                          |)
                                                        |));
                                                      ("module",
                                                        M.read (|
                                                          M.match_operator (|
                                                            M.alloc (|
                                                              M.call_closure (|
                                                                M.get_trait_method (|
                                                                  "core::ops::try_trait::Try",
                                                                  Ty.apply
                                                                    (Ty.path "core::result::Result")
                                                                    [
                                                                      Ty.path
                                                                        "move_core_types::identifier::Identifier";
                                                                      Ty.path "anyhow::Error"
                                                                    ],
                                                                  [],
                                                                  "branch",
                                                                  []
                                                                |),
                                                                [
                                                                  M.call_closure (|
                                                                    M.get_associated_function (|
                                                                      Ty.path
                                                                        "move_core_types::identifier::Identifier",
                                                                      "new",
                                                                      [
                                                                        Ty.path
                                                                          "alloc::string::String"
                                                                      ]
                                                                    |),
                                                                    [ M.read (| module |) ]
                                                                  |)
                                                                ]
                                                              |)
                                                            |),
                                                            [
                                                              fun γ =>
                                                                ltac:(M.monadic
                                                                  (let γ0_0 :=
                                                                    M.get_struct_tuple_field_or_break_match (|
                                                                      γ,
                                                                      "core::ops::control_flow::ControlFlow::Break",
                                                                      0
                                                                    |) in
                                                                  let residual :=
                                                                    M.copy (| γ0_0 |) in
                                                                  M.alloc (|
                                                                    M.never_to_any (|
                                                                      M.read (|
                                                                        M.return_ (|
                                                                          M.call_closure (|
                                                                            M.get_trait_method (|
                                                                              "core::ops::try_trait::FromResidual",
                                                                              Ty.apply
                                                                                (Ty.path
                                                                                  "core::result::Result")
                                                                                [
                                                                                  Ty.path
                                                                                    "move_core_types::language_storage::TypeTag";
                                                                                  Ty.path
                                                                                    "anyhow::Error"
                                                                                ],
                                                                              [
                                                                                Ty.apply
                                                                                  (Ty.path
                                                                                    "core::result::Result")
                                                                                  [
                                                                                    Ty.path
                                                                                      "core::convert::Infallible";
                                                                                    Ty.path
                                                                                      "anyhow::Error"
                                                                                  ]
                                                                              ],
                                                                              "from_residual",
                                                                              []
                                                                            |),
                                                                            [ M.read (| residual |)
                                                                            ]
                                                                          |)
                                                                        |)
                                                                      |)
                                                                    |)
                                                                  |)));
                                                              fun γ =>
                                                                ltac:(M.monadic
                                                                  (let γ0_0 :=
                                                                    M.get_struct_tuple_field_or_break_match (|
                                                                      γ,
                                                                      "core::ops::control_flow::ControlFlow::Continue",
                                                                      0
                                                                    |) in
                                                                  let val := M.copy (| γ0_0 |) in
                                                                  val))
                                                            ]
                                                          |)
                                                        |));
                                                      ("name",
                                                        M.read (|
                                                          M.match_operator (|
                                                            M.alloc (|
                                                              M.call_closure (|
                                                                M.get_trait_method (|
                                                                  "core::ops::try_trait::Try",
                                                                  Ty.apply
                                                                    (Ty.path "core::result::Result")
                                                                    [
                                                                      Ty.path
                                                                        "move_core_types::identifier::Identifier";
                                                                      Ty.path "anyhow::Error"
                                                                    ],
                                                                  [],
                                                                  "branch",
                                                                  []
                                                                |),
                                                                [
                                                                  M.call_closure (|
                                                                    M.get_associated_function (|
                                                                      Ty.path
                                                                        "move_core_types::identifier::Identifier",
                                                                      "new",
                                                                      [
                                                                        Ty.path
                                                                          "alloc::string::String"
                                                                      ]
                                                                    |),
                                                                    [ M.read (| name |) ]
                                                                  |)
                                                                ]
                                                              |)
                                                            |),
                                                            [
                                                              fun γ =>
                                                                ltac:(M.monadic
                                                                  (let γ0_0 :=
                                                                    M.get_struct_tuple_field_or_break_match (|
                                                                      γ,
                                                                      "core::ops::control_flow::ControlFlow::Break",
                                                                      0
                                                                    |) in
                                                                  let residual :=
                                                                    M.copy (| γ0_0 |) in
                                                                  M.alloc (|
                                                                    M.never_to_any (|
                                                                      M.read (|
                                                                        M.return_ (|
                                                                          M.call_closure (|
                                                                            M.get_trait_method (|
                                                                              "core::ops::try_trait::FromResidual",
                                                                              Ty.apply
                                                                                (Ty.path
                                                                                  "core::result::Result")
                                                                                [
                                                                                  Ty.path
                                                                                    "move_core_types::language_storage::TypeTag";
                                                                                  Ty.path
                                                                                    "anyhow::Error"
                                                                                ],
                                                                              [
                                                                                Ty.apply
                                                                                  (Ty.path
                                                                                    "core::result::Result")
                                                                                  [
                                                                                    Ty.path
                                                                                      "core::convert::Infallible";
                                                                                    Ty.path
                                                                                      "anyhow::Error"
                                                                                  ]
                                                                              ],
                                                                              "from_residual",
                                                                              []
                                                                            |),
                                                                            [ M.read (| residual |)
                                                                            ]
                                                                          |)
                                                                        |)
                                                                      |)
                                                                    |)
                                                                  |)));
                                                              fun γ =>
                                                                ltac:(M.monadic
                                                                  (let γ0_0 :=
                                                                    M.get_struct_tuple_field_or_break_match (|
                                                                      γ,
                                                                      "core::ops::control_flow::ControlFlow::Continue",
                                                                      0
                                                                    |) in
                                                                  let val := M.copy (| γ0_0 |) in
                                                                  val))
                                                            ]
                                                          |)
                                                        |));
                                                      ("type_params", M.read (| ty_args |))
                                                    ]
                                                ]
                                              |)
                                            ]
                                        |)));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let t := M.copy (| γ |) in
                                        M.alloc (|
                                          M.never_to_any (|
                                            M.read (|
                                              M.return_ (|
                                                Value.StructTuple
                                                  "core::result::Result::Err"
                                                  [
                                                    M.call_closure (|
                                                      M.get_associated_function (|
                                                        Ty.path "anyhow::Error",
                                                        "msg",
                                                        [ Ty.path "alloc::string::String" ]
                                                      |),
                                                      [
                                                        M.read (|
                                                          let res :=
                                                            M.alloc (|
                                                              M.call_closure (|
                                                                M.get_function (|
                                                                  "alloc::fmt::format",
                                                                  []
                                                                |),
                                                                [
                                                                  M.call_closure (|
                                                                    M.get_associated_function (|
                                                                      Ty.path
                                                                        "core::fmt::Arguments",
                                                                      "new_v1",
                                                                      []
                                                                    |),
                                                                    [
                                                                      (* Unsize *)
                                                                      M.pointer_coercion
                                                                        (M.alloc (|
                                                                          Value.Array
                                                                            [
                                                                              M.read (|
                                                                                mk_str
                                                                                  "expected name, got "
                                                                              |)
                                                                            ]
                                                                        |));
                                                                      (* Unsize *)
                                                                      M.pointer_coercion
                                                                        (M.alloc (|
                                                                          Value.Array
                                                                            [
                                                                              M.call_closure (|
                                                                                M.get_associated_function (|
                                                                                  Ty.path
                                                                                    "core::fmt::rt::Argument",
                                                                                  "new_debug",
                                                                                  [
                                                                                    Ty.path
                                                                                      "move_core_types::parser::Token"
                                                                                  ]
                                                                                |),
                                                                                [ t ]
                                                                              |)
                                                                            ]
                                                                        |))
                                                                    ]
                                                                  |)
                                                                ]
                                                              |)
                                                            |) in
                                                          res
                                                        |)
                                                      ]
                                                    |)
                                                  ]
                                              |)
                                            |)
                                          |)
                                        |)))
                                  ]
                                |)));
                            fun γ =>
                              ltac:(M.monadic
                                (let t := M.copy (| γ |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      M.return_ (|
                                        Value.StructTuple
                                          "core::result::Result::Err"
                                          [
                                            M.call_closure (|
                                              M.get_associated_function (|
                                                Ty.path "anyhow::Error",
                                                "msg",
                                                [ Ty.path "alloc::string::String" ]
                                              |),
                                              [
                                                M.read (|
                                                  let res :=
                                                    M.alloc (|
                                                      M.call_closure (|
                                                        M.get_function (|
                                                          "alloc::fmt::format",
                                                          []
                                                        |),
                                                        [
                                                          M.call_closure (|
                                                            M.get_associated_function (|
                                                              Ty.path "core::fmt::Arguments",
                                                              "new_v1",
                                                              []
                                                            |),
                                                            [
                                                              (* Unsize *)
                                                              M.pointer_coercion
                                                                (M.alloc (|
                                                                  Value.Array
                                                                    [
                                                                      M.read (|
                                                                        mk_str "expected name, got "
                                                                      |)
                                                                    ]
                                                                |));
                                                              (* Unsize *)
                                                              M.pointer_coercion
                                                                (M.alloc (|
                                                                  Value.Array
                                                                    [
                                                                      M.call_closure (|
                                                                        M.get_associated_function (|
                                                                          Ty.path
                                                                            "core::fmt::rt::Argument",
                                                                          "new_debug",
                                                                          [
                                                                            Ty.path
                                                                              "move_core_types::parser::Token"
                                                                          ]
                                                                        |),
                                                                        [ t ]
                                                                      |)
                                                                    ]
                                                                |))
                                                            ]
                                                          |)
                                                        ]
                                                      |)
                                                    |) in
                                                  res
                                                |)
                                              ]
                                            |)
                                          ]
                                      |)
                                    |)
                                  |)
                                |)))
                          ]
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let tok := M.copy (| γ |) in
                        M.alloc (|
                          M.never_to_any (|
                            M.read (|
                              M.return_ (|
                                Value.StructTuple
                                  "core::result::Result::Err"
                                  [
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.path "anyhow::Error",
                                        "msg",
                                        [ Ty.path "alloc::string::String" ]
                                      |),
                                      [
                                        M.read (|
                                          let res :=
                                            M.alloc (|
                                              M.call_closure (|
                                                M.get_function (| "alloc::fmt::format", [] |),
                                                [
                                                  M.call_closure (|
                                                    M.get_associated_function (|
                                                      Ty.path "core::fmt::Arguments",
                                                      "new_v1",
                                                      []
                                                    |),
                                                    [
                                                      (* Unsize *)
                                                      M.pointer_coercion
                                                        (M.alloc (|
                                                          Value.Array
                                                            [
                                                              M.read (|
                                                                mk_str "unexpected token "
                                                              |);
                                                              M.read (|
                                                                mk_str ", expected type tag"
                                                              |)
                                                            ]
                                                        |));
                                                      (* Unsize *)
                                                      M.pointer_coercion
                                                        (M.alloc (|
                                                          Value.Array
                                                            [
                                                              M.call_closure (|
                                                                M.get_associated_function (|
                                                                  Ty.path "core::fmt::rt::Argument",
                                                                  "new_debug",
                                                                  [
                                                                    Ty.path
                                                                      "move_core_types::parser::Token"
                                                                  ]
                                                                |),
                                                                [ tok ]
                                                              |)
                                                            ]
                                                        |))
                                                    ]
                                                  |)
                                                ]
                                              |)
                                            |) in
                                          res
                                        |)
                                      ]
                                    |)
                                  ]
                              |)
                            |)
                          |)
                        |)))
                  ]
                |)
              |)
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_parse_type_tag :
      forall (I : Ty.t),
      M.IsAssociatedFunction (Self I) "parse_type_tag" (parse_type_tag I).
    
    (*
        fn parse_transaction_argument(&mut self) -> Result<TransactionArgument> {
            Ok(match self.next()? {
                Token::U8(s) => TransactionArgument::U8(s.replace('_', "").parse()?),
                Token::U16(s) => TransactionArgument::U16(s.replace('_', "").parse()?),
                Token::U32(s) => TransactionArgument::U32(s.replace('_', "").parse()?),
                Token::U64(s) => TransactionArgument::U64(s.replace('_', "").parse()?),
                Token::U128(s) => TransactionArgument::U128(s.replace('_', "").parse()?),
                Token::U256(s) => TransactionArgument::U256(s.replace('_', "").parse()?),
                Token::True => TransactionArgument::Bool(true),
                Token::False => TransactionArgument::Bool(false),
                Token::Address(addr) => {
                    TransactionArgument::Address(AccountAddress::from_hex_literal(&addr)?)
                }
                Token::Bytes(s) => TransactionArgument::U8Vector(hex::decode(s)?),
                tok => bail!("unexpected token {:?}, expected transaction argument", tok),
            })
        }
    *)
    Definition parse_transaction_argument (I : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self I in
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.StructTuple
            "core::result::Result::Ok"
            [
              M.read (|
                M.match_operator (|
                  M.match_operator (|
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::ops::try_trait::Try",
                          Ty.apply
                            (Ty.path "core::result::Result")
                            [ Ty.path "move_core_types::parser::Token"; Ty.path "anyhow::Error" ],
                          [],
                          "branch",
                          []
                        |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.apply (Ty.path "move_core_types::parser::Parser") [ I ],
                              "next",
                              []
                            |),
                            [ M.read (| self |) ]
                          |)
                        ]
                      |)
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.get_struct_tuple_field_or_break_match (|
                              γ,
                              "core::ops::control_flow::ControlFlow::Break",
                              0
                            |) in
                          let residual := M.copy (| γ0_0 |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::ops::try_trait::FromResidual",
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        [
                                          Ty.path
                                            "move_core_types::transaction_argument::TransactionArgument";
                                          Ty.path "anyhow::Error"
                                        ],
                                      [
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          [
                                            Ty.path "core::convert::Infallible";
                                            Ty.path "anyhow::Error"
                                          ]
                                      ],
                                      "from_residual",
                                      []
                                    |),
                                    [ M.read (| residual |) ]
                                  |)
                                |)
                              |)
                            |)
                          |)));
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.get_struct_tuple_field_or_break_match (|
                              γ,
                              "core::ops::control_flow::ControlFlow::Continue",
                              0
                            |) in
                          let val := M.copy (| γ0_0 |) in
                          val))
                    ]
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.get_struct_tuple_field_or_break_match (|
                            γ,
                            "move_core_types::parser::Token::U8",
                            0
                          |) in
                        let s := M.copy (| γ0_0 |) in
                        M.alloc (|
                          Value.StructTuple
                            "move_core_types::transaction_argument::TransactionArgument::U8"
                            [
                              M.read (|
                                M.match_operator (|
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::ops::try_trait::Try",
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          [ Ty.path "u8"; Ty.path "core::num::error::ParseIntError"
                                          ],
                                        [],
                                        "branch",
                                        []
                                      |),
                                      [
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.path "str",
                                            "parse",
                                            [ Ty.path "u8" ]
                                          |),
                                          [
                                            M.call_closure (|
                                              M.get_trait_method (|
                                                "core::ops::deref::Deref",
                                                Ty.path "alloc::string::String",
                                                [],
                                                "deref",
                                                []
                                              |),
                                              [
                                                M.alloc (|
                                                  M.call_closure (|
                                                    M.get_associated_function (|
                                                      Ty.path "str",
                                                      "replace",
                                                      [ Ty.path "char" ]
                                                    |),
                                                    [
                                                      M.call_closure (|
                                                        M.get_trait_method (|
                                                          "core::ops::deref::Deref",
                                                          Ty.path "alloc::string::String",
                                                          [],
                                                          "deref",
                                                          []
                                                        |),
                                                        [ s ]
                                                      |);
                                                      Value.UnicodeChar 95;
                                                      M.read (| mk_str "" |)
                                                    ]
                                                  |)
                                                |)
                                              ]
                                            |)
                                          ]
                                        |)
                                      ]
                                    |)
                                  |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 :=
                                          M.get_struct_tuple_field_or_break_match (|
                                            γ,
                                            "core::ops::control_flow::ControlFlow::Break",
                                            0
                                          |) in
                                        let residual := M.copy (| γ0_0 |) in
                                        M.alloc (|
                                          M.never_to_any (|
                                            M.read (|
                                              M.return_ (|
                                                M.call_closure (|
                                                  M.get_trait_method (|
                                                    "core::ops::try_trait::FromResidual",
                                                    Ty.apply
                                                      (Ty.path "core::result::Result")
                                                      [
                                                        Ty.path
                                                          "move_core_types::transaction_argument::TransactionArgument";
                                                        Ty.path "anyhow::Error"
                                                      ],
                                                    [
                                                      Ty.apply
                                                        (Ty.path "core::result::Result")
                                                        [
                                                          Ty.path "core::convert::Infallible";
                                                          Ty.path "core::num::error::ParseIntError"
                                                        ]
                                                    ],
                                                    "from_residual",
                                                    []
                                                  |),
                                                  [ M.read (| residual |) ]
                                                |)
                                              |)
                                            |)
                                          |)
                                        |)));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 :=
                                          M.get_struct_tuple_field_or_break_match (|
                                            γ,
                                            "core::ops::control_flow::ControlFlow::Continue",
                                            0
                                          |) in
                                        let val := M.copy (| γ0_0 |) in
                                        val))
                                  ]
                                |)
                              |)
                            ]
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.get_struct_tuple_field_or_break_match (|
                            γ,
                            "move_core_types::parser::Token::U16",
                            0
                          |) in
                        let s := M.copy (| γ0_0 |) in
                        M.alloc (|
                          Value.StructTuple
                            "move_core_types::transaction_argument::TransactionArgument::U16"
                            [
                              M.read (|
                                M.match_operator (|
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::ops::try_trait::Try",
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          [ Ty.path "u16"; Ty.path "core::num::error::ParseIntError"
                                          ],
                                        [],
                                        "branch",
                                        []
                                      |),
                                      [
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.path "str",
                                            "parse",
                                            [ Ty.path "u16" ]
                                          |),
                                          [
                                            M.call_closure (|
                                              M.get_trait_method (|
                                                "core::ops::deref::Deref",
                                                Ty.path "alloc::string::String",
                                                [],
                                                "deref",
                                                []
                                              |),
                                              [
                                                M.alloc (|
                                                  M.call_closure (|
                                                    M.get_associated_function (|
                                                      Ty.path "str",
                                                      "replace",
                                                      [ Ty.path "char" ]
                                                    |),
                                                    [
                                                      M.call_closure (|
                                                        M.get_trait_method (|
                                                          "core::ops::deref::Deref",
                                                          Ty.path "alloc::string::String",
                                                          [],
                                                          "deref",
                                                          []
                                                        |),
                                                        [ s ]
                                                      |);
                                                      Value.UnicodeChar 95;
                                                      M.read (| mk_str "" |)
                                                    ]
                                                  |)
                                                |)
                                              ]
                                            |)
                                          ]
                                        |)
                                      ]
                                    |)
                                  |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 :=
                                          M.get_struct_tuple_field_or_break_match (|
                                            γ,
                                            "core::ops::control_flow::ControlFlow::Break",
                                            0
                                          |) in
                                        let residual := M.copy (| γ0_0 |) in
                                        M.alloc (|
                                          M.never_to_any (|
                                            M.read (|
                                              M.return_ (|
                                                M.call_closure (|
                                                  M.get_trait_method (|
                                                    "core::ops::try_trait::FromResidual",
                                                    Ty.apply
                                                      (Ty.path "core::result::Result")
                                                      [
                                                        Ty.path
                                                          "move_core_types::transaction_argument::TransactionArgument";
                                                        Ty.path "anyhow::Error"
                                                      ],
                                                    [
                                                      Ty.apply
                                                        (Ty.path "core::result::Result")
                                                        [
                                                          Ty.path "core::convert::Infallible";
                                                          Ty.path "core::num::error::ParseIntError"
                                                        ]
                                                    ],
                                                    "from_residual",
                                                    []
                                                  |),
                                                  [ M.read (| residual |) ]
                                                |)
                                              |)
                                            |)
                                          |)
                                        |)));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 :=
                                          M.get_struct_tuple_field_or_break_match (|
                                            γ,
                                            "core::ops::control_flow::ControlFlow::Continue",
                                            0
                                          |) in
                                        let val := M.copy (| γ0_0 |) in
                                        val))
                                  ]
                                |)
                              |)
                            ]
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.get_struct_tuple_field_or_break_match (|
                            γ,
                            "move_core_types::parser::Token::U32",
                            0
                          |) in
                        let s := M.copy (| γ0_0 |) in
                        M.alloc (|
                          Value.StructTuple
                            "move_core_types::transaction_argument::TransactionArgument::U32"
                            [
                              M.read (|
                                M.match_operator (|
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::ops::try_trait::Try",
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          [ Ty.path "u32"; Ty.path "core::num::error::ParseIntError"
                                          ],
                                        [],
                                        "branch",
                                        []
                                      |),
                                      [
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.path "str",
                                            "parse",
                                            [ Ty.path "u32" ]
                                          |),
                                          [
                                            M.call_closure (|
                                              M.get_trait_method (|
                                                "core::ops::deref::Deref",
                                                Ty.path "alloc::string::String",
                                                [],
                                                "deref",
                                                []
                                              |),
                                              [
                                                M.alloc (|
                                                  M.call_closure (|
                                                    M.get_associated_function (|
                                                      Ty.path "str",
                                                      "replace",
                                                      [ Ty.path "char" ]
                                                    |),
                                                    [
                                                      M.call_closure (|
                                                        M.get_trait_method (|
                                                          "core::ops::deref::Deref",
                                                          Ty.path "alloc::string::String",
                                                          [],
                                                          "deref",
                                                          []
                                                        |),
                                                        [ s ]
                                                      |);
                                                      Value.UnicodeChar 95;
                                                      M.read (| mk_str "" |)
                                                    ]
                                                  |)
                                                |)
                                              ]
                                            |)
                                          ]
                                        |)
                                      ]
                                    |)
                                  |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 :=
                                          M.get_struct_tuple_field_or_break_match (|
                                            γ,
                                            "core::ops::control_flow::ControlFlow::Break",
                                            0
                                          |) in
                                        let residual := M.copy (| γ0_0 |) in
                                        M.alloc (|
                                          M.never_to_any (|
                                            M.read (|
                                              M.return_ (|
                                                M.call_closure (|
                                                  M.get_trait_method (|
                                                    "core::ops::try_trait::FromResidual",
                                                    Ty.apply
                                                      (Ty.path "core::result::Result")
                                                      [
                                                        Ty.path
                                                          "move_core_types::transaction_argument::TransactionArgument";
                                                        Ty.path "anyhow::Error"
                                                      ],
                                                    [
                                                      Ty.apply
                                                        (Ty.path "core::result::Result")
                                                        [
                                                          Ty.path "core::convert::Infallible";
                                                          Ty.path "core::num::error::ParseIntError"
                                                        ]
                                                    ],
                                                    "from_residual",
                                                    []
                                                  |),
                                                  [ M.read (| residual |) ]
                                                |)
                                              |)
                                            |)
                                          |)
                                        |)));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 :=
                                          M.get_struct_tuple_field_or_break_match (|
                                            γ,
                                            "core::ops::control_flow::ControlFlow::Continue",
                                            0
                                          |) in
                                        let val := M.copy (| γ0_0 |) in
                                        val))
                                  ]
                                |)
                              |)
                            ]
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.get_struct_tuple_field_or_break_match (|
                            γ,
                            "move_core_types::parser::Token::U64",
                            0
                          |) in
                        let s := M.copy (| γ0_0 |) in
                        M.alloc (|
                          Value.StructTuple
                            "move_core_types::transaction_argument::TransactionArgument::U64"
                            [
                              M.read (|
                                M.match_operator (|
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::ops::try_trait::Try",
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          [ Ty.path "u64"; Ty.path "core::num::error::ParseIntError"
                                          ],
                                        [],
                                        "branch",
                                        []
                                      |),
                                      [
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.path "str",
                                            "parse",
                                            [ Ty.path "u64" ]
                                          |),
                                          [
                                            M.call_closure (|
                                              M.get_trait_method (|
                                                "core::ops::deref::Deref",
                                                Ty.path "alloc::string::String",
                                                [],
                                                "deref",
                                                []
                                              |),
                                              [
                                                M.alloc (|
                                                  M.call_closure (|
                                                    M.get_associated_function (|
                                                      Ty.path "str",
                                                      "replace",
                                                      [ Ty.path "char" ]
                                                    |),
                                                    [
                                                      M.call_closure (|
                                                        M.get_trait_method (|
                                                          "core::ops::deref::Deref",
                                                          Ty.path "alloc::string::String",
                                                          [],
                                                          "deref",
                                                          []
                                                        |),
                                                        [ s ]
                                                      |);
                                                      Value.UnicodeChar 95;
                                                      M.read (| mk_str "" |)
                                                    ]
                                                  |)
                                                |)
                                              ]
                                            |)
                                          ]
                                        |)
                                      ]
                                    |)
                                  |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 :=
                                          M.get_struct_tuple_field_or_break_match (|
                                            γ,
                                            "core::ops::control_flow::ControlFlow::Break",
                                            0
                                          |) in
                                        let residual := M.copy (| γ0_0 |) in
                                        M.alloc (|
                                          M.never_to_any (|
                                            M.read (|
                                              M.return_ (|
                                                M.call_closure (|
                                                  M.get_trait_method (|
                                                    "core::ops::try_trait::FromResidual",
                                                    Ty.apply
                                                      (Ty.path "core::result::Result")
                                                      [
                                                        Ty.path
                                                          "move_core_types::transaction_argument::TransactionArgument";
                                                        Ty.path "anyhow::Error"
                                                      ],
                                                    [
                                                      Ty.apply
                                                        (Ty.path "core::result::Result")
                                                        [
                                                          Ty.path "core::convert::Infallible";
                                                          Ty.path "core::num::error::ParseIntError"
                                                        ]
                                                    ],
                                                    "from_residual",
                                                    []
                                                  |),
                                                  [ M.read (| residual |) ]
                                                |)
                                              |)
                                            |)
                                          |)
                                        |)));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 :=
                                          M.get_struct_tuple_field_or_break_match (|
                                            γ,
                                            "core::ops::control_flow::ControlFlow::Continue",
                                            0
                                          |) in
                                        let val := M.copy (| γ0_0 |) in
                                        val))
                                  ]
                                |)
                              |)
                            ]
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.get_struct_tuple_field_or_break_match (|
                            γ,
                            "move_core_types::parser::Token::U128",
                            0
                          |) in
                        let s := M.copy (| γ0_0 |) in
                        M.alloc (|
                          Value.StructTuple
                            "move_core_types::transaction_argument::TransactionArgument::U128"
                            [
                              M.read (|
                                M.match_operator (|
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::ops::try_trait::Try",
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          [
                                            Ty.path "u128";
                                            Ty.path "core::num::error::ParseIntError"
                                          ],
                                        [],
                                        "branch",
                                        []
                                      |),
                                      [
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.path "str",
                                            "parse",
                                            [ Ty.path "u128" ]
                                          |),
                                          [
                                            M.call_closure (|
                                              M.get_trait_method (|
                                                "core::ops::deref::Deref",
                                                Ty.path "alloc::string::String",
                                                [],
                                                "deref",
                                                []
                                              |),
                                              [
                                                M.alloc (|
                                                  M.call_closure (|
                                                    M.get_associated_function (|
                                                      Ty.path "str",
                                                      "replace",
                                                      [ Ty.path "char" ]
                                                    |),
                                                    [
                                                      M.call_closure (|
                                                        M.get_trait_method (|
                                                          "core::ops::deref::Deref",
                                                          Ty.path "alloc::string::String",
                                                          [],
                                                          "deref",
                                                          []
                                                        |),
                                                        [ s ]
                                                      |);
                                                      Value.UnicodeChar 95;
                                                      M.read (| mk_str "" |)
                                                    ]
                                                  |)
                                                |)
                                              ]
                                            |)
                                          ]
                                        |)
                                      ]
                                    |)
                                  |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 :=
                                          M.get_struct_tuple_field_or_break_match (|
                                            γ,
                                            "core::ops::control_flow::ControlFlow::Break",
                                            0
                                          |) in
                                        let residual := M.copy (| γ0_0 |) in
                                        M.alloc (|
                                          M.never_to_any (|
                                            M.read (|
                                              M.return_ (|
                                                M.call_closure (|
                                                  M.get_trait_method (|
                                                    "core::ops::try_trait::FromResidual",
                                                    Ty.apply
                                                      (Ty.path "core::result::Result")
                                                      [
                                                        Ty.path
                                                          "move_core_types::transaction_argument::TransactionArgument";
                                                        Ty.path "anyhow::Error"
                                                      ],
                                                    [
                                                      Ty.apply
                                                        (Ty.path "core::result::Result")
                                                        [
                                                          Ty.path "core::convert::Infallible";
                                                          Ty.path "core::num::error::ParseIntError"
                                                        ]
                                                    ],
                                                    "from_residual",
                                                    []
                                                  |),
                                                  [ M.read (| residual |) ]
                                                |)
                                              |)
                                            |)
                                          |)
                                        |)));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 :=
                                          M.get_struct_tuple_field_or_break_match (|
                                            γ,
                                            "core::ops::control_flow::ControlFlow::Continue",
                                            0
                                          |) in
                                        let val := M.copy (| γ0_0 |) in
                                        val))
                                  ]
                                |)
                              |)
                            ]
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.get_struct_tuple_field_or_break_match (|
                            γ,
                            "move_core_types::parser::Token::U256",
                            0
                          |) in
                        let s := M.copy (| γ0_0 |) in
                        M.alloc (|
                          Value.StructTuple
                            "move_core_types::transaction_argument::TransactionArgument::U256"
                            [
                              M.read (|
                                M.match_operator (|
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::ops::try_trait::Try",
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          [
                                            Ty.path "move_core_types::u256::U256";
                                            Ty.path "move_core_types::u256::U256FromStrError"
                                          ],
                                        [],
                                        "branch",
                                        []
                                      |),
                                      [
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.path "str",
                                            "parse",
                                            [ Ty.path "move_core_types::u256::U256" ]
                                          |),
                                          [
                                            M.call_closure (|
                                              M.get_trait_method (|
                                                "core::ops::deref::Deref",
                                                Ty.path "alloc::string::String",
                                                [],
                                                "deref",
                                                []
                                              |),
                                              [
                                                M.alloc (|
                                                  M.call_closure (|
                                                    M.get_associated_function (|
                                                      Ty.path "str",
                                                      "replace",
                                                      [ Ty.path "char" ]
                                                    |),
                                                    [
                                                      M.call_closure (|
                                                        M.get_trait_method (|
                                                          "core::ops::deref::Deref",
                                                          Ty.path "alloc::string::String",
                                                          [],
                                                          "deref",
                                                          []
                                                        |),
                                                        [ s ]
                                                      |);
                                                      Value.UnicodeChar 95;
                                                      M.read (| mk_str "" |)
                                                    ]
                                                  |)
                                                |)
                                              ]
                                            |)
                                          ]
                                        |)
                                      ]
                                    |)
                                  |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 :=
                                          M.get_struct_tuple_field_or_break_match (|
                                            γ,
                                            "core::ops::control_flow::ControlFlow::Break",
                                            0
                                          |) in
                                        let residual := M.copy (| γ0_0 |) in
                                        M.alloc (|
                                          M.never_to_any (|
                                            M.read (|
                                              M.return_ (|
                                                M.call_closure (|
                                                  M.get_trait_method (|
                                                    "core::ops::try_trait::FromResidual",
                                                    Ty.apply
                                                      (Ty.path "core::result::Result")
                                                      [
                                                        Ty.path
                                                          "move_core_types::transaction_argument::TransactionArgument";
                                                        Ty.path "anyhow::Error"
                                                      ],
                                                    [
                                                      Ty.apply
                                                        (Ty.path "core::result::Result")
                                                        [
                                                          Ty.path "core::convert::Infallible";
                                                          Ty.path
                                                            "move_core_types::u256::U256FromStrError"
                                                        ]
                                                    ],
                                                    "from_residual",
                                                    []
                                                  |),
                                                  [ M.read (| residual |) ]
                                                |)
                                              |)
                                            |)
                                          |)
                                        |)));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 :=
                                          M.get_struct_tuple_field_or_break_match (|
                                            γ,
                                            "core::ops::control_flow::ControlFlow::Continue",
                                            0
                                          |) in
                                        let val := M.copy (| γ0_0 |) in
                                        val))
                                  ]
                                |)
                              |)
                            ]
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (M.alloc (|
                          Value.StructTuple
                            "move_core_types::transaction_argument::TransactionArgument::Bool"
                            [ Value.Bool true ]
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (M.alloc (|
                          Value.StructTuple
                            "move_core_types::transaction_argument::TransactionArgument::Bool"
                            [ Value.Bool false ]
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.get_struct_tuple_field_or_break_match (|
                            γ,
                            "move_core_types::parser::Token::Address",
                            0
                          |) in
                        let addr := M.copy (| γ0_0 |) in
                        M.alloc (|
                          Value.StructTuple
                            "move_core_types::transaction_argument::TransactionArgument::Address"
                            [
                              M.read (|
                                M.match_operator (|
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::ops::try_trait::Try",
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          [
                                            Ty.path
                                              "move_core_types::account_address::AccountAddress";
                                            Ty.path
                                              "move_core_types::account_address::AccountAddressParseError"
                                          ],
                                        [],
                                        "branch",
                                        []
                                      |),
                                      [
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.path
                                              "move_core_types::account_address::AccountAddress",
                                            "from_hex_literal",
                                            []
                                          |),
                                          [
                                            M.call_closure (|
                                              M.get_trait_method (|
                                                "core::ops::deref::Deref",
                                                Ty.path "alloc::string::String",
                                                [],
                                                "deref",
                                                []
                                              |),
                                              [ addr ]
                                            |)
                                          ]
                                        |)
                                      ]
                                    |)
                                  |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 :=
                                          M.get_struct_tuple_field_or_break_match (|
                                            γ,
                                            "core::ops::control_flow::ControlFlow::Break",
                                            0
                                          |) in
                                        let residual := M.copy (| γ0_0 |) in
                                        M.alloc (|
                                          M.never_to_any (|
                                            M.read (|
                                              M.return_ (|
                                                M.call_closure (|
                                                  M.get_trait_method (|
                                                    "core::ops::try_trait::FromResidual",
                                                    Ty.apply
                                                      (Ty.path "core::result::Result")
                                                      [
                                                        Ty.path
                                                          "move_core_types::transaction_argument::TransactionArgument";
                                                        Ty.path "anyhow::Error"
                                                      ],
                                                    [
                                                      Ty.apply
                                                        (Ty.path "core::result::Result")
                                                        [
                                                          Ty.path "core::convert::Infallible";
                                                          Ty.path
                                                            "move_core_types::account_address::AccountAddressParseError"
                                                        ]
                                                    ],
                                                    "from_residual",
                                                    []
                                                  |),
                                                  [ M.read (| residual |) ]
                                                |)
                                              |)
                                            |)
                                          |)
                                        |)));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 :=
                                          M.get_struct_tuple_field_or_break_match (|
                                            γ,
                                            "core::ops::control_flow::ControlFlow::Continue",
                                            0
                                          |) in
                                        let val := M.copy (| γ0_0 |) in
                                        val))
                                  ]
                                |)
                              |)
                            ]
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.get_struct_tuple_field_or_break_match (|
                            γ,
                            "move_core_types::parser::Token::Bytes",
                            0
                          |) in
                        let s := M.copy (| γ0_0 |) in
                        M.alloc (|
                          Value.StructTuple
                            "move_core_types::transaction_argument::TransactionArgument::U8Vector"
                            [
                              M.read (|
                                M.match_operator (|
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::ops::try_trait::Try",
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          [
                                            Ty.apply
                                              (Ty.path "alloc::vec::Vec")
                                              [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ];
                                            Ty.path "hex::error::FromHexError"
                                          ],
                                        [],
                                        "branch",
                                        []
                                      |),
                                      [
                                        M.call_closure (|
                                          M.get_function (|
                                            "hex::decode",
                                            [ Ty.path "alloc::string::String" ]
                                          |),
                                          [ M.read (| s |) ]
                                        |)
                                      ]
                                    |)
                                  |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 :=
                                          M.get_struct_tuple_field_or_break_match (|
                                            γ,
                                            "core::ops::control_flow::ControlFlow::Break",
                                            0
                                          |) in
                                        let residual := M.copy (| γ0_0 |) in
                                        M.alloc (|
                                          M.never_to_any (|
                                            M.read (|
                                              M.return_ (|
                                                M.call_closure (|
                                                  M.get_trait_method (|
                                                    "core::ops::try_trait::FromResidual",
                                                    Ty.apply
                                                      (Ty.path "core::result::Result")
                                                      [
                                                        Ty.path
                                                          "move_core_types::transaction_argument::TransactionArgument";
                                                        Ty.path "anyhow::Error"
                                                      ],
                                                    [
                                                      Ty.apply
                                                        (Ty.path "core::result::Result")
                                                        [
                                                          Ty.path "core::convert::Infallible";
                                                          Ty.path "hex::error::FromHexError"
                                                        ]
                                                    ],
                                                    "from_residual",
                                                    []
                                                  |),
                                                  [ M.read (| residual |) ]
                                                |)
                                              |)
                                            |)
                                          |)
                                        |)));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 :=
                                          M.get_struct_tuple_field_or_break_match (|
                                            γ,
                                            "core::ops::control_flow::ControlFlow::Continue",
                                            0
                                          |) in
                                        let val := M.copy (| γ0_0 |) in
                                        val))
                                  ]
                                |)
                              |)
                            ]
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let tok := M.copy (| γ |) in
                        M.alloc (|
                          M.never_to_any (|
                            M.read (|
                              M.return_ (|
                                Value.StructTuple
                                  "core::result::Result::Err"
                                  [
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.path "anyhow::Error",
                                        "msg",
                                        [ Ty.path "alloc::string::String" ]
                                      |),
                                      [
                                        M.read (|
                                          let res :=
                                            M.alloc (|
                                              M.call_closure (|
                                                M.get_function (| "alloc::fmt::format", [] |),
                                                [
                                                  M.call_closure (|
                                                    M.get_associated_function (|
                                                      Ty.path "core::fmt::Arguments",
                                                      "new_v1",
                                                      []
                                                    |),
                                                    [
                                                      (* Unsize *)
                                                      M.pointer_coercion
                                                        (M.alloc (|
                                                          Value.Array
                                                            [
                                                              M.read (|
                                                                mk_str "unexpected token "
                                                              |);
                                                              M.read (|
                                                                mk_str
                                                                  ", expected transaction argument"
                                                              |)
                                                            ]
                                                        |));
                                                      (* Unsize *)
                                                      M.pointer_coercion
                                                        (M.alloc (|
                                                          Value.Array
                                                            [
                                                              M.call_closure (|
                                                                M.get_associated_function (|
                                                                  Ty.path "core::fmt::rt::Argument",
                                                                  "new_debug",
                                                                  [
                                                                    Ty.path
                                                                      "move_core_types::parser::Token"
                                                                  ]
                                                                |),
                                                                [ tok ]
                                                              |)
                                                            ]
                                                        |))
                                                    ]
                                                  |)
                                                ]
                                              |)
                                            |) in
                                          res
                                        |)
                                      ]
                                    |)
                                  ]
                              |)
                            |)
                          |)
                        |)))
                  ]
                |)
              |)
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_parse_transaction_argument :
      forall (I : Ty.t),
      M.IsAssociatedFunction (Self I) "parse_transaction_argument" (parse_transaction_argument I).
  End Impl_move_core_types_parser_Parser_I.
  
  (*
  fn parse<F, T>(s: &str, f: F) -> Result<T>
  where
      F: Fn(&mut Parser<std::vec::IntoIter<Token>>) -> Result<T>,
  {
      let mut tokens: Vec<_> = tokenize(s)?
          .into_iter()
          .filter(|tok| !tok.is_whitespace())
          .collect();
      tokens.push(Token::EOF);
      let mut parser = Parser::new(tokens);
      let res = f(&mut parser)?;
      parser.consume(Token::EOF)?;
      Ok(res)
  }
  *)
  Definition parse (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [ F; T ], [ s; f ] =>
      ltac:(M.monadic
        (let s := M.alloc (| s |) in
        let f := M.alloc (| f |) in
        M.read (|
          let tokens :=
            M.alloc (|
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  Ty.apply
                    (Ty.path "core::iter::adapters::filter::Filter")
                    [
                      Ty.apply
                        (Ty.path "alloc::vec::into_iter::IntoIter")
                        [ Ty.path "move_core_types::parser::Token"; Ty.path "alloc::alloc::Global"
                        ];
                      Ty.function
                        [
                          Ty.tuple
                            [ Ty.apply (Ty.path "&") [ Ty.path "move_core_types::parser::Token" ] ]
                        ]
                        (Ty.path "bool")
                    ],
                  [],
                  "collect",
                  [
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      [ Ty.path "move_core_types::parser::Token"; Ty.path "alloc::alloc::Global" ]
                  ]
                |),
                [
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::iter::traits::iterator::Iterator",
                      Ty.apply
                        (Ty.path "alloc::vec::into_iter::IntoIter")
                        [ Ty.path "move_core_types::parser::Token"; Ty.path "alloc::alloc::Global"
                        ],
                      [],
                      "filter",
                      [
                        Ty.function
                          [
                            Ty.tuple
                              [ Ty.apply (Ty.path "&") [ Ty.path "move_core_types::parser::Token" ]
                              ]
                          ]
                          (Ty.path "bool")
                      ]
                    |),
                    [
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::iter::traits::collect::IntoIterator",
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            [
                              Ty.path "move_core_types::parser::Token";
                              Ty.path "alloc::alloc::Global"
                            ],
                          [],
                          "into_iter",
                          []
                        |),
                        [
                          M.read (|
                            M.match_operator (|
                              M.alloc (|
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::ops::try_trait::Try",
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      [
                                        Ty.apply
                                          (Ty.path "alloc::vec::Vec")
                                          [
                                            Ty.path "move_core_types::parser::Token";
                                            Ty.path "alloc::alloc::Global"
                                          ];
                                        Ty.path "anyhow::Error"
                                      ],
                                    [],
                                    "branch",
                                    []
                                  |),
                                  [
                                    M.call_closure (|
                                      M.get_function (| "move_core_types::parser::tokenize", [] |),
                                      [ M.read (| s |) ]
                                    |)
                                  ]
                                |)
                              |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ0_0 :=
                                      M.get_struct_tuple_field_or_break_match (|
                                        γ,
                                        "core::ops::control_flow::ControlFlow::Break",
                                        0
                                      |) in
                                    let residual := M.copy (| γ0_0 |) in
                                    M.alloc (|
                                      M.never_to_any (|
                                        M.read (|
                                          M.return_ (|
                                            M.call_closure (|
                                              M.get_trait_method (|
                                                "core::ops::try_trait::FromResidual",
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  [ T; Ty.path "anyhow::Error" ],
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::result::Result")
                                                    [
                                                      Ty.path "core::convert::Infallible";
                                                      Ty.path "anyhow::Error"
                                                    ]
                                                ],
                                                "from_residual",
                                                []
                                              |),
                                              [ M.read (| residual |) ]
                                            |)
                                          |)
                                        |)
                                      |)
                                    |)));
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ0_0 :=
                                      M.get_struct_tuple_field_or_break_match (|
                                        γ,
                                        "core::ops::control_flow::ControlFlow::Continue",
                                        0
                                      |) in
                                    let val := M.copy (| γ0_0 |) in
                                    val))
                              ]
                            |)
                          |)
                        ]
                      |);
                      M.closure
                        (fun γ =>
                          ltac:(M.monadic
                            match γ with
                            | [ α0 ] =>
                              M.match_operator (|
                                M.alloc (| α0 |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let tok := M.copy (| γ |) in
                                      UnOp.Pure.not
                                        (M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.path "move_core_types::parser::Token",
                                            "is_whitespace",
                                            []
                                          |),
                                          [ M.read (| tok |) ]
                                        |))))
                                ]
                              |)
                            | _ => M.impossible (||)
                            end))
                    ]
                  |)
                ]
              |)
            |) in
          let _ :=
            M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    [ Ty.path "move_core_types::parser::Token"; Ty.path "alloc::alloc::Global" ],
                  "push",
                  []
                |),
                [ tokens; Value.StructTuple "move_core_types::parser::Token::EOF" [] ]
              |)
            |) in
          let parser :=
            M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "move_core_types::parser::Parser")
                    [
                      Ty.apply
                        (Ty.path "alloc::vec::into_iter::IntoIter")
                        [ Ty.path "move_core_types::parser::Token"; Ty.path "alloc::alloc::Global" ]
                    ],
                  "new",
                  [
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      [ Ty.path "move_core_types::parser::Token"; Ty.path "alloc::alloc::Global" ]
                  ]
                |),
                [ M.read (| tokens |) ]
              |)
            |) in
          let res :=
            M.copy (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::try_trait::Try",
                      Ty.apply (Ty.path "core::result::Result") [ T; Ty.path "anyhow::Error" ],
                      [],
                      "branch",
                      []
                    |),
                    [
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::ops::function::Fn",
                          F,
                          [
                            Ty.tuple
                              [
                                Ty.apply
                                  (Ty.path "&mut")
                                  [
                                    Ty.apply
                                      (Ty.path "move_core_types::parser::Parser")
                                      [
                                        Ty.apply
                                          (Ty.path "alloc::vec::into_iter::IntoIter")
                                          [
                                            Ty.path "move_core_types::parser::Token";
                                            Ty.path "alloc::alloc::Global"
                                          ]
                                      ]
                                  ]
                              ]
                          ],
                          "call",
                          []
                        |),
                        [ f; Value.Tuple [ parser ] ]
                      |)
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.get_struct_tuple_field_or_break_match (|
                          γ,
                          "core::ops::control_flow::ControlFlow::Break",
                          0
                        |) in
                      let residual := M.copy (| γ0_0 |) in
                      M.alloc (|
                        M.never_to_any (|
                          M.read (|
                            M.return_ (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::ops::try_trait::FromResidual",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    [ T; Ty.path "anyhow::Error" ],
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      [ Ty.path "core::convert::Infallible"; Ty.path "anyhow::Error"
                                      ]
                                  ],
                                  "from_residual",
                                  []
                                |),
                                [ M.read (| residual |) ]
                              |)
                            |)
                          |)
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.get_struct_tuple_field_or_break_match (|
                          γ,
                          "core::ops::control_flow::ControlFlow::Continue",
                          0
                        |) in
                      let val := M.copy (| γ0_0 |) in
                      val))
                ]
              |)
            |) in
          let _ :=
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "core::ops::try_trait::Try",
                    Ty.apply
                      (Ty.path "core::result::Result")
                      [ Ty.tuple []; Ty.path "anyhow::Error" ],
                    [],
                    "branch",
                    []
                  |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "move_core_types::parser::Parser")
                          [
                            Ty.apply
                              (Ty.path "alloc::vec::into_iter::IntoIter")
                              [
                                Ty.path "move_core_types::parser::Token";
                                Ty.path "alloc::alloc::Global"
                              ]
                          ],
                        "consume",
                        []
                      |),
                      [ parser; Value.StructTuple "move_core_types::parser::Token::EOF" [] ]
                    |)
                  ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "core::ops::control_flow::ControlFlow::Break",
                        0
                      |) in
                    let residual := M.copy (| γ0_0 |) in
                    M.alloc (|
                      M.never_to_any (|
                        M.read (|
                          M.return_ (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::ops::try_trait::FromResidual",
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  [ T; Ty.path "anyhow::Error" ],
                                [
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    [ Ty.path "core::convert::Infallible"; Ty.path "anyhow::Error" ]
                                ],
                                "from_residual",
                                []
                              |),
                              [ M.read (| residual |) ]
                            |)
                          |)
                        |)
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "core::ops::control_flow::ControlFlow::Continue",
                        0
                      |) in
                    let val := M.copy (| γ0_0 |) in
                    val))
              ]
            |) in
          M.alloc (| Value.StructTuple "core::result::Result::Ok" [ M.read (| res |) ] |)
        |)))
    | _, _ => M.impossible
    end.
  
  (*
  pub fn parse_string_list(s: &str) -> Result<Vec<String>> {
      parse(s, |parser| {
          parser.parse_comma_list(|parser| parser.parse_string(), Token::EOF, true)
      })
  }
  *)
  Definition parse_string_list (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ s ] =>
      ltac:(M.monadic
        (let s := M.alloc (| s |) in
        M.call_closure (|
          M.get_function (|
            "move_core_types::parser::parse",
            [
              Ty.function
                [
                  Ty.tuple
                    [
                      Ty.apply
                        (Ty.path "&mut")
                        [
                          Ty.apply
                            (Ty.path "move_core_types::parser::Parser")
                            [
                              Ty.apply
                                (Ty.path "alloc::vec::into_iter::IntoIter")
                                [
                                  Ty.path "move_core_types::parser::Token";
                                  Ty.path "alloc::alloc::Global"
                                ]
                            ]
                        ]
                    ]
                ]
                (Ty.apply
                  (Ty.path "core::result::Result")
                  [
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      [ Ty.path "alloc::string::String"; Ty.path "alloc::alloc::Global" ];
                    Ty.path "anyhow::Error"
                  ]);
              Ty.apply
                (Ty.path "alloc::vec::Vec")
                [ Ty.path "alloc::string::String"; Ty.path "alloc::alloc::Global" ]
            ]
          |),
          [
            M.read (| s |);
            M.closure
              (fun γ =>
                ltac:(M.monadic
                  match γ with
                  | [ α0 ] =>
                    M.match_operator (|
                      M.alloc (| α0 |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let parser := M.copy (| γ |) in
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "move_core_types::parser::Parser")
                                  [
                                    Ty.apply
                                      (Ty.path "alloc::vec::into_iter::IntoIter")
                                      [
                                        Ty.path "move_core_types::parser::Token";
                                        Ty.path "alloc::alloc::Global"
                                      ]
                                  ],
                                "parse_comma_list",
                                [
                                  Ty.function
                                    [
                                      Ty.tuple
                                        [
                                          Ty.apply
                                            (Ty.path "&mut")
                                            [
                                              Ty.apply
                                                (Ty.path "move_core_types::parser::Parser")
                                                [
                                                  Ty.apply
                                                    (Ty.path "alloc::vec::into_iter::IntoIter")
                                                    [
                                                      Ty.path "move_core_types::parser::Token";
                                                      Ty.path "alloc::alloc::Global"
                                                    ]
                                                ]
                                            ]
                                        ]
                                    ]
                                    (Ty.apply
                                      (Ty.path "core::result::Result")
                                      [ Ty.path "alloc::string::String"; Ty.path "anyhow::Error" ]);
                                  Ty.path "alloc::string::String"
                                ]
                              |),
                              [
                                M.read (| parser |);
                                M.closure
                                  (fun γ =>
                                    ltac:(M.monadic
                                      match γ with
                                      | [ α0 ] =>
                                        M.match_operator (|
                                          M.alloc (| α0 |),
                                          [
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let parser := M.copy (| γ |) in
                                                M.call_closure (|
                                                  M.get_associated_function (|
                                                    Ty.apply
                                                      (Ty.path "move_core_types::parser::Parser")
                                                      [
                                                        Ty.apply
                                                          (Ty.path
                                                            "alloc::vec::into_iter::IntoIter")
                                                          [
                                                            Ty.path
                                                              "move_core_types::parser::Token";
                                                            Ty.path "alloc::alloc::Global"
                                                          ]
                                                      ],
                                                    "parse_string",
                                                    []
                                                  |),
                                                  [ M.read (| parser |) ]
                                                |)))
                                          ]
                                        |)
                                      | _ => M.impossible (||)
                                      end));
                                Value.StructTuple "move_core_types::parser::Token::EOF" [];
                                Value.Bool true
                              ]
                            |)))
                      ]
                    |)
                  | _ => M.impossible (||)
                  end))
          ]
        |)))
    | _, _ => M.impossible
    end.
  
  (*
  pub fn parse_type_tags(s: &str) -> Result<Vec<TypeTag>> {
      parse(s, |parser| {
          parser.parse_comma_list(|parser| parser.parse_type_tag(), Token::EOF, true)
      })
  }
  *)
  Definition parse_type_tags (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ s ] =>
      ltac:(M.monadic
        (let s := M.alloc (| s |) in
        M.call_closure (|
          M.get_function (|
            "move_core_types::parser::parse",
            [
              Ty.function
                [
                  Ty.tuple
                    [
                      Ty.apply
                        (Ty.path "&mut")
                        [
                          Ty.apply
                            (Ty.path "move_core_types::parser::Parser")
                            [
                              Ty.apply
                                (Ty.path "alloc::vec::into_iter::IntoIter")
                                [
                                  Ty.path "move_core_types::parser::Token";
                                  Ty.path "alloc::alloc::Global"
                                ]
                            ]
                        ]
                    ]
                ]
                (Ty.apply
                  (Ty.path "core::result::Result")
                  [
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      [
                        Ty.path "move_core_types::language_storage::TypeTag";
                        Ty.path "alloc::alloc::Global"
                      ];
                    Ty.path "anyhow::Error"
                  ]);
              Ty.apply
                (Ty.path "alloc::vec::Vec")
                [
                  Ty.path "move_core_types::language_storage::TypeTag";
                  Ty.path "alloc::alloc::Global"
                ]
            ]
          |),
          [
            M.read (| s |);
            M.closure
              (fun γ =>
                ltac:(M.monadic
                  match γ with
                  | [ α0 ] =>
                    M.match_operator (|
                      M.alloc (| α0 |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let parser := M.copy (| γ |) in
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "move_core_types::parser::Parser")
                                  [
                                    Ty.apply
                                      (Ty.path "alloc::vec::into_iter::IntoIter")
                                      [
                                        Ty.path "move_core_types::parser::Token";
                                        Ty.path "alloc::alloc::Global"
                                      ]
                                  ],
                                "parse_comma_list",
                                [
                                  Ty.function
                                    [
                                      Ty.tuple
                                        [
                                          Ty.apply
                                            (Ty.path "&mut")
                                            [
                                              Ty.apply
                                                (Ty.path "move_core_types::parser::Parser")
                                                [
                                                  Ty.apply
                                                    (Ty.path "alloc::vec::into_iter::IntoIter")
                                                    [
                                                      Ty.path "move_core_types::parser::Token";
                                                      Ty.path "alloc::alloc::Global"
                                                    ]
                                                ]
                                            ]
                                        ]
                                    ]
                                    (Ty.apply
                                      (Ty.path "core::result::Result")
                                      [
                                        Ty.path "move_core_types::language_storage::TypeTag";
                                        Ty.path "anyhow::Error"
                                      ]);
                                  Ty.path "move_core_types::language_storage::TypeTag"
                                ]
                              |),
                              [
                                M.read (| parser |);
                                M.closure
                                  (fun γ =>
                                    ltac:(M.monadic
                                      match γ with
                                      | [ α0 ] =>
                                        M.match_operator (|
                                          M.alloc (| α0 |),
                                          [
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let parser := M.copy (| γ |) in
                                                M.call_closure (|
                                                  M.get_associated_function (|
                                                    Ty.apply
                                                      (Ty.path "move_core_types::parser::Parser")
                                                      [
                                                        Ty.apply
                                                          (Ty.path
                                                            "alloc::vec::into_iter::IntoIter")
                                                          [
                                                            Ty.path
                                                              "move_core_types::parser::Token";
                                                            Ty.path "alloc::alloc::Global"
                                                          ]
                                                      ],
                                                    "parse_type_tag",
                                                    []
                                                  |),
                                                  [ M.read (| parser |) ]
                                                |)))
                                          ]
                                        |)
                                      | _ => M.impossible (||)
                                      end));
                                Value.StructTuple "move_core_types::parser::Token::EOF" [];
                                Value.Bool true
                              ]
                            |)))
                      ]
                    |)
                  | _ => M.impossible (||)
                  end))
          ]
        |)))
    | _, _ => M.impossible
    end.
  
  (*
  pub fn parse_type_tag(s: &str) -> Result<TypeTag> {
      parse(s, |parser| parser.parse_type_tag())
  }
  *)
  Definition parse_type_tag (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ s ] =>
      ltac:(M.monadic
        (let s := M.alloc (| s |) in
        M.call_closure (|
          M.get_function (|
            "move_core_types::parser::parse",
            [
              Ty.function
                [
                  Ty.tuple
                    [
                      Ty.apply
                        (Ty.path "&mut")
                        [
                          Ty.apply
                            (Ty.path "move_core_types::parser::Parser")
                            [
                              Ty.apply
                                (Ty.path "alloc::vec::into_iter::IntoIter")
                                [
                                  Ty.path "move_core_types::parser::Token";
                                  Ty.path "alloc::alloc::Global"
                                ]
                            ]
                        ]
                    ]
                ]
                (Ty.apply
                  (Ty.path "core::result::Result")
                  [ Ty.path "move_core_types::language_storage::TypeTag"; Ty.path "anyhow::Error"
                  ]);
              Ty.path "move_core_types::language_storage::TypeTag"
            ]
          |),
          [
            M.read (| s |);
            M.closure
              (fun γ =>
                ltac:(M.monadic
                  match γ with
                  | [ α0 ] =>
                    M.match_operator (|
                      M.alloc (| α0 |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let parser := M.copy (| γ |) in
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "move_core_types::parser::Parser")
                                  [
                                    Ty.apply
                                      (Ty.path "alloc::vec::into_iter::IntoIter")
                                      [
                                        Ty.path "move_core_types::parser::Token";
                                        Ty.path "alloc::alloc::Global"
                                      ]
                                  ],
                                "parse_type_tag",
                                []
                              |),
                              [ M.read (| parser |) ]
                            |)))
                      ]
                    |)
                  | _ => M.impossible (||)
                  end))
          ]
        |)))
    | _, _ => M.impossible
    end.
  
  (*
  pub fn parse_transaction_arguments(s: &str) -> Result<Vec<TransactionArgument>> {
      parse(s, |parser| {
          parser.parse_comma_list(
              |parser| parser.parse_transaction_argument(),
              Token::EOF,
              true,
          )
      })
  }
  *)
  Definition parse_transaction_arguments (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ s ] =>
      ltac:(M.monadic
        (let s := M.alloc (| s |) in
        M.call_closure (|
          M.get_function (|
            "move_core_types::parser::parse",
            [
              Ty.function
                [
                  Ty.tuple
                    [
                      Ty.apply
                        (Ty.path "&mut")
                        [
                          Ty.apply
                            (Ty.path "move_core_types::parser::Parser")
                            [
                              Ty.apply
                                (Ty.path "alloc::vec::into_iter::IntoIter")
                                [
                                  Ty.path "move_core_types::parser::Token";
                                  Ty.path "alloc::alloc::Global"
                                ]
                            ]
                        ]
                    ]
                ]
                (Ty.apply
                  (Ty.path "core::result::Result")
                  [
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      [
                        Ty.path "move_core_types::transaction_argument::TransactionArgument";
                        Ty.path "alloc::alloc::Global"
                      ];
                    Ty.path "anyhow::Error"
                  ]);
              Ty.apply
                (Ty.path "alloc::vec::Vec")
                [
                  Ty.path "move_core_types::transaction_argument::TransactionArgument";
                  Ty.path "alloc::alloc::Global"
                ]
            ]
          |),
          [
            M.read (| s |);
            M.closure
              (fun γ =>
                ltac:(M.monadic
                  match γ with
                  | [ α0 ] =>
                    M.match_operator (|
                      M.alloc (| α0 |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let parser := M.copy (| γ |) in
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "move_core_types::parser::Parser")
                                  [
                                    Ty.apply
                                      (Ty.path "alloc::vec::into_iter::IntoIter")
                                      [
                                        Ty.path "move_core_types::parser::Token";
                                        Ty.path "alloc::alloc::Global"
                                      ]
                                  ],
                                "parse_comma_list",
                                [
                                  Ty.function
                                    [
                                      Ty.tuple
                                        [
                                          Ty.apply
                                            (Ty.path "&mut")
                                            [
                                              Ty.apply
                                                (Ty.path "move_core_types::parser::Parser")
                                                [
                                                  Ty.apply
                                                    (Ty.path "alloc::vec::into_iter::IntoIter")
                                                    [
                                                      Ty.path "move_core_types::parser::Token";
                                                      Ty.path "alloc::alloc::Global"
                                                    ]
                                                ]
                                            ]
                                        ]
                                    ]
                                    (Ty.apply
                                      (Ty.path "core::result::Result")
                                      [
                                        Ty.path
                                          "move_core_types::transaction_argument::TransactionArgument";
                                        Ty.path "anyhow::Error"
                                      ]);
                                  Ty.path
                                    "move_core_types::transaction_argument::TransactionArgument"
                                ]
                              |),
                              [
                                M.read (| parser |);
                                M.closure
                                  (fun γ =>
                                    ltac:(M.monadic
                                      match γ with
                                      | [ α0 ] =>
                                        M.match_operator (|
                                          M.alloc (| α0 |),
                                          [
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let parser := M.copy (| γ |) in
                                                M.call_closure (|
                                                  M.get_associated_function (|
                                                    Ty.apply
                                                      (Ty.path "move_core_types::parser::Parser")
                                                      [
                                                        Ty.apply
                                                          (Ty.path
                                                            "alloc::vec::into_iter::IntoIter")
                                                          [
                                                            Ty.path
                                                              "move_core_types::parser::Token";
                                                            Ty.path "alloc::alloc::Global"
                                                          ]
                                                      ],
                                                    "parse_transaction_argument",
                                                    []
                                                  |),
                                                  [ M.read (| parser |) ]
                                                |)))
                                          ]
                                        |)
                                      | _ => M.impossible (||)
                                      end));
                                Value.StructTuple "move_core_types::parser::Token::EOF" [];
                                Value.Bool true
                              ]
                            |)))
                      ]
                    |)
                  | _ => M.impossible (||)
                  end))
          ]
        |)))
    | _, _ => M.impossible
    end.
  
  (*
  pub fn parse_transaction_argument(s: &str) -> Result<TransactionArgument> {
      parse(s, |parser| parser.parse_transaction_argument())
  }
  *)
  Definition parse_transaction_argument (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ s ] =>
      ltac:(M.monadic
        (let s := M.alloc (| s |) in
        M.call_closure (|
          M.get_function (|
            "move_core_types::parser::parse",
            [
              Ty.function
                [
                  Ty.tuple
                    [
                      Ty.apply
                        (Ty.path "&mut")
                        [
                          Ty.apply
                            (Ty.path "move_core_types::parser::Parser")
                            [
                              Ty.apply
                                (Ty.path "alloc::vec::into_iter::IntoIter")
                                [
                                  Ty.path "move_core_types::parser::Token";
                                  Ty.path "alloc::alloc::Global"
                                ]
                            ]
                        ]
                    ]
                ]
                (Ty.apply
                  (Ty.path "core::result::Result")
                  [
                    Ty.path "move_core_types::transaction_argument::TransactionArgument";
                    Ty.path "anyhow::Error"
                  ]);
              Ty.path "move_core_types::transaction_argument::TransactionArgument"
            ]
          |),
          [
            M.read (| s |);
            M.closure
              (fun γ =>
                ltac:(M.monadic
                  match γ with
                  | [ α0 ] =>
                    M.match_operator (|
                      M.alloc (| α0 |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let parser := M.copy (| γ |) in
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "move_core_types::parser::Parser")
                                  [
                                    Ty.apply
                                      (Ty.path "alloc::vec::into_iter::IntoIter")
                                      [
                                        Ty.path "move_core_types::parser::Token";
                                        Ty.path "alloc::alloc::Global"
                                      ]
                                  ],
                                "parse_transaction_argument",
                                []
                              |),
                              [ M.read (| parser |) ]
                            |)))
                      ]
                    |)
                  | _ => M.impossible (||)
                  end))
          ]
        |)))
    | _, _ => M.impossible
    end.
  
  (*
  pub fn parse_struct_tag(s: &str) -> Result<StructTag> {
      let type_tag = parse(s, |parser| parser.parse_type_tag())
          .map_err(|e| format_err!("invalid struct tag: {}, {}", s, e))?;
      if let TypeTag::Struct(struct_tag) = type_tag {
          Ok( *struct_tag)
      } else {
          bail!("invalid struct tag: {}", s)
      }
  }
  *)
  Definition parse_struct_tag (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ s ] =>
      ltac:(M.monadic
        (let s := M.alloc (| s |) in
        M.read (|
          let type_tag :=
            M.copy (|
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::try_trait::Try",
                      Ty.apply
                        (Ty.path "core::result::Result")
                        [
                          Ty.path "move_core_types::language_storage::TypeTag";
                          Ty.path "anyhow::Error"
                        ],
                      [],
                      "branch",
                      []
                    |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "core::result::Result")
                            [
                              Ty.path "move_core_types::language_storage::TypeTag";
                              Ty.path "anyhow::Error"
                            ],
                          "map_err",
                          [
                            Ty.path "anyhow::Error";
                            Ty.function
                              [ Ty.tuple [ Ty.path "anyhow::Error" ] ]
                              (Ty.path "anyhow::Error")
                          ]
                        |),
                        [
                          M.call_closure (|
                            M.get_function (|
                              "move_core_types::parser::parse",
                              [
                                Ty.function
                                  [
                                    Ty.tuple
                                      [
                                        Ty.apply
                                          (Ty.path "&mut")
                                          [
                                            Ty.apply
                                              (Ty.path "move_core_types::parser::Parser")
                                              [
                                                Ty.apply
                                                  (Ty.path "alloc::vec::into_iter::IntoIter")
                                                  [
                                                    Ty.path "move_core_types::parser::Token";
                                                    Ty.path "alloc::alloc::Global"
                                                  ]
                                              ]
                                          ]
                                      ]
                                  ]
                                  (Ty.apply
                                    (Ty.path "core::result::Result")
                                    [
                                      Ty.path "move_core_types::language_storage::TypeTag";
                                      Ty.path "anyhow::Error"
                                    ]);
                                Ty.path "move_core_types::language_storage::TypeTag"
                              ]
                            |),
                            [
                              M.read (| s |);
                              M.closure
                                (fun γ =>
                                  ltac:(M.monadic
                                    match γ with
                                    | [ α0 ] =>
                                      M.match_operator (|
                                        M.alloc (| α0 |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let parser := M.copy (| γ |) in
                                              M.call_closure (|
                                                M.get_associated_function (|
                                                  Ty.apply
                                                    (Ty.path "move_core_types::parser::Parser")
                                                    [
                                                      Ty.apply
                                                        (Ty.path "alloc::vec::into_iter::IntoIter")
                                                        [
                                                          Ty.path "move_core_types::parser::Token";
                                                          Ty.path "alloc::alloc::Global"
                                                        ]
                                                    ],
                                                  "parse_type_tag",
                                                  []
                                                |),
                                                [ M.read (| parser |) ]
                                              |)))
                                        ]
                                      |)
                                    | _ => M.impossible (||)
                                    end))
                            ]
                          |);
                          M.closure
                            (fun γ =>
                              ltac:(M.monadic
                                match γ with
                                | [ α0 ] =>
                                  M.match_operator (|
                                    M.alloc (| α0 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let e := M.copy (| γ |) in
                                          M.call_closure (|
                                            M.get_associated_function (|
                                              Ty.path "anyhow::Error",
                                              "msg",
                                              [ Ty.path "alloc::string::String" ]
                                            |),
                                            [
                                              M.read (|
                                                let res :=
                                                  M.alloc (|
                                                    M.call_closure (|
                                                      M.get_function (| "alloc::fmt::format", [] |),
                                                      [
                                                        M.call_closure (|
                                                          M.get_associated_function (|
                                                            Ty.path "core::fmt::Arguments",
                                                            "new_v1",
                                                            []
                                                          |),
                                                          [
                                                            (* Unsize *)
                                                            M.pointer_coercion
                                                              (M.alloc (|
                                                                Value.Array
                                                                  [
                                                                    M.read (|
                                                                      mk_str "invalid struct tag: "
                                                                    |);
                                                                    M.read (| mk_str ", " |)
                                                                  ]
                                                              |));
                                                            (* Unsize *)
                                                            M.pointer_coercion
                                                              (M.alloc (|
                                                                Value.Array
                                                                  [
                                                                    M.call_closure (|
                                                                      M.get_associated_function (|
                                                                        Ty.path
                                                                          "core::fmt::rt::Argument",
                                                                        "new_display",
                                                                        [
                                                                          Ty.apply
                                                                            (Ty.path "&")
                                                                            [ Ty.path "str" ]
                                                                        ]
                                                                      |),
                                                                      [ s ]
                                                                    |);
                                                                    M.call_closure (|
                                                                      M.get_associated_function (|
                                                                        Ty.path
                                                                          "core::fmt::rt::Argument",
                                                                        "new_display",
                                                                        [ Ty.path "anyhow::Error" ]
                                                                      |),
                                                                      [ e ]
                                                                    |)
                                                                  ]
                                                              |))
                                                          ]
                                                        |)
                                                      ]
                                                    |)
                                                  |) in
                                                res
                                              |)
                                            ]
                                          |)))
                                    ]
                                  |)
                                | _ => M.impossible (||)
                                end))
                        ]
                      |)
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.get_struct_tuple_field_or_break_match (|
                          γ,
                          "core::ops::control_flow::ControlFlow::Break",
                          0
                        |) in
                      let residual := M.copy (| γ0_0 |) in
                      M.alloc (|
                        M.never_to_any (|
                          M.read (|
                            M.return_ (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::ops::try_trait::FromResidual",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    [
                                      Ty.path "move_core_types::language_storage::StructTag";
                                      Ty.path "anyhow::Error"
                                    ],
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      [ Ty.path "core::convert::Infallible"; Ty.path "anyhow::Error"
                                      ]
                                  ],
                                  "from_residual",
                                  []
                                |),
                                [ M.read (| residual |) ]
                              |)
                            |)
                          |)
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.get_struct_tuple_field_or_break_match (|
                          γ,
                          "core::ops::control_flow::ControlFlow::Continue",
                          0
                        |) in
                      let val := M.copy (| γ0_0 |) in
                      val))
                ]
              |)
            |) in
          M.match_operator (|
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ := type_tag in
                  let γ0_0 :=
                    M.get_struct_tuple_field_or_break_match (|
                      γ,
                      "move_core_types::language_storage::TypeTag::Struct",
                      0
                    |) in
                  let struct_tag := M.copy (| γ0_0 |) in
                  M.alloc (|
                    Value.StructTuple
                      "core::result::Result::Ok"
                      [ M.read (| M.read (| struct_tag |) |) ]
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (M.alloc (|
                    M.never_to_any (|
                      M.read (|
                        M.return_ (|
                          Value.StructTuple
                            "core::result::Result::Err"
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "anyhow::Error",
                                  "msg",
                                  [ Ty.path "alloc::string::String" ]
                                |),
                                [
                                  M.read (|
                                    let res :=
                                      M.alloc (|
                                        M.call_closure (|
                                          M.get_function (| "alloc::fmt::format", [] |),
                                          [
                                            M.call_closure (|
                                              M.get_associated_function (|
                                                Ty.path "core::fmt::Arguments",
                                                "new_v1",
                                                []
                                              |),
                                              [
                                                (* Unsize *)
                                                M.pointer_coercion
                                                  (M.alloc (|
                                                    Value.Array
                                                      [ M.read (| mk_str "invalid struct tag: " |) ]
                                                  |));
                                                (* Unsize *)
                                                M.pointer_coercion
                                                  (M.alloc (|
                                                    Value.Array
                                                      [
                                                        M.call_closure (|
                                                          M.get_associated_function (|
                                                            Ty.path "core::fmt::rt::Argument",
                                                            "new_display",
                                                            [
                                                              Ty.apply
                                                                (Ty.path "&")
                                                                [ Ty.path "str" ]
                                                            ]
                                                          |),
                                                          [ s ]
                                                        |)
                                                      ]
                                                  |))
                                              ]
                                            |)
                                          ]
                                        |)
                                      |) in
                                    res
                                  |)
                                ]
                              |)
                            ]
                        |)
                      |)
                    |)
                  |)))
            ]
          |)
        |)))
    | _, _ => M.impossible
    end.
End parser.

Module resolver.
  (* Trait *)
  (* Empty module 'ModuleResolver' *)
  
  (* Trait *)
  (* Empty module 'ResourceResolver' *)
  
  (* Trait *)
  (* Empty module 'MoveResolver' *)
  
  Module Impl_move_core_types_resolver_MoveResolver_for_T.
    Definition Self (E T : Ty.t) : Ty.t := T.
    
    (*     type Err = E; *)
    Definition _Err (E T : Ty.t) : Ty.t := E.
    
    Axiom Implements :
      forall (E T : Ty.t),
      M.IsTraitInstance
        "move_core_types::resolver::MoveResolver"
        (Self E T)
        (* Trait polymorphic types *) []
        (* Instance *) [ ("Err", InstanceField.Ty (_Err E T)) ].
  End Impl_move_core_types_resolver_MoveResolver_for_T.
  
  Module Impl_move_core_types_resolver_ResourceResolver_for_ref__T.
    Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "&") [ T ].
    
    (*     type Error = T::Error; *)
    Definition _Error (T : Ty.t) : Ty.t := Ty.associated.
    
    (*
        fn get_resource(
            &self,
            address: &AccountAddress,
            tag: &StructTag,
        ) -> Result<Option<Vec<u8>>, Self::Error> {
            ( **self).get_resource(address, tag)
        }
    *)
    Definition get_resource (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ self; address; tag ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let address := M.alloc (| address |) in
          let tag := M.alloc (| tag |) in
          M.call_closure (|
            M.get_trait_method (|
              "move_core_types::resolver::ResourceResolver",
              T,
              [],
              "get_resource",
              []
            |),
            [ M.read (| M.read (| self |) |); M.read (| address |); M.read (| tag |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "move_core_types::resolver::ResourceResolver"
        (Self T)
        (* Trait polymorphic types *) []
        (* Instance *)
        [
          ("Error", InstanceField.Ty (_Error T));
          ("get_resource", InstanceField.Method (get_resource T))
        ].
  End Impl_move_core_types_resolver_ResourceResolver_for_ref__T.
  
  Module Impl_move_core_types_resolver_ModuleResolver_for_ref__T.
    Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "&") [ T ].
    
    (*     type Error = T::Error; *)
    Definition _Error (T : Ty.t) : Ty.t := Ty.associated.
    
    (*
        fn get_module(&self, module_id: &ModuleId) -> Result<Option<Vec<u8>>, Self::Error> {
            ( **self).get_module(module_id)
        }
    *)
    Definition get_module (T : Ty.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self T in
      match τ, α with
      | [], [ self; module_id ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let module_id := M.alloc (| module_id |) in
          M.call_closure (|
            M.get_trait_method (|
              "move_core_types::resolver::ModuleResolver",
              T,
              [],
              "get_module",
              []
            |),
            [ M.read (| M.read (| self |) |); M.read (| module_id |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      forall (T : Ty.t),
      M.IsTraitInstance
        "move_core_types::resolver::ModuleResolver"
        (Self T)
        (* Trait polymorphic types *) []
        (* Instance *)
        [
          ("Error", InstanceField.Ty (_Error T));
          ("get_module", InstanceField.Method (get_module T))
        ].
  End Impl_move_core_types_resolver_ModuleResolver_for_ref__T.
End resolver.

Module state.
  (*
  Enum VMState
  {
    ty_params := [];
    variants :=
      [
        {
          name := "DESERIALIZER";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "VERIFIER";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "RUNTIME";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "OTHER";
          item := StructTuple [];
          discriminant := None;
        }
      ];
  }
  *)
  
  Module Impl_core_clone_Clone_for_move_core_types_state_VMState.
    Definition Self : Ty.t := Ty.path "move_core_types::state::VMState".
    
    (* Clone *)
    Definition clone (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (| M.read (| self |) |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_move_core_types_state_VMState.
  
  Module Impl_core_marker_Copy_for_move_core_types_state_VMState.
    Definition Self : Ty.t := Ty.path "move_core_types::state::VMState".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::Copy"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_Copy_for_move_core_types_state_VMState.
  
  Module Impl_core_fmt_Debug_for_move_core_types_state_VMState.
    Definition Self : Ty.t := Ty.path "move_core_types::state::VMState".
    
    (* Debug *)
    Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_str", [] |),
            [
              M.read (| f |);
              M.read (|
                M.match_operator (|
                  self,
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "DESERIALIZER" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "VERIFIER" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "RUNTIME" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "OTHER" |) |)))
                  ]
                |)
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_move_core_types_state_VMState.
  
  Module Impl_core_marker_StructuralPartialEq_for_move_core_types_state_VMState.
    Definition Self : Ty.t := Ty.path "move_core_types::state::VMState".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_move_core_types_state_VMState.
  
  Module Impl_core_cmp_PartialEq_for_move_core_types_state_VMState.
    Definition Self : Ty.t := Ty.path "move_core_types::state::VMState".
    
    (* PartialEq *)
    Definition eq (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            let __self_tag :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [ Ty.path "move_core_types::state::VMState" ]
                  |),
                  [ M.read (| self |) ]
                |)
              |) in
            let __arg1_tag :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [ Ty.path "move_core_types::state::VMState" ]
                  |),
                  [ M.read (| other |) ]
                |)
              |) in
            M.alloc (| BinOp.Pure.eq (M.read (| __self_tag |)) (M.read (| __arg1_tag |)) |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_for_move_core_types_state_VMState.
  
  Module Impl_core_marker_StructuralEq_for_move_core_types_state_VMState.
    Definition Self : Ty.t := Ty.path "move_core_types::state::VMState".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralEq_for_move_core_types_state_VMState.
  
  Module Impl_core_cmp_Eq_for_move_core_types_state_VMState.
    Definition Self : Ty.t := Ty.path "move_core_types::state::VMState".
    
    (* Eq *)
    Definition assert_receiver_is_total_eq (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.Tuple []))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_move_core_types_state_VMState.
  
  Definition value_STATE : Value.t :=
    M.run
      ltac:(M.monadic
        (M.alloc (|
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply
                (Ty.path "std::thread::local::LocalKey")
                [
                  Ty.apply
                    (Ty.path "core::cell::RefCell")
                    [ Ty.path "move_core_types::state::VMState" ]
                ],
              "new",
              []
            |),
            [
              (* ReifyFnPointer *)
              M.pointer_coercion
                (M.read (| (* Unimplemented parent_kind *) M.alloc (| Value.Tuple [] |) |))
            ]
          |)
        |))).
  
  Module STATE.
    (*             fn __init() -> $t { $init } *)
    Definition __init (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [] =>
        ltac:(M.monadic
          (M.call_closure (|
            M.get_associated_function (|
              Ty.apply
                (Ty.path "core::cell::RefCell")
                [ Ty.path "move_core_types::state::VMState" ],
              "new",
              []
            |),
            [ Value.StructTuple "move_core_types::state::VMState::OTHER" [] ]
          |)))
      | _, _ => M.impossible
      end.
    
    (*
                unsafe fn __getit(
                    init: $crate::option::Option<&mut $crate::option::Option<$t>>,
                ) -> $crate::option::Option<&'static $t> {
                    #[thread_local]
                    static __KEY: $crate::thread::local_impl::Key<$t> =
                        $crate::thread::local_impl::Key::<$t>::new();
    
                    unsafe {
                        __KEY.get(move || {
                            if let $crate::option::Option::Some(init) = init {
                                if let $crate::option::Option::Some(value) = init.take() {
                                    return value;
                                } else if $crate::cfg!(debug_assertions) {
                                    $crate::unreachable!("missing default value");
                                }
                            }
                            __init()
                        })
                    }
                }
    *)
    Definition __getit (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ init ] =>
        ltac:(M.monadic
          (let init := M.alloc (| init |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply
                (Ty.path "std::sys::common::thread_local::fast_local::Key")
                [
                  Ty.apply
                    (Ty.path "core::cell::RefCell")
                    [ Ty.path "move_core_types::state::VMState" ]
                ],
              "get",
              [
                Ty.function
                  [ Ty.tuple [] ]
                  (Ty.apply
                    (Ty.path "core::cell::RefCell")
                    [ Ty.path "move_core_types::state::VMState" ])
              ]
            |),
            [
              M.read (| M.get_constant (| "move_core_types::state::STATE::__getit::__KEY" |) |);
              M.closure
                (fun γ =>
                  ltac:(M.monadic
                    match γ with
                    | [ α0 ] =>
                      M.match_operator (|
                        M.alloc (| α0 |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (M.read (|
                                let _ :=
                                  M.match_operator (|
                                    M.alloc (| Value.Tuple [] |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let γ := init in
                                          let γ0_0 :=
                                            M.get_struct_tuple_field_or_break_match (|
                                              γ,
                                              "core::option::Option::Some",
                                              0
                                            |) in
                                          let init := M.copy (| γ0_0 |) in
                                          M.match_operator (|
                                            M.alloc (| Value.Tuple [] |),
                                            [
                                              fun γ =>
                                                ltac:(M.monadic
                                                  (let γ :=
                                                    M.alloc (|
                                                      M.call_closure (|
                                                        M.get_associated_function (|
                                                          Ty.apply
                                                            (Ty.path "core::option::Option")
                                                            [
                                                              Ty.apply
                                                                (Ty.path "core::cell::RefCell")
                                                                [
                                                                  Ty.path
                                                                    "move_core_types::state::VMState"
                                                                ]
                                                            ],
                                                          "take",
                                                          []
                                                        |),
                                                        [ M.read (| init |) ]
                                                      |)
                                                    |) in
                                                  let γ0_0 :=
                                                    M.get_struct_tuple_field_or_break_match (|
                                                      γ,
                                                      "core::option::Option::Some",
                                                      0
                                                    |) in
                                                  let value := M.copy (| γ0_0 |) in
                                                  M.alloc (|
                                                    M.never_to_any (|
                                                      M.read (|
                                                        M.return_ (| M.read (| value |) |)
                                                      |)
                                                    |)
                                                  |)));
                                              fun γ =>
                                                ltac:(M.monadic
                                                  (M.match_operator (|
                                                    M.alloc (| Value.Tuple [] |),
                                                    [
                                                      fun γ =>
                                                        ltac:(M.monadic
                                                          (let γ :=
                                                            M.use (M.alloc (| Value.Bool true |)) in
                                                          let _ :=
                                                            M.is_constant_or_break_match (|
                                                              M.read (| γ |),
                                                              Value.Bool true
                                                            |) in
                                                          M.alloc (|
                                                            M.never_to_any (|
                                                              M.call_closure (|
                                                                M.get_function (|
                                                                  "core::panicking::panic_fmt",
                                                                  []
                                                                |),
                                                                [
                                                                  M.call_closure (|
                                                                    M.get_associated_function (|
                                                                      Ty.path
                                                                        "core::fmt::Arguments",
                                                                      "new_v1",
                                                                      []
                                                                    |),
                                                                    [
                                                                      (* Unsize *)
                                                                      M.pointer_coercion
                                                                        (M.alloc (|
                                                                          Value.Array
                                                                            [
                                                                              M.read (|
                                                                                mk_str
                                                                                  "internal error: entered unreachable code: missing default value"
                                                                              |)
                                                                            ]
                                                                        |));
                                                                      (* Unsize *)
                                                                      M.pointer_coercion
                                                                        (M.alloc (|
                                                                          M.call_closure (|
                                                                            M.get_associated_function (|
                                                                              Ty.path
                                                                                "core::fmt::rt::Argument",
                                                                              "none",
                                                                              []
                                                                            |),
                                                                            []
                                                                          |)
                                                                        |))
                                                                    ]
                                                                  |)
                                                                ]
                                                              |)
                                                            |)
                                                          |)));
                                                      fun γ =>
                                                        ltac:(M.monadic
                                                          (M.alloc (| Value.Tuple [] |)))
                                                    ]
                                                  |)))
                                            ]
                                          |)));
                                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                    ]
                                  |) in
                                M.alloc (|
                                  M.call_closure (|
                                    M.read (|
                                      (* Unimplemented parent_kind *) M.alloc (| Value.Tuple [] |)
                                    |),
                                    []
                                  |)
                                |)
                              |)))
                        ]
                      |)
                    | _ => M.impossible (||)
                    end))
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Module __getit.
      Definition __KEY : Value.t :=
        M.run
          ltac:(M.monadic
            (M.alloc (|
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "std::sys::common::thread_local::fast_local::Key")
                      [
                        Ty.apply
                          (Ty.path "core::cell::RefCell")
                          [ Ty.path "move_core_types::state::VMState" ]
                      ],
                    "new",
                    []
                  |),
                  []
                |)
              |)
            |))).
    End __getit.
  End STATE.
  
  (*
  pub fn set_state(state: VMState) -> VMState {
      STATE.with(|s| s.replace(state))
  }
  *)
  Definition set_state (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ state ] =>
      ltac:(M.monadic
        (let state := M.alloc (| state |) in
        M.call_closure (|
          M.get_associated_function (|
            Ty.apply
              (Ty.path "std::thread::local::LocalKey")
              [
                Ty.apply
                  (Ty.path "core::cell::RefCell")
                  [ Ty.path "move_core_types::state::VMState" ]
              ],
            "with",
            [
              Ty.function
                [
                  Ty.tuple
                    [
                      Ty.apply
                        (Ty.path "&")
                        [
                          Ty.apply
                            (Ty.path "core::cell::RefCell")
                            [ Ty.path "move_core_types::state::VMState" ]
                        ]
                    ]
                ]
                (Ty.path "move_core_types::state::VMState");
              Ty.path "move_core_types::state::VMState"
            ]
          |),
          [
            M.get_constant (| "move_core_types::state::STATE" |);
            M.closure
              (fun γ =>
                ltac:(M.monadic
                  match γ with
                  | [ α0 ] =>
                    M.match_operator (|
                      M.alloc (| α0 |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let s := M.copy (| γ |) in
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "core::cell::RefCell")
                                  [ Ty.path "move_core_types::state::VMState" ],
                                "replace",
                                []
                              |),
                              [ M.read (| s |); M.read (| state |) ]
                            |)))
                      ]
                    |)
                  | _ => M.impossible (||)
                  end))
          ]
        |)))
    | _, _ => M.impossible
    end.
  
  (*
  pub fn get_state() -> VMState {
      STATE.with(|s| *s.borrow())
  }
  *)
  Definition get_state (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [] =>
      ltac:(M.monadic
        (M.call_closure (|
          M.get_associated_function (|
            Ty.apply
              (Ty.path "std::thread::local::LocalKey")
              [
                Ty.apply
                  (Ty.path "core::cell::RefCell")
                  [ Ty.path "move_core_types::state::VMState" ]
              ],
            "with",
            [
              Ty.function
                [
                  Ty.tuple
                    [
                      Ty.apply
                        (Ty.path "&")
                        [
                          Ty.apply
                            (Ty.path "core::cell::RefCell")
                            [ Ty.path "move_core_types::state::VMState" ]
                        ]
                    ]
                ]
                (Ty.path "move_core_types::state::VMState");
              Ty.path "move_core_types::state::VMState"
            ]
          |),
          [
            M.get_constant (| "move_core_types::state::STATE" |);
            M.closure
              (fun γ =>
                ltac:(M.monadic
                  match γ with
                  | [ α0 ] =>
                    M.match_operator (|
                      M.alloc (| α0 |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let s := M.copy (| γ |) in
                            M.read (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::ops::deref::Deref",
                                  Ty.apply
                                    (Ty.path "core::cell::Ref")
                                    [ Ty.path "move_core_types::state::VMState" ],
                                  [],
                                  "deref",
                                  []
                                |),
                                [
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.apply
                                          (Ty.path "core::cell::RefCell")
                                          [ Ty.path "move_core_types::state::VMState" ],
                                        "borrow",
                                        []
                                      |),
                                      [ M.read (| s |) ]
                                    |)
                                  |)
                                ]
                              |)
                            |)))
                      ]
                    |)
                  | _ => M.impossible (||)
                  end))
          ]
        |)))
    | _, _ => M.impossible
    end.
End state.

Module transaction_argument.
  (*
  Enum TransactionArgument
  {
    ty_params := [];
    variants :=
      [
        {
          name := "U8";
          item := StructTuple [ Ty.path "u8" ];
          discriminant := None;
        };
        {
          name := "U64";
          item := StructTuple [ Ty.path "u64" ];
          discriminant := None;
        };
        {
          name := "U128";
          item := StructTuple [ Ty.path "u128" ];
          discriminant := None;
        };
        {
          name := "Address";
          item := StructTuple [ Ty.path "move_core_types::account_address::AccountAddress" ];
          discriminant := None;
        };
        {
          name := "U8Vector";
          item :=
            StructTuple
              [
                Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
              ];
          discriminant := None;
        };
        {
          name := "Bool";
          item := StructTuple [ Ty.path "bool" ];
          discriminant := None;
        };
        {
          name := "U16";
          item := StructTuple [ Ty.path "u16" ];
          discriminant := None;
        };
        {
          name := "U32";
          item := StructTuple [ Ty.path "u32" ];
          discriminant := None;
        };
        {
          name := "U256";
          item := StructTuple [ Ty.path "move_core_types::u256::U256" ];
          discriminant := None;
        }
      ];
  }
  *)
  
  Module Impl_core_clone_Clone_for_move_core_types_transaction_argument_TransactionArgument.
    Definition Self : Ty.t := Ty.path "move_core_types::transaction_argument::TransactionArgument".
    
    (* Clone *)
    Definition clone (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::transaction_argument::TransactionArgument::U8",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_core_types::transaction_argument::TransactionArgument::U8"
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.path "u8",
                              [],
                              "clone",
                              []
                            |),
                            [ M.read (| __self_0 |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::transaction_argument::TransactionArgument::U64",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_core_types::transaction_argument::TransactionArgument::U64"
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.path "u64",
                              [],
                              "clone",
                              []
                            |),
                            [ M.read (| __self_0 |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::transaction_argument::TransactionArgument::U128",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_core_types::transaction_argument::TransactionArgument::U128"
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.path "u128",
                              [],
                              "clone",
                              []
                            |),
                            [ M.read (| __self_0 |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::transaction_argument::TransactionArgument::Address",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_core_types::transaction_argument::TransactionArgument::Address"
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.path "move_core_types::account_address::AccountAddress",
                              [],
                              "clone",
                              []
                            |),
                            [ M.read (| __self_0 |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::transaction_argument::TransactionArgument::U8Vector",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_core_types::transaction_argument::TransactionArgument::U8Vector"
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                              [],
                              "clone",
                              []
                            |),
                            [ M.read (| __self_0 |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::transaction_argument::TransactionArgument::Bool",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_core_types::transaction_argument::TransactionArgument::Bool"
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.path "bool",
                              [],
                              "clone",
                              []
                            |),
                            [ M.read (| __self_0 |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::transaction_argument::TransactionArgument::U16",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_core_types::transaction_argument::TransactionArgument::U16"
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.path "u16",
                              [],
                              "clone",
                              []
                            |),
                            [ M.read (| __self_0 |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::transaction_argument::TransactionArgument::U32",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_core_types::transaction_argument::TransactionArgument::U32"
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.path "u32",
                              [],
                              "clone",
                              []
                            |),
                            [ M.read (| __self_0 |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::transaction_argument::TransactionArgument::U256",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_core_types::transaction_argument::TransactionArgument::U256"
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.path "move_core_types::u256::U256",
                              [],
                              "clone",
                              []
                            |),
                            [ M.read (| __self_0 |) ]
                          |)
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_move_core_types_transaction_argument_TransactionArgument.
  
  Module Impl_core_hash_Hash_for_move_core_types_transaction_argument_TransactionArgument.
    Definition Self : Ty.t := Ty.path "move_core_types::transaction_argument::TransactionArgument".
    
    (* Hash *)
    Definition hash (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ __H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let state := M.alloc (| state |) in
          M.read (|
            let __self_tag :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [ Ty.path "move_core_types::transaction_argument::TransactionArgument" ]
                  |),
                  [ M.read (| self |) ]
                |)
              |) in
            let _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (| "core::hash::Hash", Ty.path "isize", [], "hash", [ __H ] |),
                  [ __self_tag; M.read (| state |) ]
                |)
              |) in
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::transaction_argument::TransactionArgument::U8",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.path "u8",
                          [],
                          "hash",
                          [ __H ]
                        |),
                        [ M.read (| __self_0 |); M.read (| state |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::transaction_argument::TransactionArgument::U64",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.path "u64",
                          [],
                          "hash",
                          [ __H ]
                        |),
                        [ M.read (| __self_0 |); M.read (| state |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::transaction_argument::TransactionArgument::U128",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.path "u128",
                          [],
                          "hash",
                          [ __H ]
                        |),
                        [ M.read (| __self_0 |); M.read (| state |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::transaction_argument::TransactionArgument::Address",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.path "move_core_types::account_address::AccountAddress",
                          [],
                          "hash",
                          [ __H ]
                        |),
                        [ M.read (| __self_0 |); M.read (| state |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::transaction_argument::TransactionArgument::U8Vector",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                          [],
                          "hash",
                          [ __H ]
                        |),
                        [ M.read (| __self_0 |); M.read (| state |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::transaction_argument::TransactionArgument::Bool",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.path "bool",
                          [],
                          "hash",
                          [ __H ]
                        |),
                        [ M.read (| __self_0 |); M.read (| state |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::transaction_argument::TransactionArgument::U16",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.path "u16",
                          [],
                          "hash",
                          [ __H ]
                        |),
                        [ M.read (| __self_0 |); M.read (| state |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::transaction_argument::TransactionArgument::U32",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.path "u32",
                          [],
                          "hash",
                          [ __H ]
                        |),
                        [ M.read (| __self_0 |); M.read (| state |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::transaction_argument::TransactionArgument::U256",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.path "move_core_types::u256::U256",
                          [],
                          "hash",
                          [ __H ]
                        |),
                        [ M.read (| __self_0 |); M.read (| state |) ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::hash::Hash"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("hash", InstanceField.Method hash) ].
  End Impl_core_hash_Hash_for_move_core_types_transaction_argument_TransactionArgument.
  
  Module Impl_core_marker_StructuralEq_for_move_core_types_transaction_argument_TransactionArgument.
    Definition Self : Ty.t := Ty.path "move_core_types::transaction_argument::TransactionArgument".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralEq_for_move_core_types_transaction_argument_TransactionArgument.
  
  Module Impl_core_cmp_Eq_for_move_core_types_transaction_argument_TransactionArgument.
    Definition Self : Ty.t := Ty.path "move_core_types::transaction_argument::TransactionArgument".
    
    (* Eq *)
    Definition assert_receiver_is_total_eq (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Value.DeclaredButUndefined,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      Value.DeclaredButUndefined,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              Value.DeclaredButUndefined,
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (M.match_operator (|
                                      Value.DeclaredButUndefined,
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (M.match_operator (|
                                              Value.DeclaredButUndefined,
                                              [
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (M.match_operator (|
                                                      Value.DeclaredButUndefined,
                                                      [
                                                        fun γ =>
                                                          ltac:(M.monadic
                                                            (M.match_operator (|
                                                              Value.DeclaredButUndefined,
                                                              [
                                                                fun γ =>
                                                                  ltac:(M.monadic
                                                                    (M.match_operator (|
                                                                      Value.DeclaredButUndefined,
                                                                      [
                                                                        fun γ =>
                                                                          ltac:(M.monadic
                                                                            (M.match_operator (|
                                                                              Value.DeclaredButUndefined,
                                                                              [
                                                                                fun γ =>
                                                                                  ltac:(M.monadic
                                                                                    (M.alloc (|
                                                                                      Value.Tuple []
                                                                                    |)))
                                                                              ]
                                                                            |)))
                                                                      ]
                                                                    |)))
                                                              ]
                                                            |)))
                                                      ]
                                                    |)))
                                              ]
                                            |)))
                                      ]
                                    |)))
                              ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_move_core_types_transaction_argument_TransactionArgument.
  
  Module Impl_core_marker_StructuralPartialEq_for_move_core_types_transaction_argument_TransactionArgument.
    Definition Self : Ty.t := Ty.path "move_core_types::transaction_argument::TransactionArgument".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_move_core_types_transaction_argument_TransactionArgument.
  
  Module Impl_core_cmp_PartialEq_for_move_core_types_transaction_argument_TransactionArgument.
    Definition Self : Ty.t := Ty.path "move_core_types::transaction_argument::TransactionArgument".
    
    (* PartialEq *)
    Definition eq (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            let __self_tag :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [ Ty.path "move_core_types::transaction_argument::TransactionArgument" ]
                  |),
                  [ M.read (| self |) ]
                |)
              |) in
            let __arg1_tag :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [ Ty.path "move_core_types::transaction_argument::TransactionArgument" ]
                  |),
                  [ M.read (| other |) ]
                |)
              |) in
            M.alloc (|
              LogicalOp.and (|
                BinOp.Pure.eq (M.read (| __self_tag |)) (M.read (| __arg1_tag |)),
                ltac:(M.monadic
                  (M.read (|
                    M.match_operator (|
                      M.alloc (| Value.Tuple [ M.read (| self |); M.read (| other |) ] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.get_tuple_field γ 0 in
                            let γ0_1 := M.get_tuple_field γ 1 in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ0_0,
                                "move_core_types::transaction_argument::TransactionArgument::U8",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ0_1,
                                "move_core_types::transaction_argument::TransactionArgument::U8",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              BinOp.Pure.eq
                                (M.read (| M.read (| __self_0 |) |))
                                (M.read (| M.read (| __arg1_0 |) |))
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.get_tuple_field γ 0 in
                            let γ0_1 := M.get_tuple_field γ 1 in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ0_0,
                                "move_core_types::transaction_argument::TransactionArgument::U64",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ0_1,
                                "move_core_types::transaction_argument::TransactionArgument::U64",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              BinOp.Pure.eq
                                (M.read (| M.read (| __self_0 |) |))
                                (M.read (| M.read (| __arg1_0 |) |))
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.get_tuple_field γ 0 in
                            let γ0_1 := M.get_tuple_field γ 1 in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ0_0,
                                "move_core_types::transaction_argument::TransactionArgument::U128",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ0_1,
                                "move_core_types::transaction_argument::TransactionArgument::U128",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              BinOp.Pure.eq
                                (M.read (| M.read (| __self_0 |) |))
                                (M.read (| M.read (| __arg1_0 |) |))
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.get_tuple_field γ 0 in
                            let γ0_1 := M.get_tuple_field γ 1 in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ0_0,
                                "move_core_types::transaction_argument::TransactionArgument::Address",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ0_1,
                                "move_core_types::transaction_argument::TransactionArgument::Address",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.path "move_core_types::account_address::AccountAddress",
                                  [ Ty.path "move_core_types::account_address::AccountAddress" ],
                                  "eq",
                                  []
                                |),
                                [ M.read (| __self_0 |); M.read (| __arg1_0 |) ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.get_tuple_field γ 0 in
                            let γ0_1 := M.get_tuple_field γ 1 in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ0_0,
                                "move_core_types::transaction_argument::TransactionArgument::U8Vector",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ0_1,
                                "move_core_types::transaction_argument::TransactionArgument::U8Vector",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.apply
                                    (Ty.path "alloc::vec::Vec")
                                    [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                                  [
                                    Ty.apply
                                      (Ty.path "alloc::vec::Vec")
                                      [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                                  ],
                                  "eq",
                                  []
                                |),
                                [ M.read (| __self_0 |); M.read (| __arg1_0 |) ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.get_tuple_field γ 0 in
                            let γ0_1 := M.get_tuple_field γ 1 in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ0_0,
                                "move_core_types::transaction_argument::TransactionArgument::Bool",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ0_1,
                                "move_core_types::transaction_argument::TransactionArgument::Bool",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              BinOp.Pure.eq
                                (M.read (| M.read (| __self_0 |) |))
                                (M.read (| M.read (| __arg1_0 |) |))
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.get_tuple_field γ 0 in
                            let γ0_1 := M.get_tuple_field γ 1 in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ0_0,
                                "move_core_types::transaction_argument::TransactionArgument::U16",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ0_1,
                                "move_core_types::transaction_argument::TransactionArgument::U16",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              BinOp.Pure.eq
                                (M.read (| M.read (| __self_0 |) |))
                                (M.read (| M.read (| __arg1_0 |) |))
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.get_tuple_field γ 0 in
                            let γ0_1 := M.get_tuple_field γ 1 in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ0_0,
                                "move_core_types::transaction_argument::TransactionArgument::U32",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ0_1,
                                "move_core_types::transaction_argument::TransactionArgument::U32",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              BinOp.Pure.eq
                                (M.read (| M.read (| __self_0 |) |))
                                (M.read (| M.read (| __arg1_0 |) |))
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.get_tuple_field γ 0 in
                            let γ0_1 := M.get_tuple_field γ 1 in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ0_0,
                                "move_core_types::transaction_argument::TransactionArgument::U256",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ0_1,
                                "move_core_types::transaction_argument::TransactionArgument::U256",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.path "move_core_types::u256::U256",
                                  [ Ty.path "move_core_types::u256::U256" ],
                                  "eq",
                                  []
                                |),
                                [ M.read (| __self_0 |); M.read (| __arg1_0 |) ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              M.never_to_any (|
                                M.call_closure (|
                                  M.get_function (| "core::intrinsics::unreachable", [] |),
                                  []
                                |)
                              |)
                            |)))
                      ]
                    |)
                  |)))
              |)
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_for_move_core_types_transaction_argument_TransactionArgument.
  
  Module underscore.
    Module Impl_serde_ser_Serialize_for_move_core_types_transaction_argument_TransactionArgument.
      Definition Self : Ty.t :=
        Ty.path "move_core_types::transaction_argument::TransactionArgument".
      
      (* Serialize *)
      Definition serialize (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ __S ], [ self; __serializer ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let __serializer := M.alloc (| __serializer |) in
            M.read (|
              M.match_operator (|
                M.read (| self |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.get_struct_tuple_field_or_break_match (|
                          γ,
                          "move_core_types::transaction_argument::TransactionArgument::U8",
                          0
                        |) in
                      let __field0 := M.alloc (| γ0_0 |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "serde::ser::Serializer",
                            __S,
                            [],
                            "serialize_newtype_variant",
                            [ Ty.path "u8" ]
                          |),
                          [
                            M.read (| __serializer |);
                            M.read (| mk_str "TransactionArgument" |);
                            Value.Integer Integer.U32 0;
                            M.read (| mk_str "U8" |);
                            M.read (| __field0 |)
                          ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.get_struct_tuple_field_or_break_match (|
                          γ,
                          "move_core_types::transaction_argument::TransactionArgument::U64",
                          0
                        |) in
                      let __field0 := M.alloc (| γ0_0 |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "serde::ser::Serializer",
                            __S,
                            [],
                            "serialize_newtype_variant",
                            [ Ty.path "u64" ]
                          |),
                          [
                            M.read (| __serializer |);
                            M.read (| mk_str "TransactionArgument" |);
                            Value.Integer Integer.U32 1;
                            M.read (| mk_str "U64" |);
                            M.read (| __field0 |)
                          ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.get_struct_tuple_field_or_break_match (|
                          γ,
                          "move_core_types::transaction_argument::TransactionArgument::U128",
                          0
                        |) in
                      let __field0 := M.alloc (| γ0_0 |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "serde::ser::Serializer",
                            __S,
                            [],
                            "serialize_newtype_variant",
                            [ Ty.path "u128" ]
                          |),
                          [
                            M.read (| __serializer |);
                            M.read (| mk_str "TransactionArgument" |);
                            Value.Integer Integer.U32 2;
                            M.read (| mk_str "U128" |);
                            M.read (| __field0 |)
                          ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.get_struct_tuple_field_or_break_match (|
                          γ,
                          "move_core_types::transaction_argument::TransactionArgument::Address",
                          0
                        |) in
                      let __field0 := M.alloc (| γ0_0 |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "serde::ser::Serializer",
                            __S,
                            [],
                            "serialize_newtype_variant",
                            [ Ty.path "move_core_types::account_address::AccountAddress" ]
                          |),
                          [
                            M.read (| __serializer |);
                            M.read (| mk_str "TransactionArgument" |);
                            Value.Integer Integer.U32 3;
                            M.read (| mk_str "Address" |);
                            M.read (| __field0 |)
                          ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.get_struct_tuple_field_or_break_match (|
                          γ,
                          "move_core_types::transaction_argument::TransactionArgument::U8Vector",
                          0
                        |) in
                      let __field0 := M.alloc (| γ0_0 |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "serde::ser::Serializer",
                            __S,
                            [],
                            "serialize_newtype_variant",
                            [
                              Ty.path
                                "move_core_types::transaction_argument::_::serialize::__SerializeWith"
                            ]
                          |),
                          [
                            M.read (| __serializer |);
                            M.read (| mk_str "TransactionArgument" |);
                            Value.Integer Integer.U32 4;
                            M.read (| mk_str "U8Vector" |);
                            M.alloc (|
                              Value.StructRecord
                                "move_core_types::transaction_argument::_::serialize::__SerializeWith"
                                [
                                  ("values", Value.Tuple [ M.read (| __field0 |) ]);
                                  ("phantom", Value.StructTuple "core::marker::PhantomData" [])
                                ]
                            |)
                          ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.get_struct_tuple_field_or_break_match (|
                          γ,
                          "move_core_types::transaction_argument::TransactionArgument::Bool",
                          0
                        |) in
                      let __field0 := M.alloc (| γ0_0 |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "serde::ser::Serializer",
                            __S,
                            [],
                            "serialize_newtype_variant",
                            [ Ty.path "bool" ]
                          |),
                          [
                            M.read (| __serializer |);
                            M.read (| mk_str "TransactionArgument" |);
                            Value.Integer Integer.U32 5;
                            M.read (| mk_str "Bool" |);
                            M.read (| __field0 |)
                          ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.get_struct_tuple_field_or_break_match (|
                          γ,
                          "move_core_types::transaction_argument::TransactionArgument::U16",
                          0
                        |) in
                      let __field0 := M.alloc (| γ0_0 |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "serde::ser::Serializer",
                            __S,
                            [],
                            "serialize_newtype_variant",
                            [ Ty.path "u16" ]
                          |),
                          [
                            M.read (| __serializer |);
                            M.read (| mk_str "TransactionArgument" |);
                            Value.Integer Integer.U32 6;
                            M.read (| mk_str "U16" |);
                            M.read (| __field0 |)
                          ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.get_struct_tuple_field_or_break_match (|
                          γ,
                          "move_core_types::transaction_argument::TransactionArgument::U32",
                          0
                        |) in
                      let __field0 := M.alloc (| γ0_0 |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "serde::ser::Serializer",
                            __S,
                            [],
                            "serialize_newtype_variant",
                            [ Ty.path "u32" ]
                          |),
                          [
                            M.read (| __serializer |);
                            M.read (| mk_str "TransactionArgument" |);
                            Value.Integer Integer.U32 7;
                            M.read (| mk_str "U32" |);
                            M.read (| __field0 |)
                          ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.get_struct_tuple_field_or_break_match (|
                          γ,
                          "move_core_types::transaction_argument::TransactionArgument::U256",
                          0
                        |) in
                      let __field0 := M.alloc (| γ0_0 |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "serde::ser::Serializer",
                            __S,
                            [],
                            "serialize_newtype_variant",
                            [ Ty.path "move_core_types::u256::U256" ]
                          |),
                          [
                            M.read (| __serializer |);
                            M.read (| mk_str "TransactionArgument" |);
                            Value.Integer Integer.U32 8;
                            M.read (| mk_str "U256" |);
                            M.read (| __field0 |)
                          ]
                        |)
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "serde::ser::Serialize"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("serialize", InstanceField.Method serialize) ].
    End Impl_serde_ser_Serialize_for_move_core_types_transaction_argument_TransactionArgument.
  End underscore.
  
  Module Wrap_underscore_2.
  Module underscore.
    Module Impl_serde_de_Deserialize_for_move_core_types_transaction_argument_TransactionArgument.
      Definition Self : Ty.t :=
        Ty.path "move_core_types::transaction_argument::TransactionArgument".
      
      (* Deserialize *)
      Definition deserialize (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ __D ], [ __deserializer ] =>
          ltac:(M.monadic
            (let __deserializer := M.alloc (| __deserializer |) in
            M.call_closure (|
              M.get_trait_method (|
                "serde::de::Deserializer",
                __D,
                [],
                "deserialize_enum",
                [ Ty.path "move_core_types::transaction_argument::_'1::deserialize::__Visitor" ]
              |),
              [
                M.read (| __deserializer |);
                M.read (| mk_str "TransactionArgument" |);
                M.read (|
                  M.get_constant (|
                    "move_core_types::transaction_argument::_'1::deserialize::VARIANTS"
                  |)
                |);
                Value.StructRecord
                  "move_core_types::transaction_argument::_'1::deserialize::__Visitor"
                  [
                    ("marker", Value.StructTuple "core::marker::PhantomData" []);
                    ("lifetime", Value.StructTuple "core::marker::PhantomData" [])
                  ]
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "serde::de::Deserialize"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("deserialize", InstanceField.Method deserialize) ].
    End Impl_serde_de_Deserialize_for_move_core_types_transaction_argument_TransactionArgument.
  End underscore.
  End Wrap_underscore_2.
  Import Wrap_underscore_2.
  
  Module Impl_core_fmt_Debug_for_move_core_types_transaction_argument_TransactionArgument.
    Definition Self : Ty.t := Ty.path "move_core_types::transaction_argument::TransactionArgument".
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            match self {
                TransactionArgument::U8(value) => write!(f, "{{U8: {}}}", value),
                TransactionArgument::U64(value) => write!(f, "{{U64: {}}}", value),
                TransactionArgument::U128(value) => write!(f, "{{U128: {}}}", value),
                TransactionArgument::Bool(boolean) => write!(f, "{{BOOL: {}}}", boolean),
                TransactionArgument::Address(address) => write!(f, "{{ADDRESS: {:?}}}", address),
                TransactionArgument::U8Vector(vector) => {
                    write!(f, "{{U8Vector: 0x{}}}", hex::encode(vector))
                }
                TransactionArgument::U16(value) => write!(f, "{{U16: {}}}", value),
                TransactionArgument::U32(value) => write!(f, "{{U32: {}}}", value),
                TransactionArgument::U256(value) => write!(f, "{{U256: {}}}", value),
            }
        }
    *)
    Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::transaction_argument::TransactionArgument::U8",
                        0
                      |) in
                    let value := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_v1",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [ M.read (| mk_str "{U8: " |); M.read (| mk_str "}" |) ]
                                |));
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.path "core::fmt::rt::Argument",
                                          "new_display",
                                          [ Ty.apply (Ty.path "&") [ Ty.path "u8" ] ]
                                        |),
                                        [ value ]
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::transaction_argument::TransactionArgument::U64",
                        0
                      |) in
                    let value := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_v1",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [ M.read (| mk_str "{U64: " |); M.read (| mk_str "}" |) ]
                                |));
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.path "core::fmt::rt::Argument",
                                          "new_display",
                                          [ Ty.apply (Ty.path "&") [ Ty.path "u64" ] ]
                                        |),
                                        [ value ]
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::transaction_argument::TransactionArgument::U128",
                        0
                      |) in
                    let value := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_v1",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [ M.read (| mk_str "{U128: " |); M.read (| mk_str "}" |) ]
                                |));
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.path "core::fmt::rt::Argument",
                                          "new_display",
                                          [ Ty.apply (Ty.path "&") [ Ty.path "u128" ] ]
                                        |),
                                        [ value ]
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::transaction_argument::TransactionArgument::Bool",
                        0
                      |) in
                    let boolean := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_v1",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [ M.read (| mk_str "{BOOL: " |); M.read (| mk_str "}" |) ]
                                |));
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.path "core::fmt::rt::Argument",
                                          "new_display",
                                          [ Ty.apply (Ty.path "&") [ Ty.path "bool" ] ]
                                        |),
                                        [ boolean ]
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::transaction_argument::TransactionArgument::Address",
                        0
                      |) in
                    let address := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_v1",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [ M.read (| mk_str "{ADDRESS: " |); M.read (| mk_str "}" |) ]
                                |));
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.path "core::fmt::rt::Argument",
                                          "new_debug",
                                          [
                                            Ty.apply
                                              (Ty.path "&")
                                              [
                                                Ty.path
                                                  "move_core_types::account_address::AccountAddress"
                                              ]
                                          ]
                                        |),
                                        [ address ]
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::transaction_argument::TransactionArgument::U8Vector",
                        0
                      |) in
                    let vector := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_v1",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [ M.read (| mk_str "{U8Vector: 0x" |); M.read (| mk_str "}" |) ]
                                |));
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.path "core::fmt::rt::Argument",
                                          "new_display",
                                          [ Ty.path "alloc::string::String" ]
                                        |),
                                        [
                                          M.alloc (|
                                            M.call_closure (|
                                              M.get_function (|
                                                "hex::encode",
                                                [
                                                  Ty.apply
                                                    (Ty.path "&")
                                                    [
                                                      Ty.apply
                                                        (Ty.path "alloc::vec::Vec")
                                                        [
                                                          Ty.path "u8";
                                                          Ty.path "alloc::alloc::Global"
                                                        ]
                                                    ]
                                                ]
                                              |),
                                              [ M.read (| vector |) ]
                                            |)
                                          |)
                                        ]
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::transaction_argument::TransactionArgument::U16",
                        0
                      |) in
                    let value := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_v1",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [ M.read (| mk_str "{U16: " |); M.read (| mk_str "}" |) ]
                                |));
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.path "core::fmt::rt::Argument",
                                          "new_display",
                                          [ Ty.apply (Ty.path "&") [ Ty.path "u16" ] ]
                                        |),
                                        [ value ]
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::transaction_argument::TransactionArgument::U32",
                        0
                      |) in
                    let value := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_v1",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [ M.read (| mk_str "{U32: " |); M.read (| mk_str "}" |) ]
                                |));
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.path "core::fmt::rt::Argument",
                                          "new_display",
                                          [ Ty.apply (Ty.path "&") [ Ty.path "u32" ] ]
                                        |),
                                        [ value ]
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::transaction_argument::TransactionArgument::U256",
                        0
                      |) in
                    let value := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_v1",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [ M.read (| mk_str "{U256: " |); M.read (| mk_str "}" |) ]
                                |));
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.path "core::fmt::rt::Argument",
                                          "new_display",
                                          [
                                            Ty.apply
                                              (Ty.path "&")
                                              [ Ty.path "move_core_types::u256::U256" ]
                                          ]
                                        |),
                                        [ value ]
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_move_core_types_transaction_argument_TransactionArgument.
  
  Module Impl_core_convert_From_move_core_types_transaction_argument_TransactionArgument_for_move_core_types_value_MoveValue.
    Definition Self : Ty.t := Ty.path "move_core_types::value::MoveValue".
    
    (*
        fn from(val: TransactionArgument) -> Self {
            match val {
                TransactionArgument::U8(i) => MoveValue::U8(i),
                TransactionArgument::U64(i) => MoveValue::U64(i),
                TransactionArgument::U128(i) => MoveValue::U128(i),
                TransactionArgument::Address(a) => MoveValue::Address(a),
                TransactionArgument::Bool(b) => MoveValue::Bool(b),
                TransactionArgument::U8Vector(v) => MoveValue::vector_u8(v),
                TransactionArgument::U16(i) => MoveValue::U16(i),
                TransactionArgument::U32(i) => MoveValue::U32(i),
                TransactionArgument::U256(i) => MoveValue::U256(i),
            }
        }
    *)
    Definition from (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ val ] =>
        ltac:(M.monadic
          (let val := M.alloc (| val |) in
          M.read (|
            M.match_operator (|
              val,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::transaction_argument::TransactionArgument::U8",
                        0
                      |) in
                    let i := M.copy (| γ0_0 |) in
                    M.alloc (|
                      Value.StructTuple "move_core_types::value::MoveValue::U8" [ M.read (| i |) ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::transaction_argument::TransactionArgument::U64",
                        0
                      |) in
                    let i := M.copy (| γ0_0 |) in
                    M.alloc (|
                      Value.StructTuple "move_core_types::value::MoveValue::U64" [ M.read (| i |) ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::transaction_argument::TransactionArgument::U128",
                        0
                      |) in
                    let i := M.copy (| γ0_0 |) in
                    M.alloc (|
                      Value.StructTuple "move_core_types::value::MoveValue::U128" [ M.read (| i |) ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::transaction_argument::TransactionArgument::Address",
                        0
                      |) in
                    let a := M.copy (| γ0_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_core_types::value::MoveValue::Address"
                        [ M.read (| a |) ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::transaction_argument::TransactionArgument::Bool",
                        0
                      |) in
                    let b := M.copy (| γ0_0 |) in
                    M.alloc (|
                      Value.StructTuple "move_core_types::value::MoveValue::Bool" [ M.read (| b |) ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::transaction_argument::TransactionArgument::U8Vector",
                        0
                      |) in
                    let v := M.copy (| γ0_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "move_core_types::value::MoveValue",
                          "vector_u8",
                          []
                        |),
                        [ M.read (| v |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::transaction_argument::TransactionArgument::U16",
                        0
                      |) in
                    let i := M.copy (| γ0_0 |) in
                    M.alloc (|
                      Value.StructTuple "move_core_types::value::MoveValue::U16" [ M.read (| i |) ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::transaction_argument::TransactionArgument::U32",
                        0
                      |) in
                    let i := M.copy (| γ0_0 |) in
                    M.alloc (|
                      Value.StructTuple "move_core_types::value::MoveValue::U32" [ M.read (| i |) ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::transaction_argument::TransactionArgument::U256",
                        0
                      |) in
                    let i := M.copy (| γ0_0 |) in
                    M.alloc (|
                      Value.StructTuple "move_core_types::value::MoveValue::U256" [ M.read (| i |) ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::convert::From"
        Self
        (* Trait polymorphic types *)
        [ (* T *) Ty.path "move_core_types::transaction_argument::TransactionArgument" ]
        (* Instance *) [ ("from", InstanceField.Method from) ].
  End Impl_core_convert_From_move_core_types_transaction_argument_TransactionArgument_for_move_core_types_value_MoveValue.
  
  Module Impl_core_convert_TryFrom_move_core_types_value_MoveValue_for_move_core_types_transaction_argument_TransactionArgument.
    Definition Self : Ty.t := Ty.path "move_core_types::transaction_argument::TransactionArgument".
    
    (*     type Error = Error; *)
    Definition _Error : Ty.t := Ty.path "anyhow::Error".
    
    (*
        fn try_from(val: MoveValue) -> Result<Self> {
            Ok(match val {
                MoveValue::U8(i) => TransactionArgument::U8(i),
                MoveValue::U64(i) => TransactionArgument::U64(i),
                MoveValue::U128(i) => TransactionArgument::U128(i),
                MoveValue::Address(a) => TransactionArgument::Address(a),
                MoveValue::Bool(b) => TransactionArgument::Bool(b),
                MoveValue::Vector(v) => TransactionArgument::U8Vector(
                    v.into_iter()
                        .map(|mv| {
                            if let MoveValue::U8(byte) = mv {
                                Ok(byte)
                            } else {
                                Err(anyhow!("unexpected value in bytes: {:?}", mv))
                            }
                        })
                        .collect::<Result<Vec<u8>>>()?,
                ),
                MoveValue::Signer(_) | MoveValue::Struct(_) => {
                    return Err(anyhow!("invalid transaction argument: {:?}", val))
                }
                MoveValue::U16(i) => TransactionArgument::U16(i),
                MoveValue::U32(i) => TransactionArgument::U32(i),
                MoveValue::U256(i) => TransactionArgument::U256(i),
            })
        }
    *)
    Definition try_from (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ val ] =>
        ltac:(M.monadic
          (let val := M.alloc (| val |) in
          Value.StructTuple
            "core::result::Result::Ok"
            [
              M.read (|
                M.match_operator (|
                  val,
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.get_struct_tuple_field_or_break_match (|
                            γ,
                            "move_core_types::value::MoveValue::U8",
                            0
                          |) in
                        let i := M.copy (| γ0_0 |) in
                        M.alloc (|
                          Value.StructTuple
                            "move_core_types::transaction_argument::TransactionArgument::U8"
                            [ M.read (| i |) ]
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.get_struct_tuple_field_or_break_match (|
                            γ,
                            "move_core_types::value::MoveValue::U64",
                            0
                          |) in
                        let i := M.copy (| γ0_0 |) in
                        M.alloc (|
                          Value.StructTuple
                            "move_core_types::transaction_argument::TransactionArgument::U64"
                            [ M.read (| i |) ]
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.get_struct_tuple_field_or_break_match (|
                            γ,
                            "move_core_types::value::MoveValue::U128",
                            0
                          |) in
                        let i := M.copy (| γ0_0 |) in
                        M.alloc (|
                          Value.StructTuple
                            "move_core_types::transaction_argument::TransactionArgument::U128"
                            [ M.read (| i |) ]
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.get_struct_tuple_field_or_break_match (|
                            γ,
                            "move_core_types::value::MoveValue::Address",
                            0
                          |) in
                        let a := M.copy (| γ0_0 |) in
                        M.alloc (|
                          Value.StructTuple
                            "move_core_types::transaction_argument::TransactionArgument::Address"
                            [ M.read (| a |) ]
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.get_struct_tuple_field_or_break_match (|
                            γ,
                            "move_core_types::value::MoveValue::Bool",
                            0
                          |) in
                        let b := M.copy (| γ0_0 |) in
                        M.alloc (|
                          Value.StructTuple
                            "move_core_types::transaction_argument::TransactionArgument::Bool"
                            [ M.read (| b |) ]
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.get_struct_tuple_field_or_break_match (|
                            γ,
                            "move_core_types::value::MoveValue::Vector",
                            0
                          |) in
                        let v := M.copy (| γ0_0 |) in
                        M.alloc (|
                          Value.StructTuple
                            "move_core_types::transaction_argument::TransactionArgument::U8Vector"
                            [
                              M.read (|
                                M.match_operator (|
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::ops::try_trait::Try",
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          [
                                            Ty.apply
                                              (Ty.path "alloc::vec::Vec")
                                              [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ];
                                            Ty.path "anyhow::Error"
                                          ],
                                        [],
                                        "branch",
                                        []
                                      |),
                                      [
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::iter::traits::iterator::Iterator",
                                            Ty.apply
                                              (Ty.path "core::iter::adapters::map::Map")
                                              [
                                                Ty.apply
                                                  (Ty.path "alloc::vec::into_iter::IntoIter")
                                                  [
                                                    Ty.path "move_core_types::value::MoveValue";
                                                    Ty.path "alloc::alloc::Global"
                                                  ];
                                                Ty.function
                                                  [
                                                    Ty.tuple
                                                      [ Ty.path "move_core_types::value::MoveValue"
                                                      ]
                                                  ]
                                                  (Ty.apply
                                                    (Ty.path "core::result::Result")
                                                    [ Ty.path "u8"; Ty.path "anyhow::Error" ])
                                              ],
                                            [],
                                            "collect",
                                            [
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                [
                                                  Ty.apply
                                                    (Ty.path "alloc::vec::Vec")
                                                    [ Ty.path "u8"; Ty.path "alloc::alloc::Global"
                                                    ];
                                                  Ty.path "anyhow::Error"
                                                ]
                                            ]
                                          |),
                                          [
                                            M.call_closure (|
                                              M.get_trait_method (|
                                                "core::iter::traits::iterator::Iterator",
                                                Ty.apply
                                                  (Ty.path "alloc::vec::into_iter::IntoIter")
                                                  [
                                                    Ty.path "move_core_types::value::MoveValue";
                                                    Ty.path "alloc::alloc::Global"
                                                  ],
                                                [],
                                                "map",
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::result::Result")
                                                    [ Ty.path "u8"; Ty.path "anyhow::Error" ];
                                                  Ty.function
                                                    [
                                                      Ty.tuple
                                                        [
                                                          Ty.path
                                                            "move_core_types::value::MoveValue"
                                                        ]
                                                    ]
                                                    (Ty.apply
                                                      (Ty.path "core::result::Result")
                                                      [ Ty.path "u8"; Ty.path "anyhow::Error" ])
                                                ]
                                              |),
                                              [
                                                M.call_closure (|
                                                  M.get_trait_method (|
                                                    "core::iter::traits::collect::IntoIterator",
                                                    Ty.apply
                                                      (Ty.path "alloc::vec::Vec")
                                                      [
                                                        Ty.path "move_core_types::value::MoveValue";
                                                        Ty.path "alloc::alloc::Global"
                                                      ],
                                                    [],
                                                    "into_iter",
                                                    []
                                                  |),
                                                  [ M.read (| v |) ]
                                                |);
                                                M.closure
                                                  (fun γ =>
                                                    ltac:(M.monadic
                                                      match γ with
                                                      | [ α0 ] =>
                                                        M.match_operator (|
                                                          M.alloc (| α0 |),
                                                          [
                                                            fun γ =>
                                                              ltac:(M.monadic
                                                                (let mv := M.copy (| γ |) in
                                                                M.read (|
                                                                  M.match_operator (|
                                                                    M.alloc (| Value.Tuple [] |),
                                                                    [
                                                                      fun γ =>
                                                                        ltac:(M.monadic
                                                                          (let γ := mv in
                                                                          let γ0_0 :=
                                                                            M.get_struct_tuple_field_or_break_match (|
                                                                              γ,
                                                                              "move_core_types::value::MoveValue::U8",
                                                                              0
                                                                            |) in
                                                                          let byte :=
                                                                            M.copy (| γ0_0 |) in
                                                                          M.alloc (|
                                                                            Value.StructTuple
                                                                              "core::result::Result::Ok"
                                                                              [ M.read (| byte |) ]
                                                                          |)));
                                                                      fun γ =>
                                                                        ltac:(M.monadic
                                                                          (M.alloc (|
                                                                            Value.StructTuple
                                                                              "core::result::Result::Err"
                                                                              [
                                                                                M.call_closure (|
                                                                                  M.get_associated_function (|
                                                                                    Ty.path
                                                                                      "anyhow::Error",
                                                                                    "msg",
                                                                                    [
                                                                                      Ty.path
                                                                                        "alloc::string::String"
                                                                                    ]
                                                                                  |),
                                                                                  [
                                                                                    M.read (|
                                                                                      let res :=
                                                                                        M.alloc (|
                                                                                          M.call_closure (|
                                                                                            M.get_function (|
                                                                                              "alloc::fmt::format",
                                                                                              []
                                                                                            |),
                                                                                            [
                                                                                              M.call_closure (|
                                                                                                M.get_associated_function (|
                                                                                                  Ty.path
                                                                                                    "core::fmt::Arguments",
                                                                                                  "new_v1",
                                                                                                  []
                                                                                                |),
                                                                                                [
                                                                                                  (* Unsize *)
                                                                                                  M.pointer_coercion
                                                                                                    (M.alloc (|
                                                                                                      Value.Array
                                                                                                        [
                                                                                                          M.read (|
                                                                                                            mk_str
                                                                                                              "unexpected value in bytes: "
                                                                                                          |)
                                                                                                        ]
                                                                                                    |));
                                                                                                  (* Unsize *)
                                                                                                  M.pointer_coercion
                                                                                                    (M.alloc (|
                                                                                                      Value.Array
                                                                                                        [
                                                                                                          M.call_closure (|
                                                                                                            M.get_associated_function (|
                                                                                                              Ty.path
                                                                                                                "core::fmt::rt::Argument",
                                                                                                              "new_debug",
                                                                                                              [
                                                                                                                Ty.path
                                                                                                                  "move_core_types::value::MoveValue"
                                                                                                              ]
                                                                                                            |),
                                                                                                            [
                                                                                                              mv
                                                                                                            ]
                                                                                                          |)
                                                                                                        ]
                                                                                                    |))
                                                                                                ]
                                                                                              |)
                                                                                            ]
                                                                                          |)
                                                                                        |) in
                                                                                      res
                                                                                    |)
                                                                                  ]
                                                                                |)
                                                                              ]
                                                                          |)))
                                                                    ]
                                                                  |)
                                                                |)))
                                                          ]
                                                        |)
                                                      | _ => M.impossible (||)
                                                      end))
                                              ]
                                            |)
                                          ]
                                        |)
                                      ]
                                    |)
                                  |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 :=
                                          M.get_struct_tuple_field_or_break_match (|
                                            γ,
                                            "core::ops::control_flow::ControlFlow::Break",
                                            0
                                          |) in
                                        let residual := M.copy (| γ0_0 |) in
                                        M.alloc (|
                                          M.never_to_any (|
                                            M.read (|
                                              M.return_ (|
                                                M.call_closure (|
                                                  M.get_trait_method (|
                                                    "core::ops::try_trait::FromResidual",
                                                    Ty.apply
                                                      (Ty.path "core::result::Result")
                                                      [
                                                        Ty.path
                                                          "move_core_types::transaction_argument::TransactionArgument";
                                                        Ty.path "anyhow::Error"
                                                      ],
                                                    [
                                                      Ty.apply
                                                        (Ty.path "core::result::Result")
                                                        [
                                                          Ty.path "core::convert::Infallible";
                                                          Ty.path "anyhow::Error"
                                                        ]
                                                    ],
                                                    "from_residual",
                                                    []
                                                  |),
                                                  [ M.read (| residual |) ]
                                                |)
                                              |)
                                            |)
                                          |)
                                        |)));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 :=
                                          M.get_struct_tuple_field_or_break_match (|
                                            γ,
                                            "core::ops::control_flow::ControlFlow::Continue",
                                            0
                                          |) in
                                        let val := M.copy (| γ0_0 |) in
                                        val))
                                  ]
                                |)
                              |)
                            ]
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (M.find_or_pattern (|
                          γ,
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.get_struct_tuple_field_or_break_match (|
                                    γ,
                                    "move_core_types::value::MoveValue::Signer",
                                    0
                                  |) in
                                Value.Tuple []));
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.get_struct_tuple_field_or_break_match (|
                                    γ,
                                    "move_core_types::value::MoveValue::Struct",
                                    0
                                  |) in
                                Value.Tuple []))
                          ],
                          M.closure
                            (fun γ =>
                              ltac:(M.monadic
                                match γ with
                                | [] =>
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          Value.StructTuple
                                            "core::result::Result::Err"
                                            [
                                              M.call_closure (|
                                                M.get_associated_function (|
                                                  Ty.path "anyhow::Error",
                                                  "msg",
                                                  [ Ty.path "alloc::string::String" ]
                                                |),
                                                [
                                                  M.read (|
                                                    let res :=
                                                      M.alloc (|
                                                        M.call_closure (|
                                                          M.get_function (|
                                                            "alloc::fmt::format",
                                                            []
                                                          |),
                                                          [
                                                            M.call_closure (|
                                                              M.get_associated_function (|
                                                                Ty.path "core::fmt::Arguments",
                                                                "new_v1",
                                                                []
                                                              |),
                                                              [
                                                                (* Unsize *)
                                                                M.pointer_coercion
                                                                  (M.alloc (|
                                                                    Value.Array
                                                                      [
                                                                        M.read (|
                                                                          mk_str
                                                                            "invalid transaction argument: "
                                                                        |)
                                                                      ]
                                                                  |));
                                                                (* Unsize *)
                                                                M.pointer_coercion
                                                                  (M.alloc (|
                                                                    Value.Array
                                                                      [
                                                                        M.call_closure (|
                                                                          M.get_associated_function (|
                                                                            Ty.path
                                                                              "core::fmt::rt::Argument",
                                                                            "new_debug",
                                                                            [
                                                                              Ty.path
                                                                                "move_core_types::value::MoveValue"
                                                                            ]
                                                                          |),
                                                                          [ val ]
                                                                        |)
                                                                      ]
                                                                  |))
                                                              ]
                                                            |)
                                                          ]
                                                        |)
                                                      |) in
                                                    res
                                                  |)
                                                ]
                                              |)
                                            ]
                                        |)
                                      |)
                                    |)
                                  |)
                                | _ => M.impossible (||)
                                end))
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.get_struct_tuple_field_or_break_match (|
                            γ,
                            "move_core_types::value::MoveValue::U16",
                            0
                          |) in
                        let i := M.copy (| γ0_0 |) in
                        M.alloc (|
                          Value.StructTuple
                            "move_core_types::transaction_argument::TransactionArgument::U16"
                            [ M.read (| i |) ]
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.get_struct_tuple_field_or_break_match (|
                            γ,
                            "move_core_types::value::MoveValue::U32",
                            0
                          |) in
                        let i := M.copy (| γ0_0 |) in
                        M.alloc (|
                          Value.StructTuple
                            "move_core_types::transaction_argument::TransactionArgument::U32"
                            [ M.read (| i |) ]
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.get_struct_tuple_field_or_break_match (|
                            γ,
                            "move_core_types::value::MoveValue::U256",
                            0
                          |) in
                        let i := M.copy (| γ0_0 |) in
                        M.alloc (|
                          Value.StructTuple
                            "move_core_types::transaction_argument::TransactionArgument::U256"
                            [ M.read (| i |) ]
                        |)))
                  ]
                |)
              |)
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::convert::TryFrom"
        Self
        (* Trait polymorphic types *) [ (* T *) Ty.path "move_core_types::value::MoveValue" ]
        (* Instance *)
        [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
  End Impl_core_convert_TryFrom_move_core_types_value_MoveValue_for_move_core_types_transaction_argument_TransactionArgument.
  
  (*
  pub fn convert_txn_args(args: &[TransactionArgument]) -> Vec<Vec<u8>> {
      args.iter()
          .map(|arg| {
              MoveValue::from(arg.clone())
                  .simple_serialize()
                  .expect("transaction arguments must serialize")
          })
          .collect()
  }
  *)
  Definition convert_txn_args (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [], [ args ] =>
      ltac:(M.monadic
        (let args := M.alloc (| args |) in
        M.call_closure (|
          M.get_trait_method (|
            "core::iter::traits::iterator::Iterator",
            Ty.apply
              (Ty.path "core::iter::adapters::map::Map")
              [
                Ty.apply
                  (Ty.path "core::slice::iter::Iter")
                  [ Ty.path "move_core_types::transaction_argument::TransactionArgument" ];
                Ty.function
                  [
                    Ty.tuple
                      [
                        Ty.apply
                          (Ty.path "&")
                          [ Ty.path "move_core_types::transaction_argument::TransactionArgument" ]
                      ]
                  ]
                  (Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ])
              ],
            [],
            "collect",
            [
              Ty.apply
                (Ty.path "alloc::vec::Vec")
                [
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ];
                  Ty.path "alloc::alloc::Global"
                ]
            ]
          |),
          [
            M.call_closure (|
              M.get_trait_method (|
                "core::iter::traits::iterator::Iterator",
                Ty.apply
                  (Ty.path "core::slice::iter::Iter")
                  [ Ty.path "move_core_types::transaction_argument::TransactionArgument" ],
                [],
                "map",
                [
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ];
                  Ty.function
                    [
                      Ty.tuple
                        [
                          Ty.apply
                            (Ty.path "&")
                            [ Ty.path "move_core_types::transaction_argument::TransactionArgument" ]
                        ]
                    ]
                    (Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ])
                ]
              |),
              [
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "slice")
                      [ Ty.path "move_core_types::transaction_argument::TransactionArgument" ],
                    "iter",
                    []
                  |),
                  [ M.read (| args |) ]
                |);
                M.closure
                  (fun γ =>
                    ltac:(M.monadic
                      match γ with
                      | [ α0 ] =>
                        M.match_operator (|
                          M.alloc (| α0 |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let arg := M.copy (| γ |) in
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "core::option::Option")
                                      [
                                        Ty.apply
                                          (Ty.path "alloc::vec::Vec")
                                          [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                                      ],
                                    "expect",
                                    []
                                  |),
                                  [
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.path "move_core_types::value::MoveValue",
                                        "simple_serialize",
                                        []
                                      |),
                                      [
                                        M.alloc (|
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::convert::From",
                                              Ty.path "move_core_types::value::MoveValue",
                                              [
                                                Ty.path
                                                  "move_core_types::transaction_argument::TransactionArgument"
                                              ],
                                              "from",
                                              []
                                            |),
                                            [
                                              M.call_closure (|
                                                M.get_trait_method (|
                                                  "core::clone::Clone",
                                                  Ty.path
                                                    "move_core_types::transaction_argument::TransactionArgument",
                                                  [],
                                                  "clone",
                                                  []
                                                |),
                                                [ M.read (| arg |) ]
                                              |)
                                            ]
                                          |)
                                        |)
                                      ]
                                    |);
                                    M.read (| mk_str "transaction arguments must serialize" |)
                                  ]
                                |)))
                          ]
                        |)
                      | _ => M.impossible (||)
                      end))
              ]
            |)
          ]
        |)))
    | _, _ => M.impossible
    end.
  
  (* StructTuple
    {
      name := "VecBytes";
      ty_params := [];
      fields :=
        [
          Ty.apply
            (Ty.path "alloc::vec::Vec")
            [ Ty.path "serde_bytes::bytebuf::ByteBuf"; Ty.path "alloc::alloc::Global" ]
        ];
    } *)
  
  Module Impl_core_clone_Clone_for_move_core_types_transaction_argument_VecBytes.
    Definition Self : Ty.t := Ty.path "move_core_types::transaction_argument::VecBytes".
    
    (* Clone *)
    Definition clone (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.StructTuple
            "move_core_types::transaction_argument::VecBytes"
            [
              M.call_closure (|
                M.get_trait_method (|
                  "core::clone::Clone",
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    [ Ty.path "serde_bytes::bytebuf::ByteBuf"; Ty.path "alloc::alloc::Global" ],
                  [],
                  "clone",
                  []
                |),
                [
                  M.get_struct_tuple_field
                    (M.read (| self |))
                    "move_core_types::transaction_argument::VecBytes"
                    0
                ]
              |)
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_move_core_types_transaction_argument_VecBytes.
  
  Module Impl_core_hash_Hash_for_move_core_types_transaction_argument_VecBytes.
    Definition Self : Ty.t := Ty.path "move_core_types::transaction_argument::VecBytes".
    
    (* Hash *)
    Definition hash (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ __H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let state := M.alloc (| state |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::hash::Hash",
              Ty.apply
                (Ty.path "alloc::vec::Vec")
                [ Ty.path "serde_bytes::bytebuf::ByteBuf"; Ty.path "alloc::alloc::Global" ],
              [],
              "hash",
              [ __H ]
            |),
            [
              M.get_struct_tuple_field
                (M.read (| self |))
                "move_core_types::transaction_argument::VecBytes"
                0;
              M.read (| state |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::hash::Hash"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("hash", InstanceField.Method hash) ].
  End Impl_core_hash_Hash_for_move_core_types_transaction_argument_VecBytes.
  
  Module Impl_core_marker_StructuralEq_for_move_core_types_transaction_argument_VecBytes.
    Definition Self : Ty.t := Ty.path "move_core_types::transaction_argument::VecBytes".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralEq_for_move_core_types_transaction_argument_VecBytes.
  
  Module Impl_core_cmp_Eq_for_move_core_types_transaction_argument_VecBytes.
    Definition Self : Ty.t := Ty.path "move_core_types::transaction_argument::VecBytes".
    
    (* Eq *)
    Definition assert_receiver_is_total_eq (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Value.DeclaredButUndefined,
              [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_move_core_types_transaction_argument_VecBytes.
  
  Module Impl_core_marker_StructuralPartialEq_for_move_core_types_transaction_argument_VecBytes.
    Definition Self : Ty.t := Ty.path "move_core_types::transaction_argument::VecBytes".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_move_core_types_transaction_argument_VecBytes.
  
  Module Impl_core_cmp_PartialEq_for_move_core_types_transaction_argument_VecBytes.
    Definition Self : Ty.t := Ty.path "move_core_types::transaction_argument::VecBytes".
    
    (* PartialEq *)
    Definition eq (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::cmp::PartialEq",
              Ty.apply
                (Ty.path "alloc::vec::Vec")
                [ Ty.path "serde_bytes::bytebuf::ByteBuf"; Ty.path "alloc::alloc::Global" ],
              [
                Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  [ Ty.path "serde_bytes::bytebuf::ByteBuf"; Ty.path "alloc::alloc::Global" ]
              ],
              "eq",
              []
            |),
            [
              M.get_struct_tuple_field
                (M.read (| self |))
                "move_core_types::transaction_argument::VecBytes"
                0;
              M.get_struct_tuple_field
                (M.read (| other |))
                "move_core_types::transaction_argument::VecBytes"
                0
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_for_move_core_types_transaction_argument_VecBytes.
  
  Module Wrap_underscore_3.
  Module underscore.
    Module Impl_serde_de_Deserialize_for_move_core_types_transaction_argument_VecBytes.
      Definition Self : Ty.t := Ty.path "move_core_types::transaction_argument::VecBytes".
      
      (* Deserialize *)
      Definition deserialize (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ __D ], [ __deserializer ] =>
          ltac:(M.monadic
            (let __deserializer := M.alloc (| __deserializer |) in
            M.call_closure (|
              M.get_trait_method (|
                "serde::de::Deserializer",
                __D,
                [],
                "deserialize_newtype_struct",
                [ Ty.path "move_core_types::transaction_argument::_'2::deserialize::__Visitor" ]
              |),
              [
                M.read (| __deserializer |);
                M.read (| mk_str "VecBytes" |);
                Value.StructRecord
                  "move_core_types::transaction_argument::_'2::deserialize::__Visitor"
                  [
                    ("marker", Value.StructTuple "core::marker::PhantomData" []);
                    ("lifetime", Value.StructTuple "core::marker::PhantomData" [])
                  ]
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "serde::de::Deserialize"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("deserialize", InstanceField.Method deserialize) ].
    End Impl_serde_de_Deserialize_for_move_core_types_transaction_argument_VecBytes.
  End underscore.
  End Wrap_underscore_3.
  Import Wrap_underscore_3.
  
  Module Impl_move_core_types_transaction_argument_VecBytes.
    Definition Self : Ty.t := Ty.path "move_core_types::transaction_argument::VecBytes".
    
    (*
        pub fn from(vec_bytes: Vec<Vec<u8>>) -> Self {
            VecBytes(
                vec_bytes
                    .into_iter()
                    .map(serde_bytes::ByteBuf::from)
                    .collect(),
            )
        }
    *)
    Definition from (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ vec_bytes ] =>
        ltac:(M.monadic
          (let vec_bytes := M.alloc (| vec_bytes |) in
          Value.StructTuple
            "move_core_types::transaction_argument::VecBytes"
            [
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  Ty.apply
                    (Ty.path "core::iter::adapters::map::Map")
                    [
                      Ty.apply
                        (Ty.path "alloc::vec::into_iter::IntoIter")
                        [
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ];
                          Ty.path "alloc::alloc::Global"
                        ];
                      Ty.function
                        [
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                        ]
                        (Ty.path "serde_bytes::bytebuf::ByteBuf")
                    ],
                  [],
                  "collect",
                  [
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      [ Ty.path "serde_bytes::bytebuf::ByteBuf"; Ty.path "alloc::alloc::Global" ]
                  ]
                |),
                [
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::iter::traits::iterator::Iterator",
                      Ty.apply
                        (Ty.path "alloc::vec::into_iter::IntoIter")
                        [
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ];
                          Ty.path "alloc::alloc::Global"
                        ],
                      [],
                      "map",
                      [
                        Ty.path "serde_bytes::bytebuf::ByteBuf";
                        Ty.function
                          [
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                          ]
                          (Ty.path "serde_bytes::bytebuf::ByteBuf")
                      ]
                    |),
                    [
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::iter::traits::collect::IntoIterator",
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            [
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ];
                              Ty.path "alloc::alloc::Global"
                            ],
                          [],
                          "into_iter",
                          []
                        |),
                        [ M.read (| vec_bytes |) ]
                      |);
                      M.get_associated_function (|
                        Ty.path "serde_bytes::bytebuf::ByteBuf",
                        "from",
                        [
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                        ]
                      |)
                    ]
                  |)
                ]
              |)
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_from : M.IsAssociatedFunction Self "from" from.
    
    (*
        pub fn into_vec(self) -> Vec<Vec<u8>> {
            self.0
                .into_iter()
                .map(|byte_buf| byte_buf.into_vec())
                .collect()
        }
    *)
    Definition into_vec (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::iter::traits::iterator::Iterator",
              Ty.apply
                (Ty.path "core::iter::adapters::map::Map")
                [
                  Ty.apply
                    (Ty.path "alloc::vec::into_iter::IntoIter")
                    [ Ty.path "serde_bytes::bytebuf::ByteBuf"; Ty.path "alloc::alloc::Global" ];
                  Ty.function
                    [ Ty.tuple [ Ty.path "serde_bytes::bytebuf::ByteBuf" ] ]
                    (Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ])
                ],
              [],
              "collect",
              [
                Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  [
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ];
                    Ty.path "alloc::alloc::Global"
                  ]
              ]
            |),
            [
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  Ty.apply
                    (Ty.path "alloc::vec::into_iter::IntoIter")
                    [ Ty.path "serde_bytes::bytebuf::ByteBuf"; Ty.path "alloc::alloc::Global" ],
                  [],
                  "map",
                  [
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ];
                    Ty.function
                      [ Ty.tuple [ Ty.path "serde_bytes::bytebuf::ByteBuf" ] ]
                      (Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ])
                  ]
                |),
                [
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::iter::traits::collect::IntoIterator",
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        [ Ty.path "serde_bytes::bytebuf::ByteBuf"; Ty.path "alloc::alloc::Global" ],
                      [],
                      "into_iter",
                      []
                    |),
                    [
                      M.read (|
                        M.get_struct_tuple_field
                          self
                          "move_core_types::transaction_argument::VecBytes"
                          0
                      |)
                    ]
                  |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          M.match_operator (|
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let byte_buf := M.copy (| γ |) in
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.path "serde_bytes::bytebuf::ByteBuf",
                                      "into_vec",
                                      []
                                    |),
                                    [ M.read (| byte_buf |) ]
                                  |)))
                            ]
                          |)
                        | _ => M.impossible (||)
                        end))
                ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_into_vec : M.IsAssociatedFunction Self "into_vec" into_vec.
  End Impl_move_core_types_transaction_argument_VecBytes.
End transaction_argument.

Module u256.
  Definition value_NUM_BITS_PER_BYTE : Value.t :=
    M.run ltac:(M.monadic (M.alloc (| Value.Integer Integer.Usize 8 |))).
  
  Definition value_U256_NUM_BITS : Value.t :=
    M.run ltac:(M.monadic (M.alloc (| Value.Integer Integer.Usize 256 |))).
  
  Definition value_U256_NUM_BYTES : Value.t :=
    M.run
      ltac:(M.monadic
        (M.alloc (|
          BinOp.Panic.div (|
            M.read (| M.get_constant (| "move_core_types::u256::U256_NUM_BITS" |) |),
            M.read (| M.get_constant (| "move_core_types::u256::NUM_BITS_PER_BYTE" |) |)
          |)
        |))).
  
  (* StructTuple
    {
      name := "U256FromStrError";
      ty_params := [];
      fields := [ Ty.path "uint::uint::FromStrRadixErr" ];
    } *)
  
  Module Impl_core_fmt_Debug_for_move_core_types_u256_U256FromStrError.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::U256FromStrError".
    
    (* Debug *)
    Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.path "core::fmt::Formatter",
              "debug_tuple_field1_finish",
              []
            |),
            [
              M.read (| f |);
              M.read (| mk_str "U256FromStrError" |);
              (* Unsize *)
              M.pointer_coercion
                (M.alloc (|
                  M.get_struct_tuple_field
                    (M.read (| self |))
                    "move_core_types::u256::U256FromStrError"
                    0
                |))
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_move_core_types_u256_U256FromStrError.
  
  (*
  Enum U256CastErrorKind
  {
    ty_params := [];
    variants :=
      [
        {
          name := "TooLargeForU8";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "TooLargeForU16";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "TooLargeForU32";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "TooLargeForU64";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "TooLargeForU128";
          item := StructTuple [];
          discriminant := None;
        }
      ];
  }
  *)
  
  Module Impl_core_fmt_Debug_for_move_core_types_u256_U256CastErrorKind.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::U256CastErrorKind".
    
    (* Debug *)
    Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_str", [] |),
            [
              M.read (| f |);
              M.read (|
                M.match_operator (|
                  self,
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "TooLargeForU8" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "TooLargeForU16" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "TooLargeForU32" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "TooLargeForU64" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "TooLargeForU128" |) |)))
                  ]
                |)
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_move_core_types_u256_U256CastErrorKind.
  
  Module Impl_core_marker_StructuralPartialEq_for_move_core_types_u256_U256CastErrorKind.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::U256CastErrorKind".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_move_core_types_u256_U256CastErrorKind.
  
  Module Impl_core_cmp_PartialEq_for_move_core_types_u256_U256CastErrorKind.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::U256CastErrorKind".
    
    (* PartialEq *)
    Definition eq (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            let __self_tag :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [ Ty.path "move_core_types::u256::U256CastErrorKind" ]
                  |),
                  [ M.read (| self |) ]
                |)
              |) in
            let __arg1_tag :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [ Ty.path "move_core_types::u256::U256CastErrorKind" ]
                  |),
                  [ M.read (| other |) ]
                |)
              |) in
            M.alloc (| BinOp.Pure.eq (M.read (| __self_tag |)) (M.read (| __arg1_tag |)) |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_for_move_core_types_u256_U256CastErrorKind.
  
  Module Impl_core_marker_StructuralEq_for_move_core_types_u256_U256CastErrorKind.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::U256CastErrorKind".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralEq_for_move_core_types_u256_U256CastErrorKind.
  
  Module Impl_core_cmp_Eq_for_move_core_types_u256_U256CastErrorKind.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::U256CastErrorKind".
    
    (* Eq *)
    Definition assert_receiver_is_total_eq (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.Tuple []))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_move_core_types_u256_U256CastErrorKind.
  
  Module Impl_core_clone_Clone_for_move_core_types_u256_U256CastErrorKind.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::U256CastErrorKind".
    
    (* Clone *)
    Definition clone (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (| M.read (| self |) |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_move_core_types_u256_U256CastErrorKind.
  
  Module Impl_core_marker_Copy_for_move_core_types_u256_U256CastErrorKind.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::U256CastErrorKind".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::Copy"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_Copy_for_move_core_types_u256_U256CastErrorKind.
  
  Module Impl_core_hash_Hash_for_move_core_types_u256_U256CastErrorKind.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::U256CastErrorKind".
    
    (* Hash *)
    Definition hash (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ __H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let state := M.alloc (| state |) in
          M.read (|
            let __self_tag :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [ Ty.path "move_core_types::u256::U256CastErrorKind" ]
                  |),
                  [ M.read (| self |) ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                M.get_trait_method (| "core::hash::Hash", Ty.path "isize", [], "hash", [ __H ] |),
                [ __self_tag; M.read (| state |) ]
              |)
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::hash::Hash"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("hash", InstanceField.Method hash) ].
  End Impl_core_hash_Hash_for_move_core_types_u256_U256CastErrorKind.
  
  (* StructRecord
    {
      name := "U256CastError";
      ty_params := [];
      fields :=
        [
          ("kind", Ty.path "move_core_types::u256::U256CastErrorKind");
          ("val", Ty.path "move_core_types::u256::U256")
        ];
    } *)
  
  Module Impl_core_fmt_Debug_for_move_core_types_u256_U256CastError.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::U256CastError".
    
    (* Debug *)
    Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.path "core::fmt::Formatter",
              "debug_struct_field2_finish",
              []
            |),
            [
              M.read (| f |);
              M.read (| mk_str "U256CastError" |);
              M.read (| mk_str "kind" |);
              (* Unsize *)
              M.pointer_coercion
                (M.get_struct_record_field
                  (M.read (| self |))
                  "move_core_types::u256::U256CastError"
                  "kind");
              M.read (| mk_str "val" |);
              (* Unsize *)
              M.pointer_coercion
                (M.alloc (|
                  M.get_struct_record_field
                    (M.read (| self |))
                    "move_core_types::u256::U256CastError"
                    "val"
                |))
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_move_core_types_u256_U256CastError.
  
  Module Impl_move_core_types_u256_U256CastError.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::U256CastError".
    
    (*
        pub fn new<T: std::convert::Into<U256>>(val: T, kind: U256CastErrorKind) -> Self {
            Self {
                kind,
                val: val.into(),
            }
        }
    *)
    Definition new (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ T ], [ val; kind ] =>
        ltac:(M.monadic
          (let val := M.alloc (| val |) in
          let kind := M.alloc (| kind |) in
          Value.StructRecord
            "move_core_types::u256::U256CastError"
            [
              ("kind", M.read (| kind |));
              ("val",
                M.call_closure (|
                  M.get_trait_method (|
                    "core::convert::Into",
                    T,
                    [ Ty.path "move_core_types::u256::U256" ],
                    "into",
                    []
                  |),
                  [ M.read (| val |) ]
                |))
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_new : M.IsAssociatedFunction Self "new" new.
  End Impl_move_core_types_u256_U256CastError.
  
  Module Impl_core_error_Error_for_move_core_types_u256_U256CastError.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::U256CastError".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::error::Error"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_error_Error_for_move_core_types_u256_U256CastError.
  
  Module Impl_core_fmt_Display_for_move_core_types_u256_U256CastError.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::U256CastError".
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            let type_str = match self.kind {
                U256CastErrorKind::TooLargeForU8 => "u8",
                U256CastErrorKind::TooLargeForU16 => "u16",
                U256CastErrorKind::TooLargeForU32 => "u32",
                U256CastErrorKind::TooLargeForU64 => "u64",
                U256CastErrorKind::TooLargeForU128 => "u128",
            };
            let err_str = format!("Cast failed. {} too large for {}.", self.val, type_str);
            write!(f, "{err_str}")
        }
    *)
    Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.read (|
            let type_str :=
              M.copy (|
                M.match_operator (|
                  M.get_struct_record_field
                    (M.read (| self |))
                    "move_core_types::u256::U256CastError"
                    "kind",
                  [
                    fun γ => ltac:(M.monadic (mk_str "u8"));
                    fun γ => ltac:(M.monadic (M.alloc (| M.read (| mk_str "u16" |) |)));
                    fun γ => ltac:(M.monadic (M.alloc (| M.read (| mk_str "u32" |) |)));
                    fun γ => ltac:(M.monadic (M.alloc (| M.read (| mk_str "u64" |) |)));
                    fun γ => ltac:(M.monadic (M.alloc (| M.read (| mk_str "u128" |) |)))
                  ]
                |)
              |) in
            let err_str :=
              M.copy (|
                let res :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_function (| "alloc::fmt::format", [] |),
                      [
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.path "core::fmt::Arguments",
                            "new_v1",
                            []
                          |),
                          [
                            (* Unsize *)
                            M.pointer_coercion
                              (M.alloc (|
                                Value.Array
                                  [
                                    M.read (| mk_str "Cast failed. " |);
                                    M.read (| mk_str " too large for " |);
                                    M.read (| mk_str "." |)
                                  ]
                              |));
                            (* Unsize *)
                            M.pointer_coercion
                              (M.alloc (|
                                Value.Array
                                  [
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.path "core::fmt::rt::Argument",
                                        "new_display",
                                        [ Ty.path "move_core_types::u256::U256" ]
                                      |),
                                      [
                                        M.get_struct_record_field
                                          (M.read (| self |))
                                          "move_core_types::u256::U256CastError"
                                          "val"
                                      ]
                                    |);
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.path "core::fmt::rt::Argument",
                                        "new_display",
                                        [ Ty.apply (Ty.path "&") [ Ty.path "str" ] ]
                                      |),
                                      [ type_str ]
                                    |)
                                  ]
                              |))
                          ]
                        |)
                      ]
                    |)
                  |) in
                res
              |) in
            M.alloc (|
              M.call_closure (|
                M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_fmt", [] |),
                [
                  M.read (| f |);
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "core::fmt::Arguments", "new_v1", [] |),
                    [
                      (* Unsize *)
                      M.pointer_coercion (M.alloc (| Value.Array [ M.read (| mk_str "" |) ] |));
                      (* Unsize *)
                      M.pointer_coercion
                        (M.alloc (|
                          Value.Array
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::fmt::rt::Argument",
                                  "new_display",
                                  [ Ty.path "alloc::string::String" ]
                                |),
                                [ err_str ]
                              |)
                            ]
                        |))
                    ]
                  |)
                ]
              |)
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Display"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Display_for_move_core_types_u256_U256CastError.
  
  Module Impl_core_error_Error_for_move_core_types_u256_U256FromStrError.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::U256FromStrError".
    
    (*
        fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
            self.0.source()
        }
    *)
    Definition source (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::error::Error",
              Ty.path "uint::uint::FromStrRadixErr",
              [],
              "source",
              []
            |),
            [
              M.get_struct_tuple_field
                (M.read (| self |))
                "move_core_types::u256::U256FromStrError"
                0
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::error::Error"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("source", InstanceField.Method source) ].
  End Impl_core_error_Error_for_move_core_types_u256_U256FromStrError.
  
  Module Impl_core_fmt_Display_for_move_core_types_u256_U256FromStrError.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::U256FromStrError".
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            write!(f, "{}", self.0)
        }
    *)
    Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_fmt", [] |),
            [
              M.read (| f |);
              M.call_closure (|
                M.get_associated_function (| Ty.path "core::fmt::Arguments", "new_v1", [] |),
                [
                  (* Unsize *)
                  M.pointer_coercion (M.alloc (| Value.Array [ M.read (| mk_str "" |) ] |));
                  (* Unsize *)
                  M.pointer_coercion
                    (M.alloc (|
                      Value.Array
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::rt::Argument",
                              "new_display",
                              [ Ty.path "uint::uint::FromStrRadixErr" ]
                            |),
                            [
                              M.get_struct_tuple_field
                                (M.read (| self |))
                                "move_core_types::u256::U256FromStrError"
                                0
                            ]
                          |)
                        ]
                    |))
                ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Display"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Display_for_move_core_types_u256_U256FromStrError.
  
  (* StructTuple
    {
      name := "U256";
      ty_params := [];
      fields := [ Ty.path "primitive_types::U256" ];
    } *)
  
  Module Impl_core_clone_Clone_for_move_core_types_u256_U256.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::U256".
    
    (* Clone *)
    Definition clone (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Value.DeclaredButUndefined,
              [ fun γ => ltac:(M.monadic (M.read (| self |))) ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_move_core_types_u256_U256.
  
  Module Impl_core_fmt_Debug_for_move_core_types_u256_U256.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::U256".
    
    (* Debug *)
    Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.path "core::fmt::Formatter",
              "debug_tuple_field1_finish",
              []
            |),
            [
              M.read (| f |);
              M.read (| mk_str "U256" |);
              (* Unsize *)
              M.pointer_coercion
                (M.alloc (|
                  M.get_struct_tuple_field (M.read (| self |)) "move_core_types::u256::U256" 0
                |))
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_move_core_types_u256_U256.
  
  Module Impl_core_marker_StructuralPartialEq_for_move_core_types_u256_U256.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::U256".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_move_core_types_u256_U256.
  
  Module Impl_core_cmp_PartialEq_for_move_core_types_u256_U256.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::U256".
    
    (* PartialEq *)
    Definition eq (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::cmp::PartialEq",
              Ty.path "primitive_types::U256",
              [ Ty.path "primitive_types::U256" ],
              "eq",
              []
            |),
            [
              M.get_struct_tuple_field (M.read (| self |)) "move_core_types::u256::U256" 0;
              M.get_struct_tuple_field (M.read (| other |)) "move_core_types::u256::U256" 0
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_for_move_core_types_u256_U256.
  
  Module Impl_core_marker_StructuralEq_for_move_core_types_u256_U256.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::U256".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralEq_for_move_core_types_u256_U256.
  
  Module Impl_core_cmp_Eq_for_move_core_types_u256_U256.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::U256".
    
    (* Eq *)
    Definition assert_receiver_is_total_eq (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Value.DeclaredButUndefined,
              [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_move_core_types_u256_U256.
  
  Module Impl_core_hash_Hash_for_move_core_types_u256_U256.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::U256".
    
    (* Hash *)
    Definition hash (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ __H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let state := M.alloc (| state |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::hash::Hash",
              Ty.path "primitive_types::U256",
              [],
              "hash",
              [ __H ]
            |),
            [
              M.get_struct_tuple_field (M.read (| self |)) "move_core_types::u256::U256" 0;
              M.read (| state |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::hash::Hash"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("hash", InstanceField.Method hash) ].
  End Impl_core_hash_Hash_for_move_core_types_u256_U256.
  
  Module Impl_core_marker_Copy_for_move_core_types_u256_U256.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::U256".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::Copy"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_Copy_for_move_core_types_u256_U256.
  
  Module Impl_core_cmp_PartialOrd_for_move_core_types_u256_U256.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::U256".
    
    (* PartialOrd *)
    Definition partial_cmp (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::cmp::PartialOrd",
              Ty.path "primitive_types::U256",
              [ Ty.path "primitive_types::U256" ],
              "partial_cmp",
              []
            |),
            [
              M.get_struct_tuple_field (M.read (| self |)) "move_core_types::u256::U256" 0;
              M.get_struct_tuple_field (M.read (| other |)) "move_core_types::u256::U256" 0
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialOrd"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("partial_cmp", InstanceField.Method partial_cmp) ].
  End Impl_core_cmp_PartialOrd_for_move_core_types_u256_U256.
  
  Module Impl_core_cmp_Ord_for_move_core_types_u256_U256.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::U256".
    
    (* Ord *)
    Definition cmp (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::cmp::Ord",
              Ty.path "primitive_types::U256",
              [],
              "cmp",
              []
            |),
            [
              M.get_struct_tuple_field (M.read (| self |)) "move_core_types::u256::U256" 0;
              M.get_struct_tuple_field (M.read (| other |)) "move_core_types::u256::U256" 0
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Ord"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("cmp", InstanceField.Method cmp) ].
  End Impl_core_cmp_Ord_for_move_core_types_u256_U256.
  
  Module Impl_core_default_Default_for_move_core_types_u256_U256.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::U256".
    
    (* Default *)
    Definition default (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [] =>
        ltac:(M.monadic
          (Value.StructTuple
            "move_core_types::u256::U256"
            [
              M.call_closure (|
                M.get_trait_method (|
                  "core::default::Default",
                  Ty.path "primitive_types::U256",
                  [],
                  "default",
                  []
                |),
                []
              |)
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::default::Default"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("default", InstanceField.Method default) ].
  End Impl_core_default_Default_for_move_core_types_u256_U256.
  
  Module Impl_core_fmt_Display_for_move_core_types_u256_U256.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::U256".
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter) -> std::fmt::Result {
            self.0.fmt(f)
        }
    *)
    Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::fmt::Display",
              Ty.path "primitive_types::U256",
              [],
              "fmt",
              []
            |),
            [
              M.get_struct_tuple_field (M.read (| self |)) "move_core_types::u256::U256" 0;
              M.read (| f |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Display"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Display_for_move_core_types_u256_U256.
  
  Module Impl_core_fmt_UpperHex_for_move_core_types_u256_U256.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::U256".
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            fmt::UpperHex::fmt(&self.0, f)
        }
    *)
    Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::fmt::UpperHex",
              Ty.path "primitive_types::U256",
              [],
              "fmt",
              []
            |),
            [
              M.get_struct_tuple_field (M.read (| self |)) "move_core_types::u256::U256" 0;
              M.read (| f |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::UpperHex"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_UpperHex_for_move_core_types_u256_U256.
  
  Module Impl_core_fmt_LowerHex_for_move_core_types_u256_U256.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::U256".
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            fmt::LowerHex::fmt(&self.0, f)
        }
    *)
    Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            M.get_trait_method (|
              "core::fmt::LowerHex",
              Ty.path "primitive_types::U256",
              [],
              "fmt",
              []
            |),
            [
              M.get_struct_tuple_field (M.read (| self |)) "move_core_types::u256::U256" 0;
              M.read (| f |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::LowerHex"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_LowerHex_for_move_core_types_u256_U256.
  
  Module Impl_core_str_traits_FromStr_for_move_core_types_u256_U256.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::U256".
    
    (*     type Err = U256FromStrError; *)
    Definition _Err : Ty.t := Ty.path "move_core_types::u256::U256FromStrError".
    
    (*
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            Self::from_str_radix(s, 10)
        }
    *)
    Definition from_str (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ s ] =>
        ltac:(M.monadic
          (let s := M.alloc (| s |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.path "move_core_types::u256::U256",
              "from_str_radix",
              []
            |),
            [ M.read (| s |); Value.Integer Integer.U32 10 ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::str::traits::FromStr"
        Self
        (* Trait polymorphic types *) []
        (* Instance *)
        [ ("Err", InstanceField.Ty _Err); ("from_str", InstanceField.Method from_str) ].
  End Impl_core_str_traits_FromStr_for_move_core_types_u256_U256.
  
  Module Impl_serde_de_Deserialize_for_move_core_types_u256_U256.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::U256".
    
    (*
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: Deserializer<'de>,
        {
            Ok(U256::from_le_bytes(
                &(<[u8; U256_NUM_BYTES]>::deserialize(deserializer)?),
            ))
        }
    *)
    Definition deserialize (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ D ], [ deserializer ] =>
        ltac:(M.monadic
          (let deserializer := M.alloc (| deserializer |) in
          Value.StructTuple
            "core::result::Result::Ok"
            [
              M.call_closure (|
                M.get_associated_function (|
                  Ty.path "move_core_types::u256::U256",
                  "from_le_bytes",
                  []
                |),
                [
                  M.match_operator (|
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::ops::try_trait::Try",
                          Ty.apply
                            (Ty.path "core::result::Result")
                            [ Ty.apply (Ty.path "array") [ Ty.path "u8" ]; Ty.associated ],
                          [],
                          "branch",
                          []
                        |),
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "serde::de::Deserialize",
                              Ty.apply (Ty.path "array") [ Ty.path "u8" ],
                              [],
                              "deserialize",
                              [ D ]
                            |),
                            [ M.read (| deserializer |) ]
                          |)
                        ]
                      |)
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.get_struct_tuple_field_or_break_match (|
                              γ,
                              "core::ops::control_flow::ControlFlow::Break",
                              0
                            |) in
                          let residual := M.copy (| γ0_0 |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::ops::try_trait::FromResidual",
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        [ Ty.path "move_core_types::u256::U256"; Ty.associated ],
                                      [
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          [ Ty.path "core::convert::Infallible"; Ty.associated ]
                                      ],
                                      "from_residual",
                                      []
                                    |),
                                    [ M.read (| residual |) ]
                                  |)
                                |)
                              |)
                            |)
                          |)));
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.get_struct_tuple_field_or_break_match (|
                              γ,
                              "core::ops::control_flow::ControlFlow::Continue",
                              0
                            |) in
                          let val := M.copy (| γ0_0 |) in
                          val))
                    ]
                  |)
                ]
              |)
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "serde::de::Deserialize"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("deserialize", InstanceField.Method deserialize) ].
  End Impl_serde_de_Deserialize_for_move_core_types_u256_U256.
  
  Module Impl_serde_ser_Serialize_for_move_core_types_u256_U256.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::U256".
    
    (*
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: Serializer,
        {
            self.to_le_bytes().serialize(serializer)
        }
    *)
    Definition serialize (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ _ as S ], [ self; serializer ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let serializer := M.alloc (| serializer |) in
          M.call_closure (|
            M.get_trait_method (|
              "serde::ser::Serialize",
              Ty.apply (Ty.path "array") [ Ty.path "u8" ],
              [],
              "serialize",
              [ S ]
            |),
            [
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.path "move_core_types::u256::U256",
                    "to_le_bytes",
                    []
                  |),
                  [ M.read (| M.read (| self |) |) ]
                |)
              |);
              M.read (| serializer |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "serde::ser::Serialize"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("serialize", InstanceField.Method serialize) ].
  End Impl_serde_ser_Serialize_for_move_core_types_u256_U256.
  
  Module Impl_core_ops_bit_Shl_u32_for_move_core_types_u256_U256.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::U256".
    
    (*     type Output = Self; *)
    Definition _Output : Ty.t := Ty.path "move_core_types::u256::U256".
    
    (*
        fn shl(self, rhs: u32) -> Self::Output {
            let Self(lhs) = self;
            Self(lhs << rhs)
        }
    *)
    Definition shl (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::u256::U256",
                        0
                      |) in
                    let lhs := M.copy (| γ0_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_core_types::u256::U256"
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::ops::bit::Shl",
                              Ty.path "primitive_types::U256",
                              [ Ty.path "u32" ],
                              "shl",
                              []
                            |),
                            [ M.read (| lhs |); M.read (| rhs |) ]
                          |)
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::ops::bit::Shl"
        Self
        (* Trait polymorphic types *) [ (* Rhs *) Ty.path "u32" ]
        (* Instance *) [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
  End Impl_core_ops_bit_Shl_u32_for_move_core_types_u256_U256.
  
  Module Impl_core_ops_bit_Shl_u8_for_move_core_types_u256_U256.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::U256".
    
    (*     type Output = Self; *)
    Definition _Output : Ty.t := Ty.path "move_core_types::u256::U256".
    
    (*
        fn shl(self, rhs: u8) -> Self::Output {
            let Self(lhs) = self;
            Self(lhs << rhs)
        }
    *)
    Definition shl (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::u256::U256",
                        0
                      |) in
                    let lhs := M.copy (| γ0_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_core_types::u256::U256"
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::ops::bit::Shl",
                              Ty.path "primitive_types::U256",
                              [ Ty.path "u8" ],
                              "shl",
                              []
                            |),
                            [ M.read (| lhs |); M.read (| rhs |) ]
                          |)
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::ops::bit::Shl"
        Self
        (* Trait polymorphic types *) [ (* Rhs *) Ty.path "u8" ]
        (* Instance *) [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
  End Impl_core_ops_bit_Shl_u8_for_move_core_types_u256_U256.
  
  Module Impl_core_ops_bit_Shr_u8_for_move_core_types_u256_U256.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::U256".
    
    (*     type Output = Self; *)
    Definition _Output : Ty.t := Ty.path "move_core_types::u256::U256".
    
    (*
        fn shr(self, rhs: u8) -> Self::Output {
            let Self(lhs) = self;
            Self(lhs >> rhs)
        }
    *)
    Definition shr (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::u256::U256",
                        0
                      |) in
                    let lhs := M.copy (| γ0_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_core_types::u256::U256"
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::ops::bit::Shr",
                              Ty.path "primitive_types::U256",
                              [ Ty.path "u8" ],
                              "shr",
                              []
                            |),
                            [ M.read (| lhs |); M.read (| rhs |) ]
                          |)
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::ops::bit::Shr"
        Self
        (* Trait polymorphic types *) [ (* Rhs *) Ty.path "u8" ]
        (* Instance *) [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
  End Impl_core_ops_bit_Shr_u8_for_move_core_types_u256_U256.
  
  Module Impl_core_ops_bit_BitOr_move_core_types_u256_U256_for_move_core_types_u256_U256.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::U256".
    
    (*     type Output = Self; *)
    Definition _Output : Ty.t := Ty.path "move_core_types::u256::U256".
    
    (*
        fn bitor(self, rhs: U256) -> Self::Output {
            let Self(lhs) = self;
            let Self(rhs) = rhs;
            Self(lhs | rhs)
        }
    *)
    Definition bitor (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::u256::U256",
                        0
                      |) in
                    let lhs := M.copy (| γ0_0 |) in
                    M.match_operator (|
                      rhs,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ,
                                "move_core_types::u256::U256",
                                0
                              |) in
                            let rhs := M.copy (| γ0_0 |) in
                            M.alloc (|
                              Value.StructTuple
                                "move_core_types::u256::U256"
                                [
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::ops::bit::BitOr",
                                      Ty.path "primitive_types::U256",
                                      [ Ty.path "primitive_types::U256" ],
                                      "bitor",
                                      []
                                    |),
                                    [ M.read (| lhs |); M.read (| rhs |) ]
                                  |)
                                ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::ops::bit::BitOr"
        Self
        (* Trait polymorphic types *) [ (* Rhs *) Ty.path "move_core_types::u256::U256" ]
        (* Instance *)
        [ ("Output", InstanceField.Ty _Output); ("bitor", InstanceField.Method bitor) ].
  End Impl_core_ops_bit_BitOr_move_core_types_u256_U256_for_move_core_types_u256_U256.
  
  Module Impl_core_ops_bit_BitAnd_move_core_types_u256_U256_for_move_core_types_u256_U256.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::U256".
    
    (*     type Output = Self; *)
    Definition _Output : Ty.t := Ty.path "move_core_types::u256::U256".
    
    (*
        fn bitand(self, rhs: U256) -> Self::Output {
            let Self(lhs) = self;
            let Self(rhs) = rhs;
            Self(lhs & rhs)
        }
    *)
    Definition bitand (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::u256::U256",
                        0
                      |) in
                    let lhs := M.copy (| γ0_0 |) in
                    M.match_operator (|
                      rhs,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ,
                                "move_core_types::u256::U256",
                                0
                              |) in
                            let rhs := M.copy (| γ0_0 |) in
                            M.alloc (|
                              Value.StructTuple
                                "move_core_types::u256::U256"
                                [
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::ops::bit::BitAnd",
                                      Ty.path "primitive_types::U256",
                                      [ Ty.path "primitive_types::U256" ],
                                      "bitand",
                                      []
                                    |),
                                    [ M.read (| lhs |); M.read (| rhs |) ]
                                  |)
                                ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::ops::bit::BitAnd"
        Self
        (* Trait polymorphic types *) [ (* Rhs *) Ty.path "move_core_types::u256::U256" ]
        (* Instance *)
        [ ("Output", InstanceField.Ty _Output); ("bitand", InstanceField.Method bitand) ].
  End Impl_core_ops_bit_BitAnd_move_core_types_u256_U256_for_move_core_types_u256_U256.
  
  Module Impl_core_ops_bit_BitXor_move_core_types_u256_U256_for_move_core_types_u256_U256.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::U256".
    
    (*     type Output = Self; *)
    Definition _Output : Ty.t := Ty.path "move_core_types::u256::U256".
    
    (*
        fn bitxor(self, rhs: U256) -> Self::Output {
            let Self(lhs) = self;
            let Self(rhs) = rhs;
            Self(lhs ^ rhs)
        }
    *)
    Definition bitxor (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::u256::U256",
                        0
                      |) in
                    let lhs := M.copy (| γ0_0 |) in
                    M.match_operator (|
                      rhs,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ,
                                "move_core_types::u256::U256",
                                0
                              |) in
                            let rhs := M.copy (| γ0_0 |) in
                            M.alloc (|
                              Value.StructTuple
                                "move_core_types::u256::U256"
                                [
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::ops::bit::BitXor",
                                      Ty.path "primitive_types::U256",
                                      [ Ty.path "primitive_types::U256" ],
                                      "bitxor",
                                      []
                                    |),
                                    [ M.read (| lhs |); M.read (| rhs |) ]
                                  |)
                                ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::ops::bit::BitXor"
        Self
        (* Trait polymorphic types *) [ (* Rhs *) Ty.path "move_core_types::u256::U256" ]
        (* Instance *)
        [ ("Output", InstanceField.Ty _Output); ("bitxor", InstanceField.Method bitxor) ].
  End Impl_core_ops_bit_BitXor_move_core_types_u256_U256_for_move_core_types_u256_U256.
  
  Module Impl_core_ops_bit_BitAndAssign_move_core_types_u256_U256_for_move_core_types_u256_U256.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::U256".
    
    (*
        fn bitand_assign(&mut self, rhs: U256) {
            *self = *self & rhs;
        }
    *)
    Definition bitand_assign (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            let _ :=
              M.write (|
                M.read (| self |),
                M.call_closure (|
                  M.get_trait_method (|
                    "core::ops::bit::BitAnd",
                    Ty.path "move_core_types::u256::U256",
                    [ Ty.path "move_core_types::u256::U256" ],
                    "bitand",
                    []
                  |),
                  [ M.read (| M.read (| self |) |); M.read (| rhs |) ]
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::ops::bit::BitAndAssign"
        Self
        (* Trait polymorphic types *) [ (* Rhs *) Ty.path "move_core_types::u256::U256" ]
        (* Instance *) [ ("bitand_assign", InstanceField.Method bitand_assign) ].
  End Impl_core_ops_bit_BitAndAssign_move_core_types_u256_U256_for_move_core_types_u256_U256.
  
  Module Impl_core_ops_arith_Add_move_core_types_u256_U256_for_move_core_types_u256_U256.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::U256".
    
    (*     type Output = Self; *)
    Definition _Output : Ty.t := Ty.path "move_core_types::u256::U256".
    
    (*
        fn add(self, rhs: U256) -> Self::Output {
            self.wrapping_add(rhs)
        }
    *)
    Definition add (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.path "move_core_types::u256::U256",
              "wrapping_add",
              []
            |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::ops::arith::Add"
        Self
        (* Trait polymorphic types *) [ (* Rhs *) Ty.path "move_core_types::u256::U256" ]
        (* Instance *) [ ("Output", InstanceField.Ty _Output); ("add", InstanceField.Method add) ].
  End Impl_core_ops_arith_Add_move_core_types_u256_U256_for_move_core_types_u256_U256.
  
  Module Impl_core_ops_arith_AddAssign_move_core_types_u256_U256_for_move_core_types_u256_U256.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::U256".
    
    (*
        fn add_assign(&mut self, rhs: U256) {
            *self = *self + rhs;
        }
    *)
    Definition add_assign (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            let _ :=
              M.write (|
                M.read (| self |),
                M.call_closure (|
                  M.get_trait_method (|
                    "core::ops::arith::Add",
                    Ty.path "move_core_types::u256::U256",
                    [ Ty.path "move_core_types::u256::U256" ],
                    "add",
                    []
                  |),
                  [ M.read (| M.read (| self |) |); M.read (| rhs |) ]
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::ops::arith::AddAssign"
        Self
        (* Trait polymorphic types *) [ (* Rhs *) Ty.path "move_core_types::u256::U256" ]
        (* Instance *) [ ("add_assign", InstanceField.Method add_assign) ].
  End Impl_core_ops_arith_AddAssign_move_core_types_u256_U256_for_move_core_types_u256_U256.
  
  Module Impl_core_ops_arith_Sub_move_core_types_u256_U256_for_move_core_types_u256_U256.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::U256".
    
    (*     type Output = Self; *)
    Definition _Output : Ty.t := Ty.path "move_core_types::u256::U256".
    
    (*
        fn sub(self, rhs: U256) -> Self::Output {
            self.wrapping_sub(rhs)
        }
    *)
    Definition sub (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.path "move_core_types::u256::U256",
              "wrapping_sub",
              []
            |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::ops::arith::Sub"
        Self
        (* Trait polymorphic types *) [ (* Rhs *) Ty.path "move_core_types::u256::U256" ]
        (* Instance *) [ ("Output", InstanceField.Ty _Output); ("sub", InstanceField.Method sub) ].
  End Impl_core_ops_arith_Sub_move_core_types_u256_U256_for_move_core_types_u256_U256.
  
  Module Impl_core_ops_arith_SubAssign_move_core_types_u256_U256_for_move_core_types_u256_U256.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::U256".
    
    (*
        fn sub_assign(&mut self, rhs: U256) {
            *self = *self - rhs;
        }
    *)
    Definition sub_assign (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            let _ :=
              M.write (|
                M.read (| self |),
                M.call_closure (|
                  M.get_trait_method (|
                    "core::ops::arith::Sub",
                    Ty.path "move_core_types::u256::U256",
                    [ Ty.path "move_core_types::u256::U256" ],
                    "sub",
                    []
                  |),
                  [ M.read (| M.read (| self |) |); M.read (| rhs |) ]
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::ops::arith::SubAssign"
        Self
        (* Trait polymorphic types *) [ (* Rhs *) Ty.path "move_core_types::u256::U256" ]
        (* Instance *) [ ("sub_assign", InstanceField.Method sub_assign) ].
  End Impl_core_ops_arith_SubAssign_move_core_types_u256_U256_for_move_core_types_u256_U256.
  
  Module Impl_core_ops_arith_Mul_move_core_types_u256_U256_for_move_core_types_u256_U256.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::U256".
    
    (*     type Output = Self; *)
    Definition _Output : Ty.t := Ty.path "move_core_types::u256::U256".
    
    (*
        fn mul(self, rhs: U256) -> Self::Output {
            self.wrapping_mul(rhs)
        }
    *)
    Definition mul (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.path "move_core_types::u256::U256",
              "wrapping_mul",
              []
            |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::ops::arith::Mul"
        Self
        (* Trait polymorphic types *) [ (* Rhs *) Ty.path "move_core_types::u256::U256" ]
        (* Instance *) [ ("Output", InstanceField.Ty _Output); ("mul", InstanceField.Method mul) ].
  End Impl_core_ops_arith_Mul_move_core_types_u256_U256_for_move_core_types_u256_U256.
  
  Module Impl_core_ops_arith_MulAssign_move_core_types_u256_U256_for_move_core_types_u256_U256.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::U256".
    
    (*
        fn mul_assign(&mut self, rhs: U256) {
            *self = *self * rhs;
        }
    *)
    Definition mul_assign (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            let _ :=
              M.write (|
                M.read (| self |),
                M.call_closure (|
                  M.get_trait_method (|
                    "core::ops::arith::Mul",
                    Ty.path "move_core_types::u256::U256",
                    [ Ty.path "move_core_types::u256::U256" ],
                    "mul",
                    []
                  |),
                  [ M.read (| M.read (| self |) |); M.read (| rhs |) ]
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::ops::arith::MulAssign"
        Self
        (* Trait polymorphic types *) [ (* Rhs *) Ty.path "move_core_types::u256::U256" ]
        (* Instance *) [ ("mul_assign", InstanceField.Method mul_assign) ].
  End Impl_core_ops_arith_MulAssign_move_core_types_u256_U256_for_move_core_types_u256_U256.
  
  Module Impl_core_ops_arith_Div_move_core_types_u256_U256_for_move_core_types_u256_U256.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::U256".
    
    (*     type Output = Self; *)
    Definition _Output : Ty.t := Ty.path "move_core_types::u256::U256".
    
    (*
        fn div(self, rhs: U256) -> Self::Output {
            Self(self.0 / rhs.0)
        }
    *)
    Definition div (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          Value.StructTuple
            "move_core_types::u256::U256"
            [
              M.call_closure (|
                M.get_trait_method (|
                  "core::ops::arith::Div",
                  Ty.path "primitive_types::U256",
                  [ Ty.path "primitive_types::U256" ],
                  "div",
                  []
                |),
                [
                  M.read (| M.get_struct_tuple_field self "move_core_types::u256::U256" 0 |);
                  M.read (| M.get_struct_tuple_field rhs "move_core_types::u256::U256" 0 |)
                ]
              |)
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::ops::arith::Div"
        Self
        (* Trait polymorphic types *) [ (* Rhs *) Ty.path "move_core_types::u256::U256" ]
        (* Instance *) [ ("Output", InstanceField.Ty _Output); ("div", InstanceField.Method div) ].
  End Impl_core_ops_arith_Div_move_core_types_u256_U256_for_move_core_types_u256_U256.
  
  Module Impl_core_ops_arith_DivAssign_move_core_types_u256_U256_for_move_core_types_u256_U256.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::U256".
    
    (*
        fn div_assign(&mut self, rhs: U256) {
            *self = *self / rhs;
        }
    *)
    Definition div_assign (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            let _ :=
              M.write (|
                M.read (| self |),
                M.call_closure (|
                  M.get_trait_method (|
                    "core::ops::arith::Div",
                    Ty.path "move_core_types::u256::U256",
                    [ Ty.path "move_core_types::u256::U256" ],
                    "div",
                    []
                  |),
                  [ M.read (| M.read (| self |) |); M.read (| rhs |) ]
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::ops::arith::DivAssign"
        Self
        (* Trait polymorphic types *) [ (* Rhs *) Ty.path "move_core_types::u256::U256" ]
        (* Instance *) [ ("div_assign", InstanceField.Method div_assign) ].
  End Impl_core_ops_arith_DivAssign_move_core_types_u256_U256_for_move_core_types_u256_U256.
  
  Module Impl_core_ops_arith_Rem_move_core_types_u256_U256_for_move_core_types_u256_U256.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::U256".
    
    (*     type Output = Self; *)
    Definition _Output : Ty.t := Ty.path "move_core_types::u256::U256".
    
    (*
        fn rem(self, rhs: U256) -> Self::Output {
            Self(self.0 % rhs.0)
        }
    *)
    Definition rem (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          Value.StructTuple
            "move_core_types::u256::U256"
            [
              M.call_closure (|
                M.get_trait_method (|
                  "core::ops::arith::Rem",
                  Ty.path "primitive_types::U256",
                  [ Ty.path "primitive_types::U256" ],
                  "rem",
                  []
                |),
                [
                  M.read (| M.get_struct_tuple_field self "move_core_types::u256::U256" 0 |);
                  M.read (| M.get_struct_tuple_field rhs "move_core_types::u256::U256" 0 |)
                ]
              |)
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::ops::arith::Rem"
        Self
        (* Trait polymorphic types *) [ (* Rhs *) Ty.path "move_core_types::u256::U256" ]
        (* Instance *) [ ("Output", InstanceField.Ty _Output); ("rem", InstanceField.Method rem) ].
  End Impl_core_ops_arith_Rem_move_core_types_u256_U256_for_move_core_types_u256_U256.
  
  Module Impl_core_ops_arith_RemAssign_move_core_types_u256_U256_for_move_core_types_u256_U256.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::U256".
    
    (*
        fn rem_assign(&mut self, rhs: U256) {
            *self = Self(self.0 % rhs.0);
        }
    *)
    Definition rem_assign (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            let _ :=
              M.write (|
                M.read (| self |),
                Value.StructTuple
                  "move_core_types::u256::U256"
                  [
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::ops::arith::Rem",
                        Ty.path "primitive_types::U256",
                        [ Ty.path "primitive_types::U256" ],
                        "rem",
                        []
                      |),
                      [
                        M.read (|
                          M.get_struct_tuple_field
                            (M.read (| self |))
                            "move_core_types::u256::U256"
                            0
                        |);
                        M.read (| M.get_struct_tuple_field rhs "move_core_types::u256::U256" 0 |)
                      ]
                    |)
                  ]
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::ops::arith::RemAssign"
        Self
        (* Trait polymorphic types *) [ (* Rhs *) Ty.path "move_core_types::u256::U256" ]
        (* Instance *) [ ("rem_assign", InstanceField.Method rem_assign) ].
  End Impl_core_ops_arith_RemAssign_move_core_types_u256_U256_for_move_core_types_u256_U256.
  
  Module Impl_move_core_types_u256_U256.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::U256".
    
    (*
        pub const fn zero() -> Self {
            Self(PrimitiveU256::zero())
        }
    *)
    Definition zero (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [] =>
        ltac:(M.monadic
          (Value.StructTuple
            "move_core_types::u256::U256"
            [
              M.call_closure (|
                M.get_associated_function (| Ty.path "primitive_types::U256", "zero", [] |),
                []
              |)
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_zero : M.IsAssociatedFunction Self "zero" zero.
    
    (*
        pub const fn one() -> Self {
            Self(PrimitiveU256::one())
        }
    *)
    Definition one (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [] =>
        ltac:(M.monadic
          (Value.StructTuple
            "move_core_types::u256::U256"
            [
              M.call_closure (|
                M.get_associated_function (| Ty.path "primitive_types::U256", "one", [] |),
                []
              |)
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_one : M.IsAssociatedFunction Self "one" one.
    
    (*
        pub const fn max_value() -> Self {
            Self(PrimitiveU256::max_value())
        }
    *)
    Definition max_value (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [] =>
        ltac:(M.monadic
          (Value.StructTuple
            "move_core_types::u256::U256"
            [
              M.call_closure (|
                M.get_associated_function (| Ty.path "primitive_types::U256", "max_value", [] |),
                []
              |)
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_max_value : M.IsAssociatedFunction Self "max_value" max_value.
    
    (*
        pub fn from_str_radix(src: &str, radix: u32) -> Result<Self, U256FromStrError> {
            PrimitiveU256::from_str_radix(src.trim_start_matches('0'), radix)
                .map(Self)
                .map_err(U256FromStrError)
        }
    *)
    Definition from_str_radix (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ src; radix ] =>
        ltac:(M.monadic
          (let src := M.alloc (| src |) in
          let radix := M.alloc (| radix |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply
                (Ty.path "core::result::Result")
                [ Ty.path "move_core_types::u256::U256"; Ty.path "uint::uint::FromStrRadixErr" ],
              "map_err",
              [
                Ty.path "move_core_types::u256::U256FromStrError";
                Ty.function
                  [ Ty.path "uint::uint::FromStrRadixErr" ]
                  (Ty.path "move_core_types::u256::U256FromStrError")
              ]
            |),
            [
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    [ Ty.path "primitive_types::U256"; Ty.path "uint::uint::FromStrRadixErr" ],
                  "map",
                  [
                    Ty.path "move_core_types::u256::U256";
                    Ty.function
                      [ Ty.path "primitive_types::U256" ]
                      (Ty.path "move_core_types::u256::U256")
                  ]
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "primitive_types::U256",
                      "from_str_radix",
                      []
                    |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "str",
                          "trim_start_matches",
                          [ Ty.path "char" ]
                        |),
                        [ M.read (| src |); Value.UnicodeChar 48 ]
                      |);
                      M.read (| radix |)
                    ]
                  |);
                  M.constructor_as_closure "move_core_types::u256::U256"
                ]
              |);
              M.constructor_as_closure "move_core_types::u256::U256FromStrError"
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_from_str_radix :
      M.IsAssociatedFunction Self "from_str_radix" from_str_radix.
    
    (*
        pub fn from_le_bytes(slice: &[u8; U256_NUM_BYTES]) -> Self {
            Self(PrimitiveU256::from_little_endian(slice))
        }
    *)
    Definition from_le_bytes (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ slice ] =>
        ltac:(M.monadic
          (let slice := M.alloc (| slice |) in
          Value.StructTuple
            "move_core_types::u256::U256"
            [
              M.call_closure (|
                M.get_associated_function (|
                  Ty.path "primitive_types::U256",
                  "from_little_endian",
                  []
                |),
                [ (* Unsize *) M.pointer_coercion (M.read (| slice |)) ]
              |)
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_from_le_bytes :
      M.IsAssociatedFunction Self "from_le_bytes" from_le_bytes.
    
    (*
        pub fn to_le_bytes(self) -> [u8; U256_NUM_BYTES] {
            let mut bytes = [0u8; U256_NUM_BYTES];
            self.0.to_little_endian(&mut bytes);
            bytes
        }
    *)
    Definition to_le_bytes (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let bytes := M.alloc (| repeat (Value.Integer Integer.U8 0) 32 |) in
            let _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.path "primitive_types::U256",
                    "to_little_endian",
                    []
                  |),
                  [
                    M.get_struct_tuple_field self "move_core_types::u256::U256" 0;
                    (* Unsize *) M.pointer_coercion bytes
                  ]
                |)
              |) in
            bytes
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_to_le_bytes : M.IsAssociatedFunction Self "to_le_bytes" to_le_bytes.
    
    (*
        pub fn leading_zeros(&self) -> u32 {
            self.0.leading_zeros()
        }
    *)
    Definition leading_zeros (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "primitive_types::U256", "leading_zeros", [] |),
            [ M.get_struct_tuple_field (M.read (| self |)) "move_core_types::u256::U256" 0 ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_leading_zeros :
      M.IsAssociatedFunction Self "leading_zeros" leading_zeros.
    
    (*
        pub fn unchecked_as_u8(&self) -> u8 {
            self.0.low_u128() as u8
        }
    *)
    Definition unchecked_as_u8 (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.rust_cast
            (M.call_closure (|
              M.get_associated_function (| Ty.path "primitive_types::U256", "low_u128", [] |),
              [ M.get_struct_tuple_field (M.read (| self |)) "move_core_types::u256::U256" 0 ]
            |))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_unchecked_as_u8 :
      M.IsAssociatedFunction Self "unchecked_as_u8" unchecked_as_u8.
    
    (*
        pub fn unchecked_as_u16(&self) -> u16 {
            self.0.low_u128() as u16
        }
    *)
    Definition unchecked_as_u16 (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.rust_cast
            (M.call_closure (|
              M.get_associated_function (| Ty.path "primitive_types::U256", "low_u128", [] |),
              [ M.get_struct_tuple_field (M.read (| self |)) "move_core_types::u256::U256" 0 ]
            |))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_unchecked_as_u16 :
      M.IsAssociatedFunction Self "unchecked_as_u16" unchecked_as_u16.
    
    (*
        pub fn unchecked_as_u32(&self) -> u32 {
            self.0.low_u128() as u32
        }
    *)
    Definition unchecked_as_u32 (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.rust_cast
            (M.call_closure (|
              M.get_associated_function (| Ty.path "primitive_types::U256", "low_u128", [] |),
              [ M.get_struct_tuple_field (M.read (| self |)) "move_core_types::u256::U256" 0 ]
            |))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_unchecked_as_u32 :
      M.IsAssociatedFunction Self "unchecked_as_u32" unchecked_as_u32.
    
    (*
        pub fn unchecked_as_u64(&self) -> u64 {
            self.0.low_u128() as u64
        }
    *)
    Definition unchecked_as_u64 (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.rust_cast
            (M.call_closure (|
              M.get_associated_function (| Ty.path "primitive_types::U256", "low_u128", [] |),
              [ M.get_struct_tuple_field (M.read (| self |)) "move_core_types::u256::U256" 0 ]
            |))))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_unchecked_as_u64 :
      M.IsAssociatedFunction Self "unchecked_as_u64" unchecked_as_u64.
    
    (*
        pub fn unchecked_as_u128(&self) -> u128 {
            self.0.low_u128()
        }
    *)
    Definition unchecked_as_u128 (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "primitive_types::U256", "low_u128", [] |),
            [ M.get_struct_tuple_field (M.read (| self |)) "move_core_types::u256::U256" 0 ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_unchecked_as_u128 :
      M.IsAssociatedFunction Self "unchecked_as_u128" unchecked_as_u128.
    
    (*
        pub fn checked_add(self, rhs: Self) -> Option<Self> {
            self.0.checked_add(rhs.0).map(Self)
        }
    *)
    Definition checked_add (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply (Ty.path "core::option::Option") [ Ty.path "primitive_types::U256" ],
              "map",
              [
                Ty.path "move_core_types::u256::U256";
                Ty.function
                  [ Ty.path "primitive_types::U256" ]
                  (Ty.path "move_core_types::u256::U256")
              ]
            |),
            [
              M.call_closure (|
                M.get_associated_function (| Ty.path "primitive_types::U256", "checked_add", [] |),
                [
                  M.read (| M.get_struct_tuple_field self "move_core_types::u256::U256" 0 |);
                  M.read (| M.get_struct_tuple_field rhs "move_core_types::u256::U256" 0 |)
                ]
              |);
              M.constructor_as_closure "move_core_types::u256::U256"
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_add : M.IsAssociatedFunction Self "checked_add" checked_add.
    
    (*
        pub fn checked_sub(self, rhs: Self) -> Option<Self> {
            self.0.checked_sub(rhs.0).map(Self)
        }
    *)
    Definition checked_sub (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply (Ty.path "core::option::Option") [ Ty.path "primitive_types::U256" ],
              "map",
              [
                Ty.path "move_core_types::u256::U256";
                Ty.function
                  [ Ty.path "primitive_types::U256" ]
                  (Ty.path "move_core_types::u256::U256")
              ]
            |),
            [
              M.call_closure (|
                M.get_associated_function (| Ty.path "primitive_types::U256", "checked_sub", [] |),
                [
                  M.read (| M.get_struct_tuple_field self "move_core_types::u256::U256" 0 |);
                  M.read (| M.get_struct_tuple_field rhs "move_core_types::u256::U256" 0 |)
                ]
              |);
              M.constructor_as_closure "move_core_types::u256::U256"
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_sub : M.IsAssociatedFunction Self "checked_sub" checked_sub.
    
    (*
        pub fn checked_mul(self, rhs: Self) -> Option<Self> {
            self.0.checked_mul(rhs.0).map(Self)
        }
    *)
    Definition checked_mul (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply (Ty.path "core::option::Option") [ Ty.path "primitive_types::U256" ],
              "map",
              [
                Ty.path "move_core_types::u256::U256";
                Ty.function
                  [ Ty.path "primitive_types::U256" ]
                  (Ty.path "move_core_types::u256::U256")
              ]
            |),
            [
              M.call_closure (|
                M.get_associated_function (| Ty.path "primitive_types::U256", "checked_mul", [] |),
                [
                  M.read (| M.get_struct_tuple_field self "move_core_types::u256::U256" 0 |);
                  M.read (| M.get_struct_tuple_field rhs "move_core_types::u256::U256" 0 |)
                ]
              |);
              M.constructor_as_closure "move_core_types::u256::U256"
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_mul : M.IsAssociatedFunction Self "checked_mul" checked_mul.
    
    (*
        pub fn checked_div(self, rhs: Self) -> Option<Self> {
            self.0.checked_div(rhs.0).map(Self)
        }
    *)
    Definition checked_div (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply (Ty.path "core::option::Option") [ Ty.path "primitive_types::U256" ],
              "map",
              [
                Ty.path "move_core_types::u256::U256";
                Ty.function
                  [ Ty.path "primitive_types::U256" ]
                  (Ty.path "move_core_types::u256::U256")
              ]
            |),
            [
              M.call_closure (|
                M.get_associated_function (| Ty.path "primitive_types::U256", "checked_div", [] |),
                [
                  M.read (| M.get_struct_tuple_field self "move_core_types::u256::U256" 0 |);
                  M.read (| M.get_struct_tuple_field rhs "move_core_types::u256::U256" 0 |)
                ]
              |);
              M.constructor_as_closure "move_core_types::u256::U256"
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_div : M.IsAssociatedFunction Self "checked_div" checked_div.
    
    (*
        pub fn checked_rem(self, rhs: Self) -> Option<Self> {
            self.0.checked_rem(rhs.0).map(Self)
        }
    *)
    Definition checked_rem (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply (Ty.path "core::option::Option") [ Ty.path "primitive_types::U256" ],
              "map",
              [
                Ty.path "move_core_types::u256::U256";
                Ty.function
                  [ Ty.path "primitive_types::U256" ]
                  (Ty.path "move_core_types::u256::U256")
              ]
            |),
            [
              M.call_closure (|
                M.get_associated_function (| Ty.path "primitive_types::U256", "checked_rem", [] |),
                [
                  M.read (| M.get_struct_tuple_field self "move_core_types::u256::U256" 0 |);
                  M.read (| M.get_struct_tuple_field rhs "move_core_types::u256::U256" 0 |)
                ]
              |);
              M.constructor_as_closure "move_core_types::u256::U256"
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_rem : M.IsAssociatedFunction Self "checked_rem" checked_rem.
    
    (*
        pub fn checked_shl(self, rhs: u32) -> Option<Self> {
            if rhs >= U256_NUM_BITS as u32 {
                return None;
            }
            Some(Self(self.0.shl(rhs)))
        }
    *)
    Definition checked_shl (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            let _ :=
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            BinOp.Pure.ge
                              (M.read (| rhs |))
                              (M.rust_cast
                                (M.read (|
                                  M.get_constant (| "move_core_types::u256::U256_NUM_BITS" |)
                                |)))
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        M.never_to_any (|
                          M.read (|
                            M.return_ (| Value.StructTuple "core::option::Option::None" [] |)
                          |)
                        |)
                      |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            M.alloc (|
              Value.StructTuple
                "core::option::Option::Some"
                [
                  Value.StructTuple
                    "move_core_types::u256::U256"
                    [
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::ops::bit::Shl",
                          Ty.path "primitive_types::U256",
                          [ Ty.path "u32" ],
                          "shl",
                          []
                        |),
                        [
                          M.read (|
                            M.get_struct_tuple_field self "move_core_types::u256::U256" 0
                          |);
                          M.read (| rhs |)
                        ]
                      |)
                    ]
                ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_shl : M.IsAssociatedFunction Self "checked_shl" checked_shl.
    
    (*
        pub fn checked_shr(self, rhs: u32) -> Option<Self> {
            if rhs >= U256_NUM_BITS as u32 {
                return None;
            }
            Some(Self(self.0.shr(rhs)))
        }
    *)
    Definition checked_shr (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            let _ :=
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            BinOp.Pure.ge
                              (M.read (| rhs |))
                              (M.rust_cast
                                (M.read (|
                                  M.get_constant (| "move_core_types::u256::U256_NUM_BITS" |)
                                |)))
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        M.never_to_any (|
                          M.read (|
                            M.return_ (| Value.StructTuple "core::option::Option::None" [] |)
                          |)
                        |)
                      |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            M.alloc (|
              Value.StructTuple
                "core::option::Option::Some"
                [
                  Value.StructTuple
                    "move_core_types::u256::U256"
                    [
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::ops::bit::Shr",
                          Ty.path "primitive_types::U256",
                          [ Ty.path "u32" ],
                          "shr",
                          []
                        |),
                        [
                          M.read (|
                            M.get_struct_tuple_field self "move_core_types::u256::U256" 0
                          |);
                          M.read (| rhs |)
                        ]
                      |)
                    ]
                ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_checked_shr : M.IsAssociatedFunction Self "checked_shr" checked_shr.
    
    (*
        pub fn down_cast_lossy<T: std::convert::TryFrom<u128>>(self) -> T {
            // Size of this type
            let type_size = size_of::<T>();
            // Maximum value for this type
            let max_val: u128 = if type_size < 16 {
                (1u128 << (NUM_BITS_PER_BYTE * type_size)) - 1u128
            } else {
                u128::MAX
            };
            // This should never fail
            match T::try_from(self.0.low_u128() & max_val) {
                Ok(w) => w,
                Err(_) => panic!("Fatal! Downcast failed"),
            }
        }
    *)
    Definition down_cast_lossy (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ T ], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let type_size :=
              M.alloc (|
                M.call_closure (| M.get_function (| "core::mem::size_of", [ T ] |), [] |)
              |) in
            let max_val :=
              M.copy (|
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              BinOp.Pure.lt
                                (M.read (| type_size |))
                                (Value.Integer Integer.Usize 16)
                            |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.alloc (|
                          BinOp.Panic.sub (|
                            BinOp.Panic.shl (|
                              Value.Integer Integer.U128 1,
                              BinOp.Panic.mul (|
                                M.read (|
                                  M.get_constant (| "move_core_types::u256::NUM_BITS_PER_BYTE" |)
                                |),
                                M.read (| type_size |)
                              |)
                            |),
                            Value.Integer Integer.U128 1
                          |)
                        |)));
                    fun γ => ltac:(M.monadic (M.get_constant (| "core::num::MAX" |)))
                  ]
                |)
              |) in
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "core::convert::TryFrom",
                    T,
                    [ Ty.path "u128" ],
                    "try_from",
                    []
                  |),
                  [
                    BinOp.Pure.bit_and
                      (M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "primitive_types::U256",
                          "low_u128",
                          []
                        |),
                        [ M.get_struct_tuple_field self "move_core_types::u256::U256" 0 ]
                      |))
                      (M.read (| max_val |))
                  ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "core::result::Result::Ok",
                        0
                      |) in
                    let w := M.copy (| γ0_0 |) in
                    w));
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "core::result::Result::Err",
                        0
                      |) in
                    M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          M.get_function (| "core::panicking::panic_fmt", [] |),
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::fmt::Arguments",
                                "new_const",
                                []
                              |),
                              [
                                (* Unsize *)
                                M.pointer_coercion
                                  (M.alloc (|
                                    Value.Array [ M.read (| mk_str "Fatal! Downcast failed" |) ]
                                  |))
                              ]
                            |)
                          ]
                        |)
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_down_cast_lossy :
      M.IsAssociatedFunction Self "down_cast_lossy" down_cast_lossy.
    
    (*
        pub fn wrapping_add(self, rhs: Self) -> Self {
            Self(self.0.overflowing_add(rhs.0).0)
        }
    *)
    Definition wrapping_add (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          Value.StructTuple
            "move_core_types::u256::U256"
            [
              M.read (|
                M.get_tuple_field
                  (M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "primitive_types::U256",
                        "overflowing_add",
                        []
                      |),
                      [
                        M.read (| M.get_struct_tuple_field self "move_core_types::u256::U256" 0 |);
                        M.read (| M.get_struct_tuple_field rhs "move_core_types::u256::U256" 0 |)
                      ]
                    |)
                  |))
                  0
              |)
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_add : M.IsAssociatedFunction Self "wrapping_add" wrapping_add.
    
    (*
        pub fn wrapping_sub(self, rhs: Self) -> Self {
            Self(self.0.overflowing_sub(rhs.0).0)
        }
    *)
    Definition wrapping_sub (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          Value.StructTuple
            "move_core_types::u256::U256"
            [
              M.read (|
                M.get_tuple_field
                  (M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "primitive_types::U256",
                        "overflowing_sub",
                        []
                      |),
                      [
                        M.read (| M.get_struct_tuple_field self "move_core_types::u256::U256" 0 |);
                        M.read (| M.get_struct_tuple_field rhs "move_core_types::u256::U256" 0 |)
                      ]
                    |)
                  |))
                  0
              |)
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_sub : M.IsAssociatedFunction Self "wrapping_sub" wrapping_sub.
    
    (*
        pub fn wrapping_mul(self, rhs: Self) -> Self {
            Self(self.0.overflowing_mul(rhs.0).0)
        }
    *)
    Definition wrapping_mul (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          Value.StructTuple
            "move_core_types::u256::U256"
            [
              M.read (|
                M.get_tuple_field
                  (M.alloc (|
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "primitive_types::U256",
                        "overflowing_mul",
                        []
                      |),
                      [
                        M.read (| M.get_struct_tuple_field self "move_core_types::u256::U256" 0 |);
                        M.read (| M.get_struct_tuple_field rhs "move_core_types::u256::U256" 0 |)
                      ]
                    |)
                  |))
                  0
              |)
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wrapping_mul : M.IsAssociatedFunction Self "wrapping_mul" wrapping_mul.
    
    (*
        fn wmul(self, b: Self) -> (Self, Self) {
            let half = 128;
            #[allow(non_snake_case)]
            let LOWER_MASK: U256 = Self::max_value() >> half;
    
            let mut low = (self & LOWER_MASK).wrapping_mul(b & LOWER_MASK);
            let mut t = low >> half;
            low &= LOWER_MASK;
            t += (self >> half).wrapping_mul(b & LOWER_MASK);
            low += (t & LOWER_MASK) << half;
            let mut high = t >> half;
            t = low >> half;
            low &= LOWER_MASK;
            t += (b >> half).wrapping_mul(self & LOWER_MASK);
            low += (t & LOWER_MASK) << half;
            high += t >> half;
            high += (self >> half).wrapping_mul(b >> half);
    
            (high, low)
        }
    *)
    Definition wmul (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; b ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let b := M.alloc (| b |) in
          M.read (|
            let half := M.alloc (| Value.Integer Integer.U8 128 |) in
            let value_LOWER_MASK :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "core::ops::bit::Shr",
                    Ty.path "move_core_types::u256::U256",
                    [ Ty.path "u8" ],
                    "shr",
                    []
                  |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "move_core_types::u256::U256",
                        "max_value",
                        []
                      |),
                      []
                    |);
                    M.read (| half |)
                  ]
                |)
              |) in
            let low :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.path "move_core_types::u256::U256",
                    "wrapping_mul",
                    []
                  |),
                  [
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::ops::bit::BitAnd",
                        Ty.path "move_core_types::u256::U256",
                        [ Ty.path "move_core_types::u256::U256" ],
                        "bitand",
                        []
                      |),
                      [ M.read (| self |); M.read (| value_LOWER_MASK |) ]
                    |);
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::ops::bit::BitAnd",
                        Ty.path "move_core_types::u256::U256",
                        [ Ty.path "move_core_types::u256::U256" ],
                        "bitand",
                        []
                      |),
                      [ M.read (| b |); M.read (| value_LOWER_MASK |) ]
                    |)
                  ]
                |)
              |) in
            let t :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "core::ops::bit::Shr",
                    Ty.path "move_core_types::u256::U256",
                    [ Ty.path "u8" ],
                    "shr",
                    []
                  |),
                  [ M.read (| low |); M.read (| half |) ]
                |)
              |) in
            let _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "core::ops::bit::BitAndAssign",
                    Ty.path "move_core_types::u256::U256",
                    [ Ty.path "move_core_types::u256::U256" ],
                    "bitand_assign",
                    []
                  |),
                  [ low; M.read (| value_LOWER_MASK |) ]
                |)
              |) in
            let _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "core::ops::arith::AddAssign",
                    Ty.path "move_core_types::u256::U256",
                    [ Ty.path "move_core_types::u256::U256" ],
                    "add_assign",
                    []
                  |),
                  [
                    t;
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "move_core_types::u256::U256",
                        "wrapping_mul",
                        []
                      |),
                      [
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::ops::bit::Shr",
                            Ty.path "move_core_types::u256::U256",
                            [ Ty.path "u8" ],
                            "shr",
                            []
                          |),
                          [ M.read (| self |); M.read (| half |) ]
                        |);
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::ops::bit::BitAnd",
                            Ty.path "move_core_types::u256::U256",
                            [ Ty.path "move_core_types::u256::U256" ],
                            "bitand",
                            []
                          |),
                          [ M.read (| b |); M.read (| value_LOWER_MASK |) ]
                        |)
                      ]
                    |)
                  ]
                |)
              |) in
            let _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "core::ops::arith::AddAssign",
                    Ty.path "move_core_types::u256::U256",
                    [ Ty.path "move_core_types::u256::U256" ],
                    "add_assign",
                    []
                  |),
                  [
                    low;
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::ops::bit::Shl",
                        Ty.path "move_core_types::u256::U256",
                        [ Ty.path "u8" ],
                        "shl",
                        []
                      |),
                      [
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::ops::bit::BitAnd",
                            Ty.path "move_core_types::u256::U256",
                            [ Ty.path "move_core_types::u256::U256" ],
                            "bitand",
                            []
                          |),
                          [ M.read (| t |); M.read (| value_LOWER_MASK |) ]
                        |);
                        M.read (| half |)
                      ]
                    |)
                  ]
                |)
              |) in
            let high :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "core::ops::bit::Shr",
                    Ty.path "move_core_types::u256::U256",
                    [ Ty.path "u8" ],
                    "shr",
                    []
                  |),
                  [ M.read (| t |); M.read (| half |) ]
                |)
              |) in
            let _ :=
              M.write (|
                t,
                M.call_closure (|
                  M.get_trait_method (|
                    "core::ops::bit::Shr",
                    Ty.path "move_core_types::u256::U256",
                    [ Ty.path "u8" ],
                    "shr",
                    []
                  |),
                  [ M.read (| low |); M.read (| half |) ]
                |)
              |) in
            let _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "core::ops::bit::BitAndAssign",
                    Ty.path "move_core_types::u256::U256",
                    [ Ty.path "move_core_types::u256::U256" ],
                    "bitand_assign",
                    []
                  |),
                  [ low; M.read (| value_LOWER_MASK |) ]
                |)
              |) in
            let _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "core::ops::arith::AddAssign",
                    Ty.path "move_core_types::u256::U256",
                    [ Ty.path "move_core_types::u256::U256" ],
                    "add_assign",
                    []
                  |),
                  [
                    t;
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "move_core_types::u256::U256",
                        "wrapping_mul",
                        []
                      |),
                      [
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::ops::bit::Shr",
                            Ty.path "move_core_types::u256::U256",
                            [ Ty.path "u8" ],
                            "shr",
                            []
                          |),
                          [ M.read (| b |); M.read (| half |) ]
                        |);
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::ops::bit::BitAnd",
                            Ty.path "move_core_types::u256::U256",
                            [ Ty.path "move_core_types::u256::U256" ],
                            "bitand",
                            []
                          |),
                          [ M.read (| self |); M.read (| value_LOWER_MASK |) ]
                        |)
                      ]
                    |)
                  ]
                |)
              |) in
            let _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "core::ops::arith::AddAssign",
                    Ty.path "move_core_types::u256::U256",
                    [ Ty.path "move_core_types::u256::U256" ],
                    "add_assign",
                    []
                  |),
                  [
                    low;
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::ops::bit::Shl",
                        Ty.path "move_core_types::u256::U256",
                        [ Ty.path "u8" ],
                        "shl",
                        []
                      |),
                      [
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::ops::bit::BitAnd",
                            Ty.path "move_core_types::u256::U256",
                            [ Ty.path "move_core_types::u256::U256" ],
                            "bitand",
                            []
                          |),
                          [ M.read (| t |); M.read (| value_LOWER_MASK |) ]
                        |);
                        M.read (| half |)
                      ]
                    |)
                  ]
                |)
              |) in
            let _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "core::ops::arith::AddAssign",
                    Ty.path "move_core_types::u256::U256",
                    [ Ty.path "move_core_types::u256::U256" ],
                    "add_assign",
                    []
                  |),
                  [
                    high;
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::ops::bit::Shr",
                        Ty.path "move_core_types::u256::U256",
                        [ Ty.path "u8" ],
                        "shr",
                        []
                      |),
                      [ M.read (| t |); M.read (| half |) ]
                    |)
                  ]
                |)
              |) in
            let _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "core::ops::arith::AddAssign",
                    Ty.path "move_core_types::u256::U256",
                    [ Ty.path "move_core_types::u256::U256" ],
                    "add_assign",
                    []
                  |),
                  [
                    high;
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "move_core_types::u256::U256",
                        "wrapping_mul",
                        []
                      |),
                      [
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::ops::bit::Shr",
                            Ty.path "move_core_types::u256::U256",
                            [ Ty.path "u8" ],
                            "shr",
                            []
                          |),
                          [ M.read (| self |); M.read (| half |) ]
                        |);
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::ops::bit::Shr",
                            Ty.path "move_core_types::u256::U256",
                            [ Ty.path "u8" ],
                            "shr",
                            []
                          |),
                          [ M.read (| b |); M.read (| half |) ]
                        |)
                      ]
                    |)
                  ]
                |)
              |) in
            M.alloc (| Value.Tuple [ M.read (| high |); M.read (| low |) ] |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_wmul : M.IsAssociatedFunction Self "wmul" wmul.
  End Impl_move_core_types_u256_U256.
  
  Module Impl_core_convert_From_u8_for_move_core_types_u256_U256.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::U256".
    
    (*
        fn from(n: u8) -> Self {
            U256(PrimitiveU256::from(n))
        }
    *)
    Definition from (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ n ] =>
        ltac:(M.monadic
          (let n := M.alloc (| n |) in
          Value.StructTuple
            "move_core_types::u256::U256"
            [
              M.call_closure (|
                M.get_trait_method (|
                  "core::convert::From",
                  Ty.path "primitive_types::U256",
                  [ Ty.path "u8" ],
                  "from",
                  []
                |),
                [ M.read (| n |) ]
              |)
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::convert::From"
        Self
        (* Trait polymorphic types *) [ (* T *) Ty.path "u8" ]
        (* Instance *) [ ("from", InstanceField.Method from) ].
  End Impl_core_convert_From_u8_for_move_core_types_u256_U256.
  
  Module Impl_core_convert_From_u16_for_move_core_types_u256_U256.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::U256".
    
    (*
        fn from(n: u16) -> Self {
            U256(PrimitiveU256::from(n))
        }
    *)
    Definition from (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ n ] =>
        ltac:(M.monadic
          (let n := M.alloc (| n |) in
          Value.StructTuple
            "move_core_types::u256::U256"
            [
              M.call_closure (|
                M.get_trait_method (|
                  "core::convert::From",
                  Ty.path "primitive_types::U256",
                  [ Ty.path "u16" ],
                  "from",
                  []
                |),
                [ M.read (| n |) ]
              |)
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::convert::From"
        Self
        (* Trait polymorphic types *) [ (* T *) Ty.path "u16" ]
        (* Instance *) [ ("from", InstanceField.Method from) ].
  End Impl_core_convert_From_u16_for_move_core_types_u256_U256.
  
  Module Impl_core_convert_From_u32_for_move_core_types_u256_U256.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::U256".
    
    (*
        fn from(n: u32) -> Self {
            U256(PrimitiveU256::from(n))
        }
    *)
    Definition from (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ n ] =>
        ltac:(M.monadic
          (let n := M.alloc (| n |) in
          Value.StructTuple
            "move_core_types::u256::U256"
            [
              M.call_closure (|
                M.get_trait_method (|
                  "core::convert::From",
                  Ty.path "primitive_types::U256",
                  [ Ty.path "u32" ],
                  "from",
                  []
                |),
                [ M.read (| n |) ]
              |)
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::convert::From"
        Self
        (* Trait polymorphic types *) [ (* T *) Ty.path "u32" ]
        (* Instance *) [ ("from", InstanceField.Method from) ].
  End Impl_core_convert_From_u32_for_move_core_types_u256_U256.
  
  Module Impl_core_convert_From_u64_for_move_core_types_u256_U256.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::U256".
    
    (*
        fn from(n: u64) -> Self {
            U256(PrimitiveU256::from(n))
        }
    *)
    Definition from (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ n ] =>
        ltac:(M.monadic
          (let n := M.alloc (| n |) in
          Value.StructTuple
            "move_core_types::u256::U256"
            [
              M.call_closure (|
                M.get_trait_method (|
                  "core::convert::From",
                  Ty.path "primitive_types::U256",
                  [ Ty.path "u64" ],
                  "from",
                  []
                |),
                [ M.read (| n |) ]
              |)
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::convert::From"
        Self
        (* Trait polymorphic types *) [ (* T *) Ty.path "u64" ]
        (* Instance *) [ ("from", InstanceField.Method from) ].
  End Impl_core_convert_From_u64_for_move_core_types_u256_U256.
  
  Module Impl_core_convert_From_u128_for_move_core_types_u256_U256.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::U256".
    
    (*
        fn from(n: u128) -> Self {
            U256(PrimitiveU256::from(n))
        }
    *)
    Definition from (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ n ] =>
        ltac:(M.monadic
          (let n := M.alloc (| n |) in
          Value.StructTuple
            "move_core_types::u256::U256"
            [
              M.call_closure (|
                M.get_trait_method (|
                  "core::convert::From",
                  Ty.path "primitive_types::U256",
                  [ Ty.path "u128" ],
                  "from",
                  []
                |),
                [ M.read (| n |) ]
              |)
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::convert::From"
        Self
        (* Trait polymorphic types *) [ (* T *) Ty.path "u128" ]
        (* Instance *) [ ("from", InstanceField.Method from) ].
  End Impl_core_convert_From_u128_for_move_core_types_u256_U256.
  
  Module Impl_core_convert_From_ref__move_core_types_u256_U256_for_num_bigint_bigint_BigInt.
    Definition Self : Ty.t := Ty.path "num_bigint::bigint::BigInt".
    
    (*
        fn from(n: &U256) -> Self {
            BigInt::from_bytes_le(Sign::Plus, &n.to_le_bytes())
        }
    *)
    Definition from (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ n ] =>
        ltac:(M.monadic
          (let n := M.alloc (| n |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.path "num_bigint::bigint::BigInt",
              "from_bytes_le",
              []
            |),
            [
              Value.StructTuple "num_bigint::bigint::Sign::Plus" [];
              (* Unsize *)
              M.pointer_coercion
                (M.alloc (|
                  M.call_closure (|
                    M.get_associated_function (|
                      Ty.path "move_core_types::u256::U256",
                      "to_le_bytes",
                      []
                    |),
                    [ M.read (| M.read (| n |) |) ]
                  |)
                |))
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::convert::From"
        Self
        (* Trait polymorphic types *)
        [ (* T *) Ty.apply (Ty.path "&") [ Ty.path "move_core_types::u256::U256" ] ]
        (* Instance *) [ ("from", InstanceField.Method from) ].
  End Impl_core_convert_From_ref__move_core_types_u256_U256_for_num_bigint_bigint_BigInt.
  
  Module Impl_core_convert_From_ref__move_core_types_u256_U256_for_ethnum_U256.
    Definition Self : Ty.t := Ty.path "ethnum::U256".
    
    (*
        fn from(n: &U256) -> EthnumU256 {
            // TODO (ade): use better solution for conversion
            // Currently using str because EthnumU256 can be little or big endian
            let num_str = format!("{:X}", n.0);
            // TODO (ade): remove expect()
            EthnumU256::from_str_radix(&num_str, 16).expect("Cannot convert to U256")
        }
    *)
    Definition from (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ n ] =>
        ltac:(M.monadic
          (let n := M.alloc (| n |) in
          M.read (|
            let num_str :=
              M.copy (|
                let res :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_function (| "alloc::fmt::format", [] |),
                      [
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.path "core::fmt::Arguments",
                            "new_v1",
                            []
                          |),
                          [
                            (* Unsize *)
                            M.pointer_coercion
                              (M.alloc (| Value.Array [ M.read (| mk_str "" |) ] |));
                            (* Unsize *)
                            M.pointer_coercion
                              (M.alloc (|
                                Value.Array
                                  [
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.path "core::fmt::rt::Argument",
                                        "new_upper_hex",
                                        [ Ty.path "primitive_types::U256" ]
                                      |),
                                      [
                                        M.get_struct_tuple_field
                                          (M.read (| n |))
                                          "move_core_types::u256::U256"
                                          0
                                      ]
                                    |)
                                  ]
                              |))
                          ]
                        |)
                      ]
                    |)
                  |) in
                res
              |) in
            M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    [ Ty.path "ethnum::U256"; Ty.path "core::num::error::ParseIntError" ],
                  "expect",
                  []
                |),
                [
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "ethnum::U256", "from_str_radix", [] |),
                    [
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::ops::deref::Deref",
                          Ty.path "alloc::string::String",
                          [],
                          "deref",
                          []
                        |),
                        [ num_str ]
                      |);
                      Value.Integer Integer.U32 16
                    ]
                  |);
                  M.read (| mk_str "Cannot convert to U256" |)
                ]
              |)
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::convert::From"
        Self
        (* Trait polymorphic types *)
        [ (* T *) Ty.apply (Ty.path "&") [ Ty.path "move_core_types::u256::U256" ] ]
        (* Instance *) [ ("from", InstanceField.Method from) ].
  End Impl_core_convert_From_ref__move_core_types_u256_U256_for_ethnum_U256.
  
  Module Impl_core_convert_TryFrom_move_core_types_u256_U256_for_u8.
    Definition Self : Ty.t := Ty.path "u8".
    
    (*     type Error = U256CastError; *)
    Definition _Error : Ty.t := Ty.path "move_core_types::u256::U256CastError".
    
    (*
        fn try_from(n: U256) -> Result<Self, Self::Error> {
            let n = n.0.low_u64();
            if n > u8::MAX as u64 {
                Err(U256CastError::new(n, U256CastErrorKind::TooLargeForU8))
            } else {
                Ok(n as u8)
            }
        }
    *)
    Definition try_from (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ n ] =>
        ltac:(M.monadic
          (let n := M.alloc (| n |) in
          M.read (|
            let n :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "primitive_types::U256", "low_u64", [] |),
                  [ M.get_struct_tuple_field n "move_core_types::u256::U256" 0 ]
                |)
              |) in
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          BinOp.Pure.gt
                            (M.read (| n |))
                            (M.rust_cast (M.read (| M.get_constant (| "core::num::MAX" |) |)))
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Err"
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "move_core_types::u256::U256CastError",
                              "new",
                              [ Ty.path "u64" ]
                            |),
                            [
                              M.read (| n |);
                              Value.StructTuple
                                "move_core_types::u256::U256CastErrorKind::TooLargeForU8"
                                []
                            ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.StructTuple "core::result::Result::Ok" [ M.rust_cast (M.read (| n |)) ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::convert::TryFrom"
        Self
        (* Trait polymorphic types *) [ (* T *) Ty.path "move_core_types::u256::U256" ]
        (* Instance *)
        [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
  End Impl_core_convert_TryFrom_move_core_types_u256_U256_for_u8.
  
  Module Impl_core_convert_TryFrom_move_core_types_u256_U256_for_u16.
    Definition Self : Ty.t := Ty.path "u16".
    
    (*     type Error = U256CastError; *)
    Definition _Error : Ty.t := Ty.path "move_core_types::u256::U256CastError".
    
    (*
        fn try_from(n: U256) -> Result<Self, Self::Error> {
            let n = n.0.low_u64();
            if n > u16::MAX as u64 {
                Err(U256CastError::new(n, U256CastErrorKind::TooLargeForU16))
            } else {
                Ok(n as u16)
            }
        }
    *)
    Definition try_from (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ n ] =>
        ltac:(M.monadic
          (let n := M.alloc (| n |) in
          M.read (|
            let n :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "primitive_types::U256", "low_u64", [] |),
                  [ M.get_struct_tuple_field n "move_core_types::u256::U256" 0 ]
                |)
              |) in
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          BinOp.Pure.gt
                            (M.read (| n |))
                            (M.rust_cast (M.read (| M.get_constant (| "core::num::MAX" |) |)))
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Err"
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "move_core_types::u256::U256CastError",
                              "new",
                              [ Ty.path "u64" ]
                            |),
                            [
                              M.read (| n |);
                              Value.StructTuple
                                "move_core_types::u256::U256CastErrorKind::TooLargeForU16"
                                []
                            ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.StructTuple "core::result::Result::Ok" [ M.rust_cast (M.read (| n |)) ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::convert::TryFrom"
        Self
        (* Trait polymorphic types *) [ (* T *) Ty.path "move_core_types::u256::U256" ]
        (* Instance *)
        [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
  End Impl_core_convert_TryFrom_move_core_types_u256_U256_for_u16.
  
  Module Impl_core_convert_TryFrom_move_core_types_u256_U256_for_u32.
    Definition Self : Ty.t := Ty.path "u32".
    
    (*     type Error = U256CastError; *)
    Definition _Error : Ty.t := Ty.path "move_core_types::u256::U256CastError".
    
    (*
        fn try_from(n: U256) -> Result<Self, Self::Error> {
            let n = n.0.low_u64();
            if n > u32::MAX as u64 {
                Err(U256CastError::new(n, U256CastErrorKind::TooLargeForU32))
            } else {
                Ok(n as u32)
            }
        }
    *)
    Definition try_from (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ n ] =>
        ltac:(M.monadic
          (let n := M.alloc (| n |) in
          M.read (|
            let n :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "primitive_types::U256", "low_u64", [] |),
                  [ M.get_struct_tuple_field n "move_core_types::u256::U256" 0 ]
                |)
              |) in
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          BinOp.Pure.gt
                            (M.read (| n |))
                            (M.rust_cast (M.read (| M.get_constant (| "core::num::MAX" |) |)))
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Err"
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "move_core_types::u256::U256CastError",
                              "new",
                              [ Ty.path "u64" ]
                            |),
                            [
                              M.read (| n |);
                              Value.StructTuple
                                "move_core_types::u256::U256CastErrorKind::TooLargeForU32"
                                []
                            ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.StructTuple "core::result::Result::Ok" [ M.rust_cast (M.read (| n |)) ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::convert::TryFrom"
        Self
        (* Trait polymorphic types *) [ (* T *) Ty.path "move_core_types::u256::U256" ]
        (* Instance *)
        [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
  End Impl_core_convert_TryFrom_move_core_types_u256_U256_for_u32.
  
  Module Impl_core_convert_TryFrom_move_core_types_u256_U256_for_u64.
    Definition Self : Ty.t := Ty.path "u64".
    
    (*     type Error = U256CastError; *)
    Definition _Error : Ty.t := Ty.path "move_core_types::u256::U256CastError".
    
    (*
        fn try_from(n: U256) -> Result<Self, Self::Error> {
            let n = n.0.low_u128();
            if n > u64::MAX as u128 {
                Err(U256CastError::new(n, U256CastErrorKind::TooLargeForU64))
            } else {
                Ok(n as u64)
            }
        }
    *)
    Definition try_from (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ n ] =>
        ltac:(M.monadic
          (let n := M.alloc (| n |) in
          M.read (|
            let n :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (| Ty.path "primitive_types::U256", "low_u128", [] |),
                  [ M.get_struct_tuple_field n "move_core_types::u256::U256" 0 ]
                |)
              |) in
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          BinOp.Pure.gt
                            (M.read (| n |))
                            (M.rust_cast (M.read (| M.get_constant (| "core::num::MAX" |) |)))
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Err"
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "move_core_types::u256::U256CastError",
                              "new",
                              [ Ty.path "u128" ]
                            |),
                            [
                              M.read (| n |);
                              Value.StructTuple
                                "move_core_types::u256::U256CastErrorKind::TooLargeForU64"
                                []
                            ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.StructTuple "core::result::Result::Ok" [ M.rust_cast (M.read (| n |)) ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::convert::TryFrom"
        Self
        (* Trait polymorphic types *) [ (* T *) Ty.path "move_core_types::u256::U256" ]
        (* Instance *)
        [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
  End Impl_core_convert_TryFrom_move_core_types_u256_U256_for_u64.
  
  Module Impl_core_convert_TryFrom_move_core_types_u256_U256_for_u128.
    Definition Self : Ty.t := Ty.path "u128".
    
    (*     type Error = U256CastError; *)
    Definition _Error : Ty.t := Ty.path "move_core_types::u256::U256CastError".
    
    (*
        fn try_from(n: U256) -> Result<Self, Self::Error> {
            if n > U256::from(u128::MAX) {
                Err(U256CastError::new(n, U256CastErrorKind::TooLargeForU128))
            } else {
                Ok(n.0.low_u128())
            }
        }
    *)
    Definition try_from (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ n ] =>
        ltac:(M.monadic
          (let n := M.alloc (| n |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::cmp::PartialOrd",
                              Ty.path "move_core_types::u256::U256",
                              [ Ty.path "move_core_types::u256::U256" ],
                              "gt",
                              []
                            |),
                            [
                              n;
                              M.alloc (|
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::convert::From",
                                    Ty.path "move_core_types::u256::U256",
                                    [ Ty.path "u128" ],
                                    "from",
                                    []
                                  |),
                                  [ M.read (| M.get_constant (| "core::num::MAX" |) |) ]
                                |)
                              |)
                            ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Err"
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "move_core_types::u256::U256CastError",
                              "new",
                              [ Ty.path "move_core_types::u256::U256" ]
                            |),
                            [
                              M.read (| n |);
                              Value.StructTuple
                                "move_core_types::u256::U256CastErrorKind::TooLargeForU128"
                                []
                            ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "primitive_types::U256",
                              "low_u128",
                              []
                            |),
                            [ M.get_struct_tuple_field n "move_core_types::u256::U256" 0 ]
                          |)
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::convert::TryFrom"
        Self
        (* Trait polymorphic types *) [ (* T *) Ty.path "move_core_types::u256::U256" ]
        (* Instance *)
        [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
  End Impl_core_convert_TryFrom_move_core_types_u256_U256_for_u128.
  
  Module Impl_rand_distributions_distribution_Distribution_move_core_types_u256_U256_for_rand_distributions_Standard.
    Definition Self : Ty.t := Ty.path "rand::distributions::Standard".
    
    (*
        fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> U256 {
            let mut dest = [0; U256_NUM_BYTES];
            rng.fill_bytes(&mut dest);
            U256::from_le_bytes(&dest)
        }
    *)
    Definition sample (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ R ], [ self; rng ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rng := M.alloc (| rng |) in
          M.read (|
            let dest := M.alloc (| repeat (Value.Integer Integer.U8 0) 32 |) in
            let _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (| "rand_core::RngCore", R, [], "fill_bytes", [] |),
                  [ M.read (| rng |); (* Unsize *) M.pointer_coercion dest ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.path "move_core_types::u256::U256",
                  "from_le_bytes",
                  []
                |),
                [ dest ]
              |)
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "rand::distributions::distribution::Distribution"
        Self
        (* Trait polymorphic types *) [ (* T *) Ty.path "move_core_types::u256::U256" ]
        (* Instance *) [ ("sample", InstanceField.Method sample) ].
  End Impl_rand_distributions_distribution_Distribution_move_core_types_u256_U256_for_rand_distributions_Standard.
  
  (* StructRecord
    {
      name := "UniformU256";
      ty_params := [];
      fields :=
        [
          ("low", Ty.path "move_core_types::u256::U256");
          ("range", Ty.path "move_core_types::u256::U256");
          ("z", Ty.path "move_core_types::u256::U256")
        ];
    } *)
  
  Module Impl_core_clone_Clone_for_move_core_types_u256_UniformU256.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::UniformU256".
    
    (* Clone *)
    Definition clone (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Value.DeclaredButUndefined,
              [ fun γ => ltac:(M.monadic (M.read (| self |))) ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_move_core_types_u256_UniformU256.
  
  Module Impl_core_marker_Copy_for_move_core_types_u256_UniformU256.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::UniformU256".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::Copy"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_Copy_for_move_core_types_u256_UniformU256.
  
  Module Impl_core_fmt_Debug_for_move_core_types_u256_UniformU256.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::UniformU256".
    
    (* Debug *)
    Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.path "core::fmt::Formatter",
              "debug_struct_field3_finish",
              []
            |),
            [
              M.read (| f |);
              M.read (| mk_str "UniformU256" |);
              M.read (| mk_str "low" |);
              (* Unsize *)
              M.pointer_coercion
                (M.get_struct_record_field
                  (M.read (| self |))
                  "move_core_types::u256::UniformU256"
                  "low");
              M.read (| mk_str "range" |);
              (* Unsize *)
              M.pointer_coercion
                (M.get_struct_record_field
                  (M.read (| self |))
                  "move_core_types::u256::UniformU256"
                  "range");
              M.read (| mk_str "z" |);
              (* Unsize *)
              M.pointer_coercion
                (M.alloc (|
                  M.get_struct_record_field
                    (M.read (| self |))
                    "move_core_types::u256::UniformU256"
                    "z"
                |))
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_move_core_types_u256_UniformU256.
  
  Module Impl_core_marker_StructuralPartialEq_for_move_core_types_u256_UniformU256.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::UniformU256".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_move_core_types_u256_UniformU256.
  
  Module Impl_core_cmp_PartialEq_for_move_core_types_u256_UniformU256.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::UniformU256".
    
    (* PartialEq *)
    Definition eq (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          LogicalOp.and (|
            LogicalOp.and (|
              M.call_closure (|
                M.get_trait_method (|
                  "core::cmp::PartialEq",
                  Ty.path "move_core_types::u256::U256",
                  [ Ty.path "move_core_types::u256::U256" ],
                  "eq",
                  []
                |),
                [
                  M.get_struct_record_field
                    (M.read (| self |))
                    "move_core_types::u256::UniformU256"
                    "low";
                  M.get_struct_record_field
                    (M.read (| other |))
                    "move_core_types::u256::UniformU256"
                    "low"
                ]
              |),
              ltac:(M.monadic
                (M.call_closure (|
                  M.get_trait_method (|
                    "core::cmp::PartialEq",
                    Ty.path "move_core_types::u256::U256",
                    [ Ty.path "move_core_types::u256::U256" ],
                    "eq",
                    []
                  |),
                  [
                    M.get_struct_record_field
                      (M.read (| self |))
                      "move_core_types::u256::UniformU256"
                      "range";
                    M.get_struct_record_field
                      (M.read (| other |))
                      "move_core_types::u256::UniformU256"
                      "range"
                  ]
                |)))
            |),
            ltac:(M.monadic
              (M.call_closure (|
                M.get_trait_method (|
                  "core::cmp::PartialEq",
                  Ty.path "move_core_types::u256::U256",
                  [ Ty.path "move_core_types::u256::U256" ],
                  "eq",
                  []
                |),
                [
                  M.get_struct_record_field
                    (M.read (| self |))
                    "move_core_types::u256::UniformU256"
                    "z";
                  M.get_struct_record_field
                    (M.read (| other |))
                    "move_core_types::u256::UniformU256"
                    "z"
                ]
              |)))
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_for_move_core_types_u256_UniformU256.
  
  Module Impl_core_marker_StructuralEq_for_move_core_types_u256_UniformU256.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::UniformU256".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralEq_for_move_core_types_u256_UniformU256.
  
  Module Impl_core_cmp_Eq_for_move_core_types_u256_UniformU256.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::UniformU256".
    
    (* Eq *)
    Definition assert_receiver_is_total_eq (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Value.DeclaredButUndefined,
              [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_move_core_types_u256_UniformU256.
  
  Module Impl_rand_distributions_uniform_SampleUniform_for_move_core_types_u256_U256.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::U256".
    
    (*     type Sampler = UniformU256; *)
    Definition _Sampler : Ty.t := Ty.path "move_core_types::u256::UniformU256".
    
    Axiom Implements :
      M.IsTraitInstance
        "rand::distributions::uniform::SampleUniform"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("Sampler", InstanceField.Ty _Sampler) ].
  End Impl_rand_distributions_uniform_SampleUniform_for_move_core_types_u256_U256.
  
  Module Impl_rand_distributions_uniform_UniformSampler_for_move_core_types_u256_UniformU256.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::UniformU256".
    
    (*     type X = U256; *)
    Definition _X : Ty.t := Ty.path "move_core_types::u256::U256".
    
    (*
        fn new<B1, B2>(low: B1, high: B2) -> Self
        where
            B1: rand::distributions::uniform::SampleBorrow<Self::X> + Sized,
            B2: rand::distributions::uniform::SampleBorrow<Self::X> + Sized,
        {
            let low = *low.borrow();
            let high = *high.borrow();
            assert!(low < high, "Uniform::new called with `low >= high`");
            UniformSampler::new_inclusive(low, high - U256::one())
        }
    *)
    Definition new (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ B1; B2 ], [ low; high ] =>
        ltac:(M.monadic
          (let low := M.alloc (| low |) in
          let high := M.alloc (| high |) in
          M.read (|
            let low :=
              M.copy (|
                M.call_closure (|
                  M.get_trait_method (|
                    "rand::distributions::uniform::SampleBorrow",
                    B1,
                    [ Ty.path "move_core_types::u256::U256" ],
                    "borrow",
                    []
                  |),
                  [ low ]
                |)
              |) in
            let high :=
              M.copy (|
                M.call_closure (|
                  M.get_trait_method (|
                    "rand::distributions::uniform::SampleBorrow",
                    B2,
                    [ Ty.path "move_core_types::u256::U256" ],
                    "borrow",
                    []
                  |),
                  [ high ]
                |)
              |) in
            let _ :=
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            UnOp.Pure.not
                              (M.call_closure (|
                                M.get_trait_method (|
                                  "core::cmp::PartialOrd",
                                  Ty.path "move_core_types::u256::U256",
                                  [ Ty.path "move_core_types::u256::U256" ],
                                  "lt",
                                  []
                                |),
                                [ low; high ]
                              |))
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        M.never_to_any (|
                          M.call_closure (|
                            M.get_function (| "core::panicking::panic_fmt", [] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::fmt::Arguments",
                                  "new_const",
                                  []
                                |),
                                [
                                  (* Unsize *)
                                  M.pointer_coercion
                                    (M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            mk_str "Uniform::new called with `low >= high`"
                                          |)
                                        ]
                                    |))
                                ]
                              |)
                            ]
                          |)
                        |)
                      |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            M.alloc (|
              M.call_closure (|
                M.get_trait_method (|
                  "rand::distributions::uniform::UniformSampler",
                  Ty.path "move_core_types::u256::UniformU256",
                  [],
                  "new_inclusive",
                  [ Ty.path "move_core_types::u256::U256"; Ty.path "move_core_types::u256::U256" ]
                |),
                [
                  M.read (| low |);
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Sub",
                      Ty.path "move_core_types::u256::U256",
                      [ Ty.path "move_core_types::u256::U256" ],
                      "sub",
                      []
                    |),
                    [
                      M.read (| high |);
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "move_core_types::u256::U256",
                          "one",
                          []
                        |),
                        []
                      |)
                    ]
                  |)
                ]
              |)
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    (*
        fn new_inclusive<B1, B2>(low: B1, high: B2) -> Self
        where
            B1: rand::distributions::uniform::SampleBorrow<Self::X> + Sized,
            B2: rand::distributions::uniform::SampleBorrow<Self::X> + Sized,
        {
            let low = *low.borrow();
            let high = *high.borrow();
            assert!(
                low <= high,
                "Uniform::new_inclusive called with `low > high`"
            );
            let unsigned_max = U256::max_value();
    
            let range = high.wrapping_sub(low).wrapping_add(U256::one());
    
            let ints_to_reject = if range > U256::zero() {
                (unsigned_max - range) + U256::one() % range
            } else {
                U256::zero()
            };
    
            UniformU256 {
                low,
                range,
                z: ints_to_reject,
            }
        }
    *)
    Definition new_inclusive (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ B1; B2 ], [ low; high ] =>
        ltac:(M.monadic
          (let low := M.alloc (| low |) in
          let high := M.alloc (| high |) in
          M.read (|
            let low :=
              M.copy (|
                M.call_closure (|
                  M.get_trait_method (|
                    "rand::distributions::uniform::SampleBorrow",
                    B1,
                    [ Ty.path "move_core_types::u256::U256" ],
                    "borrow",
                    []
                  |),
                  [ low ]
                |)
              |) in
            let high :=
              M.copy (|
                M.call_closure (|
                  M.get_trait_method (|
                    "rand::distributions::uniform::SampleBorrow",
                    B2,
                    [ Ty.path "move_core_types::u256::U256" ],
                    "borrow",
                    []
                  |),
                  [ high ]
                |)
              |) in
            let _ :=
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            UnOp.Pure.not
                              (M.call_closure (|
                                M.get_trait_method (|
                                  "core::cmp::PartialOrd",
                                  Ty.path "move_core_types::u256::U256",
                                  [ Ty.path "move_core_types::u256::U256" ],
                                  "le",
                                  []
                                |),
                                [ low; high ]
                              |))
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        M.never_to_any (|
                          M.call_closure (|
                            M.get_function (| "core::panicking::panic_fmt", [] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::fmt::Arguments",
                                  "new_const",
                                  []
                                |),
                                [
                                  (* Unsize *)
                                  M.pointer_coercion
                                    (M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            mk_str "Uniform::new_inclusive called with `low > high`"
                                          |)
                                        ]
                                    |))
                                ]
                              |)
                            ]
                          |)
                        |)
                      |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            let unsigned_max :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.path "move_core_types::u256::U256",
                    "max_value",
                    []
                  |),
                  []
                |)
              |) in
            let range :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.path "move_core_types::u256::U256",
                    "wrapping_add",
                    []
                  |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "move_core_types::u256::U256",
                        "wrapping_sub",
                        []
                      |),
                      [ M.read (| high |); M.read (| low |) ]
                    |);
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "move_core_types::u256::U256",
                        "one",
                        []
                      |),
                      []
                    |)
                  ]
                |)
              |) in
            let ints_to_reject :=
              M.copy (|
                M.match_operator (|
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::cmp::PartialOrd",
                                  Ty.path "move_core_types::u256::U256",
                                  [ Ty.path "move_core_types::u256::U256" ],
                                  "gt",
                                  []
                                |),
                                [
                                  range;
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.path "move_core_types::u256::U256",
                                        "zero",
                                        []
                                      |),
                                      []
                                    |)
                                  |)
                                ]
                              |)
                            |)) in
                        let _ :=
                          M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::ops::arith::Add",
                              Ty.path "move_core_types::u256::U256",
                              [ Ty.path "move_core_types::u256::U256" ],
                              "add",
                              []
                            |),
                            [
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::ops::arith::Sub",
                                  Ty.path "move_core_types::u256::U256",
                                  [ Ty.path "move_core_types::u256::U256" ],
                                  "sub",
                                  []
                                |),
                                [ M.read (| unsigned_max |); M.read (| range |) ]
                              |);
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::ops::arith::Rem",
                                  Ty.path "move_core_types::u256::U256",
                                  [ Ty.path "move_core_types::u256::U256" ],
                                  "rem",
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.path "move_core_types::u256::U256",
                                      "one",
                                      []
                                    |),
                                    []
                                  |);
                                  M.read (| range |)
                                ]
                              |)
                            ]
                          |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "move_core_types::u256::U256",
                              "zero",
                              []
                            |),
                            []
                          |)
                        |)))
                  ]
                |)
              |) in
            M.alloc (|
              Value.StructRecord
                "move_core_types::u256::UniformU256"
                [
                  ("low", M.read (| low |));
                  ("range", M.read (| range |));
                  ("z", M.read (| ints_to_reject |))
                ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    (*
        fn sample<R: rand::Rng + ?Sized>(&self, rng: &mut R) -> Self::X {
            let range = self.range;
            if range > U256::zero() {
                let unsigned_max = U256::max_value();
                let zone = unsigned_max - self.z;
                loop {
                    let v: U256 = rng.gen();
                    let (hi, lo) = v.wmul(range);
                    if lo <= zone {
                        return self.low.wrapping_add(hi);
                    }
                }
            } else {
                // Sample from the entire integer range.
                rng.gen()
            }
        }
    *)
    Definition sample (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ R ], [ self; rng ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rng := M.alloc (| rng |) in
          M.read (|
            let range :=
              M.copy (|
                M.get_struct_record_field
                  (M.read (| self |))
                  "move_core_types::u256::UniformU256"
                  "range"
              |) in
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::cmp::PartialOrd",
                              Ty.path "move_core_types::u256::U256",
                              [ Ty.path "move_core_types::u256::U256" ],
                              "gt",
                              []
                            |),
                            [
                              range;
                              M.alloc (|
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.path "move_core_types::u256::U256",
                                    "zero",
                                    []
                                  |),
                                  []
                                |)
                              |)
                            ]
                          |)
                        |)) in
                    let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    let unsigned_max :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.path "move_core_types::u256::U256",
                            "max_value",
                            []
                          |),
                          []
                        |)
                      |) in
                    let zone :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::ops::arith::Sub",
                            Ty.path "move_core_types::u256::U256",
                            [ Ty.path "move_core_types::u256::U256" ],
                            "sub",
                            []
                          |),
                          [
                            M.read (| unsigned_max |);
                            M.read (|
                              M.get_struct_record_field
                                (M.read (| self |))
                                "move_core_types::u256::UniformU256"
                                "z"
                            |)
                          ]
                        |)
                      |) in
                    M.alloc (|
                      M.never_to_any (|
                        M.read (|
                          M.loop (|
                            ltac:(M.monadic
                              (let v :=
                                M.alloc (|
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "rand::rng::Rng",
                                      R,
                                      [],
                                      "gen",
                                      [ Ty.path "move_core_types::u256::U256" ]
                                    |),
                                    [ M.read (| rng |) ]
                                  |)
                                |) in
                              M.match_operator (|
                                M.alloc (|
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.path "move_core_types::u256::U256",
                                      "wmul",
                                      []
                                    |),
                                    [ M.read (| v |); M.read (| range |) ]
                                  |)
                                |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ0_0 := M.get_tuple_field γ 0 in
                                      let γ0_1 := M.get_tuple_field γ 1 in
                                      let hi := M.copy (| γ0_0 |) in
                                      let lo := M.copy (| γ0_1 |) in
                                      M.match_operator (|
                                        M.alloc (| Value.Tuple [] |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let γ :=
                                                M.use
                                                  (M.alloc (|
                                                    M.call_closure (|
                                                      M.get_trait_method (|
                                                        "core::cmp::PartialOrd",
                                                        Ty.path "move_core_types::u256::U256",
                                                        [ Ty.path "move_core_types::u256::U256" ],
                                                        "le",
                                                        []
                                                      |),
                                                      [ lo; zone ]
                                                    |)
                                                  |)) in
                                              let _ :=
                                                M.is_constant_or_break_match (|
                                                  M.read (| γ |),
                                                  Value.Bool true
                                                |) in
                                              M.alloc (|
                                                M.never_to_any (|
                                                  M.read (|
                                                    M.return_ (|
                                                      M.call_closure (|
                                                        M.get_associated_function (|
                                                          Ty.path "move_core_types::u256::U256",
                                                          "wrapping_add",
                                                          []
                                                        |),
                                                        [
                                                          M.read (|
                                                            M.get_struct_record_field
                                                              (M.read (| self |))
                                                              "move_core_types::u256::UniformU256"
                                                              "low"
                                                          |);
                                                          M.read (| hi |)
                                                        ]
                                                      |)
                                                    |)
                                                  |)
                                                |)
                                              |)));
                                          fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                        ]
                                      |)))
                                ]
                              |)))
                          |)
                        |)
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "rand::rng::Rng",
                          R,
                          [],
                          "gen",
                          [ Ty.path "move_core_types::u256::U256" ]
                        |),
                        [ M.read (| rng |) ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    (*
        fn sample_single<R: rand::Rng + ?Sized, B1, B2>(low: B1, high: B2, rng: &mut R) -> Self::X
        where
            B1: rand::distributions::uniform::SampleBorrow<Self::X> + Sized,
            B2: rand::distributions::uniform::SampleBorrow<Self::X> + Sized,
        {
            let low = *low.borrow();
            let high = *high.borrow();
            assert!(low < high, "UniformSampler::sample_single: low >= high");
            Self::sample_single_inclusive(low, high - U256::one(), rng)
        }
    *)
    Definition sample_single (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ R; B1; B2 ], [ low; high; rng ] =>
        ltac:(M.monadic
          (let low := M.alloc (| low |) in
          let high := M.alloc (| high |) in
          let rng := M.alloc (| rng |) in
          M.read (|
            let low :=
              M.copy (|
                M.call_closure (|
                  M.get_trait_method (|
                    "rand::distributions::uniform::SampleBorrow",
                    B1,
                    [ Ty.path "move_core_types::u256::U256" ],
                    "borrow",
                    []
                  |),
                  [ low ]
                |)
              |) in
            let high :=
              M.copy (|
                M.call_closure (|
                  M.get_trait_method (|
                    "rand::distributions::uniform::SampleBorrow",
                    B2,
                    [ Ty.path "move_core_types::u256::U256" ],
                    "borrow",
                    []
                  |),
                  [ high ]
                |)
              |) in
            let _ :=
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            UnOp.Pure.not
                              (M.call_closure (|
                                M.get_trait_method (|
                                  "core::cmp::PartialOrd",
                                  Ty.path "move_core_types::u256::U256",
                                  [ Ty.path "move_core_types::u256::U256" ],
                                  "lt",
                                  []
                                |),
                                [ low; high ]
                              |))
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        M.never_to_any (|
                          M.call_closure (|
                            M.get_function (| "core::panicking::panic_fmt", [] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::fmt::Arguments",
                                  "new_const",
                                  []
                                |),
                                [
                                  (* Unsize *)
                                  M.pointer_coercion
                                    (M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            mk_str "UniformSampler::sample_single: low >= high"
                                          |)
                                        ]
                                    |))
                                ]
                              |)
                            ]
                          |)
                        |)
                      |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            M.alloc (|
              M.call_closure (|
                M.get_trait_method (|
                  "rand::distributions::uniform::UniformSampler",
                  Ty.path "move_core_types::u256::UniformU256",
                  [],
                  "sample_single_inclusive",
                  [ R; Ty.path "move_core_types::u256::U256"; Ty.path "move_core_types::u256::U256"
                  ]
                |),
                [
                  M.read (| low |);
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::arith::Sub",
                      Ty.path "move_core_types::u256::U256",
                      [ Ty.path "move_core_types::u256::U256" ],
                      "sub",
                      []
                    |),
                    [
                      M.read (| high |);
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "move_core_types::u256::U256",
                          "one",
                          []
                        |),
                        []
                      |)
                    ]
                  |);
                  M.read (| rng |)
                ]
              |)
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    (*
        fn sample_single_inclusive<R: rand::Rng + ?Sized, B1, B2>(
            low: B1,
            high: B2,
            rng: &mut R,
        ) -> Self::X
        where
            B1: rand::distributions::uniform::SampleBorrow<Self::X> + Sized,
            B2: rand::distributions::uniform::SampleBorrow<Self::X> + Sized,
        {
            let low = *low.borrow();
            let high = *high.borrow();
            assert!(
                low <= high,
                "UniformSampler::sample_single_inclusive: low > high"
            );
            let range = high.wrapping_sub(low).wrapping_add(U256::one());
            // If the above resulted in wrap-around to 0, the range is U256::MIN..=U256::MAX,
            // and any integer will do.
            if range == U256::zero() {
                return rng.gen();
            }
            // conservative but fast approximation. `- 1` is necessary to allow the
            // same comparison without bias.
            let zone = (range << range.leading_zeros()).wrapping_sub(U256::one());
    
            loop {
                let v: U256 = rng.gen();
                let (hi, lo) = v.wmul(range);
                if lo <= zone {
                    return low.wrapping_add(hi);
                }
            }
        }
    *)
    Definition sample_single_inclusive (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ R; B1; B2 ], [ low; high; rng ] =>
        ltac:(M.monadic
          (let low := M.alloc (| low |) in
          let high := M.alloc (| high |) in
          let rng := M.alloc (| rng |) in
          M.read (|
            let low :=
              M.copy (|
                M.call_closure (|
                  M.get_trait_method (|
                    "rand::distributions::uniform::SampleBorrow",
                    B1,
                    [ Ty.path "move_core_types::u256::U256" ],
                    "borrow",
                    []
                  |),
                  [ low ]
                |)
              |) in
            let high :=
              M.copy (|
                M.call_closure (|
                  M.get_trait_method (|
                    "rand::distributions::uniform::SampleBorrow",
                    B2,
                    [ Ty.path "move_core_types::u256::U256" ],
                    "borrow",
                    []
                  |),
                  [ high ]
                |)
              |) in
            let _ :=
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            UnOp.Pure.not
                              (M.call_closure (|
                                M.get_trait_method (|
                                  "core::cmp::PartialOrd",
                                  Ty.path "move_core_types::u256::U256",
                                  [ Ty.path "move_core_types::u256::U256" ],
                                  "le",
                                  []
                                |),
                                [ low; high ]
                              |))
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        M.never_to_any (|
                          M.call_closure (|
                            M.get_function (| "core::panicking::panic_fmt", [] |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::fmt::Arguments",
                                  "new_const",
                                  []
                                |),
                                [
                                  (* Unsize *)
                                  M.pointer_coercion
                                    (M.alloc (|
                                      Value.Array
                                        [
                                          M.read (|
                                            mk_str
                                              "UniformSampler::sample_single_inclusive: low > high"
                                          |)
                                        ]
                                    |))
                                ]
                              |)
                            ]
                          |)
                        |)
                      |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            let range :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.path "move_core_types::u256::U256",
                    "wrapping_add",
                    []
                  |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "move_core_types::u256::U256",
                        "wrapping_sub",
                        []
                      |),
                      [ M.read (| high |); M.read (| low |) ]
                    |);
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "move_core_types::u256::U256",
                        "one",
                        []
                      |),
                      []
                    |)
                  ]
                |)
              |) in
            let _ :=
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::cmp::PartialEq",
                                Ty.path "move_core_types::u256::U256",
                                [ Ty.path "move_core_types::u256::U256" ],
                                "eq",
                                []
                              |),
                              [
                                range;
                                M.alloc (|
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.path "move_core_types::u256::U256",
                                      "zero",
                                      []
                                    |),
                                    []
                                  |)
                                |)
                              ]
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        M.never_to_any (|
                          M.read (|
                            M.return_ (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "rand::rng::Rng",
                                  R,
                                  [],
                                  "gen",
                                  [ Ty.path "move_core_types::u256::U256" ]
                                |),
                                [ M.read (| rng |) ]
                              |)
                            |)
                          |)
                        |)
                      |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            let zone :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.path "move_core_types::u256::U256",
                    "wrapping_sub",
                    []
                  |),
                  [
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::ops::bit::Shl",
                        Ty.path "move_core_types::u256::U256",
                        [ Ty.path "u32" ],
                        "shl",
                        []
                      |),
                      [
                        M.read (| range |);
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.path "move_core_types::u256::U256",
                            "leading_zeros",
                            []
                          |),
                          [ range ]
                        |)
                      ]
                    |);
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "move_core_types::u256::U256",
                        "one",
                        []
                      |),
                      []
                    |)
                  ]
                |)
              |) in
            M.alloc (|
              M.never_to_any (|
                M.read (|
                  M.loop (|
                    ltac:(M.monadic
                      (let v :=
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (|
                              "rand::rng::Rng",
                              R,
                              [],
                              "gen",
                              [ Ty.path "move_core_types::u256::U256" ]
                            |),
                            [ M.read (| rng |) ]
                          |)
                        |) in
                      M.match_operator (|
                        M.alloc (|
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "move_core_types::u256::U256",
                              "wmul",
                              []
                            |),
                            [ M.read (| v |); M.read (| range |) ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 := M.get_tuple_field γ 0 in
                              let γ0_1 := M.get_tuple_field γ 1 in
                              let hi := M.copy (| γ0_0 |) in
                              let lo := M.copy (| γ0_1 |) in
                              M.match_operator (|
                                M.alloc (| Value.Tuple [] |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ :=
                                        M.use
                                          (M.alloc (|
                                            M.call_closure (|
                                              M.get_trait_method (|
                                                "core::cmp::PartialOrd",
                                                Ty.path "move_core_types::u256::U256",
                                                [ Ty.path "move_core_types::u256::U256" ],
                                                "le",
                                                []
                                              |),
                                              [ lo; zone ]
                                            |)
                                          |)) in
                                      let _ :=
                                        M.is_constant_or_break_match (|
                                          M.read (| γ |),
                                          Value.Bool true
                                        |) in
                                      M.alloc (|
                                        M.never_to_any (|
                                          M.read (|
                                            M.return_ (|
                                              M.call_closure (|
                                                M.get_associated_function (|
                                                  Ty.path "move_core_types::u256::U256",
                                                  "wrapping_add",
                                                  []
                                                |),
                                                [ M.read (| low |); M.read (| hi |) ]
                                              |)
                                            |)
                                          |)
                                        |)
                                      |)));
                                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                ]
                              |)))
                        ]
                      |)))
                  |)
                |)
              |)
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "rand::distributions::uniform::UniformSampler"
        Self
        (* Trait polymorphic types *) []
        (* Instance *)
        [
          ("X", InstanceField.Ty _X);
          ("new", InstanceField.Method new);
          ("new_inclusive", InstanceField.Method new_inclusive);
          ("sample", InstanceField.Method sample);
          ("sample_single", InstanceField.Method sample_single);
          ("sample_single_inclusive", InstanceField.Method sample_single_inclusive)
        ].
  End Impl_rand_distributions_uniform_UniformSampler_for_move_core_types_u256_UniformU256.
End u256.

Module value.
  Definition value_MOVE_STRUCT_NAME : Value.t := M.run ltac:(M.monadic (mk_str "struct")).
  
  Definition value_MOVE_STRUCT_TYPE : Value.t := M.run ltac:(M.monadic (mk_str "type")).
  
  Definition value_MOVE_STRUCT_FIELDS : Value.t := M.run ltac:(M.monadic (mk_str "fields")).
  
  (*
  Enum MoveStruct
  {
    ty_params := [];
    variants :=
      [
        {
          name := "Runtime";
          item :=
            StructTuple
              [
                Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  [ Ty.path "move_core_types::value::MoveValue"; Ty.path "alloc::alloc::Global" ]
              ];
          discriminant := None;
        };
        {
          name := "WithFields";
          item :=
            StructTuple
              [
                Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  [
                    Ty.tuple
                      [
                        Ty.path "move_core_types::identifier::Identifier";
                        Ty.path "move_core_types::value::MoveValue"
                      ];
                    Ty.path "alloc::alloc::Global"
                  ]
              ];
          discriminant := None;
        };
        {
          name := "WithTypes";
          item :=
            StructRecord
              [
                ("type_", Ty.path "move_core_types::language_storage::StructTag");
                ("fields",
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    [
                      Ty.tuple
                        [
                          Ty.path "move_core_types::identifier::Identifier";
                          Ty.path "move_core_types::value::MoveValue"
                        ];
                      Ty.path "alloc::alloc::Global"
                    ])
              ];
          discriminant := None;
        }
      ];
  }
  *)
  
  Module Impl_core_fmt_Debug_for_move_core_types_value_MoveStruct.
    Definition Self : Ty.t := Ty.path "move_core_types::value::MoveStruct".
    
    (* Debug *)
    Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::value::MoveStruct::Runtime",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_tuple_field1_finish",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.read (| mk_str "Runtime" |);
                          (* Unsize *) M.pointer_coercion __self_0
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::value::MoveStruct::WithFields",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_tuple_field1_finish",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.read (| mk_str "WithFields" |);
                          (* Unsize *) M.pointer_coercion __self_0
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_record_field_or_break_match (|
                        γ,
                        "move_core_types::value::MoveStruct::WithTypes",
                        "type_"
                      |) in
                    let γ1_1 :=
                      M.get_struct_record_field_or_break_match (|
                        γ,
                        "move_core_types::value::MoveStruct::WithTypes",
                        "fields"
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    let __self_1 := M.alloc (| γ1_1 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_struct_field2_finish",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.read (| mk_str "WithTypes" |);
                          M.read (| mk_str "type_" |);
                          (* Unsize *) M.pointer_coercion (M.read (| __self_0 |));
                          M.read (| mk_str "fields" |);
                          (* Unsize *) M.pointer_coercion __self_1
                        ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_move_core_types_value_MoveStruct.
  
  Module Impl_core_marker_StructuralPartialEq_for_move_core_types_value_MoveStruct.
    Definition Self : Ty.t := Ty.path "move_core_types::value::MoveStruct".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_move_core_types_value_MoveStruct.
  
  Module Impl_core_cmp_PartialEq_for_move_core_types_value_MoveStruct.
    Definition Self : Ty.t := Ty.path "move_core_types::value::MoveStruct".
    
    (* PartialEq *)
    Definition eq (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            let __self_tag :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [ Ty.path "move_core_types::value::MoveStruct" ]
                  |),
                  [ M.read (| self |) ]
                |)
              |) in
            let __arg1_tag :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [ Ty.path "move_core_types::value::MoveStruct" ]
                  |),
                  [ M.read (| other |) ]
                |)
              |) in
            M.alloc (|
              LogicalOp.and (|
                BinOp.Pure.eq (M.read (| __self_tag |)) (M.read (| __arg1_tag |)),
                ltac:(M.monadic
                  (M.read (|
                    M.match_operator (|
                      M.alloc (| Value.Tuple [ M.read (| self |); M.read (| other |) ] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.get_tuple_field γ 0 in
                            let γ0_1 := M.get_tuple_field γ 1 in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ0_0,
                                "move_core_types::value::MoveStruct::Runtime",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ0_1,
                                "move_core_types::value::MoveStruct::Runtime",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.apply
                                    (Ty.path "alloc::vec::Vec")
                                    [
                                      Ty.path "move_core_types::value::MoveValue";
                                      Ty.path "alloc::alloc::Global"
                                    ],
                                  [
                                    Ty.apply
                                      (Ty.path "alloc::vec::Vec")
                                      [
                                        Ty.path "move_core_types::value::MoveValue";
                                        Ty.path "alloc::alloc::Global"
                                      ]
                                  ],
                                  "eq",
                                  []
                                |),
                                [ M.read (| __self_0 |); M.read (| __arg1_0 |) ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.get_tuple_field γ 0 in
                            let γ0_1 := M.get_tuple_field γ 1 in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ0_0,
                                "move_core_types::value::MoveStruct::WithFields",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ0_1,
                                "move_core_types::value::MoveStruct::WithFields",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.apply
                                    (Ty.path "alloc::vec::Vec")
                                    [
                                      Ty.tuple
                                        [
                                          Ty.path "move_core_types::identifier::Identifier";
                                          Ty.path "move_core_types::value::MoveValue"
                                        ];
                                      Ty.path "alloc::alloc::Global"
                                    ],
                                  [
                                    Ty.apply
                                      (Ty.path "alloc::vec::Vec")
                                      [
                                        Ty.tuple
                                          [
                                            Ty.path "move_core_types::identifier::Identifier";
                                            Ty.path "move_core_types::value::MoveValue"
                                          ];
                                        Ty.path "alloc::alloc::Global"
                                      ]
                                  ],
                                  "eq",
                                  []
                                |),
                                [ M.read (| __self_0 |); M.read (| __arg1_0 |) ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.get_tuple_field γ 0 in
                            let γ0_1 := M.get_tuple_field γ 1 in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.get_struct_record_field_or_break_match (|
                                γ0_0,
                                "move_core_types::value::MoveStruct::WithTypes",
                                "type_"
                              |) in
                            let γ2_1 :=
                              M.get_struct_record_field_or_break_match (|
                                γ0_0,
                                "move_core_types::value::MoveStruct::WithTypes",
                                "fields"
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let __self_1 := M.alloc (| γ2_1 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.get_struct_record_field_or_break_match (|
                                γ0_1,
                                "move_core_types::value::MoveStruct::WithTypes",
                                "type_"
                              |) in
                            let γ2_1 :=
                              M.get_struct_record_field_or_break_match (|
                                γ0_1,
                                "move_core_types::value::MoveStruct::WithTypes",
                                "fields"
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            let __arg1_1 := M.alloc (| γ2_1 |) in
                            M.alloc (|
                              LogicalOp.and (|
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::cmp::PartialEq",
                                    Ty.path "move_core_types::language_storage::StructTag",
                                    [ Ty.path "move_core_types::language_storage::StructTag" ],
                                    "eq",
                                    []
                                  |),
                                  [ M.read (| __self_0 |); M.read (| __arg1_0 |) ]
                                |),
                                ltac:(M.monadic
                                  (M.call_closure (|
                                    M.get_trait_method (|
                                      "core::cmp::PartialEq",
                                      Ty.apply
                                        (Ty.path "alloc::vec::Vec")
                                        [
                                          Ty.tuple
                                            [
                                              Ty.path "move_core_types::identifier::Identifier";
                                              Ty.path "move_core_types::value::MoveValue"
                                            ];
                                          Ty.path "alloc::alloc::Global"
                                        ],
                                      [
                                        Ty.apply
                                          (Ty.path "alloc::vec::Vec")
                                          [
                                            Ty.tuple
                                              [
                                                Ty.path "move_core_types::identifier::Identifier";
                                                Ty.path "move_core_types::value::MoveValue"
                                              ];
                                            Ty.path "alloc::alloc::Global"
                                          ]
                                      ],
                                      "eq",
                                      []
                                    |),
                                    [ M.read (| __self_1 |); M.read (| __arg1_1 |) ]
                                  |)))
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              M.never_to_any (|
                                M.call_closure (|
                                  M.get_function (| "core::intrinsics::unreachable", [] |),
                                  []
                                |)
                              |)
                            |)))
                      ]
                    |)
                  |)))
              |)
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_for_move_core_types_value_MoveStruct.
  
  Module Impl_core_marker_StructuralEq_for_move_core_types_value_MoveStruct.
    Definition Self : Ty.t := Ty.path "move_core_types::value::MoveStruct".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralEq_for_move_core_types_value_MoveStruct.
  
  Module Impl_core_cmp_Eq_for_move_core_types_value_MoveStruct.
    Definition Self : Ty.t := Ty.path "move_core_types::value::MoveStruct".
    
    (* Eq *)
    Definition assert_receiver_is_total_eq (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Value.DeclaredButUndefined,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      Value.DeclaredButUndefined,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              Value.DeclaredButUndefined,
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (M.match_operator (|
                                      Value.DeclaredButUndefined,
                                      [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                                    |)))
                              ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_move_core_types_value_MoveStruct.
  
  Module Impl_core_clone_Clone_for_move_core_types_value_MoveStruct.
    Definition Self : Ty.t := Ty.path "move_core_types::value::MoveStruct".
    
    (* Clone *)
    Definition clone (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::value::MoveStruct::Runtime",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_core_types::value::MoveStruct::Runtime"
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                [
                                  Ty.path "move_core_types::value::MoveValue";
                                  Ty.path "alloc::alloc::Global"
                                ],
                              [],
                              "clone",
                              []
                            |),
                            [ M.read (| __self_0 |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::value::MoveStruct::WithFields",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_core_types::value::MoveStruct::WithFields"
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                [
                                  Ty.tuple
                                    [
                                      Ty.path "move_core_types::identifier::Identifier";
                                      Ty.path "move_core_types::value::MoveValue"
                                    ];
                                  Ty.path "alloc::alloc::Global"
                                ],
                              [],
                              "clone",
                              []
                            |),
                            [ M.read (| __self_0 |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_record_field_or_break_match (|
                        γ,
                        "move_core_types::value::MoveStruct::WithTypes",
                        "type_"
                      |) in
                    let γ1_1 :=
                      M.get_struct_record_field_or_break_match (|
                        γ,
                        "move_core_types::value::MoveStruct::WithTypes",
                        "fields"
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    let __self_1 := M.alloc (| γ1_1 |) in
                    M.alloc (|
                      Value.StructRecord
                        "move_core_types::value::MoveStruct::WithTypes"
                        [
                          ("type_",
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::clone::Clone",
                                Ty.path "move_core_types::language_storage::StructTag",
                                [],
                                "clone",
                                []
                              |),
                              [ M.read (| __self_0 |) ]
                            |));
                          ("fields",
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::clone::Clone",
                                Ty.apply
                                  (Ty.path "alloc::vec::Vec")
                                  [
                                    Ty.tuple
                                      [
                                        Ty.path "move_core_types::identifier::Identifier";
                                        Ty.path "move_core_types::value::MoveValue"
                                      ];
                                    Ty.path "alloc::alloc::Global"
                                  ],
                                [],
                                "clone",
                                []
                              |),
                              [ M.read (| __self_1 |) ]
                            |))
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_move_core_types_value_MoveStruct.
  
  (*
  Enum MoveValue
  {
    ty_params := [];
    variants :=
      [
        {
          name := "U8";
          item := StructTuple [ Ty.path "u8" ];
          discriminant := None;
        };
        {
          name := "U64";
          item := StructTuple [ Ty.path "u64" ];
          discriminant := None;
        };
        {
          name := "U128";
          item := StructTuple [ Ty.path "u128" ];
          discriminant := None;
        };
        {
          name := "Bool";
          item := StructTuple [ Ty.path "bool" ];
          discriminant := None;
        };
        {
          name := "Address";
          item := StructTuple [ Ty.path "move_core_types::account_address::AccountAddress" ];
          discriminant := None;
        };
        {
          name := "Vector";
          item :=
            StructTuple
              [
                Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  [ Ty.path "move_core_types::value::MoveValue"; Ty.path "alloc::alloc::Global" ]
              ];
          discriminant := None;
        };
        {
          name := "Struct";
          item := StructTuple [ Ty.path "move_core_types::value::MoveStruct" ];
          discriminant := None;
        };
        {
          name := "Signer";
          item := StructTuple [ Ty.path "move_core_types::account_address::AccountAddress" ];
          discriminant := None;
        };
        {
          name := "U16";
          item := StructTuple [ Ty.path "u16" ];
          discriminant := None;
        };
        {
          name := "U32";
          item := StructTuple [ Ty.path "u32" ];
          discriminant := None;
        };
        {
          name := "U256";
          item := StructTuple [ Ty.path "move_core_types::u256::U256" ];
          discriminant := None;
        }
      ];
  }
  *)
  
  Module Impl_core_fmt_Debug_for_move_core_types_value_MoveValue.
    Definition Self : Ty.t := Ty.path "move_core_types::value::MoveValue".
    
    (* Debug *)
    Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::value::MoveValue::U8",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_tuple_field1_finish",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.read (| mk_str "U8" |);
                          (* Unsize *) M.pointer_coercion __self_0
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::value::MoveValue::U64",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_tuple_field1_finish",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.read (| mk_str "U64" |);
                          (* Unsize *) M.pointer_coercion __self_0
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::value::MoveValue::U128",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_tuple_field1_finish",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.read (| mk_str "U128" |);
                          (* Unsize *) M.pointer_coercion __self_0
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::value::MoveValue::Bool",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_tuple_field1_finish",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.read (| mk_str "Bool" |);
                          (* Unsize *) M.pointer_coercion __self_0
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::value::MoveValue::Address",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_tuple_field1_finish",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.read (| mk_str "Address" |);
                          (* Unsize *) M.pointer_coercion __self_0
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::value::MoveValue::Vector",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_tuple_field1_finish",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.read (| mk_str "Vector" |);
                          (* Unsize *) M.pointer_coercion __self_0
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::value::MoveValue::Struct",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_tuple_field1_finish",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.read (| mk_str "Struct" |);
                          (* Unsize *) M.pointer_coercion __self_0
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::value::MoveValue::Signer",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_tuple_field1_finish",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.read (| mk_str "Signer" |);
                          (* Unsize *) M.pointer_coercion __self_0
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::value::MoveValue::U16",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_tuple_field1_finish",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.read (| mk_str "U16" |);
                          (* Unsize *) M.pointer_coercion __self_0
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::value::MoveValue::U32",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_tuple_field1_finish",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.read (| mk_str "U32" |);
                          (* Unsize *) M.pointer_coercion __self_0
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::value::MoveValue::U256",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_tuple_field1_finish",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.read (| mk_str "U256" |);
                          (* Unsize *) M.pointer_coercion __self_0
                        ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_move_core_types_value_MoveValue.
  
  Module Impl_core_marker_StructuralPartialEq_for_move_core_types_value_MoveValue.
    Definition Self : Ty.t := Ty.path "move_core_types::value::MoveValue".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_move_core_types_value_MoveValue.
  
  Module Impl_core_cmp_PartialEq_for_move_core_types_value_MoveValue.
    Definition Self : Ty.t := Ty.path "move_core_types::value::MoveValue".
    
    (* PartialEq *)
    Definition eq (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            let __self_tag :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [ Ty.path "move_core_types::value::MoveValue" ]
                  |),
                  [ M.read (| self |) ]
                |)
              |) in
            let __arg1_tag :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [ Ty.path "move_core_types::value::MoveValue" ]
                  |),
                  [ M.read (| other |) ]
                |)
              |) in
            M.alloc (|
              LogicalOp.and (|
                BinOp.Pure.eq (M.read (| __self_tag |)) (M.read (| __arg1_tag |)),
                ltac:(M.monadic
                  (M.read (|
                    M.match_operator (|
                      M.alloc (| Value.Tuple [ M.read (| self |); M.read (| other |) ] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.get_tuple_field γ 0 in
                            let γ0_1 := M.get_tuple_field γ 1 in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ0_0,
                                "move_core_types::value::MoveValue::U8",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ0_1,
                                "move_core_types::value::MoveValue::U8",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              BinOp.Pure.eq
                                (M.read (| M.read (| __self_0 |) |))
                                (M.read (| M.read (| __arg1_0 |) |))
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.get_tuple_field γ 0 in
                            let γ0_1 := M.get_tuple_field γ 1 in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ0_0,
                                "move_core_types::value::MoveValue::U64",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ0_1,
                                "move_core_types::value::MoveValue::U64",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              BinOp.Pure.eq
                                (M.read (| M.read (| __self_0 |) |))
                                (M.read (| M.read (| __arg1_0 |) |))
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.get_tuple_field γ 0 in
                            let γ0_1 := M.get_tuple_field γ 1 in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ0_0,
                                "move_core_types::value::MoveValue::U128",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ0_1,
                                "move_core_types::value::MoveValue::U128",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              BinOp.Pure.eq
                                (M.read (| M.read (| __self_0 |) |))
                                (M.read (| M.read (| __arg1_0 |) |))
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.get_tuple_field γ 0 in
                            let γ0_1 := M.get_tuple_field γ 1 in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ0_0,
                                "move_core_types::value::MoveValue::Bool",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ0_1,
                                "move_core_types::value::MoveValue::Bool",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              BinOp.Pure.eq
                                (M.read (| M.read (| __self_0 |) |))
                                (M.read (| M.read (| __arg1_0 |) |))
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.get_tuple_field γ 0 in
                            let γ0_1 := M.get_tuple_field γ 1 in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ0_0,
                                "move_core_types::value::MoveValue::Address",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ0_1,
                                "move_core_types::value::MoveValue::Address",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.path "move_core_types::account_address::AccountAddress",
                                  [ Ty.path "move_core_types::account_address::AccountAddress" ],
                                  "eq",
                                  []
                                |),
                                [ M.read (| __self_0 |); M.read (| __arg1_0 |) ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.get_tuple_field γ 0 in
                            let γ0_1 := M.get_tuple_field γ 1 in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ0_0,
                                "move_core_types::value::MoveValue::Vector",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ0_1,
                                "move_core_types::value::MoveValue::Vector",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.apply
                                    (Ty.path "alloc::vec::Vec")
                                    [
                                      Ty.path "move_core_types::value::MoveValue";
                                      Ty.path "alloc::alloc::Global"
                                    ],
                                  [
                                    Ty.apply
                                      (Ty.path "alloc::vec::Vec")
                                      [
                                        Ty.path "move_core_types::value::MoveValue";
                                        Ty.path "alloc::alloc::Global"
                                      ]
                                  ],
                                  "eq",
                                  []
                                |),
                                [ M.read (| __self_0 |); M.read (| __arg1_0 |) ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.get_tuple_field γ 0 in
                            let γ0_1 := M.get_tuple_field γ 1 in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ0_0,
                                "move_core_types::value::MoveValue::Struct",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ0_1,
                                "move_core_types::value::MoveValue::Struct",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.path "move_core_types::value::MoveStruct",
                                  [ Ty.path "move_core_types::value::MoveStruct" ],
                                  "eq",
                                  []
                                |),
                                [ M.read (| __self_0 |); M.read (| __arg1_0 |) ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.get_tuple_field γ 0 in
                            let γ0_1 := M.get_tuple_field γ 1 in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ0_0,
                                "move_core_types::value::MoveValue::Signer",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ0_1,
                                "move_core_types::value::MoveValue::Signer",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.path "move_core_types::account_address::AccountAddress",
                                  [ Ty.path "move_core_types::account_address::AccountAddress" ],
                                  "eq",
                                  []
                                |),
                                [ M.read (| __self_0 |); M.read (| __arg1_0 |) ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.get_tuple_field γ 0 in
                            let γ0_1 := M.get_tuple_field γ 1 in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ0_0,
                                "move_core_types::value::MoveValue::U16",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ0_1,
                                "move_core_types::value::MoveValue::U16",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              BinOp.Pure.eq
                                (M.read (| M.read (| __self_0 |) |))
                                (M.read (| M.read (| __arg1_0 |) |))
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.get_tuple_field γ 0 in
                            let γ0_1 := M.get_tuple_field γ 1 in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ0_0,
                                "move_core_types::value::MoveValue::U32",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ0_1,
                                "move_core_types::value::MoveValue::U32",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              BinOp.Pure.eq
                                (M.read (| M.read (| __self_0 |) |))
                                (M.read (| M.read (| __arg1_0 |) |))
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.get_tuple_field γ 0 in
                            let γ0_1 := M.get_tuple_field γ 1 in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ0_0,
                                "move_core_types::value::MoveValue::U256",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ0_1,
                                "move_core_types::value::MoveValue::U256",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.path "move_core_types::u256::U256",
                                  [ Ty.path "move_core_types::u256::U256" ],
                                  "eq",
                                  []
                                |),
                                [ M.read (| __self_0 |); M.read (| __arg1_0 |) ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              M.never_to_any (|
                                M.call_closure (|
                                  M.get_function (| "core::intrinsics::unreachable", [] |),
                                  []
                                |)
                              |)
                            |)))
                      ]
                    |)
                  |)))
              |)
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_for_move_core_types_value_MoveValue.
  
  Module Impl_core_marker_StructuralEq_for_move_core_types_value_MoveValue.
    Definition Self : Ty.t := Ty.path "move_core_types::value::MoveValue".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralEq_for_move_core_types_value_MoveValue.
  
  Module Impl_core_cmp_Eq_for_move_core_types_value_MoveValue.
    Definition Self : Ty.t := Ty.path "move_core_types::value::MoveValue".
    
    (* Eq *)
    Definition assert_receiver_is_total_eq (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Value.DeclaredButUndefined,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      Value.DeclaredButUndefined,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              Value.DeclaredButUndefined,
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (M.match_operator (|
                                      Value.DeclaredButUndefined,
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (M.match_operator (|
                                              Value.DeclaredButUndefined,
                                              [
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (M.match_operator (|
                                                      Value.DeclaredButUndefined,
                                                      [
                                                        fun γ =>
                                                          ltac:(M.monadic
                                                            (M.match_operator (|
                                                              Value.DeclaredButUndefined,
                                                              [
                                                                fun γ =>
                                                                  ltac:(M.monadic
                                                                    (M.match_operator (|
                                                                      Value.DeclaredButUndefined,
                                                                      [
                                                                        fun γ =>
                                                                          ltac:(M.monadic
                                                                            (M.match_operator (|
                                                                              Value.DeclaredButUndefined,
                                                                              [
                                                                                fun γ =>
                                                                                  ltac:(M.monadic
                                                                                    (M.match_operator (|
                                                                                      Value.DeclaredButUndefined,
                                                                                      [
                                                                                        fun γ =>
                                                                                          ltac:(M.monadic
                                                                                            (M.alloc (|
                                                                                              Value.Tuple
                                                                                                []
                                                                                            |)))
                                                                                      ]
                                                                                    |)))
                                                                              ]
                                                                            |)))
                                                                      ]
                                                                    |)))
                                                              ]
                                                            |)))
                                                      ]
                                                    |)))
                                              ]
                                            |)))
                                      ]
                                    |)))
                              ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_move_core_types_value_MoveValue.
  
  Module Impl_core_clone_Clone_for_move_core_types_value_MoveValue.
    Definition Self : Ty.t := Ty.path "move_core_types::value::MoveValue".
    
    (* Clone *)
    Definition clone (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::value::MoveValue::U8",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_core_types::value::MoveValue::U8"
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.path "u8",
                              [],
                              "clone",
                              []
                            |),
                            [ M.read (| __self_0 |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::value::MoveValue::U64",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_core_types::value::MoveValue::U64"
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.path "u64",
                              [],
                              "clone",
                              []
                            |),
                            [ M.read (| __self_0 |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::value::MoveValue::U128",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_core_types::value::MoveValue::U128"
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.path "u128",
                              [],
                              "clone",
                              []
                            |),
                            [ M.read (| __self_0 |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::value::MoveValue::Bool",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_core_types::value::MoveValue::Bool"
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.path "bool",
                              [],
                              "clone",
                              []
                            |),
                            [ M.read (| __self_0 |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::value::MoveValue::Address",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_core_types::value::MoveValue::Address"
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.path "move_core_types::account_address::AccountAddress",
                              [],
                              "clone",
                              []
                            |),
                            [ M.read (| __self_0 |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::value::MoveValue::Vector",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_core_types::value::MoveValue::Vector"
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                [
                                  Ty.path "move_core_types::value::MoveValue";
                                  Ty.path "alloc::alloc::Global"
                                ],
                              [],
                              "clone",
                              []
                            |),
                            [ M.read (| __self_0 |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::value::MoveValue::Struct",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_core_types::value::MoveValue::Struct"
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.path "move_core_types::value::MoveStruct",
                              [],
                              "clone",
                              []
                            |),
                            [ M.read (| __self_0 |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::value::MoveValue::Signer",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_core_types::value::MoveValue::Signer"
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.path "move_core_types::account_address::AccountAddress",
                              [],
                              "clone",
                              []
                            |),
                            [ M.read (| __self_0 |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::value::MoveValue::U16",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_core_types::value::MoveValue::U16"
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.path "u16",
                              [],
                              "clone",
                              []
                            |),
                            [ M.read (| __self_0 |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::value::MoveValue::U32",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_core_types::value::MoveValue::U32"
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.path "u32",
                              [],
                              "clone",
                              []
                            |),
                            [ M.read (| __self_0 |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::value::MoveValue::U256",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_core_types::value::MoveValue::U256"
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.path "move_core_types::u256::U256",
                              [],
                              "clone",
                              []
                            |),
                            [ M.read (| __self_0 |) ]
                          |)
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_move_core_types_value_MoveValue.
  
  (* StructRecord
    {
      name := "MoveFieldLayout";
      ty_params := [];
      fields :=
        [
          ("name", Ty.path "move_core_types::identifier::Identifier");
          ("layout", Ty.path "move_core_types::value::MoveTypeLayout")
        ];
    } *)
  
  Module Impl_core_fmt_Debug_for_move_core_types_value_MoveFieldLayout.
    Definition Self : Ty.t := Ty.path "move_core_types::value::MoveFieldLayout".
    
    (* Debug *)
    Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.path "core::fmt::Formatter",
              "debug_struct_field2_finish",
              []
            |),
            [
              M.read (| f |);
              M.read (| mk_str "MoveFieldLayout" |);
              M.read (| mk_str "name" |);
              (* Unsize *)
              M.pointer_coercion
                (M.get_struct_record_field
                  (M.read (| self |))
                  "move_core_types::value::MoveFieldLayout"
                  "name");
              M.read (| mk_str "layout" |);
              (* Unsize *)
              M.pointer_coercion
                (M.alloc (|
                  M.get_struct_record_field
                    (M.read (| self |))
                    "move_core_types::value::MoveFieldLayout"
                    "layout"
                |))
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_move_core_types_value_MoveFieldLayout.
  
  Module Impl_core_clone_Clone_for_move_core_types_value_MoveFieldLayout.
    Definition Self : Ty.t := Ty.path "move_core_types::value::MoveFieldLayout".
    
    (* Clone *)
    Definition clone (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.StructRecord
            "move_core_types::value::MoveFieldLayout"
            [
              ("name",
                M.call_closure (|
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.path "move_core_types::identifier::Identifier",
                    [],
                    "clone",
                    []
                  |),
                  [
                    M.get_struct_record_field
                      (M.read (| self |))
                      "move_core_types::value::MoveFieldLayout"
                      "name"
                  ]
                |));
              ("layout",
                M.call_closure (|
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.path "move_core_types::value::MoveTypeLayout",
                    [],
                    "clone",
                    []
                  |),
                  [
                    M.get_struct_record_field
                      (M.read (| self |))
                      "move_core_types::value::MoveFieldLayout"
                      "layout"
                  ]
                |))
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_move_core_types_value_MoveFieldLayout.
  
  Module underscore.
    Module Impl_serde_ser_Serialize_for_move_core_types_value_MoveFieldLayout.
      Definition Self : Ty.t := Ty.path "move_core_types::value::MoveFieldLayout".
      
      (* Serialize *)
      Definition serialize (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ __S ], [ self; __serializer ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let __serializer := M.alloc (| __serializer |) in
            M.read (|
              let __serde_state :=
                M.copy (|
                  M.match_operator (|
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "serde::ser::Serializer",
                          __S,
                          [],
                          "serialize_struct",
                          []
                        |),
                        [
                          M.read (| __serializer |);
                          M.read (| mk_str "MoveFieldLayout" |);
                          BinOp.Panic.add (|
                            BinOp.Panic.add (|
                              M.rust_cast (Value.Bool false),
                              Value.Integer Integer.Usize 1
                            |),
                            Value.Integer Integer.Usize 1
                          |)
                        ]
                      |)
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.get_struct_tuple_field_or_break_match (|
                              γ,
                              "core::result::Result::Ok",
                              0
                            |) in
                          let __val := M.copy (| γ0_0 |) in
                          __val));
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.get_struct_tuple_field_or_break_match (|
                              γ,
                              "core::result::Result::Err",
                              0
                            |) in
                          let __err := M.copy (| γ0_0 |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  Value.StructTuple
                                    "core::result::Result::Err"
                                    [ M.read (| __err |) ]
                                |)
                              |)
                            |)
                          |)))
                    ]
                  |)
                |) in
              let _ :=
                M.match_operator (|
                  M.alloc (|
                    M.call_closure (|
                      M.get_trait_method (|
                        "serde::ser::SerializeStruct",
                        Ty.associated,
                        [],
                        "serialize_field",
                        [ Ty.path "move_core_types::identifier::Identifier" ]
                      |),
                      [
                        __serde_state;
                        M.read (| mk_str "name" |);
                        M.get_struct_record_field
                          (M.read (| self |))
                          "move_core_types::value::MoveFieldLayout"
                          "name"
                      ]
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.get_struct_tuple_field_or_break_match (|
                            γ,
                            "core::result::Result::Ok",
                            0
                          |) in
                        let __val := M.copy (| γ0_0 |) in
                        __val));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.get_struct_tuple_field_or_break_match (|
                            γ,
                            "core::result::Result::Err",
                            0
                          |) in
                        let __err := M.copy (| γ0_0 |) in
                        M.alloc (|
                          M.never_to_any (|
                            M.read (|
                              M.return_ (|
                                Value.StructTuple "core::result::Result::Err" [ M.read (| __err |) ]
                              |)
                            |)
                          |)
                        |)))
                  ]
                |) in
              let _ :=
                M.match_operator (|
                  M.alloc (|
                    M.call_closure (|
                      M.get_trait_method (|
                        "serde::ser::SerializeStruct",
                        Ty.associated,
                        [],
                        "serialize_field",
                        [ Ty.path "move_core_types::value::MoveTypeLayout" ]
                      |),
                      [
                        __serde_state;
                        M.read (| mk_str "layout" |);
                        M.get_struct_record_field
                          (M.read (| self |))
                          "move_core_types::value::MoveFieldLayout"
                          "layout"
                      ]
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.get_struct_tuple_field_or_break_match (|
                            γ,
                            "core::result::Result::Ok",
                            0
                          |) in
                        let __val := M.copy (| γ0_0 |) in
                        __val));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.get_struct_tuple_field_or_break_match (|
                            γ,
                            "core::result::Result::Err",
                            0
                          |) in
                        let __err := M.copy (| γ0_0 |) in
                        M.alloc (|
                          M.never_to_any (|
                            M.read (|
                              M.return_ (|
                                Value.StructTuple "core::result::Result::Err" [ M.read (| __err |) ]
                              |)
                            |)
                          |)
                        |)))
                  ]
                |) in
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "serde::ser::SerializeStruct",
                    Ty.associated,
                    [],
                    "end",
                    []
                  |),
                  [ M.read (| __serde_state |) ]
                |)
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "serde::ser::Serialize"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("serialize", InstanceField.Method serialize) ].
    End Impl_serde_ser_Serialize_for_move_core_types_value_MoveFieldLayout.
  End underscore.
  
  Module Wrap_underscore_2.
  Module underscore.
    Module Impl_serde_de_Deserialize_for_move_core_types_value_MoveFieldLayout.
      Definition Self : Ty.t := Ty.path "move_core_types::value::MoveFieldLayout".
      
      (* Deserialize *)
      Definition deserialize (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ __D ], [ __deserializer ] =>
          ltac:(M.monadic
            (let __deserializer := M.alloc (| __deserializer |) in
            M.call_closure (|
              M.get_trait_method (|
                "serde::de::Deserializer",
                __D,
                [],
                "deserialize_struct",
                [ Ty.path "move_core_types::value::_'1::deserialize::__Visitor" ]
              |),
              [
                M.read (| __deserializer |);
                M.read (| mk_str "MoveFieldLayout" |);
                M.read (|
                  M.get_constant (| "move_core_types::value::_'1::deserialize::FIELDS" |)
                |);
                Value.StructRecord
                  "move_core_types::value::_'1::deserialize::__Visitor"
                  [
                    ("marker", Value.StructTuple "core::marker::PhantomData" []);
                    ("lifetime", Value.StructTuple "core::marker::PhantomData" [])
                  ]
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "serde::de::Deserialize"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("deserialize", InstanceField.Method deserialize) ].
    End Impl_serde_de_Deserialize_for_move_core_types_value_MoveFieldLayout.
  End underscore.
  End Wrap_underscore_2.
  Import Wrap_underscore_2.
  
  Module Impl_move_core_types_value_MoveFieldLayout.
    Definition Self : Ty.t := Ty.path "move_core_types::value::MoveFieldLayout".
    
    (*
        pub fn new(name: Identifier, layout: MoveTypeLayout) -> Self {
            Self { name, layout }
        }
    *)
    Definition new (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ name; layout ] =>
        ltac:(M.monadic
          (let name := M.alloc (| name |) in
          let layout := M.alloc (| layout |) in
          Value.StructRecord
            "move_core_types::value::MoveFieldLayout"
            [ ("name", M.read (| name |)); ("layout", M.read (| layout |)) ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_new : M.IsAssociatedFunction Self "new" new.
  End Impl_move_core_types_value_MoveFieldLayout.
  
  (*
  Enum MoveStructLayout
  {
    ty_params := [];
    variants :=
      [
        {
          name := "Runtime";
          item :=
            StructTuple
              [
                Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  [ Ty.path "move_core_types::value::MoveTypeLayout"; Ty.path "alloc::alloc::Global"
                  ]
              ];
          discriminant := None;
        };
        {
          name := "WithFields";
          item :=
            StructTuple
              [
                Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  [
                    Ty.path "move_core_types::value::MoveFieldLayout";
                    Ty.path "alloc::alloc::Global"
                  ]
              ];
          discriminant := None;
        };
        {
          name := "WithTypes";
          item :=
            StructRecord
              [
                ("type_", Ty.path "move_core_types::language_storage::StructTag");
                ("fields",
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    [
                      Ty.path "move_core_types::value::MoveFieldLayout";
                      Ty.path "alloc::alloc::Global"
                    ])
              ];
          discriminant := None;
        }
      ];
  }
  *)
  
  Module Impl_core_fmt_Debug_for_move_core_types_value_MoveStructLayout.
    Definition Self : Ty.t := Ty.path "move_core_types::value::MoveStructLayout".
    
    (* Debug *)
    Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::value::MoveStructLayout::Runtime",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_tuple_field1_finish",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.read (| mk_str "Runtime" |);
                          (* Unsize *) M.pointer_coercion __self_0
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::value::MoveStructLayout::WithFields",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_tuple_field1_finish",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.read (| mk_str "WithFields" |);
                          (* Unsize *) M.pointer_coercion __self_0
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_record_field_or_break_match (|
                        γ,
                        "move_core_types::value::MoveStructLayout::WithTypes",
                        "type_"
                      |) in
                    let γ1_1 :=
                      M.get_struct_record_field_or_break_match (|
                        γ,
                        "move_core_types::value::MoveStructLayout::WithTypes",
                        "fields"
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    let __self_1 := M.alloc (| γ1_1 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_struct_field2_finish",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.read (| mk_str "WithTypes" |);
                          M.read (| mk_str "type_" |);
                          (* Unsize *) M.pointer_coercion (M.read (| __self_0 |));
                          M.read (| mk_str "fields" |);
                          (* Unsize *) M.pointer_coercion __self_1
                        ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_move_core_types_value_MoveStructLayout.
  
  Module Impl_core_clone_Clone_for_move_core_types_value_MoveStructLayout.
    Definition Self : Ty.t := Ty.path "move_core_types::value::MoveStructLayout".
    
    (* Clone *)
    Definition clone (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::value::MoveStructLayout::Runtime",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_core_types::value::MoveStructLayout::Runtime"
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                [
                                  Ty.path "move_core_types::value::MoveTypeLayout";
                                  Ty.path "alloc::alloc::Global"
                                ],
                              [],
                              "clone",
                              []
                            |),
                            [ M.read (| __self_0 |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::value::MoveStructLayout::WithFields",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_core_types::value::MoveStructLayout::WithFields"
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                [
                                  Ty.path "move_core_types::value::MoveFieldLayout";
                                  Ty.path "alloc::alloc::Global"
                                ],
                              [],
                              "clone",
                              []
                            |),
                            [ M.read (| __self_0 |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_record_field_or_break_match (|
                        γ,
                        "move_core_types::value::MoveStructLayout::WithTypes",
                        "type_"
                      |) in
                    let γ1_1 :=
                      M.get_struct_record_field_or_break_match (|
                        γ,
                        "move_core_types::value::MoveStructLayout::WithTypes",
                        "fields"
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    let __self_1 := M.alloc (| γ1_1 |) in
                    M.alloc (|
                      Value.StructRecord
                        "move_core_types::value::MoveStructLayout::WithTypes"
                        [
                          ("type_",
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::clone::Clone",
                                Ty.path "move_core_types::language_storage::StructTag",
                                [],
                                "clone",
                                []
                              |),
                              [ M.read (| __self_0 |) ]
                            |));
                          ("fields",
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::clone::Clone",
                                Ty.apply
                                  (Ty.path "alloc::vec::Vec")
                                  [
                                    Ty.path "move_core_types::value::MoveFieldLayout";
                                    Ty.path "alloc::alloc::Global"
                                  ],
                                [],
                                "clone",
                                []
                              |),
                              [ M.read (| __self_1 |) ]
                            |))
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_move_core_types_value_MoveStructLayout.
  
  Module Wrap_underscore_3.
  Module underscore.
    Module Impl_serde_ser_Serialize_for_move_core_types_value_MoveStructLayout.
      Definition Self : Ty.t := Ty.path "move_core_types::value::MoveStructLayout".
      
      (* Serialize *)
      Definition serialize (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ __S ], [ self; __serializer ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let __serializer := M.alloc (| __serializer |) in
            M.read (|
              M.match_operator (|
                M.read (| self |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.get_struct_tuple_field_or_break_match (|
                          γ,
                          "move_core_types::value::MoveStructLayout::Runtime",
                          0
                        |) in
                      let __field0 := M.alloc (| γ0_0 |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "serde::ser::Serializer",
                            __S,
                            [],
                            "serialize_newtype_variant",
                            [
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                [
                                  Ty.path "move_core_types::value::MoveTypeLayout";
                                  Ty.path "alloc::alloc::Global"
                                ]
                            ]
                          |),
                          [
                            M.read (| __serializer |);
                            M.read (| mk_str "MoveStructLayout" |);
                            Value.Integer Integer.U32 0;
                            M.read (| mk_str "Runtime" |);
                            M.read (| __field0 |)
                          ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.get_struct_tuple_field_or_break_match (|
                          γ,
                          "move_core_types::value::MoveStructLayout::WithFields",
                          0
                        |) in
                      let __field0 := M.alloc (| γ0_0 |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "serde::ser::Serializer",
                            __S,
                            [],
                            "serialize_newtype_variant",
                            [
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                [
                                  Ty.path "move_core_types::value::MoveFieldLayout";
                                  Ty.path "alloc::alloc::Global"
                                ]
                            ]
                          |),
                          [
                            M.read (| __serializer |);
                            M.read (| mk_str "MoveStructLayout" |);
                            Value.Integer Integer.U32 1;
                            M.read (| mk_str "WithFields" |);
                            M.read (| __field0 |)
                          ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.get_struct_record_field_or_break_match (|
                          γ,
                          "move_core_types::value::MoveStructLayout::WithTypes",
                          "type_"
                        |) in
                      let γ0_1 :=
                        M.get_struct_record_field_or_break_match (|
                          γ,
                          "move_core_types::value::MoveStructLayout::WithTypes",
                          "fields"
                        |) in
                      let type_ := M.alloc (| γ0_0 |) in
                      let fields := M.alloc (| γ0_1 |) in
                      let __serde_state :=
                        M.copy (|
                          M.match_operator (|
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "serde::ser::Serializer",
                                  __S,
                                  [],
                                  "serialize_struct_variant",
                                  []
                                |),
                                [
                                  M.read (| __serializer |);
                                  M.read (| mk_str "MoveStructLayout" |);
                                  Value.Integer Integer.U32 2;
                                  M.read (| mk_str "WithTypes" |);
                                  BinOp.Panic.add (|
                                    BinOp.Panic.add (|
                                      Value.Integer Integer.Usize 0,
                                      Value.Integer Integer.Usize 1
                                    |),
                                    Value.Integer Integer.Usize 1
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.get_struct_tuple_field_or_break_match (|
                                      γ,
                                      "core::result::Result::Ok",
                                      0
                                    |) in
                                  let __val := M.copy (| γ0_0 |) in
                                  __val));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.get_struct_tuple_field_or_break_match (|
                                      γ,
                                      "core::result::Result::Err",
                                      0
                                    |) in
                                  let __err := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          Value.StructTuple
                                            "core::result::Result::Err"
                                            [ M.read (| __err |) ]
                                        |)
                                      |)
                                    |)
                                  |)))
                            ]
                          |)
                        |) in
                      let _ :=
                        M.match_operator (|
                          M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "serde::ser::SerializeStructVariant",
                                Ty.associated,
                                [],
                                "serialize_field",
                                [ Ty.path "move_core_types::language_storage::StructTag" ]
                              |),
                              [ __serde_state; M.read (| mk_str "type_" |); M.read (| type_ |) ]
                            |)
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.get_struct_tuple_field_or_break_match (|
                                    γ,
                                    "core::result::Result::Ok",
                                    0
                                  |) in
                                let __val := M.copy (| γ0_0 |) in
                                __val));
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.get_struct_tuple_field_or_break_match (|
                                    γ,
                                    "core::result::Result::Err",
                                    0
                                  |) in
                                let __err := M.copy (| γ0_0 |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      M.return_ (|
                                        Value.StructTuple
                                          "core::result::Result::Err"
                                          [ M.read (| __err |) ]
                                      |)
                                    |)
                                  |)
                                |)))
                          ]
                        |) in
                      let _ :=
                        M.match_operator (|
                          M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "serde::ser::SerializeStructVariant",
                                Ty.associated,
                                [],
                                "serialize_field",
                                [
                                  Ty.apply
                                    (Ty.path "alloc::vec::Vec")
                                    [
                                      Ty.path "move_core_types::value::MoveFieldLayout";
                                      Ty.path "alloc::alloc::Global"
                                    ]
                                ]
                              |),
                              [ __serde_state; M.read (| mk_str "fields" |); M.read (| fields |) ]
                            |)
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.get_struct_tuple_field_or_break_match (|
                                    γ,
                                    "core::result::Result::Ok",
                                    0
                                  |) in
                                let __val := M.copy (| γ0_0 |) in
                                __val));
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.get_struct_tuple_field_or_break_match (|
                                    γ,
                                    "core::result::Result::Err",
                                    0
                                  |) in
                                let __err := M.copy (| γ0_0 |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      M.return_ (|
                                        Value.StructTuple
                                          "core::result::Result::Err"
                                          [ M.read (| __err |) ]
                                      |)
                                    |)
                                  |)
                                |)))
                          ]
                        |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "serde::ser::SerializeStructVariant",
                            Ty.associated,
                            [],
                            "end",
                            []
                          |),
                          [ M.read (| __serde_state |) ]
                        |)
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "serde::ser::Serialize"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("serialize", InstanceField.Method serialize) ].
    End Impl_serde_ser_Serialize_for_move_core_types_value_MoveStructLayout.
  End underscore.
  End Wrap_underscore_3.
  Import Wrap_underscore_3.
  
  Module Wrap_underscore_4.
  Module underscore.
    Module Impl_serde_de_Deserialize_for_move_core_types_value_MoveStructLayout.
      Definition Self : Ty.t := Ty.path "move_core_types::value::MoveStructLayout".
      
      (* Deserialize *)
      Definition deserialize (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ __D ], [ __deserializer ] =>
          ltac:(M.monadic
            (let __deserializer := M.alloc (| __deserializer |) in
            M.call_closure (|
              M.get_trait_method (|
                "serde::de::Deserializer",
                __D,
                [],
                "deserialize_enum",
                [ Ty.path "move_core_types::value::_'3::deserialize::__Visitor" ]
              |),
              [
                M.read (| __deserializer |);
                M.read (| mk_str "MoveStructLayout" |);
                M.read (|
                  M.get_constant (| "move_core_types::value::_'3::deserialize::VARIANTS" |)
                |);
                Value.StructRecord
                  "move_core_types::value::_'3::deserialize::__Visitor"
                  [
                    ("marker", Value.StructTuple "core::marker::PhantomData" []);
                    ("lifetime", Value.StructTuple "core::marker::PhantomData" [])
                  ]
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "serde::de::Deserialize"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("deserialize", InstanceField.Method deserialize) ].
    End Impl_serde_de_Deserialize_for_move_core_types_value_MoveStructLayout.
  End underscore.
  End Wrap_underscore_4.
  Import Wrap_underscore_4.
  
  (*
  Enum MoveTypeLayout
  {
    ty_params := [];
    variants :=
      [
        {
          name := "Bool";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "U8";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "U64";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "U128";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "Address";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "Vector";
          item :=
            StructTuple
              [
                Ty.apply
                  (Ty.path "alloc::boxed::Box")
                  [ Ty.path "move_core_types::value::MoveTypeLayout"; Ty.path "alloc::alloc::Global"
                  ]
              ];
          discriminant := None;
        };
        {
          name := "Struct";
          item := StructTuple [ Ty.path "move_core_types::value::MoveStructLayout" ];
          discriminant := None;
        };
        {
          name := "Signer";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "U16";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "U32";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "U256";
          item := StructTuple [];
          discriminant := None;
        }
      ];
  }
  *)
  
  Module Impl_core_fmt_Debug_for_move_core_types_value_MoveTypeLayout.
    Definition Self : Ty.t := Ty.path "move_core_types::value::MoveTypeLayout".
    
    (* Debug *)
    Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| mk_str "Bool" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| mk_str "U8" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| mk_str "U64" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| mk_str "U128" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| mk_str "Address" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::value::MoveTypeLayout::Vector",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_tuple_field1_finish",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.read (| mk_str "Vector" |);
                          (* Unsize *) M.pointer_coercion __self_0
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::value::MoveTypeLayout::Struct",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_tuple_field1_finish",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.read (| mk_str "Struct" |);
                          (* Unsize *) M.pointer_coercion __self_0
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| mk_str "Signer" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| mk_str "U16" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| mk_str "U32" |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          []
                        |),
                        [ M.read (| f |); M.read (| mk_str "U256" |) ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_move_core_types_value_MoveTypeLayout.
  
  Module Impl_core_clone_Clone_for_move_core_types_value_MoveTypeLayout.
    Definition Self : Ty.t := Ty.path "move_core_types::value::MoveTypeLayout".
    
    (* Clone *)
    Definition clone (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (|
                      Value.StructTuple "move_core_types::value::MoveTypeLayout::Bool" []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (|
                      Value.StructTuple "move_core_types::value::MoveTypeLayout::U8" []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (|
                      Value.StructTuple "move_core_types::value::MoveTypeLayout::U64" []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (|
                      Value.StructTuple "move_core_types::value::MoveTypeLayout::U128" []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (|
                      Value.StructTuple "move_core_types::value::MoveTypeLayout::Address" []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::value::MoveTypeLayout::Vector",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_core_types::value::MoveTypeLayout::Vector"
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.apply
                                (Ty.path "alloc::boxed::Box")
                                [
                                  Ty.path "move_core_types::value::MoveTypeLayout";
                                  Ty.path "alloc::alloc::Global"
                                ],
                              [],
                              "clone",
                              []
                            |),
                            [ M.read (| __self_0 |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::value::MoveTypeLayout::Struct",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_core_types::value::MoveTypeLayout::Struct"
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.path "move_core_types::value::MoveStructLayout",
                              [],
                              "clone",
                              []
                            |),
                            [ M.read (| __self_0 |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (|
                      Value.StructTuple "move_core_types::value::MoveTypeLayout::Signer" []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (|
                      Value.StructTuple "move_core_types::value::MoveTypeLayout::U16" []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (|
                      Value.StructTuple "move_core_types::value::MoveTypeLayout::U32" []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (|
                      Value.StructTuple "move_core_types::value::MoveTypeLayout::U256" []
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_move_core_types_value_MoveTypeLayout.
  
  Module Wrap_underscore_5.
  Module underscore.
    Module Impl_serde_ser_Serialize_for_move_core_types_value_MoveTypeLayout.
      Definition Self : Ty.t := Ty.path "move_core_types::value::MoveTypeLayout".
      
      (* Serialize *)
      Definition serialize (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ __S ], [ self; __serializer ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let __serializer := M.alloc (| __serializer |) in
            M.read (|
              M.match_operator (|
                M.read (| self |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "serde::ser::Serializer",
                            __S,
                            [],
                            "serialize_unit_variant",
                            []
                          |),
                          [
                            M.read (| __serializer |);
                            M.read (| mk_str "MoveTypeLayout" |);
                            Value.Integer Integer.U32 0;
                            M.read (| mk_str "bool" |)
                          ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "serde::ser::Serializer",
                            __S,
                            [],
                            "serialize_unit_variant",
                            []
                          |),
                          [
                            M.read (| __serializer |);
                            M.read (| mk_str "MoveTypeLayout" |);
                            Value.Integer Integer.U32 1;
                            M.read (| mk_str "u8" |)
                          ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "serde::ser::Serializer",
                            __S,
                            [],
                            "serialize_unit_variant",
                            []
                          |),
                          [
                            M.read (| __serializer |);
                            M.read (| mk_str "MoveTypeLayout" |);
                            Value.Integer Integer.U32 2;
                            M.read (| mk_str "u64" |)
                          ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "serde::ser::Serializer",
                            __S,
                            [],
                            "serialize_unit_variant",
                            []
                          |),
                          [
                            M.read (| __serializer |);
                            M.read (| mk_str "MoveTypeLayout" |);
                            Value.Integer Integer.U32 3;
                            M.read (| mk_str "u128" |)
                          ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "serde::ser::Serializer",
                            __S,
                            [],
                            "serialize_unit_variant",
                            []
                          |),
                          [
                            M.read (| __serializer |);
                            M.read (| mk_str "MoveTypeLayout" |);
                            Value.Integer Integer.U32 4;
                            M.read (| mk_str "address" |)
                          ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.get_struct_tuple_field_or_break_match (|
                          γ,
                          "move_core_types::value::MoveTypeLayout::Vector",
                          0
                        |) in
                      let __field0 := M.alloc (| γ0_0 |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "serde::ser::Serializer",
                            __S,
                            [],
                            "serialize_newtype_variant",
                            [
                              Ty.apply
                                (Ty.path "alloc::boxed::Box")
                                [
                                  Ty.path "move_core_types::value::MoveTypeLayout";
                                  Ty.path "alloc::alloc::Global"
                                ]
                            ]
                          |),
                          [
                            M.read (| __serializer |);
                            M.read (| mk_str "MoveTypeLayout" |);
                            Value.Integer Integer.U32 5;
                            M.read (| mk_str "vector" |);
                            M.read (| __field0 |)
                          ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.get_struct_tuple_field_or_break_match (|
                          γ,
                          "move_core_types::value::MoveTypeLayout::Struct",
                          0
                        |) in
                      let __field0 := M.alloc (| γ0_0 |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "serde::ser::Serializer",
                            __S,
                            [],
                            "serialize_newtype_variant",
                            [ Ty.path "move_core_types::value::MoveStructLayout" ]
                          |),
                          [
                            M.read (| __serializer |);
                            M.read (| mk_str "MoveTypeLayout" |);
                            Value.Integer Integer.U32 6;
                            M.read (| mk_str "struct" |);
                            M.read (| __field0 |)
                          ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "serde::ser::Serializer",
                            __S,
                            [],
                            "serialize_unit_variant",
                            []
                          |),
                          [
                            M.read (| __serializer |);
                            M.read (| mk_str "MoveTypeLayout" |);
                            Value.Integer Integer.U32 7;
                            M.read (| mk_str "signer" |)
                          ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "serde::ser::Serializer",
                            __S,
                            [],
                            "serialize_unit_variant",
                            []
                          |),
                          [
                            M.read (| __serializer |);
                            M.read (| mk_str "MoveTypeLayout" |);
                            Value.Integer Integer.U32 8;
                            M.read (| mk_str "u16" |)
                          ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "serde::ser::Serializer",
                            __S,
                            [],
                            "serialize_unit_variant",
                            []
                          |),
                          [
                            M.read (| __serializer |);
                            M.read (| mk_str "MoveTypeLayout" |);
                            Value.Integer Integer.U32 9;
                            M.read (| mk_str "u32" |)
                          ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "serde::ser::Serializer",
                            __S,
                            [],
                            "serialize_unit_variant",
                            []
                          |),
                          [
                            M.read (| __serializer |);
                            M.read (| mk_str "MoveTypeLayout" |);
                            Value.Integer Integer.U32 10;
                            M.read (| mk_str "u256" |)
                          ]
                        |)
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "serde::ser::Serialize"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("serialize", InstanceField.Method serialize) ].
    End Impl_serde_ser_Serialize_for_move_core_types_value_MoveTypeLayout.
  End underscore.
  End Wrap_underscore_5.
  Import Wrap_underscore_5.
  
  Module Wrap_underscore_6.
  Module underscore.
    Module Impl_serde_de_Deserialize_for_move_core_types_value_MoveTypeLayout.
      Definition Self : Ty.t := Ty.path "move_core_types::value::MoveTypeLayout".
      
      (* Deserialize *)
      Definition deserialize (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ __D ], [ __deserializer ] =>
          ltac:(M.monadic
            (let __deserializer := M.alloc (| __deserializer |) in
            M.call_closure (|
              M.get_trait_method (|
                "serde::de::Deserializer",
                __D,
                [],
                "deserialize_enum",
                [ Ty.path "move_core_types::value::_'5::deserialize::__Visitor" ]
              |),
              [
                M.read (| __deserializer |);
                M.read (| mk_str "MoveTypeLayout" |);
                M.read (|
                  M.get_constant (| "move_core_types::value::_'5::deserialize::VARIANTS" |)
                |);
                Value.StructRecord
                  "move_core_types::value::_'5::deserialize::__Visitor"
                  [
                    ("marker", Value.StructTuple "core::marker::PhantomData" []);
                    ("lifetime", Value.StructTuple "core::marker::PhantomData" [])
                  ]
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "serde::de::Deserialize"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("deserialize", InstanceField.Method deserialize) ].
    End Impl_serde_de_Deserialize_for_move_core_types_value_MoveTypeLayout.
  End underscore.
  End Wrap_underscore_6.
  Import Wrap_underscore_6.
  
  Module Impl_move_core_types_value_MoveValue.
    Definition Self : Ty.t := Ty.path "move_core_types::value::MoveValue".
    
    (*
        pub fn simple_deserialize(blob: &[u8], ty: &MoveTypeLayout) -> AResult<Self> {
            Ok(bcs::from_bytes_seed(ty, blob)?)
        }
    *)
    Definition simple_deserialize (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ blob; ty ] =>
        ltac:(M.monadic
          (let blob := M.alloc (| blob |) in
          let ty := M.alloc (| ty |) in
          Value.StructTuple
            "core::result::Result::Ok"
            [
              M.read (|
                M.match_operator (|
                  M.alloc (|
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::ops::try_trait::Try",
                        Ty.apply
                          (Ty.path "core::result::Result")
                          [ Ty.path "move_core_types::value::MoveValue"; Ty.path "bcs::error::Error"
                          ],
                        [],
                        "branch",
                        []
                      |),
                      [
                        M.call_closure (|
                          M.get_function (|
                            "bcs::de::from_bytes_seed",
                            [
                              Ty.apply
                                (Ty.path "&")
                                [ Ty.path "move_core_types::value::MoveTypeLayout" ]
                            ]
                          |),
                          [ M.read (| ty |); M.read (| blob |) ]
                        |)
                      ]
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.get_struct_tuple_field_or_break_match (|
                            γ,
                            "core::ops::control_flow::ControlFlow::Break",
                            0
                          |) in
                        let residual := M.copy (| γ0_0 |) in
                        M.alloc (|
                          M.never_to_any (|
                            M.read (|
                              M.return_ (|
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::ops::try_trait::FromResidual",
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      [
                                        Ty.path "move_core_types::value::MoveValue";
                                        Ty.path "anyhow::Error"
                                      ],
                                    [
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        [
                                          Ty.path "core::convert::Infallible";
                                          Ty.path "bcs::error::Error"
                                        ]
                                    ],
                                    "from_residual",
                                    []
                                  |),
                                  [ M.read (| residual |) ]
                                |)
                              |)
                            |)
                          |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.get_struct_tuple_field_or_break_match (|
                            γ,
                            "core::ops::control_flow::ControlFlow::Continue",
                            0
                          |) in
                        let val := M.copy (| γ0_0 |) in
                        val))
                  ]
                |)
              |)
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_simple_deserialize :
      M.IsAssociatedFunction Self "simple_deserialize" simple_deserialize.
    
    (*
        pub fn simple_serialize(&self) -> Option<Vec<u8>> {
            bcs::to_bytes(self).ok()
        }
    *)
    Definition simple_serialize (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.apply
                (Ty.path "core::result::Result")
                [
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ];
                  Ty.path "bcs::error::Error"
                ],
              "ok",
              []
            |),
            [
              M.call_closure (|
                M.get_function (|
                  "bcs::ser::to_bytes",
                  [ Ty.path "move_core_types::value::MoveValue" ]
                |),
                [ M.read (| self |) ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_simple_serialize :
      M.IsAssociatedFunction Self "simple_serialize" simple_serialize.
    
    (*
        pub fn vector_u8(v: Vec<u8>) -> Self {
            MoveValue::Vector(v.into_iter().map(MoveValue::U8).collect())
        }
    *)
    Definition vector_u8 (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ v ] =>
        ltac:(M.monadic
          (let v := M.alloc (| v |) in
          Value.StructTuple
            "move_core_types::value::MoveValue::Vector"
            [
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  Ty.apply
                    (Ty.path "core::iter::adapters::map::Map")
                    [
                      Ty.apply
                        (Ty.path "alloc::vec::into_iter::IntoIter")
                        [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ];
                      Ty.function [ Ty.path "u8" ] (Ty.path "move_core_types::value::MoveValue")
                    ],
                  [],
                  "collect",
                  [
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      [ Ty.path "move_core_types::value::MoveValue"; Ty.path "alloc::alloc::Global"
                      ]
                  ]
                |),
                [
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::iter::traits::iterator::Iterator",
                      Ty.apply
                        (Ty.path "alloc::vec::into_iter::IntoIter")
                        [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                      [],
                      "map",
                      [
                        Ty.path "move_core_types::value::MoveValue";
                        Ty.function [ Ty.path "u8" ] (Ty.path "move_core_types::value::MoveValue")
                      ]
                    |),
                    [
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::iter::traits::collect::IntoIterator",
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                          [],
                          "into_iter",
                          []
                        |),
                        [ M.read (| v |) ]
                      |);
                      M.constructor_as_closure "move_core_types::value::MoveValue::U8"
                    ]
                  |)
                ]
              |)
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_vector_u8 : M.IsAssociatedFunction Self "vector_u8" vector_u8.
    
    (*
        pub fn vec_to_vec_u8(vec: Vec<MoveValue>) -> AResult<Vec<u8>> {
            let mut vec_u8 = Vec::with_capacity(vec.len());
    
            for byte in vec {
                match byte {
                    MoveValue::U8(u8) => {
                        vec_u8.push(u8);
                    }
                    _ => {
                        return Err(anyhow!(
                            "Expected inner MoveValue in Vec<MoveValue> to be a MoveValue::U8"
                                .to_string(),
                        ));
                    }
                }
            }
            Ok(vec_u8)
        }
    *)
    Definition vec_to_vec_u8 (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ vec ] =>
        ltac:(M.monadic
          (let vec := M.alloc (| vec |) in
          M.read (|
            let vec_u8 :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                    "with_capacity",
                    []
                  |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::vec::Vec")
                          [
                            Ty.path "move_core_types::value::MoveValue";
                            Ty.path "alloc::alloc::Global"
                          ],
                        "len",
                        []
                      |),
                      [ vec ]
                    |)
                  ]
                |)
              |) in
            let _ :=
              M.use
                (M.match_operator (|
                  M.alloc (|
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::iter::traits::collect::IntoIterator",
                        Ty.apply
                          (Ty.path "alloc::vec::Vec")
                          [
                            Ty.path "move_core_types::value::MoveValue";
                            Ty.path "alloc::alloc::Global"
                          ],
                        [],
                        "into_iter",
                        []
                      |),
                      [ M.read (| vec |) ]
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let iter := M.copy (| γ |) in
                        M.loop (|
                          ltac:(M.monadic
                            (let _ :=
                              M.match_operator (|
                                M.alloc (|
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::iter::traits::iterator::Iterator",
                                      Ty.apply
                                        (Ty.path "alloc::vec::into_iter::IntoIter")
                                        [
                                          Ty.path "move_core_types::value::MoveValue";
                                          Ty.path "alloc::alloc::Global"
                                        ],
                                      [],
                                      "next",
                                      []
                                    |),
                                    [ iter ]
                                  |)
                                |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (M.alloc (|
                                        M.never_to_any (| M.read (| M.break (||) |) |)
                                      |)));
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ0_0 :=
                                        M.get_struct_tuple_field_or_break_match (|
                                          γ,
                                          "core::option::Option::Some",
                                          0
                                        |) in
                                      let byte := M.copy (| γ0_0 |) in
                                      M.match_operator (|
                                        byte,
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let γ0_0 :=
                                                M.get_struct_tuple_field_or_break_match (|
                                                  γ,
                                                  "move_core_types::value::MoveValue::U8",
                                                  0
                                                |) in
                                              let u8 := M.copy (| γ0_0 |) in
                                              let _ :=
                                                M.alloc (|
                                                  M.call_closure (|
                                                    M.get_associated_function (|
                                                      Ty.apply
                                                        (Ty.path "alloc::vec::Vec")
                                                        [
                                                          Ty.path "u8";
                                                          Ty.path "alloc::alloc::Global"
                                                        ],
                                                      "push",
                                                      []
                                                    |),
                                                    [ vec_u8; M.read (| u8 |) ]
                                                  |)
                                                |) in
                                              M.alloc (| Value.Tuple [] |)));
                                          fun γ =>
                                            ltac:(M.monadic
                                              (M.alloc (|
                                                M.never_to_any (|
                                                  M.read (|
                                                    M.return_ (|
                                                      Value.StructTuple
                                                        "core::result::Result::Err"
                                                        [
                                                          M.read (|
                                                            let error :=
                                                              M.copy (|
                                                                M.match_operator (|
                                                                  M.alloc (|
                                                                    M.call_closure (|
                                                                      M.get_trait_method (|
                                                                        "alloc::string::ToString",
                                                                        Ty.path "str",
                                                                        [],
                                                                        "to_string",
                                                                        []
                                                                      |),
                                                                      [
                                                                        M.read (|
                                                                          mk_str
                                                                            "Expected inner MoveValue in Vec<MoveValue> to be a MoveValue::U8"
                                                                        |)
                                                                      ]
                                                                    |)
                                                                  |),
                                                                  [
                                                                    fun γ =>
                                                                      ltac:(M.monadic
                                                                        (let error :=
                                                                          M.copy (| γ |) in
                                                                        M.alloc (|
                                                                          M.call_closure (|
                                                                            M.get_associated_function (|
                                                                              Ty.path
                                                                                "anyhow::kind::Adhoc",
                                                                              "new",
                                                                              [
                                                                                Ty.path
                                                                                  "alloc::string::String"
                                                                              ]
                                                                            |),
                                                                            [
                                                                              M.call_closure (|
                                                                                M.get_trait_method (|
                                                                                  "anyhow::kind::AdhocKind",
                                                                                  Ty.apply
                                                                                    (Ty.path "&")
                                                                                    [
                                                                                      Ty.path
                                                                                        "alloc::string::String"
                                                                                    ],
                                                                                  [],
                                                                                  "anyhow_kind",
                                                                                  []
                                                                                |),
                                                                                [
                                                                                  M.alloc (|
                                                                                    error
                                                                                  |)
                                                                                ]
                                                                              |);
                                                                              M.read (| error |)
                                                                            ]
                                                                          |)
                                                                        |)))
                                                                  ]
                                                                |)
                                                              |) in
                                                            error
                                                          |)
                                                        ]
                                                    |)
                                                  |)
                                                |)
                                              |)))
                                        ]
                                      |)))
                                ]
                              |) in
                            M.alloc (| Value.Tuple [] |)))
                        |)))
                  ]
                |)) in
            M.alloc (| Value.StructTuple "core::result::Result::Ok" [ M.read (| vec_u8 |) ] |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_vec_to_vec_u8 :
      M.IsAssociatedFunction Self "vec_to_vec_u8" vec_to_vec_u8.
    
    (*
        pub fn vector_address(v: Vec<AccountAddress>) -> Self {
            MoveValue::Vector(v.into_iter().map(MoveValue::Address).collect())
        }
    *)
    Definition vector_address (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ v ] =>
        ltac:(M.monadic
          (let v := M.alloc (| v |) in
          Value.StructTuple
            "move_core_types::value::MoveValue::Vector"
            [
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  Ty.apply
                    (Ty.path "core::iter::adapters::map::Map")
                    [
                      Ty.apply
                        (Ty.path "alloc::vec::into_iter::IntoIter")
                        [
                          Ty.path "move_core_types::account_address::AccountAddress";
                          Ty.path "alloc::alloc::Global"
                        ];
                      Ty.function
                        [ Ty.path "move_core_types::account_address::AccountAddress" ]
                        (Ty.path "move_core_types::value::MoveValue")
                    ],
                  [],
                  "collect",
                  [
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      [ Ty.path "move_core_types::value::MoveValue"; Ty.path "alloc::alloc::Global"
                      ]
                  ]
                |),
                [
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::iter::traits::iterator::Iterator",
                      Ty.apply
                        (Ty.path "alloc::vec::into_iter::IntoIter")
                        [
                          Ty.path "move_core_types::account_address::AccountAddress";
                          Ty.path "alloc::alloc::Global"
                        ],
                      [],
                      "map",
                      [
                        Ty.path "move_core_types::value::MoveValue";
                        Ty.function
                          [ Ty.path "move_core_types::account_address::AccountAddress" ]
                          (Ty.path "move_core_types::value::MoveValue")
                      ]
                    |),
                    [
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::iter::traits::collect::IntoIterator",
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            [
                              Ty.path "move_core_types::account_address::AccountAddress";
                              Ty.path "alloc::alloc::Global"
                            ],
                          [],
                          "into_iter",
                          []
                        |),
                        [ M.read (| v |) ]
                      |);
                      M.constructor_as_closure "move_core_types::value::MoveValue::Address"
                    ]
                  |)
                ]
              |)
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_vector_address :
      M.IsAssociatedFunction Self "vector_address" vector_address.
    
    (*
        pub fn decorate(self, layout: &MoveTypeLayout) -> Self {
            match (self, layout) {
                (MoveValue::Struct(s), MoveTypeLayout::Struct(l)) => MoveValue::Struct(s.decorate(l)),
                (MoveValue::Vector(vals), MoveTypeLayout::Vector(t)) => {
                    MoveValue::Vector(vals.into_iter().map(|v| v.decorate(t)).collect())
                }
                (v, _) => v,
            }
        }
    *)
    Definition decorate (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; layout ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let layout := M.alloc (| layout |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [ M.read (| self |); M.read (| layout |) ] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.get_tuple_field γ 0 in
                    let γ0_1 := M.get_tuple_field γ 1 in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ0_0,
                        "move_core_types::value::MoveValue::Struct",
                        0
                      |) in
                    let s := M.copy (| γ1_0 |) in
                    let γ0_1 := M.read (| γ0_1 |) in
                    let γ2_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ0_1,
                        "move_core_types::value::MoveTypeLayout::Struct",
                        0
                      |) in
                    let l := M.alloc (| γ2_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_core_types::value::MoveValue::Struct"
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "move_core_types::value::MoveStruct",
                              "decorate",
                              []
                            |),
                            [ M.read (| s |); M.read (| l |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.get_tuple_field γ 0 in
                    let γ0_1 := M.get_tuple_field γ 1 in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ0_0,
                        "move_core_types::value::MoveValue::Vector",
                        0
                      |) in
                    let vals := M.copy (| γ1_0 |) in
                    let γ0_1 := M.read (| γ0_1 |) in
                    let γ2_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ0_1,
                        "move_core_types::value::MoveTypeLayout::Vector",
                        0
                      |) in
                    let t := M.alloc (| γ2_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_core_types::value::MoveValue::Vector"
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::iter::traits::iterator::Iterator",
                              Ty.apply
                                (Ty.path "core::iter::adapters::map::Map")
                                [
                                  Ty.apply
                                    (Ty.path "alloc::vec::into_iter::IntoIter")
                                    [
                                      Ty.path "move_core_types::value::MoveValue";
                                      Ty.path "alloc::alloc::Global"
                                    ];
                                  Ty.function
                                    [ Ty.tuple [ Ty.path "move_core_types::value::MoveValue" ] ]
                                    (Ty.path "move_core_types::value::MoveValue")
                                ],
                              [],
                              "collect",
                              [
                                Ty.apply
                                  (Ty.path "alloc::vec::Vec")
                                  [
                                    Ty.path "move_core_types::value::MoveValue";
                                    Ty.path "alloc::alloc::Global"
                                  ]
                              ]
                            |),
                            [
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::iter::traits::iterator::Iterator",
                                  Ty.apply
                                    (Ty.path "alloc::vec::into_iter::IntoIter")
                                    [
                                      Ty.path "move_core_types::value::MoveValue";
                                      Ty.path "alloc::alloc::Global"
                                    ],
                                  [],
                                  "map",
                                  [
                                    Ty.path "move_core_types::value::MoveValue";
                                    Ty.function
                                      [ Ty.tuple [ Ty.path "move_core_types::value::MoveValue" ] ]
                                      (Ty.path "move_core_types::value::MoveValue")
                                  ]
                                |),
                                [
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::iter::traits::collect::IntoIterator",
                                      Ty.apply
                                        (Ty.path "alloc::vec::Vec")
                                        [
                                          Ty.path "move_core_types::value::MoveValue";
                                          Ty.path "alloc::alloc::Global"
                                        ],
                                      [],
                                      "into_iter",
                                      []
                                    |),
                                    [ M.read (| vals |) ]
                                  |);
                                  M.closure
                                    (fun γ =>
                                      ltac:(M.monadic
                                        match γ with
                                        | [ α0 ] =>
                                          M.match_operator (|
                                            M.alloc (| α0 |),
                                            [
                                              fun γ =>
                                                ltac:(M.monadic
                                                  (let v := M.copy (| γ |) in
                                                  M.call_closure (|
                                                    M.get_associated_function (|
                                                      Ty.path "move_core_types::value::MoveValue",
                                                      "decorate",
                                                      []
                                                    |),
                                                    [ M.read (| v |); M.read (| M.read (| t |) |) ]
                                                  |)))
                                            ]
                                          |)
                                        | _ => M.impossible (||)
                                        end))
                                ]
                              |)
                            ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.get_tuple_field γ 0 in
                    let γ0_1 := M.get_tuple_field γ 1 in
                    let v := M.copy (| γ0_0 |) in
                    v))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_decorate : M.IsAssociatedFunction Self "decorate" decorate.
    
    (*
        pub fn undecorate(self) -> Self {
            match self {
                Self::Struct(s) => MoveValue::Struct(s.undecorate()),
                Self::Vector(vals) => {
                    MoveValue::Vector(vals.into_iter().map(MoveValue::undecorate).collect())
                }
                v => v,
            }
        }
    *)
    Definition undecorate (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::value::MoveValue::Struct",
                        0
                      |) in
                    let s := M.copy (| γ0_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_core_types::value::MoveValue::Struct"
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "move_core_types::value::MoveStruct",
                              "undecorate",
                              []
                            |),
                            [ M.read (| s |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::value::MoveValue::Vector",
                        0
                      |) in
                    let vals := M.copy (| γ0_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_core_types::value::MoveValue::Vector"
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::iter::traits::iterator::Iterator",
                              Ty.apply
                                (Ty.path "core::iter::adapters::map::Map")
                                [
                                  Ty.apply
                                    (Ty.path "alloc::vec::into_iter::IntoIter")
                                    [
                                      Ty.path "move_core_types::value::MoveValue";
                                      Ty.path "alloc::alloc::Global"
                                    ];
                                  Ty.function
                                    [ Ty.path "move_core_types::value::MoveValue" ]
                                    (Ty.path "move_core_types::value::MoveValue")
                                ],
                              [],
                              "collect",
                              [
                                Ty.apply
                                  (Ty.path "alloc::vec::Vec")
                                  [
                                    Ty.path "move_core_types::value::MoveValue";
                                    Ty.path "alloc::alloc::Global"
                                  ]
                              ]
                            |),
                            [
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::iter::traits::iterator::Iterator",
                                  Ty.apply
                                    (Ty.path "alloc::vec::into_iter::IntoIter")
                                    [
                                      Ty.path "move_core_types::value::MoveValue";
                                      Ty.path "alloc::alloc::Global"
                                    ],
                                  [],
                                  "map",
                                  [
                                    Ty.path "move_core_types::value::MoveValue";
                                    Ty.function
                                      [ Ty.path "move_core_types::value::MoveValue" ]
                                      (Ty.path "move_core_types::value::MoveValue")
                                  ]
                                |),
                                [
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::iter::traits::collect::IntoIterator",
                                      Ty.apply
                                        (Ty.path "alloc::vec::Vec")
                                        [
                                          Ty.path "move_core_types::value::MoveValue";
                                          Ty.path "alloc::alloc::Global"
                                        ],
                                      [],
                                      "into_iter",
                                      []
                                    |),
                                    [ M.read (| vals |) ]
                                  |);
                                  M.get_associated_function (|
                                    Ty.path "move_core_types::value::MoveValue",
                                    "undecorate",
                                    []
                                  |)
                                ]
                              |)
                            ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let v := M.copy (| γ |) in
                    v))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_undecorate : M.IsAssociatedFunction Self "undecorate" undecorate.
  End Impl_move_core_types_value_MoveValue.
  
  (*
  pub fn serialize_values<'a, I>(vals: I) -> Vec<Vec<u8>>
  where
      I: IntoIterator<Item = &'a MoveValue>,
  {
      vals.into_iter()
          .map(|val| {
              val.simple_serialize()
                  .expect("serialization should succeed")
          })
          .collect()
  }
  *)
  Definition serialize_values (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [ _ as I ], [ vals ] =>
      ltac:(M.monadic
        (let vals := M.alloc (| vals |) in
        M.call_closure (|
          M.get_trait_method (|
            "core::iter::traits::iterator::Iterator",
            Ty.apply
              (Ty.path "core::iter::adapters::map::Map")
              [
                Ty.associated;
                Ty.function
                  [
                    Ty.tuple
                      [ Ty.apply (Ty.path "&") [ Ty.path "move_core_types::value::MoveValue" ] ]
                  ]
                  (Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ])
              ],
            [],
            "collect",
            [
              Ty.apply
                (Ty.path "alloc::vec::Vec")
                [
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ];
                  Ty.path "alloc::alloc::Global"
                ]
            ]
          |),
          [
            M.call_closure (|
              M.get_trait_method (|
                "core::iter::traits::iterator::Iterator",
                Ty.associated,
                [],
                "map",
                [
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ];
                  Ty.function
                    [
                      Ty.tuple
                        [ Ty.apply (Ty.path "&") [ Ty.path "move_core_types::value::MoveValue" ] ]
                    ]
                    (Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ])
                ]
              |),
              [
                M.call_closure (|
                  M.get_trait_method (|
                    "core::iter::traits::collect::IntoIterator",
                    I,
                    [],
                    "into_iter",
                    []
                  |),
                  [ M.read (| vals |) ]
                |);
                M.closure
                  (fun γ =>
                    ltac:(M.monadic
                      match γ with
                      | [ α0 ] =>
                        M.match_operator (|
                          M.alloc (| α0 |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let val := M.copy (| γ |) in
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "core::option::Option")
                                      [
                                        Ty.apply
                                          (Ty.path "alloc::vec::Vec")
                                          [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                                      ],
                                    "expect",
                                    []
                                  |),
                                  [
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.path "move_core_types::value::MoveValue",
                                        "simple_serialize",
                                        []
                                      |),
                                      [ M.read (| val |) ]
                                    |);
                                    M.read (| mk_str "serialization should succeed" |)
                                  ]
                                |)))
                          ]
                        |)
                      | _ => M.impossible (||)
                      end))
              ]
            |)
          ]
        |)))
    | _, _ => M.impossible
    end.
  
  Module Impl_move_core_types_value_MoveStruct.
    Definition Self : Ty.t := Ty.path "move_core_types::value::MoveStruct".
    
    (*
        pub fn new(value: Vec<MoveValue>) -> Self {
            Self::Runtime(value)
        }
    *)
    Definition new (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ value ] =>
        ltac:(M.monadic
          (let value := M.alloc (| value |) in
          Value.StructTuple "move_core_types::value::MoveStruct::Runtime" [ M.read (| value |) ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_new : M.IsAssociatedFunction Self "new" new.
    
    (*
        pub fn with_fields(values: Vec<(Identifier, MoveValue)>) -> Self {
            Self::WithFields(values)
        }
    *)
    Definition with_fields (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ values ] =>
        ltac:(M.monadic
          (let values := M.alloc (| values |) in
          Value.StructTuple
            "move_core_types::value::MoveStruct::WithFields"
            [ M.read (| values |) ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_with_fields : M.IsAssociatedFunction Self "with_fields" with_fields.
    
    (*
        pub fn with_types(type_: StructTag, fields: Vec<(Identifier, MoveValue)>) -> Self {
            Self::WithTypes { type_, fields }
        }
    *)
    Definition with_types (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ type_; fields ] =>
        ltac:(M.monadic
          (let type_ := M.alloc (| type_ |) in
          let fields := M.alloc (| fields |) in
          Value.StructRecord
            "move_core_types::value::MoveStruct::WithTypes"
            [ ("type_", M.read (| type_ |)); ("fields", M.read (| fields |)) ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_with_types : M.IsAssociatedFunction Self "with_types" with_types.
    
    (*
        pub fn simple_deserialize(blob: &[u8], ty: &MoveStructLayout) -> AResult<Self> {
            Ok(bcs::from_bytes_seed(ty, blob)?)
        }
    *)
    Definition simple_deserialize (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ blob; ty ] =>
        ltac:(M.monadic
          (let blob := M.alloc (| blob |) in
          let ty := M.alloc (| ty |) in
          Value.StructTuple
            "core::result::Result::Ok"
            [
              M.read (|
                M.match_operator (|
                  M.alloc (|
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::ops::try_trait::Try",
                        Ty.apply
                          (Ty.path "core::result::Result")
                          [
                            Ty.path "move_core_types::value::MoveStruct";
                            Ty.path "bcs::error::Error"
                          ],
                        [],
                        "branch",
                        []
                      |),
                      [
                        M.call_closure (|
                          M.get_function (|
                            "bcs::de::from_bytes_seed",
                            [
                              Ty.apply
                                (Ty.path "&")
                                [ Ty.path "move_core_types::value::MoveStructLayout" ]
                            ]
                          |),
                          [ M.read (| ty |); M.read (| blob |) ]
                        |)
                      ]
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.get_struct_tuple_field_or_break_match (|
                            γ,
                            "core::ops::control_flow::ControlFlow::Break",
                            0
                          |) in
                        let residual := M.copy (| γ0_0 |) in
                        M.alloc (|
                          M.never_to_any (|
                            M.read (|
                              M.return_ (|
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::ops::try_trait::FromResidual",
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      [
                                        Ty.path "move_core_types::value::MoveStruct";
                                        Ty.path "anyhow::Error"
                                      ],
                                    [
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        [
                                          Ty.path "core::convert::Infallible";
                                          Ty.path "bcs::error::Error"
                                        ]
                                    ],
                                    "from_residual",
                                    []
                                  |),
                                  [ M.read (| residual |) ]
                                |)
                              |)
                            |)
                          |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.get_struct_tuple_field_or_break_match (|
                            γ,
                            "core::ops::control_flow::ControlFlow::Continue",
                            0
                          |) in
                        let val := M.copy (| γ0_0 |) in
                        val))
                  ]
                |)
              |)
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_simple_deserialize :
      M.IsAssociatedFunction Self "simple_deserialize" simple_deserialize.
    
    (*
        pub fn decorate(self, layout: &MoveStructLayout) -> Self {
            match (self, layout) {
                (MoveStruct::Runtime(vals), MoveStructLayout::WithFields(layouts)) => {
                    MoveStruct::WithFields(
                        vals.into_iter()
                            .zip(layouts)
                            .map(|(v, l)| (l.name.clone(), v.decorate(&l.layout)))
                            .collect(),
                    )
                }
                (MoveStruct::Runtime(vals), MoveStructLayout::WithTypes { type_, fields }) => {
                    MoveStruct::WithTypes {
                        type_: type_.clone(),
                        fields: vals
                            .into_iter()
                            .zip(fields)
                            .map(|(v, l)| (l.name.clone(), v.decorate(&l.layout)))
                            .collect(),
                    }
                }
                (MoveStruct::WithFields(vals), MoveStructLayout::WithTypes { type_, fields }) => {
                    MoveStruct::WithTypes {
                        type_: type_.clone(),
                        fields: vals
                            .into_iter()
                            .zip(fields)
                            .map(|((fld, v), l)| (fld, v.decorate(&l.layout)))
                            .collect(),
                    }
                }
                (v, _) => v, // already decorated
            }
        }
    *)
    Definition decorate (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; layout ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let layout := M.alloc (| layout |) in
          M.read (|
            M.match_operator (|
              M.alloc (| Value.Tuple [ M.read (| self |); M.read (| layout |) ] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.get_tuple_field γ 0 in
                    let γ0_1 := M.get_tuple_field γ 1 in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ0_0,
                        "move_core_types::value::MoveStruct::Runtime",
                        0
                      |) in
                    let vals := M.copy (| γ1_0 |) in
                    let γ0_1 := M.read (| γ0_1 |) in
                    let γ2_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ0_1,
                        "move_core_types::value::MoveStructLayout::WithFields",
                        0
                      |) in
                    let layouts := M.alloc (| γ2_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_core_types::value::MoveStruct::WithFields"
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::iter::traits::iterator::Iterator",
                              Ty.apply
                                (Ty.path "core::iter::adapters::map::Map")
                                [
                                  Ty.apply
                                    (Ty.path "core::iter::adapters::zip::Zip")
                                    [
                                      Ty.apply
                                        (Ty.path "alloc::vec::into_iter::IntoIter")
                                        [
                                          Ty.path "move_core_types::value::MoveValue";
                                          Ty.path "alloc::alloc::Global"
                                        ];
                                      Ty.apply
                                        (Ty.path "core::slice::iter::Iter")
                                        [ Ty.path "move_core_types::value::MoveFieldLayout" ]
                                    ];
                                  Ty.function
                                    [
                                      Ty.tuple
                                        [
                                          Ty.tuple
                                            [
                                              Ty.path "move_core_types::value::MoveValue";
                                              Ty.apply
                                                (Ty.path "&")
                                                [ Ty.path "move_core_types::value::MoveFieldLayout"
                                                ]
                                            ]
                                        ]
                                    ]
                                    (Ty.tuple
                                      [
                                        Ty.path "move_core_types::identifier::Identifier";
                                        Ty.path "move_core_types::value::MoveValue"
                                      ])
                                ],
                              [],
                              "collect",
                              [
                                Ty.apply
                                  (Ty.path "alloc::vec::Vec")
                                  [
                                    Ty.tuple
                                      [
                                        Ty.path "move_core_types::identifier::Identifier";
                                        Ty.path "move_core_types::value::MoveValue"
                                      ];
                                    Ty.path "alloc::alloc::Global"
                                  ]
                              ]
                            |),
                            [
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::iter::traits::iterator::Iterator",
                                  Ty.apply
                                    (Ty.path "core::iter::adapters::zip::Zip")
                                    [
                                      Ty.apply
                                        (Ty.path "alloc::vec::into_iter::IntoIter")
                                        [
                                          Ty.path "move_core_types::value::MoveValue";
                                          Ty.path "alloc::alloc::Global"
                                        ];
                                      Ty.apply
                                        (Ty.path "core::slice::iter::Iter")
                                        [ Ty.path "move_core_types::value::MoveFieldLayout" ]
                                    ],
                                  [],
                                  "map",
                                  [
                                    Ty.tuple
                                      [
                                        Ty.path "move_core_types::identifier::Identifier";
                                        Ty.path "move_core_types::value::MoveValue"
                                      ];
                                    Ty.function
                                      [
                                        Ty.tuple
                                          [
                                            Ty.tuple
                                              [
                                                Ty.path "move_core_types::value::MoveValue";
                                                Ty.apply
                                                  (Ty.path "&")
                                                  [
                                                    Ty.path
                                                      "move_core_types::value::MoveFieldLayout"
                                                  ]
                                              ]
                                          ]
                                      ]
                                      (Ty.tuple
                                        [
                                          Ty.path "move_core_types::identifier::Identifier";
                                          Ty.path "move_core_types::value::MoveValue"
                                        ])
                                  ]
                                |),
                                [
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::iter::traits::iterator::Iterator",
                                      Ty.apply
                                        (Ty.path "alloc::vec::into_iter::IntoIter")
                                        [
                                          Ty.path "move_core_types::value::MoveValue";
                                          Ty.path "alloc::alloc::Global"
                                        ],
                                      [],
                                      "zip",
                                      [
                                        Ty.apply
                                          (Ty.path "&")
                                          [
                                            Ty.apply
                                              (Ty.path "alloc::vec::Vec")
                                              [
                                                Ty.path "move_core_types::value::MoveFieldLayout";
                                                Ty.path "alloc::alloc::Global"
                                              ]
                                          ]
                                      ]
                                    |),
                                    [
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::iter::traits::collect::IntoIterator",
                                          Ty.apply
                                            (Ty.path "alloc::vec::Vec")
                                            [
                                              Ty.path "move_core_types::value::MoveValue";
                                              Ty.path "alloc::alloc::Global"
                                            ],
                                          [],
                                          "into_iter",
                                          []
                                        |),
                                        [ M.read (| vals |) ]
                                      |);
                                      M.read (| layouts |)
                                    ]
                                  |);
                                  M.closure
                                    (fun γ =>
                                      ltac:(M.monadic
                                        match γ with
                                        | [ α0 ] =>
                                          M.match_operator (|
                                            M.alloc (| α0 |),
                                            [
                                              fun γ =>
                                                ltac:(M.monadic
                                                  (let γ0_0 := M.get_tuple_field γ 0 in
                                                  let γ0_1 := M.get_tuple_field γ 1 in
                                                  let v := M.copy (| γ0_0 |) in
                                                  let l := M.copy (| γ0_1 |) in
                                                  Value.Tuple
                                                    [
                                                      M.call_closure (|
                                                        M.get_trait_method (|
                                                          "core::clone::Clone",
                                                          Ty.path
                                                            "move_core_types::identifier::Identifier",
                                                          [],
                                                          "clone",
                                                          []
                                                        |),
                                                        [
                                                          M.get_struct_record_field
                                                            (M.read (| l |))
                                                            "move_core_types::value::MoveFieldLayout"
                                                            "name"
                                                        ]
                                                      |);
                                                      M.call_closure (|
                                                        M.get_associated_function (|
                                                          Ty.path
                                                            "move_core_types::value::MoveValue",
                                                          "decorate",
                                                          []
                                                        |),
                                                        [
                                                          M.read (| v |);
                                                          M.get_struct_record_field
                                                            (M.read (| l |))
                                                            "move_core_types::value::MoveFieldLayout"
                                                            "layout"
                                                        ]
                                                      |)
                                                    ]))
                                            ]
                                          |)
                                        | _ => M.impossible (||)
                                        end))
                                ]
                              |)
                            ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.get_tuple_field γ 0 in
                    let γ0_1 := M.get_tuple_field γ 1 in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ0_0,
                        "move_core_types::value::MoveStruct::Runtime",
                        0
                      |) in
                    let vals := M.copy (| γ1_0 |) in
                    let γ0_1 := M.read (| γ0_1 |) in
                    let γ2_0 :=
                      M.get_struct_record_field_or_break_match (|
                        γ0_1,
                        "move_core_types::value::MoveStructLayout::WithTypes",
                        "type_"
                      |) in
                    let γ2_1 :=
                      M.get_struct_record_field_or_break_match (|
                        γ0_1,
                        "move_core_types::value::MoveStructLayout::WithTypes",
                        "fields"
                      |) in
                    let type_ := M.alloc (| γ2_0 |) in
                    let fields := M.alloc (| γ2_1 |) in
                    M.alloc (|
                      Value.StructRecord
                        "move_core_types::value::MoveStruct::WithTypes"
                        [
                          ("type_",
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::clone::Clone",
                                Ty.path "move_core_types::language_storage::StructTag",
                                [],
                                "clone",
                                []
                              |),
                              [ M.read (| type_ |) ]
                            |));
                          ("fields",
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::iter::traits::iterator::Iterator",
                                Ty.apply
                                  (Ty.path "core::iter::adapters::map::Map")
                                  [
                                    Ty.apply
                                      (Ty.path "core::iter::adapters::zip::Zip")
                                      [
                                        Ty.apply
                                          (Ty.path "alloc::vec::into_iter::IntoIter")
                                          [
                                            Ty.path "move_core_types::value::MoveValue";
                                            Ty.path "alloc::alloc::Global"
                                          ];
                                        Ty.apply
                                          (Ty.path "core::slice::iter::Iter")
                                          [ Ty.path "move_core_types::value::MoveFieldLayout" ]
                                      ];
                                    Ty.function
                                      [
                                        Ty.tuple
                                          [
                                            Ty.tuple
                                              [
                                                Ty.path "move_core_types::value::MoveValue";
                                                Ty.apply
                                                  (Ty.path "&")
                                                  [
                                                    Ty.path
                                                      "move_core_types::value::MoveFieldLayout"
                                                  ]
                                              ]
                                          ]
                                      ]
                                      (Ty.tuple
                                        [
                                          Ty.path "move_core_types::identifier::Identifier";
                                          Ty.path "move_core_types::value::MoveValue"
                                        ])
                                  ],
                                [],
                                "collect",
                                [
                                  Ty.apply
                                    (Ty.path "alloc::vec::Vec")
                                    [
                                      Ty.tuple
                                        [
                                          Ty.path "move_core_types::identifier::Identifier";
                                          Ty.path "move_core_types::value::MoveValue"
                                        ];
                                      Ty.path "alloc::alloc::Global"
                                    ]
                                ]
                              |),
                              [
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::iter::traits::iterator::Iterator",
                                    Ty.apply
                                      (Ty.path "core::iter::adapters::zip::Zip")
                                      [
                                        Ty.apply
                                          (Ty.path "alloc::vec::into_iter::IntoIter")
                                          [
                                            Ty.path "move_core_types::value::MoveValue";
                                            Ty.path "alloc::alloc::Global"
                                          ];
                                        Ty.apply
                                          (Ty.path "core::slice::iter::Iter")
                                          [ Ty.path "move_core_types::value::MoveFieldLayout" ]
                                      ],
                                    [],
                                    "map",
                                    [
                                      Ty.tuple
                                        [
                                          Ty.path "move_core_types::identifier::Identifier";
                                          Ty.path "move_core_types::value::MoveValue"
                                        ];
                                      Ty.function
                                        [
                                          Ty.tuple
                                            [
                                              Ty.tuple
                                                [
                                                  Ty.path "move_core_types::value::MoveValue";
                                                  Ty.apply
                                                    (Ty.path "&")
                                                    [
                                                      Ty.path
                                                        "move_core_types::value::MoveFieldLayout"
                                                    ]
                                                ]
                                            ]
                                        ]
                                        (Ty.tuple
                                          [
                                            Ty.path "move_core_types::identifier::Identifier";
                                            Ty.path "move_core_types::value::MoveValue"
                                          ])
                                    ]
                                  |),
                                  [
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::iter::traits::iterator::Iterator",
                                        Ty.apply
                                          (Ty.path "alloc::vec::into_iter::IntoIter")
                                          [
                                            Ty.path "move_core_types::value::MoveValue";
                                            Ty.path "alloc::alloc::Global"
                                          ],
                                        [],
                                        "zip",
                                        [
                                          Ty.apply
                                            (Ty.path "&")
                                            [
                                              Ty.apply
                                                (Ty.path "alloc::vec::Vec")
                                                [
                                                  Ty.path "move_core_types::value::MoveFieldLayout";
                                                  Ty.path "alloc::alloc::Global"
                                                ]
                                            ]
                                        ]
                                      |),
                                      [
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::iter::traits::collect::IntoIterator",
                                            Ty.apply
                                              (Ty.path "alloc::vec::Vec")
                                              [
                                                Ty.path "move_core_types::value::MoveValue";
                                                Ty.path "alloc::alloc::Global"
                                              ],
                                            [],
                                            "into_iter",
                                            []
                                          |),
                                          [ M.read (| vals |) ]
                                        |);
                                        M.read (| fields |)
                                      ]
                                    |);
                                    M.closure
                                      (fun γ =>
                                        ltac:(M.monadic
                                          match γ with
                                          | [ α0 ] =>
                                            M.match_operator (|
                                              M.alloc (| α0 |),
                                              [
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (let γ0_0 := M.get_tuple_field γ 0 in
                                                    let γ0_1 := M.get_tuple_field γ 1 in
                                                    let v := M.copy (| γ0_0 |) in
                                                    let l := M.copy (| γ0_1 |) in
                                                    Value.Tuple
                                                      [
                                                        M.call_closure (|
                                                          M.get_trait_method (|
                                                            "core::clone::Clone",
                                                            Ty.path
                                                              "move_core_types::identifier::Identifier",
                                                            [],
                                                            "clone",
                                                            []
                                                          |),
                                                          [
                                                            M.get_struct_record_field
                                                              (M.read (| l |))
                                                              "move_core_types::value::MoveFieldLayout"
                                                              "name"
                                                          ]
                                                        |);
                                                        M.call_closure (|
                                                          M.get_associated_function (|
                                                            Ty.path
                                                              "move_core_types::value::MoveValue",
                                                            "decorate",
                                                            []
                                                          |),
                                                          [
                                                            M.read (| v |);
                                                            M.get_struct_record_field
                                                              (M.read (| l |))
                                                              "move_core_types::value::MoveFieldLayout"
                                                              "layout"
                                                          ]
                                                        |)
                                                      ]))
                                              ]
                                            |)
                                          | _ => M.impossible (||)
                                          end))
                                  ]
                                |)
                              ]
                            |))
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.get_tuple_field γ 0 in
                    let γ0_1 := M.get_tuple_field γ 1 in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ0_0,
                        "move_core_types::value::MoveStruct::WithFields",
                        0
                      |) in
                    let vals := M.copy (| γ1_0 |) in
                    let γ0_1 := M.read (| γ0_1 |) in
                    let γ2_0 :=
                      M.get_struct_record_field_or_break_match (|
                        γ0_1,
                        "move_core_types::value::MoveStructLayout::WithTypes",
                        "type_"
                      |) in
                    let γ2_1 :=
                      M.get_struct_record_field_or_break_match (|
                        γ0_1,
                        "move_core_types::value::MoveStructLayout::WithTypes",
                        "fields"
                      |) in
                    let type_ := M.alloc (| γ2_0 |) in
                    let fields := M.alloc (| γ2_1 |) in
                    M.alloc (|
                      Value.StructRecord
                        "move_core_types::value::MoveStruct::WithTypes"
                        [
                          ("type_",
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::clone::Clone",
                                Ty.path "move_core_types::language_storage::StructTag",
                                [],
                                "clone",
                                []
                              |),
                              [ M.read (| type_ |) ]
                            |));
                          ("fields",
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::iter::traits::iterator::Iterator",
                                Ty.apply
                                  (Ty.path "core::iter::adapters::map::Map")
                                  [
                                    Ty.apply
                                      (Ty.path "core::iter::adapters::zip::Zip")
                                      [
                                        Ty.apply
                                          (Ty.path "alloc::vec::into_iter::IntoIter")
                                          [
                                            Ty.tuple
                                              [
                                                Ty.path "move_core_types::identifier::Identifier";
                                                Ty.path "move_core_types::value::MoveValue"
                                              ];
                                            Ty.path "alloc::alloc::Global"
                                          ];
                                        Ty.apply
                                          (Ty.path "core::slice::iter::Iter")
                                          [ Ty.path "move_core_types::value::MoveFieldLayout" ]
                                      ];
                                    Ty.function
                                      [
                                        Ty.tuple
                                          [
                                            Ty.tuple
                                              [
                                                Ty.tuple
                                                  [
                                                    Ty.path
                                                      "move_core_types::identifier::Identifier";
                                                    Ty.path "move_core_types::value::MoveValue"
                                                  ];
                                                Ty.apply
                                                  (Ty.path "&")
                                                  [
                                                    Ty.path
                                                      "move_core_types::value::MoveFieldLayout"
                                                  ]
                                              ]
                                          ]
                                      ]
                                      (Ty.tuple
                                        [
                                          Ty.path "move_core_types::identifier::Identifier";
                                          Ty.path "move_core_types::value::MoveValue"
                                        ])
                                  ],
                                [],
                                "collect",
                                [
                                  Ty.apply
                                    (Ty.path "alloc::vec::Vec")
                                    [
                                      Ty.tuple
                                        [
                                          Ty.path "move_core_types::identifier::Identifier";
                                          Ty.path "move_core_types::value::MoveValue"
                                        ];
                                      Ty.path "alloc::alloc::Global"
                                    ]
                                ]
                              |),
                              [
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::iter::traits::iterator::Iterator",
                                    Ty.apply
                                      (Ty.path "core::iter::adapters::zip::Zip")
                                      [
                                        Ty.apply
                                          (Ty.path "alloc::vec::into_iter::IntoIter")
                                          [
                                            Ty.tuple
                                              [
                                                Ty.path "move_core_types::identifier::Identifier";
                                                Ty.path "move_core_types::value::MoveValue"
                                              ];
                                            Ty.path "alloc::alloc::Global"
                                          ];
                                        Ty.apply
                                          (Ty.path "core::slice::iter::Iter")
                                          [ Ty.path "move_core_types::value::MoveFieldLayout" ]
                                      ],
                                    [],
                                    "map",
                                    [
                                      Ty.tuple
                                        [
                                          Ty.path "move_core_types::identifier::Identifier";
                                          Ty.path "move_core_types::value::MoveValue"
                                        ];
                                      Ty.function
                                        [
                                          Ty.tuple
                                            [
                                              Ty.tuple
                                                [
                                                  Ty.tuple
                                                    [
                                                      Ty.path
                                                        "move_core_types::identifier::Identifier";
                                                      Ty.path "move_core_types::value::MoveValue"
                                                    ];
                                                  Ty.apply
                                                    (Ty.path "&")
                                                    [
                                                      Ty.path
                                                        "move_core_types::value::MoveFieldLayout"
                                                    ]
                                                ]
                                            ]
                                        ]
                                        (Ty.tuple
                                          [
                                            Ty.path "move_core_types::identifier::Identifier";
                                            Ty.path "move_core_types::value::MoveValue"
                                          ])
                                    ]
                                  |),
                                  [
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::iter::traits::iterator::Iterator",
                                        Ty.apply
                                          (Ty.path "alloc::vec::into_iter::IntoIter")
                                          [
                                            Ty.tuple
                                              [
                                                Ty.path "move_core_types::identifier::Identifier";
                                                Ty.path "move_core_types::value::MoveValue"
                                              ];
                                            Ty.path "alloc::alloc::Global"
                                          ],
                                        [],
                                        "zip",
                                        [
                                          Ty.apply
                                            (Ty.path "&")
                                            [
                                              Ty.apply
                                                (Ty.path "alloc::vec::Vec")
                                                [
                                                  Ty.path "move_core_types::value::MoveFieldLayout";
                                                  Ty.path "alloc::alloc::Global"
                                                ]
                                            ]
                                        ]
                                      |),
                                      [
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::iter::traits::collect::IntoIterator",
                                            Ty.apply
                                              (Ty.path "alloc::vec::Vec")
                                              [
                                                Ty.tuple
                                                  [
                                                    Ty.path
                                                      "move_core_types::identifier::Identifier";
                                                    Ty.path "move_core_types::value::MoveValue"
                                                  ];
                                                Ty.path "alloc::alloc::Global"
                                              ],
                                            [],
                                            "into_iter",
                                            []
                                          |),
                                          [ M.read (| vals |) ]
                                        |);
                                        M.read (| fields |)
                                      ]
                                    |);
                                    M.closure
                                      (fun γ =>
                                        ltac:(M.monadic
                                          match γ with
                                          | [ α0 ] =>
                                            M.match_operator (|
                                              M.alloc (| α0 |),
                                              [
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (let γ0_0 := M.get_tuple_field γ 0 in
                                                    let γ0_1 := M.get_tuple_field γ 1 in
                                                    let γ1_0 := M.get_tuple_field γ0_0 0 in
                                                    let γ1_1 := M.get_tuple_field γ0_0 1 in
                                                    let fld := M.copy (| γ1_0 |) in
                                                    let v := M.copy (| γ1_1 |) in
                                                    let l := M.copy (| γ0_1 |) in
                                                    Value.Tuple
                                                      [
                                                        M.read (| fld |);
                                                        M.call_closure (|
                                                          M.get_associated_function (|
                                                            Ty.path
                                                              "move_core_types::value::MoveValue",
                                                            "decorate",
                                                            []
                                                          |),
                                                          [
                                                            M.read (| v |);
                                                            M.get_struct_record_field
                                                              (M.read (| l |))
                                                              "move_core_types::value::MoveFieldLayout"
                                                              "layout"
                                                          ]
                                                        |)
                                                      ]))
                                              ]
                                            |)
                                          | _ => M.impossible (||)
                                          end))
                                  ]
                                |)
                              ]
                            |))
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.get_tuple_field γ 0 in
                    let γ0_1 := M.get_tuple_field γ 1 in
                    let v := M.copy (| γ0_0 |) in
                    v))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_decorate : M.IsAssociatedFunction Self "decorate" decorate.
    
    (*
        pub fn fields(&self) -> &[MoveValue] {
            match self {
                Self::Runtime(vals) => vals,
                Self::WithFields(_) | Self::WithTypes { .. } => {
                    // It's not possible to implement this without changing the return type, and thus
                    // panicking is the best move
                    panic!("Getting fields for decorated representation")
                }
            }
        }
    *)
    Definition fields (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::value::MoveStruct::Runtime",
                        0
                      |) in
                    let vals := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::ops::deref::Deref",
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            [
                              Ty.path "move_core_types::value::MoveValue";
                              Ty.path "alloc::alloc::Global"
                            ],
                          [],
                          "deref",
                          []
                        |),
                        [ M.read (| vals |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.find_or_pattern (|
                      γ,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.read (| γ |) in
                            let γ1_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ,
                                "move_core_types::value::MoveStruct::WithFields",
                                0
                              |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.read (| γ |) in
                            Value.Tuple []))
                      ],
                      M.closure
                        (fun γ =>
                          ltac:(M.monadic
                            match γ with
                            | [] =>
                              M.alloc (|
                                M.never_to_any (|
                                  M.call_closure (|
                                    M.get_function (| "core::panicking::panic_fmt", [] |),
                                    [
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.path "core::fmt::Arguments",
                                          "new_const",
                                          []
                                        |),
                                        [
                                          (* Unsize *)
                                          M.pointer_coercion
                                            (M.alloc (|
                                              Value.Array
                                                [
                                                  M.read (|
                                                    mk_str
                                                      "Getting fields for decorated representation"
                                                  |)
                                                ]
                                            |))
                                        ]
                                      |)
                                    ]
                                  |)
                                |)
                              |)
                            | _ => M.impossible (||)
                            end))
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_fields : M.IsAssociatedFunction Self "fields" fields.
    
    (*
        pub fn into_fields(self) -> Vec<MoveValue> {
            match self {
                Self::Runtime(vals) => vals,
                Self::WithFields(fields) | Self::WithTypes { fields, .. } => {
                    fields.into_iter().map(|(_, f)| f).collect()
                }
            }
        }
    *)
    Definition into_fields (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::value::MoveStruct::Runtime",
                        0
                      |) in
                    let vals := M.copy (| γ0_0 |) in
                    vals));
                fun γ =>
                  ltac:(M.monadic
                    (M.find_or_pattern (|
                      γ,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ,
                                "move_core_types::value::MoveStruct::WithFields",
                                0
                              |) in
                            let fields := M.copy (| γ0_0 |) in
                            Value.Tuple [ fields ]));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.get_struct_record_field_or_break_match (|
                                γ,
                                "move_core_types::value::MoveStruct::WithTypes",
                                "fields"
                              |) in
                            let fields := M.copy (| γ0_0 |) in
                            Value.Tuple [ fields ]))
                      ],
                      M.closure
                        (fun γ =>
                          ltac:(M.monadic
                            match γ with
                            | [ fields ] =>
                              M.alloc (|
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::iter::traits::iterator::Iterator",
                                    Ty.apply
                                      (Ty.path "core::iter::adapters::map::Map")
                                      [
                                        Ty.apply
                                          (Ty.path "alloc::vec::into_iter::IntoIter")
                                          [
                                            Ty.tuple
                                              [
                                                Ty.path "move_core_types::identifier::Identifier";
                                                Ty.path "move_core_types::value::MoveValue"
                                              ];
                                            Ty.path "alloc::alloc::Global"
                                          ];
                                        Ty.function
                                          [
                                            Ty.tuple
                                              [
                                                Ty.tuple
                                                  [
                                                    Ty.path
                                                      "move_core_types::identifier::Identifier";
                                                    Ty.path "move_core_types::value::MoveValue"
                                                  ]
                                              ]
                                          ]
                                          (Ty.path "move_core_types::value::MoveValue")
                                      ],
                                    [],
                                    "collect",
                                    [
                                      Ty.apply
                                        (Ty.path "alloc::vec::Vec")
                                        [
                                          Ty.path "move_core_types::value::MoveValue";
                                          Ty.path "alloc::alloc::Global"
                                        ]
                                    ]
                                  |),
                                  [
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::iter::traits::iterator::Iterator",
                                        Ty.apply
                                          (Ty.path "alloc::vec::into_iter::IntoIter")
                                          [
                                            Ty.tuple
                                              [
                                                Ty.path "move_core_types::identifier::Identifier";
                                                Ty.path "move_core_types::value::MoveValue"
                                              ];
                                            Ty.path "alloc::alloc::Global"
                                          ],
                                        [],
                                        "map",
                                        [
                                          Ty.path "move_core_types::value::MoveValue";
                                          Ty.function
                                            [
                                              Ty.tuple
                                                [
                                                  Ty.tuple
                                                    [
                                                      Ty.path
                                                        "move_core_types::identifier::Identifier";
                                                      Ty.path "move_core_types::value::MoveValue"
                                                    ]
                                                ]
                                            ]
                                            (Ty.path "move_core_types::value::MoveValue")
                                        ]
                                      |),
                                      [
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::iter::traits::collect::IntoIterator",
                                            Ty.apply
                                              (Ty.path "alloc::vec::Vec")
                                              [
                                                Ty.tuple
                                                  [
                                                    Ty.path
                                                      "move_core_types::identifier::Identifier";
                                                    Ty.path "move_core_types::value::MoveValue"
                                                  ];
                                                Ty.path "alloc::alloc::Global"
                                              ],
                                            [],
                                            "into_iter",
                                            []
                                          |),
                                          [ M.read (| fields |) ]
                                        |);
                                        M.closure
                                          (fun γ =>
                                            ltac:(M.monadic
                                              match γ with
                                              | [ α0 ] =>
                                                M.match_operator (|
                                                  M.alloc (| α0 |),
                                                  [
                                                    fun γ =>
                                                      ltac:(M.monadic
                                                        (let γ0_0 := M.get_tuple_field γ 0 in
                                                        let γ0_1 := M.get_tuple_field γ 1 in
                                                        let f := M.copy (| γ0_1 |) in
                                                        M.read (| f |)))
                                                  ]
                                                |)
                                              | _ => M.impossible (||)
                                              end))
                                      ]
                                    |)
                                  ]
                                |)
                              |)
                            | _ => M.impossible (||)
                            end))
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_into_fields : M.IsAssociatedFunction Self "into_fields" into_fields.
    
    (*
        pub fn undecorate(self) -> Self {
            Self::Runtime(
                self.into_fields()
                    .into_iter()
                    .map(MoveValue::undecorate)
                    .collect(),
            )
        }
    *)
    Definition undecorate (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.StructTuple
            "move_core_types::value::MoveStruct::Runtime"
            [
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  Ty.apply
                    (Ty.path "core::iter::adapters::map::Map")
                    [
                      Ty.apply
                        (Ty.path "alloc::vec::into_iter::IntoIter")
                        [
                          Ty.path "move_core_types::value::MoveValue";
                          Ty.path "alloc::alloc::Global"
                        ];
                      Ty.function
                        [ Ty.path "move_core_types::value::MoveValue" ]
                        (Ty.path "move_core_types::value::MoveValue")
                    ],
                  [],
                  "collect",
                  [
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      [ Ty.path "move_core_types::value::MoveValue"; Ty.path "alloc::alloc::Global"
                      ]
                  ]
                |),
                [
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::iter::traits::iterator::Iterator",
                      Ty.apply
                        (Ty.path "alloc::vec::into_iter::IntoIter")
                        [
                          Ty.path "move_core_types::value::MoveValue";
                          Ty.path "alloc::alloc::Global"
                        ],
                      [],
                      "map",
                      [
                        Ty.path "move_core_types::value::MoveValue";
                        Ty.function
                          [ Ty.path "move_core_types::value::MoveValue" ]
                          (Ty.path "move_core_types::value::MoveValue")
                      ]
                    |),
                    [
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::iter::traits::collect::IntoIterator",
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            [
                              Ty.path "move_core_types::value::MoveValue";
                              Ty.path "alloc::alloc::Global"
                            ],
                          [],
                          "into_iter",
                          []
                        |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "move_core_types::value::MoveStruct",
                              "into_fields",
                              []
                            |),
                            [ M.read (| self |) ]
                          |)
                        ]
                      |);
                      M.get_associated_function (|
                        Ty.path "move_core_types::value::MoveValue",
                        "undecorate",
                        []
                      |)
                    ]
                  |)
                ]
              |)
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_undecorate : M.IsAssociatedFunction Self "undecorate" undecorate.
  End Impl_move_core_types_value_MoveStruct.
  
  Module Impl_move_core_types_value_MoveStructLayout.
    Definition Self : Ty.t := Ty.path "move_core_types::value::MoveStructLayout".
    
    (*
        pub fn new(types: Vec<MoveTypeLayout>) -> Self {
            Self::Runtime(types)
        }
    *)
    Definition new (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ types ] =>
        ltac:(M.monadic
          (let types := M.alloc (| types |) in
          Value.StructTuple
            "move_core_types::value::MoveStructLayout::Runtime"
            [ M.read (| types |) ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_new : M.IsAssociatedFunction Self "new" new.
    
    (*
        pub fn with_fields(types: Vec<MoveFieldLayout>) -> Self {
            Self::WithFields(types)
        }
    *)
    Definition with_fields (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ types ] =>
        ltac:(M.monadic
          (let types := M.alloc (| types |) in
          Value.StructTuple
            "move_core_types::value::MoveStructLayout::WithFields"
            [ M.read (| types |) ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_with_fields : M.IsAssociatedFunction Self "with_fields" with_fields.
    
    (*
        pub fn with_types(type_: StructTag, fields: Vec<MoveFieldLayout>) -> Self {
            Self::WithTypes { type_, fields }
        }
    *)
    Definition with_types (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ type_; fields ] =>
        ltac:(M.monadic
          (let type_ := M.alloc (| type_ |) in
          let fields := M.alloc (| fields |) in
          Value.StructRecord
            "move_core_types::value::MoveStructLayout::WithTypes"
            [ ("type_", M.read (| type_ |)); ("fields", M.read (| fields |)) ]))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_with_types : M.IsAssociatedFunction Self "with_types" with_types.
    
    (*
        pub fn fields(&self) -> &[MoveTypeLayout] {
            match self {
                Self::Runtime(vals) => vals,
                Self::WithFields(_) | Self::WithTypes { .. } => {
                    // It's not possible to implement this without changing the return type, and some
                    // performance-critical VM serialization code uses the Runtime case of this.
                    // panicking is the best move
                    panic!("Getting fields for decorated representation")
                }
            }
        }
    *)
    Definition fields (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::value::MoveStructLayout::Runtime",
                        0
                      |) in
                    let vals := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::ops::deref::Deref",
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            [
                              Ty.path "move_core_types::value::MoveTypeLayout";
                              Ty.path "alloc::alloc::Global"
                            ],
                          [],
                          "deref",
                          []
                        |),
                        [ M.read (| vals |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.find_or_pattern (|
                      γ,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.read (| γ |) in
                            let γ1_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ,
                                "move_core_types::value::MoveStructLayout::WithFields",
                                0
                              |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.read (| γ |) in
                            Value.Tuple []))
                      ],
                      M.closure
                        (fun γ =>
                          ltac:(M.monadic
                            match γ with
                            | [] =>
                              M.alloc (|
                                M.never_to_any (|
                                  M.call_closure (|
                                    M.get_function (| "core::panicking::panic_fmt", [] |),
                                    [
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.path "core::fmt::Arguments",
                                          "new_const",
                                          []
                                        |),
                                        [
                                          (* Unsize *)
                                          M.pointer_coercion
                                            (M.alloc (|
                                              Value.Array
                                                [
                                                  M.read (|
                                                    mk_str
                                                      "Getting fields for decorated representation"
                                                  |)
                                                ]
                                            |))
                                        ]
                                      |)
                                    ]
                                  |)
                                |)
                              |)
                            | _ => M.impossible (||)
                            end))
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_fields : M.IsAssociatedFunction Self "fields" fields.
    
    (*
        pub fn into_fields(self) -> Vec<MoveTypeLayout> {
            match self {
                Self::Runtime(vals) => vals,
                Self::WithFields(fields) | Self::WithTypes { fields, .. } => {
                    fields.into_iter().map(|f| f.layout).collect()
                }
            }
        }
    *)
    Definition into_fields (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::value::MoveStructLayout::Runtime",
                        0
                      |) in
                    let vals := M.copy (| γ0_0 |) in
                    vals));
                fun γ =>
                  ltac:(M.monadic
                    (M.find_or_pattern (|
                      γ,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ,
                                "move_core_types::value::MoveStructLayout::WithFields",
                                0
                              |) in
                            let fields := M.copy (| γ0_0 |) in
                            Value.Tuple [ fields ]));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.get_struct_record_field_or_break_match (|
                                γ,
                                "move_core_types::value::MoveStructLayout::WithTypes",
                                "fields"
                              |) in
                            let fields := M.copy (| γ0_0 |) in
                            Value.Tuple [ fields ]))
                      ],
                      M.closure
                        (fun γ =>
                          ltac:(M.monadic
                            match γ with
                            | [ fields ] =>
                              M.alloc (|
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::iter::traits::iterator::Iterator",
                                    Ty.apply
                                      (Ty.path "core::iter::adapters::map::Map")
                                      [
                                        Ty.apply
                                          (Ty.path "alloc::vec::into_iter::IntoIter")
                                          [
                                            Ty.path "move_core_types::value::MoveFieldLayout";
                                            Ty.path "alloc::alloc::Global"
                                          ];
                                        Ty.function
                                          [
                                            Ty.tuple
                                              [ Ty.path "move_core_types::value::MoveFieldLayout" ]
                                          ]
                                          (Ty.path "move_core_types::value::MoveTypeLayout")
                                      ],
                                    [],
                                    "collect",
                                    [
                                      Ty.apply
                                        (Ty.path "alloc::vec::Vec")
                                        [
                                          Ty.path "move_core_types::value::MoveTypeLayout";
                                          Ty.path "alloc::alloc::Global"
                                        ]
                                    ]
                                  |),
                                  [
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::iter::traits::iterator::Iterator",
                                        Ty.apply
                                          (Ty.path "alloc::vec::into_iter::IntoIter")
                                          [
                                            Ty.path "move_core_types::value::MoveFieldLayout";
                                            Ty.path "alloc::alloc::Global"
                                          ],
                                        [],
                                        "map",
                                        [
                                          Ty.path "move_core_types::value::MoveTypeLayout";
                                          Ty.function
                                            [
                                              Ty.tuple
                                                [ Ty.path "move_core_types::value::MoveFieldLayout"
                                                ]
                                            ]
                                            (Ty.path "move_core_types::value::MoveTypeLayout")
                                        ]
                                      |),
                                      [
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::iter::traits::collect::IntoIterator",
                                            Ty.apply
                                              (Ty.path "alloc::vec::Vec")
                                              [
                                                Ty.path "move_core_types::value::MoveFieldLayout";
                                                Ty.path "alloc::alloc::Global"
                                              ],
                                            [],
                                            "into_iter",
                                            []
                                          |),
                                          [ M.read (| fields |) ]
                                        |);
                                        M.closure
                                          (fun γ =>
                                            ltac:(M.monadic
                                              match γ with
                                              | [ α0 ] =>
                                                M.match_operator (|
                                                  M.alloc (| α0 |),
                                                  [
                                                    fun γ =>
                                                      ltac:(M.monadic
                                                        (let f := M.copy (| γ |) in
                                                        M.read (|
                                                          M.get_struct_record_field
                                                            f
                                                            "move_core_types::value::MoveFieldLayout"
                                                            "layout"
                                                        |)))
                                                  ]
                                                |)
                                              | _ => M.impossible (||)
                                              end))
                                      ]
                                    |)
                                  ]
                                |)
                              |)
                            | _ => M.impossible (||)
                            end))
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_into_fields : M.IsAssociatedFunction Self "into_fields" into_fields.
  End Impl_move_core_types_value_MoveStructLayout.
  
  Module Impl_serde_de_DeserializeSeed_for_ref__move_core_types_value_MoveTypeLayout.
    Definition Self : Ty.t :=
      Ty.apply (Ty.path "&") [ Ty.path "move_core_types::value::MoveTypeLayout" ].
    
    (*     type Value = MoveValue; *)
    Definition _Value : Ty.t := Ty.path "move_core_types::value::MoveValue".
    
    (*
        fn deserialize<D: serde::de::Deserializer<'d>>(
            self,
            deserializer: D,
        ) -> Result<Self::Value, D::Error> {
            match self {
                MoveTypeLayout::Bool => bool::deserialize(deserializer).map(MoveValue::Bool),
                MoveTypeLayout::U8 => u8::deserialize(deserializer).map(MoveValue::U8),
                MoveTypeLayout::U16 => u16::deserialize(deserializer).map(MoveValue::U16),
                MoveTypeLayout::U32 => u32::deserialize(deserializer).map(MoveValue::U32),
                MoveTypeLayout::U64 => u64::deserialize(deserializer).map(MoveValue::U64),
                MoveTypeLayout::U128 => u128::deserialize(deserializer).map(MoveValue::U128),
                MoveTypeLayout::U256 => u256::U256::deserialize(deserializer).map(MoveValue::U256),
                MoveTypeLayout::Address => {
                    AccountAddress::deserialize(deserializer).map(MoveValue::Address)
                }
                MoveTypeLayout::Signer => {
                    AccountAddress::deserialize(deserializer).map(MoveValue::Signer)
                }
                MoveTypeLayout::Struct(ty) => Ok(MoveValue::Struct(ty.deserialize(deserializer)?)),
                MoveTypeLayout::Vector(layout) => Ok(MoveValue::Vector(
                    deserializer.deserialize_seq(VectorElementVisitor(layout))?,
                )),
            }
        }
    *)
    Definition deserialize (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ D ], [ self; deserializer ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let deserializer := M.alloc (| deserializer |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "core::result::Result")
                            [ Ty.path "bool"; Ty.associated ],
                          "map",
                          [
                            Ty.path "move_core_types::value::MoveValue";
                            Ty.function
                              [ Ty.path "bool" ]
                              (Ty.path "move_core_types::value::MoveValue")
                          ]
                        |),
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "serde::de::Deserialize",
                              Ty.path "bool",
                              [],
                              "deserialize",
                              [ D ]
                            |),
                            [ M.read (| deserializer |) ]
                          |);
                          M.constructor_as_closure "move_core_types::value::MoveValue::Bool"
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply (Ty.path "core::result::Result") [ Ty.path "u8"; Ty.associated ],
                          "map",
                          [
                            Ty.path "move_core_types::value::MoveValue";
                            Ty.function
                              [ Ty.path "u8" ]
                              (Ty.path "move_core_types::value::MoveValue")
                          ]
                        |),
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "serde::de::Deserialize",
                              Ty.path "u8",
                              [],
                              "deserialize",
                              [ D ]
                            |),
                            [ M.read (| deserializer |) ]
                          |);
                          M.constructor_as_closure "move_core_types::value::MoveValue::U8"
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "core::result::Result")
                            [ Ty.path "u16"; Ty.associated ],
                          "map",
                          [
                            Ty.path "move_core_types::value::MoveValue";
                            Ty.function
                              [ Ty.path "u16" ]
                              (Ty.path "move_core_types::value::MoveValue")
                          ]
                        |),
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "serde::de::Deserialize",
                              Ty.path "u16",
                              [],
                              "deserialize",
                              [ D ]
                            |),
                            [ M.read (| deserializer |) ]
                          |);
                          M.constructor_as_closure "move_core_types::value::MoveValue::U16"
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "core::result::Result")
                            [ Ty.path "u32"; Ty.associated ],
                          "map",
                          [
                            Ty.path "move_core_types::value::MoveValue";
                            Ty.function
                              [ Ty.path "u32" ]
                              (Ty.path "move_core_types::value::MoveValue")
                          ]
                        |),
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "serde::de::Deserialize",
                              Ty.path "u32",
                              [],
                              "deserialize",
                              [ D ]
                            |),
                            [ M.read (| deserializer |) ]
                          |);
                          M.constructor_as_closure "move_core_types::value::MoveValue::U32"
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "core::result::Result")
                            [ Ty.path "u64"; Ty.associated ],
                          "map",
                          [
                            Ty.path "move_core_types::value::MoveValue";
                            Ty.function
                              [ Ty.path "u64" ]
                              (Ty.path "move_core_types::value::MoveValue")
                          ]
                        |),
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "serde::de::Deserialize",
                              Ty.path "u64",
                              [],
                              "deserialize",
                              [ D ]
                            |),
                            [ M.read (| deserializer |) ]
                          |);
                          M.constructor_as_closure "move_core_types::value::MoveValue::U64"
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "core::result::Result")
                            [ Ty.path "u128"; Ty.associated ],
                          "map",
                          [
                            Ty.path "move_core_types::value::MoveValue";
                            Ty.function
                              [ Ty.path "u128" ]
                              (Ty.path "move_core_types::value::MoveValue")
                          ]
                        |),
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "serde::de::Deserialize",
                              Ty.path "u128",
                              [],
                              "deserialize",
                              [ D ]
                            |),
                            [ M.read (| deserializer |) ]
                          |);
                          M.constructor_as_closure "move_core_types::value::MoveValue::U128"
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "core::result::Result")
                            [ Ty.path "move_core_types::u256::U256"; Ty.associated ],
                          "map",
                          [
                            Ty.path "move_core_types::value::MoveValue";
                            Ty.function
                              [ Ty.path "move_core_types::u256::U256" ]
                              (Ty.path "move_core_types::value::MoveValue")
                          ]
                        |),
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "serde::de::Deserialize",
                              Ty.path "move_core_types::u256::U256",
                              [],
                              "deserialize",
                              [ D ]
                            |),
                            [ M.read (| deserializer |) ]
                          |);
                          M.constructor_as_closure "move_core_types::value::MoveValue::U256"
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "core::result::Result")
                            [
                              Ty.path "move_core_types::account_address::AccountAddress";
                              Ty.associated
                            ],
                          "map",
                          [
                            Ty.path "move_core_types::value::MoveValue";
                            Ty.function
                              [ Ty.path "move_core_types::account_address::AccountAddress" ]
                              (Ty.path "move_core_types::value::MoveValue")
                          ]
                        |),
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "serde::de::Deserialize",
                              Ty.path "move_core_types::account_address::AccountAddress",
                              [],
                              "deserialize",
                              [ D ]
                            |),
                            [ M.read (| deserializer |) ]
                          |);
                          M.constructor_as_closure "move_core_types::value::MoveValue::Address"
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "core::result::Result")
                            [
                              Ty.path "move_core_types::account_address::AccountAddress";
                              Ty.associated
                            ],
                          "map",
                          [
                            Ty.path "move_core_types::value::MoveValue";
                            Ty.function
                              [ Ty.path "move_core_types::account_address::AccountAddress" ]
                              (Ty.path "move_core_types::value::MoveValue")
                          ]
                        |),
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "serde::de::Deserialize",
                              Ty.path "move_core_types::account_address::AccountAddress",
                              [],
                              "deserialize",
                              [ D ]
                            |),
                            [ M.read (| deserializer |) ]
                          |);
                          M.constructor_as_closure "move_core_types::value::MoveValue::Signer"
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::value::MoveTypeLayout::Struct",
                        0
                      |) in
                    let ty := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::value::MoveValue::Struct"
                            [
                              M.read (|
                                M.match_operator (|
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::ops::try_trait::Try",
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          [
                                            Ty.path "move_core_types::value::MoveStruct";
                                            Ty.associated
                                          ],
                                        [],
                                        "branch",
                                        []
                                      |),
                                      [
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "serde::de::DeserializeSeed",
                                            Ty.apply
                                              (Ty.path "&")
                                              [ Ty.path "move_core_types::value::MoveStructLayout"
                                              ],
                                            [],
                                            "deserialize",
                                            [ D ]
                                          |),
                                          [ M.read (| ty |); M.read (| deserializer |) ]
                                        |)
                                      ]
                                    |)
                                  |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 :=
                                          M.get_struct_tuple_field_or_break_match (|
                                            γ,
                                            "core::ops::control_flow::ControlFlow::Break",
                                            0
                                          |) in
                                        let residual := M.copy (| γ0_0 |) in
                                        M.alloc (|
                                          M.never_to_any (|
                                            M.read (|
                                              M.return_ (|
                                                M.call_closure (|
                                                  M.get_trait_method (|
                                                    "core::ops::try_trait::FromResidual",
                                                    Ty.apply
                                                      (Ty.path "core::result::Result")
                                                      [
                                                        Ty.path "move_core_types::value::MoveValue";
                                                        Ty.associated
                                                      ],
                                                    [
                                                      Ty.apply
                                                        (Ty.path "core::result::Result")
                                                        [
                                                          Ty.path "core::convert::Infallible";
                                                          Ty.associated
                                                        ]
                                                    ],
                                                    "from_residual",
                                                    []
                                                  |),
                                                  [ M.read (| residual |) ]
                                                |)
                                              |)
                                            |)
                                          |)
                                        |)));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 :=
                                          M.get_struct_tuple_field_or_break_match (|
                                            γ,
                                            "core::ops::control_flow::ControlFlow::Continue",
                                            0
                                          |) in
                                        let val := M.copy (| γ0_0 |) in
                                        val))
                                  ]
                                |)
                              |)
                            ]
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::value::MoveTypeLayout::Vector",
                        0
                      |) in
                    let layout := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::value::MoveValue::Vector"
                            [
                              M.read (|
                                M.match_operator (|
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::ops::try_trait::Try",
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          [
                                            Ty.apply
                                              (Ty.path "alloc::vec::Vec")
                                              [
                                                Ty.path "move_core_types::value::MoveValue";
                                                Ty.path "alloc::alloc::Global"
                                              ];
                                            Ty.associated
                                          ],
                                        [],
                                        "branch",
                                        []
                                      |),
                                      [
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "serde::de::Deserializer",
                                            D,
                                            [],
                                            "deserialize_seq",
                                            [ Ty.path "move_core_types::value::VectorElementVisitor"
                                            ]
                                          |),
                                          [
                                            M.read (| deserializer |);
                                            Value.StructTuple
                                              "move_core_types::value::VectorElementVisitor"
                                              [ M.read (| M.read (| layout |) |) ]
                                          ]
                                        |)
                                      ]
                                    |)
                                  |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 :=
                                          M.get_struct_tuple_field_or_break_match (|
                                            γ,
                                            "core::ops::control_flow::ControlFlow::Break",
                                            0
                                          |) in
                                        let residual := M.copy (| γ0_0 |) in
                                        M.alloc (|
                                          M.never_to_any (|
                                            M.read (|
                                              M.return_ (|
                                                M.call_closure (|
                                                  M.get_trait_method (|
                                                    "core::ops::try_trait::FromResidual",
                                                    Ty.apply
                                                      (Ty.path "core::result::Result")
                                                      [
                                                        Ty.path "move_core_types::value::MoveValue";
                                                        Ty.associated
                                                      ],
                                                    [
                                                      Ty.apply
                                                        (Ty.path "core::result::Result")
                                                        [
                                                          Ty.path "core::convert::Infallible";
                                                          Ty.associated
                                                        ]
                                                    ],
                                                    "from_residual",
                                                    []
                                                  |),
                                                  [ M.read (| residual |) ]
                                                |)
                                              |)
                                            |)
                                          |)
                                        |)));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 :=
                                          M.get_struct_tuple_field_or_break_match (|
                                            γ,
                                            "core::ops::control_flow::ControlFlow::Continue",
                                            0
                                          |) in
                                        let val := M.copy (| γ0_0 |) in
                                        val))
                                  ]
                                |)
                              |)
                            ]
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "serde::de::DeserializeSeed"
        Self
        (* Trait polymorphic types *) []
        (* Instance *)
        [ ("Value", InstanceField.Ty _Value); ("deserialize", InstanceField.Method deserialize) ].
  End Impl_serde_de_DeserializeSeed_for_ref__move_core_types_value_MoveTypeLayout.
  
  (* StructTuple
    {
      name := "VectorElementVisitor";
      ty_params := [];
      fields := [ Ty.apply (Ty.path "&") [ Ty.path "move_core_types::value::MoveTypeLayout" ] ];
    } *)
  
  Module Impl_serde_de_Visitor_for_move_core_types_value_VectorElementVisitor.
    Definition Self : Ty.t := Ty.path "move_core_types::value::VectorElementVisitor".
    
    (*     type Value = Vec<MoveValue>; *)
    Definition _Value : Ty.t :=
      Ty.apply
        (Ty.path "alloc::vec::Vec")
        [ Ty.path "move_core_types::value::MoveValue"; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn expecting(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {
            formatter.write_str("Vector")
        }
    *)
    Definition expecting (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; formatter ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let formatter := M.alloc (| formatter |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_str", [] |),
            [ M.read (| formatter |); M.read (| mk_str "Vector" |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    (*
        fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>
        where
            A: serde::de::SeqAccess<'d>,
        {
            let mut vals = Vec::new();
            while let Some(elem) = seq.next_element_seed(self.0)? {
                vals.push(elem)
            }
            Ok(vals)
        }
    *)
    Definition visit_seq (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ A ], [ self; seq ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let seq := M.alloc (| seq |) in
          M.read (|
            let vals :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      [ Ty.path "move_core_types::value::MoveValue"; Ty.path "alloc::alloc::Global"
                      ],
                    "new",
                    []
                  |),
                  []
                |)
              |) in
            let _ :=
              M.loop (|
                ltac:(M.monadic
                  (M.match_operator (|
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.match_operator (|
                              M.alloc (|
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::ops::try_trait::Try",
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      [
                                        Ty.apply
                                          (Ty.path "core::option::Option")
                                          [ Ty.path "move_core_types::value::MoveValue" ];
                                        Ty.associated
                                      ],
                                    [],
                                    "branch",
                                    []
                                  |),
                                  [
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "serde::de::SeqAccess",
                                        A,
                                        [],
                                        "next_element_seed",
                                        [
                                          Ty.apply
                                            (Ty.path "&")
                                            [ Ty.path "move_core_types::value::MoveTypeLayout" ]
                                        ]
                                      |),
                                      [
                                        seq;
                                        M.read (|
                                          M.get_struct_tuple_field
                                            self
                                            "move_core_types::value::VectorElementVisitor"
                                            0
                                        |)
                                      ]
                                    |)
                                  ]
                                |)
                              |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ0_0 :=
                                      M.get_struct_tuple_field_or_break_match (|
                                        γ,
                                        "core::ops::control_flow::ControlFlow::Break",
                                        0
                                      |) in
                                    let residual := M.copy (| γ0_0 |) in
                                    M.alloc (|
                                      M.never_to_any (|
                                        M.read (|
                                          M.return_ (|
                                            M.call_closure (|
                                              M.get_trait_method (|
                                                "core::ops::try_trait::FromResidual",
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  [
                                                    Ty.apply
                                                      (Ty.path "alloc::vec::Vec")
                                                      [
                                                        Ty.path "move_core_types::value::MoveValue";
                                                        Ty.path "alloc::alloc::Global"
                                                      ];
                                                    Ty.associated
                                                  ],
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::result::Result")
                                                    [
                                                      Ty.path "core::convert::Infallible";
                                                      Ty.associated
                                                    ]
                                                ],
                                                "from_residual",
                                                []
                                              |),
                                              [ M.read (| residual |) ]
                                            |)
                                          |)
                                        |)
                                      |)
                                    |)));
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ0_0 :=
                                      M.get_struct_tuple_field_or_break_match (|
                                        γ,
                                        "core::ops::control_flow::ControlFlow::Continue",
                                        0
                                      |) in
                                    let val := M.copy (| γ0_0 |) in
                                    val))
                              ]
                            |) in
                          let γ0_0 :=
                            M.get_struct_tuple_field_or_break_match (|
                              γ,
                              "core::option::Option::Some",
                              0
                            |) in
                          let elem := M.copy (| γ0_0 |) in
                          M.alloc (|
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "alloc::vec::Vec")
                                  [
                                    Ty.path "move_core_types::value::MoveValue";
                                    Ty.path "alloc::alloc::Global"
                                  ],
                                "push",
                                []
                              |),
                              [ vals; M.read (| elem |) ]
                            |)
                          |)));
                      fun γ =>
                        ltac:(M.monadic
                          (M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                let _ :=
                                  M.alloc (| M.never_to_any (| M.read (| M.break (||) |) |) |) in
                                M.alloc (| Value.Tuple [] |)
                              |)
                            |)
                          |)))
                    ]
                  |)))
              |) in
            M.alloc (| Value.StructTuple "core::result::Result::Ok" [ M.read (| vals |) ] |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "serde::de::Visitor"
        Self
        (* Trait polymorphic types *) []
        (* Instance *)
        [
          ("Value", InstanceField.Ty _Value);
          ("expecting", InstanceField.Method expecting);
          ("visit_seq", InstanceField.Method visit_seq)
        ].
  End Impl_serde_de_Visitor_for_move_core_types_value_VectorElementVisitor.
  
  (* StructTuple
    {
      name := "DecoratedStructFieldVisitor";
      ty_params := [];
      fields :=
        [
          Ty.apply
            (Ty.path "&")
            [ Ty.apply (Ty.path "slice") [ Ty.path "move_core_types::value::MoveFieldLayout" ] ]
        ];
    } *)
  
  Module Impl_serde_de_Visitor_for_move_core_types_value_DecoratedStructFieldVisitor.
    Definition Self : Ty.t := Ty.path "move_core_types::value::DecoratedStructFieldVisitor".
    
    (*     type Value = Vec<(Identifier, MoveValue)>; *)
    Definition _Value : Ty.t :=
      Ty.apply
        (Ty.path "alloc::vec::Vec")
        [
          Ty.tuple
            [
              Ty.path "move_core_types::identifier::Identifier";
              Ty.path "move_core_types::value::MoveValue"
            ];
          Ty.path "alloc::alloc::Global"
        ].
    
    (*
        fn expecting(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {
            formatter.write_str("Struct")
        }
    *)
    Definition expecting (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; formatter ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let formatter := M.alloc (| formatter |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_str", [] |),
            [ M.read (| formatter |); M.read (| mk_str "Struct" |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    (*
        fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>
        where
            A: serde::de::SeqAccess<'d>,
        {
            let mut vals = Vec::new();
            for (i, layout) in self.0.iter().enumerate() {
                match seq.next_element_seed(layout)? {
                    Some(elem) => vals.push(elem),
                    None => return Err(A::Error::invalid_length(i, &self)),
                }
            }
            Ok(vals)
        }
    *)
    Definition visit_seq (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ A ], [ self; seq ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let seq := M.alloc (| seq |) in
          M.read (|
            let vals :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      [
                        Ty.tuple
                          [
                            Ty.path "move_core_types::identifier::Identifier";
                            Ty.path "move_core_types::value::MoveValue"
                          ];
                        Ty.path "alloc::alloc::Global"
                      ],
                    "new",
                    []
                  |),
                  []
                |)
              |) in
            let _ :=
              M.use
                (M.match_operator (|
                  M.alloc (|
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::iter::traits::collect::IntoIterator",
                        Ty.apply
                          (Ty.path "core::iter::adapters::enumerate::Enumerate")
                          [
                            Ty.apply
                              (Ty.path "core::slice::iter::Iter")
                              [ Ty.path "move_core_types::value::MoveFieldLayout" ]
                          ],
                        [],
                        "into_iter",
                        []
                      |),
                      [
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::iter::traits::iterator::Iterator",
                            Ty.apply
                              (Ty.path "core::slice::iter::Iter")
                              [ Ty.path "move_core_types::value::MoveFieldLayout" ],
                            [],
                            "enumerate",
                            []
                          |),
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "slice")
                                  [ Ty.path "move_core_types::value::MoveFieldLayout" ],
                                "iter",
                                []
                              |),
                              [
                                M.read (|
                                  M.get_struct_tuple_field
                                    self
                                    "move_core_types::value::DecoratedStructFieldVisitor"
                                    0
                                |)
                              ]
                            |)
                          ]
                        |)
                      ]
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let iter := M.copy (| γ |) in
                        M.loop (|
                          ltac:(M.monadic
                            (let _ :=
                              M.match_operator (|
                                M.alloc (|
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::iter::traits::iterator::Iterator",
                                      Ty.apply
                                        (Ty.path "core::iter::adapters::enumerate::Enumerate")
                                        [
                                          Ty.apply
                                            (Ty.path "core::slice::iter::Iter")
                                            [ Ty.path "move_core_types::value::MoveFieldLayout" ]
                                        ],
                                      [],
                                      "next",
                                      []
                                    |),
                                    [ iter ]
                                  |)
                                |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (M.alloc (|
                                        M.never_to_any (| M.read (| M.break (||) |) |)
                                      |)));
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ0_0 :=
                                        M.get_struct_tuple_field_or_break_match (|
                                          γ,
                                          "core::option::Option::Some",
                                          0
                                        |) in
                                      let γ1_0 := M.get_tuple_field γ0_0 0 in
                                      let γ1_1 := M.get_tuple_field γ0_0 1 in
                                      let i := M.copy (| γ1_0 |) in
                                      let layout := M.copy (| γ1_1 |) in
                                      M.match_operator (|
                                        M.match_operator (|
                                          M.alloc (|
                                            M.call_closure (|
                                              M.get_trait_method (|
                                                "core::ops::try_trait::Try",
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  [
                                                    Ty.apply
                                                      (Ty.path "core::option::Option")
                                                      [
                                                        Ty.tuple
                                                          [
                                                            Ty.path
                                                              "move_core_types::identifier::Identifier";
                                                            Ty.path
                                                              "move_core_types::value::MoveValue"
                                                          ]
                                                      ];
                                                    Ty.associated
                                                  ],
                                                [],
                                                "branch",
                                                []
                                              |),
                                              [
                                                M.call_closure (|
                                                  M.get_trait_method (|
                                                    "serde::de::SeqAccess",
                                                    A,
                                                    [],
                                                    "next_element_seed",
                                                    [
                                                      Ty.apply
                                                        (Ty.path "&")
                                                        [
                                                          Ty.path
                                                            "move_core_types::value::MoveFieldLayout"
                                                        ]
                                                    ]
                                                  |),
                                                  [ seq; M.read (| layout |) ]
                                                |)
                                              ]
                                            |)
                                          |),
                                          [
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let γ0_0 :=
                                                  M.get_struct_tuple_field_or_break_match (|
                                                    γ,
                                                    "core::ops::control_flow::ControlFlow::Break",
                                                    0
                                                  |) in
                                                let residual := M.copy (| γ0_0 |) in
                                                M.alloc (|
                                                  M.never_to_any (|
                                                    M.read (|
                                                      M.return_ (|
                                                        M.call_closure (|
                                                          M.get_trait_method (|
                                                            "core::ops::try_trait::FromResidual",
                                                            Ty.apply
                                                              (Ty.path "core::result::Result")
                                                              [
                                                                Ty.apply
                                                                  (Ty.path "alloc::vec::Vec")
                                                                  [
                                                                    Ty.tuple
                                                                      [
                                                                        Ty.path
                                                                          "move_core_types::identifier::Identifier";
                                                                        Ty.path
                                                                          "move_core_types::value::MoveValue"
                                                                      ];
                                                                    Ty.path "alloc::alloc::Global"
                                                                  ];
                                                                Ty.associated
                                                              ],
                                                            [
                                                              Ty.apply
                                                                (Ty.path "core::result::Result")
                                                                [
                                                                  Ty.path
                                                                    "core::convert::Infallible";
                                                                  Ty.associated
                                                                ]
                                                            ],
                                                            "from_residual",
                                                            []
                                                          |),
                                                          [ M.read (| residual |) ]
                                                        |)
                                                      |)
                                                    |)
                                                  |)
                                                |)));
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let γ0_0 :=
                                                  M.get_struct_tuple_field_or_break_match (|
                                                    γ,
                                                    "core::ops::control_flow::ControlFlow::Continue",
                                                    0
                                                  |) in
                                                let val := M.copy (| γ0_0 |) in
                                                val))
                                          ]
                                        |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let γ0_0 :=
                                                M.get_struct_tuple_field_or_break_match (|
                                                  γ,
                                                  "core::option::Option::Some",
                                                  0
                                                |) in
                                              let elem := M.copy (| γ0_0 |) in
                                              M.alloc (|
                                                M.call_closure (|
                                                  M.get_associated_function (|
                                                    Ty.apply
                                                      (Ty.path "alloc::vec::Vec")
                                                      [
                                                        Ty.tuple
                                                          [
                                                            Ty.path
                                                              "move_core_types::identifier::Identifier";
                                                            Ty.path
                                                              "move_core_types::value::MoveValue"
                                                          ];
                                                        Ty.path "alloc::alloc::Global"
                                                      ],
                                                    "push",
                                                    []
                                                  |),
                                                  [ vals; M.read (| elem |) ]
                                                |)
                                              |)));
                                          fun γ =>
                                            ltac:(M.monadic
                                              (M.alloc (|
                                                M.never_to_any (|
                                                  M.read (|
                                                    M.return_ (|
                                                      Value.StructTuple
                                                        "core::result::Result::Err"
                                                        [
                                                          M.call_closure (|
                                                            M.get_trait_method (|
                                                              "serde::de::Error",
                                                              Ty.associated,
                                                              [],
                                                              "invalid_length",
                                                              []
                                                            |),
                                                            [
                                                              M.read (| i |);
                                                              (* Unsize *) M.pointer_coercion self
                                                            ]
                                                          |)
                                                        ]
                                                    |)
                                                  |)
                                                |)
                                              |)))
                                        ]
                                      |)))
                                ]
                              |) in
                            M.alloc (| Value.Tuple [] |)))
                        |)))
                  ]
                |)) in
            M.alloc (| Value.StructTuple "core::result::Result::Ok" [ M.read (| vals |) ] |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "serde::de::Visitor"
        Self
        (* Trait polymorphic types *) []
        (* Instance *)
        [
          ("Value", InstanceField.Ty _Value);
          ("expecting", InstanceField.Method expecting);
          ("visit_seq", InstanceField.Method visit_seq)
        ].
  End Impl_serde_de_Visitor_for_move_core_types_value_DecoratedStructFieldVisitor.
  
  (* StructTuple
    {
      name := "StructFieldVisitor";
      ty_params := [];
      fields :=
        [
          Ty.apply
            (Ty.path "&")
            [ Ty.apply (Ty.path "slice") [ Ty.path "move_core_types::value::MoveTypeLayout" ] ]
        ];
    } *)
  
  Module Impl_serde_de_Visitor_for_move_core_types_value_StructFieldVisitor.
    Definition Self : Ty.t := Ty.path "move_core_types::value::StructFieldVisitor".
    
    (*     type Value = Vec<MoveValue>; *)
    Definition _Value : Ty.t :=
      Ty.apply
        (Ty.path "alloc::vec::Vec")
        [ Ty.path "move_core_types::value::MoveValue"; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn expecting(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {
            formatter.write_str("Struct")
        }
    *)
    Definition expecting (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; formatter ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let formatter := M.alloc (| formatter |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_str", [] |),
            [ M.read (| formatter |); M.read (| mk_str "Struct" |) ]
          |)))
      | _, _ => M.impossible
      end.
    
    (*
        fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>
        where
            A: serde::de::SeqAccess<'d>,
        {
            let mut val = Vec::new();
            for (i, field_type) in self.0.iter().enumerate() {
                match seq.next_element_seed(field_type)? {
                    Some(elem) => val.push(elem),
                    None => return Err(A::Error::invalid_length(i, &self)),
                }
            }
            Ok(val)
        }
    *)
    Definition visit_seq (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ A ], [ self; seq ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let seq := M.alloc (| seq |) in
          M.read (|
            let val :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      [ Ty.path "move_core_types::value::MoveValue"; Ty.path "alloc::alloc::Global"
                      ],
                    "new",
                    []
                  |),
                  []
                |)
              |) in
            let _ :=
              M.use
                (M.match_operator (|
                  M.alloc (|
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::iter::traits::collect::IntoIterator",
                        Ty.apply
                          (Ty.path "core::iter::adapters::enumerate::Enumerate")
                          [
                            Ty.apply
                              (Ty.path "core::slice::iter::Iter")
                              [ Ty.path "move_core_types::value::MoveTypeLayout" ]
                          ],
                        [],
                        "into_iter",
                        []
                      |),
                      [
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::iter::traits::iterator::Iterator",
                            Ty.apply
                              (Ty.path "core::slice::iter::Iter")
                              [ Ty.path "move_core_types::value::MoveTypeLayout" ],
                            [],
                            "enumerate",
                            []
                          |),
                          [
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "slice")
                                  [ Ty.path "move_core_types::value::MoveTypeLayout" ],
                                "iter",
                                []
                              |),
                              [
                                M.read (|
                                  M.get_struct_tuple_field
                                    self
                                    "move_core_types::value::StructFieldVisitor"
                                    0
                                |)
                              ]
                            |)
                          ]
                        |)
                      ]
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let iter := M.copy (| γ |) in
                        M.loop (|
                          ltac:(M.monadic
                            (let _ :=
                              M.match_operator (|
                                M.alloc (|
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::iter::traits::iterator::Iterator",
                                      Ty.apply
                                        (Ty.path "core::iter::adapters::enumerate::Enumerate")
                                        [
                                          Ty.apply
                                            (Ty.path "core::slice::iter::Iter")
                                            [ Ty.path "move_core_types::value::MoveTypeLayout" ]
                                        ],
                                      [],
                                      "next",
                                      []
                                    |),
                                    [ iter ]
                                  |)
                                |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (M.alloc (|
                                        M.never_to_any (| M.read (| M.break (||) |) |)
                                      |)));
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ0_0 :=
                                        M.get_struct_tuple_field_or_break_match (|
                                          γ,
                                          "core::option::Option::Some",
                                          0
                                        |) in
                                      let γ1_0 := M.get_tuple_field γ0_0 0 in
                                      let γ1_1 := M.get_tuple_field γ0_0 1 in
                                      let i := M.copy (| γ1_0 |) in
                                      let field_type := M.copy (| γ1_1 |) in
                                      M.match_operator (|
                                        M.match_operator (|
                                          M.alloc (|
                                            M.call_closure (|
                                              M.get_trait_method (|
                                                "core::ops::try_trait::Try",
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  [
                                                    Ty.apply
                                                      (Ty.path "core::option::Option")
                                                      [ Ty.path "move_core_types::value::MoveValue"
                                                      ];
                                                    Ty.associated
                                                  ],
                                                [],
                                                "branch",
                                                []
                                              |),
                                              [
                                                M.call_closure (|
                                                  M.get_trait_method (|
                                                    "serde::de::SeqAccess",
                                                    A,
                                                    [],
                                                    "next_element_seed",
                                                    [
                                                      Ty.apply
                                                        (Ty.path "&")
                                                        [
                                                          Ty.path
                                                            "move_core_types::value::MoveTypeLayout"
                                                        ]
                                                    ]
                                                  |),
                                                  [ seq; M.read (| field_type |) ]
                                                |)
                                              ]
                                            |)
                                          |),
                                          [
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let γ0_0 :=
                                                  M.get_struct_tuple_field_or_break_match (|
                                                    γ,
                                                    "core::ops::control_flow::ControlFlow::Break",
                                                    0
                                                  |) in
                                                let residual := M.copy (| γ0_0 |) in
                                                M.alloc (|
                                                  M.never_to_any (|
                                                    M.read (|
                                                      M.return_ (|
                                                        M.call_closure (|
                                                          M.get_trait_method (|
                                                            "core::ops::try_trait::FromResidual",
                                                            Ty.apply
                                                              (Ty.path "core::result::Result")
                                                              [
                                                                Ty.apply
                                                                  (Ty.path "alloc::vec::Vec")
                                                                  [
                                                                    Ty.path
                                                                      "move_core_types::value::MoveValue";
                                                                    Ty.path "alloc::alloc::Global"
                                                                  ];
                                                                Ty.associated
                                                              ],
                                                            [
                                                              Ty.apply
                                                                (Ty.path "core::result::Result")
                                                                [
                                                                  Ty.path
                                                                    "core::convert::Infallible";
                                                                  Ty.associated
                                                                ]
                                                            ],
                                                            "from_residual",
                                                            []
                                                          |),
                                                          [ M.read (| residual |) ]
                                                        |)
                                                      |)
                                                    |)
                                                  |)
                                                |)));
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let γ0_0 :=
                                                  M.get_struct_tuple_field_or_break_match (|
                                                    γ,
                                                    "core::ops::control_flow::ControlFlow::Continue",
                                                    0
                                                  |) in
                                                let val := M.copy (| γ0_0 |) in
                                                val))
                                          ]
                                        |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let γ0_0 :=
                                                M.get_struct_tuple_field_or_break_match (|
                                                  γ,
                                                  "core::option::Option::Some",
                                                  0
                                                |) in
                                              let elem := M.copy (| γ0_0 |) in
                                              M.alloc (|
                                                M.call_closure (|
                                                  M.get_associated_function (|
                                                    Ty.apply
                                                      (Ty.path "alloc::vec::Vec")
                                                      [
                                                        Ty.path "move_core_types::value::MoveValue";
                                                        Ty.path "alloc::alloc::Global"
                                                      ],
                                                    "push",
                                                    []
                                                  |),
                                                  [ val; M.read (| elem |) ]
                                                |)
                                              |)));
                                          fun γ =>
                                            ltac:(M.monadic
                                              (M.alloc (|
                                                M.never_to_any (|
                                                  M.read (|
                                                    M.return_ (|
                                                      Value.StructTuple
                                                        "core::result::Result::Err"
                                                        [
                                                          M.call_closure (|
                                                            M.get_trait_method (|
                                                              "serde::de::Error",
                                                              Ty.associated,
                                                              [],
                                                              "invalid_length",
                                                              []
                                                            |),
                                                            [
                                                              M.read (| i |);
                                                              (* Unsize *) M.pointer_coercion self
                                                            ]
                                                          |)
                                                        ]
                                                    |)
                                                  |)
                                                |)
                                              |)))
                                        ]
                                      |)))
                                ]
                              |) in
                            M.alloc (| Value.Tuple [] |)))
                        |)))
                  ]
                |)) in
            M.alloc (| Value.StructTuple "core::result::Result::Ok" [ M.read (| val |) ] |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "serde::de::Visitor"
        Self
        (* Trait polymorphic types *) []
        (* Instance *)
        [
          ("Value", InstanceField.Ty _Value);
          ("expecting", InstanceField.Method expecting);
          ("visit_seq", InstanceField.Method visit_seq)
        ].
  End Impl_serde_de_Visitor_for_move_core_types_value_StructFieldVisitor.
  
  Module Impl_serde_de_DeserializeSeed_for_ref__move_core_types_value_MoveFieldLayout.
    Definition Self : Ty.t :=
      Ty.apply (Ty.path "&") [ Ty.path "move_core_types::value::MoveFieldLayout" ].
    
    (*     type Value = (Identifier, MoveValue); *)
    Definition _Value : Ty.t :=
      Ty.tuple
        [
          Ty.path "move_core_types::identifier::Identifier";
          Ty.path "move_core_types::value::MoveValue"
        ].
    
    (*
        fn deserialize<D: serde::de::Deserializer<'d>>(
            self,
            deserializer: D,
        ) -> Result<Self::Value, D::Error> {
            Ok((self.name.clone(), self.layout.deserialize(deserializer)?))
        }
    *)
    Definition deserialize (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ D ], [ self; deserializer ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let deserializer := M.alloc (| deserializer |) in
          Value.StructTuple
            "core::result::Result::Ok"
            [
              Value.Tuple
                [
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::clone::Clone",
                      Ty.path "move_core_types::identifier::Identifier",
                      [],
                      "clone",
                      []
                    |),
                    [
                      M.get_struct_record_field
                        (M.read (| self |))
                        "move_core_types::value::MoveFieldLayout"
                        "name"
                    ]
                  |);
                  M.read (|
                    M.match_operator (|
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::ops::try_trait::Try",
                            Ty.apply
                              (Ty.path "core::result::Result")
                              [ Ty.path "move_core_types::value::MoveValue"; Ty.associated ],
                            [],
                            "branch",
                            []
                          |),
                          [
                            M.call_closure (|
                              M.get_trait_method (|
                                "serde::de::DeserializeSeed",
                                Ty.apply
                                  (Ty.path "&")
                                  [ Ty.path "move_core_types::value::MoveTypeLayout" ],
                                [],
                                "deserialize",
                                [ D ]
                              |),
                              [
                                M.get_struct_record_field
                                  (M.read (| self |))
                                  "move_core_types::value::MoveFieldLayout"
                                  "layout";
                                M.read (| deserializer |)
                              ]
                            |)
                          ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Break",
                                0
                              |) in
                            let residual := M.copy (| γ0_0 |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::ops::try_trait::FromResidual",
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          [
                                            Ty.tuple
                                              [
                                                Ty.path "move_core_types::identifier::Identifier";
                                                Ty.path "move_core_types::value::MoveValue"
                                              ];
                                            Ty.associated
                                          ],
                                        [
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            [ Ty.path "core::convert::Infallible"; Ty.associated ]
                                        ],
                                        "from_residual",
                                        []
                                      |),
                                      [ M.read (| residual |) ]
                                    |)
                                  |)
                                |)
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Continue",
                                0
                              |) in
                            let val := M.copy (| γ0_0 |) in
                            val))
                      ]
                    |)
                  |)
                ]
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "serde::de::DeserializeSeed"
        Self
        (* Trait polymorphic types *) []
        (* Instance *)
        [ ("Value", InstanceField.Ty _Value); ("deserialize", InstanceField.Method deserialize) ].
  End Impl_serde_de_DeserializeSeed_for_ref__move_core_types_value_MoveFieldLayout.
  
  Module Impl_serde_de_DeserializeSeed_for_ref__move_core_types_value_MoveStructLayout.
    Definition Self : Ty.t :=
      Ty.apply (Ty.path "&") [ Ty.path "move_core_types::value::MoveStructLayout" ].
    
    (*     type Value = MoveStruct; *)
    Definition _Value : Ty.t := Ty.path "move_core_types::value::MoveStruct".
    
    (*
        fn deserialize<D: serde::de::Deserializer<'d>>(
            self,
            deserializer: D,
        ) -> Result<Self::Value, D::Error> {
            match self {
                MoveStructLayout::Runtime(layout) => {
                    let fields =
                        deserializer.deserialize_tuple(layout.len(), StructFieldVisitor(layout))?;
                    Ok(MoveStruct::Runtime(fields))
                }
                MoveStructLayout::WithFields(layout) => {
                    let fields = deserializer
                        .deserialize_tuple(layout.len(), DecoratedStructFieldVisitor(layout))?;
                    Ok(MoveStruct::WithFields(fields))
                }
                MoveStructLayout::WithTypes {
                    type_,
                    fields: layout,
                } => {
                    let fields = deserializer
                        .deserialize_tuple(layout.len(), DecoratedStructFieldVisitor(layout))?;
                    Ok(MoveStruct::WithTypes {
                        type_: type_.clone(),
                        fields,
                    })
                }
            }
        }
    *)
    Definition deserialize (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ D ], [ self; deserializer ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let deserializer := M.alloc (| deserializer |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::value::MoveStructLayout::Runtime",
                        0
                      |) in
                    let layout := M.alloc (| γ1_0 |) in
                    let fields :=
                      M.copy (|
                        M.match_operator (|
                          M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::ops::try_trait::Try",
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  [
                                    Ty.apply
                                      (Ty.path "alloc::vec::Vec")
                                      [
                                        Ty.path "move_core_types::value::MoveValue";
                                        Ty.path "alloc::alloc::Global"
                                      ];
                                    Ty.associated
                                  ],
                                [],
                                "branch",
                                []
                              |),
                              [
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "serde::de::Deserializer",
                                    D,
                                    [],
                                    "deserialize_tuple",
                                    [ Ty.path "move_core_types::value::StructFieldVisitor" ]
                                  |),
                                  [
                                    M.read (| deserializer |);
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.apply
                                          (Ty.path "alloc::vec::Vec")
                                          [
                                            Ty.path "move_core_types::value::MoveTypeLayout";
                                            Ty.path "alloc::alloc::Global"
                                          ],
                                        "len",
                                        []
                                      |),
                                      [ M.read (| layout |) ]
                                    |);
                                    Value.StructTuple
                                      "move_core_types::value::StructFieldVisitor"
                                      [
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::ops::deref::Deref",
                                            Ty.apply
                                              (Ty.path "alloc::vec::Vec")
                                              [
                                                Ty.path "move_core_types::value::MoveTypeLayout";
                                                Ty.path "alloc::alloc::Global"
                                              ],
                                            [],
                                            "deref",
                                            []
                                          |),
                                          [ M.read (| layout |) ]
                                        |)
                                      ]
                                  ]
                                |)
                              ]
                            |)
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.get_struct_tuple_field_or_break_match (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Break",
                                    0
                                  |) in
                                let residual := M.copy (| γ0_0 |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      M.return_ (|
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::ops::try_trait::FromResidual",
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              [
                                                Ty.path "move_core_types::value::MoveStruct";
                                                Ty.associated
                                              ],
                                            [
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                [ Ty.path "core::convert::Infallible"; Ty.associated
                                                ]
                                            ],
                                            "from_residual",
                                            []
                                          |),
                                          [ M.read (| residual |) ]
                                        |)
                                      |)
                                    |)
                                  |)
                                |)));
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.get_struct_tuple_field_or_break_match (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Continue",
                                    0
                                  |) in
                                let val := M.copy (| γ0_0 |) in
                                val))
                          ]
                        |)
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::value::MoveStruct::Runtime"
                            [ M.read (| fields |) ]
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::value::MoveStructLayout::WithFields",
                        0
                      |) in
                    let layout := M.alloc (| γ1_0 |) in
                    let fields :=
                      M.copy (|
                        M.match_operator (|
                          M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::ops::try_trait::Try",
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  [
                                    Ty.apply
                                      (Ty.path "alloc::vec::Vec")
                                      [
                                        Ty.tuple
                                          [
                                            Ty.path "move_core_types::identifier::Identifier";
                                            Ty.path "move_core_types::value::MoveValue"
                                          ];
                                        Ty.path "alloc::alloc::Global"
                                      ];
                                    Ty.associated
                                  ],
                                [],
                                "branch",
                                []
                              |),
                              [
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "serde::de::Deserializer",
                                    D,
                                    [],
                                    "deserialize_tuple",
                                    [ Ty.path "move_core_types::value::DecoratedStructFieldVisitor"
                                    ]
                                  |),
                                  [
                                    M.read (| deserializer |);
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.apply
                                          (Ty.path "alloc::vec::Vec")
                                          [
                                            Ty.path "move_core_types::value::MoveFieldLayout";
                                            Ty.path "alloc::alloc::Global"
                                          ],
                                        "len",
                                        []
                                      |),
                                      [ M.read (| layout |) ]
                                    |);
                                    Value.StructTuple
                                      "move_core_types::value::DecoratedStructFieldVisitor"
                                      [
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::ops::deref::Deref",
                                            Ty.apply
                                              (Ty.path "alloc::vec::Vec")
                                              [
                                                Ty.path "move_core_types::value::MoveFieldLayout";
                                                Ty.path "alloc::alloc::Global"
                                              ],
                                            [],
                                            "deref",
                                            []
                                          |),
                                          [ M.read (| layout |) ]
                                        |)
                                      ]
                                  ]
                                |)
                              ]
                            |)
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.get_struct_tuple_field_or_break_match (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Break",
                                    0
                                  |) in
                                let residual := M.copy (| γ0_0 |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      M.return_ (|
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::ops::try_trait::FromResidual",
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              [
                                                Ty.path "move_core_types::value::MoveStruct";
                                                Ty.associated
                                              ],
                                            [
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                [ Ty.path "core::convert::Infallible"; Ty.associated
                                                ]
                                            ],
                                            "from_residual",
                                            []
                                          |),
                                          [ M.read (| residual |) ]
                                        |)
                                      |)
                                    |)
                                  |)
                                |)));
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.get_struct_tuple_field_or_break_match (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Continue",
                                    0
                                  |) in
                                let val := M.copy (| γ0_0 |) in
                                val))
                          ]
                        |)
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::value::MoveStruct::WithFields"
                            [ M.read (| fields |) ]
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_record_field_or_break_match (|
                        γ,
                        "move_core_types::value::MoveStructLayout::WithTypes",
                        "type_"
                      |) in
                    let γ1_1 :=
                      M.get_struct_record_field_or_break_match (|
                        γ,
                        "move_core_types::value::MoveStructLayout::WithTypes",
                        "fields"
                      |) in
                    let type_ := M.alloc (| γ1_0 |) in
                    let layout := M.alloc (| γ1_1 |) in
                    let fields :=
                      M.copy (|
                        M.match_operator (|
                          M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::ops::try_trait::Try",
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  [
                                    Ty.apply
                                      (Ty.path "alloc::vec::Vec")
                                      [
                                        Ty.tuple
                                          [
                                            Ty.path "move_core_types::identifier::Identifier";
                                            Ty.path "move_core_types::value::MoveValue"
                                          ];
                                        Ty.path "alloc::alloc::Global"
                                      ];
                                    Ty.associated
                                  ],
                                [],
                                "branch",
                                []
                              |),
                              [
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "serde::de::Deserializer",
                                    D,
                                    [],
                                    "deserialize_tuple",
                                    [ Ty.path "move_core_types::value::DecoratedStructFieldVisitor"
                                    ]
                                  |),
                                  [
                                    M.read (| deserializer |);
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.apply
                                          (Ty.path "alloc::vec::Vec")
                                          [
                                            Ty.path "move_core_types::value::MoveFieldLayout";
                                            Ty.path "alloc::alloc::Global"
                                          ],
                                        "len",
                                        []
                                      |),
                                      [ M.read (| layout |) ]
                                    |);
                                    Value.StructTuple
                                      "move_core_types::value::DecoratedStructFieldVisitor"
                                      [
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::ops::deref::Deref",
                                            Ty.apply
                                              (Ty.path "alloc::vec::Vec")
                                              [
                                                Ty.path "move_core_types::value::MoveFieldLayout";
                                                Ty.path "alloc::alloc::Global"
                                              ],
                                            [],
                                            "deref",
                                            []
                                          |),
                                          [ M.read (| layout |) ]
                                        |)
                                      ]
                                  ]
                                |)
                              ]
                            |)
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.get_struct_tuple_field_or_break_match (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Break",
                                    0
                                  |) in
                                let residual := M.copy (| γ0_0 |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      M.return_ (|
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::ops::try_trait::FromResidual",
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              [
                                                Ty.path "move_core_types::value::MoveStruct";
                                                Ty.associated
                                              ],
                                            [
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                [ Ty.path "core::convert::Infallible"; Ty.associated
                                                ]
                                            ],
                                            "from_residual",
                                            []
                                          |),
                                          [ M.read (| residual |) ]
                                        |)
                                      |)
                                    |)
                                  |)
                                |)));
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.get_struct_tuple_field_or_break_match (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Continue",
                                    0
                                  |) in
                                let val := M.copy (| γ0_0 |) in
                                val))
                          ]
                        |)
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructRecord
                            "move_core_types::value::MoveStruct::WithTypes"
                            [
                              ("type_",
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::clone::Clone",
                                    Ty.path "move_core_types::language_storage::StructTag",
                                    [],
                                    "clone",
                                    []
                                  |),
                                  [ M.read (| type_ |) ]
                                |));
                              ("fields", M.read (| fields |))
                            ]
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "serde::de::DeserializeSeed"
        Self
        (* Trait polymorphic types *) []
        (* Instance *)
        [ ("Value", InstanceField.Ty _Value); ("deserialize", InstanceField.Method deserialize) ].
  End Impl_serde_de_DeserializeSeed_for_ref__move_core_types_value_MoveStructLayout.
  
  Module Impl_serde_ser_Serialize_for_move_core_types_value_MoveValue.
    Definition Self : Ty.t := Ty.path "move_core_types::value::MoveValue".
    
    (*
        fn serialize<S: serde::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
            match self {
                MoveValue::Struct(s) => s.serialize(serializer),
                MoveValue::Bool(b) => serializer.serialize_bool( *b),
                MoveValue::U8(i) => serializer.serialize_u8( *i),
                MoveValue::U16(i) => serializer.serialize_u16( *i),
                MoveValue::U32(i) => serializer.serialize_u32( *i),
                MoveValue::U64(i) => serializer.serialize_u64( *i),
                MoveValue::U128(i) => serializer.serialize_u128( *i),
                MoveValue::U256(i) => i.serialize(serializer),
                MoveValue::Address(a) => a.serialize(serializer),
                MoveValue::Signer(a) => a.serialize(serializer),
                MoveValue::Vector(v) => {
                    let mut t = serializer.serialize_seq(Some(v.len()))?;
                    for val in v {
                        t.serialize_element(val)?;
                    }
                    t.end()
                }
            }
        }
    *)
    Definition serialize (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ _ as S ], [ self; serializer ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let serializer := M.alloc (| serializer |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::value::MoveValue::Struct",
                        0
                      |) in
                    let s := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "serde::ser::Serialize",
                          Ty.path "move_core_types::value::MoveStruct",
                          [],
                          "serialize",
                          [ S ]
                        |),
                        [ M.read (| s |); M.read (| serializer |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::value::MoveValue::Bool",
                        0
                      |) in
                    let b := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "serde::ser::Serializer",
                          S,
                          [],
                          "serialize_bool",
                          []
                        |),
                        [ M.read (| serializer |); M.read (| M.read (| b |) |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::value::MoveValue::U8",
                        0
                      |) in
                    let i := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "serde::ser::Serializer",
                          S,
                          [],
                          "serialize_u8",
                          []
                        |),
                        [ M.read (| serializer |); M.read (| M.read (| i |) |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::value::MoveValue::U16",
                        0
                      |) in
                    let i := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "serde::ser::Serializer",
                          S,
                          [],
                          "serialize_u16",
                          []
                        |),
                        [ M.read (| serializer |); M.read (| M.read (| i |) |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::value::MoveValue::U32",
                        0
                      |) in
                    let i := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "serde::ser::Serializer",
                          S,
                          [],
                          "serialize_u32",
                          []
                        |),
                        [ M.read (| serializer |); M.read (| M.read (| i |) |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::value::MoveValue::U64",
                        0
                      |) in
                    let i := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "serde::ser::Serializer",
                          S,
                          [],
                          "serialize_u64",
                          []
                        |),
                        [ M.read (| serializer |); M.read (| M.read (| i |) |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::value::MoveValue::U128",
                        0
                      |) in
                    let i := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "serde::ser::Serializer",
                          S,
                          [],
                          "serialize_u128",
                          []
                        |),
                        [ M.read (| serializer |); M.read (| M.read (| i |) |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::value::MoveValue::U256",
                        0
                      |) in
                    let i := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "serde::ser::Serialize",
                          Ty.path "move_core_types::u256::U256",
                          [],
                          "serialize",
                          [ S ]
                        |),
                        [ M.read (| i |); M.read (| serializer |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::value::MoveValue::Address",
                        0
                      |) in
                    let a := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "serde::ser::Serialize",
                          Ty.path "move_core_types::account_address::AccountAddress",
                          [],
                          "serialize",
                          [ S ]
                        |),
                        [ M.read (| a |); M.read (| serializer |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::value::MoveValue::Signer",
                        0
                      |) in
                    let a := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "serde::ser::Serialize",
                          Ty.path "move_core_types::account_address::AccountAddress",
                          [],
                          "serialize",
                          [ S ]
                        |),
                        [ M.read (| a |); M.read (| serializer |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::value::MoveValue::Vector",
                        0
                      |) in
                    let v := M.alloc (| γ1_0 |) in
                    let t :=
                      M.copy (|
                        M.match_operator (|
                          M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::ops::try_trait::Try",
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  [ Ty.associated; Ty.associated ],
                                [],
                                "branch",
                                []
                              |),
                              [
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "serde::ser::Serializer",
                                    S,
                                    [],
                                    "serialize_seq",
                                    []
                                  |),
                                  [
                                    M.read (| serializer |);
                                    Value.StructTuple
                                      "core::option::Option::Some"
                                      [
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.apply
                                              (Ty.path "alloc::vec::Vec")
                                              [
                                                Ty.path "move_core_types::value::MoveValue";
                                                Ty.path "alloc::alloc::Global"
                                              ],
                                            "len",
                                            []
                                          |),
                                          [ M.read (| v |) ]
                                        |)
                                      ]
                                  ]
                                |)
                              ]
                            |)
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.get_struct_tuple_field_or_break_match (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Break",
                                    0
                                  |) in
                                let residual := M.copy (| γ0_0 |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      M.return_ (|
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::ops::try_trait::FromResidual",
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              [ Ty.associated; Ty.associated ],
                                            [
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                [ Ty.path "core::convert::Infallible"; Ty.associated
                                                ]
                                            ],
                                            "from_residual",
                                            []
                                          |),
                                          [ M.read (| residual |) ]
                                        |)
                                      |)
                                    |)
                                  |)
                                |)));
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.get_struct_tuple_field_or_break_match (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Continue",
                                    0
                                  |) in
                                let val := M.copy (| γ0_0 |) in
                                val))
                          ]
                        |)
                      |) in
                    let _ :=
                      M.use
                        (M.match_operator (|
                          M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::iter::traits::collect::IntoIterator",
                                Ty.apply
                                  (Ty.path "&")
                                  [
                                    Ty.apply
                                      (Ty.path "alloc::vec::Vec")
                                      [
                                        Ty.path "move_core_types::value::MoveValue";
                                        Ty.path "alloc::alloc::Global"
                                      ]
                                  ],
                                [],
                                "into_iter",
                                []
                              |),
                              [ M.read (| v |) ]
                            |)
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let iter := M.copy (| γ |) in
                                M.loop (|
                                  ltac:(M.monadic
                                    (let _ :=
                                      M.match_operator (|
                                        M.alloc (|
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::iter::traits::iterator::Iterator",
                                              Ty.apply
                                                (Ty.path "core::slice::iter::Iter")
                                                [ Ty.path "move_core_types::value::MoveValue" ],
                                              [],
                                              "next",
                                              []
                                            |),
                                            [ iter ]
                                          |)
                                        |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (M.alloc (|
                                                M.never_to_any (| M.read (| M.break (||) |) |)
                                              |)));
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let γ0_0 :=
                                                M.get_struct_tuple_field_or_break_match (|
                                                  γ,
                                                  "core::option::Option::Some",
                                                  0
                                                |) in
                                              let val := M.copy (| γ0_0 |) in
                                              let _ :=
                                                M.match_operator (|
                                                  M.alloc (|
                                                    M.call_closure (|
                                                      M.get_trait_method (|
                                                        "core::ops::try_trait::Try",
                                                        Ty.apply
                                                          (Ty.path "core::result::Result")
                                                          [ Ty.tuple []; Ty.associated ],
                                                        [],
                                                        "branch",
                                                        []
                                                      |),
                                                      [
                                                        M.call_closure (|
                                                          M.get_trait_method (|
                                                            "serde::ser::SerializeSeq",
                                                            Ty.associated,
                                                            [],
                                                            "serialize_element",
                                                            [
                                                              Ty.path
                                                                "move_core_types::value::MoveValue"
                                                            ]
                                                          |),
                                                          [ t; M.read (| val |) ]
                                                        |)
                                                      ]
                                                    |)
                                                  |),
                                                  [
                                                    fun γ =>
                                                      ltac:(M.monadic
                                                        (let γ0_0 :=
                                                          M.get_struct_tuple_field_or_break_match (|
                                                            γ,
                                                            "core::ops::control_flow::ControlFlow::Break",
                                                            0
                                                          |) in
                                                        let residual := M.copy (| γ0_0 |) in
                                                        M.alloc (|
                                                          M.never_to_any (|
                                                            M.read (|
                                                              M.return_ (|
                                                                M.call_closure (|
                                                                  M.get_trait_method (|
                                                                    "core::ops::try_trait::FromResidual",
                                                                    Ty.apply
                                                                      (Ty.path
                                                                        "core::result::Result")
                                                                      [ Ty.associated; Ty.associated
                                                                      ],
                                                                    [
                                                                      Ty.apply
                                                                        (Ty.path
                                                                          "core::result::Result")
                                                                        [
                                                                          Ty.path
                                                                            "core::convert::Infallible";
                                                                          Ty.associated
                                                                        ]
                                                                    ],
                                                                    "from_residual",
                                                                    []
                                                                  |),
                                                                  [ M.read (| residual |) ]
                                                                |)
                                                              |)
                                                            |)
                                                          |)
                                                        |)));
                                                    fun γ =>
                                                      ltac:(M.monadic
                                                        (let γ0_0 :=
                                                          M.get_struct_tuple_field_or_break_match (|
                                                            γ,
                                                            "core::ops::control_flow::ControlFlow::Continue",
                                                            0
                                                          |) in
                                                        let val := M.copy (| γ0_0 |) in
                                                        val))
                                                  ]
                                                |) in
                                              M.alloc (| Value.Tuple [] |)))
                                        ]
                                      |) in
                                    M.alloc (| Value.Tuple [] |)))
                                |)))
                          ]
                        |)) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "serde::ser::SerializeSeq",
                          Ty.associated,
                          [],
                          "end",
                          []
                        |),
                        [ M.read (| t |) ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "serde::ser::Serialize"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("serialize", InstanceField.Method serialize) ].
  End Impl_serde_ser_Serialize_for_move_core_types_value_MoveValue.
  
  (* StructTuple
    {
      name := "MoveFields";
      ty_params := [];
      fields :=
        [
          Ty.apply
            (Ty.path "&")
            [
              Ty.apply
                (Ty.path "slice")
                [
                  Ty.tuple
                    [
                      Ty.path "move_core_types::identifier::Identifier";
                      Ty.path "move_core_types::value::MoveValue"
                    ]
                ]
            ]
        ];
    } *)
  
  Module Impl_serde_ser_Serialize_for_move_core_types_value_MoveFields.
    Definition Self : Ty.t := Ty.path "move_core_types::value::MoveFields".
    
    (*
        fn serialize<S: serde::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
            let mut t = serializer.serialize_map(Some(self.0.len()))?;
            for (f, v) in self.0.iter() {
                t.serialize_entry(f, v)?;
            }
            t.end()
        }
    *)
    Definition serialize (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ _ as S ], [ self; serializer ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let serializer := M.alloc (| serializer |) in
          M.read (|
            let t :=
              M.copy (|
                M.match_operator (|
                  M.alloc (|
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::ops::try_trait::Try",
                        Ty.apply (Ty.path "core::result::Result") [ Ty.associated; Ty.associated ],
                        [],
                        "branch",
                        []
                      |),
                      [
                        M.call_closure (|
                          M.get_trait_method (|
                            "serde::ser::Serializer",
                            S,
                            [],
                            "serialize_map",
                            []
                          |),
                          [
                            M.read (| serializer |);
                            Value.StructTuple
                              "core::option::Option::Some"
                              [
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "slice")
                                      [
                                        Ty.tuple
                                          [
                                            Ty.path "move_core_types::identifier::Identifier";
                                            Ty.path "move_core_types::value::MoveValue"
                                          ]
                                      ],
                                    "len",
                                    []
                                  |),
                                  [
                                    M.read (|
                                      M.get_struct_tuple_field
                                        (M.read (| self |))
                                        "move_core_types::value::MoveFields"
                                        0
                                    |)
                                  ]
                                |)
                              ]
                          ]
                        |)
                      ]
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.get_struct_tuple_field_or_break_match (|
                            γ,
                            "core::ops::control_flow::ControlFlow::Break",
                            0
                          |) in
                        let residual := M.copy (| γ0_0 |) in
                        M.alloc (|
                          M.never_to_any (|
                            M.read (|
                              M.return_ (|
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::ops::try_trait::FromResidual",
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      [ Ty.associated; Ty.associated ],
                                    [
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        [ Ty.path "core::convert::Infallible"; Ty.associated ]
                                    ],
                                    "from_residual",
                                    []
                                  |),
                                  [ M.read (| residual |) ]
                                |)
                              |)
                            |)
                          |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.get_struct_tuple_field_or_break_match (|
                            γ,
                            "core::ops::control_flow::ControlFlow::Continue",
                            0
                          |) in
                        let val := M.copy (| γ0_0 |) in
                        val))
                  ]
                |)
              |) in
            let _ :=
              M.use
                (M.match_operator (|
                  M.alloc (|
                    M.call_closure (|
                      M.get_trait_method (|
                        "core::iter::traits::collect::IntoIterator",
                        Ty.apply
                          (Ty.path "core::slice::iter::Iter")
                          [
                            Ty.tuple
                              [
                                Ty.path "move_core_types::identifier::Identifier";
                                Ty.path "move_core_types::value::MoveValue"
                              ]
                          ],
                        [],
                        "into_iter",
                        []
                      |),
                      [
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "slice")
                              [
                                Ty.tuple
                                  [
                                    Ty.path "move_core_types::identifier::Identifier";
                                    Ty.path "move_core_types::value::MoveValue"
                                  ]
                              ],
                            "iter",
                            []
                          |),
                          [
                            M.read (|
                              M.get_struct_tuple_field
                                (M.read (| self |))
                                "move_core_types::value::MoveFields"
                                0
                            |)
                          ]
                        |)
                      ]
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let iter := M.copy (| γ |) in
                        M.loop (|
                          ltac:(M.monadic
                            (let _ :=
                              M.match_operator (|
                                M.alloc (|
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::iter::traits::iterator::Iterator",
                                      Ty.apply
                                        (Ty.path "core::slice::iter::Iter")
                                        [
                                          Ty.tuple
                                            [
                                              Ty.path "move_core_types::identifier::Identifier";
                                              Ty.path "move_core_types::value::MoveValue"
                                            ]
                                        ],
                                      [],
                                      "next",
                                      []
                                    |),
                                    [ iter ]
                                  |)
                                |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (M.alloc (|
                                        M.never_to_any (| M.read (| M.break (||) |) |)
                                      |)));
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ0_0 :=
                                        M.get_struct_tuple_field_or_break_match (|
                                          γ,
                                          "core::option::Option::Some",
                                          0
                                        |) in
                                      let γ0_0 := M.read (| γ0_0 |) in
                                      let γ2_0 := M.get_tuple_field γ0_0 0 in
                                      let γ2_1 := M.get_tuple_field γ0_0 1 in
                                      let f := M.alloc (| γ2_0 |) in
                                      let v := M.alloc (| γ2_1 |) in
                                      let _ :=
                                        M.match_operator (|
                                          M.alloc (|
                                            M.call_closure (|
                                              M.get_trait_method (|
                                                "core::ops::try_trait::Try",
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  [ Ty.tuple []; Ty.associated ],
                                                [],
                                                "branch",
                                                []
                                              |),
                                              [
                                                M.call_closure (|
                                                  M.get_trait_method (|
                                                    "serde::ser::SerializeMap",
                                                    Ty.associated,
                                                    [],
                                                    "serialize_entry",
                                                    [
                                                      Ty.path
                                                        "move_core_types::identifier::Identifier";
                                                      Ty.path "move_core_types::value::MoveValue"
                                                    ]
                                                  |),
                                                  [ t; M.read (| f |); M.read (| v |) ]
                                                |)
                                              ]
                                            |)
                                          |),
                                          [
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let γ0_0 :=
                                                  M.get_struct_tuple_field_or_break_match (|
                                                    γ,
                                                    "core::ops::control_flow::ControlFlow::Break",
                                                    0
                                                  |) in
                                                let residual := M.copy (| γ0_0 |) in
                                                M.alloc (|
                                                  M.never_to_any (|
                                                    M.read (|
                                                      M.return_ (|
                                                        M.call_closure (|
                                                          M.get_trait_method (|
                                                            "core::ops::try_trait::FromResidual",
                                                            Ty.apply
                                                              (Ty.path "core::result::Result")
                                                              [ Ty.associated; Ty.associated ],
                                                            [
                                                              Ty.apply
                                                                (Ty.path "core::result::Result")
                                                                [
                                                                  Ty.path
                                                                    "core::convert::Infallible";
                                                                  Ty.associated
                                                                ]
                                                            ],
                                                            "from_residual",
                                                            []
                                                          |),
                                                          [ M.read (| residual |) ]
                                                        |)
                                                      |)
                                                    |)
                                                  |)
                                                |)));
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let γ0_0 :=
                                                  M.get_struct_tuple_field_or_break_match (|
                                                    γ,
                                                    "core::ops::control_flow::ControlFlow::Continue",
                                                    0
                                                  |) in
                                                let val := M.copy (| γ0_0 |) in
                                                val))
                                          ]
                                        |) in
                                      M.alloc (| Value.Tuple [] |)))
                                ]
                              |) in
                            M.alloc (| Value.Tuple [] |)))
                        |)))
                  ]
                |)) in
            M.alloc (|
              M.call_closure (|
                M.get_trait_method (| "serde::ser::SerializeMap", Ty.associated, [], "end", [] |),
                [ M.read (| t |) ]
              |)
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "serde::ser::Serialize"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("serialize", InstanceField.Method serialize) ].
  End Impl_serde_ser_Serialize_for_move_core_types_value_MoveFields.
  
  Module Impl_serde_ser_Serialize_for_move_core_types_value_MoveStruct.
    Definition Self : Ty.t := Ty.path "move_core_types::value::MoveStruct".
    
    (*
        fn serialize<S: serde::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
            match self {
                Self::Runtime(s) => {
                    let mut t = serializer.serialize_tuple(s.len())?;
                    for v in s.iter() {
                        t.serialize_element(v)?;
                    }
                    t.end()
                }
                Self::WithFields(fields) => MoveFields(fields).serialize(serializer),
                Self::WithTypes { type_, fields } => {
                    // Serialize a Move struct as Serde struct type named `struct `with two fields named `type` and `fields`.
                    // `fields` will get serialized as a Serde map.
                    // Unfortunately, we can't serialize this in the logical way: as a Serde struct named `type` with a field for
                    // each of `fields` because serde insists that struct and field names be `'static &str`'s
                    let mut t = serializer.serialize_struct(MOVE_STRUCT_NAME, 2)?;
                    // serialize type as string (e.g., 0x0::ModuleName::StructName<TypeArg1,TypeArg2>) instead of (e.g.
                    // { address: 0x0...0, module: ModuleName, name: StructName, type_args: [TypeArg1, TypeArg2]})
                    t.serialize_field(MOVE_STRUCT_TYPE, &type_.to_string())?;
                    t.serialize_field(MOVE_STRUCT_FIELDS, &MoveFields(fields))?;
                    t.end()
                }
            }
        }
    *)
    Definition serialize (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ _ as S ], [ self; serializer ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let serializer := M.alloc (| serializer |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::value::MoveStruct::Runtime",
                        0
                      |) in
                    let s := M.alloc (| γ1_0 |) in
                    let t :=
                      M.copy (|
                        M.match_operator (|
                          M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::ops::try_trait::Try",
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  [ Ty.associated; Ty.associated ],
                                [],
                                "branch",
                                []
                              |),
                              [
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "serde::ser::Serializer",
                                    S,
                                    [],
                                    "serialize_tuple",
                                    []
                                  |),
                                  [
                                    M.read (| serializer |);
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.apply
                                          (Ty.path "alloc::vec::Vec")
                                          [
                                            Ty.path "move_core_types::value::MoveValue";
                                            Ty.path "alloc::alloc::Global"
                                          ],
                                        "len",
                                        []
                                      |),
                                      [ M.read (| s |) ]
                                    |)
                                  ]
                                |)
                              ]
                            |)
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.get_struct_tuple_field_or_break_match (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Break",
                                    0
                                  |) in
                                let residual := M.copy (| γ0_0 |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      M.return_ (|
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::ops::try_trait::FromResidual",
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              [ Ty.associated; Ty.associated ],
                                            [
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                [ Ty.path "core::convert::Infallible"; Ty.associated
                                                ]
                                            ],
                                            "from_residual",
                                            []
                                          |),
                                          [ M.read (| residual |) ]
                                        |)
                                      |)
                                    |)
                                  |)
                                |)));
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.get_struct_tuple_field_or_break_match (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Continue",
                                    0
                                  |) in
                                let val := M.copy (| γ0_0 |) in
                                val))
                          ]
                        |)
                      |) in
                    let _ :=
                      M.use
                        (M.match_operator (|
                          M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::iter::traits::collect::IntoIterator",
                                Ty.apply
                                  (Ty.path "core::slice::iter::Iter")
                                  [ Ty.path "move_core_types::value::MoveValue" ],
                                [],
                                "into_iter",
                                []
                              |),
                              [
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "slice")
                                      [ Ty.path "move_core_types::value::MoveValue" ],
                                    "iter",
                                    []
                                  |),
                                  [
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::ops::deref::Deref",
                                        Ty.apply
                                          (Ty.path "alloc::vec::Vec")
                                          [
                                            Ty.path "move_core_types::value::MoveValue";
                                            Ty.path "alloc::alloc::Global"
                                          ],
                                        [],
                                        "deref",
                                        []
                                      |),
                                      [ M.read (| s |) ]
                                    |)
                                  ]
                                |)
                              ]
                            |)
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let iter := M.copy (| γ |) in
                                M.loop (|
                                  ltac:(M.monadic
                                    (let _ :=
                                      M.match_operator (|
                                        M.alloc (|
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::iter::traits::iterator::Iterator",
                                              Ty.apply
                                                (Ty.path "core::slice::iter::Iter")
                                                [ Ty.path "move_core_types::value::MoveValue" ],
                                              [],
                                              "next",
                                              []
                                            |),
                                            [ iter ]
                                          |)
                                        |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (M.alloc (|
                                                M.never_to_any (| M.read (| M.break (||) |) |)
                                              |)));
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let γ0_0 :=
                                                M.get_struct_tuple_field_or_break_match (|
                                                  γ,
                                                  "core::option::Option::Some",
                                                  0
                                                |) in
                                              let v := M.copy (| γ0_0 |) in
                                              let _ :=
                                                M.match_operator (|
                                                  M.alloc (|
                                                    M.call_closure (|
                                                      M.get_trait_method (|
                                                        "core::ops::try_trait::Try",
                                                        Ty.apply
                                                          (Ty.path "core::result::Result")
                                                          [ Ty.tuple []; Ty.associated ],
                                                        [],
                                                        "branch",
                                                        []
                                                      |),
                                                      [
                                                        M.call_closure (|
                                                          M.get_trait_method (|
                                                            "serde::ser::SerializeTuple",
                                                            Ty.associated,
                                                            [],
                                                            "serialize_element",
                                                            [
                                                              Ty.path
                                                                "move_core_types::value::MoveValue"
                                                            ]
                                                          |),
                                                          [ t; M.read (| v |) ]
                                                        |)
                                                      ]
                                                    |)
                                                  |),
                                                  [
                                                    fun γ =>
                                                      ltac:(M.monadic
                                                        (let γ0_0 :=
                                                          M.get_struct_tuple_field_or_break_match (|
                                                            γ,
                                                            "core::ops::control_flow::ControlFlow::Break",
                                                            0
                                                          |) in
                                                        let residual := M.copy (| γ0_0 |) in
                                                        M.alloc (|
                                                          M.never_to_any (|
                                                            M.read (|
                                                              M.return_ (|
                                                                M.call_closure (|
                                                                  M.get_trait_method (|
                                                                    "core::ops::try_trait::FromResidual",
                                                                    Ty.apply
                                                                      (Ty.path
                                                                        "core::result::Result")
                                                                      [ Ty.associated; Ty.associated
                                                                      ],
                                                                    [
                                                                      Ty.apply
                                                                        (Ty.path
                                                                          "core::result::Result")
                                                                        [
                                                                          Ty.path
                                                                            "core::convert::Infallible";
                                                                          Ty.associated
                                                                        ]
                                                                    ],
                                                                    "from_residual",
                                                                    []
                                                                  |),
                                                                  [ M.read (| residual |) ]
                                                                |)
                                                              |)
                                                            |)
                                                          |)
                                                        |)));
                                                    fun γ =>
                                                      ltac:(M.monadic
                                                        (let γ0_0 :=
                                                          M.get_struct_tuple_field_or_break_match (|
                                                            γ,
                                                            "core::ops::control_flow::ControlFlow::Continue",
                                                            0
                                                          |) in
                                                        let val := M.copy (| γ0_0 |) in
                                                        val))
                                                  ]
                                                |) in
                                              M.alloc (| Value.Tuple [] |)))
                                        ]
                                      |) in
                                    M.alloc (| Value.Tuple [] |)))
                                |)))
                          ]
                        |)) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "serde::ser::SerializeTuple",
                          Ty.associated,
                          [],
                          "end",
                          []
                        |),
                        [ M.read (| t |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::value::MoveStruct::WithFields",
                        0
                      |) in
                    let fields := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "serde::ser::Serialize",
                          Ty.path "move_core_types::value::MoveFields",
                          [],
                          "serialize",
                          [ S ]
                        |),
                        [
                          M.alloc (|
                            Value.StructTuple
                              "move_core_types::value::MoveFields"
                              [
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::ops::deref::Deref",
                                    Ty.apply
                                      (Ty.path "alloc::vec::Vec")
                                      [
                                        Ty.tuple
                                          [
                                            Ty.path "move_core_types::identifier::Identifier";
                                            Ty.path "move_core_types::value::MoveValue"
                                          ];
                                        Ty.path "alloc::alloc::Global"
                                      ],
                                    [],
                                    "deref",
                                    []
                                  |),
                                  [ M.read (| fields |) ]
                                |)
                              ]
                          |);
                          M.read (| serializer |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_record_field_or_break_match (|
                        γ,
                        "move_core_types::value::MoveStruct::WithTypes",
                        "type_"
                      |) in
                    let γ1_1 :=
                      M.get_struct_record_field_or_break_match (|
                        γ,
                        "move_core_types::value::MoveStruct::WithTypes",
                        "fields"
                      |) in
                    let type_ := M.alloc (| γ1_0 |) in
                    let fields := M.alloc (| γ1_1 |) in
                    let t :=
                      M.copy (|
                        M.match_operator (|
                          M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::ops::try_trait::Try",
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  [ Ty.associated; Ty.associated ],
                                [],
                                "branch",
                                []
                              |),
                              [
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "serde::ser::Serializer",
                                    S,
                                    [],
                                    "serialize_struct",
                                    []
                                  |),
                                  [
                                    M.read (| serializer |);
                                    M.read (|
                                      M.get_constant (|
                                        "move_core_types::value::MOVE_STRUCT_NAME"
                                      |)
                                    |);
                                    Value.Integer Integer.Usize 2
                                  ]
                                |)
                              ]
                            |)
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.get_struct_tuple_field_or_break_match (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Break",
                                    0
                                  |) in
                                let residual := M.copy (| γ0_0 |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      M.return_ (|
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::ops::try_trait::FromResidual",
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              [ Ty.associated; Ty.associated ],
                                            [
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                [ Ty.path "core::convert::Infallible"; Ty.associated
                                                ]
                                            ],
                                            "from_residual",
                                            []
                                          |),
                                          [ M.read (| residual |) ]
                                        |)
                                      |)
                                    |)
                                  |)
                                |)));
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.get_struct_tuple_field_or_break_match (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Continue",
                                    0
                                  |) in
                                let val := M.copy (| γ0_0 |) in
                                val))
                          ]
                        |)
                      |) in
                    let _ :=
                      M.match_operator (|
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::ops::try_trait::Try",
                              Ty.apply
                                (Ty.path "core::result::Result")
                                [ Ty.tuple []; Ty.associated ],
                              [],
                              "branch",
                              []
                            |),
                            [
                              M.call_closure (|
                                M.get_trait_method (|
                                  "serde::ser::SerializeStruct",
                                  Ty.associated,
                                  [],
                                  "serialize_field",
                                  [ Ty.path "alloc::string::String" ]
                                |),
                                [
                                  t;
                                  M.read (|
                                    M.get_constant (| "move_core_types::value::MOVE_STRUCT_TYPE" |)
                                  |);
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "alloc::string::ToString",
                                        Ty.path "move_core_types::language_storage::StructTag",
                                        [],
                                        "to_string",
                                        []
                                      |),
                                      [ M.read (| type_ |) ]
                                    |)
                                  |)
                                ]
                              |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.get_struct_tuple_field_or_break_match (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Break",
                                  0
                                |) in
                              let residual := M.copy (| γ0_0 |) in
                              M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    M.return_ (|
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::ops::try_trait::FromResidual",
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            [ Ty.associated; Ty.associated ],
                                          [
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              [ Ty.path "core::convert::Infallible"; Ty.associated ]
                                          ],
                                          "from_residual",
                                          []
                                        |),
                                        [ M.read (| residual |) ]
                                      |)
                                    |)
                                  |)
                                |)
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.get_struct_tuple_field_or_break_match (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Continue",
                                  0
                                |) in
                              let val := M.copy (| γ0_0 |) in
                              val))
                        ]
                      |) in
                    let _ :=
                      M.match_operator (|
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::ops::try_trait::Try",
                              Ty.apply
                                (Ty.path "core::result::Result")
                                [ Ty.tuple []; Ty.associated ],
                              [],
                              "branch",
                              []
                            |),
                            [
                              M.call_closure (|
                                M.get_trait_method (|
                                  "serde::ser::SerializeStruct",
                                  Ty.associated,
                                  [],
                                  "serialize_field",
                                  [ Ty.path "move_core_types::value::MoveFields" ]
                                |),
                                [
                                  t;
                                  M.read (|
                                    M.get_constant (|
                                      "move_core_types::value::MOVE_STRUCT_FIELDS"
                                    |)
                                  |);
                                  M.alloc (|
                                    Value.StructTuple
                                      "move_core_types::value::MoveFields"
                                      [
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::ops::deref::Deref",
                                            Ty.apply
                                              (Ty.path "alloc::vec::Vec")
                                              [
                                                Ty.tuple
                                                  [
                                                    Ty.path
                                                      "move_core_types::identifier::Identifier";
                                                    Ty.path "move_core_types::value::MoveValue"
                                                  ];
                                                Ty.path "alloc::alloc::Global"
                                              ],
                                            [],
                                            "deref",
                                            []
                                          |),
                                          [ M.read (| fields |) ]
                                        |)
                                      ]
                                  |)
                                ]
                              |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.get_struct_tuple_field_or_break_match (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Break",
                                  0
                                |) in
                              let residual := M.copy (| γ0_0 |) in
                              M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    M.return_ (|
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::ops::try_trait::FromResidual",
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            [ Ty.associated; Ty.associated ],
                                          [
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              [ Ty.path "core::convert::Infallible"; Ty.associated ]
                                          ],
                                          "from_residual",
                                          []
                                        |),
                                        [ M.read (| residual |) ]
                                      |)
                                    |)
                                  |)
                                |)
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.get_struct_tuple_field_or_break_match (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Continue",
                                  0
                                |) in
                              let val := M.copy (| γ0_0 |) in
                              val))
                        ]
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "serde::ser::SerializeStruct",
                          Ty.associated,
                          [],
                          "end",
                          []
                        |),
                        [ M.read (| t |) ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "serde::ser::Serialize"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("serialize", InstanceField.Method serialize) ].
  End Impl_serde_ser_Serialize_for_move_core_types_value_MoveStruct.
  
  Module Impl_core_fmt_Display_for_move_core_types_value_MoveFieldLayout.
    Definition Self : Ty.t := Ty.path "move_core_types::value::MoveFieldLayout".
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter) -> std::fmt::Result {
            write!(f, "{}: {}", self.name, self.layout)
        }
    *)
    Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_fmt", [] |),
            [
              M.read (| f |);
              M.call_closure (|
                M.get_associated_function (| Ty.path "core::fmt::Arguments", "new_v1", [] |),
                [
                  (* Unsize *)
                  M.pointer_coercion
                    (M.alloc (|
                      Value.Array [ M.read (| mk_str "" |); M.read (| mk_str ": " |) ]
                    |));
                  (* Unsize *)
                  M.pointer_coercion
                    (M.alloc (|
                      Value.Array
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::rt::Argument",
                              "new_display",
                              [ Ty.path "move_core_types::identifier::Identifier" ]
                            |),
                            [
                              M.get_struct_record_field
                                (M.read (| self |))
                                "move_core_types::value::MoveFieldLayout"
                                "name"
                            ]
                          |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::rt::Argument",
                              "new_display",
                              [ Ty.path "move_core_types::value::MoveTypeLayout" ]
                            |),
                            [
                              M.get_struct_record_field
                                (M.read (| self |))
                                "move_core_types::value::MoveFieldLayout"
                                "layout"
                            ]
                          |)
                        ]
                    |))
                ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Display"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Display_for_move_core_types_value_MoveFieldLayout.
  
  Module Impl_core_fmt_Display_for_move_core_types_value_MoveTypeLayout.
    Definition Self : Ty.t := Ty.path "move_core_types::value::MoveTypeLayout".
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter) -> std::fmt::Result {
            use MoveTypeLayout::*;
            match self {
                Bool => write!(f, "bool"),
                U8 => write!(f, "u8"),
                U16 => write!(f, "u16"),
                U32 => write!(f, "u32"),
                U64 => write!(f, "u64"),
                U128 => write!(f, "u128"),
                U256 => write!(f, "u256"),
                Address => write!(f, "address"),
                Vector(typ) => write!(f, "vector<{}>", typ),
                Struct(s) => write!(f, "{}", s),
                Signer => write!(f, "signer"),
            }
        }
    *)
    Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (| Value.Array [ M.read (| mk_str "bool" |) ] |))
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (| Value.Array [ M.read (| mk_str "u8" |) ] |))
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (| Value.Array [ M.read (| mk_str "u16" |) ] |))
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (| Value.Array [ M.read (| mk_str "u32" |) ] |))
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (| Value.Array [ M.read (| mk_str "u64" |) ] |))
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (| Value.Array [ M.read (| mk_str "u128" |) ] |))
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (| Value.Array [ M.read (| mk_str "u256" |) ] |))
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (| Value.Array [ M.read (| mk_str "address" |) ] |))
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::value::MoveTypeLayout::Vector",
                        0
                      |) in
                    let typ := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_v1",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [ M.read (| mk_str "vector<" |); M.read (| mk_str ">" |) ]
                                |));
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.path "core::fmt::rt::Argument",
                                          "new_display",
                                          [
                                            Ty.apply
                                              (Ty.path "&")
                                              [
                                                Ty.apply
                                                  (Ty.path "alloc::boxed::Box")
                                                  [
                                                    Ty.path
                                                      "move_core_types::value::MoveTypeLayout";
                                                    Ty.path "alloc::alloc::Global"
                                                  ]
                                              ]
                                          ]
                                        |),
                                        [ typ ]
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::value::MoveTypeLayout::Struct",
                        0
                      |) in
                    let s := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_v1",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (| Value.Array [ M.read (| mk_str "" |) ] |));
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.path "core::fmt::rt::Argument",
                                          "new_display",
                                          [
                                            Ty.apply
                                              (Ty.path "&")
                                              [ Ty.path "move_core_types::value::MoveStructLayout" ]
                                          ]
                                        |),
                                        [ s ]
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (| Value.Array [ M.read (| mk_str "signer" |) ] |))
                            ]
                          |)
                        ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Display"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Display_for_move_core_types_value_MoveTypeLayout.
  
  Module Impl_core_fmt_Display_for_move_core_types_value_MoveStructLayout.
    Definition Self : Ty.t := Ty.path "move_core_types::value::MoveStructLayout".
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter) -> std::fmt::Result {
            write!(f, "{{ ")?;
            match self {
                Self::Runtime(layouts) => {
                    for (i, l) in layouts.iter().enumerate() {
                        write!(f, "{}: {}, ", i, l)?
                    }
                }
                Self::WithFields(layouts) => {
                    for layout in layouts {
                        write!(f, "{}, ", layout)?
                    }
                }
                Self::WithTypes { type_, fields } => {
                    write!(f, "Type: {}", type_)?;
                    write!(f, "Fields:")?;
                    for field in fields {
                        write!(f, "{}, ", field)?
                    }
                }
            }
            write!(f, "}}")
        }
    *)
    Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.read (|
            let _ :=
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::try_trait::Try",
                      Ty.apply
                        (Ty.path "core::result::Result")
                        [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                      [],
                      "branch",
                      []
                    |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (| Value.Array [ M.read (| mk_str "{ " |) ] |))
                            ]
                          |)
                        ]
                      |)
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.get_struct_tuple_field_or_break_match (|
                          γ,
                          "core::ops::control_flow::ControlFlow::Break",
                          0
                        |) in
                      let residual := M.copy (| γ0_0 |) in
                      M.alloc (|
                        M.never_to_any (|
                          M.read (|
                            M.return_ (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::ops::try_trait::FromResidual",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path "core::fmt::Error"
                                      ]
                                  ],
                                  "from_residual",
                                  []
                                |),
                                [ M.read (| residual |) ]
                              |)
                            |)
                          |)
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.get_struct_tuple_field_or_break_match (|
                          γ,
                          "core::ops::control_flow::ControlFlow::Continue",
                          0
                        |) in
                      let val := M.copy (| γ0_0 |) in
                      val))
                ]
              |) in
            let _ :=
              M.match_operator (|
                self,
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.get_struct_tuple_field_or_break_match (|
                          γ,
                          "move_core_types::value::MoveStructLayout::Runtime",
                          0
                        |) in
                      let layouts := M.alloc (| γ1_0 |) in
                      M.use
                        (M.match_operator (|
                          M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::iter::traits::collect::IntoIterator",
                                Ty.apply
                                  (Ty.path "core::iter::adapters::enumerate::Enumerate")
                                  [
                                    Ty.apply
                                      (Ty.path "core::slice::iter::Iter")
                                      [ Ty.path "move_core_types::value::MoveTypeLayout" ]
                                  ],
                                [],
                                "into_iter",
                                []
                              |),
                              [
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::iter::traits::iterator::Iterator",
                                    Ty.apply
                                      (Ty.path "core::slice::iter::Iter")
                                      [ Ty.path "move_core_types::value::MoveTypeLayout" ],
                                    [],
                                    "enumerate",
                                    []
                                  |),
                                  [
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.apply
                                          (Ty.path "slice")
                                          [ Ty.path "move_core_types::value::MoveTypeLayout" ],
                                        "iter",
                                        []
                                      |),
                                      [
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::ops::deref::Deref",
                                            Ty.apply
                                              (Ty.path "alloc::vec::Vec")
                                              [
                                                Ty.path "move_core_types::value::MoveTypeLayout";
                                                Ty.path "alloc::alloc::Global"
                                              ],
                                            [],
                                            "deref",
                                            []
                                          |),
                                          [ M.read (| layouts |) ]
                                        |)
                                      ]
                                    |)
                                  ]
                                |)
                              ]
                            |)
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let iter := M.copy (| γ |) in
                                M.loop (|
                                  ltac:(M.monadic
                                    (let _ :=
                                      M.match_operator (|
                                        M.alloc (|
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::iter::traits::iterator::Iterator",
                                              Ty.apply
                                                (Ty.path
                                                  "core::iter::adapters::enumerate::Enumerate")
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::slice::iter::Iter")
                                                    [
                                                      Ty.path
                                                        "move_core_types::value::MoveTypeLayout"
                                                    ]
                                                ],
                                              [],
                                              "next",
                                              []
                                            |),
                                            [ iter ]
                                          |)
                                        |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (M.alloc (|
                                                M.never_to_any (| M.read (| M.break (||) |) |)
                                              |)));
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let γ0_0 :=
                                                M.get_struct_tuple_field_or_break_match (|
                                                  γ,
                                                  "core::option::Option::Some",
                                                  0
                                                |) in
                                              let γ1_0 := M.get_tuple_field γ0_0 0 in
                                              let γ1_1 := M.get_tuple_field γ0_0 1 in
                                              let i := M.copy (| γ1_0 |) in
                                              let l := M.copy (| γ1_1 |) in
                                              M.match_operator (|
                                                M.alloc (|
                                                  M.call_closure (|
                                                    M.get_trait_method (|
                                                      "core::ops::try_trait::Try",
                                                      Ty.apply
                                                        (Ty.path "core::result::Result")
                                                        [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                                                      [],
                                                      "branch",
                                                      []
                                                    |),
                                                    [
                                                      M.call_closure (|
                                                        M.get_associated_function (|
                                                          Ty.path "core::fmt::Formatter",
                                                          "write_fmt",
                                                          []
                                                        |),
                                                        [
                                                          M.read (| f |);
                                                          M.call_closure (|
                                                            M.get_associated_function (|
                                                              Ty.path "core::fmt::Arguments",
                                                              "new_v1",
                                                              []
                                                            |),
                                                            [
                                                              (* Unsize *)
                                                              M.pointer_coercion
                                                                (M.alloc (|
                                                                  Value.Array
                                                                    [
                                                                      M.read (| mk_str "" |);
                                                                      M.read (| mk_str ": " |);
                                                                      M.read (| mk_str ", " |)
                                                                    ]
                                                                |));
                                                              (* Unsize *)
                                                              M.pointer_coercion
                                                                (M.alloc (|
                                                                  Value.Array
                                                                    [
                                                                      M.call_closure (|
                                                                        M.get_associated_function (|
                                                                          Ty.path
                                                                            "core::fmt::rt::Argument",
                                                                          "new_display",
                                                                          [ Ty.path "usize" ]
                                                                        |),
                                                                        [ i ]
                                                                      |);
                                                                      M.call_closure (|
                                                                        M.get_associated_function (|
                                                                          Ty.path
                                                                            "core::fmt::rt::Argument",
                                                                          "new_display",
                                                                          [
                                                                            Ty.apply
                                                                              (Ty.path "&")
                                                                              [
                                                                                Ty.path
                                                                                  "move_core_types::value::MoveTypeLayout"
                                                                              ]
                                                                          ]
                                                                        |),
                                                                        [ l ]
                                                                      |)
                                                                    ]
                                                                |))
                                                            ]
                                                          |)
                                                        ]
                                                      |)
                                                    ]
                                                  |)
                                                |),
                                                [
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (let γ0_0 :=
                                                        M.get_struct_tuple_field_or_break_match (|
                                                          γ,
                                                          "core::ops::control_flow::ControlFlow::Break",
                                                          0
                                                        |) in
                                                      let residual := M.copy (| γ0_0 |) in
                                                      M.alloc (|
                                                        M.never_to_any (|
                                                          M.read (|
                                                            M.return_ (|
                                                              M.call_closure (|
                                                                M.get_trait_method (|
                                                                  "core::ops::try_trait::FromResidual",
                                                                  Ty.apply
                                                                    (Ty.path "core::result::Result")
                                                                    [
                                                                      Ty.tuple [];
                                                                      Ty.path "core::fmt::Error"
                                                                    ],
                                                                  [
                                                                    Ty.apply
                                                                      (Ty.path
                                                                        "core::result::Result")
                                                                      [
                                                                        Ty.path
                                                                          "core::convert::Infallible";
                                                                        Ty.path "core::fmt::Error"
                                                                      ]
                                                                  ],
                                                                  "from_residual",
                                                                  []
                                                                |),
                                                                [ M.read (| residual |) ]
                                                              |)
                                                            |)
                                                          |)
                                                        |)
                                                      |)));
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (let γ0_0 :=
                                                        M.get_struct_tuple_field_or_break_match (|
                                                          γ,
                                                          "core::ops::control_flow::ControlFlow::Continue",
                                                          0
                                                        |) in
                                                      let val := M.copy (| γ0_0 |) in
                                                      val))
                                                ]
                                              |)))
                                        ]
                                      |) in
                                    M.alloc (| Value.Tuple [] |)))
                                |)))
                          ]
                        |))));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.get_struct_tuple_field_or_break_match (|
                          γ,
                          "move_core_types::value::MoveStructLayout::WithFields",
                          0
                        |) in
                      let layouts := M.alloc (| γ1_0 |) in
                      M.use
                        (M.match_operator (|
                          M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::iter::traits::collect::IntoIterator",
                                Ty.apply
                                  (Ty.path "&")
                                  [
                                    Ty.apply
                                      (Ty.path "alloc::vec::Vec")
                                      [
                                        Ty.path "move_core_types::value::MoveFieldLayout";
                                        Ty.path "alloc::alloc::Global"
                                      ]
                                  ],
                                [],
                                "into_iter",
                                []
                              |),
                              [ M.read (| layouts |) ]
                            |)
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let iter := M.copy (| γ |) in
                                M.loop (|
                                  ltac:(M.monadic
                                    (let _ :=
                                      M.match_operator (|
                                        M.alloc (|
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::iter::traits::iterator::Iterator",
                                              Ty.apply
                                                (Ty.path "core::slice::iter::Iter")
                                                [ Ty.path "move_core_types::value::MoveFieldLayout"
                                                ],
                                              [],
                                              "next",
                                              []
                                            |),
                                            [ iter ]
                                          |)
                                        |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (M.alloc (|
                                                M.never_to_any (| M.read (| M.break (||) |) |)
                                              |)));
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let γ0_0 :=
                                                M.get_struct_tuple_field_or_break_match (|
                                                  γ,
                                                  "core::option::Option::Some",
                                                  0
                                                |) in
                                              let layout := M.copy (| γ0_0 |) in
                                              M.match_operator (|
                                                M.alloc (|
                                                  M.call_closure (|
                                                    M.get_trait_method (|
                                                      "core::ops::try_trait::Try",
                                                      Ty.apply
                                                        (Ty.path "core::result::Result")
                                                        [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                                                      [],
                                                      "branch",
                                                      []
                                                    |),
                                                    [
                                                      M.call_closure (|
                                                        M.get_associated_function (|
                                                          Ty.path "core::fmt::Formatter",
                                                          "write_fmt",
                                                          []
                                                        |),
                                                        [
                                                          M.read (| f |);
                                                          M.call_closure (|
                                                            M.get_associated_function (|
                                                              Ty.path "core::fmt::Arguments",
                                                              "new_v1",
                                                              []
                                                            |),
                                                            [
                                                              (* Unsize *)
                                                              M.pointer_coercion
                                                                (M.alloc (|
                                                                  Value.Array
                                                                    [
                                                                      M.read (| mk_str "" |);
                                                                      M.read (| mk_str ", " |)
                                                                    ]
                                                                |));
                                                              (* Unsize *)
                                                              M.pointer_coercion
                                                                (M.alloc (|
                                                                  Value.Array
                                                                    [
                                                                      M.call_closure (|
                                                                        M.get_associated_function (|
                                                                          Ty.path
                                                                            "core::fmt::rt::Argument",
                                                                          "new_display",
                                                                          [
                                                                            Ty.apply
                                                                              (Ty.path "&")
                                                                              [
                                                                                Ty.path
                                                                                  "move_core_types::value::MoveFieldLayout"
                                                                              ]
                                                                          ]
                                                                        |),
                                                                        [ layout ]
                                                                      |)
                                                                    ]
                                                                |))
                                                            ]
                                                          |)
                                                        ]
                                                      |)
                                                    ]
                                                  |)
                                                |),
                                                [
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (let γ0_0 :=
                                                        M.get_struct_tuple_field_or_break_match (|
                                                          γ,
                                                          "core::ops::control_flow::ControlFlow::Break",
                                                          0
                                                        |) in
                                                      let residual := M.copy (| γ0_0 |) in
                                                      M.alloc (|
                                                        M.never_to_any (|
                                                          M.read (|
                                                            M.return_ (|
                                                              M.call_closure (|
                                                                M.get_trait_method (|
                                                                  "core::ops::try_trait::FromResidual",
                                                                  Ty.apply
                                                                    (Ty.path "core::result::Result")
                                                                    [
                                                                      Ty.tuple [];
                                                                      Ty.path "core::fmt::Error"
                                                                    ],
                                                                  [
                                                                    Ty.apply
                                                                      (Ty.path
                                                                        "core::result::Result")
                                                                      [
                                                                        Ty.path
                                                                          "core::convert::Infallible";
                                                                        Ty.path "core::fmt::Error"
                                                                      ]
                                                                  ],
                                                                  "from_residual",
                                                                  []
                                                                |),
                                                                [ M.read (| residual |) ]
                                                              |)
                                                            |)
                                                          |)
                                                        |)
                                                      |)));
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (let γ0_0 :=
                                                        M.get_struct_tuple_field_or_break_match (|
                                                          γ,
                                                          "core::ops::control_flow::ControlFlow::Continue",
                                                          0
                                                        |) in
                                                      let val := M.copy (| γ0_0 |) in
                                                      val))
                                                ]
                                              |)))
                                        ]
                                      |) in
                                    M.alloc (| Value.Tuple [] |)))
                                |)))
                          ]
                        |))));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.get_struct_record_field_or_break_match (|
                          γ,
                          "move_core_types::value::MoveStructLayout::WithTypes",
                          "type_"
                        |) in
                      let γ1_1 :=
                        M.get_struct_record_field_or_break_match (|
                          γ,
                          "move_core_types::value::MoveStructLayout::WithTypes",
                          "fields"
                        |) in
                      let type_ := M.alloc (| γ1_0 |) in
                      let fields := M.alloc (| γ1_1 |) in
                      let _ :=
                        M.match_operator (|
                          M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::ops::try_trait::Try",
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                                [],
                                "branch",
                                []
                              |),
                              [
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.path "core::fmt::Formatter",
                                    "write_fmt",
                                    []
                                  |),
                                  [
                                    M.read (| f |);
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.path "core::fmt::Arguments",
                                        "new_v1",
                                        []
                                      |),
                                      [
                                        (* Unsize *)
                                        M.pointer_coercion
                                          (M.alloc (|
                                            Value.Array [ M.read (| mk_str "Type: " |) ]
                                          |));
                                        (* Unsize *)
                                        M.pointer_coercion
                                          (M.alloc (|
                                            Value.Array
                                              [
                                                M.call_closure (|
                                                  M.get_associated_function (|
                                                    Ty.path "core::fmt::rt::Argument",
                                                    "new_display",
                                                    [
                                                      Ty.apply
                                                        (Ty.path "&")
                                                        [
                                                          Ty.path
                                                            "move_core_types::language_storage::StructTag"
                                                        ]
                                                    ]
                                                  |),
                                                  [ type_ ]
                                                |)
                                              ]
                                          |))
                                      ]
                                    |)
                                  ]
                                |)
                              ]
                            |)
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.get_struct_tuple_field_or_break_match (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Break",
                                    0
                                  |) in
                                let residual := M.copy (| γ0_0 |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      M.return_ (|
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::ops::try_trait::FromResidual",
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                                            [
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                [
                                                  Ty.path "core::convert::Infallible";
                                                  Ty.path "core::fmt::Error"
                                                ]
                                            ],
                                            "from_residual",
                                            []
                                          |),
                                          [ M.read (| residual |) ]
                                        |)
                                      |)
                                    |)
                                  |)
                                |)));
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.get_struct_tuple_field_or_break_match (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Continue",
                                    0
                                  |) in
                                let val := M.copy (| γ0_0 |) in
                                val))
                          ]
                        |) in
                      let _ :=
                        M.match_operator (|
                          M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::ops::try_trait::Try",
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                                [],
                                "branch",
                                []
                              |),
                              [
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.path "core::fmt::Formatter",
                                    "write_fmt",
                                    []
                                  |),
                                  [
                                    M.read (| f |);
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.path "core::fmt::Arguments",
                                        "new_const",
                                        []
                                      |),
                                      [
                                        (* Unsize *)
                                        M.pointer_coercion
                                          (M.alloc (|
                                            Value.Array [ M.read (| mk_str "Fields:" |) ]
                                          |))
                                      ]
                                    |)
                                  ]
                                |)
                              ]
                            |)
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.get_struct_tuple_field_or_break_match (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Break",
                                    0
                                  |) in
                                let residual := M.copy (| γ0_0 |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      M.return_ (|
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::ops::try_trait::FromResidual",
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                                            [
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                [
                                                  Ty.path "core::convert::Infallible";
                                                  Ty.path "core::fmt::Error"
                                                ]
                                            ],
                                            "from_residual",
                                            []
                                          |),
                                          [ M.read (| residual |) ]
                                        |)
                                      |)
                                    |)
                                  |)
                                |)));
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.get_struct_tuple_field_or_break_match (|
                                    γ,
                                    "core::ops::control_flow::ControlFlow::Continue",
                                    0
                                  |) in
                                let val := M.copy (| γ0_0 |) in
                                val))
                          ]
                        |) in
                      M.use
                        (M.match_operator (|
                          M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::iter::traits::collect::IntoIterator",
                                Ty.apply
                                  (Ty.path "&")
                                  [
                                    Ty.apply
                                      (Ty.path "alloc::vec::Vec")
                                      [
                                        Ty.path "move_core_types::value::MoveFieldLayout";
                                        Ty.path "alloc::alloc::Global"
                                      ]
                                  ],
                                [],
                                "into_iter",
                                []
                              |),
                              [ M.read (| fields |) ]
                            |)
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let iter := M.copy (| γ |) in
                                M.loop (|
                                  ltac:(M.monadic
                                    (let _ :=
                                      M.match_operator (|
                                        M.alloc (|
                                          M.call_closure (|
                                            M.get_trait_method (|
                                              "core::iter::traits::iterator::Iterator",
                                              Ty.apply
                                                (Ty.path "core::slice::iter::Iter")
                                                [ Ty.path "move_core_types::value::MoveFieldLayout"
                                                ],
                                              [],
                                              "next",
                                              []
                                            |),
                                            [ iter ]
                                          |)
                                        |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (M.alloc (|
                                                M.never_to_any (| M.read (| M.break (||) |) |)
                                              |)));
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let γ0_0 :=
                                                M.get_struct_tuple_field_or_break_match (|
                                                  γ,
                                                  "core::option::Option::Some",
                                                  0
                                                |) in
                                              let field := M.copy (| γ0_0 |) in
                                              M.match_operator (|
                                                M.alloc (|
                                                  M.call_closure (|
                                                    M.get_trait_method (|
                                                      "core::ops::try_trait::Try",
                                                      Ty.apply
                                                        (Ty.path "core::result::Result")
                                                        [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                                                      [],
                                                      "branch",
                                                      []
                                                    |),
                                                    [
                                                      M.call_closure (|
                                                        M.get_associated_function (|
                                                          Ty.path "core::fmt::Formatter",
                                                          "write_fmt",
                                                          []
                                                        |),
                                                        [
                                                          M.read (| f |);
                                                          M.call_closure (|
                                                            M.get_associated_function (|
                                                              Ty.path "core::fmt::Arguments",
                                                              "new_v1",
                                                              []
                                                            |),
                                                            [
                                                              (* Unsize *)
                                                              M.pointer_coercion
                                                                (M.alloc (|
                                                                  Value.Array
                                                                    [
                                                                      M.read (| mk_str "" |);
                                                                      M.read (| mk_str ", " |)
                                                                    ]
                                                                |));
                                                              (* Unsize *)
                                                              M.pointer_coercion
                                                                (M.alloc (|
                                                                  Value.Array
                                                                    [
                                                                      M.call_closure (|
                                                                        M.get_associated_function (|
                                                                          Ty.path
                                                                            "core::fmt::rt::Argument",
                                                                          "new_display",
                                                                          [
                                                                            Ty.apply
                                                                              (Ty.path "&")
                                                                              [
                                                                                Ty.path
                                                                                  "move_core_types::value::MoveFieldLayout"
                                                                              ]
                                                                          ]
                                                                        |),
                                                                        [ field ]
                                                                      |)
                                                                    ]
                                                                |))
                                                            ]
                                                          |)
                                                        ]
                                                      |)
                                                    ]
                                                  |)
                                                |),
                                                [
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (let γ0_0 :=
                                                        M.get_struct_tuple_field_or_break_match (|
                                                          γ,
                                                          "core::ops::control_flow::ControlFlow::Break",
                                                          0
                                                        |) in
                                                      let residual := M.copy (| γ0_0 |) in
                                                      M.alloc (|
                                                        M.never_to_any (|
                                                          M.read (|
                                                            M.return_ (|
                                                              M.call_closure (|
                                                                M.get_trait_method (|
                                                                  "core::ops::try_trait::FromResidual",
                                                                  Ty.apply
                                                                    (Ty.path "core::result::Result")
                                                                    [
                                                                      Ty.tuple [];
                                                                      Ty.path "core::fmt::Error"
                                                                    ],
                                                                  [
                                                                    Ty.apply
                                                                      (Ty.path
                                                                        "core::result::Result")
                                                                      [
                                                                        Ty.path
                                                                          "core::convert::Infallible";
                                                                        Ty.path "core::fmt::Error"
                                                                      ]
                                                                  ],
                                                                  "from_residual",
                                                                  []
                                                                |),
                                                                [ M.read (| residual |) ]
                                                              |)
                                                            |)
                                                          |)
                                                        |)
                                                      |)));
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (let γ0_0 :=
                                                        M.get_struct_tuple_field_or_break_match (|
                                                          γ,
                                                          "core::ops::control_flow::ControlFlow::Continue",
                                                          0
                                                        |) in
                                                      let val := M.copy (| γ0_0 |) in
                                                      val))
                                                ]
                                              |)))
                                        ]
                                      |) in
                                    M.alloc (| Value.Tuple [] |)))
                                |)))
                          ]
                        |))))
                ]
              |) in
            M.alloc (|
              M.call_closure (|
                M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_fmt", [] |),
                [
                  M.read (| f |);
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "core::fmt::Arguments", "new_const", [] |),
                    [
                      (* Unsize *)
                      M.pointer_coercion (M.alloc (| Value.Array [ M.read (| mk_str "}" |) ] |))
                    ]
                  |)
                ]
              |)
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Display"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Display_for_move_core_types_value_MoveStructLayout.
  
  Module Impl_core_convert_TryInto_move_core_types_language_storage_TypeTag_for_ref__move_core_types_value_MoveTypeLayout.
    Definition Self : Ty.t :=
      Ty.apply (Ty.path "&") [ Ty.path "move_core_types::value::MoveTypeLayout" ].
    
    (*     type Error = anyhow::Error; *)
    Definition _Error : Ty.t := Ty.path "anyhow::Error".
    
    (*
        fn try_into(self) -> Result<TypeTag, Self::Error> {
            Ok(match self {
                MoveTypeLayout::Address => TypeTag::Address,
                MoveTypeLayout::Bool => TypeTag::Bool,
                MoveTypeLayout::U8 => TypeTag::U8,
                MoveTypeLayout::U16 => TypeTag::U16,
                MoveTypeLayout::U32 => TypeTag::U32,
                MoveTypeLayout::U64 => TypeTag::U64,
                MoveTypeLayout::U128 => TypeTag::U128,
                MoveTypeLayout::U256 => TypeTag::U256,
                MoveTypeLayout::Signer => TypeTag::Signer,
                MoveTypeLayout::Vector(v) => {
                    let inner_type = &**v;
                    TypeTag::Vector(Box::new(inner_type.try_into()?))
                }
                MoveTypeLayout::Struct(v) => TypeTag::Struct(Box::new(v.try_into()?)),
            })
        }
    *)
    Definition try_into (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.StructTuple
            "core::result::Result::Ok"
            [
              M.read (|
                M.match_operator (|
                  self,
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (|
                          Value.StructTuple "move_core_types::language_storage::TypeTag::Address" []
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (|
                          Value.StructTuple "move_core_types::language_storage::TypeTag::Bool" []
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (|
                          Value.StructTuple "move_core_types::language_storage::TypeTag::U8" []
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (|
                          Value.StructTuple "move_core_types::language_storage::TypeTag::U16" []
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (|
                          Value.StructTuple "move_core_types::language_storage::TypeTag::U32" []
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (|
                          Value.StructTuple "move_core_types::language_storage::TypeTag::U64" []
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (|
                          Value.StructTuple "move_core_types::language_storage::TypeTag::U128" []
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (|
                          Value.StructTuple "move_core_types::language_storage::TypeTag::U256" []
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (|
                          Value.StructTuple "move_core_types::language_storage::TypeTag::Signer" []
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let γ1_0 :=
                          M.get_struct_tuple_field_or_break_match (|
                            γ,
                            "move_core_types::value::MoveTypeLayout::Vector",
                            0
                          |) in
                        let v := M.alloc (| γ1_0 |) in
                        let inner_type := M.alloc (| M.read (| M.read (| v |) |) |) in
                        M.alloc (|
                          Value.StructTuple
                            "move_core_types::language_storage::TypeTag::Vector"
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "alloc::boxed::Box")
                                    [
                                      Ty.path "move_core_types::language_storage::TypeTag";
                                      Ty.path "alloc::alloc::Global"
                                    ],
                                  "new",
                                  []
                                |),
                                [
                                  M.read (|
                                    M.match_operator (|
                                      M.alloc (|
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::ops::try_trait::Try",
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              [
                                                Ty.path
                                                  "move_core_types::language_storage::TypeTag";
                                                Ty.path "anyhow::Error"
                                              ],
                                            [],
                                            "branch",
                                            []
                                          |),
                                          [
                                            M.call_closure (|
                                              M.get_trait_method (|
                                                "core::convert::TryInto",
                                                Ty.apply
                                                  (Ty.path "&")
                                                  [ Ty.path "move_core_types::value::MoveTypeLayout"
                                                  ],
                                                [
                                                  Ty.path
                                                    "move_core_types::language_storage::TypeTag"
                                                ],
                                                "try_into",
                                                []
                                              |),
                                              [ M.read (| inner_type |) ]
                                            |)
                                          ]
                                        |)
                                      |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.get_struct_tuple_field_or_break_match (|
                                                γ,
                                                "core::ops::control_flow::ControlFlow::Break",
                                                0
                                              |) in
                                            let residual := M.copy (| γ0_0 |) in
                                            M.alloc (|
                                              M.never_to_any (|
                                                M.read (|
                                                  M.return_ (|
                                                    M.call_closure (|
                                                      M.get_trait_method (|
                                                        "core::ops::try_trait::FromResidual",
                                                        Ty.apply
                                                          (Ty.path "core::result::Result")
                                                          [
                                                            Ty.path
                                                              "move_core_types::language_storage::TypeTag";
                                                            Ty.path "anyhow::Error"
                                                          ],
                                                        [
                                                          Ty.apply
                                                            (Ty.path "core::result::Result")
                                                            [
                                                              Ty.path "core::convert::Infallible";
                                                              Ty.path "anyhow::Error"
                                                            ]
                                                        ],
                                                        "from_residual",
                                                        []
                                                      |),
                                                      [ M.read (| residual |) ]
                                                    |)
                                                  |)
                                                |)
                                              |)
                                            |)));
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.get_struct_tuple_field_or_break_match (|
                                                γ,
                                                "core::ops::control_flow::ControlFlow::Continue",
                                                0
                                              |) in
                                            let val := M.copy (| γ0_0 |) in
                                            val))
                                      ]
                                    |)
                                  |)
                                ]
                              |)
                            ]
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let γ1_0 :=
                          M.get_struct_tuple_field_or_break_match (|
                            γ,
                            "move_core_types::value::MoveTypeLayout::Struct",
                            0
                          |) in
                        let v := M.alloc (| γ1_0 |) in
                        M.alloc (|
                          Value.StructTuple
                            "move_core_types::language_storage::TypeTag::Struct"
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "alloc::boxed::Box")
                                    [
                                      Ty.path "move_core_types::language_storage::StructTag";
                                      Ty.path "alloc::alloc::Global"
                                    ],
                                  "new",
                                  []
                                |),
                                [
                                  M.read (|
                                    M.match_operator (|
                                      M.alloc (|
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::ops::try_trait::Try",
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              [
                                                Ty.path
                                                  "move_core_types::language_storage::StructTag";
                                                Ty.path "anyhow::Error"
                                              ],
                                            [],
                                            "branch",
                                            []
                                          |),
                                          [
                                            M.call_closure (|
                                              M.get_trait_method (|
                                                "core::convert::TryInto",
                                                Ty.apply
                                                  (Ty.path "&")
                                                  [
                                                    Ty.path
                                                      "move_core_types::value::MoveStructLayout"
                                                  ],
                                                [
                                                  Ty.path
                                                    "move_core_types::language_storage::StructTag"
                                                ],
                                                "try_into",
                                                []
                                              |),
                                              [ M.read (| v |) ]
                                            |)
                                          ]
                                        |)
                                      |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.get_struct_tuple_field_or_break_match (|
                                                γ,
                                                "core::ops::control_flow::ControlFlow::Break",
                                                0
                                              |) in
                                            let residual := M.copy (| γ0_0 |) in
                                            M.alloc (|
                                              M.never_to_any (|
                                                M.read (|
                                                  M.return_ (|
                                                    M.call_closure (|
                                                      M.get_trait_method (|
                                                        "core::ops::try_trait::FromResidual",
                                                        Ty.apply
                                                          (Ty.path "core::result::Result")
                                                          [
                                                            Ty.path
                                                              "move_core_types::language_storage::TypeTag";
                                                            Ty.path "anyhow::Error"
                                                          ],
                                                        [
                                                          Ty.apply
                                                            (Ty.path "core::result::Result")
                                                            [
                                                              Ty.path "core::convert::Infallible";
                                                              Ty.path "anyhow::Error"
                                                            ]
                                                        ],
                                                        "from_residual",
                                                        []
                                                      |),
                                                      [ M.read (| residual |) ]
                                                    |)
                                                  |)
                                                |)
                                              |)
                                            |)));
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.get_struct_tuple_field_or_break_match (|
                                                γ,
                                                "core::ops::control_flow::ControlFlow::Continue",
                                                0
                                              |) in
                                            let val := M.copy (| γ0_0 |) in
                                            val))
                                      ]
                                    |)
                                  |)
                                ]
                              |)
                            ]
                        |)))
                  ]
                |)
              |)
            ]))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::convert::TryInto"
        Self
        (* Trait polymorphic types *)
        [ (* T *) Ty.path "move_core_types::language_storage::TypeTag" ]
        (* Instance *)
        [ ("Error", InstanceField.Ty _Error); ("try_into", InstanceField.Method try_into) ].
  End Impl_core_convert_TryInto_move_core_types_language_storage_TypeTag_for_ref__move_core_types_value_MoveTypeLayout.
  
  Module Impl_core_convert_TryInto_move_core_types_language_storage_StructTag_for_ref__move_core_types_value_MoveStructLayout.
    Definition Self : Ty.t :=
      Ty.apply (Ty.path "&") [ Ty.path "move_core_types::value::MoveStructLayout" ].
    
    (*     type Error = anyhow::Error; *)
    Definition _Error : Ty.t := Ty.path "anyhow::Error".
    
    (*
        fn try_into(self) -> Result<StructTag, Self::Error> {
            use MoveStructLayout::*;
            match self {
                Runtime(..) | WithFields(..) => bail!(
                    "Invalid MoveTypeLayout -> StructTag conversion--needed MoveLayoutType::WithTypes"
                ),
                WithTypes { type_, .. } => Ok(type_.clone()),
            }
        }
    *)
    Definition try_into (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.find_or_pattern (|
                      γ,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.read (| γ |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.read (| γ |) in
                            Value.Tuple []))
                      ],
                      M.closure
                        (fun γ =>
                          ltac:(M.monadic
                            match γ with
                            | [] =>
                              M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    M.return_ (|
                                      Value.StructTuple
                                        "core::result::Result::Err"
                                        [
                                          M.read (|
                                            let error :=
                                              M.alloc (|
                                                M.call_closure (|
                                                  M.get_function (|
                                                    "anyhow::private::format_err",
                                                    []
                                                  |),
                                                  [
                                                    M.call_closure (|
                                                      M.get_associated_function (|
                                                        Ty.path "core::fmt::Arguments",
                                                        "new_const",
                                                        []
                                                      |),
                                                      [
                                                        (* Unsize *)
                                                        M.pointer_coercion
                                                          (M.alloc (|
                                                            Value.Array
                                                              [
                                                                M.read (|
                                                                  mk_str
                                                                    "Invalid MoveTypeLayout -> StructTag conversion--needed MoveLayoutType::WithTypes"
                                                                |)
                                                              ]
                                                          |))
                                                      ]
                                                    |)
                                                  ]
                                                |)
                                              |) in
                                            error
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            | _ => M.impossible (||)
                            end))
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_record_field_or_break_match (|
                        γ,
                        "move_core_types::value::MoveStructLayout::WithTypes",
                        "type_"
                      |) in
                    let type_ := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.path "move_core_types::language_storage::StructTag",
                              [],
                              "clone",
                              []
                            |),
                            [ M.read (| type_ |) ]
                          |)
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::convert::TryInto"
        Self
        (* Trait polymorphic types *)
        [ (* T *) Ty.path "move_core_types::language_storage::StructTag" ]
        (* Instance *)
        [ ("Error", InstanceField.Ty _Error); ("try_into", InstanceField.Method try_into) ].
  End Impl_core_convert_TryInto_move_core_types_language_storage_StructTag_for_ref__move_core_types_value_MoveStructLayout.
  
  Module Impl_core_fmt_Display_for_move_core_types_value_MoveValue.
    Definition Self : Ty.t := Ty.path "move_core_types::value::MoveValue".
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            match self {
                MoveValue::U8(u) => write!(f, "{}u8", u),
                MoveValue::U16(u) => write!(f, "{}u16", u),
                MoveValue::U32(u) => write!(f, "{}u32", u),
                MoveValue::U64(u) => write!(f, "{}u64", u),
                MoveValue::U128(u) => write!(f, "{}u128", u),
                MoveValue::U256(u) => write!(f, "{}u256", u),
                MoveValue::Bool(false) => write!(f, "false"),
                MoveValue::Bool(true) => write!(f, "true"),
                MoveValue::Address(a) => write!(f, "{}", a.to_hex_literal()),
                MoveValue::Signer(a) => write!(f, "signer({})", a.to_hex_literal()),
                MoveValue::Vector(v) => fmt_list(f, "vector[", v, "]"),
                MoveValue::Struct(s) => fmt::Display::fmt(s, f),
            }
        }
    *)
    Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::value::MoveValue::U8",
                        0
                      |) in
                    let u := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_v1",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array [ M.read (| mk_str "" |); M.read (| mk_str "u8" |) ]
                                |));
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.path "core::fmt::rt::Argument",
                                          "new_display",
                                          [ Ty.apply (Ty.path "&") [ Ty.path "u8" ] ]
                                        |),
                                        [ u ]
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::value::MoveValue::U16",
                        0
                      |) in
                    let u := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_v1",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array [ M.read (| mk_str "" |); M.read (| mk_str "u16" |) ]
                                |));
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.path "core::fmt::rt::Argument",
                                          "new_display",
                                          [ Ty.apply (Ty.path "&") [ Ty.path "u16" ] ]
                                        |),
                                        [ u ]
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::value::MoveValue::U32",
                        0
                      |) in
                    let u := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_v1",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array [ M.read (| mk_str "" |); M.read (| mk_str "u32" |) ]
                                |));
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.path "core::fmt::rt::Argument",
                                          "new_display",
                                          [ Ty.apply (Ty.path "&") [ Ty.path "u32" ] ]
                                        |),
                                        [ u ]
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::value::MoveValue::U64",
                        0
                      |) in
                    let u := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_v1",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array [ M.read (| mk_str "" |); M.read (| mk_str "u64" |) ]
                                |));
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.path "core::fmt::rt::Argument",
                                          "new_display",
                                          [ Ty.apply (Ty.path "&") [ Ty.path "u64" ] ]
                                        |),
                                        [ u ]
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::value::MoveValue::U128",
                        0
                      |) in
                    let u := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_v1",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array [ M.read (| mk_str "" |); M.read (| mk_str "u128" |) ]
                                |));
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.path "core::fmt::rt::Argument",
                                          "new_display",
                                          [ Ty.apply (Ty.path "&") [ Ty.path "u128" ] ]
                                        |),
                                        [ u ]
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::value::MoveValue::U256",
                        0
                      |) in
                    let u := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_v1",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array [ M.read (| mk_str "" |); M.read (| mk_str "u256" |) ]
                                |));
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.path "core::fmt::rt::Argument",
                                          "new_display",
                                          [
                                            Ty.apply
                                              (Ty.path "&")
                                              [ Ty.path "move_core_types::u256::U256" ]
                                          ]
                                        |),
                                        [ u ]
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::value::MoveValue::Bool",
                        0
                      |) in
                    let _ :=
                      M.is_constant_or_break_match (| M.read (| γ1_0 |), Value.Bool false |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (| Value.Array [ M.read (| mk_str "false" |) ] |))
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::value::MoveValue::Bool",
                        0
                      |) in
                    let _ :=
                      M.is_constant_or_break_match (| M.read (| γ1_0 |), Value.Bool true |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (| Value.Array [ M.read (| mk_str "true" |) ] |))
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::value::MoveValue::Address",
                        0
                      |) in
                    let a := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_v1",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (| Value.Array [ M.read (| mk_str "" |) ] |));
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.path "core::fmt::rt::Argument",
                                          "new_display",
                                          [ Ty.path "alloc::string::String" ]
                                        |),
                                        [
                                          M.alloc (|
                                            M.call_closure (|
                                              M.get_associated_function (|
                                                Ty.path
                                                  "move_core_types::account_address::AccountAddress",
                                                "to_hex_literal",
                                                []
                                              |),
                                              [ M.read (| a |) ]
                                            |)
                                          |)
                                        ]
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::value::MoveValue::Signer",
                        0
                      |) in
                    let a := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_v1",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [ M.read (| mk_str "signer(" |); M.read (| mk_str ")" |) ]
                                |));
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.path "core::fmt::rt::Argument",
                                          "new_display",
                                          [ Ty.path "alloc::string::String" ]
                                        |),
                                        [
                                          M.alloc (|
                                            M.call_closure (|
                                              M.get_associated_function (|
                                                Ty.path
                                                  "move_core_types::account_address::AccountAddress",
                                                "to_hex_literal",
                                                []
                                              |),
                                              [ M.read (| a |) ]
                                            |)
                                          |)
                                        ]
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::value::MoveValue::Vector",
                        0
                      |) in
                    let v := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_function (|
                          "move_core_types::value::fmt_list",
                          [
                            Ty.apply (Ty.path "&") [ Ty.path "move_core_types::value::MoveValue" ];
                            Ty.apply
                              (Ty.path "&")
                              [
                                Ty.apply
                                  (Ty.path "alloc::vec::Vec")
                                  [
                                    Ty.path "move_core_types::value::MoveValue";
                                    Ty.path "alloc::alloc::Global"
                                  ]
                              ]
                          ]
                        |),
                        [
                          M.read (| f |);
                          M.read (| mk_str "vector[" |);
                          M.read (| v |);
                          M.read (| mk_str "]" |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::value::MoveValue::Struct",
                        0
                      |) in
                    let s := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::fmt::Display",
                          Ty.path "move_core_types::value::MoveStruct",
                          [],
                          "fmt",
                          []
                        |),
                        [ M.read (| s |); M.read (| f |) ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Display"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Display_for_move_core_types_value_MoveValue.
  
  Module Impl_core_fmt_Display_for_move_core_types_value_MoveStruct.
    Definition Self : Ty.t := Ty.path "move_core_types::value::MoveStruct".
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            match self {
                MoveStruct::Runtime(v) => fmt_list(f, "struct[", v, "]"),
                MoveStruct::WithFields(fields) => {
                    fmt_list(f, "{", fields.iter().map(DisplayFieldBinding), "}")
                }
                MoveStruct::WithTypes { type_, fields } => {
                    fmt::Display::fmt(type_, f)?;
                    fmt_list(f, " {", fields.iter().map(DisplayFieldBinding), "}")
                }
            }
        }
    *)
    Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::value::MoveStruct::Runtime",
                        0
                      |) in
                    let v := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_function (|
                          "move_core_types::value::fmt_list",
                          [
                            Ty.apply (Ty.path "&") [ Ty.path "move_core_types::value::MoveValue" ];
                            Ty.apply
                              (Ty.path "&")
                              [
                                Ty.apply
                                  (Ty.path "alloc::vec::Vec")
                                  [
                                    Ty.path "move_core_types::value::MoveValue";
                                    Ty.path "alloc::alloc::Global"
                                  ]
                              ]
                          ]
                        |),
                        [
                          M.read (| f |);
                          M.read (| mk_str "struct[" |);
                          M.read (| v |);
                          M.read (| mk_str "]" |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::value::MoveStruct::WithFields",
                        0
                      |) in
                    let fields := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_function (|
                          "move_core_types::value::fmt_list",
                          [
                            Ty.path "move_core_types::value::DisplayFieldBinding";
                            Ty.apply
                              (Ty.path "core::iter::adapters::map::Map")
                              [
                                Ty.apply
                                  (Ty.path "core::slice::iter::Iter")
                                  [
                                    Ty.tuple
                                      [
                                        Ty.path "move_core_types::identifier::Identifier";
                                        Ty.path "move_core_types::value::MoveValue"
                                      ]
                                  ];
                                Ty.function
                                  [
                                    Ty.apply
                                      (Ty.path "&")
                                      [
                                        Ty.tuple
                                          [
                                            Ty.path "move_core_types::identifier::Identifier";
                                            Ty.path "move_core_types::value::MoveValue"
                                          ]
                                      ]
                                  ]
                                  (Ty.path "move_core_types::value::DisplayFieldBinding")
                              ]
                          ]
                        |),
                        [
                          M.read (| f |);
                          M.read (| mk_str "{" |);
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::iter::traits::iterator::Iterator",
                              Ty.apply
                                (Ty.path "core::slice::iter::Iter")
                                [
                                  Ty.tuple
                                    [
                                      Ty.path "move_core_types::identifier::Identifier";
                                      Ty.path "move_core_types::value::MoveValue"
                                    ]
                                ],
                              [],
                              "map",
                              [
                                Ty.path "move_core_types::value::DisplayFieldBinding";
                                Ty.function
                                  [
                                    Ty.apply
                                      (Ty.path "&")
                                      [
                                        Ty.tuple
                                          [
                                            Ty.path "move_core_types::identifier::Identifier";
                                            Ty.path "move_core_types::value::MoveValue"
                                          ]
                                      ]
                                  ]
                                  (Ty.path "move_core_types::value::DisplayFieldBinding")
                              ]
                            |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "slice")
                                    [
                                      Ty.tuple
                                        [
                                          Ty.path "move_core_types::identifier::Identifier";
                                          Ty.path "move_core_types::value::MoveValue"
                                        ]
                                    ],
                                  "iter",
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::ops::deref::Deref",
                                      Ty.apply
                                        (Ty.path "alloc::vec::Vec")
                                        [
                                          Ty.tuple
                                            [
                                              Ty.path "move_core_types::identifier::Identifier";
                                              Ty.path "move_core_types::value::MoveValue"
                                            ];
                                          Ty.path "alloc::alloc::Global"
                                        ],
                                      [],
                                      "deref",
                                      []
                                    |),
                                    [ M.read (| fields |) ]
                                  |)
                                ]
                              |);
                              M.constructor_as_closure "move_core_types::value::DisplayFieldBinding"
                            ]
                          |);
                          M.read (| mk_str "}" |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_record_field_or_break_match (|
                        γ,
                        "move_core_types::value::MoveStruct::WithTypes",
                        "type_"
                      |) in
                    let γ1_1 :=
                      M.get_struct_record_field_or_break_match (|
                        γ,
                        "move_core_types::value::MoveStruct::WithTypes",
                        "fields"
                      |) in
                    let type_ := M.alloc (| γ1_0 |) in
                    let fields := M.alloc (| γ1_1 |) in
                    let _ :=
                      M.match_operator (|
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::ops::try_trait::Try",
                              Ty.apply
                                (Ty.path "core::result::Result")
                                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                              [],
                              "branch",
                              []
                            |),
                            [
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::fmt::Display",
                                  Ty.path "move_core_types::language_storage::StructTag",
                                  [],
                                  "fmt",
                                  []
                                |),
                                [ M.read (| type_ |); M.read (| f |) ]
                              |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.get_struct_tuple_field_or_break_match (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Break",
                                  0
                                |) in
                              let residual := M.copy (| γ0_0 |) in
                              M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    M.return_ (|
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::ops::try_trait::FromResidual",
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                                          [
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              [
                                                Ty.path "core::convert::Infallible";
                                                Ty.path "core::fmt::Error"
                                              ]
                                          ],
                                          "from_residual",
                                          []
                                        |),
                                        [ M.read (| residual |) ]
                                      |)
                                    |)
                                  |)
                                |)
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.get_struct_tuple_field_or_break_match (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Continue",
                                  0
                                |) in
                              let val := M.copy (| γ0_0 |) in
                              val))
                        ]
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_function (|
                          "move_core_types::value::fmt_list",
                          [
                            Ty.path "move_core_types::value::DisplayFieldBinding";
                            Ty.apply
                              (Ty.path "core::iter::adapters::map::Map")
                              [
                                Ty.apply
                                  (Ty.path "core::slice::iter::Iter")
                                  [
                                    Ty.tuple
                                      [
                                        Ty.path "move_core_types::identifier::Identifier";
                                        Ty.path "move_core_types::value::MoveValue"
                                      ]
                                  ];
                                Ty.function
                                  [
                                    Ty.apply
                                      (Ty.path "&")
                                      [
                                        Ty.tuple
                                          [
                                            Ty.path "move_core_types::identifier::Identifier";
                                            Ty.path "move_core_types::value::MoveValue"
                                          ]
                                      ]
                                  ]
                                  (Ty.path "move_core_types::value::DisplayFieldBinding")
                              ]
                          ]
                        |),
                        [
                          M.read (| f |);
                          M.read (| mk_str " {" |);
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::iter::traits::iterator::Iterator",
                              Ty.apply
                                (Ty.path "core::slice::iter::Iter")
                                [
                                  Ty.tuple
                                    [
                                      Ty.path "move_core_types::identifier::Identifier";
                                      Ty.path "move_core_types::value::MoveValue"
                                    ]
                                ],
                              [],
                              "map",
                              [
                                Ty.path "move_core_types::value::DisplayFieldBinding";
                                Ty.function
                                  [
                                    Ty.apply
                                      (Ty.path "&")
                                      [
                                        Ty.tuple
                                          [
                                            Ty.path "move_core_types::identifier::Identifier";
                                            Ty.path "move_core_types::value::MoveValue"
                                          ]
                                      ]
                                  ]
                                  (Ty.path "move_core_types::value::DisplayFieldBinding")
                              ]
                            |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "slice")
                                    [
                                      Ty.tuple
                                        [
                                          Ty.path "move_core_types::identifier::Identifier";
                                          Ty.path "move_core_types::value::MoveValue"
                                        ]
                                    ],
                                  "iter",
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::ops::deref::Deref",
                                      Ty.apply
                                        (Ty.path "alloc::vec::Vec")
                                        [
                                          Ty.tuple
                                            [
                                              Ty.path "move_core_types::identifier::Identifier";
                                              Ty.path "move_core_types::value::MoveValue"
                                            ];
                                          Ty.path "alloc::alloc::Global"
                                        ],
                                      [],
                                      "deref",
                                      []
                                    |),
                                    [ M.read (| fields |) ]
                                  |)
                                ]
                              |);
                              M.constructor_as_closure "move_core_types::value::DisplayFieldBinding"
                            ]
                          |);
                          M.read (| mk_str "}" |)
                        ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Display"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Display_for_move_core_types_value_MoveStruct.
  
  (* StructTuple
    {
      name := "DisplayFieldBinding";
      ty_params := [];
      fields :=
        [
          Ty.apply
            (Ty.path "&")
            [
              Ty.tuple
                [
                  Ty.path "move_core_types::identifier::Identifier";
                  Ty.path "move_core_types::value::MoveValue"
                ]
            ]
        ];
    } *)
  
  Module Impl_core_fmt_Display_for_move_core_types_value_DisplayFieldBinding.
    Definition Self : Ty.t := Ty.path "move_core_types::value::DisplayFieldBinding".
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            let DisplayFieldBinding((field, value)) = self;
            write!(f, "{}: {}", field, value)
        }
    *)
    Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::value::DisplayFieldBinding",
                        0
                      |) in
                    let γ1_0 := M.read (| γ1_0 |) in
                    let γ3_0 := M.get_tuple_field γ1_0 0 in
                    let γ3_1 := M.get_tuple_field γ1_0 1 in
                    let field := M.alloc (| γ3_0 |) in
                    let value := M.alloc (| γ3_1 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_v1",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array [ M.read (| mk_str "" |); M.read (| mk_str ": " |) ]
                                |));
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.path "core::fmt::rt::Argument",
                                          "new_display",
                                          [
                                            Ty.apply
                                              (Ty.path "&")
                                              [ Ty.path "move_core_types::identifier::Identifier" ]
                                          ]
                                        |),
                                        [ field ]
                                      |);
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.path "core::fmt::rt::Argument",
                                          "new_display",
                                          [
                                            Ty.apply
                                              (Ty.path "&")
                                              [ Ty.path "move_core_types::value::MoveValue" ]
                                          ]
                                        |),
                                        [ value ]
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Display"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Display_for_move_core_types_value_DisplayFieldBinding.
  
  (*
  fn fmt_list<T: fmt::Display>(
      f: &mut fmt::Formatter<'_>,
      begin: &str,
      items: impl IntoIterator<Item = T>,
      end: &str,
  ) -> fmt::Result {
      write!(f, "{}", begin)?;
      let mut items = items.into_iter();
      if let Some(x) = items.next() {
          write!(f, "{}", x)?;
          for x in items {
              write!(f, ", {}", x)?;
          }
      }
      write!(f, "{}", end)?;
      Ok(())
  }
  *)
  Definition fmt_list (τ : list Ty.t) (α : list Value.t) : M :=
    match τ, α with
    | [ T; impl_IntoIterator_Item___T_ ], [ f; begin; items; end_ ] =>
      ltac:(M.monadic
        (let f := M.alloc (| f |) in
        let begin := M.alloc (| begin |) in
        let items := M.alloc (| items |) in
        let end_ := M.alloc (| end_ |) in
        M.read (|
          let _ :=
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "core::ops::try_trait::Try",
                    Ty.apply
                      (Ty.path "core::result::Result")
                      [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                    [],
                    "branch",
                    []
                  |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::fmt::Formatter",
                        "write_fmt",
                        []
                      |),
                      [
                        M.read (| f |);
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.path "core::fmt::Arguments",
                            "new_v1",
                            []
                          |),
                          [
                            (* Unsize *)
                            M.pointer_coercion
                              (M.alloc (| Value.Array [ M.read (| mk_str "" |) ] |));
                            (* Unsize *)
                            M.pointer_coercion
                              (M.alloc (|
                                Value.Array
                                  [
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.path "core::fmt::rt::Argument",
                                        "new_display",
                                        [ Ty.apply (Ty.path "&") [ Ty.path "str" ] ]
                                      |),
                                      [ begin ]
                                    |)
                                  ]
                              |))
                          ]
                        |)
                      ]
                    |)
                  ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "core::ops::control_flow::ControlFlow::Break",
                        0
                      |) in
                    let residual := M.copy (| γ0_0 |) in
                    M.alloc (|
                      M.never_to_any (|
                        M.read (|
                          M.return_ (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::ops::try_trait::FromResidual",
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                                [
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    [
                                      Ty.path "core::convert::Infallible";
                                      Ty.path "core::fmt::Error"
                                    ]
                                ],
                                "from_residual",
                                []
                              |),
                              [ M.read (| residual |) ]
                            |)
                          |)
                        |)
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "core::ops::control_flow::ControlFlow::Continue",
                        0
                      |) in
                    let val := M.copy (| γ0_0 |) in
                    val))
              ]
            |) in
          let items :=
            M.alloc (|
              M.call_closure (|
                M.get_trait_method (|
                  "core::iter::traits::collect::IntoIterator",
                  impl_IntoIterator_Item___T_,
                  [],
                  "into_iter",
                  []
                |),
                [ M.read (| items |) ]
              |)
            |) in
          let _ :=
            M.match_operator (|
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::iter::traits::iterator::Iterator",
                            Ty.associated,
                            [],
                            "next",
                            []
                          |),
                          [ items ]
                        |)
                      |) in
                    let γ0_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let x := M.copy (| γ0_0 |) in
                    let _ :=
                      M.match_operator (|
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::ops::try_trait::Try",
                              Ty.apply
                                (Ty.path "core::result::Result")
                                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                              [],
                              "branch",
                              []
                            |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::fmt::Formatter",
                                  "write_fmt",
                                  []
                                |),
                                [
                                  M.read (| f |);
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.path "core::fmt::Arguments",
                                      "new_v1",
                                      []
                                    |),
                                    [
                                      (* Unsize *)
                                      M.pointer_coercion
                                        (M.alloc (| Value.Array [ M.read (| mk_str "" |) ] |));
                                      (* Unsize *)
                                      M.pointer_coercion
                                        (M.alloc (|
                                          Value.Array
                                            [
                                              M.call_closure (|
                                                M.get_associated_function (|
                                                  Ty.path "core::fmt::rt::Argument",
                                                  "new_display",
                                                  [ T ]
                                                |),
                                                [ x ]
                                              |)
                                            ]
                                        |))
                                    ]
                                  |)
                                ]
                              |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.get_struct_tuple_field_or_break_match (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Break",
                                  0
                                |) in
                              let residual := M.copy (| γ0_0 |) in
                              M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    M.return_ (|
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::ops::try_trait::FromResidual",
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                                          [
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              [
                                                Ty.path "core::convert::Infallible";
                                                Ty.path "core::fmt::Error"
                                              ]
                                          ],
                                          "from_residual",
                                          []
                                        |),
                                        [ M.read (| residual |) ]
                                      |)
                                    |)
                                  |)
                                |)
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.get_struct_tuple_field_or_break_match (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Continue",
                                  0
                                |) in
                              let val := M.copy (| γ0_0 |) in
                              val))
                        ]
                      |) in
                    M.use
                      (M.match_operator (|
                        M.alloc (|
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::iter::traits::collect::IntoIterator",
                              Ty.associated,
                              [],
                              "into_iter",
                              []
                            |),
                            [ M.read (| items |) ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let iter := M.copy (| γ |) in
                              M.loop (|
                                ltac:(M.monadic
                                  (let _ :=
                                    M.match_operator (|
                                      M.alloc (|
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::iter::traits::iterator::Iterator",
                                            Ty.associated,
                                            [],
                                            "next",
                                            []
                                          |),
                                          [ iter ]
                                        |)
                                      |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (M.alloc (|
                                              M.never_to_any (| M.read (| M.break (||) |) |)
                                            |)));
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.get_struct_tuple_field_or_break_match (|
                                                γ,
                                                "core::option::Option::Some",
                                                0
                                              |) in
                                            let x := M.copy (| γ0_0 |) in
                                            let _ :=
                                              M.match_operator (|
                                                M.alloc (|
                                                  M.call_closure (|
                                                    M.get_trait_method (|
                                                      "core::ops::try_trait::Try",
                                                      Ty.apply
                                                        (Ty.path "core::result::Result")
                                                        [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                                                      [],
                                                      "branch",
                                                      []
                                                    |),
                                                    [
                                                      M.call_closure (|
                                                        M.get_associated_function (|
                                                          Ty.path "core::fmt::Formatter",
                                                          "write_fmt",
                                                          []
                                                        |),
                                                        [
                                                          M.read (| f |);
                                                          M.call_closure (|
                                                            M.get_associated_function (|
                                                              Ty.path "core::fmt::Arguments",
                                                              "new_v1",
                                                              []
                                                            |),
                                                            [
                                                              (* Unsize *)
                                                              M.pointer_coercion
                                                                (M.alloc (|
                                                                  Value.Array
                                                                    [ M.read (| mk_str ", " |) ]
                                                                |));
                                                              (* Unsize *)
                                                              M.pointer_coercion
                                                                (M.alloc (|
                                                                  Value.Array
                                                                    [
                                                                      M.call_closure (|
                                                                        M.get_associated_function (|
                                                                          Ty.path
                                                                            "core::fmt::rt::Argument",
                                                                          "new_display",
                                                                          [ T ]
                                                                        |),
                                                                        [ x ]
                                                                      |)
                                                                    ]
                                                                |))
                                                            ]
                                                          |)
                                                        ]
                                                      |)
                                                    ]
                                                  |)
                                                |),
                                                [
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (let γ0_0 :=
                                                        M.get_struct_tuple_field_or_break_match (|
                                                          γ,
                                                          "core::ops::control_flow::ControlFlow::Break",
                                                          0
                                                        |) in
                                                      let residual := M.copy (| γ0_0 |) in
                                                      M.alloc (|
                                                        M.never_to_any (|
                                                          M.read (|
                                                            M.return_ (|
                                                              M.call_closure (|
                                                                M.get_trait_method (|
                                                                  "core::ops::try_trait::FromResidual",
                                                                  Ty.apply
                                                                    (Ty.path "core::result::Result")
                                                                    [
                                                                      Ty.tuple [];
                                                                      Ty.path "core::fmt::Error"
                                                                    ],
                                                                  [
                                                                    Ty.apply
                                                                      (Ty.path
                                                                        "core::result::Result")
                                                                      [
                                                                        Ty.path
                                                                          "core::convert::Infallible";
                                                                        Ty.path "core::fmt::Error"
                                                                      ]
                                                                  ],
                                                                  "from_residual",
                                                                  []
                                                                |),
                                                                [ M.read (| residual |) ]
                                                              |)
                                                            |)
                                                          |)
                                                        |)
                                                      |)));
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (let γ0_0 :=
                                                        M.get_struct_tuple_field_or_break_match (|
                                                          γ,
                                                          "core::ops::control_flow::ControlFlow::Continue",
                                                          0
                                                        |) in
                                                      let val := M.copy (| γ0_0 |) in
                                                      val))
                                                ]
                                              |) in
                                            M.alloc (| Value.Tuple [] |)))
                                      ]
                                    |) in
                                  M.alloc (| Value.Tuple [] |)))
                              |)))
                        ]
                      |))));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
              ]
            |) in
          let _ :=
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "core::ops::try_trait::Try",
                    Ty.apply
                      (Ty.path "core::result::Result")
                      [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                    [],
                    "branch",
                    []
                  |),
                  [
                    M.call_closure (|
                      M.get_associated_function (|
                        Ty.path "core::fmt::Formatter",
                        "write_fmt",
                        []
                      |),
                      [
                        M.read (| f |);
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.path "core::fmt::Arguments",
                            "new_v1",
                            []
                          |),
                          [
                            (* Unsize *)
                            M.pointer_coercion
                              (M.alloc (| Value.Array [ M.read (| mk_str "" |) ] |));
                            (* Unsize *)
                            M.pointer_coercion
                              (M.alloc (|
                                Value.Array
                                  [
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.path "core::fmt::rt::Argument",
                                        "new_display",
                                        [ Ty.apply (Ty.path "&") [ Ty.path "str" ] ]
                                      |),
                                      [ end_ ]
                                    |)
                                  ]
                              |))
                          ]
                        |)
                      ]
                    |)
                  ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "core::ops::control_flow::ControlFlow::Break",
                        0
                      |) in
                    let residual := M.copy (| γ0_0 |) in
                    M.alloc (|
                      M.never_to_any (|
                        M.read (|
                          M.return_ (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::ops::try_trait::FromResidual",
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                                [
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    [
                                      Ty.path "core::convert::Infallible";
                                      Ty.path "core::fmt::Error"
                                    ]
                                ],
                                "from_residual",
                                []
                              |),
                              [ M.read (| residual |) ]
                            |)
                          |)
                        |)
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "core::ops::control_flow::ControlFlow::Continue",
                        0
                      |) in
                    let val := M.copy (| γ0_0 |) in
                    val))
              ]
            |) in
          M.alloc (| Value.StructTuple "core::result::Result::Ok" [ Value.Tuple [] ] |)
        |)))
    | _, _ => M.impossible
    end.
End value.

Module vm_status.
  Definition value_VALIDATION_STATUS_MIN_CODE : Value.t :=
    M.run ltac:(M.monadic (M.alloc (| M.alloc (| Value.Integer Integer.U64 0 |) |))).
  
  Definition value_VALIDATION_STATUS_MAX_CODE : Value.t :=
    M.run ltac:(M.monadic (M.alloc (| M.alloc (| Value.Integer Integer.U64 999 |) |))).
  
  Definition value_VERIFICATION_STATUS_MIN_CODE : Value.t :=
    M.run ltac:(M.monadic (M.alloc (| M.alloc (| Value.Integer Integer.U64 1000 |) |))).
  
  Definition value_VERIFICATION_STATUS_MAX_CODE : Value.t :=
    M.run ltac:(M.monadic (M.alloc (| M.alloc (| Value.Integer Integer.U64 1999 |) |))).
  
  Definition value_INVARIANT_VIOLATION_STATUS_MIN_CODE : Value.t :=
    M.run ltac:(M.monadic (M.alloc (| M.alloc (| Value.Integer Integer.U64 2000 |) |))).
  
  Definition value_INVARIANT_VIOLATION_STATUS_MAX_CODE : Value.t :=
    M.run ltac:(M.monadic (M.alloc (| M.alloc (| Value.Integer Integer.U64 2999 |) |))).
  
  Definition value_DESERIALIZATION_STATUS_MIN_CODE : Value.t :=
    M.run ltac:(M.monadic (M.alloc (| M.alloc (| Value.Integer Integer.U64 3000 |) |))).
  
  Definition value_DESERIALIZATION_STATUS_MAX_CODE : Value.t :=
    M.run ltac:(M.monadic (M.alloc (| M.alloc (| Value.Integer Integer.U64 3999 |) |))).
  
  Definition value_EXECUTION_STATUS_MIN_CODE : Value.t :=
    M.run ltac:(M.monadic (M.alloc (| M.alloc (| Value.Integer Integer.U64 4000 |) |))).
  
  Definition value_EXECUTION_STATUS_MAX_CODE : Value.t :=
    M.run ltac:(M.monadic (M.alloc (| M.alloc (| Value.Integer Integer.U64 4999 |) |))).
  
  (*
  Enum VMStatus
  {
    ty_params := [];
    variants :=
      [
        {
          name := "Executed";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "Error";
          item := StructTuple [ Ty.path "move_core_types::vm_status::StatusCode" ];
          discriminant := None;
        };
        {
          name := "MoveAbort";
          item :=
            StructTuple [ Ty.path "move_core_types::vm_status::AbortLocation"; Ty.path "u64" ];
          discriminant := None;
        };
        {
          name := "ExecutionFailure";
          item :=
            StructRecord
              [
                ("status_code", Ty.path "move_core_types::vm_status::StatusCode");
                ("location", Ty.path "move_core_types::vm_status::AbortLocation");
                ("function", Ty.path "u16");
                ("code_offset", Ty.path "u16")
              ];
          discriminant := None;
        }
      ];
  }
  *)
  
  Module Impl_core_clone_Clone_for_move_core_types_vm_status_VMStatus.
    Definition Self : Ty.t := Ty.path "move_core_types::vm_status::VMStatus".
    
    (* Clone *)
    Definition clone (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (|
                      Value.StructTuple "move_core_types::vm_status::VMStatus::Executed" []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::vm_status::VMStatus::Error",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_core_types::vm_status::VMStatus::Error"
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.path "move_core_types::vm_status::StatusCode",
                              [],
                              "clone",
                              []
                            |),
                            [ M.read (| __self_0 |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::vm_status::VMStatus::MoveAbort",
                        0
                      |) in
                    let γ1_1 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::vm_status::VMStatus::MoveAbort",
                        1
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    let __self_1 := M.alloc (| γ1_1 |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_core_types::vm_status::VMStatus::MoveAbort"
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.path "move_core_types::vm_status::AbortLocation",
                              [],
                              "clone",
                              []
                            |),
                            [ M.read (| __self_0 |) ]
                          |);
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.path "u64",
                              [],
                              "clone",
                              []
                            |),
                            [ M.read (| __self_1 |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_record_field_or_break_match (|
                        γ,
                        "move_core_types::vm_status::VMStatus::ExecutionFailure",
                        "status_code"
                      |) in
                    let γ1_1 :=
                      M.get_struct_record_field_or_break_match (|
                        γ,
                        "move_core_types::vm_status::VMStatus::ExecutionFailure",
                        "location"
                      |) in
                    let γ1_2 :=
                      M.get_struct_record_field_or_break_match (|
                        γ,
                        "move_core_types::vm_status::VMStatus::ExecutionFailure",
                        "function"
                      |) in
                    let γ1_3 :=
                      M.get_struct_record_field_or_break_match (|
                        γ,
                        "move_core_types::vm_status::VMStatus::ExecutionFailure",
                        "code_offset"
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    let __self_1 := M.alloc (| γ1_1 |) in
                    let __self_2 := M.alloc (| γ1_2 |) in
                    let __self_3 := M.alloc (| γ1_3 |) in
                    M.alloc (|
                      Value.StructRecord
                        "move_core_types::vm_status::VMStatus::ExecutionFailure"
                        [
                          ("status_code",
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::clone::Clone",
                                Ty.path "move_core_types::vm_status::StatusCode",
                                [],
                                "clone",
                                []
                              |),
                              [ M.read (| __self_0 |) ]
                            |));
                          ("location",
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::clone::Clone",
                                Ty.path "move_core_types::vm_status::AbortLocation",
                                [],
                                "clone",
                                []
                              |),
                              [ M.read (| __self_1 |) ]
                            |));
                          ("function",
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::clone::Clone",
                                Ty.path "u16",
                                [],
                                "clone",
                                []
                              |),
                              [ M.read (| __self_2 |) ]
                            |));
                          ("code_offset",
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::clone::Clone",
                                Ty.path "u16",
                                [],
                                "clone",
                                []
                              |),
                              [ M.read (| __self_3 |) ]
                            |))
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_move_core_types_vm_status_VMStatus.
  
  Module Impl_core_marker_StructuralPartialEq_for_move_core_types_vm_status_VMStatus.
    Definition Self : Ty.t := Ty.path "move_core_types::vm_status::VMStatus".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_move_core_types_vm_status_VMStatus.
  
  Module Impl_core_cmp_PartialEq_for_move_core_types_vm_status_VMStatus.
    Definition Self : Ty.t := Ty.path "move_core_types::vm_status::VMStatus".
    
    (* PartialEq *)
    Definition eq (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            let __self_tag :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [ Ty.path "move_core_types::vm_status::VMStatus" ]
                  |),
                  [ M.read (| self |) ]
                |)
              |) in
            let __arg1_tag :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [ Ty.path "move_core_types::vm_status::VMStatus" ]
                  |),
                  [ M.read (| other |) ]
                |)
              |) in
            M.alloc (|
              LogicalOp.and (|
                BinOp.Pure.eq (M.read (| __self_tag |)) (M.read (| __arg1_tag |)),
                ltac:(M.monadic
                  (M.read (|
                    M.match_operator (|
                      M.alloc (| Value.Tuple [ M.read (| self |); M.read (| other |) ] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.get_tuple_field γ 0 in
                            let γ0_1 := M.get_tuple_field γ 1 in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ0_0,
                                "move_core_types::vm_status::VMStatus::Error",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ0_1,
                                "move_core_types::vm_status::VMStatus::Error",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.path "move_core_types::vm_status::StatusCode",
                                  [ Ty.path "move_core_types::vm_status::StatusCode" ],
                                  "eq",
                                  []
                                |),
                                [ M.read (| __self_0 |); M.read (| __arg1_0 |) ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.get_tuple_field γ 0 in
                            let γ0_1 := M.get_tuple_field γ 1 in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ0_0,
                                "move_core_types::vm_status::VMStatus::MoveAbort",
                                0
                              |) in
                            let γ2_1 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ0_0,
                                "move_core_types::vm_status::VMStatus::MoveAbort",
                                1
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let __self_1 := M.alloc (| γ2_1 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ0_1,
                                "move_core_types::vm_status::VMStatus::MoveAbort",
                                0
                              |) in
                            let γ2_1 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ0_1,
                                "move_core_types::vm_status::VMStatus::MoveAbort",
                                1
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            let __arg1_1 := M.alloc (| γ2_1 |) in
                            M.alloc (|
                              LogicalOp.and (|
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::cmp::PartialEq",
                                    Ty.path "move_core_types::vm_status::AbortLocation",
                                    [ Ty.path "move_core_types::vm_status::AbortLocation" ],
                                    "eq",
                                    []
                                  |),
                                  [ M.read (| __self_0 |); M.read (| __arg1_0 |) ]
                                |),
                                ltac:(M.monadic
                                  (BinOp.Pure.eq
                                    (M.read (| M.read (| __self_1 |) |))
                                    (M.read (| M.read (| __arg1_1 |) |))))
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.get_tuple_field γ 0 in
                            let γ0_1 := M.get_tuple_field γ 1 in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.get_struct_record_field_or_break_match (|
                                γ0_0,
                                "move_core_types::vm_status::VMStatus::ExecutionFailure",
                                "status_code"
                              |) in
                            let γ2_1 :=
                              M.get_struct_record_field_or_break_match (|
                                γ0_0,
                                "move_core_types::vm_status::VMStatus::ExecutionFailure",
                                "location"
                              |) in
                            let γ2_2 :=
                              M.get_struct_record_field_or_break_match (|
                                γ0_0,
                                "move_core_types::vm_status::VMStatus::ExecutionFailure",
                                "function"
                              |) in
                            let γ2_3 :=
                              M.get_struct_record_field_or_break_match (|
                                γ0_0,
                                "move_core_types::vm_status::VMStatus::ExecutionFailure",
                                "code_offset"
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let __self_1 := M.alloc (| γ2_1 |) in
                            let __self_2 := M.alloc (| γ2_2 |) in
                            let __self_3 := M.alloc (| γ2_3 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.get_struct_record_field_or_break_match (|
                                γ0_1,
                                "move_core_types::vm_status::VMStatus::ExecutionFailure",
                                "status_code"
                              |) in
                            let γ2_1 :=
                              M.get_struct_record_field_or_break_match (|
                                γ0_1,
                                "move_core_types::vm_status::VMStatus::ExecutionFailure",
                                "location"
                              |) in
                            let γ2_2 :=
                              M.get_struct_record_field_or_break_match (|
                                γ0_1,
                                "move_core_types::vm_status::VMStatus::ExecutionFailure",
                                "function"
                              |) in
                            let γ2_3 :=
                              M.get_struct_record_field_or_break_match (|
                                γ0_1,
                                "move_core_types::vm_status::VMStatus::ExecutionFailure",
                                "code_offset"
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            let __arg1_1 := M.alloc (| γ2_1 |) in
                            let __arg1_2 := M.alloc (| γ2_2 |) in
                            let __arg1_3 := M.alloc (| γ2_3 |) in
                            M.alloc (|
                              LogicalOp.and (|
                                LogicalOp.and (|
                                  LogicalOp.and (|
                                    M.call_closure (|
                                      M.get_trait_method (|
                                        "core::cmp::PartialEq",
                                        Ty.path "move_core_types::vm_status::StatusCode",
                                        [ Ty.path "move_core_types::vm_status::StatusCode" ],
                                        "eq",
                                        []
                                      |),
                                      [ M.read (| __self_0 |); M.read (| __arg1_0 |) ]
                                    |),
                                    ltac:(M.monadic
                                      (M.call_closure (|
                                        M.get_trait_method (|
                                          "core::cmp::PartialEq",
                                          Ty.path "move_core_types::vm_status::AbortLocation",
                                          [ Ty.path "move_core_types::vm_status::AbortLocation" ],
                                          "eq",
                                          []
                                        |),
                                        [ M.read (| __self_1 |); M.read (| __arg1_1 |) ]
                                      |)))
                                  |),
                                  ltac:(M.monadic
                                    (BinOp.Pure.eq
                                      (M.read (| M.read (| __self_2 |) |))
                                      (M.read (| M.read (| __arg1_2 |) |))))
                                |),
                                ltac:(M.monadic
                                  (BinOp.Pure.eq
                                    (M.read (| M.read (| __self_3 |) |))
                                    (M.read (| M.read (| __arg1_3 |) |))))
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Bool true |)))
                      ]
                    |)
                  |)))
              |)
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_for_move_core_types_vm_status_VMStatus.
  
  Module Impl_core_marker_StructuralEq_for_move_core_types_vm_status_VMStatus.
    Definition Self : Ty.t := Ty.path "move_core_types::vm_status::VMStatus".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralEq_for_move_core_types_vm_status_VMStatus.
  
  Module Impl_core_cmp_Eq_for_move_core_types_vm_status_VMStatus.
    Definition Self : Ty.t := Ty.path "move_core_types::vm_status::VMStatus".
    
    (* Eq *)
    Definition assert_receiver_is_total_eq (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Value.DeclaredButUndefined,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      Value.DeclaredButUndefined,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              Value.DeclaredButUndefined,
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (M.match_operator (|
                                      Value.DeclaredButUndefined,
                                      [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                                    |)))
                              ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_move_core_types_vm_status_VMStatus.
  
  Module Impl_core_cmp_PartialOrd_for_move_core_types_vm_status_VMStatus.
    Definition Self : Ty.t := Ty.path "move_core_types::vm_status::VMStatus".
    
    (* PartialOrd *)
    Definition partial_cmp (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            let __self_tag :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [ Ty.path "move_core_types::vm_status::VMStatus" ]
                  |),
                  [ M.read (| self |) ]
                |)
              |) in
            let __arg1_tag :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [ Ty.path "move_core_types::vm_status::VMStatus" ]
                  |),
                  [ M.read (| other |) ]
                |)
              |) in
            M.match_operator (|
              M.alloc (| Value.Tuple [ M.read (| self |); M.read (| other |) ] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.get_tuple_field γ 0 in
                    let γ0_1 := M.get_tuple_field γ 1 in
                    let γ0_0 := M.read (| γ0_0 |) in
                    let γ2_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ0_0,
                        "move_core_types::vm_status::VMStatus::Error",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ2_0 |) in
                    let γ0_1 := M.read (| γ0_1 |) in
                    let γ2_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ0_1,
                        "move_core_types::vm_status::VMStatus::Error",
                        0
                      |) in
                    let __arg1_0 := M.alloc (| γ2_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::cmp::PartialOrd",
                          Ty.path "move_core_types::vm_status::StatusCode",
                          [ Ty.path "move_core_types::vm_status::StatusCode" ],
                          "partial_cmp",
                          []
                        |),
                        [ M.read (| __self_0 |); M.read (| __arg1_0 |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.get_tuple_field γ 0 in
                    let γ0_1 := M.get_tuple_field γ 1 in
                    let γ0_0 := M.read (| γ0_0 |) in
                    let γ2_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ0_0,
                        "move_core_types::vm_status::VMStatus::MoveAbort",
                        0
                      |) in
                    let γ2_1 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ0_0,
                        "move_core_types::vm_status::VMStatus::MoveAbort",
                        1
                      |) in
                    let __self_0 := M.alloc (| γ2_0 |) in
                    let __self_1 := M.alloc (| γ2_1 |) in
                    let γ0_1 := M.read (| γ0_1 |) in
                    let γ2_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ0_1,
                        "move_core_types::vm_status::VMStatus::MoveAbort",
                        0
                      |) in
                    let γ2_1 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ0_1,
                        "move_core_types::vm_status::VMStatus::MoveAbort",
                        1
                      |) in
                    let __arg1_0 := M.alloc (| γ2_0 |) in
                    let __arg1_1 := M.alloc (| γ2_1 |) in
                    M.match_operator (|
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::cmp::PartialOrd",
                            Ty.path "move_core_types::vm_status::AbortLocation",
                            [ Ty.path "move_core_types::vm_status::AbortLocation" ],
                            "partial_cmp",
                            []
                          |),
                          [ M.read (| __self_0 |); M.read (| __arg1_0 |) ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ,
                                "core::option::Option::Some",
                                0
                              |) in
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::cmp::PartialOrd",
                                  Ty.path "u64",
                                  [ Ty.path "u64" ],
                                  "partial_cmp",
                                  []
                                |),
                                [ M.read (| __self_1 |); M.read (| __arg1_1 |) ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let cmp := M.copy (| γ |) in
                            cmp))
                      ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.get_tuple_field γ 0 in
                    let γ0_1 := M.get_tuple_field γ 1 in
                    let γ0_0 := M.read (| γ0_0 |) in
                    let γ2_0 :=
                      M.get_struct_record_field_or_break_match (|
                        γ0_0,
                        "move_core_types::vm_status::VMStatus::ExecutionFailure",
                        "status_code"
                      |) in
                    let γ2_1 :=
                      M.get_struct_record_field_or_break_match (|
                        γ0_0,
                        "move_core_types::vm_status::VMStatus::ExecutionFailure",
                        "location"
                      |) in
                    let γ2_2 :=
                      M.get_struct_record_field_or_break_match (|
                        γ0_0,
                        "move_core_types::vm_status::VMStatus::ExecutionFailure",
                        "function"
                      |) in
                    let γ2_3 :=
                      M.get_struct_record_field_or_break_match (|
                        γ0_0,
                        "move_core_types::vm_status::VMStatus::ExecutionFailure",
                        "code_offset"
                      |) in
                    let __self_0 := M.alloc (| γ2_0 |) in
                    let __self_1 := M.alloc (| γ2_1 |) in
                    let __self_2 := M.alloc (| γ2_2 |) in
                    let __self_3 := M.alloc (| γ2_3 |) in
                    let γ0_1 := M.read (| γ0_1 |) in
                    let γ2_0 :=
                      M.get_struct_record_field_or_break_match (|
                        γ0_1,
                        "move_core_types::vm_status::VMStatus::ExecutionFailure",
                        "status_code"
                      |) in
                    let γ2_1 :=
                      M.get_struct_record_field_or_break_match (|
                        γ0_1,
                        "move_core_types::vm_status::VMStatus::ExecutionFailure",
                        "location"
                      |) in
                    let γ2_2 :=
                      M.get_struct_record_field_or_break_match (|
                        γ0_1,
                        "move_core_types::vm_status::VMStatus::ExecutionFailure",
                        "function"
                      |) in
                    let γ2_3 :=
                      M.get_struct_record_field_or_break_match (|
                        γ0_1,
                        "move_core_types::vm_status::VMStatus::ExecutionFailure",
                        "code_offset"
                      |) in
                    let __arg1_0 := M.alloc (| γ2_0 |) in
                    let __arg1_1 := M.alloc (| γ2_1 |) in
                    let __arg1_2 := M.alloc (| γ2_2 |) in
                    let __arg1_3 := M.alloc (| γ2_3 |) in
                    M.match_operator (|
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::cmp::PartialOrd",
                            Ty.path "move_core_types::vm_status::StatusCode",
                            [ Ty.path "move_core_types::vm_status::StatusCode" ],
                            "partial_cmp",
                            []
                          |),
                          [ M.read (| __self_0 |); M.read (| __arg1_0 |) ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ,
                                "core::option::Option::Some",
                                0
                              |) in
                            M.match_operator (|
                              M.alloc (|
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::cmp::PartialOrd",
                                    Ty.path "move_core_types::vm_status::AbortLocation",
                                    [ Ty.path "move_core_types::vm_status::AbortLocation" ],
                                    "partial_cmp",
                                    []
                                  |),
                                  [ M.read (| __self_1 |); M.read (| __arg1_1 |) ]
                                |)
                              |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ0_0 :=
                                      M.get_struct_tuple_field_or_break_match (|
                                        γ,
                                        "core::option::Option::Some",
                                        0
                                      |) in
                                    M.match_operator (|
                                      M.alloc (|
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::cmp::PartialOrd",
                                            Ty.path "u16",
                                            [ Ty.path "u16" ],
                                            "partial_cmp",
                                            []
                                          |),
                                          [ M.read (| __self_2 |); M.read (| __arg1_2 |) ]
                                        |)
                                      |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.get_struct_tuple_field_or_break_match (|
                                                γ,
                                                "core::option::Option::Some",
                                                0
                                              |) in
                                            M.alloc (|
                                              M.call_closure (|
                                                M.get_trait_method (|
                                                  "core::cmp::PartialOrd",
                                                  Ty.path "u16",
                                                  [ Ty.path "u16" ],
                                                  "partial_cmp",
                                                  []
                                                |),
                                                [ M.read (| __self_3 |); M.read (| __arg1_3 |) ]
                                              |)
                                            |)));
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let cmp := M.copy (| γ |) in
                                            cmp))
                                      ]
                                    |)));
                                fun γ =>
                                  ltac:(M.monadic
                                    (let cmp := M.copy (| γ |) in
                                    cmp))
                              ]
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let cmp := M.copy (| γ |) in
                            cmp))
                      ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::cmp::PartialOrd",
                          Ty.path "isize",
                          [ Ty.path "isize" ],
                          "partial_cmp",
                          []
                        |),
                        [ __self_tag; __arg1_tag ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialOrd"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("partial_cmp", InstanceField.Method partial_cmp) ].
  End Impl_core_cmp_PartialOrd_for_move_core_types_vm_status_VMStatus.
  
  Module Impl_core_cmp_Ord_for_move_core_types_vm_status_VMStatus.
    Definition Self : Ty.t := Ty.path "move_core_types::vm_status::VMStatus".
    
    (* Ord *)
    Definition cmp (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            let __self_tag :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [ Ty.path "move_core_types::vm_status::VMStatus" ]
                  |),
                  [ M.read (| self |) ]
                |)
              |) in
            let __arg1_tag :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [ Ty.path "move_core_types::vm_status::VMStatus" ]
                  |),
                  [ M.read (| other |) ]
                |)
              |) in
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (| "core::cmp::Ord", Ty.path "isize", [], "cmp", [] |),
                  [ __self_tag; __arg1_tag ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      M.alloc (| Value.Tuple [ M.read (| self |); M.read (| other |) ] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.get_tuple_field γ 0 in
                            let γ0_1 := M.get_tuple_field γ 1 in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ0_0,
                                "move_core_types::vm_status::VMStatus::Error",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ0_1,
                                "move_core_types::vm_status::VMStatus::Error",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::cmp::Ord",
                                  Ty.path "move_core_types::vm_status::StatusCode",
                                  [],
                                  "cmp",
                                  []
                                |),
                                [ M.read (| __self_0 |); M.read (| __arg1_0 |) ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.get_tuple_field γ 0 in
                            let γ0_1 := M.get_tuple_field γ 1 in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ0_0,
                                "move_core_types::vm_status::VMStatus::MoveAbort",
                                0
                              |) in
                            let γ2_1 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ0_0,
                                "move_core_types::vm_status::VMStatus::MoveAbort",
                                1
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let __self_1 := M.alloc (| γ2_1 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ0_1,
                                "move_core_types::vm_status::VMStatus::MoveAbort",
                                0
                              |) in
                            let γ2_1 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ0_1,
                                "move_core_types::vm_status::VMStatus::MoveAbort",
                                1
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            let __arg1_1 := M.alloc (| γ2_1 |) in
                            M.match_operator (|
                              M.alloc (|
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::cmp::Ord",
                                    Ty.path "move_core_types::vm_status::AbortLocation",
                                    [],
                                    "cmp",
                                    []
                                  |),
                                  [ M.read (| __self_0 |); M.read (| __arg1_0 |) ]
                                |)
                              |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (M.alloc (|
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::cmp::Ord",
                                          Ty.path "u64",
                                          [],
                                          "cmp",
                                          []
                                        |),
                                        [ M.read (| __self_1 |); M.read (| __arg1_1 |) ]
                                      |)
                                    |)));
                                fun γ =>
                                  ltac:(M.monadic
                                    (let cmp := M.copy (| γ |) in
                                    cmp))
                              ]
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.get_tuple_field γ 0 in
                            let γ0_1 := M.get_tuple_field γ 1 in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.get_struct_record_field_or_break_match (|
                                γ0_0,
                                "move_core_types::vm_status::VMStatus::ExecutionFailure",
                                "status_code"
                              |) in
                            let γ2_1 :=
                              M.get_struct_record_field_or_break_match (|
                                γ0_0,
                                "move_core_types::vm_status::VMStatus::ExecutionFailure",
                                "location"
                              |) in
                            let γ2_2 :=
                              M.get_struct_record_field_or_break_match (|
                                γ0_0,
                                "move_core_types::vm_status::VMStatus::ExecutionFailure",
                                "function"
                              |) in
                            let γ2_3 :=
                              M.get_struct_record_field_or_break_match (|
                                γ0_0,
                                "move_core_types::vm_status::VMStatus::ExecutionFailure",
                                "code_offset"
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let __self_1 := M.alloc (| γ2_1 |) in
                            let __self_2 := M.alloc (| γ2_2 |) in
                            let __self_3 := M.alloc (| γ2_3 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.get_struct_record_field_or_break_match (|
                                γ0_1,
                                "move_core_types::vm_status::VMStatus::ExecutionFailure",
                                "status_code"
                              |) in
                            let γ2_1 :=
                              M.get_struct_record_field_or_break_match (|
                                γ0_1,
                                "move_core_types::vm_status::VMStatus::ExecutionFailure",
                                "location"
                              |) in
                            let γ2_2 :=
                              M.get_struct_record_field_or_break_match (|
                                γ0_1,
                                "move_core_types::vm_status::VMStatus::ExecutionFailure",
                                "function"
                              |) in
                            let γ2_3 :=
                              M.get_struct_record_field_or_break_match (|
                                γ0_1,
                                "move_core_types::vm_status::VMStatus::ExecutionFailure",
                                "code_offset"
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            let __arg1_1 := M.alloc (| γ2_1 |) in
                            let __arg1_2 := M.alloc (| γ2_2 |) in
                            let __arg1_3 := M.alloc (| γ2_3 |) in
                            M.match_operator (|
                              M.alloc (|
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::cmp::Ord",
                                    Ty.path "move_core_types::vm_status::StatusCode",
                                    [],
                                    "cmp",
                                    []
                                  |),
                                  [ M.read (| __self_0 |); M.read (| __arg1_0 |) ]
                                |)
                              |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (M.match_operator (|
                                      M.alloc (|
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::cmp::Ord",
                                            Ty.path "move_core_types::vm_status::AbortLocation",
                                            [],
                                            "cmp",
                                            []
                                          |),
                                          [ M.read (| __self_1 |); M.read (| __arg1_1 |) ]
                                        |)
                                      |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (M.match_operator (|
                                              M.alloc (|
                                                M.call_closure (|
                                                  M.get_trait_method (|
                                                    "core::cmp::Ord",
                                                    Ty.path "u16",
                                                    [],
                                                    "cmp",
                                                    []
                                                  |),
                                                  [ M.read (| __self_2 |); M.read (| __arg1_2 |) ]
                                                |)
                                              |),
                                              [
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (M.alloc (|
                                                      M.call_closure (|
                                                        M.get_trait_method (|
                                                          "core::cmp::Ord",
                                                          Ty.path "u16",
                                                          [],
                                                          "cmp",
                                                          []
                                                        |),
                                                        [
                                                          M.read (| __self_3 |);
                                                          M.read (| __arg1_3 |)
                                                        ]
                                                      |)
                                                    |)));
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (let cmp := M.copy (| γ |) in
                                                    cmp))
                                              ]
                                            |)));
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let cmp := M.copy (| γ |) in
                                            cmp))
                                      ]
                                    |)));
                                fun γ =>
                                  ltac:(M.monadic
                                    (let cmp := M.copy (| γ |) in
                                    cmp))
                              ]
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (| Value.StructTuple "core::cmp::Ordering::Equal" [] |)))
                      ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let cmp := M.copy (| γ |) in
                    cmp))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Ord"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("cmp", InstanceField.Method cmp) ].
  End Impl_core_cmp_Ord_for_move_core_types_vm_status_VMStatus.
  
  Module Impl_core_hash_Hash_for_move_core_types_vm_status_VMStatus.
    Definition Self : Ty.t := Ty.path "move_core_types::vm_status::VMStatus".
    
    (* Hash *)
    Definition hash (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ __H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let state := M.alloc (| state |) in
          M.read (|
            let __self_tag :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [ Ty.path "move_core_types::vm_status::VMStatus" ]
                  |),
                  [ M.read (| self |) ]
                |)
              |) in
            let _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (| "core::hash::Hash", Ty.path "isize", [], "hash", [ __H ] |),
                  [ __self_tag; M.read (| state |) ]
                |)
              |) in
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::vm_status::VMStatus::Error",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.path "move_core_types::vm_status::StatusCode",
                          [],
                          "hash",
                          [ __H ]
                        |),
                        [ M.read (| __self_0 |); M.read (| state |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::vm_status::VMStatus::MoveAbort",
                        0
                      |) in
                    let γ1_1 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::vm_status::VMStatus::MoveAbort",
                        1
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    let __self_1 := M.alloc (| γ1_1 |) in
                    let _ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::hash::Hash",
                            Ty.path "move_core_types::vm_status::AbortLocation",
                            [],
                            "hash",
                            [ __H ]
                          |),
                          [ M.read (| __self_0 |); M.read (| state |) ]
                        |)
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.path "u64",
                          [],
                          "hash",
                          [ __H ]
                        |),
                        [ M.read (| __self_1 |); M.read (| state |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_record_field_or_break_match (|
                        γ,
                        "move_core_types::vm_status::VMStatus::ExecutionFailure",
                        "status_code"
                      |) in
                    let γ1_1 :=
                      M.get_struct_record_field_or_break_match (|
                        γ,
                        "move_core_types::vm_status::VMStatus::ExecutionFailure",
                        "location"
                      |) in
                    let γ1_2 :=
                      M.get_struct_record_field_or_break_match (|
                        γ,
                        "move_core_types::vm_status::VMStatus::ExecutionFailure",
                        "function"
                      |) in
                    let γ1_3 :=
                      M.get_struct_record_field_or_break_match (|
                        γ,
                        "move_core_types::vm_status::VMStatus::ExecutionFailure",
                        "code_offset"
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    let __self_1 := M.alloc (| γ1_1 |) in
                    let __self_2 := M.alloc (| γ1_2 |) in
                    let __self_3 := M.alloc (| γ1_3 |) in
                    let _ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::hash::Hash",
                            Ty.path "move_core_types::vm_status::StatusCode",
                            [],
                            "hash",
                            [ __H ]
                          |),
                          [ M.read (| __self_0 |); M.read (| state |) ]
                        |)
                      |) in
                    let _ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::hash::Hash",
                            Ty.path "move_core_types::vm_status::AbortLocation",
                            [],
                            "hash",
                            [ __H ]
                          |),
                          [ M.read (| __self_1 |); M.read (| state |) ]
                        |)
                      |) in
                    let _ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::hash::Hash",
                            Ty.path "u16",
                            [],
                            "hash",
                            [ __H ]
                          |),
                          [ M.read (| __self_2 |); M.read (| state |) ]
                        |)
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.path "u16",
                          [],
                          "hash",
                          [ __H ]
                        |),
                        [ M.read (| __self_3 |); M.read (| state |) ]
                      |)
                    |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::hash::Hash"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("hash", InstanceField.Method hash) ].
  End Impl_core_hash_Hash_for_move_core_types_vm_status_VMStatus.
  
  Module underscore.
    Module Impl_serde_ser_Serialize_for_move_core_types_vm_status_VMStatus.
      Definition Self : Ty.t := Ty.path "move_core_types::vm_status::VMStatus".
      
      (* Serialize *)
      Definition serialize (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ __S ], [ self; __serializer ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let __serializer := M.alloc (| __serializer |) in
            M.read (|
              M.match_operator (|
                M.read (| self |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "serde::ser::Serializer",
                            __S,
                            [],
                            "serialize_unit_variant",
                            []
                          |),
                          [
                            M.read (| __serializer |);
                            M.read (| mk_str "VMStatus" |);
                            Value.Integer Integer.U32 0;
                            M.read (| mk_str "Executed" |)
                          ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.get_struct_tuple_field_or_break_match (|
                          γ,
                          "move_core_types::vm_status::VMStatus::Error",
                          0
                        |) in
                      let __field0 := M.alloc (| γ0_0 |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "serde::ser::Serializer",
                            __S,
                            [],
                            "serialize_newtype_variant",
                            [ Ty.path "move_core_types::vm_status::StatusCode" ]
                          |),
                          [
                            M.read (| __serializer |);
                            M.read (| mk_str "VMStatus" |);
                            Value.Integer Integer.U32 1;
                            M.read (| mk_str "Error" |);
                            M.read (| __field0 |)
                          ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.get_struct_tuple_field_or_break_match (|
                          γ,
                          "move_core_types::vm_status::VMStatus::MoveAbort",
                          0
                        |) in
                      let γ0_1 :=
                        M.get_struct_tuple_field_or_break_match (|
                          γ,
                          "move_core_types::vm_status::VMStatus::MoveAbort",
                          1
                        |) in
                      let __field0 := M.alloc (| γ0_0 |) in
                      let __field1 := M.alloc (| γ0_1 |) in
                      let __serde_state :=
                        M.copy (|
                          M.match_operator (|
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "serde::ser::Serializer",
                                  __S,
                                  [],
                                  "serialize_tuple_variant",
                                  []
                                |),
                                [
                                  M.read (| __serializer |);
                                  M.read (| mk_str "VMStatus" |);
                                  Value.Integer Integer.U32 2;
                                  M.read (| mk_str "MoveAbort" |);
                                  BinOp.Panic.add (|
                                    BinOp.Panic.add (|
                                      Value.Integer Integer.Usize 0,
                                      Value.Integer Integer.Usize 1
                                    |),
                                    Value.Integer Integer.Usize 1
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.get_struct_tuple_field_or_break_match (|
                                      γ,
                                      "core::result::Result::Ok",
                                      0
                                    |) in
                                  let __val := M.copy (| γ0_0 |) in
                                  __val));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.get_struct_tuple_field_or_break_match (|
                                      γ,
                                      "core::result::Result::Err",
                                      0
                                    |) in
                                  let __err := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          Value.StructTuple
                                            "core::result::Result::Err"
                                            [ M.read (| __err |) ]
                                        |)
                                      |)
                                    |)
                                  |)))
                            ]
                          |)
                        |) in
                      let _ :=
                        M.match_operator (|
                          M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "serde::ser::SerializeTupleVariant",
                                Ty.associated,
                                [],
                                "serialize_field",
                                [ Ty.path "move_core_types::vm_status::AbortLocation" ]
                              |),
                              [ __serde_state; M.read (| __field0 |) ]
                            |)
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.get_struct_tuple_field_or_break_match (|
                                    γ,
                                    "core::result::Result::Ok",
                                    0
                                  |) in
                                let __val := M.copy (| γ0_0 |) in
                                __val));
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.get_struct_tuple_field_or_break_match (|
                                    γ,
                                    "core::result::Result::Err",
                                    0
                                  |) in
                                let __err := M.copy (| γ0_0 |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      M.return_ (|
                                        Value.StructTuple
                                          "core::result::Result::Err"
                                          [ M.read (| __err |) ]
                                      |)
                                    |)
                                  |)
                                |)))
                          ]
                        |) in
                      let _ :=
                        M.match_operator (|
                          M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "serde::ser::SerializeTupleVariant",
                                Ty.associated,
                                [],
                                "serialize_field",
                                [ Ty.path "u64" ]
                              |),
                              [ __serde_state; M.read (| __field1 |) ]
                            |)
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.get_struct_tuple_field_or_break_match (|
                                    γ,
                                    "core::result::Result::Ok",
                                    0
                                  |) in
                                let __val := M.copy (| γ0_0 |) in
                                __val));
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.get_struct_tuple_field_or_break_match (|
                                    γ,
                                    "core::result::Result::Err",
                                    0
                                  |) in
                                let __err := M.copy (| γ0_0 |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      M.return_ (|
                                        Value.StructTuple
                                          "core::result::Result::Err"
                                          [ M.read (| __err |) ]
                                      |)
                                    |)
                                  |)
                                |)))
                          ]
                        |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "serde::ser::SerializeTupleVariant",
                            Ty.associated,
                            [],
                            "end",
                            []
                          |),
                          [ M.read (| __serde_state |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.get_struct_record_field_or_break_match (|
                          γ,
                          "move_core_types::vm_status::VMStatus::ExecutionFailure",
                          "status_code"
                        |) in
                      let γ0_1 :=
                        M.get_struct_record_field_or_break_match (|
                          γ,
                          "move_core_types::vm_status::VMStatus::ExecutionFailure",
                          "location"
                        |) in
                      let γ0_2 :=
                        M.get_struct_record_field_or_break_match (|
                          γ,
                          "move_core_types::vm_status::VMStatus::ExecutionFailure",
                          "function"
                        |) in
                      let γ0_3 :=
                        M.get_struct_record_field_or_break_match (|
                          γ,
                          "move_core_types::vm_status::VMStatus::ExecutionFailure",
                          "code_offset"
                        |) in
                      let status_code := M.alloc (| γ0_0 |) in
                      let location := M.alloc (| γ0_1 |) in
                      let function := M.alloc (| γ0_2 |) in
                      let code_offset := M.alloc (| γ0_3 |) in
                      let __serde_state :=
                        M.copy (|
                          M.match_operator (|
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "serde::ser::Serializer",
                                  __S,
                                  [],
                                  "serialize_struct_variant",
                                  []
                                |),
                                [
                                  M.read (| __serializer |);
                                  M.read (| mk_str "VMStatus" |);
                                  Value.Integer Integer.U32 3;
                                  M.read (| mk_str "ExecutionFailure" |);
                                  BinOp.Panic.add (|
                                    BinOp.Panic.add (|
                                      BinOp.Panic.add (|
                                        BinOp.Panic.add (|
                                          Value.Integer Integer.Usize 0,
                                          Value.Integer Integer.Usize 1
                                        |),
                                        Value.Integer Integer.Usize 1
                                      |),
                                      Value.Integer Integer.Usize 1
                                    |),
                                    Value.Integer Integer.Usize 1
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.get_struct_tuple_field_or_break_match (|
                                      γ,
                                      "core::result::Result::Ok",
                                      0
                                    |) in
                                  let __val := M.copy (| γ0_0 |) in
                                  __val));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.get_struct_tuple_field_or_break_match (|
                                      γ,
                                      "core::result::Result::Err",
                                      0
                                    |) in
                                  let __err := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          Value.StructTuple
                                            "core::result::Result::Err"
                                            [ M.read (| __err |) ]
                                        |)
                                      |)
                                    |)
                                  |)))
                            ]
                          |)
                        |) in
                      let _ :=
                        M.match_operator (|
                          M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "serde::ser::SerializeStructVariant",
                                Ty.associated,
                                [],
                                "serialize_field",
                                [ Ty.path "move_core_types::vm_status::StatusCode" ]
                              |),
                              [
                                __serde_state;
                                M.read (| mk_str "status_code" |);
                                M.read (| status_code |)
                              ]
                            |)
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.get_struct_tuple_field_or_break_match (|
                                    γ,
                                    "core::result::Result::Ok",
                                    0
                                  |) in
                                let __val := M.copy (| γ0_0 |) in
                                __val));
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.get_struct_tuple_field_or_break_match (|
                                    γ,
                                    "core::result::Result::Err",
                                    0
                                  |) in
                                let __err := M.copy (| γ0_0 |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      M.return_ (|
                                        Value.StructTuple
                                          "core::result::Result::Err"
                                          [ M.read (| __err |) ]
                                      |)
                                    |)
                                  |)
                                |)))
                          ]
                        |) in
                      let _ :=
                        M.match_operator (|
                          M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "serde::ser::SerializeStructVariant",
                                Ty.associated,
                                [],
                                "serialize_field",
                                [ Ty.path "move_core_types::vm_status::AbortLocation" ]
                              |),
                              [ __serde_state; M.read (| mk_str "location" |); M.read (| location |)
                              ]
                            |)
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.get_struct_tuple_field_or_break_match (|
                                    γ,
                                    "core::result::Result::Ok",
                                    0
                                  |) in
                                let __val := M.copy (| γ0_0 |) in
                                __val));
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.get_struct_tuple_field_or_break_match (|
                                    γ,
                                    "core::result::Result::Err",
                                    0
                                  |) in
                                let __err := M.copy (| γ0_0 |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      M.return_ (|
                                        Value.StructTuple
                                          "core::result::Result::Err"
                                          [ M.read (| __err |) ]
                                      |)
                                    |)
                                  |)
                                |)))
                          ]
                        |) in
                      let _ :=
                        M.match_operator (|
                          M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "serde::ser::SerializeStructVariant",
                                Ty.associated,
                                [],
                                "serialize_field",
                                [ Ty.path "u16" ]
                              |),
                              [ __serde_state; M.read (| mk_str "function" |); M.read (| function |)
                              ]
                            |)
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.get_struct_tuple_field_or_break_match (|
                                    γ,
                                    "core::result::Result::Ok",
                                    0
                                  |) in
                                let __val := M.copy (| γ0_0 |) in
                                __val));
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.get_struct_tuple_field_or_break_match (|
                                    γ,
                                    "core::result::Result::Err",
                                    0
                                  |) in
                                let __err := M.copy (| γ0_0 |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      M.return_ (|
                                        Value.StructTuple
                                          "core::result::Result::Err"
                                          [ M.read (| __err |) ]
                                      |)
                                    |)
                                  |)
                                |)))
                          ]
                        |) in
                      let _ :=
                        M.match_operator (|
                          M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "serde::ser::SerializeStructVariant",
                                Ty.associated,
                                [],
                                "serialize_field",
                                [ Ty.path "u16" ]
                              |),
                              [
                                __serde_state;
                                M.read (| mk_str "code_offset" |);
                                M.read (| code_offset |)
                              ]
                            |)
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.get_struct_tuple_field_or_break_match (|
                                    γ,
                                    "core::result::Result::Ok",
                                    0
                                  |) in
                                let __val := M.copy (| γ0_0 |) in
                                __val));
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.get_struct_tuple_field_or_break_match (|
                                    γ,
                                    "core::result::Result::Err",
                                    0
                                  |) in
                                let __err := M.copy (| γ0_0 |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      M.return_ (|
                                        Value.StructTuple
                                          "core::result::Result::Err"
                                          [ M.read (| __err |) ]
                                      |)
                                    |)
                                  |)
                                |)))
                          ]
                        |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "serde::ser::SerializeStructVariant",
                            Ty.associated,
                            [],
                            "end",
                            []
                          |),
                          [ M.read (| __serde_state |) ]
                        |)
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "serde::ser::Serialize"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("serialize", InstanceField.Method serialize) ].
    End Impl_serde_ser_Serialize_for_move_core_types_vm_status_VMStatus.
  End underscore.
  
  Module Wrap_underscore_2.
  Module underscore.
    Module Impl_serde_de_Deserialize_for_move_core_types_vm_status_VMStatus.
      Definition Self : Ty.t := Ty.path "move_core_types::vm_status::VMStatus".
      
      (* Deserialize *)
      Definition deserialize (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ __D ], [ __deserializer ] =>
          ltac:(M.monadic
            (let __deserializer := M.alloc (| __deserializer |) in
            M.call_closure (|
              M.get_trait_method (|
                "serde::de::Deserializer",
                __D,
                [],
                "deserialize_enum",
                [ Ty.path "move_core_types::vm_status::_'1::deserialize::__Visitor" ]
              |),
              [
                M.read (| __deserializer |);
                M.read (| mk_str "VMStatus" |);
                M.read (|
                  M.get_constant (| "move_core_types::vm_status::_'1::deserialize::VARIANTS" |)
                |);
                Value.StructRecord
                  "move_core_types::vm_status::_'1::deserialize::__Visitor"
                  [
                    ("marker", Value.StructTuple "core::marker::PhantomData" []);
                    ("lifetime", Value.StructTuple "core::marker::PhantomData" [])
                  ]
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "serde::de::Deserialize"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("deserialize", InstanceField.Method deserialize) ].
    End Impl_serde_de_Deserialize_for_move_core_types_vm_status_VMStatus.
  End underscore.
  End Wrap_underscore_2.
  Import Wrap_underscore_2.
  
  (*
  Enum KeptVMStatus
  {
    ty_params := [];
    variants :=
      [
        {
          name := "Executed";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "OutOfGas";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "MoveAbort";
          item :=
            StructTuple [ Ty.path "move_core_types::vm_status::AbortLocation"; Ty.path "u64" ];
          discriminant := None;
        };
        {
          name := "ExecutionFailure";
          item :=
            StructRecord
              [
                ("location", Ty.path "move_core_types::vm_status::AbortLocation");
                ("function", Ty.path "u16");
                ("code_offset", Ty.path "u16")
              ];
          discriminant := None;
        };
        {
          name := "MiscellaneousError";
          item := StructTuple [];
          discriminant := None;
        }
      ];
  }
  *)
  
  Module Impl_core_clone_Clone_for_move_core_types_vm_status_KeptVMStatus.
    Definition Self : Ty.t := Ty.path "move_core_types::vm_status::KeptVMStatus".
    
    (* Clone *)
    Definition clone (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (|
                      Value.StructTuple "move_core_types::vm_status::KeptVMStatus::Executed" []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (|
                      Value.StructTuple "move_core_types::vm_status::KeptVMStatus::OutOfGas" []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::vm_status::KeptVMStatus::MoveAbort",
                        0
                      |) in
                    let γ1_1 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::vm_status::KeptVMStatus::MoveAbort",
                        1
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    let __self_1 := M.alloc (| γ1_1 |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_core_types::vm_status::KeptVMStatus::MoveAbort"
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.path "move_core_types::vm_status::AbortLocation",
                              [],
                              "clone",
                              []
                            |),
                            [ M.read (| __self_0 |) ]
                          |);
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.path "u64",
                              [],
                              "clone",
                              []
                            |),
                            [ M.read (| __self_1 |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_record_field_or_break_match (|
                        γ,
                        "move_core_types::vm_status::KeptVMStatus::ExecutionFailure",
                        "location"
                      |) in
                    let γ1_1 :=
                      M.get_struct_record_field_or_break_match (|
                        γ,
                        "move_core_types::vm_status::KeptVMStatus::ExecutionFailure",
                        "function"
                      |) in
                    let γ1_2 :=
                      M.get_struct_record_field_or_break_match (|
                        γ,
                        "move_core_types::vm_status::KeptVMStatus::ExecutionFailure",
                        "code_offset"
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    let __self_1 := M.alloc (| γ1_1 |) in
                    let __self_2 := M.alloc (| γ1_2 |) in
                    M.alloc (|
                      Value.StructRecord
                        "move_core_types::vm_status::KeptVMStatus::ExecutionFailure"
                        [
                          ("location",
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::clone::Clone",
                                Ty.path "move_core_types::vm_status::AbortLocation",
                                [],
                                "clone",
                                []
                              |),
                              [ M.read (| __self_0 |) ]
                            |));
                          ("function",
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::clone::Clone",
                                Ty.path "u16",
                                [],
                                "clone",
                                []
                              |),
                              [ M.read (| __self_1 |) ]
                            |));
                          ("code_offset",
                            M.call_closure (|
                              M.get_trait_method (|
                                "core::clone::Clone",
                                Ty.path "u16",
                                [],
                                "clone",
                                []
                              |),
                              [ M.read (| __self_2 |) ]
                            |))
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_core_types::vm_status::KeptVMStatus::MiscellaneousError"
                        []
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_move_core_types_vm_status_KeptVMStatus.
  
  Module Impl_core_marker_StructuralPartialEq_for_move_core_types_vm_status_KeptVMStatus.
    Definition Self : Ty.t := Ty.path "move_core_types::vm_status::KeptVMStatus".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_move_core_types_vm_status_KeptVMStatus.
  
  Module Impl_core_cmp_PartialEq_for_move_core_types_vm_status_KeptVMStatus.
    Definition Self : Ty.t := Ty.path "move_core_types::vm_status::KeptVMStatus".
    
    (* PartialEq *)
    Definition eq (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            let __self_tag :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [ Ty.path "move_core_types::vm_status::KeptVMStatus" ]
                  |),
                  [ M.read (| self |) ]
                |)
              |) in
            let __arg1_tag :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [ Ty.path "move_core_types::vm_status::KeptVMStatus" ]
                  |),
                  [ M.read (| other |) ]
                |)
              |) in
            M.alloc (|
              LogicalOp.and (|
                BinOp.Pure.eq (M.read (| __self_tag |)) (M.read (| __arg1_tag |)),
                ltac:(M.monadic
                  (M.read (|
                    M.match_operator (|
                      M.alloc (| Value.Tuple [ M.read (| self |); M.read (| other |) ] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.get_tuple_field γ 0 in
                            let γ0_1 := M.get_tuple_field γ 1 in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ0_0,
                                "move_core_types::vm_status::KeptVMStatus::MoveAbort",
                                0
                              |) in
                            let γ2_1 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ0_0,
                                "move_core_types::vm_status::KeptVMStatus::MoveAbort",
                                1
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let __self_1 := M.alloc (| γ2_1 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ0_1,
                                "move_core_types::vm_status::KeptVMStatus::MoveAbort",
                                0
                              |) in
                            let γ2_1 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ0_1,
                                "move_core_types::vm_status::KeptVMStatus::MoveAbort",
                                1
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            let __arg1_1 := M.alloc (| γ2_1 |) in
                            M.alloc (|
                              LogicalOp.and (|
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::cmp::PartialEq",
                                    Ty.path "move_core_types::vm_status::AbortLocation",
                                    [ Ty.path "move_core_types::vm_status::AbortLocation" ],
                                    "eq",
                                    []
                                  |),
                                  [ M.read (| __self_0 |); M.read (| __arg1_0 |) ]
                                |),
                                ltac:(M.monadic
                                  (BinOp.Pure.eq
                                    (M.read (| M.read (| __self_1 |) |))
                                    (M.read (| M.read (| __arg1_1 |) |))))
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.get_tuple_field γ 0 in
                            let γ0_1 := M.get_tuple_field γ 1 in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.get_struct_record_field_or_break_match (|
                                γ0_0,
                                "move_core_types::vm_status::KeptVMStatus::ExecutionFailure",
                                "location"
                              |) in
                            let γ2_1 :=
                              M.get_struct_record_field_or_break_match (|
                                γ0_0,
                                "move_core_types::vm_status::KeptVMStatus::ExecutionFailure",
                                "function"
                              |) in
                            let γ2_2 :=
                              M.get_struct_record_field_or_break_match (|
                                γ0_0,
                                "move_core_types::vm_status::KeptVMStatus::ExecutionFailure",
                                "code_offset"
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let __self_1 := M.alloc (| γ2_1 |) in
                            let __self_2 := M.alloc (| γ2_2 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.get_struct_record_field_or_break_match (|
                                γ0_1,
                                "move_core_types::vm_status::KeptVMStatus::ExecutionFailure",
                                "location"
                              |) in
                            let γ2_1 :=
                              M.get_struct_record_field_or_break_match (|
                                γ0_1,
                                "move_core_types::vm_status::KeptVMStatus::ExecutionFailure",
                                "function"
                              |) in
                            let γ2_2 :=
                              M.get_struct_record_field_or_break_match (|
                                γ0_1,
                                "move_core_types::vm_status::KeptVMStatus::ExecutionFailure",
                                "code_offset"
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            let __arg1_1 := M.alloc (| γ2_1 |) in
                            let __arg1_2 := M.alloc (| γ2_2 |) in
                            M.alloc (|
                              LogicalOp.and (|
                                LogicalOp.and (|
                                  M.call_closure (|
                                    M.get_trait_method (|
                                      "core::cmp::PartialEq",
                                      Ty.path "move_core_types::vm_status::AbortLocation",
                                      [ Ty.path "move_core_types::vm_status::AbortLocation" ],
                                      "eq",
                                      []
                                    |),
                                    [ M.read (| __self_0 |); M.read (| __arg1_0 |) ]
                                  |),
                                  ltac:(M.monadic
                                    (BinOp.Pure.eq
                                      (M.read (| M.read (| __self_1 |) |))
                                      (M.read (| M.read (| __arg1_1 |) |))))
                                |),
                                ltac:(M.monadic
                                  (BinOp.Pure.eq
                                    (M.read (| M.read (| __self_2 |) |))
                                    (M.read (| M.read (| __arg1_2 |) |))))
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Bool true |)))
                      ]
                    |)
                  |)))
              |)
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_for_move_core_types_vm_status_KeptVMStatus.
  
  Module Impl_core_marker_StructuralEq_for_move_core_types_vm_status_KeptVMStatus.
    Definition Self : Ty.t := Ty.path "move_core_types::vm_status::KeptVMStatus".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralEq_for_move_core_types_vm_status_KeptVMStatus.
  
  Module Impl_core_cmp_Eq_for_move_core_types_vm_status_KeptVMStatus.
    Definition Self : Ty.t := Ty.path "move_core_types::vm_status::KeptVMStatus".
    
    (* Eq *)
    Definition assert_receiver_is_total_eq (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Value.DeclaredButUndefined,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      Value.DeclaredButUndefined,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              Value.DeclaredButUndefined,
                              [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_move_core_types_vm_status_KeptVMStatus.
  
  Module Impl_core_cmp_PartialOrd_for_move_core_types_vm_status_KeptVMStatus.
    Definition Self : Ty.t := Ty.path "move_core_types::vm_status::KeptVMStatus".
    
    (* PartialOrd *)
    Definition partial_cmp (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            let __self_tag :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [ Ty.path "move_core_types::vm_status::KeptVMStatus" ]
                  |),
                  [ M.read (| self |) ]
                |)
              |) in
            let __arg1_tag :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [ Ty.path "move_core_types::vm_status::KeptVMStatus" ]
                  |),
                  [ M.read (| other |) ]
                |)
              |) in
            M.match_operator (|
              M.alloc (| Value.Tuple [ M.read (| self |); M.read (| other |) ] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.get_tuple_field γ 0 in
                    let γ0_1 := M.get_tuple_field γ 1 in
                    let γ0_0 := M.read (| γ0_0 |) in
                    let γ2_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ0_0,
                        "move_core_types::vm_status::KeptVMStatus::MoveAbort",
                        0
                      |) in
                    let γ2_1 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ0_0,
                        "move_core_types::vm_status::KeptVMStatus::MoveAbort",
                        1
                      |) in
                    let __self_0 := M.alloc (| γ2_0 |) in
                    let __self_1 := M.alloc (| γ2_1 |) in
                    let γ0_1 := M.read (| γ0_1 |) in
                    let γ2_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ0_1,
                        "move_core_types::vm_status::KeptVMStatus::MoveAbort",
                        0
                      |) in
                    let γ2_1 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ0_1,
                        "move_core_types::vm_status::KeptVMStatus::MoveAbort",
                        1
                      |) in
                    let __arg1_0 := M.alloc (| γ2_0 |) in
                    let __arg1_1 := M.alloc (| γ2_1 |) in
                    M.match_operator (|
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::cmp::PartialOrd",
                            Ty.path "move_core_types::vm_status::AbortLocation",
                            [ Ty.path "move_core_types::vm_status::AbortLocation" ],
                            "partial_cmp",
                            []
                          |),
                          [ M.read (| __self_0 |); M.read (| __arg1_0 |) ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ,
                                "core::option::Option::Some",
                                0
                              |) in
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::cmp::PartialOrd",
                                  Ty.path "u64",
                                  [ Ty.path "u64" ],
                                  "partial_cmp",
                                  []
                                |),
                                [ M.read (| __self_1 |); M.read (| __arg1_1 |) ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let cmp := M.copy (| γ |) in
                            cmp))
                      ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.get_tuple_field γ 0 in
                    let γ0_1 := M.get_tuple_field γ 1 in
                    let γ0_0 := M.read (| γ0_0 |) in
                    let γ2_0 :=
                      M.get_struct_record_field_or_break_match (|
                        γ0_0,
                        "move_core_types::vm_status::KeptVMStatus::ExecutionFailure",
                        "location"
                      |) in
                    let γ2_1 :=
                      M.get_struct_record_field_or_break_match (|
                        γ0_0,
                        "move_core_types::vm_status::KeptVMStatus::ExecutionFailure",
                        "function"
                      |) in
                    let γ2_2 :=
                      M.get_struct_record_field_or_break_match (|
                        γ0_0,
                        "move_core_types::vm_status::KeptVMStatus::ExecutionFailure",
                        "code_offset"
                      |) in
                    let __self_0 := M.alloc (| γ2_0 |) in
                    let __self_1 := M.alloc (| γ2_1 |) in
                    let __self_2 := M.alloc (| γ2_2 |) in
                    let γ0_1 := M.read (| γ0_1 |) in
                    let γ2_0 :=
                      M.get_struct_record_field_or_break_match (|
                        γ0_1,
                        "move_core_types::vm_status::KeptVMStatus::ExecutionFailure",
                        "location"
                      |) in
                    let γ2_1 :=
                      M.get_struct_record_field_or_break_match (|
                        γ0_1,
                        "move_core_types::vm_status::KeptVMStatus::ExecutionFailure",
                        "function"
                      |) in
                    let γ2_2 :=
                      M.get_struct_record_field_or_break_match (|
                        γ0_1,
                        "move_core_types::vm_status::KeptVMStatus::ExecutionFailure",
                        "code_offset"
                      |) in
                    let __arg1_0 := M.alloc (| γ2_0 |) in
                    let __arg1_1 := M.alloc (| γ2_1 |) in
                    let __arg1_2 := M.alloc (| γ2_2 |) in
                    M.match_operator (|
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::cmp::PartialOrd",
                            Ty.path "move_core_types::vm_status::AbortLocation",
                            [ Ty.path "move_core_types::vm_status::AbortLocation" ],
                            "partial_cmp",
                            []
                          |),
                          [ M.read (| __self_0 |); M.read (| __arg1_0 |) ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ,
                                "core::option::Option::Some",
                                0
                              |) in
                            M.match_operator (|
                              M.alloc (|
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::cmp::PartialOrd",
                                    Ty.path "u16",
                                    [ Ty.path "u16" ],
                                    "partial_cmp",
                                    []
                                  |),
                                  [ M.read (| __self_1 |); M.read (| __arg1_1 |) ]
                                |)
                              |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ0_0 :=
                                      M.get_struct_tuple_field_or_break_match (|
                                        γ,
                                        "core::option::Option::Some",
                                        0
                                      |) in
                                    M.alloc (|
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::cmp::PartialOrd",
                                          Ty.path "u16",
                                          [ Ty.path "u16" ],
                                          "partial_cmp",
                                          []
                                        |),
                                        [ M.read (| __self_2 |); M.read (| __arg1_2 |) ]
                                      |)
                                    |)));
                                fun γ =>
                                  ltac:(M.monadic
                                    (let cmp := M.copy (| γ |) in
                                    cmp))
                              ]
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let cmp := M.copy (| γ |) in
                            cmp))
                      ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::cmp::PartialOrd",
                          Ty.path "isize",
                          [ Ty.path "isize" ],
                          "partial_cmp",
                          []
                        |),
                        [ __self_tag; __arg1_tag ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialOrd"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("partial_cmp", InstanceField.Method partial_cmp) ].
  End Impl_core_cmp_PartialOrd_for_move_core_types_vm_status_KeptVMStatus.
  
  Module Impl_core_cmp_Ord_for_move_core_types_vm_status_KeptVMStatus.
    Definition Self : Ty.t := Ty.path "move_core_types::vm_status::KeptVMStatus".
    
    (* Ord *)
    Definition cmp (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            let __self_tag :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [ Ty.path "move_core_types::vm_status::KeptVMStatus" ]
                  |),
                  [ M.read (| self |) ]
                |)
              |) in
            let __arg1_tag :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [ Ty.path "move_core_types::vm_status::KeptVMStatus" ]
                  |),
                  [ M.read (| other |) ]
                |)
              |) in
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (| "core::cmp::Ord", Ty.path "isize", [], "cmp", [] |),
                  [ __self_tag; __arg1_tag ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      M.alloc (| Value.Tuple [ M.read (| self |); M.read (| other |) ] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.get_tuple_field γ 0 in
                            let γ0_1 := M.get_tuple_field γ 1 in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ0_0,
                                "move_core_types::vm_status::KeptVMStatus::MoveAbort",
                                0
                              |) in
                            let γ2_1 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ0_0,
                                "move_core_types::vm_status::KeptVMStatus::MoveAbort",
                                1
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let __self_1 := M.alloc (| γ2_1 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ0_1,
                                "move_core_types::vm_status::KeptVMStatus::MoveAbort",
                                0
                              |) in
                            let γ2_1 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ0_1,
                                "move_core_types::vm_status::KeptVMStatus::MoveAbort",
                                1
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            let __arg1_1 := M.alloc (| γ2_1 |) in
                            M.match_operator (|
                              M.alloc (|
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::cmp::Ord",
                                    Ty.path "move_core_types::vm_status::AbortLocation",
                                    [],
                                    "cmp",
                                    []
                                  |),
                                  [ M.read (| __self_0 |); M.read (| __arg1_0 |) ]
                                |)
                              |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (M.alloc (|
                                      M.call_closure (|
                                        M.get_trait_method (|
                                          "core::cmp::Ord",
                                          Ty.path "u64",
                                          [],
                                          "cmp",
                                          []
                                        |),
                                        [ M.read (| __self_1 |); M.read (| __arg1_1 |) ]
                                      |)
                                    |)));
                                fun γ =>
                                  ltac:(M.monadic
                                    (let cmp := M.copy (| γ |) in
                                    cmp))
                              ]
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.get_tuple_field γ 0 in
                            let γ0_1 := M.get_tuple_field γ 1 in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.get_struct_record_field_or_break_match (|
                                γ0_0,
                                "move_core_types::vm_status::KeptVMStatus::ExecutionFailure",
                                "location"
                              |) in
                            let γ2_1 :=
                              M.get_struct_record_field_or_break_match (|
                                γ0_0,
                                "move_core_types::vm_status::KeptVMStatus::ExecutionFailure",
                                "function"
                              |) in
                            let γ2_2 :=
                              M.get_struct_record_field_or_break_match (|
                                γ0_0,
                                "move_core_types::vm_status::KeptVMStatus::ExecutionFailure",
                                "code_offset"
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let __self_1 := M.alloc (| γ2_1 |) in
                            let __self_2 := M.alloc (| γ2_2 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.get_struct_record_field_or_break_match (|
                                γ0_1,
                                "move_core_types::vm_status::KeptVMStatus::ExecutionFailure",
                                "location"
                              |) in
                            let γ2_1 :=
                              M.get_struct_record_field_or_break_match (|
                                γ0_1,
                                "move_core_types::vm_status::KeptVMStatus::ExecutionFailure",
                                "function"
                              |) in
                            let γ2_2 :=
                              M.get_struct_record_field_or_break_match (|
                                γ0_1,
                                "move_core_types::vm_status::KeptVMStatus::ExecutionFailure",
                                "code_offset"
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            let __arg1_1 := M.alloc (| γ2_1 |) in
                            let __arg1_2 := M.alloc (| γ2_2 |) in
                            M.match_operator (|
                              M.alloc (|
                                M.call_closure (|
                                  M.get_trait_method (|
                                    "core::cmp::Ord",
                                    Ty.path "move_core_types::vm_status::AbortLocation",
                                    [],
                                    "cmp",
                                    []
                                  |),
                                  [ M.read (| __self_0 |); M.read (| __arg1_0 |) ]
                                |)
                              |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (M.match_operator (|
                                      M.alloc (|
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "core::cmp::Ord",
                                            Ty.path "u16",
                                            [],
                                            "cmp",
                                            []
                                          |),
                                          [ M.read (| __self_1 |); M.read (| __arg1_1 |) ]
                                        |)
                                      |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (M.alloc (|
                                              M.call_closure (|
                                                M.get_trait_method (|
                                                  "core::cmp::Ord",
                                                  Ty.path "u16",
                                                  [],
                                                  "cmp",
                                                  []
                                                |),
                                                [ M.read (| __self_2 |); M.read (| __arg1_2 |) ]
                                              |)
                                            |)));
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let cmp := M.copy (| γ |) in
                                            cmp))
                                      ]
                                    |)));
                                fun γ =>
                                  ltac:(M.monadic
                                    (let cmp := M.copy (| γ |) in
                                    cmp))
                              ]
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (| Value.StructTuple "core::cmp::Ordering::Equal" [] |)))
                      ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let cmp := M.copy (| γ |) in
                    cmp))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Ord"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("cmp", InstanceField.Method cmp) ].
  End Impl_core_cmp_Ord_for_move_core_types_vm_status_KeptVMStatus.
  
  Module Impl_core_hash_Hash_for_move_core_types_vm_status_KeptVMStatus.
    Definition Self : Ty.t := Ty.path "move_core_types::vm_status::KeptVMStatus".
    
    (* Hash *)
    Definition hash (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ __H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let state := M.alloc (| state |) in
          M.read (|
            let __self_tag :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [ Ty.path "move_core_types::vm_status::KeptVMStatus" ]
                  |),
                  [ M.read (| self |) ]
                |)
              |) in
            let _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (| "core::hash::Hash", Ty.path "isize", [], "hash", [ __H ] |),
                  [ __self_tag; M.read (| state |) ]
                |)
              |) in
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::vm_status::KeptVMStatus::MoveAbort",
                        0
                      |) in
                    let γ1_1 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::vm_status::KeptVMStatus::MoveAbort",
                        1
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    let __self_1 := M.alloc (| γ1_1 |) in
                    let _ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::hash::Hash",
                            Ty.path "move_core_types::vm_status::AbortLocation",
                            [],
                            "hash",
                            [ __H ]
                          |),
                          [ M.read (| __self_0 |); M.read (| state |) ]
                        |)
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.path "u64",
                          [],
                          "hash",
                          [ __H ]
                        |),
                        [ M.read (| __self_1 |); M.read (| state |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_record_field_or_break_match (|
                        γ,
                        "move_core_types::vm_status::KeptVMStatus::ExecutionFailure",
                        "location"
                      |) in
                    let γ1_1 :=
                      M.get_struct_record_field_or_break_match (|
                        γ,
                        "move_core_types::vm_status::KeptVMStatus::ExecutionFailure",
                        "function"
                      |) in
                    let γ1_2 :=
                      M.get_struct_record_field_or_break_match (|
                        γ,
                        "move_core_types::vm_status::KeptVMStatus::ExecutionFailure",
                        "code_offset"
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    let __self_1 := M.alloc (| γ1_1 |) in
                    let __self_2 := M.alloc (| γ1_2 |) in
                    let _ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::hash::Hash",
                            Ty.path "move_core_types::vm_status::AbortLocation",
                            [],
                            "hash",
                            [ __H ]
                          |),
                          [ M.read (| __self_0 |); M.read (| state |) ]
                        |)
                      |) in
                    let _ :=
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "core::hash::Hash",
                            Ty.path "u16",
                            [],
                            "hash",
                            [ __H ]
                          |),
                          [ M.read (| __self_1 |); M.read (| state |) ]
                        |)
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.path "u16",
                          [],
                          "hash",
                          [ __H ]
                        |),
                        [ M.read (| __self_2 |); M.read (| state |) ]
                      |)
                    |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::hash::Hash"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("hash", InstanceField.Method hash) ].
  End Impl_core_hash_Hash_for_move_core_types_vm_status_KeptVMStatus.
  
  Module Wrap_underscore_3.
  Module underscore.
    Module Impl_serde_ser_Serialize_for_move_core_types_vm_status_KeptVMStatus.
      Definition Self : Ty.t := Ty.path "move_core_types::vm_status::KeptVMStatus".
      
      (* Serialize *)
      Definition serialize (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ __S ], [ self; __serializer ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let __serializer := M.alloc (| __serializer |) in
            M.read (|
              M.match_operator (|
                M.read (| self |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "serde::ser::Serializer",
                            __S,
                            [],
                            "serialize_unit_variant",
                            []
                          |),
                          [
                            M.read (| __serializer |);
                            M.read (| mk_str "KeptVMStatus" |);
                            Value.Integer Integer.U32 0;
                            M.read (| mk_str "Executed" |)
                          ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "serde::ser::Serializer",
                            __S,
                            [],
                            "serialize_unit_variant",
                            []
                          |),
                          [
                            M.read (| __serializer |);
                            M.read (| mk_str "KeptVMStatus" |);
                            Value.Integer Integer.U32 1;
                            M.read (| mk_str "OutOfGas" |)
                          ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.get_struct_tuple_field_or_break_match (|
                          γ,
                          "move_core_types::vm_status::KeptVMStatus::MoveAbort",
                          0
                        |) in
                      let γ0_1 :=
                        M.get_struct_tuple_field_or_break_match (|
                          γ,
                          "move_core_types::vm_status::KeptVMStatus::MoveAbort",
                          1
                        |) in
                      let __field0 := M.alloc (| γ0_0 |) in
                      let __field1 := M.alloc (| γ0_1 |) in
                      let __serde_state :=
                        M.copy (|
                          M.match_operator (|
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "serde::ser::Serializer",
                                  __S,
                                  [],
                                  "serialize_tuple_variant",
                                  []
                                |),
                                [
                                  M.read (| __serializer |);
                                  M.read (| mk_str "KeptVMStatus" |);
                                  Value.Integer Integer.U32 2;
                                  M.read (| mk_str "MoveAbort" |);
                                  BinOp.Panic.add (|
                                    BinOp.Panic.add (|
                                      Value.Integer Integer.Usize 0,
                                      Value.Integer Integer.Usize 1
                                    |),
                                    Value.Integer Integer.Usize 1
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.get_struct_tuple_field_or_break_match (|
                                      γ,
                                      "core::result::Result::Ok",
                                      0
                                    |) in
                                  let __val := M.copy (| γ0_0 |) in
                                  __val));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.get_struct_tuple_field_or_break_match (|
                                      γ,
                                      "core::result::Result::Err",
                                      0
                                    |) in
                                  let __err := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          Value.StructTuple
                                            "core::result::Result::Err"
                                            [ M.read (| __err |) ]
                                        |)
                                      |)
                                    |)
                                  |)))
                            ]
                          |)
                        |) in
                      let _ :=
                        M.match_operator (|
                          M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "serde::ser::SerializeTupleVariant",
                                Ty.associated,
                                [],
                                "serialize_field",
                                [ Ty.path "move_core_types::vm_status::AbortLocation" ]
                              |),
                              [ __serde_state; M.read (| __field0 |) ]
                            |)
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.get_struct_tuple_field_or_break_match (|
                                    γ,
                                    "core::result::Result::Ok",
                                    0
                                  |) in
                                let __val := M.copy (| γ0_0 |) in
                                __val));
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.get_struct_tuple_field_or_break_match (|
                                    γ,
                                    "core::result::Result::Err",
                                    0
                                  |) in
                                let __err := M.copy (| γ0_0 |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      M.return_ (|
                                        Value.StructTuple
                                          "core::result::Result::Err"
                                          [ M.read (| __err |) ]
                                      |)
                                    |)
                                  |)
                                |)))
                          ]
                        |) in
                      let _ :=
                        M.match_operator (|
                          M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "serde::ser::SerializeTupleVariant",
                                Ty.associated,
                                [],
                                "serialize_field",
                                [ Ty.path "u64" ]
                              |),
                              [ __serde_state; M.read (| __field1 |) ]
                            |)
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.get_struct_tuple_field_or_break_match (|
                                    γ,
                                    "core::result::Result::Ok",
                                    0
                                  |) in
                                let __val := M.copy (| γ0_0 |) in
                                __val));
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.get_struct_tuple_field_or_break_match (|
                                    γ,
                                    "core::result::Result::Err",
                                    0
                                  |) in
                                let __err := M.copy (| γ0_0 |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      M.return_ (|
                                        Value.StructTuple
                                          "core::result::Result::Err"
                                          [ M.read (| __err |) ]
                                      |)
                                    |)
                                  |)
                                |)))
                          ]
                        |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "serde::ser::SerializeTupleVariant",
                            Ty.associated,
                            [],
                            "end",
                            []
                          |),
                          [ M.read (| __serde_state |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.get_struct_record_field_or_break_match (|
                          γ,
                          "move_core_types::vm_status::KeptVMStatus::ExecutionFailure",
                          "location"
                        |) in
                      let γ0_1 :=
                        M.get_struct_record_field_or_break_match (|
                          γ,
                          "move_core_types::vm_status::KeptVMStatus::ExecutionFailure",
                          "function"
                        |) in
                      let γ0_2 :=
                        M.get_struct_record_field_or_break_match (|
                          γ,
                          "move_core_types::vm_status::KeptVMStatus::ExecutionFailure",
                          "code_offset"
                        |) in
                      let location := M.alloc (| γ0_0 |) in
                      let function := M.alloc (| γ0_1 |) in
                      let code_offset := M.alloc (| γ0_2 |) in
                      let __serde_state :=
                        M.copy (|
                          M.match_operator (|
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "serde::ser::Serializer",
                                  __S,
                                  [],
                                  "serialize_struct_variant",
                                  []
                                |),
                                [
                                  M.read (| __serializer |);
                                  M.read (| mk_str "KeptVMStatus" |);
                                  Value.Integer Integer.U32 3;
                                  M.read (| mk_str "ExecutionFailure" |);
                                  BinOp.Panic.add (|
                                    BinOp.Panic.add (|
                                      BinOp.Panic.add (|
                                        Value.Integer Integer.Usize 0,
                                        Value.Integer Integer.Usize 1
                                      |),
                                      Value.Integer Integer.Usize 1
                                    |),
                                    Value.Integer Integer.Usize 1
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.get_struct_tuple_field_or_break_match (|
                                      γ,
                                      "core::result::Result::Ok",
                                      0
                                    |) in
                                  let __val := M.copy (| γ0_0 |) in
                                  __val));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.get_struct_tuple_field_or_break_match (|
                                      γ,
                                      "core::result::Result::Err",
                                      0
                                    |) in
                                  let __err := M.copy (| γ0_0 |) in
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          Value.StructTuple
                                            "core::result::Result::Err"
                                            [ M.read (| __err |) ]
                                        |)
                                      |)
                                    |)
                                  |)))
                            ]
                          |)
                        |) in
                      let _ :=
                        M.match_operator (|
                          M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "serde::ser::SerializeStructVariant",
                                Ty.associated,
                                [],
                                "serialize_field",
                                [ Ty.path "move_core_types::vm_status::AbortLocation" ]
                              |),
                              [ __serde_state; M.read (| mk_str "location" |); M.read (| location |)
                              ]
                            |)
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.get_struct_tuple_field_or_break_match (|
                                    γ,
                                    "core::result::Result::Ok",
                                    0
                                  |) in
                                let __val := M.copy (| γ0_0 |) in
                                __val));
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.get_struct_tuple_field_or_break_match (|
                                    γ,
                                    "core::result::Result::Err",
                                    0
                                  |) in
                                let __err := M.copy (| γ0_0 |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      M.return_ (|
                                        Value.StructTuple
                                          "core::result::Result::Err"
                                          [ M.read (| __err |) ]
                                      |)
                                    |)
                                  |)
                                |)))
                          ]
                        |) in
                      let _ :=
                        M.match_operator (|
                          M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "serde::ser::SerializeStructVariant",
                                Ty.associated,
                                [],
                                "serialize_field",
                                [ Ty.path "u16" ]
                              |),
                              [ __serde_state; M.read (| mk_str "function" |); M.read (| function |)
                              ]
                            |)
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.get_struct_tuple_field_or_break_match (|
                                    γ,
                                    "core::result::Result::Ok",
                                    0
                                  |) in
                                let __val := M.copy (| γ0_0 |) in
                                __val));
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.get_struct_tuple_field_or_break_match (|
                                    γ,
                                    "core::result::Result::Err",
                                    0
                                  |) in
                                let __err := M.copy (| γ0_0 |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      M.return_ (|
                                        Value.StructTuple
                                          "core::result::Result::Err"
                                          [ M.read (| __err |) ]
                                      |)
                                    |)
                                  |)
                                |)))
                          ]
                        |) in
                      let _ :=
                        M.match_operator (|
                          M.alloc (|
                            M.call_closure (|
                              M.get_trait_method (|
                                "serde::ser::SerializeStructVariant",
                                Ty.associated,
                                [],
                                "serialize_field",
                                [ Ty.path "u16" ]
                              |),
                              [
                                __serde_state;
                                M.read (| mk_str "code_offset" |);
                                M.read (| code_offset |)
                              ]
                            |)
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.get_struct_tuple_field_or_break_match (|
                                    γ,
                                    "core::result::Result::Ok",
                                    0
                                  |) in
                                let __val := M.copy (| γ0_0 |) in
                                __val));
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.get_struct_tuple_field_or_break_match (|
                                    γ,
                                    "core::result::Result::Err",
                                    0
                                  |) in
                                let __err := M.copy (| γ0_0 |) in
                                M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      M.return_ (|
                                        Value.StructTuple
                                          "core::result::Result::Err"
                                          [ M.read (| __err |) ]
                                      |)
                                    |)
                                  |)
                                |)))
                          ]
                        |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "serde::ser::SerializeStructVariant",
                            Ty.associated,
                            [],
                            "end",
                            []
                          |),
                          [ M.read (| __serde_state |) ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "serde::ser::Serializer",
                            __S,
                            [],
                            "serialize_unit_variant",
                            []
                          |),
                          [
                            M.read (| __serializer |);
                            M.read (| mk_str "KeptVMStatus" |);
                            Value.Integer Integer.U32 4;
                            M.read (| mk_str "MiscellaneousError" |)
                          ]
                        |)
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "serde::ser::Serialize"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("serialize", InstanceField.Method serialize) ].
    End Impl_serde_ser_Serialize_for_move_core_types_vm_status_KeptVMStatus.
  End underscore.
  End Wrap_underscore_3.
  Import Wrap_underscore_3.
  
  Module Wrap_underscore_4.
  Module underscore.
    Module Impl_serde_de_Deserialize_for_move_core_types_vm_status_KeptVMStatus.
      Definition Self : Ty.t := Ty.path "move_core_types::vm_status::KeptVMStatus".
      
      (* Deserialize *)
      Definition deserialize (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ __D ], [ __deserializer ] =>
          ltac:(M.monadic
            (let __deserializer := M.alloc (| __deserializer |) in
            M.call_closure (|
              M.get_trait_method (|
                "serde::de::Deserializer",
                __D,
                [],
                "deserialize_enum",
                [ Ty.path "move_core_types::vm_status::_'3::deserialize::__Visitor" ]
              |),
              [
                M.read (| __deserializer |);
                M.read (| mk_str "KeptVMStatus" |);
                M.read (|
                  M.get_constant (| "move_core_types::vm_status::_'3::deserialize::VARIANTS" |)
                |);
                Value.StructRecord
                  "move_core_types::vm_status::_'3::deserialize::__Visitor"
                  [
                    ("marker", Value.StructTuple "core::marker::PhantomData" []);
                    ("lifetime", Value.StructTuple "core::marker::PhantomData" [])
                  ]
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "serde::de::Deserialize"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("deserialize", InstanceField.Method deserialize) ].
    End Impl_serde_de_Deserialize_for_move_core_types_vm_status_KeptVMStatus.
  End underscore.
  End Wrap_underscore_4.
  Import Wrap_underscore_4.
  
  Module Impl_move_core_types_vm_status_KeptVMStatus.
    Definition Self : Ty.t := Ty.path "move_core_types::vm_status::KeptVMStatus".
    
    (*
        pub fn is_success(&self) -> bool {
            matches!(self, KeptVMStatus::Executed)
        }
    *)
    Definition is_success (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (| Value.Bool true |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Bool false |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_is_success : M.IsAssociatedFunction Self "is_success" is_success.
  End Impl_move_core_types_vm_status_KeptVMStatus.
  
  Axiom DiscardedVMStatus :
    (Ty.path "move_core_types::vm_status::DiscardedVMStatus") =
      (Ty.path "move_core_types::vm_status::StatusCode").
  
  (*
  Enum AbortLocation
  {
    ty_params := [];
    variants :=
      [
        {
          name := "Module";
          item := StructTuple [ Ty.path "move_core_types::language_storage::ModuleId" ];
          discriminant := None;
        };
        {
          name := "Script";
          item := StructTuple [];
          discriminant := None;
        }
      ];
  }
  *)
  
  Module Impl_core_clone_Clone_for_move_core_types_vm_status_AbortLocation.
    Definition Self : Ty.t := Ty.path "move_core_types::vm_status::AbortLocation".
    
    (* Clone *)
    Definition clone (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::vm_status::AbortLocation::Module",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_core_types::vm_status::AbortLocation::Module"
                        [
                          M.call_closure (|
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.path "move_core_types::language_storage::ModuleId",
                              [],
                              "clone",
                              []
                            |),
                            [ M.read (| __self_0 |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (|
                      Value.StructTuple "move_core_types::vm_status::AbortLocation::Script" []
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_move_core_types_vm_status_AbortLocation.
  
  Module Impl_core_marker_StructuralPartialEq_for_move_core_types_vm_status_AbortLocation.
    Definition Self : Ty.t := Ty.path "move_core_types::vm_status::AbortLocation".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_move_core_types_vm_status_AbortLocation.
  
  Module Impl_core_cmp_PartialEq_for_move_core_types_vm_status_AbortLocation.
    Definition Self : Ty.t := Ty.path "move_core_types::vm_status::AbortLocation".
    
    (* PartialEq *)
    Definition eq (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            let __self_tag :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [ Ty.path "move_core_types::vm_status::AbortLocation" ]
                  |),
                  [ M.read (| self |) ]
                |)
              |) in
            let __arg1_tag :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [ Ty.path "move_core_types::vm_status::AbortLocation" ]
                  |),
                  [ M.read (| other |) ]
                |)
              |) in
            M.alloc (|
              LogicalOp.and (|
                BinOp.Pure.eq (M.read (| __self_tag |)) (M.read (| __arg1_tag |)),
                ltac:(M.monadic
                  (M.read (|
                    M.match_operator (|
                      M.alloc (| Value.Tuple [ M.read (| self |); M.read (| other |) ] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.get_tuple_field γ 0 in
                            let γ0_1 := M.get_tuple_field γ 1 in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ0_0,
                                "move_core_types::vm_status::AbortLocation::Module",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ0_1,
                                "move_core_types::vm_status::AbortLocation::Module",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.path "move_core_types::language_storage::ModuleId",
                                  [ Ty.path "move_core_types::language_storage::ModuleId" ],
                                  "eq",
                                  []
                                |),
                                [ M.read (| __self_0 |); M.read (| __arg1_0 |) ]
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Bool true |)))
                      ]
                    |)
                  |)))
              |)
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_for_move_core_types_vm_status_AbortLocation.
  
  Module Impl_core_marker_StructuralEq_for_move_core_types_vm_status_AbortLocation.
    Definition Self : Ty.t := Ty.path "move_core_types::vm_status::AbortLocation".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralEq_for_move_core_types_vm_status_AbortLocation.
  
  Module Impl_core_cmp_Eq_for_move_core_types_vm_status_AbortLocation.
    Definition Self : Ty.t := Ty.path "move_core_types::vm_status::AbortLocation".
    
    (* Eq *)
    Definition assert_receiver_is_total_eq (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Value.DeclaredButUndefined,
              [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_move_core_types_vm_status_AbortLocation.
  
  Module Impl_core_cmp_PartialOrd_for_move_core_types_vm_status_AbortLocation.
    Definition Self : Ty.t := Ty.path "move_core_types::vm_status::AbortLocation".
    
    (* PartialOrd *)
    Definition partial_cmp (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            let __self_tag :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [ Ty.path "move_core_types::vm_status::AbortLocation" ]
                  |),
                  [ M.read (| self |) ]
                |)
              |) in
            let __arg1_tag :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [ Ty.path "move_core_types::vm_status::AbortLocation" ]
                  |),
                  [ M.read (| other |) ]
                |)
              |) in
            M.match_operator (|
              M.alloc (| Value.Tuple [ M.read (| self |); M.read (| other |) ] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.get_tuple_field γ 0 in
                    let γ0_1 := M.get_tuple_field γ 1 in
                    let γ0_0 := M.read (| γ0_0 |) in
                    let γ2_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ0_0,
                        "move_core_types::vm_status::AbortLocation::Module",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ2_0 |) in
                    let γ0_1 := M.read (| γ0_1 |) in
                    let γ2_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ0_1,
                        "move_core_types::vm_status::AbortLocation::Module",
                        0
                      |) in
                    let __arg1_0 := M.alloc (| γ2_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::cmp::PartialOrd",
                          Ty.path "move_core_types::language_storage::ModuleId",
                          [ Ty.path "move_core_types::language_storage::ModuleId" ],
                          "partial_cmp",
                          []
                        |),
                        [ M.read (| __self_0 |); M.read (| __arg1_0 |) ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::cmp::PartialOrd",
                          Ty.path "isize",
                          [ Ty.path "isize" ],
                          "partial_cmp",
                          []
                        |),
                        [ __self_tag; __arg1_tag ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialOrd"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("partial_cmp", InstanceField.Method partial_cmp) ].
  End Impl_core_cmp_PartialOrd_for_move_core_types_vm_status_AbortLocation.
  
  Module Impl_core_cmp_Ord_for_move_core_types_vm_status_AbortLocation.
    Definition Self : Ty.t := Ty.path "move_core_types::vm_status::AbortLocation".
    
    (* Ord *)
    Definition cmp (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            let __self_tag :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [ Ty.path "move_core_types::vm_status::AbortLocation" ]
                  |),
                  [ M.read (| self |) ]
                |)
              |) in
            let __arg1_tag :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [ Ty.path "move_core_types::vm_status::AbortLocation" ]
                  |),
                  [ M.read (| other |) ]
                |)
              |) in
            M.match_operator (|
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (| "core::cmp::Ord", Ty.path "isize", [], "cmp", [] |),
                  [ __self_tag; __arg1_tag ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      M.alloc (| Value.Tuple [ M.read (| self |); M.read (| other |) ] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.get_tuple_field γ 0 in
                            let γ0_1 := M.get_tuple_field γ 1 in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ0_0,
                                "move_core_types::vm_status::AbortLocation::Module",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ0_1,
                                "move_core_types::vm_status::AbortLocation::Module",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::cmp::Ord",
                                  Ty.path "move_core_types::language_storage::ModuleId",
                                  [],
                                  "cmp",
                                  []
                                |),
                                [ M.read (| __self_0 |); M.read (| __arg1_0 |) ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (| Value.StructTuple "core::cmp::Ordering::Equal" [] |)))
                      ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let cmp := M.copy (| γ |) in
                    cmp))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Ord"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("cmp", InstanceField.Method cmp) ].
  End Impl_core_cmp_Ord_for_move_core_types_vm_status_AbortLocation.
  
  Module Impl_core_hash_Hash_for_move_core_types_vm_status_AbortLocation.
    Definition Self : Ty.t := Ty.path "move_core_types::vm_status::AbortLocation".
    
    (* Hash *)
    Definition hash (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ __H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let state := M.alloc (| state |) in
          M.read (|
            let __self_tag :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [ Ty.path "move_core_types::vm_status::AbortLocation" ]
                  |),
                  [ M.read (| self |) ]
                |)
              |) in
            let _ :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (| "core::hash::Hash", Ty.path "isize", [], "hash", [ __H ] |),
                  [ __self_tag; M.read (| state |) ]
                |)
              |) in
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::vm_status::AbortLocation::Module",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.path "move_core_types::language_storage::ModuleId",
                          [],
                          "hash",
                          [ __H ]
                        |),
                        [ M.read (| __self_0 |); M.read (| state |) ]
                      |)
                    |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::hash::Hash"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("hash", InstanceField.Method hash) ].
  End Impl_core_hash_Hash_for_move_core_types_vm_status_AbortLocation.
  
  Module Wrap_underscore_5.
  Module underscore.
    Module Impl_serde_ser_Serialize_for_move_core_types_vm_status_AbortLocation.
      Definition Self : Ty.t := Ty.path "move_core_types::vm_status::AbortLocation".
      
      (* Serialize *)
      Definition serialize (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ __S ], [ self; __serializer ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let __serializer := M.alloc (| __serializer |) in
            M.read (|
              M.match_operator (|
                M.read (| self |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.get_struct_tuple_field_or_break_match (|
                          γ,
                          "move_core_types::vm_status::AbortLocation::Module",
                          0
                        |) in
                      let __field0 := M.alloc (| γ0_0 |) in
                      M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "serde::ser::Serializer",
                            __S,
                            [],
                            "serialize_newtype_variant",
                            [ Ty.path "move_core_types::language_storage::ModuleId" ]
                          |),
                          [
                            M.read (| __serializer |);
                            M.read (| mk_str "AbortLocation" |);
                            Value.Integer Integer.U32 0;
                            M.read (| mk_str "Module" |);
                            M.read (| __field0 |)
                          ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (M.alloc (|
                        M.call_closure (|
                          M.get_trait_method (|
                            "serde::ser::Serializer",
                            __S,
                            [],
                            "serialize_unit_variant",
                            []
                          |),
                          [
                            M.read (| __serializer |);
                            M.read (| mk_str "AbortLocation" |);
                            Value.Integer Integer.U32 1;
                            M.read (| mk_str "Script" |)
                          ]
                        |)
                      |)))
                ]
              |)
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "serde::ser::Serialize"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("serialize", InstanceField.Method serialize) ].
    End Impl_serde_ser_Serialize_for_move_core_types_vm_status_AbortLocation.
  End underscore.
  End Wrap_underscore_5.
  Import Wrap_underscore_5.
  
  Module Wrap_underscore_6.
  Module underscore.
    Module Impl_serde_de_Deserialize_for_move_core_types_vm_status_AbortLocation.
      Definition Self : Ty.t := Ty.path "move_core_types::vm_status::AbortLocation".
      
      (* Deserialize *)
      Definition deserialize (τ : list Ty.t) (α : list Value.t) : M :=
        match τ, α with
        | [ __D ], [ __deserializer ] =>
          ltac:(M.monadic
            (let __deserializer := M.alloc (| __deserializer |) in
            M.call_closure (|
              M.get_trait_method (|
                "serde::de::Deserializer",
                __D,
                [],
                "deserialize_enum",
                [ Ty.path "move_core_types::vm_status::_'5::deserialize::__Visitor" ]
              |),
              [
                M.read (| __deserializer |);
                M.read (| mk_str "AbortLocation" |);
                M.read (|
                  M.get_constant (| "move_core_types::vm_status::_'5::deserialize::VARIANTS" |)
                |);
                Value.StructRecord
                  "move_core_types::vm_status::_'5::deserialize::__Visitor"
                  [
                    ("marker", Value.StructTuple "core::marker::PhantomData" []);
                    ("lifetime", Value.StructTuple "core::marker::PhantomData" [])
                  ]
              ]
            |)))
        | _, _ => M.impossible
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "serde::de::Deserialize"
          Self
          (* Trait polymorphic types *) []
          (* Instance *) [ ("deserialize", InstanceField.Method deserialize) ].
    End Impl_serde_de_Deserialize_for_move_core_types_vm_status_AbortLocation.
  End underscore.
  End Wrap_underscore_6.
  Import Wrap_underscore_6.
  
  (*
  Enum StatusType
  {
    ty_params := [];
    variants :=
      [
        {
          name := "Validation";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "Verification";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "InvariantViolation";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "Deserialization";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "Execution";
          item := StructTuple [];
          discriminant := None;
        };
        {
          name := "Unknown";
          item := StructTuple [];
          discriminant := None;
        }
      ];
  }
  *)
  
  Module Impl_core_clone_Clone_for_move_core_types_vm_status_StatusType.
    Definition Self : Ty.t := Ty.path "move_core_types::vm_status::StatusType".
    
    (* Clone *)
    Definition clone (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (|
                      Value.StructTuple "move_core_types::vm_status::StatusType::Validation" []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (|
                      Value.StructTuple "move_core_types::vm_status::StatusType::Verification" []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_core_types::vm_status::StatusType::InvariantViolation"
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (|
                      Value.StructTuple "move_core_types::vm_status::StatusType::Deserialization" []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (|
                      Value.StructTuple "move_core_types::vm_status::StatusType::Execution" []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (|
                      Value.StructTuple "move_core_types::vm_status::StatusType::Unknown" []
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_move_core_types_vm_status_StatusType.
  
  Module Impl_core_marker_StructuralPartialEq_for_move_core_types_vm_status_StatusType.
    Definition Self : Ty.t := Ty.path "move_core_types::vm_status::StatusType".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_move_core_types_vm_status_StatusType.
  
  Module Impl_core_cmp_PartialEq_for_move_core_types_vm_status_StatusType.
    Definition Self : Ty.t := Ty.path "move_core_types::vm_status::StatusType".
    
    (* PartialEq *)
    Definition eq (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            let __self_tag :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [ Ty.path "move_core_types::vm_status::StatusType" ]
                  |),
                  [ M.read (| self |) ]
                |)
              |) in
            let __arg1_tag :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [ Ty.path "move_core_types::vm_status::StatusType" ]
                  |),
                  [ M.read (| other |) ]
                |)
              |) in
            M.alloc (| BinOp.Pure.eq (M.read (| __self_tag |)) (M.read (| __arg1_tag |)) |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_for_move_core_types_vm_status_StatusType.
  
  Module Impl_core_marker_StructuralEq_for_move_core_types_vm_status_StatusType.
    Definition Self : Ty.t := Ty.path "move_core_types::vm_status::StatusType".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralEq_for_move_core_types_vm_status_StatusType.
  
  Module Impl_core_cmp_Eq_for_move_core_types_vm_status_StatusType.
    Definition Self : Ty.t := Ty.path "move_core_types::vm_status::StatusType".
    
    (* Eq *)
    Definition assert_receiver_is_total_eq (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.Tuple []))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_move_core_types_vm_status_StatusType.
  
  Module Impl_core_fmt_Debug_for_move_core_types_vm_status_StatusType.
    Definition Self : Ty.t := Ty.path "move_core_types::vm_status::StatusType".
    
    (* Debug *)
    Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_str", [] |),
            [
              M.read (| f |);
              M.read (|
                M.match_operator (|
                  self,
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "Validation" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "Verification" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "InvariantViolation" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "Deserialization" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "Execution" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "Unknown" |) |)))
                  ]
                |)
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_move_core_types_vm_status_StatusType.
  
  Module Impl_core_hash_Hash_for_move_core_types_vm_status_StatusType.
    Definition Self : Ty.t := Ty.path "move_core_types::vm_status::StatusType".
    
    (* Hash *)
    Definition hash (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ __H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let state := M.alloc (| state |) in
          M.read (|
            let __self_tag :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [ Ty.path "move_core_types::vm_status::StatusType" ]
                  |),
                  [ M.read (| self |) ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                M.get_trait_method (| "core::hash::Hash", Ty.path "isize", [], "hash", [ __H ] |),
                [ __self_tag; M.read (| state |) ]
              |)
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::hash::Hash"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("hash", InstanceField.Method hash) ].
  End Impl_core_hash_Hash_for_move_core_types_vm_status_StatusType.
  
  Module Impl_move_core_types_vm_status_VMStatus.
    Definition Self : Ty.t := Ty.path "move_core_types::vm_status::VMStatus".
    
    (*
        pub fn status_code(&self) -> StatusCode {
            match self {
                Self::Executed => StatusCode::EXECUTED,
                Self::MoveAbort(_, _) => StatusCode::ABORTED,
                Self::ExecutionFailure { status_code, .. } => *status_code,
                Self::Error(code) => {
                    let code = *code;
                    debug_assert!(code != StatusCode::EXECUTED);
                    debug_assert!(code != StatusCode::ABORTED);
                    code
                }
            }
        }
    *)
    Definition status_code (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (|
                      Value.StructTuple "move_core_types::vm_status::StatusCode::EXECUTED" []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::vm_status::VMStatus::MoveAbort",
                        0
                      |) in
                    let γ1_1 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::vm_status::VMStatus::MoveAbort",
                        1
                      |) in
                    M.alloc (|
                      Value.StructTuple "move_core_types::vm_status::StatusCode::ABORTED" []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_record_field_or_break_match (|
                        γ,
                        "move_core_types::vm_status::VMStatus::ExecutionFailure",
                        "status_code"
                      |) in
                    let status_code := M.alloc (| γ1_0 |) in
                    M.read (| status_code |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::vm_status::VMStatus::Error",
                        0
                      |) in
                    let code := M.alloc (| γ1_0 |) in
                    let code := M.copy (| M.read (| code |) |) in
                    let _ :=
                      M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ := M.use (M.alloc (| Value.Bool true |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              let _ :=
                                M.match_operator (|
                                  M.alloc (| Value.Tuple [] |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ :=
                                          M.use
                                            (M.alloc (|
                                              UnOp.Pure.not
                                                (M.call_closure (|
                                                  M.get_trait_method (|
                                                    "core::cmp::PartialEq",
                                                    Ty.path
                                                      "move_core_types::vm_status::StatusCode",
                                                    [
                                                      Ty.path
                                                        "move_core_types::vm_status::StatusCode"
                                                    ],
                                                    "ne",
                                                    []
                                                  |),
                                                  [
                                                    code;
                                                    M.alloc (|
                                                      Value.StructTuple
                                                        "move_core_types::vm_status::StatusCode::EXECUTED"
                                                        []
                                                    |)
                                                  ]
                                                |))
                                            |)) in
                                        let _ :=
                                          M.is_constant_or_break_match (|
                                            M.read (| γ |),
                                            Value.Bool true
                                          |) in
                                        M.alloc (|
                                          M.never_to_any (|
                                            M.call_closure (|
                                              M.get_function (| "core::panicking::panic", [] |),
                                              [
                                                M.read (|
                                                  mk_str
                                                    "assertion failed: code != StatusCode::EXECUTED"
                                                |)
                                              ]
                                            |)
                                          |)
                                        |)));
                                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                  ]
                                |) in
                              M.alloc (| Value.Tuple [] |)));
                          fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                        ]
                      |) in
                    let _ :=
                      M.match_operator (|
                        M.alloc (| Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ := M.use (M.alloc (| Value.Bool true |)) in
                              let _ :=
                                M.is_constant_or_break_match (|
                                  M.read (| γ |),
                                  Value.Bool true
                                |) in
                              let _ :=
                                M.match_operator (|
                                  M.alloc (| Value.Tuple [] |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ :=
                                          M.use
                                            (M.alloc (|
                                              UnOp.Pure.not
                                                (M.call_closure (|
                                                  M.get_trait_method (|
                                                    "core::cmp::PartialEq",
                                                    Ty.path
                                                      "move_core_types::vm_status::StatusCode",
                                                    [
                                                      Ty.path
                                                        "move_core_types::vm_status::StatusCode"
                                                    ],
                                                    "ne",
                                                    []
                                                  |),
                                                  [
                                                    code;
                                                    M.alloc (|
                                                      Value.StructTuple
                                                        "move_core_types::vm_status::StatusCode::ABORTED"
                                                        []
                                                    |)
                                                  ]
                                                |))
                                            |)) in
                                        let _ :=
                                          M.is_constant_or_break_match (|
                                            M.read (| γ |),
                                            Value.Bool true
                                          |) in
                                        M.alloc (|
                                          M.never_to_any (|
                                            M.call_closure (|
                                              M.get_function (| "core::panicking::panic", [] |),
                                              [
                                                M.read (|
                                                  mk_str
                                                    "assertion failed: code != StatusCode::ABORTED"
                                                |)
                                              ]
                                            |)
                                          |)
                                        |)));
                                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                  ]
                                |) in
                              M.alloc (| Value.Tuple [] |)));
                          fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                        ]
                      |) in
                    code))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_status_code : M.IsAssociatedFunction Self "status_code" status_code.
    
    (*
        pub fn move_abort_code(&self) -> Option<u64> {
            match self {
                Self::MoveAbort(_, code) => Some( *code),
                Self::Error(_) | Self::ExecutionFailure { .. } | Self::Executed => None,
            }
        }
    *)
    Definition move_abort_code (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::vm_status::VMStatus::MoveAbort",
                        0
                      |) in
                    let γ1_1 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::vm_status::VMStatus::MoveAbort",
                        1
                      |) in
                    let code := M.alloc (| γ1_1 |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        [ M.read (| M.read (| code |) |) ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.find_or_pattern (|
                      γ,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.read (| γ |) in
                            let γ1_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ,
                                "move_core_types::vm_status::VMStatus::Error",
                                0
                              |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.read (| γ |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.read (| γ |) in
                            Value.Tuple []))
                      ],
                      M.closure
                        (fun γ =>
                          ltac:(M.monadic
                            match γ with
                            | [] => M.alloc (| Value.StructTuple "core::option::Option::None" [] |)
                            | _ => M.impossible (||)
                            end))
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_move_abort_code :
      M.IsAssociatedFunction Self "move_abort_code" move_abort_code.
    
    (*
        pub fn status_type(&self) -> StatusType {
            self.status_code().status_type()
        }
    *)
    Definition status_type (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            M.get_associated_function (|
              Ty.path "move_core_types::vm_status::StatusCode",
              "status_type",
              []
            |),
            [
              M.call_closure (|
                M.get_associated_function (|
                  Ty.path "move_core_types::vm_status::VMStatus",
                  "status_code",
                  []
                |),
                [ M.read (| self |) ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_status_type : M.IsAssociatedFunction Self "status_type" status_type.
    
    (*
        pub fn keep_or_discard(self) -> Result<KeptVMStatus, DiscardedVMStatus> {
            match self {
                VMStatus::Executed => Ok(KeptVMStatus::Executed),
                VMStatus::MoveAbort(location, code) => Ok(KeptVMStatus::MoveAbort(location, code)),
                VMStatus::ExecutionFailure {
                    status_code: StatusCode::OUT_OF_GAS,
                    ..
                }
                | VMStatus::Error(StatusCode::OUT_OF_GAS) => Ok(KeptVMStatus::OutOfGas),
    
                VMStatus::ExecutionFailure {
                    status_code:
                        StatusCode::EXECUTION_LIMIT_REACHED
                        | StatusCode::IO_LIMIT_REACHED
                        | StatusCode::STORAGE_LIMIT_REACHED,
                    ..
                }
                | VMStatus::Error(
                    StatusCode::EXECUTION_LIMIT_REACHED
                    | StatusCode::IO_LIMIT_REACHED
                    | StatusCode::STORAGE_LIMIT_REACHED,
                ) => Ok(KeptVMStatus::MiscellaneousError),
    
                VMStatus::ExecutionFailure {
                    status_code: _status_code,
                    location,
                    function,
                    code_offset,
                } => Ok(KeptVMStatus::ExecutionFailure {
                    location,
                    function,
                    code_offset,
                }),
                VMStatus::Error(code) => {
                    match code.status_type() {
                        // Any unknown error should be discarded
                        StatusType::Unknown => Err(code),
                        // Any error that is a validation status (i.e. an error arising from the prologue)
                        // causes the transaction to not be included.
                        StatusType::Validation => Err(code),
                        // If the VM encountered an invalid internal state, we should discard the transaction.
                        StatusType::InvariantViolation => Err(code),
                        // A transaction that publishes code that cannot be verified will be charged.
                        StatusType::Verification => Ok(KeptVMStatus::MiscellaneousError),
                        // If we are able to decode the`SignedTransaction`, but failed to decode
                        // `SingedTransaction.raw_transaction.payload` (i.e., the transaction script),
                        // there should be a charge made to that user's account for the gas fees related
                        // to decoding, running the prologue etc.
                        StatusType::Deserialization => Ok(KeptVMStatus::MiscellaneousError),
                        // Any error encountered during the execution of the transaction will charge gas.
                        StatusType::Execution => Ok(KeptVMStatus::ExecutionFailure {
                            location: AbortLocation::Script,
                            function: 0,
                            code_offset: 0,
                        }),
                    }
                }
            }
        }
    *)
    Definition keep_or_discard (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [ Value.StructTuple "move_core_types::vm_status::KeptVMStatus::Executed" []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::vm_status::VMStatus::MoveAbort",
                        0
                      |) in
                    let γ0_1 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::vm_status::VMStatus::MoveAbort",
                        1
                      |) in
                    let location := M.copy (| γ0_0 |) in
                    let code := M.copy (| γ0_1 |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::KeptVMStatus::MoveAbort"
                            [ M.read (| location |); M.read (| code |) ]
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.find_or_pattern (|
                      γ,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.get_struct_record_field_or_break_match (|
                                γ,
                                "move_core_types::vm_status::VMStatus::ExecutionFailure",
                                "status_code"
                              |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ,
                                "move_core_types::vm_status::VMStatus::Error",
                                0
                              |) in
                            Value.Tuple []))
                      ],
                      M.closure
                        (fun γ =>
                          ltac:(M.monadic
                            match γ with
                            | [] =>
                              M.alloc (|
                                Value.StructTuple
                                  "core::result::Result::Ok"
                                  [
                                    Value.StructTuple
                                      "move_core_types::vm_status::KeptVMStatus::OutOfGas"
                                      []
                                  ]
                              |)
                            | _ => M.impossible (||)
                            end))
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.find_or_pattern (|
                      γ,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.get_struct_record_field_or_break_match (|
                                γ,
                                "move_core_types::vm_status::VMStatus::ExecutionFailure",
                                "status_code"
                              |) in
                            M.find_or_pattern (|
                              γ0_0,
                              [
                                fun γ => ltac:(M.monadic (Value.Tuple []));
                                fun γ => ltac:(M.monadic (Value.Tuple []));
                                fun γ => ltac:(M.monadic (Value.Tuple []))
                              ],
                              M.closure
                                (fun γ =>
                                  ltac:(M.monadic
                                    match γ with
                                    | [] => Value.Tuple []
                                    | _ => M.impossible (||)
                                    end))
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.get_struct_tuple_field_or_break_match (|
                                γ,
                                "move_core_types::vm_status::VMStatus::Error",
                                0
                              |) in
                            M.find_or_pattern (|
                              γ0_0,
                              [
                                fun γ => ltac:(M.monadic (Value.Tuple []));
                                fun γ => ltac:(M.monadic (Value.Tuple []));
                                fun γ => ltac:(M.monadic (Value.Tuple []))
                              ],
                              M.closure
                                (fun γ =>
                                  ltac:(M.monadic
                                    match γ with
                                    | [] => Value.Tuple []
                                    | _ => M.impossible (||)
                                    end))
                            |)))
                      ],
                      M.closure
                        (fun γ =>
                          ltac:(M.monadic
                            match γ with
                            | [] =>
                              M.alloc (|
                                Value.StructTuple
                                  "core::result::Result::Ok"
                                  [
                                    Value.StructTuple
                                      "move_core_types::vm_status::KeptVMStatus::MiscellaneousError"
                                      []
                                  ]
                              |)
                            | _ => M.impossible (||)
                            end))
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.get_struct_record_field_or_break_match (|
                        γ,
                        "move_core_types::vm_status::VMStatus::ExecutionFailure",
                        "status_code"
                      |) in
                    let γ0_1 :=
                      M.get_struct_record_field_or_break_match (|
                        γ,
                        "move_core_types::vm_status::VMStatus::ExecutionFailure",
                        "location"
                      |) in
                    let γ0_2 :=
                      M.get_struct_record_field_or_break_match (|
                        γ,
                        "move_core_types::vm_status::VMStatus::ExecutionFailure",
                        "function"
                      |) in
                    let γ0_3 :=
                      M.get_struct_record_field_or_break_match (|
                        γ,
                        "move_core_types::vm_status::VMStatus::ExecutionFailure",
                        "code_offset"
                      |) in
                    let _status_code := M.copy (| γ0_0 |) in
                    let location := M.copy (| γ0_1 |) in
                    let function := M.copy (| γ0_2 |) in
                    let code_offset := M.copy (| γ0_3 |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructRecord
                            "move_core_types::vm_status::KeptVMStatus::ExecutionFailure"
                            [
                              ("location", M.read (| location |));
                              ("function", M.read (| function |));
                              ("code_offset", M.read (| code_offset |))
                            ]
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::vm_status::VMStatus::Error",
                        0
                      |) in
                    let code := M.copy (| γ0_0 |) in
                    M.match_operator (|
                      M.alloc (|
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.path "move_core_types::vm_status::StatusCode",
                            "status_type",
                            []
                          |),
                          [ M.read (| code |) ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              Value.StructTuple "core::result::Result::Err" [ M.read (| code |) ]
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              Value.StructTuple "core::result::Result::Err" [ M.read (| code |) ]
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              Value.StructTuple "core::result::Result::Err" [ M.read (| code |) ]
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              Value.StructTuple
                                "core::result::Result::Ok"
                                [
                                  Value.StructTuple
                                    "move_core_types::vm_status::KeptVMStatus::MiscellaneousError"
                                    []
                                ]
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              Value.StructTuple
                                "core::result::Result::Ok"
                                [
                                  Value.StructTuple
                                    "move_core_types::vm_status::KeptVMStatus::MiscellaneousError"
                                    []
                                ]
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              Value.StructTuple
                                "core::result::Result::Ok"
                                [
                                  Value.StructRecord
                                    "move_core_types::vm_status::KeptVMStatus::ExecutionFailure"
                                    [
                                      ("location",
                                        Value.StructTuple
                                          "move_core_types::vm_status::AbortLocation::Script"
                                          []);
                                      ("function", Value.Integer Integer.U16 0);
                                      ("code_offset", Value.Integer Integer.U16 0)
                                    ]
                                ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_keep_or_discard :
      M.IsAssociatedFunction Self "keep_or_discard" keep_or_discard.
  End Impl_move_core_types_vm_status_VMStatus.
  
  Module Impl_core_fmt_Display_for_move_core_types_vm_status_StatusType.
    Definition Self : Ty.t := Ty.path "move_core_types::vm_status::StatusType".
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            let string = match self {
                StatusType::Validation => "Validation",
                StatusType::Verification => "Verification",
                StatusType::InvariantViolation => "Invariant violation",
                StatusType::Deserialization => "Deserialization",
                StatusType::Execution => "Execution",
                StatusType::Unknown => "Unknown",
            };
            write!(f, "{}", string)
        }
    *)
    Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.read (|
            let string :=
              M.copy (|
                M.match_operator (|
                  self,
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        mk_str "Validation"));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "Verification" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "Invariant violation" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "Deserialization" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "Execution" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "Unknown" |) |)))
                  ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_fmt", [] |),
                [
                  M.read (| f |);
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "core::fmt::Arguments", "new_v1", [] |),
                    [
                      (* Unsize *)
                      M.pointer_coercion (M.alloc (| Value.Array [ M.read (| mk_str "" |) ] |));
                      (* Unsize *)
                      M.pointer_coercion
                        (M.alloc (|
                          Value.Array
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::fmt::rt::Argument",
                                  "new_display",
                                  [ Ty.apply (Ty.path "&") [ Ty.path "str" ] ]
                                |),
                                [ string ]
                              |)
                            ]
                        |))
                    ]
                  |)
                ]
              |)
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Display"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Display_for_move_core_types_vm_status_StatusType.
  
  Module Impl_core_fmt_Display_for_move_core_types_vm_status_VMStatus.
    Definition Self : Ty.t := Ty.path "move_core_types::vm_status::VMStatus".
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            let status_type = self.status_type();
            let mut status = format!("status {:#?} of type {}", self.status_code(), status_type);
    
            if let VMStatus::MoveAbort(_, code) = self {
                status = format!("{} with sub status {}", status, code);
            }
    
            write!(f, "{}", status)
        }
    *)
    Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.read (|
            let status_type :=
              M.alloc (|
                M.call_closure (|
                  M.get_associated_function (|
                    Ty.path "move_core_types::vm_status::VMStatus",
                    "status_type",
                    []
                  |),
                  [ M.read (| self |) ]
                |)
              |) in
            let status :=
              M.copy (|
                let res :=
                  M.alloc (|
                    M.call_closure (|
                      M.get_function (| "alloc::fmt::format", [] |),
                      [
                        M.call_closure (|
                          M.get_associated_function (|
                            Ty.path "core::fmt::Arguments",
                            "new_v1_formatted",
                            []
                          |),
                          [
                            (* Unsize *)
                            M.pointer_coercion
                              (M.alloc (|
                                Value.Array
                                  [ M.read (| mk_str "status " |); M.read (| mk_str " of type " |) ]
                              |));
                            (* Unsize *)
                            M.pointer_coercion
                              (M.alloc (|
                                Value.Array
                                  [
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.path "core::fmt::rt::Argument",
                                        "new_debug",
                                        [ Ty.path "move_core_types::vm_status::StatusCode" ]
                                      |),
                                      [
                                        M.alloc (|
                                          M.call_closure (|
                                            M.get_associated_function (|
                                              Ty.path "move_core_types::vm_status::VMStatus",
                                              "status_code",
                                              []
                                            |),
                                            [ M.read (| self |) ]
                                          |)
                                        |)
                                      ]
                                    |);
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.path "core::fmt::rt::Argument",
                                        "new_display",
                                        [ Ty.path "move_core_types::vm_status::StatusType" ]
                                      |),
                                      [ status_type ]
                                    |)
                                  ]
                              |));
                            (* Unsize *)
                            M.pointer_coercion
                              (M.alloc (|
                                Value.Array
                                  [
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.path "core::fmt::rt::Placeholder",
                                        "new",
                                        []
                                      |),
                                      [
                                        Value.Integer Integer.Usize 0;
                                        Value.UnicodeChar 32;
                                        Value.StructTuple "core::fmt::rt::Alignment::Unknown" [];
                                        Value.Integer Integer.U32 4;
                                        Value.StructTuple "core::fmt::rt::Count::Implied" [];
                                        Value.StructTuple "core::fmt::rt::Count::Implied" []
                                      ]
                                    |);
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.path "core::fmt::rt::Placeholder",
                                        "new",
                                        []
                                      |),
                                      [
                                        Value.Integer Integer.Usize 1;
                                        Value.UnicodeChar 32;
                                        Value.StructTuple "core::fmt::rt::Alignment::Unknown" [];
                                        Value.Integer Integer.U32 0;
                                        Value.StructTuple "core::fmt::rt::Count::Implied" [];
                                        Value.StructTuple "core::fmt::rt::Count::Implied" []
                                      ]
                                    |)
                                  ]
                              |));
                            M.call_closure (|
                              M.get_associated_function (|
                                Ty.path "core::fmt::rt::UnsafeArg",
                                "new",
                                []
                              |),
                              []
                            |)
                          ]
                        |)
                      ]
                    |)
                  |) in
                res
              |) in
            let _ :=
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := self in
                      let γ := M.read (| γ |) in
                      let γ1_0 :=
                        M.get_struct_tuple_field_or_break_match (|
                          γ,
                          "move_core_types::vm_status::VMStatus::MoveAbort",
                          0
                        |) in
                      let γ1_1 :=
                        M.get_struct_tuple_field_or_break_match (|
                          γ,
                          "move_core_types::vm_status::VMStatus::MoveAbort",
                          1
                        |) in
                      let code := M.alloc (| γ1_1 |) in
                      let _ :=
                        M.write (|
                          status,
                          M.read (|
                            let res :=
                              M.alloc (|
                                M.call_closure (|
                                  M.get_function (| "alloc::fmt::format", [] |),
                                  [
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.path "core::fmt::Arguments",
                                        "new_v1",
                                        []
                                      |),
                                      [
                                        (* Unsize *)
                                        M.pointer_coercion
                                          (M.alloc (|
                                            Value.Array
                                              [
                                                M.read (| mk_str "" |);
                                                M.read (| mk_str " with sub status " |)
                                              ]
                                          |));
                                        (* Unsize *)
                                        M.pointer_coercion
                                          (M.alloc (|
                                            Value.Array
                                              [
                                                M.call_closure (|
                                                  M.get_associated_function (|
                                                    Ty.path "core::fmt::rt::Argument",
                                                    "new_display",
                                                    [ Ty.path "alloc::string::String" ]
                                                  |),
                                                  [ status ]
                                                |);
                                                M.call_closure (|
                                                  M.get_associated_function (|
                                                    Ty.path "core::fmt::rt::Argument",
                                                    "new_display",
                                                    [ Ty.apply (Ty.path "&") [ Ty.path "u64" ] ]
                                                  |),
                                                  [ code ]
                                                |)
                                              ]
                                          |))
                                      ]
                                    |)
                                  ]
                                |)
                              |) in
                            res
                          |)
                        |) in
                      M.alloc (| Value.Tuple [] |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            M.alloc (|
              M.call_closure (|
                M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_fmt", [] |),
                [
                  M.read (| f |);
                  M.call_closure (|
                    M.get_associated_function (| Ty.path "core::fmt::Arguments", "new_v1", [] |),
                    [
                      (* Unsize *)
                      M.pointer_coercion (M.alloc (| Value.Array [ M.read (| mk_str "" |) ] |));
                      (* Unsize *)
                      M.pointer_coercion
                        (M.alloc (|
                          Value.Array
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::fmt::rt::Argument",
                                  "new_display",
                                  [ Ty.path "alloc::string::String" ]
                                |),
                                [ status ]
                              |)
                            ]
                        |))
                    ]
                  |)
                ]
              |)
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Display"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Display_for_move_core_types_vm_status_VMStatus.
  
  Module Impl_core_fmt_Display_for_move_core_types_vm_status_KeptVMStatus.
    Definition Self : Ty.t := Ty.path "move_core_types::vm_status::KeptVMStatus".
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            write!(f, "status ")?;
            match self {
                KeptVMStatus::Executed => write!(f, "EXECUTED"),
                KeptVMStatus::OutOfGas => write!(f, "OUT_OF_GAS"),
                KeptVMStatus::MiscellaneousError => write!(f, "MISCELLANEOUS_ERROR"),
                KeptVMStatus::MoveAbort(location, code) => {
                    write!(f, "ABORTED with code {} in {}", code, location)
                }
                KeptVMStatus::ExecutionFailure {
                    location,
                    function,
                    code_offset,
                } => write!(
                    f,
                    "EXECUTION_FAILURE at bytecode offset {} in function index {} in {}",
                    code_offset, function, location
                ),
            }
        }
    *)
    Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.read (|
            let _ :=
              M.match_operator (|
                M.alloc (|
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::try_trait::Try",
                      Ty.apply
                        (Ty.path "core::result::Result")
                        [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                      [],
                      "branch",
                      []
                    |),
                    [
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (| Value.Array [ M.read (| mk_str "status " |) ] |))
                            ]
                          |)
                        ]
                      |)
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.get_struct_tuple_field_or_break_match (|
                          γ,
                          "core::ops::control_flow::ControlFlow::Break",
                          0
                        |) in
                      let residual := M.copy (| γ0_0 |) in
                      M.alloc (|
                        M.never_to_any (|
                          M.read (|
                            M.return_ (|
                              M.call_closure (|
                                M.get_trait_method (|
                                  "core::ops::try_trait::FromResidual",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path "core::fmt::Error"
                                      ]
                                  ],
                                  "from_residual",
                                  []
                                |),
                                [ M.read (| residual |) ]
                              |)
                            |)
                          |)
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.get_struct_tuple_field_or_break_match (|
                          γ,
                          "core::ops::control_flow::ControlFlow::Continue",
                          0
                        |) in
                      let val := M.copy (| γ0_0 |) in
                      val))
                ]
              |) in
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (| Value.Array [ M.read (| mk_str "EXECUTED" |) ] |))
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (| Value.Array [ M.read (| mk_str "OUT_OF_GAS" |) ] |))
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array [ M.read (| mk_str "MISCELLANEOUS_ERROR" |) ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::vm_status::KeptVMStatus::MoveAbort",
                        0
                      |) in
                    let γ1_1 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::vm_status::KeptVMStatus::MoveAbort",
                        1
                      |) in
                    let location := M.alloc (| γ1_0 |) in
                    let code := M.alloc (| γ1_1 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_v1",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (| mk_str "ABORTED with code " |);
                                      M.read (| mk_str " in " |)
                                    ]
                                |));
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.path "core::fmt::rt::Argument",
                                          "new_display",
                                          [ Ty.apply (Ty.path "&") [ Ty.path "u64" ] ]
                                        |),
                                        [ code ]
                                      |);
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.path "core::fmt::rt::Argument",
                                          "new_display",
                                          [
                                            Ty.apply
                                              (Ty.path "&")
                                              [ Ty.path "move_core_types::vm_status::AbortLocation"
                                              ]
                                          ]
                                        |),
                                        [ location ]
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_record_field_or_break_match (|
                        γ,
                        "move_core_types::vm_status::KeptVMStatus::ExecutionFailure",
                        "location"
                      |) in
                    let γ1_1 :=
                      M.get_struct_record_field_or_break_match (|
                        γ,
                        "move_core_types::vm_status::KeptVMStatus::ExecutionFailure",
                        "function"
                      |) in
                    let γ1_2 :=
                      M.get_struct_record_field_or_break_match (|
                        γ,
                        "move_core_types::vm_status::KeptVMStatus::ExecutionFailure",
                        "code_offset"
                      |) in
                    let location := M.alloc (| γ1_0 |) in
                    let function := M.alloc (| γ1_1 |) in
                    let code_offset := M.alloc (| γ1_2 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_v1",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.read (| mk_str "EXECUTION_FAILURE at bytecode offset " |);
                                      M.read (| mk_str " in function index " |);
                                      M.read (| mk_str " in " |)
                                    ]
                                |));
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.path "core::fmt::rt::Argument",
                                          "new_display",
                                          [ Ty.apply (Ty.path "&") [ Ty.path "u16" ] ]
                                        |),
                                        [ code_offset ]
                                      |);
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.path "core::fmt::rt::Argument",
                                          "new_display",
                                          [ Ty.apply (Ty.path "&") [ Ty.path "u16" ] ]
                                        |),
                                        [ function ]
                                      |);
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.path "core::fmt::rt::Argument",
                                          "new_display",
                                          [
                                            Ty.apply
                                              (Ty.path "&")
                                              [ Ty.path "move_core_types::vm_status::AbortLocation"
                                              ]
                                          ]
                                        |),
                                        [ location ]
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Display"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Display_for_move_core_types_vm_status_KeptVMStatus.
  
  Module Impl_core_fmt_Debug_for_move_core_types_vm_status_VMStatus.
    Definition Self : Ty.t := Ty.path "move_core_types::vm_status::VMStatus".
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            match self {
                VMStatus::Executed => write!(f, "EXECUTED"),
                VMStatus::Error(code) => f.debug_struct("ERROR").field("status_code", code).finish(),
                VMStatus::MoveAbort(location, code) => f
                    .debug_struct("ABORTED")
                    .field("code", code)
                    .field("location", location)
                    .finish(),
                VMStatus::ExecutionFailure {
                    status_code,
                    location,
                    function,
                    code_offset,
                } => f
                    .debug_struct("EXECUTION_FAILURE")
                    .field("status_code", status_code)
                    .field("location", location)
                    .field("function_definition", function)
                    .field("code_offset", code_offset)
                    .finish(),
            }
        }
    *)
    Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (| Value.Array [ M.read (| mk_str "EXECUTED" |) ] |))
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::vm_status::VMStatus::Error",
                        0
                      |) in
                    let code := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::builders::DebugStruct",
                          "finish",
                          []
                        |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::builders::DebugStruct",
                              "field",
                              []
                            |),
                            [
                              M.alloc (|
                                M.call_closure (|
                                  M.get_associated_function (|
                                    Ty.path "core::fmt::Formatter",
                                    "debug_struct",
                                    []
                                  |),
                                  [ M.read (| f |); M.read (| mk_str "ERROR" |) ]
                                |)
                              |);
                              M.read (| mk_str "status_code" |);
                              (* Unsize *) M.pointer_coercion (M.read (| code |))
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::vm_status::VMStatus::MoveAbort",
                        0
                      |) in
                    let γ1_1 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::vm_status::VMStatus::MoveAbort",
                        1
                      |) in
                    let location := M.alloc (| γ1_0 |) in
                    let code := M.alloc (| γ1_1 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::builders::DebugStruct",
                          "finish",
                          []
                        |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::builders::DebugStruct",
                              "field",
                              []
                            |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::fmt::builders::DebugStruct",
                                  "field",
                                  []
                                |),
                                [
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.path "core::fmt::Formatter",
                                        "debug_struct",
                                        []
                                      |),
                                      [ M.read (| f |); M.read (| mk_str "ABORTED" |) ]
                                    |)
                                  |);
                                  M.read (| mk_str "code" |);
                                  (* Unsize *) M.pointer_coercion (M.read (| code |))
                                ]
                              |);
                              M.read (| mk_str "location" |);
                              (* Unsize *) M.pointer_coercion (M.read (| location |))
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_record_field_or_break_match (|
                        γ,
                        "move_core_types::vm_status::VMStatus::ExecutionFailure",
                        "status_code"
                      |) in
                    let γ1_1 :=
                      M.get_struct_record_field_or_break_match (|
                        γ,
                        "move_core_types::vm_status::VMStatus::ExecutionFailure",
                        "location"
                      |) in
                    let γ1_2 :=
                      M.get_struct_record_field_or_break_match (|
                        γ,
                        "move_core_types::vm_status::VMStatus::ExecutionFailure",
                        "function"
                      |) in
                    let γ1_3 :=
                      M.get_struct_record_field_or_break_match (|
                        γ,
                        "move_core_types::vm_status::VMStatus::ExecutionFailure",
                        "code_offset"
                      |) in
                    let status_code := M.alloc (| γ1_0 |) in
                    let location := M.alloc (| γ1_1 |) in
                    let function := M.alloc (| γ1_2 |) in
                    let code_offset := M.alloc (| γ1_3 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::builders::DebugStruct",
                          "finish",
                          []
                        |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::builders::DebugStruct",
                              "field",
                              []
                            |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::fmt::builders::DebugStruct",
                                  "field",
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.path "core::fmt::builders::DebugStruct",
                                      "field",
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.path "core::fmt::builders::DebugStruct",
                                          "field",
                                          []
                                        |),
                                        [
                                          M.alloc (|
                                            M.call_closure (|
                                              M.get_associated_function (|
                                                Ty.path "core::fmt::Formatter",
                                                "debug_struct",
                                                []
                                              |),
                                              [
                                                M.read (| f |);
                                                M.read (| mk_str "EXECUTION_FAILURE" |)
                                              ]
                                            |)
                                          |);
                                          M.read (| mk_str "status_code" |);
                                          (* Unsize *) M.pointer_coercion (M.read (| status_code |))
                                        ]
                                      |);
                                      M.read (| mk_str "location" |);
                                      (* Unsize *) M.pointer_coercion (M.read (| location |))
                                    ]
                                  |);
                                  M.read (| mk_str "function_definition" |);
                                  (* Unsize *) M.pointer_coercion (M.read (| function |))
                                ]
                              |);
                              M.read (| mk_str "code_offset" |);
                              (* Unsize *) M.pointer_coercion (M.read (| code_offset |))
                            ]
                          |)
                        ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_move_core_types_vm_status_VMStatus.
  
  Module Impl_core_fmt_Debug_for_move_core_types_vm_status_KeptVMStatus.
    Definition Self : Ty.t := Ty.path "move_core_types::vm_status::KeptVMStatus".
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            match self {
                KeptVMStatus::Executed => write!(f, "EXECUTED"),
                KeptVMStatus::OutOfGas => write!(f, "OUT_OF_GAS"),
                KeptVMStatus::MoveAbort(location, code) => f
                    .debug_struct("ABORTED")
                    .field("code", code)
                    .field("location", location)
                    .finish(),
                KeptVMStatus::ExecutionFailure {
                    location,
                    function,
                    code_offset,
                } => f
                    .debug_struct("EXECUTION_FAILURE")
                    .field("location", location)
                    .field("function_definition", function)
                    .field("code_offset", code_offset)
                    .finish(),
                KeptVMStatus::MiscellaneousError => write!(f, "MISCELLANEOUS_ERROR"),
            }
        }
    *)
    Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (| Value.Array [ M.read (| mk_str "EXECUTED" |) ] |))
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (| Value.Array [ M.read (| mk_str "OUT_OF_GAS" |) ] |))
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::vm_status::KeptVMStatus::MoveAbort",
                        0
                      |) in
                    let γ1_1 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::vm_status::KeptVMStatus::MoveAbort",
                        1
                      |) in
                    let location := M.alloc (| γ1_0 |) in
                    let code := M.alloc (| γ1_1 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::builders::DebugStruct",
                          "finish",
                          []
                        |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::builders::DebugStruct",
                              "field",
                              []
                            |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::fmt::builders::DebugStruct",
                                  "field",
                                  []
                                |),
                                [
                                  M.alloc (|
                                    M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.path "core::fmt::Formatter",
                                        "debug_struct",
                                        []
                                      |),
                                      [ M.read (| f |); M.read (| mk_str "ABORTED" |) ]
                                    |)
                                  |);
                                  M.read (| mk_str "code" |);
                                  (* Unsize *) M.pointer_coercion (M.read (| code |))
                                ]
                              |);
                              M.read (| mk_str "location" |);
                              (* Unsize *) M.pointer_coercion (M.read (| location |))
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_record_field_or_break_match (|
                        γ,
                        "move_core_types::vm_status::KeptVMStatus::ExecutionFailure",
                        "location"
                      |) in
                    let γ1_1 :=
                      M.get_struct_record_field_or_break_match (|
                        γ,
                        "move_core_types::vm_status::KeptVMStatus::ExecutionFailure",
                        "function"
                      |) in
                    let γ1_2 :=
                      M.get_struct_record_field_or_break_match (|
                        γ,
                        "move_core_types::vm_status::KeptVMStatus::ExecutionFailure",
                        "code_offset"
                      |) in
                    let location := M.alloc (| γ1_0 |) in
                    let function := M.alloc (| γ1_1 |) in
                    let code_offset := M.alloc (| γ1_2 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::builders::DebugStruct",
                          "finish",
                          []
                        |),
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::builders::DebugStruct",
                              "field",
                              []
                            |),
                            [
                              M.call_closure (|
                                M.get_associated_function (|
                                  Ty.path "core::fmt::builders::DebugStruct",
                                  "field",
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    M.get_associated_function (|
                                      Ty.path "core::fmt::builders::DebugStruct",
                                      "field",
                                      []
                                    |),
                                    [
                                      M.alloc (|
                                        M.call_closure (|
                                          M.get_associated_function (|
                                            Ty.path "core::fmt::Formatter",
                                            "debug_struct",
                                            []
                                          |),
                                          [ M.read (| f |); M.read (| mk_str "EXECUTION_FAILURE" |)
                                          ]
                                        |)
                                      |);
                                      M.read (| mk_str "location" |);
                                      (* Unsize *) M.pointer_coercion (M.read (| location |))
                                    ]
                                  |);
                                  M.read (| mk_str "function_definition" |);
                                  (* Unsize *) M.pointer_coercion (M.read (| function |))
                                ]
                              |);
                              M.read (| mk_str "code_offset" |);
                              (* Unsize *) M.pointer_coercion (M.read (| code_offset |))
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array [ M.read (| mk_str "MISCELLANEOUS_ERROR" |) ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_move_core_types_vm_status_KeptVMStatus.
  
  Module Impl_core_fmt_Display_for_move_core_types_vm_status_AbortLocation.
    Definition Self : Ty.t := Ty.path "move_core_types::vm_status::AbortLocation".
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            match self {
                AbortLocation::Script => write!(f, "Script"),
                AbortLocation::Module(id) => write!(f, "{}", id),
            }
        }
    *)
    Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.read (|
            M.match_operator (|
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (| Value.Array [ M.read (| mk_str "Script" |) ] |))
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.get_struct_tuple_field_or_break_match (|
                        γ,
                        "move_core_types::vm_status::AbortLocation::Module",
                        0
                      |) in
                    let id := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          []
                        |),
                        [
                          M.read (| f |);
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_v1",
                              []
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (| Value.Array [ M.read (| mk_str "" |) ] |));
                              (* Unsize *)
                              M.pointer_coercion
                                (M.alloc (|
                                  Value.Array
                                    [
                                      M.call_closure (|
                                        M.get_associated_function (|
                                          Ty.path "core::fmt::rt::Argument",
                                          "new_display",
                                          [
                                            Ty.apply
                                              (Ty.path "&")
                                              [
                                                Ty.path
                                                  "move_core_types::language_storage::ModuleId"
                                              ]
                                          ]
                                        |),
                                        [ id ]
                                      |)
                                    ]
                                |))
                            ]
                          |)
                        ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Display"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Display_for_move_core_types_vm_status_AbortLocation.
  
  Module Impl_core_fmt_Debug_for_move_core_types_vm_status_AbortLocation.
    Definition Self : Ty.t := Ty.path "move_core_types::vm_status::AbortLocation".
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            write!(f, "{}", self)
        }
    *)
    Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_fmt", [] |),
            [
              M.read (| f |);
              M.call_closure (|
                M.get_associated_function (| Ty.path "core::fmt::Arguments", "new_v1", [] |),
                [
                  (* Unsize *)
                  M.pointer_coercion (M.alloc (| Value.Array [ M.read (| mk_str "" |) ] |));
                  (* Unsize *)
                  M.pointer_coercion
                    (M.alloc (|
                      Value.Array
                        [
                          M.call_closure (|
                            M.get_associated_function (|
                              Ty.path "core::fmt::rt::Argument",
                              "new_display",
                              [
                                Ty.apply
                                  (Ty.path "&")
                                  [ Ty.path "move_core_types::vm_status::AbortLocation" ]
                              ]
                            |),
                            [ self ]
                          |)
                        ]
                    |))
                ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_move_core_types_vm_status_AbortLocation.
  
  Module Impl_core_error_Error_for_move_core_types_vm_status_VMStatus.
    Definition Self : Ty.t := Ty.path "move_core_types::vm_status::VMStatus".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::error::Error"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_error_Error_for_move_core_types_vm_status_VMStatus.
  
  Module known_locations.
    Definition value_CORE_ACCOUNT_MODULE_IDENTIFIER : Value.t :=
      M.run
        ltac:(M.monadic
          (let s := M.copy (| mk_str "Account" |) in
          let is_valid :=
            M.alloc (|
              M.call_closure (|
                M.get_function (| "move_core_types::identifier::is_valid", [] |),
                [ M.read (| s |) ]
              |)
            |) in
          let _ :=
            M.get_array_field (|
              M.alloc (|
                Value.Array [ M.read (| mk_str "String is not a valid Move identifier" |) ]
              |),
              M.alloc (| M.rust_cast (UnOp.Pure.not (M.read (| is_valid |))) |)
            |) in
          M.alloc (|
            M.call_closure (|
              M.get_function (|
                "core::intrinsics::transmute",
                [
                  Ty.apply (Ty.path "&") [ Ty.path "str" ];
                  Ty.apply (Ty.path "&") [ Ty.path "move_core_types::identifier::IdentStr" ]
                ]
              |),
              [ M.read (| s |) ]
            |)
          |))).
    
    Definition value_CORE_ACCOUNT_MODULE : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "once_cell::sync::Lazy")
                    [
                      Ty.path "move_core_types::language_storage::ModuleId";
                      Ty.function [] (Ty.path "move_core_types::language_storage::ModuleId")
                    ],
                  "new",
                  []
                |),
                [
                  (* ClosureFnPointer(Normal) *)
                  M.pointer_coercion
                    (M.closure
                      (fun γ =>
                        ltac:(M.monadic
                          match γ with
                          | [ α0 ] =>
                            M.match_operator (|
                              M.alloc (| α0 |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.path "move_core_types::language_storage::ModuleId",
                                        "new",
                                        []
                                      |),
                                      [
                                        M.read (|
                                          M.get_constant (|
                                            "move_core_types::language_storage::CORE_CODE_ADDRESS"
                                          |)
                                        |);
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "alloc::borrow::ToOwned",
                                            Ty.path "move_core_types::identifier::IdentStr",
                                            [],
                                            "to_owned",
                                            []
                                          |),
                                          [
                                            M.read (|
                                              M.get_constant (|
                                                "move_core_types::vm_status::known_locations::CORE_ACCOUNT_MODULE_IDENTIFIER"
                                              |)
                                            |)
                                          ]
                                        |)
                                      ]
                                    |)))
                              ]
                            |)
                          | _ => M.impossible (||)
                          end)))
                ]
              |)
            |)
          |))).
    
    (*
        pub fn core_account_module_abort() -> AbortLocation {
            AbortLocation::Module(CORE_ACCOUNT_MODULE.clone())
        }
    *)
    Definition core_account_module_abort (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [] =>
        ltac:(M.monadic
          (Value.StructTuple
            "move_core_types::vm_status::AbortLocation::Module"
            [
              M.call_closure (|
                M.get_trait_method (|
                  "core::clone::Clone",
                  Ty.path "move_core_types::language_storage::ModuleId",
                  [],
                  "clone",
                  []
                |),
                [
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::deref::Deref",
                      Ty.apply
                        (Ty.path "once_cell::sync::Lazy")
                        [
                          Ty.path "move_core_types::language_storage::ModuleId";
                          Ty.function [] (Ty.path "move_core_types::language_storage::ModuleId")
                        ],
                      [],
                      "deref",
                      []
                    |),
                    [
                      M.read (|
                        M.get_constant (|
                          "move_core_types::vm_status::known_locations::CORE_ACCOUNT_MODULE"
                        |)
                      |)
                    ]
                  |)
                ]
              |)
            ]))
      | _, _ => M.impossible
      end.
    
    Definition value_DIEM_ACCOUNT_MODULE_IDENTIFIER : Value.t :=
      M.run
        ltac:(M.monadic
          (let s := M.copy (| mk_str "DiemAccount" |) in
          let is_valid :=
            M.alloc (|
              M.call_closure (|
                M.get_function (| "move_core_types::identifier::is_valid", [] |),
                [ M.read (| s |) ]
              |)
            |) in
          let _ :=
            M.get_array_field (|
              M.alloc (|
                Value.Array [ M.read (| mk_str "String is not a valid Move identifier" |) ]
              |),
              M.alloc (| M.rust_cast (UnOp.Pure.not (M.read (| is_valid |))) |)
            |) in
          M.alloc (|
            M.call_closure (|
              M.get_function (|
                "core::intrinsics::transmute",
                [
                  Ty.apply (Ty.path "&") [ Ty.path "str" ];
                  Ty.apply (Ty.path "&") [ Ty.path "move_core_types::identifier::IdentStr" ]
                ]
              |),
              [ M.read (| s |) ]
            |)
          |))).
    
    Definition value_DIEM_ACCOUNT_MODULE : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "once_cell::sync::Lazy")
                    [
                      Ty.path "move_core_types::language_storage::ModuleId";
                      Ty.function [] (Ty.path "move_core_types::language_storage::ModuleId")
                    ],
                  "new",
                  []
                |),
                [
                  (* ClosureFnPointer(Normal) *)
                  M.pointer_coercion
                    (M.closure
                      (fun γ =>
                        ltac:(M.monadic
                          match γ with
                          | [ α0 ] =>
                            M.match_operator (|
                              M.alloc (| α0 |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.path "move_core_types::language_storage::ModuleId",
                                        "new",
                                        []
                                      |),
                                      [
                                        M.read (|
                                          M.get_constant (|
                                            "move_core_types::language_storage::CORE_CODE_ADDRESS"
                                          |)
                                        |);
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "alloc::borrow::ToOwned",
                                            Ty.path "move_core_types::identifier::IdentStr",
                                            [],
                                            "to_owned",
                                            []
                                          |),
                                          [
                                            M.read (|
                                              M.get_constant (|
                                                "move_core_types::vm_status::known_locations::DIEM_ACCOUNT_MODULE_IDENTIFIER"
                                              |)
                                            |)
                                          ]
                                        |)
                                      ]
                                    |)))
                              ]
                            |)
                          | _ => M.impossible (||)
                          end)))
                ]
              |)
            |)
          |))).
    
    (*
        pub fn diem_account_module_abort() -> AbortLocation {
            AbortLocation::Module(DIEM_ACCOUNT_MODULE.clone())
        }
    *)
    Definition diem_account_module_abort (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [] =>
        ltac:(M.monadic
          (Value.StructTuple
            "move_core_types::vm_status::AbortLocation::Module"
            [
              M.call_closure (|
                M.get_trait_method (|
                  "core::clone::Clone",
                  Ty.path "move_core_types::language_storage::ModuleId",
                  [],
                  "clone",
                  []
                |),
                [
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::deref::Deref",
                      Ty.apply
                        (Ty.path "once_cell::sync::Lazy")
                        [
                          Ty.path "move_core_types::language_storage::ModuleId";
                          Ty.function [] (Ty.path "move_core_types::language_storage::ModuleId")
                        ],
                      [],
                      "deref",
                      []
                    |),
                    [
                      M.read (|
                        M.get_constant (|
                          "move_core_types::vm_status::known_locations::DIEM_ACCOUNT_MODULE"
                        |)
                      |)
                    ]
                  |)
                ]
              |)
            ]))
      | _, _ => M.impossible
      end.
    
    Definition value_DIEM_MODULE_IDENTIFIER : Value.t :=
      M.run
        ltac:(M.monadic
          (let s := M.copy (| mk_str "Diem" |) in
          let is_valid :=
            M.alloc (|
              M.call_closure (|
                M.get_function (| "move_core_types::identifier::is_valid", [] |),
                [ M.read (| s |) ]
              |)
            |) in
          let _ :=
            M.get_array_field (|
              M.alloc (|
                Value.Array [ M.read (| mk_str "String is not a valid Move identifier" |) ]
              |),
              M.alloc (| M.rust_cast (UnOp.Pure.not (M.read (| is_valid |))) |)
            |) in
          M.alloc (|
            M.call_closure (|
              M.get_function (|
                "core::intrinsics::transmute",
                [
                  Ty.apply (Ty.path "&") [ Ty.path "str" ];
                  Ty.apply (Ty.path "&") [ Ty.path "move_core_types::identifier::IdentStr" ]
                ]
              |),
              [ M.read (| s |) ]
            |)
          |))).
    
    Definition value_DIEM_MODULE : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "once_cell::sync::Lazy")
                    [
                      Ty.path "move_core_types::language_storage::ModuleId";
                      Ty.function [] (Ty.path "move_core_types::language_storage::ModuleId")
                    ],
                  "new",
                  []
                |),
                [
                  (* ClosureFnPointer(Normal) *)
                  M.pointer_coercion
                    (M.closure
                      (fun γ =>
                        ltac:(M.monadic
                          match γ with
                          | [ α0 ] =>
                            M.match_operator (|
                              M.alloc (| α0 |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.path "move_core_types::language_storage::ModuleId",
                                        "new",
                                        []
                                      |),
                                      [
                                        M.read (|
                                          M.get_constant (|
                                            "move_core_types::language_storage::CORE_CODE_ADDRESS"
                                          |)
                                        |);
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "alloc::borrow::ToOwned",
                                            Ty.path "move_core_types::identifier::IdentStr",
                                            [],
                                            "to_owned",
                                            []
                                          |),
                                          [
                                            M.read (|
                                              M.get_constant (|
                                                "move_core_types::vm_status::known_locations::DIEM_MODULE_IDENTIFIER"
                                              |)
                                            |)
                                          ]
                                        |)
                                      ]
                                    |)))
                              ]
                            |)
                          | _ => M.impossible (||)
                          end)))
                ]
              |)
            |)
          |))).
    
    (*
        pub fn diem_module_abort() -> AbortLocation {
            AbortLocation::Module(DIEM_MODULE.clone())
        }
    *)
    Definition diem_module_abort (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [] =>
        ltac:(M.monadic
          (Value.StructTuple
            "move_core_types::vm_status::AbortLocation::Module"
            [
              M.call_closure (|
                M.get_trait_method (|
                  "core::clone::Clone",
                  Ty.path "move_core_types::language_storage::ModuleId",
                  [],
                  "clone",
                  []
                |),
                [
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::deref::Deref",
                      Ty.apply
                        (Ty.path "once_cell::sync::Lazy")
                        [
                          Ty.path "move_core_types::language_storage::ModuleId";
                          Ty.function [] (Ty.path "move_core_types::language_storage::ModuleId")
                        ],
                      [],
                      "deref",
                      []
                    |),
                    [
                      M.read (|
                        M.get_constant (|
                          "move_core_types::vm_status::known_locations::DIEM_MODULE"
                        |)
                      |)
                    ]
                  |)
                ]
              |)
            ]))
      | _, _ => M.impossible
      end.
    
    Definition value_DESIGNATED_DEALER_MODULE_IDENTIFIER : Value.t :=
      M.run
        ltac:(M.monadic
          (let s := M.copy (| mk_str "DesignatedDealer" |) in
          let is_valid :=
            M.alloc (|
              M.call_closure (|
                M.get_function (| "move_core_types::identifier::is_valid", [] |),
                [ M.read (| s |) ]
              |)
            |) in
          let _ :=
            M.get_array_field (|
              M.alloc (|
                Value.Array [ M.read (| mk_str "String is not a valid Move identifier" |) ]
              |),
              M.alloc (| M.rust_cast (UnOp.Pure.not (M.read (| is_valid |))) |)
            |) in
          M.alloc (|
            M.call_closure (|
              M.get_function (|
                "core::intrinsics::transmute",
                [
                  Ty.apply (Ty.path "&") [ Ty.path "str" ];
                  Ty.apply (Ty.path "&") [ Ty.path "move_core_types::identifier::IdentStr" ]
                ]
              |),
              [ M.read (| s |) ]
            |)
          |))).
    
    Definition value_DESIGNATED_DEALER_MODULE : Value.t :=
      M.run
        ltac:(M.monadic
          (M.alloc (|
            M.alloc (|
              M.call_closure (|
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "once_cell::sync::Lazy")
                    [
                      Ty.path "move_core_types::language_storage::ModuleId";
                      Ty.function [] (Ty.path "move_core_types::language_storage::ModuleId")
                    ],
                  "new",
                  []
                |),
                [
                  (* ClosureFnPointer(Normal) *)
                  M.pointer_coercion
                    (M.closure
                      (fun γ =>
                        ltac:(M.monadic
                          match γ with
                          | [ α0 ] =>
                            M.match_operator (|
                              M.alloc (| α0 |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (M.call_closure (|
                                      M.get_associated_function (|
                                        Ty.path "move_core_types::language_storage::ModuleId",
                                        "new",
                                        []
                                      |),
                                      [
                                        M.read (|
                                          M.get_constant (|
                                            "move_core_types::language_storage::CORE_CODE_ADDRESS"
                                          |)
                                        |);
                                        M.call_closure (|
                                          M.get_trait_method (|
                                            "alloc::borrow::ToOwned",
                                            Ty.path "move_core_types::identifier::IdentStr",
                                            [],
                                            "to_owned",
                                            []
                                          |),
                                          [
                                            M.read (|
                                              M.get_constant (|
                                                "move_core_types::vm_status::known_locations::DESIGNATED_DEALER_MODULE_IDENTIFIER"
                                              |)
                                            |)
                                          ]
                                        |)
                                      ]
                                    |)))
                              ]
                            |)
                          | _ => M.impossible (||)
                          end)))
                ]
              |)
            |)
          |))).
    
    (*
        pub fn designated_dealer_module_abort() -> AbortLocation {
            AbortLocation::Module(DESIGNATED_DEALER_MODULE.clone())
        }
    *)
    Definition designated_dealer_module_abort (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [] =>
        ltac:(M.monadic
          (Value.StructTuple
            "move_core_types::vm_status::AbortLocation::Module"
            [
              M.call_closure (|
                M.get_trait_method (|
                  "core::clone::Clone",
                  Ty.path "move_core_types::language_storage::ModuleId",
                  [],
                  "clone",
                  []
                |),
                [
                  M.call_closure (|
                    M.get_trait_method (|
                      "core::ops::deref::Deref",
                      Ty.apply
                        (Ty.path "once_cell::sync::Lazy")
                        [
                          Ty.path "move_core_types::language_storage::ModuleId";
                          Ty.function [] (Ty.path "move_core_types::language_storage::ModuleId")
                        ],
                      [],
                      "deref",
                      []
                    |),
                    [
                      M.read (|
                        M.get_constant (|
                          "move_core_types::vm_status::known_locations::DESIGNATED_DEALER_MODULE"
                        |)
                      |)
                    ]
                  |)
                ]
              |)
            ]))
      | _, _ => M.impossible
      end.
  End known_locations.
  
  (*
  Enum StatusCode
  {
    ty_params := [];
    variants :=
      [
        {
          name := "UNKNOWN_VALIDATION_STATUS";
          item := StructTuple [];
          discriminant := Some 0;
        };
        {
          name := "INVALID_SIGNATURE";
          item := StructTuple [];
          discriminant := Some 1;
        };
        {
          name := "INVALID_AUTH_KEY";
          item := StructTuple [];
          discriminant := Some 2;
        };
        {
          name := "SEQUENCE_NUMBER_TOO_OLD";
          item := StructTuple [];
          discriminant := Some 3;
        };
        {
          name := "SEQUENCE_NUMBER_TOO_NEW";
          item := StructTuple [];
          discriminant := Some 4;
        };
        {
          name := "INSUFFICIENT_BALANCE_FOR_TRANSACTION_FEE";
          item := StructTuple [];
          discriminant := Some 5;
        };
        {
          name := "TRANSACTION_EXPIRED";
          item := StructTuple [];
          discriminant := Some 6;
        };
        {
          name := "SENDING_ACCOUNT_DOES_NOT_EXIST";
          item := StructTuple [];
          discriminant := Some 7;
        };
        {
          name := "REJECTED_WRITE_SET";
          item := StructTuple [];
          discriminant := Some 8;
        };
        {
          name := "INVALID_WRITE_SET";
          item := StructTuple [];
          discriminant := Some 9;
        };
        {
          name := "EXCEEDED_MAX_TRANSACTION_SIZE";
          item := StructTuple [];
          discriminant := Some 10;
        };
        {
          name := "UNKNOWN_SCRIPT";
          item := StructTuple [];
          discriminant := Some 11;
        };
        {
          name := "UNKNOWN_MODULE";
          item := StructTuple [];
          discriminant := Some 12;
        };
        {
          name := "MAX_GAS_UNITS_EXCEEDS_MAX_GAS_UNITS_BOUND";
          item := StructTuple [];
          discriminant := Some 13;
        };
        {
          name := "MAX_GAS_UNITS_BELOW_MIN_TRANSACTION_GAS_UNITS";
          item := StructTuple [];
          discriminant := Some 14;
        };
        {
          name := "GAS_UNIT_PRICE_BELOW_MIN_BOUND";
          item := StructTuple [];
          discriminant := Some 15;
        };
        {
          name := "GAS_UNIT_PRICE_ABOVE_MAX_BOUND";
          item := StructTuple [];
          discriminant := Some 16;
        };
        {
          name := "INVALID_GAS_SPECIFIER";
          item := StructTuple [];
          discriminant := Some 17;
        };
        {
          name := "SENDING_ACCOUNT_FROZEN";
          item := StructTuple [];
          discriminant := Some 18;
        };
        {
          name := "UNABLE_TO_DESERIALIZE_ACCOUNT";
          item := StructTuple [];
          discriminant := Some 19;
        };
        {
          name := "CURRENCY_INFO_DOES_NOT_EXIST";
          item := StructTuple [];
          discriminant := Some 20;
        };
        {
          name := "INVALID_MODULE_PUBLISHER";
          item := StructTuple [];
          discriminant := Some 21;
        };
        {
          name := "NO_ACCOUNT_ROLE";
          item := StructTuple [];
          discriminant := Some 22;
        };
        {
          name := "BAD_CHAIN_ID";
          item := StructTuple [];
          discriminant := Some 23;
        };
        {
          name := "SEQUENCE_NUMBER_TOO_BIG";
          item := StructTuple [];
          discriminant := Some 24;
        };
        {
          name := "BAD_TRANSACTION_FEE_CURRENCY";
          item := StructTuple [];
          discriminant := Some 25;
        };
        {
          name := "FEATURE_UNDER_GATING";
          item := StructTuple [];
          discriminant := Some 26;
        };
        {
          name := "SECONDARY_KEYS_ADDRESSES_COUNT_MISMATCH";
          item := StructTuple [];
          discriminant := Some 27;
        };
        {
          name := "SIGNERS_CONTAIN_DUPLICATES";
          item := StructTuple [];
          discriminant := Some 28;
        };
        {
          name := "SEQUENCE_NONCE_INVALID";
          item := StructTuple [];
          discriminant := Some 29;
        };
        {
          name := "CHAIN_ACCOUNT_INFO_DOES_NOT_EXIST";
          item := StructTuple [];
          discriminant := Some 30;
        };
        {
          name := "RESERVED_VALIDATION_ERROR_1";
          item := StructTuple [];
          discriminant := Some 31;
        };
        {
          name := "RESERVED_VALIDATION_ERROR_2";
          item := StructTuple [];
          discriminant := Some 32;
        };
        {
          name := "RESERVED_VALIDATION_ERROR_3";
          item := StructTuple [];
          discriminant := Some 33;
        };
        {
          name := "RESERVED_VALIDATION_ERROR_4";
          item := StructTuple [];
          discriminant := Some 34;
        };
        {
          name := "RESERVED_VALIDATION_ERROR_5";
          item := StructTuple [];
          discriminant := Some 35;
        };
        {
          name := "UNKNOWN_VERIFICATION_ERROR";
          item := StructTuple [];
          discriminant := Some 1000;
        };
        {
          name := "INDEX_OUT_OF_BOUNDS";
          item := StructTuple [];
          discriminant := Some 1001;
        };
        {
          name := "INVALID_SIGNATURE_TOKEN";
          item := StructTuple [];
          discriminant := Some 1003;
        };
        {
          name := "RECURSIVE_STRUCT_DEFINITION";
          item := StructTuple [];
          discriminant := Some 1005;
        };
        {
          name := "FIELD_MISSING_TYPE_ABILITY";
          item := StructTuple [];
          discriminant := Some 1006;
        };
        {
          name := "INVALID_FALL_THROUGH";
          item := StructTuple [];
          discriminant := Some 1007;
        };
        {
          name := "NEGATIVE_STACK_SIZE_WITHIN_BLOCK";
          item := StructTuple [];
          discriminant := Some 1009;
        };
        {
          name := "INVALID_MAIN_FUNCTION_SIGNATURE";
          item := StructTuple [];
          discriminant := Some 1011;
        };
        {
          name := "DUPLICATE_ELEMENT";
          item := StructTuple [];
          discriminant := Some 1012;
        };
        {
          name := "INVALID_MODULE_HANDLE";
          item := StructTuple [];
          discriminant := Some 1013;
        };
        {
          name := "UNIMPLEMENTED_HANDLE";
          item := StructTuple [];
          discriminant := Some 1014;
        };
        {
          name := "LOOKUP_FAILED";
          item := StructTuple [];
          discriminant := Some 1017;
        };
        {
          name := "TYPE_MISMATCH";
          item := StructTuple [];
          discriminant := Some 1020;
        };
        {
          name := "MISSING_DEPENDENCY";
          item := StructTuple [];
          discriminant := Some 1021;
        };
        {
          name := "POP_WITHOUT_DROP_ABILITY";
          item := StructTuple [];
          discriminant := Some 1023;
        };
        {
          name := "BR_TYPE_MISMATCH_ERROR";
          item := StructTuple [];
          discriminant := Some 1025;
        };
        {
          name := "ABORT_TYPE_MISMATCH_ERROR";
          item := StructTuple [];
          discriminant := Some 1026;
        };
        {
          name := "STLOC_TYPE_MISMATCH_ERROR";
          item := StructTuple [];
          discriminant := Some 1027;
        };
        {
          name := "STLOC_UNSAFE_TO_DESTROY_ERROR";
          item := StructTuple [];
          discriminant := Some 1028;
        };
        {
          name := "UNSAFE_RET_LOCAL_OR_RESOURCE_STILL_BORROWED";
          item := StructTuple [];
          discriminant := Some 1029;
        };
        {
          name := "RET_TYPE_MISMATCH_ERROR";
          item := StructTuple [];
          discriminant := Some 1030;
        };
        {
          name := "RET_BORROWED_MUTABLE_REFERENCE_ERROR";
          item := StructTuple [];
          discriminant := Some 1031;
        };
        {
          name := "FREEZEREF_TYPE_MISMATCH_ERROR";
          item := StructTuple [];
          discriminant := Some 1032;
        };
        {
          name := "FREEZEREF_EXISTS_MUTABLE_BORROW_ERROR";
          item := StructTuple [];
          discriminant := Some 1033;
        };
        {
          name := "BORROWFIELD_TYPE_MISMATCH_ERROR";
          item := StructTuple [];
          discriminant := Some 1034;
        };
        {
          name := "BORROWFIELD_BAD_FIELD_ERROR";
          item := StructTuple [];
          discriminant := Some 1035;
        };
        {
          name := "BORROWFIELD_EXISTS_MUTABLE_BORROW_ERROR";
          item := StructTuple [];
          discriminant := Some 1036;
        };
        {
          name := "COPYLOC_UNAVAILABLE_ERROR";
          item := StructTuple [];
          discriminant := Some 1037;
        };
        {
          name := "COPYLOC_WITHOUT_COPY_ABILITY";
          item := StructTuple [];
          discriminant := Some 1038;
        };
        {
          name := "COPYLOC_EXISTS_BORROW_ERROR";
          item := StructTuple [];
          discriminant := Some 1039;
        };
        {
          name := "MOVELOC_UNAVAILABLE_ERROR";
          item := StructTuple [];
          discriminant := Some 1040;
        };
        {
          name := "MOVELOC_EXISTS_BORROW_ERROR";
          item := StructTuple [];
          discriminant := Some 1041;
        };
        {
          name := "BORROWLOC_REFERENCE_ERROR";
          item := StructTuple [];
          discriminant := Some 1042;
        };
        {
          name := "BORROWLOC_UNAVAILABLE_ERROR";
          item := StructTuple [];
          discriminant := Some 1043;
        };
        {
          name := "BORROWLOC_EXISTS_BORROW_ERROR";
          item := StructTuple [];
          discriminant := Some 1044;
        };
        {
          name := "CALL_TYPE_MISMATCH_ERROR";
          item := StructTuple [];
          discriminant := Some 1045;
        };
        {
          name := "CALL_BORROWED_MUTABLE_REFERENCE_ERROR";
          item := StructTuple [];
          discriminant := Some 1046;
        };
        {
          name := "PACK_TYPE_MISMATCH_ERROR";
          item := StructTuple [];
          discriminant := Some 1047;
        };
        {
          name := "UNPACK_TYPE_MISMATCH_ERROR";
          item := StructTuple [];
          discriminant := Some 1048;
        };
        {
          name := "READREF_TYPE_MISMATCH_ERROR";
          item := StructTuple [];
          discriminant := Some 1049;
        };
        {
          name := "READREF_WITHOUT_COPY_ABILITY";
          item := StructTuple [];
          discriminant := Some 1050;
        };
        {
          name := "READREF_EXISTS_MUTABLE_BORROW_ERROR";
          item := StructTuple [];
          discriminant := Some 1051;
        };
        {
          name := "WRITEREF_TYPE_MISMATCH_ERROR";
          item := StructTuple [];
          discriminant := Some 1052;
        };
        {
          name := "WRITEREF_WITHOUT_DROP_ABILITY";
          item := StructTuple [];
          discriminant := Some 1053;
        };
        {
          name := "WRITEREF_EXISTS_BORROW_ERROR";
          item := StructTuple [];
          discriminant := Some 1054;
        };
        {
          name := "WRITEREF_NO_MUTABLE_REFERENCE_ERROR";
          item := StructTuple [];
          discriminant := Some 1055;
        };
        {
          name := "INTEGER_OP_TYPE_MISMATCH_ERROR";
          item := StructTuple [];
          discriminant := Some 1056;
        };
        {
          name := "BOOLEAN_OP_TYPE_MISMATCH_ERROR";
          item := StructTuple [];
          discriminant := Some 1057;
        };
        {
          name := "EQUALITY_OP_TYPE_MISMATCH_ERROR";
          item := StructTuple [];
          discriminant := Some 1058;
        };
        {
          name := "EXISTS_WITHOUT_KEY_ABILITY_OR_BAD_ARGUMENT";
          item := StructTuple [];
          discriminant := Some 1059;
        };
        {
          name := "BORROWGLOBAL_TYPE_MISMATCH_ERROR";
          item := StructTuple [];
          discriminant := Some 1060;
        };
        {
          name := "BORROWGLOBAL_WITHOUT_KEY_ABILITY";
          item := StructTuple [];
          discriminant := Some 1061;
        };
        {
          name := "MOVEFROM_TYPE_MISMATCH_ERROR";
          item := StructTuple [];
          discriminant := Some 1062;
        };
        {
          name := "MOVEFROM_WITHOUT_KEY_ABILITY";
          item := StructTuple [];
          discriminant := Some 1063;
        };
        {
          name := "MOVETO_TYPE_MISMATCH_ERROR";
          item := StructTuple [];
          discriminant := Some 1064;
        };
        {
          name := "MOVETO_WITHOUT_KEY_ABILITY";
          item := StructTuple [];
          discriminant := Some 1065;
        };
        {
          name := "MODULE_ADDRESS_DOES_NOT_MATCH_SENDER";
          item := StructTuple [];
          discriminant := Some 1067;
        };
        {
          name := "NO_MODULE_HANDLES";
          item := StructTuple [];
          discriminant := Some 1068;
        };
        {
          name := "POSITIVE_STACK_SIZE_AT_BLOCK_END";
          item := StructTuple [];
          discriminant := Some 1069;
        };
        {
          name := "MISSING_ACQUIRES_ANNOTATION";
          item := StructTuple [];
          discriminant := Some 1070;
        };
        {
          name := "EXTRANEOUS_ACQUIRES_ANNOTATION";
          item := StructTuple [];
          discriminant := Some 1071;
        };
        {
          name := "DUPLICATE_ACQUIRES_ANNOTATION";
          item := StructTuple [];
          discriminant := Some 1072;
        };
        {
          name := "INVALID_ACQUIRES_ANNOTATION";
          item := StructTuple [];
          discriminant := Some 1073;
        };
        {
          name := "GLOBAL_REFERENCE_ERROR";
          item := StructTuple [];
          discriminant := Some 1074;
        };
        {
          name := "CONSTRAINT_NOT_SATISFIED";
          item := StructTuple [];
          discriminant := Some 1075;
        };
        {
          name := "NUMBER_OF_TYPE_ARGUMENTS_MISMATCH";
          item := StructTuple [];
          discriminant := Some 1076;
        };
        {
          name := "LOOP_IN_INSTANTIATION_GRAPH";
          item := StructTuple [];
          discriminant := Some 1077;
        };
        {
          name := "ZERO_SIZED_STRUCT";
          item := StructTuple [];
          discriminant := Some 1080;
        };
        {
          name := "LINKER_ERROR";
          item := StructTuple [];
          discriminant := Some 1081;
        };
        {
          name := "INVALID_CONSTANT_TYPE";
          item := StructTuple [];
          discriminant := Some 1082;
        };
        {
          name := "MALFORMED_CONSTANT_DATA";
          item := StructTuple [];
          discriminant := Some 1083;
        };
        {
          name := "EMPTY_CODE_UNIT";
          item := StructTuple [];
          discriminant := Some 1084;
        };
        {
          name := "INVALID_LOOP_SPLIT";
          item := StructTuple [];
          discriminant := Some 1085;
        };
        {
          name := "INVALID_LOOP_BREAK";
          item := StructTuple [];
          discriminant := Some 1086;
        };
        {
          name := "INVALID_LOOP_CONTINUE";
          item := StructTuple [];
          discriminant := Some 1087;
        };
        {
          name := "UNSAFE_RET_UNUSED_VALUES_WITHOUT_DROP";
          item := StructTuple [];
          discriminant := Some 1088;
        };
        {
          name := "TOO_MANY_LOCALS";
          item := StructTuple [];
          discriminant := Some 1089;
        };
        {
          name := "GENERIC_MEMBER_OPCODE_MISMATCH";
          item := StructTuple [];
          discriminant := Some 1090;
        };
        {
          name := "FUNCTION_RESOLUTION_FAILURE";
          item := StructTuple [];
          discriminant := Some 1091;
        };
        {
          name := "INVALID_OPERATION_IN_SCRIPT";
          item := StructTuple [];
          discriminant := Some 1094;
        };
        {
          name := "DUPLICATE_MODULE_NAME";
          item := StructTuple [];
          discriminant := Some 1095;
        };
        {
          name := "BACKWARD_INCOMPATIBLE_MODULE_UPDATE";
          item := StructTuple [];
          discriminant := Some 1096;
        };
        {
          name := "CYCLIC_MODULE_DEPENDENCY";
          item := StructTuple [];
          discriminant := Some 1097;
        };
        {
          name := "NUMBER_OF_ARGUMENTS_MISMATCH";
          item := StructTuple [];
          discriminant := Some 1098;
        };
        {
          name := "INVALID_PARAM_TYPE_FOR_DESERIALIZATION";
          item := StructTuple [];
          discriminant := Some 1099;
        };
        {
          name := "FAILED_TO_DESERIALIZE_ARGUMENT";
          item := StructTuple [];
          discriminant := Some 1100;
        };
        {
          name := "NUMBER_OF_SIGNER_ARGUMENTS_MISMATCH";
          item := StructTuple [];
          discriminant := Some 1101;
        };
        {
          name := "CALLED_SCRIPT_VISIBLE_FROM_NON_SCRIPT_VISIBLE";
          item := StructTuple [];
          discriminant := Some 1102;
        };
        {
          name := "EXECUTE_ENTRY_FUNCTION_CALLED_ON_NON_ENTRY_FUNCTION";
          item := StructTuple [];
          discriminant := Some 1103;
        };
        {
          name := "INVALID_FRIEND_DECL_WITH_SELF";
          item := StructTuple [];
          discriminant := Some 1104;
        };
        {
          name := "INVALID_FRIEND_DECL_WITH_MODULES_OUTSIDE_ACCOUNT_ADDRESS";
          item := StructTuple [];
          discriminant := Some 1105;
        };
        {
          name := "INVALID_FRIEND_DECL_WITH_MODULES_IN_DEPENDENCIES";
          item := StructTuple [];
          discriminant := Some 1106;
        };
        {
          name := "CYCLIC_MODULE_FRIENDSHIP";
          item := StructTuple [];
          discriminant := Some 1107;
        };
        {
          name := "INVALID_PHANTOM_TYPE_PARAM_POSITION";
          item := StructTuple [];
          discriminant := Some 1108;
        };
        {
          name := "VEC_UPDATE_EXISTS_MUTABLE_BORROW_ERROR";
          item := StructTuple [];
          discriminant := Some 1109;
        };
        {
          name := "VEC_BORROW_ELEMENT_EXISTS_MUTABLE_BORROW_ERROR";
          item := StructTuple [];
          discriminant := Some 1110;
        };
        {
          name := "LOOP_MAX_DEPTH_REACHED";
          item := StructTuple [];
          discriminant := Some 1111;
        };
        {
          name := "TOO_MANY_TYPE_PARAMETERS";
          item := StructTuple [];
          discriminant := Some 1112;
        };
        {
          name := "TOO_MANY_PARAMETERS";
          item := StructTuple [];
          discriminant := Some 1113;
        };
        {
          name := "TOO_MANY_BASIC_BLOCKS";
          item := StructTuple [];
          discriminant := Some 1114;
        };
        {
          name := "VALUE_STACK_OVERFLOW";
          item := StructTuple [];
          discriminant := Some 1115;
        };
        {
          name := "TOO_MANY_TYPE_NODES";
          item := StructTuple [];
          discriminant := Some 1116;
        };
        {
          name := "VALUE_STACK_PUSH_OVERFLOW";
          item := StructTuple [];
          discriminant := Some 1117;
        };
        {
          name := "MAX_DEPENDENCY_DEPTH_REACHED";
          item := StructTuple [];
          discriminant := Some 1118;
        };
        {
          name := "MAX_FUNCTION_DEFINITIONS_REACHED";
          item := StructTuple [];
          discriminant := Some 1119;
        };
        {
          name := "MAX_STRUCT_DEFINITIONS_REACHED";
          item := StructTuple [];
          discriminant := Some 1120;
        };
        {
          name := "MAX_FIELD_DEFINITIONS_REACHED";
          item := StructTuple [];
          discriminant := Some 1121;
        };
        {
          name := "TOO_MANY_BACK_EDGES";
          item := StructTuple [];
          discriminant := Some 1122;
        };
        {
          name := "RESERVED_VERIFICATION_ERROR_1";
          item := StructTuple [];
          discriminant := Some 1123;
        };
        {
          name := "RESERVED_VERIFICATION_ERROR_2";
          item := StructTuple [];
          discriminant := Some 1124;
        };
        {
          name := "RESERVED_VERIFICATION_ERROR_3";
          item := StructTuple [];
          discriminant := Some 1125;
        };
        {
          name := "RESERVED_VERIFICATION_ERROR_4";
          item := StructTuple [];
          discriminant := Some 1126;
        };
        {
          name := "RESERVED_VERIFICATION_ERROR_5";
          item := StructTuple [];
          discriminant := Some 1127;
        };
        {
          name := "UNKNOWN_INVARIANT_VIOLATION_ERROR";
          item := StructTuple [];
          discriminant := Some 2000;
        };
        {
          name := "EMPTY_VALUE_STACK";
          item := StructTuple [];
          discriminant := Some 2003;
        };
        {
          name := "PC_OVERFLOW";
          item := StructTuple [];
          discriminant := Some 2005;
        };
        {
          name := "VERIFICATION_ERROR";
          item := StructTuple [];
          discriminant := Some 2006;
        };
        {
          name := "STORAGE_ERROR";
          item := StructTuple [];
          discriminant := Some 2008;
        };
        {
          name := "INTERNAL_TYPE_ERROR";
          item := StructTuple [];
          discriminant := Some 2009;
        };
        {
          name := "EVENT_KEY_MISMATCH";
          item := StructTuple [];
          discriminant := Some 2010;
        };
        {
          name := "UNREACHABLE";
          item := StructTuple [];
          discriminant := Some 2011;
        };
        {
          name := "VM_STARTUP_FAILURE";
          item := StructTuple [];
          discriminant := Some 2012;
        };
        {
          name := "UNEXPECTED_ERROR_FROM_KNOWN_MOVE_FUNCTION";
          item := StructTuple [];
          discriminant := Some 2015;
        };
        {
          name := "VERIFIER_INVARIANT_VIOLATION";
          item := StructTuple [];
          discriminant := Some 2016;
        };
        {
          name := "UNEXPECTED_VERIFIER_ERROR";
          item := StructTuple [];
          discriminant := Some 2017;
        };
        {
          name := "UNEXPECTED_DESERIALIZATION_ERROR";
          item := StructTuple [];
          discriminant := Some 2018;
        };
        {
          name := "FAILED_TO_SERIALIZE_WRITE_SET_CHANGES";
          item := StructTuple [];
          discriminant := Some 2019;
        };
        {
          name := "FAILED_TO_DESERIALIZE_RESOURCE";
          item := StructTuple [];
          discriminant := Some 2020;
        };
        {
          name := "TYPE_RESOLUTION_FAILURE";
          item := StructTuple [];
          discriminant := Some 2021;
        };
        {
          name := "DUPLICATE_NATIVE_FUNCTION";
          item := StructTuple [];
          discriminant := Some 2022;
        };
        {
          name := "RESERVED_INVARIANT_VIOLATION_ERROR_1";
          item := StructTuple [];
          discriminant := Some 2023;
        };
        {
          name := "RESERVED_INVARIANT_VIOLATION_ERROR_2";
          item := StructTuple [];
          discriminant := Some 2024;
        };
        {
          name := "RESERVED_INVARIANT_VIOLATION_ERROR_3";
          item := StructTuple [];
          discriminant := Some 2025;
        };
        {
          name := "RESERVED_INVARIANT_VIOLATION_ERROR_4";
          item := StructTuple [];
          discriminant := Some 2026;
        };
        {
          name := "RESERVED_INVARIANT_VIOLATION_ERROR_5";
          item := StructTuple [];
          discriminant := Some 2027;
        };
        {
          name := "UNKNOWN_BINARY_ERROR";
          item := StructTuple [];
          discriminant := Some 3000;
        };
        {
          name := "MALFORMED";
          item := StructTuple [];
          discriminant := Some 3001;
        };
        {
          name := "BAD_MAGIC";
          item := StructTuple [];
          discriminant := Some 3002;
        };
        {
          name := "UNKNOWN_VERSION";
          item := StructTuple [];
          discriminant := Some 3003;
        };
        {
          name := "UNKNOWN_TABLE_TYPE";
          item := StructTuple [];
          discriminant := Some 3004;
        };
        {
          name := "UNKNOWN_SIGNATURE_TYPE";
          item := StructTuple [];
          discriminant := Some 3005;
        };
        {
          name := "UNKNOWN_SERIALIZED_TYPE";
          item := StructTuple [];
          discriminant := Some 3006;
        };
        {
          name := "UNKNOWN_OPCODE";
          item := StructTuple [];
          discriminant := Some 3007;
        };
        {
          name := "BAD_HEADER_TABLE";
          item := StructTuple [];
          discriminant := Some 3008;
        };
        {
          name := "UNEXPECTED_SIGNATURE_TYPE";
          item := StructTuple [];
          discriminant := Some 3009;
        };
        {
          name := "DUPLICATE_TABLE";
          item := StructTuple [];
          discriminant := Some 3010;
        };
        {
          name := "UNKNOWN_ABILITY";
          item := StructTuple [];
          discriminant := Some 3013;
        };
        {
          name := "UNKNOWN_NATIVE_STRUCT_FLAG";
          item := StructTuple [];
          discriminant := Some 3014;
        };
        {
          name := "BAD_U16";
          item := StructTuple [];
          discriminant := Some 3017;
        };
        {
          name := "BAD_U32";
          item := StructTuple [];
          discriminant := Some 3018;
        };
        {
          name := "BAD_U64";
          item := StructTuple [];
          discriminant := Some 3019;
        };
        {
          name := "BAD_U128";
          item := StructTuple [];
          discriminant := Some 3020;
        };
        {
          name := "BAD_U256";
          item := StructTuple [];
          discriminant := Some 3021;
        };
        {
          name := "VALUE_SERIALIZATION_ERROR";
          item := StructTuple [];
          discriminant := Some 3022;
        };
        {
          name := "VALUE_DESERIALIZATION_ERROR";
          item := StructTuple [];
          discriminant := Some 3023;
        };
        {
          name := "CODE_DESERIALIZATION_ERROR";
          item := StructTuple [];
          discriminant := Some 3024;
        };
        {
          name := "INVALID_FLAG_BITS";
          item := StructTuple [];
          discriminant := Some 3025;
        };
        {
          name := "RESERVED_DESERIALIZAION_ERROR_1";
          item := StructTuple [];
          discriminant := Some 3026;
        };
        {
          name := "RESERVED_DESERIALIZAION_ERROR_2";
          item := StructTuple [];
          discriminant := Some 3027;
        };
        {
          name := "RESERVED_DESERIALIZAION_ERROR_3";
          item := StructTuple [];
          discriminant := Some 3028;
        };
        {
          name := "RESERVED_DESERIALIZAION_ERROR_4";
          item := StructTuple [];
          discriminant := Some 3029;
        };
        {
          name := "RESERVED_DESERIALIZAION_ERROR_5";
          item := StructTuple [];
          discriminant := Some 3030;
        };
        {
          name := "UNKNOWN_RUNTIME_STATUS";
          item := StructTuple [];
          discriminant := Some 4000;
        };
        {
          name := "EXECUTED";
          item := StructTuple [];
          discriminant := Some 4001;
        };
        {
          name := "OUT_OF_GAS";
          item := StructTuple [];
          discriminant := Some 4002;
        };
        {
          name := "RESOURCE_DOES_NOT_EXIST";
          item := StructTuple [];
          discriminant := Some 4003;
        };
        {
          name := "RESOURCE_ALREADY_EXISTS";
          item := StructTuple [];
          discriminant := Some 4004;
        };
        {
          name := "MISSING_DATA";
          item := StructTuple [];
          discriminant := Some 4008;
        };
        {
          name := "DATA_FORMAT_ERROR";
          item := StructTuple [];
          discriminant := Some 4009;
        };
        {
          name := "ABORTED";
          item := StructTuple [];
          discriminant := Some 4016;
        };
        {
          name := "ARITHMETIC_ERROR";
          item := StructTuple [];
          discriminant := Some 4017;
        };
        {
          name := "VECTOR_OPERATION_ERROR";
          item := StructTuple [];
          discriminant := Some 4018;
        };
        {
          name := "EXECUTION_STACK_OVERFLOW";
          item := StructTuple [];
          discriminant := Some 4020;
        };
        {
          name := "CALL_STACK_OVERFLOW";
          item := StructTuple [];
          discriminant := Some 4021;
        };
        {
          name := "VM_MAX_TYPE_DEPTH_REACHED";
          item := StructTuple [];
          discriminant := Some 4024;
        };
        {
          name := "VM_MAX_VALUE_DEPTH_REACHED";
          item := StructTuple [];
          discriminant := Some 4025;
        };
        {
          name := "VM_EXTENSION_ERROR";
          item := StructTuple [];
          discriminant := Some 4026;
        };
        {
          name := "STORAGE_WRITE_LIMIT_REACHED";
          item := StructTuple [];
          discriminant := Some 4027;
        };
        {
          name := "MEMORY_LIMIT_EXCEEDED";
          item := StructTuple [];
          discriminant := Some 4028;
        };
        {
          name := "VM_MAX_TYPE_NODES_REACHED";
          item := StructTuple [];
          discriminant := Some 4029;
        };
        {
          name := "EXECUTION_LIMIT_REACHED";
          item := StructTuple [];
          discriminant := Some 4030;
        };
        {
          name := "IO_LIMIT_REACHED";
          item := StructTuple [];
          discriminant := Some 4031;
        };
        {
          name := "STORAGE_LIMIT_REACHED";
          item := StructTuple [];
          discriminant := Some 4032;
        };
        {
          name := "RESERVED_RUNTIME_ERROR_1";
          item := StructTuple [];
          discriminant := Some 4033;
        };
        {
          name := "RESERVED_RUNTIME_ERROR_2";
          item := StructTuple [];
          discriminant := Some 4034;
        };
        {
          name := "RESERVED_RUNTIME_ERROR_3";
          item := StructTuple [];
          discriminant := Some 4035;
        };
        {
          name := "RESERVED_RUNTIME_ERROR_4";
          item := StructTuple [];
          discriminant := Some 4036;
        };
        {
          name := "RESERVED_RUNTIME_ERROR_5";
          item := StructTuple [];
          discriminant := Some 4037;
        };
        {
          name := "UNKNOWN_STATUS";
          item := StructTuple [];
          discriminant := Some 18446744073709551615;
        }
      ];
  }
  *)
  
  Module Impl_core_clone_Clone_for_move_core_types_vm_status_StatusCode.
    Definition Self : Ty.t := Ty.path "move_core_types::vm_status::StatusCode".
    
    (* Clone *)
    Definition clone (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (| M.read (| self |) |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_move_core_types_vm_status_StatusCode.
  
  Module Impl_core_marker_Copy_for_move_core_types_vm_status_StatusCode.
    Definition Self : Ty.t := Ty.path "move_core_types::vm_status::StatusCode".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::Copy"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_Copy_for_move_core_types_vm_status_StatusCode.
  
  Module Impl_core_fmt_Debug_for_move_core_types_vm_status_StatusCode.
    Definition Self : Ty.t := Ty.path "move_core_types::vm_status::StatusCode".
    
    (* Debug *)
    Definition fmt (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_str", [] |),
            [
              M.read (| f |);
              M.read (|
                M.match_operator (|
                  self,
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "UNKNOWN_VALIDATION_STATUS" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "INVALID_SIGNATURE" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "INVALID_AUTH_KEY" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "SEQUENCE_NUMBER_TOO_OLD" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "SEQUENCE_NUMBER_TOO_NEW" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (|
                          M.read (| mk_str "INSUFFICIENT_BALANCE_FOR_TRANSACTION_FEE" |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "TRANSACTION_EXPIRED" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "SENDING_ACCOUNT_DOES_NOT_EXIST" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "REJECTED_WRITE_SET" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "INVALID_WRITE_SET" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "EXCEEDED_MAX_TRANSACTION_SIZE" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "UNKNOWN_SCRIPT" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "UNKNOWN_MODULE" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (|
                          M.read (| mk_str "MAX_GAS_UNITS_EXCEEDS_MAX_GAS_UNITS_BOUND" |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (|
                          M.read (| mk_str "MAX_GAS_UNITS_BELOW_MIN_TRANSACTION_GAS_UNITS" |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "GAS_UNIT_PRICE_BELOW_MIN_BOUND" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "GAS_UNIT_PRICE_ABOVE_MAX_BOUND" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "INVALID_GAS_SPECIFIER" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "SENDING_ACCOUNT_FROZEN" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "UNABLE_TO_DESERIALIZE_ACCOUNT" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "CURRENCY_INFO_DOES_NOT_EXIST" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "INVALID_MODULE_PUBLISHER" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "NO_ACCOUNT_ROLE" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "BAD_CHAIN_ID" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "SEQUENCE_NUMBER_TOO_BIG" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "BAD_TRANSACTION_FEE_CURRENCY" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "FEATURE_UNDER_GATING" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (|
                          M.read (| mk_str "SECONDARY_KEYS_ADDRESSES_COUNT_MISMATCH" |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "SIGNERS_CONTAIN_DUPLICATES" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "SEQUENCE_NONCE_INVALID" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "CHAIN_ACCOUNT_INFO_DOES_NOT_EXIST" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "RESERVED_VALIDATION_ERROR_1" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "RESERVED_VALIDATION_ERROR_2" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "RESERVED_VALIDATION_ERROR_3" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "RESERVED_VALIDATION_ERROR_4" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "RESERVED_VALIDATION_ERROR_5" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "UNKNOWN_VERIFICATION_ERROR" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "INDEX_OUT_OF_BOUNDS" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "INVALID_SIGNATURE_TOKEN" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "RECURSIVE_STRUCT_DEFINITION" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "FIELD_MISSING_TYPE_ABILITY" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "INVALID_FALL_THROUGH" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "NEGATIVE_STACK_SIZE_WITHIN_BLOCK" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "INVALID_MAIN_FUNCTION_SIGNATURE" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "DUPLICATE_ELEMENT" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "INVALID_MODULE_HANDLE" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "UNIMPLEMENTED_HANDLE" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "LOOKUP_FAILED" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "TYPE_MISMATCH" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "MISSING_DEPENDENCY" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "POP_WITHOUT_DROP_ABILITY" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "BR_TYPE_MISMATCH_ERROR" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "ABORT_TYPE_MISMATCH_ERROR" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "STLOC_TYPE_MISMATCH_ERROR" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "STLOC_UNSAFE_TO_DESTROY_ERROR" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (|
                          M.read (| mk_str "UNSAFE_RET_LOCAL_OR_RESOURCE_STILL_BORROWED" |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "RET_TYPE_MISMATCH_ERROR" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "RET_BORROWED_MUTABLE_REFERENCE_ERROR" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "FREEZEREF_TYPE_MISMATCH_ERROR" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "FREEZEREF_EXISTS_MUTABLE_BORROW_ERROR" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "BORROWFIELD_TYPE_MISMATCH_ERROR" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "BORROWFIELD_BAD_FIELD_ERROR" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (|
                          M.read (| mk_str "BORROWFIELD_EXISTS_MUTABLE_BORROW_ERROR" |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "COPYLOC_UNAVAILABLE_ERROR" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "COPYLOC_WITHOUT_COPY_ABILITY" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "COPYLOC_EXISTS_BORROW_ERROR" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "MOVELOC_UNAVAILABLE_ERROR" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "MOVELOC_EXISTS_BORROW_ERROR" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "BORROWLOC_REFERENCE_ERROR" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "BORROWLOC_UNAVAILABLE_ERROR" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "BORROWLOC_EXISTS_BORROW_ERROR" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "CALL_TYPE_MISMATCH_ERROR" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "CALL_BORROWED_MUTABLE_REFERENCE_ERROR" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "PACK_TYPE_MISMATCH_ERROR" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "UNPACK_TYPE_MISMATCH_ERROR" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "READREF_TYPE_MISMATCH_ERROR" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "READREF_WITHOUT_COPY_ABILITY" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "READREF_EXISTS_MUTABLE_BORROW_ERROR" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "WRITEREF_TYPE_MISMATCH_ERROR" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "WRITEREF_WITHOUT_DROP_ABILITY" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "WRITEREF_EXISTS_BORROW_ERROR" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "WRITEREF_NO_MUTABLE_REFERENCE_ERROR" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "INTEGER_OP_TYPE_MISMATCH_ERROR" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "BOOLEAN_OP_TYPE_MISMATCH_ERROR" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "EQUALITY_OP_TYPE_MISMATCH_ERROR" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (|
                          M.read (| mk_str "EXISTS_WITHOUT_KEY_ABILITY_OR_BAD_ARGUMENT" |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "BORROWGLOBAL_TYPE_MISMATCH_ERROR" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "BORROWGLOBAL_WITHOUT_KEY_ABILITY" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "MOVEFROM_TYPE_MISMATCH_ERROR" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "MOVEFROM_WITHOUT_KEY_ABILITY" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "MOVETO_TYPE_MISMATCH_ERROR" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "MOVETO_WITHOUT_KEY_ABILITY" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "MODULE_ADDRESS_DOES_NOT_MATCH_SENDER" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "NO_MODULE_HANDLES" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "POSITIVE_STACK_SIZE_AT_BLOCK_END" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "MISSING_ACQUIRES_ANNOTATION" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "EXTRANEOUS_ACQUIRES_ANNOTATION" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "DUPLICATE_ACQUIRES_ANNOTATION" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "INVALID_ACQUIRES_ANNOTATION" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "GLOBAL_REFERENCE_ERROR" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "CONSTRAINT_NOT_SATISFIED" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "NUMBER_OF_TYPE_ARGUMENTS_MISMATCH" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "LOOP_IN_INSTANTIATION_GRAPH" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "ZERO_SIZED_STRUCT" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "LINKER_ERROR" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "INVALID_CONSTANT_TYPE" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "MALFORMED_CONSTANT_DATA" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "EMPTY_CODE_UNIT" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "INVALID_LOOP_SPLIT" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "INVALID_LOOP_BREAK" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "INVALID_LOOP_CONTINUE" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "UNSAFE_RET_UNUSED_VALUES_WITHOUT_DROP" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "TOO_MANY_LOCALS" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "GENERIC_MEMBER_OPCODE_MISMATCH" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "FUNCTION_RESOLUTION_FAILURE" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "INVALID_OPERATION_IN_SCRIPT" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "DUPLICATE_MODULE_NAME" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "BACKWARD_INCOMPATIBLE_MODULE_UPDATE" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "CYCLIC_MODULE_DEPENDENCY" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "NUMBER_OF_ARGUMENTS_MISMATCH" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (|
                          M.read (| mk_str "INVALID_PARAM_TYPE_FOR_DESERIALIZATION" |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "FAILED_TO_DESERIALIZE_ARGUMENT" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "NUMBER_OF_SIGNER_ARGUMENTS_MISMATCH" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (|
                          M.read (| mk_str "CALLED_SCRIPT_VISIBLE_FROM_NON_SCRIPT_VISIBLE" |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (|
                          M.read (| mk_str "EXECUTE_ENTRY_FUNCTION_CALLED_ON_NON_ENTRY_FUNCTION" |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "INVALID_FRIEND_DECL_WITH_SELF" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (|
                          M.read (|
                            mk_str "INVALID_FRIEND_DECL_WITH_MODULES_OUTSIDE_ACCOUNT_ADDRESS"
                          |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (|
                          M.read (| mk_str "INVALID_FRIEND_DECL_WITH_MODULES_IN_DEPENDENCIES" |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "CYCLIC_MODULE_FRIENDSHIP" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "INVALID_PHANTOM_TYPE_PARAM_POSITION" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (|
                          M.read (| mk_str "VEC_UPDATE_EXISTS_MUTABLE_BORROW_ERROR" |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (|
                          M.read (| mk_str "VEC_BORROW_ELEMENT_EXISTS_MUTABLE_BORROW_ERROR" |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "LOOP_MAX_DEPTH_REACHED" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "TOO_MANY_TYPE_PARAMETERS" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "TOO_MANY_PARAMETERS" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "TOO_MANY_BASIC_BLOCKS" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "VALUE_STACK_OVERFLOW" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "TOO_MANY_TYPE_NODES" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "VALUE_STACK_PUSH_OVERFLOW" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "MAX_DEPENDENCY_DEPTH_REACHED" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "MAX_FUNCTION_DEFINITIONS_REACHED" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "MAX_STRUCT_DEFINITIONS_REACHED" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "MAX_FIELD_DEFINITIONS_REACHED" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "TOO_MANY_BACK_EDGES" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "RESERVED_VERIFICATION_ERROR_1" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "RESERVED_VERIFICATION_ERROR_2" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "RESERVED_VERIFICATION_ERROR_3" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "RESERVED_VERIFICATION_ERROR_4" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "RESERVED_VERIFICATION_ERROR_5" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "UNKNOWN_INVARIANT_VIOLATION_ERROR" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "EMPTY_VALUE_STACK" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "PC_OVERFLOW" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "VERIFICATION_ERROR" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "STORAGE_ERROR" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "INTERNAL_TYPE_ERROR" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "EVENT_KEY_MISMATCH" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "UNREACHABLE" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "VM_STARTUP_FAILURE" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (|
                          M.read (| mk_str "UNEXPECTED_ERROR_FROM_KNOWN_MOVE_FUNCTION" |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "VERIFIER_INVARIANT_VIOLATION" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "UNEXPECTED_VERIFIER_ERROR" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "UNEXPECTED_DESERIALIZATION_ERROR" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "FAILED_TO_SERIALIZE_WRITE_SET_CHANGES" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "FAILED_TO_DESERIALIZE_RESOURCE" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "TYPE_RESOLUTION_FAILURE" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "DUPLICATE_NATIVE_FUNCTION" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "RESERVED_INVARIANT_VIOLATION_ERROR_1" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "RESERVED_INVARIANT_VIOLATION_ERROR_2" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "RESERVED_INVARIANT_VIOLATION_ERROR_3" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "RESERVED_INVARIANT_VIOLATION_ERROR_4" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "RESERVED_INVARIANT_VIOLATION_ERROR_5" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "UNKNOWN_BINARY_ERROR" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "MALFORMED" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "BAD_MAGIC" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "UNKNOWN_VERSION" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "UNKNOWN_TABLE_TYPE" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "UNKNOWN_SIGNATURE_TYPE" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "UNKNOWN_SERIALIZED_TYPE" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "UNKNOWN_OPCODE" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "BAD_HEADER_TABLE" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "UNEXPECTED_SIGNATURE_TYPE" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "DUPLICATE_TABLE" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "UNKNOWN_ABILITY" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "UNKNOWN_NATIVE_STRUCT_FLAG" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "BAD_U16" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "BAD_U32" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "BAD_U64" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "BAD_U128" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "BAD_U256" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "VALUE_SERIALIZATION_ERROR" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "VALUE_DESERIALIZATION_ERROR" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "CODE_DESERIALIZATION_ERROR" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "INVALID_FLAG_BITS" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "RESERVED_DESERIALIZAION_ERROR_1" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "RESERVED_DESERIALIZAION_ERROR_2" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "RESERVED_DESERIALIZAION_ERROR_3" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "RESERVED_DESERIALIZAION_ERROR_4" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "RESERVED_DESERIALIZAION_ERROR_5" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "UNKNOWN_RUNTIME_STATUS" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "EXECUTED" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "OUT_OF_GAS" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "RESOURCE_DOES_NOT_EXIST" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "RESOURCE_ALREADY_EXISTS" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "MISSING_DATA" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "DATA_FORMAT_ERROR" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "ABORTED" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "ARITHMETIC_ERROR" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "VECTOR_OPERATION_ERROR" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "EXECUTION_STACK_OVERFLOW" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "CALL_STACK_OVERFLOW" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "VM_MAX_TYPE_DEPTH_REACHED" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "VM_MAX_VALUE_DEPTH_REACHED" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "VM_EXTENSION_ERROR" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "STORAGE_WRITE_LIMIT_REACHED" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "MEMORY_LIMIT_EXCEEDED" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "VM_MAX_TYPE_NODES_REACHED" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "EXECUTION_LIMIT_REACHED" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "IO_LIMIT_REACHED" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "STORAGE_LIMIT_REACHED" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "RESERVED_RUNTIME_ERROR_1" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "RESERVED_RUNTIME_ERROR_2" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "RESERVED_RUNTIME_ERROR_3" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "RESERVED_RUNTIME_ERROR_4" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "RESERVED_RUNTIME_ERROR_5" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        M.alloc (| M.read (| mk_str "UNKNOWN_STATUS" |) |)))
                  ]
                |)
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_move_core_types_vm_status_StatusCode.
  
  Module Impl_core_marker_StructuralEq_for_move_core_types_vm_status_StatusCode.
    Definition Self : Ty.t := Ty.path "move_core_types::vm_status::StatusCode".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralEq_for_move_core_types_vm_status_StatusCode.
  
  Module Impl_core_cmp_Eq_for_move_core_types_vm_status_StatusCode.
    Definition Self : Ty.t := Ty.path "move_core_types::vm_status::StatusCode".
    
    (* Eq *)
    Definition assert_receiver_is_total_eq (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.Tuple []))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_move_core_types_vm_status_StatusCode.
  
  Module Impl_core_hash_Hash_for_move_core_types_vm_status_StatusCode.
    Definition Self : Ty.t := Ty.path "move_core_types::vm_status::StatusCode".
    
    (* Hash *)
    Definition hash (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ __H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let state := M.alloc (| state |) in
          M.read (|
            let __self_tag :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [ Ty.path "move_core_types::vm_status::StatusCode" ]
                  |),
                  [ M.read (| self |) ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                M.get_trait_method (| "core::hash::Hash", Ty.path "u64", [], "hash", [ __H ] |),
                [ __self_tag; M.read (| state |) ]
              |)
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::hash::Hash"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("hash", InstanceField.Method hash) ].
  End Impl_core_hash_Hash_for_move_core_types_vm_status_StatusCode.
  
  Module Impl_core_marker_StructuralPartialEq_for_move_core_types_vm_status_StatusCode.
    Definition Self : Ty.t := Ty.path "move_core_types::vm_status::StatusCode".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_move_core_types_vm_status_StatusCode.
  
  Module Impl_core_cmp_PartialEq_for_move_core_types_vm_status_StatusCode.
    Definition Self : Ty.t := Ty.path "move_core_types::vm_status::StatusCode".
    
    (* PartialEq *)
    Definition eq (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            let __self_tag :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [ Ty.path "move_core_types::vm_status::StatusCode" ]
                  |),
                  [ M.read (| self |) ]
                |)
              |) in
            let __arg1_tag :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [ Ty.path "move_core_types::vm_status::StatusCode" ]
                  |),
                  [ M.read (| other |) ]
                |)
              |) in
            M.alloc (| BinOp.Pure.eq (M.read (| __self_tag |)) (M.read (| __arg1_tag |)) |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_for_move_core_types_vm_status_StatusCode.
  
  Module Impl_core_cmp_PartialOrd_for_move_core_types_vm_status_StatusCode.
    Definition Self : Ty.t := Ty.path "move_core_types::vm_status::StatusCode".
    
    (* PartialOrd *)
    Definition partial_cmp (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            let __self_tag :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [ Ty.path "move_core_types::vm_status::StatusCode" ]
                  |),
                  [ M.read (| self |) ]
                |)
              |) in
            let __arg1_tag :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [ Ty.path "move_core_types::vm_status::StatusCode" ]
                  |),
                  [ M.read (| other |) ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                M.get_trait_method (|
                  "core::cmp::PartialOrd",
                  Ty.path "u64",
                  [ Ty.path "u64" ],
                  "partial_cmp",
                  []
                |),
                [ __self_tag; __arg1_tag ]
              |)
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialOrd"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("partial_cmp", InstanceField.Method partial_cmp) ].
  End Impl_core_cmp_PartialOrd_for_move_core_types_vm_status_StatusCode.
  
  Module Impl_core_cmp_Ord_for_move_core_types_vm_status_StatusCode.
    Definition Self : Ty.t := Ty.path "move_core_types::vm_status::StatusCode".
    
    (* Ord *)
    Definition cmp (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            let __self_tag :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [ Ty.path "move_core_types::vm_status::StatusCode" ]
                  |),
                  [ M.read (| self |) ]
                |)
              |) in
            let __arg1_tag :=
              M.alloc (|
                M.call_closure (|
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [ Ty.path "move_core_types::vm_status::StatusCode" ]
                  |),
                  [ M.read (| other |) ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                M.get_trait_method (| "core::cmp::Ord", Ty.path "u64", [], "cmp", [] |),
                [ __self_tag; __arg1_tag ]
              |)
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Ord"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("cmp", InstanceField.Method cmp) ].
  End Impl_core_cmp_Ord_for_move_core_types_vm_status_StatusCode.
  
  Module Impl_core_convert_TryFrom_u64_for_move_core_types_vm_status_StatusCode.
    Definition Self : Ty.t := Ty.path "move_core_types::vm_status::StatusCode".
    
    (*             type Error = &'static str; *)
    Definition _Error : Ty.t := Ty.apply (Ty.path "&") [ Ty.path "str" ].
    
    (*
                fn try_from(value: $repr_ty) -> Result<Self, Self::Error> {
                    match value {
                        $(
                            $value => Ok($enum_name::$variant),
                        )*
                        _ => Err("invalid StatusCode"),
                    }
                }
    *)
    Definition try_from (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ value ] =>
        ltac:(M.monadic
          (let value := M.alloc (| value |) in
          M.read (|
            M.match_operator (|
              value,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 0
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::UNKNOWN_VALIDATION_STATUS"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::INVALID_SIGNATURE"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 2
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::INVALID_AUTH_KEY"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 3
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::SEQUENCE_NUMBER_TOO_OLD"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 4
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::SEQUENCE_NUMBER_TOO_NEW"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 5
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::INSUFFICIENT_BALANCE_FOR_TRANSACTION_FEE"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 6
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::TRANSACTION_EXPIRED"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 7
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::SENDING_ACCOUNT_DOES_NOT_EXIST"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 8
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::REJECTED_WRITE_SET"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 9
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::INVALID_WRITE_SET"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 10
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::EXCEEDED_MAX_TRANSACTION_SIZE"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 11
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::UNKNOWN_SCRIPT"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 12
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::UNKNOWN_MODULE"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 13
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::MAX_GAS_UNITS_EXCEEDS_MAX_GAS_UNITS_BOUND"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 14
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::MAX_GAS_UNITS_BELOW_MIN_TRANSACTION_GAS_UNITS"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 15
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::GAS_UNIT_PRICE_BELOW_MIN_BOUND"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 16
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::GAS_UNIT_PRICE_ABOVE_MAX_BOUND"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 17
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::INVALID_GAS_SPECIFIER"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 18
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::SENDING_ACCOUNT_FROZEN"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 19
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::UNABLE_TO_DESERIALIZE_ACCOUNT"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 20
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::CURRENCY_INFO_DOES_NOT_EXIST"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 21
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::INVALID_MODULE_PUBLISHER"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 22
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::NO_ACCOUNT_ROLE"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 23
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::BAD_CHAIN_ID"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 24
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::SEQUENCE_NUMBER_TOO_BIG"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 25
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::BAD_TRANSACTION_FEE_CURRENCY"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 26
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::FEATURE_UNDER_GATING"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 27
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::SECONDARY_KEYS_ADDRESSES_COUNT_MISMATCH"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 28
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::SIGNERS_CONTAIN_DUPLICATES"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 29
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::SEQUENCE_NONCE_INVALID"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 30
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::CHAIN_ACCOUNT_INFO_DOES_NOT_EXIST"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 31
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::RESERVED_VALIDATION_ERROR_1"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 32
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::RESERVED_VALIDATION_ERROR_2"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 33
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::RESERVED_VALIDATION_ERROR_3"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 34
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::RESERVED_VALIDATION_ERROR_4"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 35
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::RESERVED_VALIDATION_ERROR_5"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1000
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::UNKNOWN_VERIFICATION_ERROR"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1001
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::INDEX_OUT_OF_BOUNDS"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1003
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::INVALID_SIGNATURE_TOKEN"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1005
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::RECURSIVE_STRUCT_DEFINITION"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1006
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::FIELD_MISSING_TYPE_ABILITY"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1007
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::INVALID_FALL_THROUGH"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1009
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::NEGATIVE_STACK_SIZE_WITHIN_BLOCK"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1011
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::INVALID_MAIN_FUNCTION_SIGNATURE"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1012
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::DUPLICATE_ELEMENT"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1013
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::INVALID_MODULE_HANDLE"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1014
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::UNIMPLEMENTED_HANDLE"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1017
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::LOOKUP_FAILED"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1020
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::TYPE_MISMATCH"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1021
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::MISSING_DEPENDENCY"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1023
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::POP_WITHOUT_DROP_ABILITY"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1025
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::BR_TYPE_MISMATCH_ERROR"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1026
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::ABORT_TYPE_MISMATCH_ERROR"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1027
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::STLOC_TYPE_MISMATCH_ERROR"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1028
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::STLOC_UNSAFE_TO_DESTROY_ERROR"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1029
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::UNSAFE_RET_LOCAL_OR_RESOURCE_STILL_BORROWED"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1030
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::RET_TYPE_MISMATCH_ERROR"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1031
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::RET_BORROWED_MUTABLE_REFERENCE_ERROR"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1032
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::FREEZEREF_TYPE_MISMATCH_ERROR"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1033
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::FREEZEREF_EXISTS_MUTABLE_BORROW_ERROR"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1034
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::BORROWFIELD_TYPE_MISMATCH_ERROR"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1035
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::BORROWFIELD_BAD_FIELD_ERROR"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1036
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::BORROWFIELD_EXISTS_MUTABLE_BORROW_ERROR"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1037
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::COPYLOC_UNAVAILABLE_ERROR"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1038
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::COPYLOC_WITHOUT_COPY_ABILITY"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1039
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::COPYLOC_EXISTS_BORROW_ERROR"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1040
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::MOVELOC_UNAVAILABLE_ERROR"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1041
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::MOVELOC_EXISTS_BORROW_ERROR"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1042
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::BORROWLOC_REFERENCE_ERROR"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1043
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::BORROWLOC_UNAVAILABLE_ERROR"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1044
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::BORROWLOC_EXISTS_BORROW_ERROR"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1045
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::CALL_TYPE_MISMATCH_ERROR"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1046
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::CALL_BORROWED_MUTABLE_REFERENCE_ERROR"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1047
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::PACK_TYPE_MISMATCH_ERROR"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1048
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::UNPACK_TYPE_MISMATCH_ERROR"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1049
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::READREF_TYPE_MISMATCH_ERROR"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1050
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::READREF_WITHOUT_COPY_ABILITY"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1051
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::READREF_EXISTS_MUTABLE_BORROW_ERROR"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1052
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::WRITEREF_TYPE_MISMATCH_ERROR"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1053
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::WRITEREF_WITHOUT_DROP_ABILITY"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1054
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::WRITEREF_EXISTS_BORROW_ERROR"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1055
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::WRITEREF_NO_MUTABLE_REFERENCE_ERROR"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1056
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::INTEGER_OP_TYPE_MISMATCH_ERROR"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1057
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::BOOLEAN_OP_TYPE_MISMATCH_ERROR"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1058
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::EQUALITY_OP_TYPE_MISMATCH_ERROR"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1059
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::EXISTS_WITHOUT_KEY_ABILITY_OR_BAD_ARGUMENT"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1060
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::BORROWGLOBAL_TYPE_MISMATCH_ERROR"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1061
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::BORROWGLOBAL_WITHOUT_KEY_ABILITY"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1062
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::MOVEFROM_TYPE_MISMATCH_ERROR"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1063
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::MOVEFROM_WITHOUT_KEY_ABILITY"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1064
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::MOVETO_TYPE_MISMATCH_ERROR"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1065
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::MOVETO_WITHOUT_KEY_ABILITY"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1067
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::MODULE_ADDRESS_DOES_NOT_MATCH_SENDER"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1068
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::NO_MODULE_HANDLES"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1069
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::POSITIVE_STACK_SIZE_AT_BLOCK_END"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1070
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::MISSING_ACQUIRES_ANNOTATION"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1071
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::EXTRANEOUS_ACQUIRES_ANNOTATION"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1072
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::DUPLICATE_ACQUIRES_ANNOTATION"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1073
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::INVALID_ACQUIRES_ANNOTATION"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1074
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::GLOBAL_REFERENCE_ERROR"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1075
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::CONSTRAINT_NOT_SATISFIED"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1076
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::NUMBER_OF_TYPE_ARGUMENTS_MISMATCH"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1077
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::LOOP_IN_INSTANTIATION_GRAPH"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1080
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::ZERO_SIZED_STRUCT"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1081
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::LINKER_ERROR"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1082
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::INVALID_CONSTANT_TYPE"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1083
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::MALFORMED_CONSTANT_DATA"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1084
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::EMPTY_CODE_UNIT"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1085
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::INVALID_LOOP_SPLIT"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1086
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::INVALID_LOOP_BREAK"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1087
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::INVALID_LOOP_CONTINUE"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1088
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::UNSAFE_RET_UNUSED_VALUES_WITHOUT_DROP"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1089
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::TOO_MANY_LOCALS"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1090
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::GENERIC_MEMBER_OPCODE_MISMATCH"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1091
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::FUNCTION_RESOLUTION_FAILURE"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1094
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::INVALID_OPERATION_IN_SCRIPT"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1095
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::DUPLICATE_MODULE_NAME"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1096
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::BACKWARD_INCOMPATIBLE_MODULE_UPDATE"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1097
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::CYCLIC_MODULE_DEPENDENCY"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1098
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::NUMBER_OF_ARGUMENTS_MISMATCH"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1099
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::INVALID_PARAM_TYPE_FOR_DESERIALIZATION"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1100
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::FAILED_TO_DESERIALIZE_ARGUMENT"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1101
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::NUMBER_OF_SIGNER_ARGUMENTS_MISMATCH"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1102
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::CALLED_SCRIPT_VISIBLE_FROM_NON_SCRIPT_VISIBLE"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1103
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::EXECUTE_ENTRY_FUNCTION_CALLED_ON_NON_ENTRY_FUNCTION"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1104
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::INVALID_FRIEND_DECL_WITH_SELF"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1105
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::INVALID_FRIEND_DECL_WITH_MODULES_OUTSIDE_ACCOUNT_ADDRESS"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1106
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::INVALID_FRIEND_DECL_WITH_MODULES_IN_DEPENDENCIES"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1107
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::CYCLIC_MODULE_FRIENDSHIP"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1108
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::INVALID_PHANTOM_TYPE_PARAM_POSITION"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1109
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::VEC_UPDATE_EXISTS_MUTABLE_BORROW_ERROR"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1110
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::VEC_BORROW_ELEMENT_EXISTS_MUTABLE_BORROW_ERROR"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1111
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::LOOP_MAX_DEPTH_REACHED"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1112
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::TOO_MANY_TYPE_PARAMETERS"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1113
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::TOO_MANY_PARAMETERS"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1114
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::TOO_MANY_BASIC_BLOCKS"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1115
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::VALUE_STACK_OVERFLOW"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1116
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::TOO_MANY_TYPE_NODES"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1117
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::VALUE_STACK_PUSH_OVERFLOW"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1118
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::MAX_DEPENDENCY_DEPTH_REACHED"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1119
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::MAX_FUNCTION_DEFINITIONS_REACHED"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1120
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::MAX_STRUCT_DEFINITIONS_REACHED"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1121
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::MAX_FIELD_DEFINITIONS_REACHED"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1122
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::TOO_MANY_BACK_EDGES"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1123
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::RESERVED_VERIFICATION_ERROR_1"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1124
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::RESERVED_VERIFICATION_ERROR_2"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1125
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::RESERVED_VERIFICATION_ERROR_3"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1126
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::RESERVED_VERIFICATION_ERROR_4"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 1127
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::RESERVED_VERIFICATION_ERROR_5"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 2000
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 2003
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::EMPTY_VALUE_STACK"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 2005
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [ Value.StructTuple "move_core_types::vm_status::StatusCode::PC_OVERFLOW" []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 2006
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::VERIFICATION_ERROR"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 2008
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::STORAGE_ERROR"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 2009
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::INTERNAL_TYPE_ERROR"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 2010
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::EVENT_KEY_MISMATCH"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 2011
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [ Value.StructTuple "move_core_types::vm_status::StatusCode::UNREACHABLE" []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 2012
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::VM_STARTUP_FAILURE"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 2015
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::UNEXPECTED_ERROR_FROM_KNOWN_MOVE_FUNCTION"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 2016
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::VERIFIER_INVARIANT_VIOLATION"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 2017
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::UNEXPECTED_VERIFIER_ERROR"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 2018
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::UNEXPECTED_DESERIALIZATION_ERROR"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 2019
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::FAILED_TO_SERIALIZE_WRITE_SET_CHANGES"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 2020
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::FAILED_TO_DESERIALIZE_RESOURCE"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 2021
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::TYPE_RESOLUTION_FAILURE"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 2022
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::DUPLICATE_NATIVE_FUNCTION"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 2023
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::RESERVED_INVARIANT_VIOLATION_ERROR_1"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 2024
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::RESERVED_INVARIANT_VIOLATION_ERROR_2"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 2025
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::RESERVED_INVARIANT_VIOLATION_ERROR_3"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 2026
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::RESERVED_INVARIANT_VIOLATION_ERROR_4"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 2027
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::RESERVED_INVARIANT_VIOLATION_ERROR_5"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 3000
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::UNKNOWN_BINARY_ERROR"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 3001
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [ Value.StructTuple "move_core_types::vm_status::StatusCode::MALFORMED" [] ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 3002
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [ Value.StructTuple "move_core_types::vm_status::StatusCode::BAD_MAGIC" [] ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 3003
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::UNKNOWN_VERSION"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 3004
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::UNKNOWN_TABLE_TYPE"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 3005
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::UNKNOWN_SIGNATURE_TYPE"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 3006
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::UNKNOWN_SERIALIZED_TYPE"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 3007
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::UNKNOWN_OPCODE"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 3008
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::BAD_HEADER_TABLE"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 3009
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::UNEXPECTED_SIGNATURE_TYPE"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 3010
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::DUPLICATE_TABLE"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 3013
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::UNKNOWN_ABILITY"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 3014
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::UNKNOWN_NATIVE_STRUCT_FLAG"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 3017
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [ Value.StructTuple "move_core_types::vm_status::StatusCode::BAD_U16" [] ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 3018
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [ Value.StructTuple "move_core_types::vm_status::StatusCode::BAD_U32" [] ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 3019
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [ Value.StructTuple "move_core_types::vm_status::StatusCode::BAD_U64" [] ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 3020
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [ Value.StructTuple "move_core_types::vm_status::StatusCode::BAD_U128" [] ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 3021
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [ Value.StructTuple "move_core_types::vm_status::StatusCode::BAD_U256" [] ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 3022
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::VALUE_SERIALIZATION_ERROR"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 3023
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::VALUE_DESERIALIZATION_ERROR"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 3024
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::CODE_DESERIALIZATION_ERROR"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 3025
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::INVALID_FLAG_BITS"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 3026
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::RESERVED_DESERIALIZAION_ERROR_1"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 3027
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::RESERVED_DESERIALIZAION_ERROR_2"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 3028
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::RESERVED_DESERIALIZAION_ERROR_3"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 3029
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::RESERVED_DESERIALIZAION_ERROR_4"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 3030
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::RESERVED_DESERIALIZAION_ERROR_5"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 4000
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::UNKNOWN_RUNTIME_STATUS"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 4001
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [ Value.StructTuple "move_core_types::vm_status::StatusCode::EXECUTED" [] ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 4002
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [ Value.StructTuple "move_core_types::vm_status::StatusCode::OUT_OF_GAS" []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 4003
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::RESOURCE_DOES_NOT_EXIST"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 4004
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::RESOURCE_ALREADY_EXISTS"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 4008
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::MISSING_DATA"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 4009
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::DATA_FORMAT_ERROR"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 4016
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [ Value.StructTuple "move_core_types::vm_status::StatusCode::ABORTED" [] ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 4017
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::ARITHMETIC_ERROR"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 4018
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::VECTOR_OPERATION_ERROR"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 4020
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::EXECUTION_STACK_OVERFLOW"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 4021
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::CALL_STACK_OVERFLOW"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 4024
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::VM_MAX_TYPE_DEPTH_REACHED"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 4025
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::VM_MAX_VALUE_DEPTH_REACHED"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 4026
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::VM_EXTENSION_ERROR"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 4027
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::STORAGE_WRITE_LIMIT_REACHED"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 4028
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::MEMORY_LIMIT_EXCEEDED"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 4029
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::VM_MAX_TYPE_NODES_REACHED"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 4030
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::EXECUTION_LIMIT_REACHED"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 4031
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::IO_LIMIT_REACHED"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 4032
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::STORAGE_LIMIT_REACHED"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 4033
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::RESERVED_RUNTIME_ERROR_1"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 4034
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::RESERVED_RUNTIME_ERROR_2"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 4035
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::RESERVED_RUNTIME_ERROR_3"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 4036
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::RESERVED_RUNTIME_ERROR_4"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 4037
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::RESERVED_RUNTIME_ERROR_5"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer Integer.U64 18446744073709551615
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          Value.StructTuple
                            "move_core_types::vm_status::StatusCode::UNKNOWN_STATUS"
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Err"
                        [ M.read (| mk_str "invalid StatusCode" |) ]
                    |)))
              ]
            |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::convert::TryFrom"
        Self
        (* Trait polymorphic types *) [ (* T *) Ty.path "u64" ]
        (* Instance *)
        [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
  End Impl_core_convert_TryFrom_u64_for_move_core_types_vm_status_StatusCode.
  
  Module Impl_move_core_types_vm_status_StatusCode.
    Definition Self : Ty.t := Ty.path "move_core_types::vm_status::StatusCode".
    
    (*
        pub fn status_type(self) -> StatusType {
            let major_status_number: u64 = self.into();
            if major_status_number >= VALIDATION_STATUS_MIN_CODE
                && major_status_number <= VALIDATION_STATUS_MAX_CODE
            {
                return StatusType::Validation;
            }
    
            if major_status_number >= VERIFICATION_STATUS_MIN_CODE
                && major_status_number <= VERIFICATION_STATUS_MAX_CODE
            {
                return StatusType::Verification;
            }
    
            if major_status_number >= INVARIANT_VIOLATION_STATUS_MIN_CODE
                && major_status_number <= INVARIANT_VIOLATION_STATUS_MAX_CODE
            {
                return StatusType::InvariantViolation;
            }
    
            if major_status_number >= DESERIALIZATION_STATUS_MIN_CODE
                && major_status_number <= DESERIALIZATION_STATUS_MAX_CODE
            {
                return StatusType::Deserialization;
            }
    
            if major_status_number >= EXECUTION_STATUS_MIN_CODE
                && major_status_number <= EXECUTION_STATUS_MAX_CODE
            {
                return StatusType::Execution;
            }
    
            StatusType::Unknown
        }
    *)
    Definition status_type (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let major_status_number :=
              M.alloc (|
                M.call_closure (|
                  M.get_trait_method (|
                    "core::convert::Into",
                    Ty.path "move_core_types::vm_status::StatusCode",
                    [ Ty.path "u64" ],
                    "into",
                    []
                  |),
                  [ M.read (| self |) ]
                |)
              |) in
            let _ :=
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            LogicalOp.and (|
                              BinOp.Pure.ge
                                (M.read (| major_status_number |))
                                (M.read (|
                                  M.read (|
                                    M.get_constant (|
                                      "move_core_types::vm_status::VALIDATION_STATUS_MIN_CODE"
                                    |)
                                  |)
                                |)),
                              ltac:(M.monadic
                                (BinOp.Pure.le
                                  (M.read (| major_status_number |))
                                  (M.read (|
                                    M.read (|
                                      M.get_constant (|
                                        "move_core_types::vm_status::VALIDATION_STATUS_MAX_CODE"
                                      |)
                                    |)
                                  |))))
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        M.never_to_any (|
                          M.read (|
                            M.return_ (|
                              Value.StructTuple
                                "move_core_types::vm_status::StatusType::Validation"
                                []
                            |)
                          |)
                        |)
                      |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            let _ :=
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            LogicalOp.and (|
                              BinOp.Pure.ge
                                (M.read (| major_status_number |))
                                (M.read (|
                                  M.read (|
                                    M.get_constant (|
                                      "move_core_types::vm_status::VERIFICATION_STATUS_MIN_CODE"
                                    |)
                                  |)
                                |)),
                              ltac:(M.monadic
                                (BinOp.Pure.le
                                  (M.read (| major_status_number |))
                                  (M.read (|
                                    M.read (|
                                      M.get_constant (|
                                        "move_core_types::vm_status::VERIFICATION_STATUS_MAX_CODE"
                                      |)
                                    |)
                                  |))))
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        M.never_to_any (|
                          M.read (|
                            M.return_ (|
                              Value.StructTuple
                                "move_core_types::vm_status::StatusType::Verification"
                                []
                            |)
                          |)
                        |)
                      |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            let _ :=
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            LogicalOp.and (|
                              BinOp.Pure.ge
                                (M.read (| major_status_number |))
                                (M.read (|
                                  M.read (|
                                    M.get_constant (|
                                      "move_core_types::vm_status::INVARIANT_VIOLATION_STATUS_MIN_CODE"
                                    |)
                                  |)
                                |)),
                              ltac:(M.monadic
                                (BinOp.Pure.le
                                  (M.read (| major_status_number |))
                                  (M.read (|
                                    M.read (|
                                      M.get_constant (|
                                        "move_core_types::vm_status::INVARIANT_VIOLATION_STATUS_MAX_CODE"
                                      |)
                                    |)
                                  |))))
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        M.never_to_any (|
                          M.read (|
                            M.return_ (|
                              Value.StructTuple
                                "move_core_types::vm_status::StatusType::InvariantViolation"
                                []
                            |)
                          |)
                        |)
                      |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            let _ :=
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            LogicalOp.and (|
                              BinOp.Pure.ge
                                (M.read (| major_status_number |))
                                (M.read (|
                                  M.read (|
                                    M.get_constant (|
                                      "move_core_types::vm_status::DESERIALIZATION_STATUS_MIN_CODE"
                                    |)
                                  |)
                                |)),
                              ltac:(M.monadic
                                (BinOp.Pure.le
                                  (M.read (| major_status_number |))
                                  (M.read (|
                                    M.read (|
                                      M.get_constant (|
                                        "move_core_types::vm_status::DESERIALIZATION_STATUS_MAX_CODE"
                                      |)
                                    |)
                                  |))))
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        M.never_to_any (|
                          M.read (|
                            M.return_ (|
                              Value.StructTuple
                                "move_core_types::vm_status::StatusType::Deserialization"
                                []
                            |)
                          |)
                        |)
                      |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            let _ :=
              M.match_operator (|
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            LogicalOp.and (|
                              BinOp.Pure.ge
                                (M.read (| major_status_number |))
                                (M.read (|
                                  M.read (|
                                    M.get_constant (|
                                      "move_core_types::vm_status::EXECUTION_STATUS_MIN_CODE"
                                    |)
                                  |)
                                |)),
                              ltac:(M.monadic
                                (BinOp.Pure.le
                                  (M.read (| major_status_number |))
                                  (M.read (|
                                    M.read (|
                                      M.get_constant (|
                                        "move_core_types::vm_status::EXECUTION_STATUS_MAX_CODE"
                                      |)
                                    |)
                                  |))))
                            |)
                          |)) in
                      let _ := M.is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        M.never_to_any (|
                          M.read (|
                            M.return_ (|
                              Value.StructTuple
                                "move_core_types::vm_status::StatusType::Execution"
                                []
                            |)
                          |)
                        |)
                      |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            M.alloc (| Value.StructTuple "move_core_types::vm_status::StatusType::Unknown" [] |)
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom AssociatedFunction_status_type : M.IsAssociatedFunction Self "status_type" status_type.
  End Impl_move_core_types_vm_status_StatusCode.
  
  Module Impl_serde_ser_Serialize_for_move_core_types_vm_status_StatusCode.
    Definition Self : Ty.t := Ty.path "move_core_types::vm_status::StatusCode".
    
    (*
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: ser::Serializer,
        {
            serializer.serialize_u64(( *self).into())
        }
    *)
    Definition serialize (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ _ as S ], [ self; serializer ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let serializer := M.alloc (| serializer |) in
          M.call_closure (|
            M.get_trait_method (| "serde::ser::Serializer", S, [], "serialize_u64", [] |),
            [
              M.read (| serializer |);
              M.call_closure (|
                M.get_trait_method (|
                  "core::convert::Into",
                  Ty.path "move_core_types::vm_status::StatusCode",
                  [ Ty.path "u64" ],
                  "into",
                  []
                |),
                [ M.read (| M.read (| self |) |) ]
              |)
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "serde::ser::Serialize"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("serialize", InstanceField.Method serialize) ].
  End Impl_serde_ser_Serialize_for_move_core_types_vm_status_StatusCode.
  
  Module Impl_serde_de_Deserialize_for_move_core_types_vm_status_StatusCode.
    Definition Self : Ty.t := Ty.path "move_core_types::vm_status::StatusCode".
    
    (*
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: de::Deserializer<'de>,
        {
            struct StatusCodeVisitor;
            impl<'de> de::Visitor<'de> for StatusCodeVisitor {
                type Value = StatusCode;
    
                fn expecting(&self, formatter: &mut fmt::Formatter<'_>) -> fmt::Result {
                    formatter.write_str("StatusCode as u64")
                }
    
                fn visit_u64<E>(self, v: u64) -> std::result::Result<StatusCode, E>
                where
                    E: de::Error,
                {
                    Ok(StatusCode::try_from(v).unwrap_or(StatusCode::UNKNOWN_STATUS))
                }
            }
    
            deserializer.deserialize_u64(StatusCodeVisitor)
        }
    *)
    Definition deserialize (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [ D ], [ deserializer ] =>
        ltac:(M.monadic
          (let deserializer := M.alloc (| deserializer |) in
          M.call_closure (|
            M.get_trait_method (|
              "serde::de::Deserializer",
              D,
              [],
              "deserialize_u64",
              [ Ty.path "move_core_types::vm_status::deserialize::StatusCodeVisitor" ]
            |),
            [
              M.read (| deserializer |);
              Value.StructTuple "move_core_types::vm_status::deserialize::StatusCodeVisitor" []
            ]
          |)))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "serde::de::Deserialize"
        Self
        (* Trait polymorphic types *) []
        (* Instance *) [ ("deserialize", InstanceField.Method deserialize) ].
  End Impl_serde_de_Deserialize_for_move_core_types_vm_status_StatusCode.
  
  Module Impl_core_convert_From_move_core_types_vm_status_StatusCode_for_u64.
    Definition Self : Ty.t := Ty.path "u64".
    
    (*
        fn from(status: StatusCode) -> u64 {
            status as u64
        }
    *)
    Definition from (τ : list Ty.t) (α : list Value.t) : M :=
      match τ, α with
      | [], [ status ] =>
        ltac:(M.monadic
          (let status := M.alloc (| status |) in
          M.rust_cast (M.read (| status |))))
      | _, _ => M.impossible
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::convert::From"
        Self
        (* Trait polymorphic types *) [ (* T *) Ty.path "move_core_types::vm_status::StatusCode" ]
        (* Instance *) [ ("from", InstanceField.Method from) ].
  End Impl_core_convert_From_move_core_types_vm_status_StatusCode_for_u64.
  
  Module sub_status.
    Definition value_NFE_VECTOR_ERROR_BASE : Value.t :=
      M.run ltac:(M.monadic (M.alloc (| Value.Integer Integer.U64 0 |))).
    
    Definition value_NFE_BCS_SERIALIZATION_FAILURE : Value.t :=
      M.run ltac:(M.monadic (M.alloc (| Value.Integer Integer.U64 453 |))).
  End sub_status.
End vm_status.
