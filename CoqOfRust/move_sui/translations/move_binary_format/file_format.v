(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module file_format.
  Axiom TableIndex : (Ty.path "move_binary_format::file_format::TableIndex") = (Ty.path "u16").
  
  (* StructTuple
    {
      name := "ModuleHandleIndex";
      const_params := [];
      ty_params := [];
      fields := [ Ty.path "u16" ];
    } *)
  
  Module Impl_core_clone_Clone_for_move_binary_format_file_format_ModuleHandleIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::ModuleHandleIndex".
    
    (*         Clone *)
    Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Ty.apply
                (Ty.path "*")
                []
                [ Ty.path "move_binary_format::file_format::ModuleHandleIndex" ],
              Value.DeclaredButUndefined,
              [ fun γ => ltac:(M.monadic (M.deref (| M.read (| self |) |))) ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_move_binary_format_file_format_ModuleHandleIndex.
  
  Module Impl_core_marker_Copy_for_move_binary_format_file_format_ModuleHandleIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::ModuleHandleIndex".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::Copy"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_Copy_for_move_binary_format_file_format_ModuleHandleIndex.
  
  Module Impl_core_default_Default_for_move_binary_format_file_format_ModuleHandleIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::ModuleHandleIndex".
    
    (*         Default *)
    Definition default (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [] =>
        ltac:(M.monadic
          (Value.StructTuple
            "move_binary_format::file_format::ModuleHandleIndex"
            []
            []
            [
              M.call_closure (|
                Ty.path "u16",
                M.get_trait_method (|
                  "core::default::Default",
                  Ty.path "u16",
                  [],
                  [],
                  "default",
                  [],
                  []
                |),
                []
              |)
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::default::Default"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("default", InstanceField.Method default) ].
  End Impl_core_default_Default_for_move_binary_format_file_format_ModuleHandleIndex.
  
  Module Impl_core_cmp_Eq_for_move_binary_format_file_format_ModuleHandleIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::ModuleHandleIndex".
    
    (*         Eq *)
    Definition assert_receiver_is_total_eq
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              Value.DeclaredButUndefined,
              [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_move_binary_format_file_format_ModuleHandleIndex.
  
  Module Impl_core_hash_Hash_for_move_binary_format_file_format_ModuleHandleIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::ModuleHandleIndex".
    
    (*         Hash *)
    Definition hash (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ __H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let state := M.alloc (| state |) in
          M.call_closure (|
            Ty.tuple [],
            M.get_trait_method (| "core::hash::Hash", Ty.path "u16", [], [], "hash", [], [ __H ] |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| self |) |),
                      "move_binary_format::file_format::ModuleHandleIndex",
                      0
                    |)
                  |)
                |)
              |);
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::hash::Hash"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("hash", InstanceField.Method hash) ].
  End Impl_core_hash_Hash_for_move_binary_format_file_format_ModuleHandleIndex.
  
  Module Impl_core_cmp_Ord_for_move_binary_format_file_format_ModuleHandleIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::ModuleHandleIndex".
    
    (*         Ord *)
    Definition cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.path "core::cmp::Ordering",
            M.get_trait_method (| "core::cmp::Ord", Ty.path "u16", [], [], "cmp", [], [] |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| self |) |),
                      "move_binary_format::file_format::ModuleHandleIndex",
                      0
                    |)
                  |)
                |)
              |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| other |) |),
                      "move_binary_format::file_format::ModuleHandleIndex",
                      0
                    |)
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Ord"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("cmp", InstanceField.Method cmp) ].
  End Impl_core_cmp_Ord_for_move_binary_format_file_format_ModuleHandleIndex.
  
  Module Impl_core_marker_StructuralPartialEq_for_move_binary_format_file_format_ModuleHandleIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::ModuleHandleIndex".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_move_binary_format_file_format_ModuleHandleIndex.
  
  Module Impl_core_cmp_PartialEq_move_binary_format_file_format_ModuleHandleIndex_for_move_binary_format_file_format_ModuleHandleIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::ModuleHandleIndex".
    
    (*         PartialEq *)
    Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.path "bool",
            BinOp.eq,
            [
              M.read (|
                M.SubPointer.get_struct_tuple_field (|
                  M.deref (| M.read (| self |) |),
                  "move_binary_format::file_format::ModuleHandleIndex",
                  0
                |)
              |);
              M.read (|
                M.SubPointer.get_struct_tuple_field (|
                  M.deref (| M.read (| other |) |),
                  "move_binary_format::file_format::ModuleHandleIndex",
                  0
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.path "move_binary_format::file_format::ModuleHandleIndex" ]
        Self
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_move_binary_format_file_format_ModuleHandleIndex_for_move_binary_format_file_format_ModuleHandleIndex.
  
  Module Impl_core_cmp_PartialOrd_move_binary_format_file_format_ModuleHandleIndex_for_move_binary_format_file_format_ModuleHandleIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::ModuleHandleIndex".
    
    (*         PartialOrd *)
    Definition partial_cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "core::cmp::Ordering" ],
            M.get_trait_method (|
              "core::cmp::PartialOrd",
              Ty.path "u16",
              [],
              [ Ty.path "u16" ],
              "partial_cmp",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| self |) |),
                      "move_binary_format::file_format::ModuleHandleIndex",
                      0
                    |)
                  |)
                |)
              |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| other |) |),
                      "move_binary_format::file_format::ModuleHandleIndex",
                      0
                    |)
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialOrd"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.path "move_binary_format::file_format::ModuleHandleIndex" ]
        Self
        (* Instance *) [ ("partial_cmp", InstanceField.Method partial_cmp) ].
  End Impl_core_cmp_PartialOrd_move_binary_format_file_format_ModuleHandleIndex_for_move_binary_format_file_format_ModuleHandleIndex.
  
  Module Impl_move_binary_format_file_format_ModuleHandleIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::ModuleHandleIndex".
    
    (*
                pub fn new(idx: TableIndex) -> Self {
                    Self(idx)
                }
    *)
    Definition new (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ idx ] =>
        ltac:(M.monadic
          (let idx := M.alloc (| idx |) in
          Value.StructTuple
            "move_binary_format::file_format::ModuleHandleIndex"
            []
            []
            [ M.read (| idx |) ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_new : M.IsAssociatedFunction.C Self "new" new.
    Admitted.
    Global Typeclasses Opaque new.
  End Impl_move_binary_format_file_format_ModuleHandleIndex.
  
  Module Impl_core_fmt_Display_for_move_binary_format_file_format_ModuleHandleIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::ModuleHandleIndex".
    
    (*
                fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "{}", self.0)
                }
    *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_fmt", [], [] |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
              M.call_closure (|
                Ty.path "core::fmt::Arguments",
                M.get_associated_function (|
                  Ty.path "core::fmt::Arguments",
                  "new_v1",
                  [ Value.Integer IntegerKind.Usize 1; Value.Integer IntegerKind.Usize 1 ],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (| Pointer.Kind.Ref, M.alloc (| Value.Array [ mk_str (| "" |) ] |) |)
                    |)
                  |);
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          Value.Array
                            [
                              M.call_closure (|
                                Ty.path "core::fmt::rt::Argument",
                                M.get_associated_function (|
                                  Ty.path "core::fmt::rt::Argument",
                                  "new_display",
                                  [],
                                  [ Ty.path "u16" ]
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.SubPointer.get_struct_tuple_field (|
                                          M.deref (| M.read (| self |) |),
                                          "move_binary_format::file_format::ModuleHandleIndex",
                                          0
                                        |)
                                      |)
                                    |)
                                  |)
                                ]
                              |)
                            ]
                        |)
                      |)
                    |)
                  |)
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Display"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Display_for_move_binary_format_file_format_ModuleHandleIndex.
  
  Module Impl_core_fmt_Debug_for_move_binary_format_file_format_ModuleHandleIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::ModuleHandleIndex".
    
    (*
                fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "{}({})", stringify!($name), self.0)
                }
    *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_fmt", [], [] |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
              M.call_closure (|
                Ty.path "core::fmt::Arguments",
                M.get_associated_function (|
                  Ty.path "core::fmt::Arguments",
                  "new_v1",
                  [ Value.Integer IntegerKind.Usize 2; Value.Integer IntegerKind.Usize 1 ],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          Value.Array [ mk_str (| "ModuleHandleIndex(" |); mk_str (| ")" |) ]
                        |)
                      |)
                    |)
                  |);
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          Value.Array
                            [
                              M.call_closure (|
                                Ty.path "core::fmt::rt::Argument",
                                M.get_associated_function (|
                                  Ty.path "core::fmt::rt::Argument",
                                  "new_display",
                                  [],
                                  [ Ty.path "u16" ]
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.SubPointer.get_struct_tuple_field (|
                                          M.deref (| M.read (| self |) |),
                                          "move_binary_format::file_format::ModuleHandleIndex",
                                          0
                                        |)
                                      |)
                                    |)
                                  |)
                                ]
                              |)
                            ]
                        |)
                      |)
                    |)
                  |)
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_move_binary_format_file_format_ModuleHandleIndex.
  
  Module Impl_move_binary_format_internals_ModuleIndex_for_move_binary_format_file_format_ModuleHandleIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::ModuleHandleIndex".
    
    (*             const KIND: IndexKind = IndexKind::$kind; *)
    (* Ty.path "move_binary_format::IndexKind" *)
    Definition value_KIND (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      ltac:(M.monadic
        (M.alloc (| Value.StructTuple "move_binary_format::IndexKind::ModuleHandle" [] [] [] |))).
    
    (*
                fn into_index(self) -> usize {
                    self.0 as usize
                }
    *)
    Definition into_index (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.cast
            (Ty.path "usize")
            (M.read (|
              M.SubPointer.get_struct_tuple_field (|
                self,
                "move_binary_format::file_format::ModuleHandleIndex",
                0
              |)
            |))))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "move_binary_format::internals::ModuleIndex"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *)
        [
          ("value_KIND", InstanceField.Method value_KIND);
          ("into_index", InstanceField.Method into_index)
        ].
  End Impl_move_binary_format_internals_ModuleIndex_for_move_binary_format_file_format_ModuleHandleIndex.
  
  (* StructTuple
    {
      name := "StructHandleIndex";
      const_params := [];
      ty_params := [];
      fields := [ Ty.path "u16" ];
    } *)
  
  Module Impl_core_clone_Clone_for_move_binary_format_file_format_StructHandleIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::StructHandleIndex".
    
    (*         Clone *)
    Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Ty.apply
                (Ty.path "*")
                []
                [ Ty.path "move_binary_format::file_format::StructHandleIndex" ],
              Value.DeclaredButUndefined,
              [ fun γ => ltac:(M.monadic (M.deref (| M.read (| self |) |))) ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_move_binary_format_file_format_StructHandleIndex.
  
  Module Impl_core_marker_Copy_for_move_binary_format_file_format_StructHandleIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::StructHandleIndex".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::Copy"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_Copy_for_move_binary_format_file_format_StructHandleIndex.
  
  Module Impl_core_default_Default_for_move_binary_format_file_format_StructHandleIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::StructHandleIndex".
    
    (*         Default *)
    Definition default (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [] =>
        ltac:(M.monadic
          (Value.StructTuple
            "move_binary_format::file_format::StructHandleIndex"
            []
            []
            [
              M.call_closure (|
                Ty.path "u16",
                M.get_trait_method (|
                  "core::default::Default",
                  Ty.path "u16",
                  [],
                  [],
                  "default",
                  [],
                  []
                |),
                []
              |)
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::default::Default"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("default", InstanceField.Method default) ].
  End Impl_core_default_Default_for_move_binary_format_file_format_StructHandleIndex.
  
  Module Impl_core_cmp_Eq_for_move_binary_format_file_format_StructHandleIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::StructHandleIndex".
    
    (*         Eq *)
    Definition assert_receiver_is_total_eq
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              Value.DeclaredButUndefined,
              [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_move_binary_format_file_format_StructHandleIndex.
  
  Module Impl_core_hash_Hash_for_move_binary_format_file_format_StructHandleIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::StructHandleIndex".
    
    (*         Hash *)
    Definition hash (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ __H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let state := M.alloc (| state |) in
          M.call_closure (|
            Ty.tuple [],
            M.get_trait_method (| "core::hash::Hash", Ty.path "u16", [], [], "hash", [], [ __H ] |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| self |) |),
                      "move_binary_format::file_format::StructHandleIndex",
                      0
                    |)
                  |)
                |)
              |);
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::hash::Hash"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("hash", InstanceField.Method hash) ].
  End Impl_core_hash_Hash_for_move_binary_format_file_format_StructHandleIndex.
  
  Module Impl_core_cmp_Ord_for_move_binary_format_file_format_StructHandleIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::StructHandleIndex".
    
    (*         Ord *)
    Definition cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.path "core::cmp::Ordering",
            M.get_trait_method (| "core::cmp::Ord", Ty.path "u16", [], [], "cmp", [], [] |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| self |) |),
                      "move_binary_format::file_format::StructHandleIndex",
                      0
                    |)
                  |)
                |)
              |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| other |) |),
                      "move_binary_format::file_format::StructHandleIndex",
                      0
                    |)
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Ord"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("cmp", InstanceField.Method cmp) ].
  End Impl_core_cmp_Ord_for_move_binary_format_file_format_StructHandleIndex.
  
  Module Impl_core_marker_StructuralPartialEq_for_move_binary_format_file_format_StructHandleIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::StructHandleIndex".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_move_binary_format_file_format_StructHandleIndex.
  
  Module Impl_core_cmp_PartialEq_move_binary_format_file_format_StructHandleIndex_for_move_binary_format_file_format_StructHandleIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::StructHandleIndex".
    
    (*         PartialEq *)
    Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.path "bool",
            BinOp.eq,
            [
              M.read (|
                M.SubPointer.get_struct_tuple_field (|
                  M.deref (| M.read (| self |) |),
                  "move_binary_format::file_format::StructHandleIndex",
                  0
                |)
              |);
              M.read (|
                M.SubPointer.get_struct_tuple_field (|
                  M.deref (| M.read (| other |) |),
                  "move_binary_format::file_format::StructHandleIndex",
                  0
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.path "move_binary_format::file_format::StructHandleIndex" ]
        Self
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_move_binary_format_file_format_StructHandleIndex_for_move_binary_format_file_format_StructHandleIndex.
  
  Module Impl_core_cmp_PartialOrd_move_binary_format_file_format_StructHandleIndex_for_move_binary_format_file_format_StructHandleIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::StructHandleIndex".
    
    (*         PartialOrd *)
    Definition partial_cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "core::cmp::Ordering" ],
            M.get_trait_method (|
              "core::cmp::PartialOrd",
              Ty.path "u16",
              [],
              [ Ty.path "u16" ],
              "partial_cmp",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| self |) |),
                      "move_binary_format::file_format::StructHandleIndex",
                      0
                    |)
                  |)
                |)
              |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| other |) |),
                      "move_binary_format::file_format::StructHandleIndex",
                      0
                    |)
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialOrd"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.path "move_binary_format::file_format::StructHandleIndex" ]
        Self
        (* Instance *) [ ("partial_cmp", InstanceField.Method partial_cmp) ].
  End Impl_core_cmp_PartialOrd_move_binary_format_file_format_StructHandleIndex_for_move_binary_format_file_format_StructHandleIndex.
  
  Module Impl_move_binary_format_file_format_StructHandleIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::StructHandleIndex".
    
    (*
                pub fn new(idx: TableIndex) -> Self {
                    Self(idx)
                }
    *)
    Definition new (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ idx ] =>
        ltac:(M.monadic
          (let idx := M.alloc (| idx |) in
          Value.StructTuple
            "move_binary_format::file_format::StructHandleIndex"
            []
            []
            [ M.read (| idx |) ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_new : M.IsAssociatedFunction.C Self "new" new.
    Admitted.
    Global Typeclasses Opaque new.
  End Impl_move_binary_format_file_format_StructHandleIndex.
  
  Module Impl_core_fmt_Display_for_move_binary_format_file_format_StructHandleIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::StructHandleIndex".
    
    (*
                fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "{}", self.0)
                }
    *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_fmt", [], [] |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
              M.call_closure (|
                Ty.path "core::fmt::Arguments",
                M.get_associated_function (|
                  Ty.path "core::fmt::Arguments",
                  "new_v1",
                  [ Value.Integer IntegerKind.Usize 1; Value.Integer IntegerKind.Usize 1 ],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (| Pointer.Kind.Ref, M.alloc (| Value.Array [ mk_str (| "" |) ] |) |)
                    |)
                  |);
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          Value.Array
                            [
                              M.call_closure (|
                                Ty.path "core::fmt::rt::Argument",
                                M.get_associated_function (|
                                  Ty.path "core::fmt::rt::Argument",
                                  "new_display",
                                  [],
                                  [ Ty.path "u16" ]
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.SubPointer.get_struct_tuple_field (|
                                          M.deref (| M.read (| self |) |),
                                          "move_binary_format::file_format::StructHandleIndex",
                                          0
                                        |)
                                      |)
                                    |)
                                  |)
                                ]
                              |)
                            ]
                        |)
                      |)
                    |)
                  |)
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Display"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Display_for_move_binary_format_file_format_StructHandleIndex.
  
  Module Impl_core_fmt_Debug_for_move_binary_format_file_format_StructHandleIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::StructHandleIndex".
    
    (*
                fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "{}({})", stringify!($name), self.0)
                }
    *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_fmt", [], [] |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
              M.call_closure (|
                Ty.path "core::fmt::Arguments",
                M.get_associated_function (|
                  Ty.path "core::fmt::Arguments",
                  "new_v1",
                  [ Value.Integer IntegerKind.Usize 2; Value.Integer IntegerKind.Usize 1 ],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          Value.Array [ mk_str (| "StructHandleIndex(" |); mk_str (| ")" |) ]
                        |)
                      |)
                    |)
                  |);
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          Value.Array
                            [
                              M.call_closure (|
                                Ty.path "core::fmt::rt::Argument",
                                M.get_associated_function (|
                                  Ty.path "core::fmt::rt::Argument",
                                  "new_display",
                                  [],
                                  [ Ty.path "u16" ]
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.SubPointer.get_struct_tuple_field (|
                                          M.deref (| M.read (| self |) |),
                                          "move_binary_format::file_format::StructHandleIndex",
                                          0
                                        |)
                                      |)
                                    |)
                                  |)
                                ]
                              |)
                            ]
                        |)
                      |)
                    |)
                  |)
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_move_binary_format_file_format_StructHandleIndex.
  
  Module Impl_move_binary_format_internals_ModuleIndex_for_move_binary_format_file_format_StructHandleIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::StructHandleIndex".
    
    (*             const KIND: IndexKind = IndexKind::$kind; *)
    (* Ty.path "move_binary_format::IndexKind" *)
    Definition value_KIND (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      ltac:(M.monadic
        (M.alloc (| Value.StructTuple "move_binary_format::IndexKind::StructHandle" [] [] [] |))).
    
    (*
                fn into_index(self) -> usize {
                    self.0 as usize
                }
    *)
    Definition into_index (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.cast
            (Ty.path "usize")
            (M.read (|
              M.SubPointer.get_struct_tuple_field (|
                self,
                "move_binary_format::file_format::StructHandleIndex",
                0
              |)
            |))))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "move_binary_format::internals::ModuleIndex"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *)
        [
          ("value_KIND", InstanceField.Method value_KIND);
          ("into_index", InstanceField.Method into_index)
        ].
  End Impl_move_binary_format_internals_ModuleIndex_for_move_binary_format_file_format_StructHandleIndex.
  
  (* StructTuple
    {
      name := "FunctionHandleIndex";
      const_params := [];
      ty_params := [];
      fields := [ Ty.path "u16" ];
    } *)
  
  Module Impl_core_clone_Clone_for_move_binary_format_file_format_FunctionHandleIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::FunctionHandleIndex".
    
    (*         Clone *)
    Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Ty.apply
                (Ty.path "*")
                []
                [ Ty.path "move_binary_format::file_format::FunctionHandleIndex" ],
              Value.DeclaredButUndefined,
              [ fun γ => ltac:(M.monadic (M.deref (| M.read (| self |) |))) ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_move_binary_format_file_format_FunctionHandleIndex.
  
  Module Impl_core_marker_Copy_for_move_binary_format_file_format_FunctionHandleIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::FunctionHandleIndex".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::Copy"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_Copy_for_move_binary_format_file_format_FunctionHandleIndex.
  
  Module Impl_core_default_Default_for_move_binary_format_file_format_FunctionHandleIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::FunctionHandleIndex".
    
    (*         Default *)
    Definition default (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [] =>
        ltac:(M.monadic
          (Value.StructTuple
            "move_binary_format::file_format::FunctionHandleIndex"
            []
            []
            [
              M.call_closure (|
                Ty.path "u16",
                M.get_trait_method (|
                  "core::default::Default",
                  Ty.path "u16",
                  [],
                  [],
                  "default",
                  [],
                  []
                |),
                []
              |)
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::default::Default"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("default", InstanceField.Method default) ].
  End Impl_core_default_Default_for_move_binary_format_file_format_FunctionHandleIndex.
  
  Module Impl_core_cmp_Eq_for_move_binary_format_file_format_FunctionHandleIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::FunctionHandleIndex".
    
    (*         Eq *)
    Definition assert_receiver_is_total_eq
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              Value.DeclaredButUndefined,
              [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_move_binary_format_file_format_FunctionHandleIndex.
  
  Module Impl_core_hash_Hash_for_move_binary_format_file_format_FunctionHandleIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::FunctionHandleIndex".
    
    (*         Hash *)
    Definition hash (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ __H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let state := M.alloc (| state |) in
          M.call_closure (|
            Ty.tuple [],
            M.get_trait_method (| "core::hash::Hash", Ty.path "u16", [], [], "hash", [], [ __H ] |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| self |) |),
                      "move_binary_format::file_format::FunctionHandleIndex",
                      0
                    |)
                  |)
                |)
              |);
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::hash::Hash"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("hash", InstanceField.Method hash) ].
  End Impl_core_hash_Hash_for_move_binary_format_file_format_FunctionHandleIndex.
  
  Module Impl_core_cmp_Ord_for_move_binary_format_file_format_FunctionHandleIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::FunctionHandleIndex".
    
    (*         Ord *)
    Definition cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.path "core::cmp::Ordering",
            M.get_trait_method (| "core::cmp::Ord", Ty.path "u16", [], [], "cmp", [], [] |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| self |) |),
                      "move_binary_format::file_format::FunctionHandleIndex",
                      0
                    |)
                  |)
                |)
              |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| other |) |),
                      "move_binary_format::file_format::FunctionHandleIndex",
                      0
                    |)
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Ord"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("cmp", InstanceField.Method cmp) ].
  End Impl_core_cmp_Ord_for_move_binary_format_file_format_FunctionHandleIndex.
  
  Module Impl_core_marker_StructuralPartialEq_for_move_binary_format_file_format_FunctionHandleIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::FunctionHandleIndex".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_move_binary_format_file_format_FunctionHandleIndex.
  
  Module Impl_core_cmp_PartialEq_move_binary_format_file_format_FunctionHandleIndex_for_move_binary_format_file_format_FunctionHandleIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::FunctionHandleIndex".
    
    (*         PartialEq *)
    Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.path "bool",
            BinOp.eq,
            [
              M.read (|
                M.SubPointer.get_struct_tuple_field (|
                  M.deref (| M.read (| self |) |),
                  "move_binary_format::file_format::FunctionHandleIndex",
                  0
                |)
              |);
              M.read (|
                M.SubPointer.get_struct_tuple_field (|
                  M.deref (| M.read (| other |) |),
                  "move_binary_format::file_format::FunctionHandleIndex",
                  0
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.path "move_binary_format::file_format::FunctionHandleIndex" ]
        Self
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_move_binary_format_file_format_FunctionHandleIndex_for_move_binary_format_file_format_FunctionHandleIndex.
  
  Module Impl_core_cmp_PartialOrd_move_binary_format_file_format_FunctionHandleIndex_for_move_binary_format_file_format_FunctionHandleIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::FunctionHandleIndex".
    
    (*         PartialOrd *)
    Definition partial_cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "core::cmp::Ordering" ],
            M.get_trait_method (|
              "core::cmp::PartialOrd",
              Ty.path "u16",
              [],
              [ Ty.path "u16" ],
              "partial_cmp",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| self |) |),
                      "move_binary_format::file_format::FunctionHandleIndex",
                      0
                    |)
                  |)
                |)
              |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| other |) |),
                      "move_binary_format::file_format::FunctionHandleIndex",
                      0
                    |)
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialOrd"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.path "move_binary_format::file_format::FunctionHandleIndex" ]
        Self
        (* Instance *) [ ("partial_cmp", InstanceField.Method partial_cmp) ].
  End Impl_core_cmp_PartialOrd_move_binary_format_file_format_FunctionHandleIndex_for_move_binary_format_file_format_FunctionHandleIndex.
  
  Module Impl_move_binary_format_file_format_FunctionHandleIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::FunctionHandleIndex".
    
    (*
                pub fn new(idx: TableIndex) -> Self {
                    Self(idx)
                }
    *)
    Definition new (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ idx ] =>
        ltac:(M.monadic
          (let idx := M.alloc (| idx |) in
          Value.StructTuple
            "move_binary_format::file_format::FunctionHandleIndex"
            []
            []
            [ M.read (| idx |) ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_new : M.IsAssociatedFunction.C Self "new" new.
    Admitted.
    Global Typeclasses Opaque new.
  End Impl_move_binary_format_file_format_FunctionHandleIndex.
  
  Module Impl_core_fmt_Display_for_move_binary_format_file_format_FunctionHandleIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::FunctionHandleIndex".
    
    (*
                fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "{}", self.0)
                }
    *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_fmt", [], [] |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
              M.call_closure (|
                Ty.path "core::fmt::Arguments",
                M.get_associated_function (|
                  Ty.path "core::fmt::Arguments",
                  "new_v1",
                  [ Value.Integer IntegerKind.Usize 1; Value.Integer IntegerKind.Usize 1 ],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (| Pointer.Kind.Ref, M.alloc (| Value.Array [ mk_str (| "" |) ] |) |)
                    |)
                  |);
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          Value.Array
                            [
                              M.call_closure (|
                                Ty.path "core::fmt::rt::Argument",
                                M.get_associated_function (|
                                  Ty.path "core::fmt::rt::Argument",
                                  "new_display",
                                  [],
                                  [ Ty.path "u16" ]
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.SubPointer.get_struct_tuple_field (|
                                          M.deref (| M.read (| self |) |),
                                          "move_binary_format::file_format::FunctionHandleIndex",
                                          0
                                        |)
                                      |)
                                    |)
                                  |)
                                ]
                              |)
                            ]
                        |)
                      |)
                    |)
                  |)
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Display"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Display_for_move_binary_format_file_format_FunctionHandleIndex.
  
  Module Impl_core_fmt_Debug_for_move_binary_format_file_format_FunctionHandleIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::FunctionHandleIndex".
    
    (*
                fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "{}({})", stringify!($name), self.0)
                }
    *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_fmt", [], [] |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
              M.call_closure (|
                Ty.path "core::fmt::Arguments",
                M.get_associated_function (|
                  Ty.path "core::fmt::Arguments",
                  "new_v1",
                  [ Value.Integer IntegerKind.Usize 2; Value.Integer IntegerKind.Usize 1 ],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          Value.Array [ mk_str (| "FunctionHandleIndex(" |); mk_str (| ")" |) ]
                        |)
                      |)
                    |)
                  |);
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          Value.Array
                            [
                              M.call_closure (|
                                Ty.path "core::fmt::rt::Argument",
                                M.get_associated_function (|
                                  Ty.path "core::fmt::rt::Argument",
                                  "new_display",
                                  [],
                                  [ Ty.path "u16" ]
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.SubPointer.get_struct_tuple_field (|
                                          M.deref (| M.read (| self |) |),
                                          "move_binary_format::file_format::FunctionHandleIndex",
                                          0
                                        |)
                                      |)
                                    |)
                                  |)
                                ]
                              |)
                            ]
                        |)
                      |)
                    |)
                  |)
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_move_binary_format_file_format_FunctionHandleIndex.
  
  Module Impl_move_binary_format_internals_ModuleIndex_for_move_binary_format_file_format_FunctionHandleIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::FunctionHandleIndex".
    
    (*             const KIND: IndexKind = IndexKind::$kind; *)
    (* Ty.path "move_binary_format::IndexKind" *)
    Definition value_KIND (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      ltac:(M.monadic
        (M.alloc (| Value.StructTuple "move_binary_format::IndexKind::FunctionHandle" [] [] [] |))).
    
    (*
                fn into_index(self) -> usize {
                    self.0 as usize
                }
    *)
    Definition into_index (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.cast
            (Ty.path "usize")
            (M.read (|
              M.SubPointer.get_struct_tuple_field (|
                self,
                "move_binary_format::file_format::FunctionHandleIndex",
                0
              |)
            |))))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "move_binary_format::internals::ModuleIndex"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *)
        [
          ("value_KIND", InstanceField.Method value_KIND);
          ("into_index", InstanceField.Method into_index)
        ].
  End Impl_move_binary_format_internals_ModuleIndex_for_move_binary_format_file_format_FunctionHandleIndex.
  
  (* StructTuple
    {
      name := "FieldHandleIndex";
      const_params := [];
      ty_params := [];
      fields := [ Ty.path "u16" ];
    } *)
  
  Module Impl_core_clone_Clone_for_move_binary_format_file_format_FieldHandleIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::FieldHandleIndex".
    
    (*         Clone *)
    Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Ty.apply
                (Ty.path "*")
                []
                [ Ty.path "move_binary_format::file_format::FieldHandleIndex" ],
              Value.DeclaredButUndefined,
              [ fun γ => ltac:(M.monadic (M.deref (| M.read (| self |) |))) ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_move_binary_format_file_format_FieldHandleIndex.
  
  Module Impl_core_marker_Copy_for_move_binary_format_file_format_FieldHandleIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::FieldHandleIndex".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::Copy"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_Copy_for_move_binary_format_file_format_FieldHandleIndex.
  
  Module Impl_core_default_Default_for_move_binary_format_file_format_FieldHandleIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::FieldHandleIndex".
    
    (*         Default *)
    Definition default (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [] =>
        ltac:(M.monadic
          (Value.StructTuple
            "move_binary_format::file_format::FieldHandleIndex"
            []
            []
            [
              M.call_closure (|
                Ty.path "u16",
                M.get_trait_method (|
                  "core::default::Default",
                  Ty.path "u16",
                  [],
                  [],
                  "default",
                  [],
                  []
                |),
                []
              |)
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::default::Default"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("default", InstanceField.Method default) ].
  End Impl_core_default_Default_for_move_binary_format_file_format_FieldHandleIndex.
  
  Module Impl_core_cmp_Eq_for_move_binary_format_file_format_FieldHandleIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::FieldHandleIndex".
    
    (*         Eq *)
    Definition assert_receiver_is_total_eq
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              Value.DeclaredButUndefined,
              [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_move_binary_format_file_format_FieldHandleIndex.
  
  Module Impl_core_hash_Hash_for_move_binary_format_file_format_FieldHandleIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::FieldHandleIndex".
    
    (*         Hash *)
    Definition hash (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ __H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let state := M.alloc (| state |) in
          M.call_closure (|
            Ty.tuple [],
            M.get_trait_method (| "core::hash::Hash", Ty.path "u16", [], [], "hash", [], [ __H ] |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| self |) |),
                      "move_binary_format::file_format::FieldHandleIndex",
                      0
                    |)
                  |)
                |)
              |);
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::hash::Hash"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("hash", InstanceField.Method hash) ].
  End Impl_core_hash_Hash_for_move_binary_format_file_format_FieldHandleIndex.
  
  Module Impl_core_cmp_Ord_for_move_binary_format_file_format_FieldHandleIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::FieldHandleIndex".
    
    (*         Ord *)
    Definition cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.path "core::cmp::Ordering",
            M.get_trait_method (| "core::cmp::Ord", Ty.path "u16", [], [], "cmp", [], [] |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| self |) |),
                      "move_binary_format::file_format::FieldHandleIndex",
                      0
                    |)
                  |)
                |)
              |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| other |) |),
                      "move_binary_format::file_format::FieldHandleIndex",
                      0
                    |)
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Ord"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("cmp", InstanceField.Method cmp) ].
  End Impl_core_cmp_Ord_for_move_binary_format_file_format_FieldHandleIndex.
  
  Module Impl_core_marker_StructuralPartialEq_for_move_binary_format_file_format_FieldHandleIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::FieldHandleIndex".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_move_binary_format_file_format_FieldHandleIndex.
  
  Module Impl_core_cmp_PartialEq_move_binary_format_file_format_FieldHandleIndex_for_move_binary_format_file_format_FieldHandleIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::FieldHandleIndex".
    
    (*         PartialEq *)
    Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.path "bool",
            BinOp.eq,
            [
              M.read (|
                M.SubPointer.get_struct_tuple_field (|
                  M.deref (| M.read (| self |) |),
                  "move_binary_format::file_format::FieldHandleIndex",
                  0
                |)
              |);
              M.read (|
                M.SubPointer.get_struct_tuple_field (|
                  M.deref (| M.read (| other |) |),
                  "move_binary_format::file_format::FieldHandleIndex",
                  0
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.path "move_binary_format::file_format::FieldHandleIndex" ]
        Self
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_move_binary_format_file_format_FieldHandleIndex_for_move_binary_format_file_format_FieldHandleIndex.
  
  Module Impl_core_cmp_PartialOrd_move_binary_format_file_format_FieldHandleIndex_for_move_binary_format_file_format_FieldHandleIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::FieldHandleIndex".
    
    (*         PartialOrd *)
    Definition partial_cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "core::cmp::Ordering" ],
            M.get_trait_method (|
              "core::cmp::PartialOrd",
              Ty.path "u16",
              [],
              [ Ty.path "u16" ],
              "partial_cmp",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| self |) |),
                      "move_binary_format::file_format::FieldHandleIndex",
                      0
                    |)
                  |)
                |)
              |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| other |) |),
                      "move_binary_format::file_format::FieldHandleIndex",
                      0
                    |)
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialOrd"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.path "move_binary_format::file_format::FieldHandleIndex" ]
        Self
        (* Instance *) [ ("partial_cmp", InstanceField.Method partial_cmp) ].
  End Impl_core_cmp_PartialOrd_move_binary_format_file_format_FieldHandleIndex_for_move_binary_format_file_format_FieldHandleIndex.
  
  Module Impl_move_binary_format_file_format_FieldHandleIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::FieldHandleIndex".
    
    (*
                pub fn new(idx: TableIndex) -> Self {
                    Self(idx)
                }
    *)
    Definition new (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ idx ] =>
        ltac:(M.monadic
          (let idx := M.alloc (| idx |) in
          Value.StructTuple
            "move_binary_format::file_format::FieldHandleIndex"
            []
            []
            [ M.read (| idx |) ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_new : M.IsAssociatedFunction.C Self "new" new.
    Admitted.
    Global Typeclasses Opaque new.
  End Impl_move_binary_format_file_format_FieldHandleIndex.
  
  Module Impl_core_fmt_Display_for_move_binary_format_file_format_FieldHandleIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::FieldHandleIndex".
    
    (*
                fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "{}", self.0)
                }
    *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_fmt", [], [] |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
              M.call_closure (|
                Ty.path "core::fmt::Arguments",
                M.get_associated_function (|
                  Ty.path "core::fmt::Arguments",
                  "new_v1",
                  [ Value.Integer IntegerKind.Usize 1; Value.Integer IntegerKind.Usize 1 ],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (| Pointer.Kind.Ref, M.alloc (| Value.Array [ mk_str (| "" |) ] |) |)
                    |)
                  |);
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          Value.Array
                            [
                              M.call_closure (|
                                Ty.path "core::fmt::rt::Argument",
                                M.get_associated_function (|
                                  Ty.path "core::fmt::rt::Argument",
                                  "new_display",
                                  [],
                                  [ Ty.path "u16" ]
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.SubPointer.get_struct_tuple_field (|
                                          M.deref (| M.read (| self |) |),
                                          "move_binary_format::file_format::FieldHandleIndex",
                                          0
                                        |)
                                      |)
                                    |)
                                  |)
                                ]
                              |)
                            ]
                        |)
                      |)
                    |)
                  |)
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Display"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Display_for_move_binary_format_file_format_FieldHandleIndex.
  
  Module Impl_core_fmt_Debug_for_move_binary_format_file_format_FieldHandleIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::FieldHandleIndex".
    
    (*
                fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "{}({})", stringify!($name), self.0)
                }
    *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_fmt", [], [] |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
              M.call_closure (|
                Ty.path "core::fmt::Arguments",
                M.get_associated_function (|
                  Ty.path "core::fmt::Arguments",
                  "new_v1",
                  [ Value.Integer IntegerKind.Usize 2; Value.Integer IntegerKind.Usize 1 ],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          Value.Array [ mk_str (| "FieldHandleIndex(" |); mk_str (| ")" |) ]
                        |)
                      |)
                    |)
                  |);
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          Value.Array
                            [
                              M.call_closure (|
                                Ty.path "core::fmt::rt::Argument",
                                M.get_associated_function (|
                                  Ty.path "core::fmt::rt::Argument",
                                  "new_display",
                                  [],
                                  [ Ty.path "u16" ]
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.SubPointer.get_struct_tuple_field (|
                                          M.deref (| M.read (| self |) |),
                                          "move_binary_format::file_format::FieldHandleIndex",
                                          0
                                        |)
                                      |)
                                    |)
                                  |)
                                ]
                              |)
                            ]
                        |)
                      |)
                    |)
                  |)
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_move_binary_format_file_format_FieldHandleIndex.
  
  Module Impl_move_binary_format_internals_ModuleIndex_for_move_binary_format_file_format_FieldHandleIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::FieldHandleIndex".
    
    (*             const KIND: IndexKind = IndexKind::$kind; *)
    (* Ty.path "move_binary_format::IndexKind" *)
    Definition value_KIND (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      ltac:(M.monadic
        (M.alloc (| Value.StructTuple "move_binary_format::IndexKind::FieldHandle" [] [] [] |))).
    
    (*
                fn into_index(self) -> usize {
                    self.0 as usize
                }
    *)
    Definition into_index (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.cast
            (Ty.path "usize")
            (M.read (|
              M.SubPointer.get_struct_tuple_field (|
                self,
                "move_binary_format::file_format::FieldHandleIndex",
                0
              |)
            |))))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "move_binary_format::internals::ModuleIndex"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *)
        [
          ("value_KIND", InstanceField.Method value_KIND);
          ("into_index", InstanceField.Method into_index)
        ].
  End Impl_move_binary_format_internals_ModuleIndex_for_move_binary_format_file_format_FieldHandleIndex.
  
  (* StructTuple
    {
      name := "StructDefInstantiationIndex";
      const_params := [];
      ty_params := [];
      fields := [ Ty.path "u16" ];
    } *)
  
  Module Impl_core_clone_Clone_for_move_binary_format_file_format_StructDefInstantiationIndex.
    Definition Self : Ty.t :=
      Ty.path "move_binary_format::file_format::StructDefInstantiationIndex".
    
    (*         Clone *)
    Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Ty.apply
                (Ty.path "*")
                []
                [ Ty.path "move_binary_format::file_format::StructDefInstantiationIndex" ],
              Value.DeclaredButUndefined,
              [ fun γ => ltac:(M.monadic (M.deref (| M.read (| self |) |))) ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_move_binary_format_file_format_StructDefInstantiationIndex.
  
  Module Impl_core_marker_Copy_for_move_binary_format_file_format_StructDefInstantiationIndex.
    Definition Self : Ty.t :=
      Ty.path "move_binary_format::file_format::StructDefInstantiationIndex".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::Copy"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_Copy_for_move_binary_format_file_format_StructDefInstantiationIndex.
  
  Module Impl_core_default_Default_for_move_binary_format_file_format_StructDefInstantiationIndex.
    Definition Self : Ty.t :=
      Ty.path "move_binary_format::file_format::StructDefInstantiationIndex".
    
    (*         Default *)
    Definition default (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [] =>
        ltac:(M.monadic
          (Value.StructTuple
            "move_binary_format::file_format::StructDefInstantiationIndex"
            []
            []
            [
              M.call_closure (|
                Ty.path "u16",
                M.get_trait_method (|
                  "core::default::Default",
                  Ty.path "u16",
                  [],
                  [],
                  "default",
                  [],
                  []
                |),
                []
              |)
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::default::Default"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("default", InstanceField.Method default) ].
  End Impl_core_default_Default_for_move_binary_format_file_format_StructDefInstantiationIndex.
  
  Module Impl_core_cmp_Eq_for_move_binary_format_file_format_StructDefInstantiationIndex.
    Definition Self : Ty.t :=
      Ty.path "move_binary_format::file_format::StructDefInstantiationIndex".
    
    (*         Eq *)
    Definition assert_receiver_is_total_eq
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              Value.DeclaredButUndefined,
              [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_move_binary_format_file_format_StructDefInstantiationIndex.
  
  Module Impl_core_hash_Hash_for_move_binary_format_file_format_StructDefInstantiationIndex.
    Definition Self : Ty.t :=
      Ty.path "move_binary_format::file_format::StructDefInstantiationIndex".
    
    (*         Hash *)
    Definition hash (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ __H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let state := M.alloc (| state |) in
          M.call_closure (|
            Ty.tuple [],
            M.get_trait_method (| "core::hash::Hash", Ty.path "u16", [], [], "hash", [], [ __H ] |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| self |) |),
                      "move_binary_format::file_format::StructDefInstantiationIndex",
                      0
                    |)
                  |)
                |)
              |);
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::hash::Hash"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("hash", InstanceField.Method hash) ].
  End Impl_core_hash_Hash_for_move_binary_format_file_format_StructDefInstantiationIndex.
  
  Module Impl_core_cmp_Ord_for_move_binary_format_file_format_StructDefInstantiationIndex.
    Definition Self : Ty.t :=
      Ty.path "move_binary_format::file_format::StructDefInstantiationIndex".
    
    (*         Ord *)
    Definition cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.path "core::cmp::Ordering",
            M.get_trait_method (| "core::cmp::Ord", Ty.path "u16", [], [], "cmp", [], [] |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| self |) |),
                      "move_binary_format::file_format::StructDefInstantiationIndex",
                      0
                    |)
                  |)
                |)
              |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| other |) |),
                      "move_binary_format::file_format::StructDefInstantiationIndex",
                      0
                    |)
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Ord"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("cmp", InstanceField.Method cmp) ].
  End Impl_core_cmp_Ord_for_move_binary_format_file_format_StructDefInstantiationIndex.
  
  Module Impl_core_marker_StructuralPartialEq_for_move_binary_format_file_format_StructDefInstantiationIndex.
    Definition Self : Ty.t :=
      Ty.path "move_binary_format::file_format::StructDefInstantiationIndex".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_move_binary_format_file_format_StructDefInstantiationIndex.
  
  Module Impl_core_cmp_PartialEq_move_binary_format_file_format_StructDefInstantiationIndex_for_move_binary_format_file_format_StructDefInstantiationIndex.
    Definition Self : Ty.t :=
      Ty.path "move_binary_format::file_format::StructDefInstantiationIndex".
    
    (*         PartialEq *)
    Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.path "bool",
            BinOp.eq,
            [
              M.read (|
                M.SubPointer.get_struct_tuple_field (|
                  M.deref (| M.read (| self |) |),
                  "move_binary_format::file_format::StructDefInstantiationIndex",
                  0
                |)
              |);
              M.read (|
                M.SubPointer.get_struct_tuple_field (|
                  M.deref (| M.read (| other |) |),
                  "move_binary_format::file_format::StructDefInstantiationIndex",
                  0
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.path "move_binary_format::file_format::StructDefInstantiationIndex" ]
        Self
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_move_binary_format_file_format_StructDefInstantiationIndex_for_move_binary_format_file_format_StructDefInstantiationIndex.
  
  Module Impl_core_cmp_PartialOrd_move_binary_format_file_format_StructDefInstantiationIndex_for_move_binary_format_file_format_StructDefInstantiationIndex.
    Definition Self : Ty.t :=
      Ty.path "move_binary_format::file_format::StructDefInstantiationIndex".
    
    (*         PartialOrd *)
    Definition partial_cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "core::cmp::Ordering" ],
            M.get_trait_method (|
              "core::cmp::PartialOrd",
              Ty.path "u16",
              [],
              [ Ty.path "u16" ],
              "partial_cmp",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| self |) |),
                      "move_binary_format::file_format::StructDefInstantiationIndex",
                      0
                    |)
                  |)
                |)
              |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| other |) |),
                      "move_binary_format::file_format::StructDefInstantiationIndex",
                      0
                    |)
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialOrd"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.path "move_binary_format::file_format::StructDefInstantiationIndex" ]
        Self
        (* Instance *) [ ("partial_cmp", InstanceField.Method partial_cmp) ].
  End Impl_core_cmp_PartialOrd_move_binary_format_file_format_StructDefInstantiationIndex_for_move_binary_format_file_format_StructDefInstantiationIndex.
  
  Module Impl_move_binary_format_file_format_StructDefInstantiationIndex.
    Definition Self : Ty.t :=
      Ty.path "move_binary_format::file_format::StructDefInstantiationIndex".
    
    (*
                pub fn new(idx: TableIndex) -> Self {
                    Self(idx)
                }
    *)
    Definition new (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ idx ] =>
        ltac:(M.monadic
          (let idx := M.alloc (| idx |) in
          Value.StructTuple
            "move_binary_format::file_format::StructDefInstantiationIndex"
            []
            []
            [ M.read (| idx |) ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_new : M.IsAssociatedFunction.C Self "new" new.
    Admitted.
    Global Typeclasses Opaque new.
  End Impl_move_binary_format_file_format_StructDefInstantiationIndex.
  
  Module Impl_core_fmt_Display_for_move_binary_format_file_format_StructDefInstantiationIndex.
    Definition Self : Ty.t :=
      Ty.path "move_binary_format::file_format::StructDefInstantiationIndex".
    
    (*
                fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "{}", self.0)
                }
    *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_fmt", [], [] |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
              M.call_closure (|
                Ty.path "core::fmt::Arguments",
                M.get_associated_function (|
                  Ty.path "core::fmt::Arguments",
                  "new_v1",
                  [ Value.Integer IntegerKind.Usize 1; Value.Integer IntegerKind.Usize 1 ],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (| Pointer.Kind.Ref, M.alloc (| Value.Array [ mk_str (| "" |) ] |) |)
                    |)
                  |);
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          Value.Array
                            [
                              M.call_closure (|
                                Ty.path "core::fmt::rt::Argument",
                                M.get_associated_function (|
                                  Ty.path "core::fmt::rt::Argument",
                                  "new_display",
                                  [],
                                  [ Ty.path "u16" ]
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.SubPointer.get_struct_tuple_field (|
                                          M.deref (| M.read (| self |) |),
                                          "move_binary_format::file_format::StructDefInstantiationIndex",
                                          0
                                        |)
                                      |)
                                    |)
                                  |)
                                ]
                              |)
                            ]
                        |)
                      |)
                    |)
                  |)
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Display"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Display_for_move_binary_format_file_format_StructDefInstantiationIndex.
  
  Module Impl_core_fmt_Debug_for_move_binary_format_file_format_StructDefInstantiationIndex.
    Definition Self : Ty.t :=
      Ty.path "move_binary_format::file_format::StructDefInstantiationIndex".
    
    (*
                fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "{}({})", stringify!($name), self.0)
                }
    *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_fmt", [], [] |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
              M.call_closure (|
                Ty.path "core::fmt::Arguments",
                M.get_associated_function (|
                  Ty.path "core::fmt::Arguments",
                  "new_v1",
                  [ Value.Integer IntegerKind.Usize 2; Value.Integer IntegerKind.Usize 1 ],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          Value.Array
                            [ mk_str (| "StructDefInstantiationIndex(" |); mk_str (| ")" |) ]
                        |)
                      |)
                    |)
                  |);
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          Value.Array
                            [
                              M.call_closure (|
                                Ty.path "core::fmt::rt::Argument",
                                M.get_associated_function (|
                                  Ty.path "core::fmt::rt::Argument",
                                  "new_display",
                                  [],
                                  [ Ty.path "u16" ]
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.SubPointer.get_struct_tuple_field (|
                                          M.deref (| M.read (| self |) |),
                                          "move_binary_format::file_format::StructDefInstantiationIndex",
                                          0
                                        |)
                                      |)
                                    |)
                                  |)
                                ]
                              |)
                            ]
                        |)
                      |)
                    |)
                  |)
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_move_binary_format_file_format_StructDefInstantiationIndex.
  
  Module Impl_move_binary_format_internals_ModuleIndex_for_move_binary_format_file_format_StructDefInstantiationIndex.
    Definition Self : Ty.t :=
      Ty.path "move_binary_format::file_format::StructDefInstantiationIndex".
    
    (*             const KIND: IndexKind = IndexKind::$kind; *)
    (* Ty.path "move_binary_format::IndexKind" *)
    Definition value_KIND (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      ltac:(M.monadic
        (M.alloc (|
          Value.StructTuple "move_binary_format::IndexKind::StructDefInstantiation" [] [] []
        |))).
    
    (*
                fn into_index(self) -> usize {
                    self.0 as usize
                }
    *)
    Definition into_index (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.cast
            (Ty.path "usize")
            (M.read (|
              M.SubPointer.get_struct_tuple_field (|
                self,
                "move_binary_format::file_format::StructDefInstantiationIndex",
                0
              |)
            |))))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "move_binary_format::internals::ModuleIndex"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *)
        [
          ("value_KIND", InstanceField.Method value_KIND);
          ("into_index", InstanceField.Method into_index)
        ].
  End Impl_move_binary_format_internals_ModuleIndex_for_move_binary_format_file_format_StructDefInstantiationIndex.
  
  (* StructTuple
    {
      name := "FunctionInstantiationIndex";
      const_params := [];
      ty_params := [];
      fields := [ Ty.path "u16" ];
    } *)
  
  Module Impl_core_clone_Clone_for_move_binary_format_file_format_FunctionInstantiationIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::FunctionInstantiationIndex".
    
    (*         Clone *)
    Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Ty.apply
                (Ty.path "*")
                []
                [ Ty.path "move_binary_format::file_format::FunctionInstantiationIndex" ],
              Value.DeclaredButUndefined,
              [ fun γ => ltac:(M.monadic (M.deref (| M.read (| self |) |))) ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_move_binary_format_file_format_FunctionInstantiationIndex.
  
  Module Impl_core_marker_Copy_for_move_binary_format_file_format_FunctionInstantiationIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::FunctionInstantiationIndex".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::Copy"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_Copy_for_move_binary_format_file_format_FunctionInstantiationIndex.
  
  Module Impl_core_default_Default_for_move_binary_format_file_format_FunctionInstantiationIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::FunctionInstantiationIndex".
    
    (*         Default *)
    Definition default (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [] =>
        ltac:(M.monadic
          (Value.StructTuple
            "move_binary_format::file_format::FunctionInstantiationIndex"
            []
            []
            [
              M.call_closure (|
                Ty.path "u16",
                M.get_trait_method (|
                  "core::default::Default",
                  Ty.path "u16",
                  [],
                  [],
                  "default",
                  [],
                  []
                |),
                []
              |)
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::default::Default"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("default", InstanceField.Method default) ].
  End Impl_core_default_Default_for_move_binary_format_file_format_FunctionInstantiationIndex.
  
  Module Impl_core_cmp_Eq_for_move_binary_format_file_format_FunctionInstantiationIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::FunctionInstantiationIndex".
    
    (*         Eq *)
    Definition assert_receiver_is_total_eq
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              Value.DeclaredButUndefined,
              [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_move_binary_format_file_format_FunctionInstantiationIndex.
  
  Module Impl_core_hash_Hash_for_move_binary_format_file_format_FunctionInstantiationIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::FunctionInstantiationIndex".
    
    (*         Hash *)
    Definition hash (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ __H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let state := M.alloc (| state |) in
          M.call_closure (|
            Ty.tuple [],
            M.get_trait_method (| "core::hash::Hash", Ty.path "u16", [], [], "hash", [], [ __H ] |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| self |) |),
                      "move_binary_format::file_format::FunctionInstantiationIndex",
                      0
                    |)
                  |)
                |)
              |);
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::hash::Hash"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("hash", InstanceField.Method hash) ].
  End Impl_core_hash_Hash_for_move_binary_format_file_format_FunctionInstantiationIndex.
  
  Module Impl_core_cmp_Ord_for_move_binary_format_file_format_FunctionInstantiationIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::FunctionInstantiationIndex".
    
    (*         Ord *)
    Definition cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.path "core::cmp::Ordering",
            M.get_trait_method (| "core::cmp::Ord", Ty.path "u16", [], [], "cmp", [], [] |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| self |) |),
                      "move_binary_format::file_format::FunctionInstantiationIndex",
                      0
                    |)
                  |)
                |)
              |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| other |) |),
                      "move_binary_format::file_format::FunctionInstantiationIndex",
                      0
                    |)
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Ord"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("cmp", InstanceField.Method cmp) ].
  End Impl_core_cmp_Ord_for_move_binary_format_file_format_FunctionInstantiationIndex.
  
  Module Impl_core_marker_StructuralPartialEq_for_move_binary_format_file_format_FunctionInstantiationIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::FunctionInstantiationIndex".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_move_binary_format_file_format_FunctionInstantiationIndex.
  
  Module Impl_core_cmp_PartialEq_move_binary_format_file_format_FunctionInstantiationIndex_for_move_binary_format_file_format_FunctionInstantiationIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::FunctionInstantiationIndex".
    
    (*         PartialEq *)
    Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.path "bool",
            BinOp.eq,
            [
              M.read (|
                M.SubPointer.get_struct_tuple_field (|
                  M.deref (| M.read (| self |) |),
                  "move_binary_format::file_format::FunctionInstantiationIndex",
                  0
                |)
              |);
              M.read (|
                M.SubPointer.get_struct_tuple_field (|
                  M.deref (| M.read (| other |) |),
                  "move_binary_format::file_format::FunctionInstantiationIndex",
                  0
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.path "move_binary_format::file_format::FunctionInstantiationIndex" ]
        Self
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_move_binary_format_file_format_FunctionInstantiationIndex_for_move_binary_format_file_format_FunctionInstantiationIndex.
  
  Module Impl_core_cmp_PartialOrd_move_binary_format_file_format_FunctionInstantiationIndex_for_move_binary_format_file_format_FunctionInstantiationIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::FunctionInstantiationIndex".
    
    (*         PartialOrd *)
    Definition partial_cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "core::cmp::Ordering" ],
            M.get_trait_method (|
              "core::cmp::PartialOrd",
              Ty.path "u16",
              [],
              [ Ty.path "u16" ],
              "partial_cmp",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| self |) |),
                      "move_binary_format::file_format::FunctionInstantiationIndex",
                      0
                    |)
                  |)
                |)
              |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| other |) |),
                      "move_binary_format::file_format::FunctionInstantiationIndex",
                      0
                    |)
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialOrd"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.path "move_binary_format::file_format::FunctionInstantiationIndex" ]
        Self
        (* Instance *) [ ("partial_cmp", InstanceField.Method partial_cmp) ].
  End Impl_core_cmp_PartialOrd_move_binary_format_file_format_FunctionInstantiationIndex_for_move_binary_format_file_format_FunctionInstantiationIndex.
  
  Module Impl_move_binary_format_file_format_FunctionInstantiationIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::FunctionInstantiationIndex".
    
    (*
                pub fn new(idx: TableIndex) -> Self {
                    Self(idx)
                }
    *)
    Definition new (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ idx ] =>
        ltac:(M.monadic
          (let idx := M.alloc (| idx |) in
          Value.StructTuple
            "move_binary_format::file_format::FunctionInstantiationIndex"
            []
            []
            [ M.read (| idx |) ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_new : M.IsAssociatedFunction.C Self "new" new.
    Admitted.
    Global Typeclasses Opaque new.
  End Impl_move_binary_format_file_format_FunctionInstantiationIndex.
  
  Module Impl_core_fmt_Display_for_move_binary_format_file_format_FunctionInstantiationIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::FunctionInstantiationIndex".
    
    (*
                fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "{}", self.0)
                }
    *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_fmt", [], [] |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
              M.call_closure (|
                Ty.path "core::fmt::Arguments",
                M.get_associated_function (|
                  Ty.path "core::fmt::Arguments",
                  "new_v1",
                  [ Value.Integer IntegerKind.Usize 1; Value.Integer IntegerKind.Usize 1 ],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (| Pointer.Kind.Ref, M.alloc (| Value.Array [ mk_str (| "" |) ] |) |)
                    |)
                  |);
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          Value.Array
                            [
                              M.call_closure (|
                                Ty.path "core::fmt::rt::Argument",
                                M.get_associated_function (|
                                  Ty.path "core::fmt::rt::Argument",
                                  "new_display",
                                  [],
                                  [ Ty.path "u16" ]
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.SubPointer.get_struct_tuple_field (|
                                          M.deref (| M.read (| self |) |),
                                          "move_binary_format::file_format::FunctionInstantiationIndex",
                                          0
                                        |)
                                      |)
                                    |)
                                  |)
                                ]
                              |)
                            ]
                        |)
                      |)
                    |)
                  |)
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Display"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Display_for_move_binary_format_file_format_FunctionInstantiationIndex.
  
  Module Impl_core_fmt_Debug_for_move_binary_format_file_format_FunctionInstantiationIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::FunctionInstantiationIndex".
    
    (*
                fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "{}({})", stringify!($name), self.0)
                }
    *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_fmt", [], [] |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
              M.call_closure (|
                Ty.path "core::fmt::Arguments",
                M.get_associated_function (|
                  Ty.path "core::fmt::Arguments",
                  "new_v1",
                  [ Value.Integer IntegerKind.Usize 2; Value.Integer IntegerKind.Usize 1 ],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          Value.Array
                            [ mk_str (| "FunctionInstantiationIndex(" |); mk_str (| ")" |) ]
                        |)
                      |)
                    |)
                  |);
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          Value.Array
                            [
                              M.call_closure (|
                                Ty.path "core::fmt::rt::Argument",
                                M.get_associated_function (|
                                  Ty.path "core::fmt::rt::Argument",
                                  "new_display",
                                  [],
                                  [ Ty.path "u16" ]
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.SubPointer.get_struct_tuple_field (|
                                          M.deref (| M.read (| self |) |),
                                          "move_binary_format::file_format::FunctionInstantiationIndex",
                                          0
                                        |)
                                      |)
                                    |)
                                  |)
                                ]
                              |)
                            ]
                        |)
                      |)
                    |)
                  |)
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_move_binary_format_file_format_FunctionInstantiationIndex.
  
  Module Impl_move_binary_format_internals_ModuleIndex_for_move_binary_format_file_format_FunctionInstantiationIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::FunctionInstantiationIndex".
    
    (*             const KIND: IndexKind = IndexKind::$kind; *)
    (* Ty.path "move_binary_format::IndexKind" *)
    Definition value_KIND (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      ltac:(M.monadic
        (M.alloc (|
          Value.StructTuple "move_binary_format::IndexKind::FunctionInstantiation" [] [] []
        |))).
    
    (*
                fn into_index(self) -> usize {
                    self.0 as usize
                }
    *)
    Definition into_index (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.cast
            (Ty.path "usize")
            (M.read (|
              M.SubPointer.get_struct_tuple_field (|
                self,
                "move_binary_format::file_format::FunctionInstantiationIndex",
                0
              |)
            |))))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "move_binary_format::internals::ModuleIndex"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *)
        [
          ("value_KIND", InstanceField.Method value_KIND);
          ("into_index", InstanceField.Method into_index)
        ].
  End Impl_move_binary_format_internals_ModuleIndex_for_move_binary_format_file_format_FunctionInstantiationIndex.
  
  (* StructTuple
    {
      name := "FieldInstantiationIndex";
      const_params := [];
      ty_params := [];
      fields := [ Ty.path "u16" ];
    } *)
  
  Module Impl_core_clone_Clone_for_move_binary_format_file_format_FieldInstantiationIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::FieldInstantiationIndex".
    
    (*         Clone *)
    Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Ty.apply
                (Ty.path "*")
                []
                [ Ty.path "move_binary_format::file_format::FieldInstantiationIndex" ],
              Value.DeclaredButUndefined,
              [ fun γ => ltac:(M.monadic (M.deref (| M.read (| self |) |))) ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_move_binary_format_file_format_FieldInstantiationIndex.
  
  Module Impl_core_marker_Copy_for_move_binary_format_file_format_FieldInstantiationIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::FieldInstantiationIndex".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::Copy"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_Copy_for_move_binary_format_file_format_FieldInstantiationIndex.
  
  Module Impl_core_default_Default_for_move_binary_format_file_format_FieldInstantiationIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::FieldInstantiationIndex".
    
    (*         Default *)
    Definition default (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [] =>
        ltac:(M.monadic
          (Value.StructTuple
            "move_binary_format::file_format::FieldInstantiationIndex"
            []
            []
            [
              M.call_closure (|
                Ty.path "u16",
                M.get_trait_method (|
                  "core::default::Default",
                  Ty.path "u16",
                  [],
                  [],
                  "default",
                  [],
                  []
                |),
                []
              |)
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::default::Default"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("default", InstanceField.Method default) ].
  End Impl_core_default_Default_for_move_binary_format_file_format_FieldInstantiationIndex.
  
  Module Impl_core_cmp_Eq_for_move_binary_format_file_format_FieldInstantiationIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::FieldInstantiationIndex".
    
    (*         Eq *)
    Definition assert_receiver_is_total_eq
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              Value.DeclaredButUndefined,
              [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_move_binary_format_file_format_FieldInstantiationIndex.
  
  Module Impl_core_hash_Hash_for_move_binary_format_file_format_FieldInstantiationIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::FieldInstantiationIndex".
    
    (*         Hash *)
    Definition hash (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ __H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let state := M.alloc (| state |) in
          M.call_closure (|
            Ty.tuple [],
            M.get_trait_method (| "core::hash::Hash", Ty.path "u16", [], [], "hash", [], [ __H ] |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| self |) |),
                      "move_binary_format::file_format::FieldInstantiationIndex",
                      0
                    |)
                  |)
                |)
              |);
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::hash::Hash"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("hash", InstanceField.Method hash) ].
  End Impl_core_hash_Hash_for_move_binary_format_file_format_FieldInstantiationIndex.
  
  Module Impl_core_cmp_Ord_for_move_binary_format_file_format_FieldInstantiationIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::FieldInstantiationIndex".
    
    (*         Ord *)
    Definition cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.path "core::cmp::Ordering",
            M.get_trait_method (| "core::cmp::Ord", Ty.path "u16", [], [], "cmp", [], [] |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| self |) |),
                      "move_binary_format::file_format::FieldInstantiationIndex",
                      0
                    |)
                  |)
                |)
              |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| other |) |),
                      "move_binary_format::file_format::FieldInstantiationIndex",
                      0
                    |)
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Ord"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("cmp", InstanceField.Method cmp) ].
  End Impl_core_cmp_Ord_for_move_binary_format_file_format_FieldInstantiationIndex.
  
  Module Impl_core_marker_StructuralPartialEq_for_move_binary_format_file_format_FieldInstantiationIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::FieldInstantiationIndex".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_move_binary_format_file_format_FieldInstantiationIndex.
  
  Module Impl_core_cmp_PartialEq_move_binary_format_file_format_FieldInstantiationIndex_for_move_binary_format_file_format_FieldInstantiationIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::FieldInstantiationIndex".
    
    (*         PartialEq *)
    Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.path "bool",
            BinOp.eq,
            [
              M.read (|
                M.SubPointer.get_struct_tuple_field (|
                  M.deref (| M.read (| self |) |),
                  "move_binary_format::file_format::FieldInstantiationIndex",
                  0
                |)
              |);
              M.read (|
                M.SubPointer.get_struct_tuple_field (|
                  M.deref (| M.read (| other |) |),
                  "move_binary_format::file_format::FieldInstantiationIndex",
                  0
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.path "move_binary_format::file_format::FieldInstantiationIndex" ]
        Self
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_move_binary_format_file_format_FieldInstantiationIndex_for_move_binary_format_file_format_FieldInstantiationIndex.
  
  Module Impl_core_cmp_PartialOrd_move_binary_format_file_format_FieldInstantiationIndex_for_move_binary_format_file_format_FieldInstantiationIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::FieldInstantiationIndex".
    
    (*         PartialOrd *)
    Definition partial_cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "core::cmp::Ordering" ],
            M.get_trait_method (|
              "core::cmp::PartialOrd",
              Ty.path "u16",
              [],
              [ Ty.path "u16" ],
              "partial_cmp",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| self |) |),
                      "move_binary_format::file_format::FieldInstantiationIndex",
                      0
                    |)
                  |)
                |)
              |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| other |) |),
                      "move_binary_format::file_format::FieldInstantiationIndex",
                      0
                    |)
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialOrd"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.path "move_binary_format::file_format::FieldInstantiationIndex" ]
        Self
        (* Instance *) [ ("partial_cmp", InstanceField.Method partial_cmp) ].
  End Impl_core_cmp_PartialOrd_move_binary_format_file_format_FieldInstantiationIndex_for_move_binary_format_file_format_FieldInstantiationIndex.
  
  Module Impl_move_binary_format_file_format_FieldInstantiationIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::FieldInstantiationIndex".
    
    (*
                pub fn new(idx: TableIndex) -> Self {
                    Self(idx)
                }
    *)
    Definition new (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ idx ] =>
        ltac:(M.monadic
          (let idx := M.alloc (| idx |) in
          Value.StructTuple
            "move_binary_format::file_format::FieldInstantiationIndex"
            []
            []
            [ M.read (| idx |) ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_new : M.IsAssociatedFunction.C Self "new" new.
    Admitted.
    Global Typeclasses Opaque new.
  End Impl_move_binary_format_file_format_FieldInstantiationIndex.
  
  Module Impl_core_fmt_Display_for_move_binary_format_file_format_FieldInstantiationIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::FieldInstantiationIndex".
    
    (*
                fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "{}", self.0)
                }
    *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_fmt", [], [] |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
              M.call_closure (|
                Ty.path "core::fmt::Arguments",
                M.get_associated_function (|
                  Ty.path "core::fmt::Arguments",
                  "new_v1",
                  [ Value.Integer IntegerKind.Usize 1; Value.Integer IntegerKind.Usize 1 ],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (| Pointer.Kind.Ref, M.alloc (| Value.Array [ mk_str (| "" |) ] |) |)
                    |)
                  |);
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          Value.Array
                            [
                              M.call_closure (|
                                Ty.path "core::fmt::rt::Argument",
                                M.get_associated_function (|
                                  Ty.path "core::fmt::rt::Argument",
                                  "new_display",
                                  [],
                                  [ Ty.path "u16" ]
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.SubPointer.get_struct_tuple_field (|
                                          M.deref (| M.read (| self |) |),
                                          "move_binary_format::file_format::FieldInstantiationIndex",
                                          0
                                        |)
                                      |)
                                    |)
                                  |)
                                ]
                              |)
                            ]
                        |)
                      |)
                    |)
                  |)
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Display"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Display_for_move_binary_format_file_format_FieldInstantiationIndex.
  
  Module Impl_core_fmt_Debug_for_move_binary_format_file_format_FieldInstantiationIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::FieldInstantiationIndex".
    
    (*
                fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "{}({})", stringify!($name), self.0)
                }
    *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_fmt", [], [] |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
              M.call_closure (|
                Ty.path "core::fmt::Arguments",
                M.get_associated_function (|
                  Ty.path "core::fmt::Arguments",
                  "new_v1",
                  [ Value.Integer IntegerKind.Usize 2; Value.Integer IntegerKind.Usize 1 ],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          Value.Array [ mk_str (| "FieldInstantiationIndex(" |); mk_str (| ")" |) ]
                        |)
                      |)
                    |)
                  |);
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          Value.Array
                            [
                              M.call_closure (|
                                Ty.path "core::fmt::rt::Argument",
                                M.get_associated_function (|
                                  Ty.path "core::fmt::rt::Argument",
                                  "new_display",
                                  [],
                                  [ Ty.path "u16" ]
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.SubPointer.get_struct_tuple_field (|
                                          M.deref (| M.read (| self |) |),
                                          "move_binary_format::file_format::FieldInstantiationIndex",
                                          0
                                        |)
                                      |)
                                    |)
                                  |)
                                ]
                              |)
                            ]
                        |)
                      |)
                    |)
                  |)
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_move_binary_format_file_format_FieldInstantiationIndex.
  
  Module Impl_move_binary_format_internals_ModuleIndex_for_move_binary_format_file_format_FieldInstantiationIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::FieldInstantiationIndex".
    
    (*             const KIND: IndexKind = IndexKind::$kind; *)
    (* Ty.path "move_binary_format::IndexKind" *)
    Definition value_KIND (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      ltac:(M.monadic
        (M.alloc (|
          Value.StructTuple "move_binary_format::IndexKind::FieldInstantiation" [] [] []
        |))).
    
    (*
                fn into_index(self) -> usize {
                    self.0 as usize
                }
    *)
    Definition into_index (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.cast
            (Ty.path "usize")
            (M.read (|
              M.SubPointer.get_struct_tuple_field (|
                self,
                "move_binary_format::file_format::FieldInstantiationIndex",
                0
              |)
            |))))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "move_binary_format::internals::ModuleIndex"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *)
        [
          ("value_KIND", InstanceField.Method value_KIND);
          ("into_index", InstanceField.Method into_index)
        ].
  End Impl_move_binary_format_internals_ModuleIndex_for_move_binary_format_file_format_FieldInstantiationIndex.
  
  (* StructTuple
    {
      name := "IdentifierIndex";
      const_params := [];
      ty_params := [];
      fields := [ Ty.path "u16" ];
    } *)
  
  Module Impl_core_clone_Clone_for_move_binary_format_file_format_IdentifierIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::IdentifierIndex".
    
    (*         Clone *)
    Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Ty.apply
                (Ty.path "*")
                []
                [ Ty.path "move_binary_format::file_format::IdentifierIndex" ],
              Value.DeclaredButUndefined,
              [ fun γ => ltac:(M.monadic (M.deref (| M.read (| self |) |))) ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_move_binary_format_file_format_IdentifierIndex.
  
  Module Impl_core_marker_Copy_for_move_binary_format_file_format_IdentifierIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::IdentifierIndex".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::Copy"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_Copy_for_move_binary_format_file_format_IdentifierIndex.
  
  Module Impl_core_default_Default_for_move_binary_format_file_format_IdentifierIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::IdentifierIndex".
    
    (*         Default *)
    Definition default (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [] =>
        ltac:(M.monadic
          (Value.StructTuple
            "move_binary_format::file_format::IdentifierIndex"
            []
            []
            [
              M.call_closure (|
                Ty.path "u16",
                M.get_trait_method (|
                  "core::default::Default",
                  Ty.path "u16",
                  [],
                  [],
                  "default",
                  [],
                  []
                |),
                []
              |)
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::default::Default"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("default", InstanceField.Method default) ].
  End Impl_core_default_Default_for_move_binary_format_file_format_IdentifierIndex.
  
  Module Impl_core_cmp_Eq_for_move_binary_format_file_format_IdentifierIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::IdentifierIndex".
    
    (*         Eq *)
    Definition assert_receiver_is_total_eq
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              Value.DeclaredButUndefined,
              [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_move_binary_format_file_format_IdentifierIndex.
  
  Module Impl_core_hash_Hash_for_move_binary_format_file_format_IdentifierIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::IdentifierIndex".
    
    (*         Hash *)
    Definition hash (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ __H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let state := M.alloc (| state |) in
          M.call_closure (|
            Ty.tuple [],
            M.get_trait_method (| "core::hash::Hash", Ty.path "u16", [], [], "hash", [], [ __H ] |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| self |) |),
                      "move_binary_format::file_format::IdentifierIndex",
                      0
                    |)
                  |)
                |)
              |);
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::hash::Hash"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("hash", InstanceField.Method hash) ].
  End Impl_core_hash_Hash_for_move_binary_format_file_format_IdentifierIndex.
  
  Module Impl_core_cmp_Ord_for_move_binary_format_file_format_IdentifierIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::IdentifierIndex".
    
    (*         Ord *)
    Definition cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.path "core::cmp::Ordering",
            M.get_trait_method (| "core::cmp::Ord", Ty.path "u16", [], [], "cmp", [], [] |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| self |) |),
                      "move_binary_format::file_format::IdentifierIndex",
                      0
                    |)
                  |)
                |)
              |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| other |) |),
                      "move_binary_format::file_format::IdentifierIndex",
                      0
                    |)
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Ord"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("cmp", InstanceField.Method cmp) ].
  End Impl_core_cmp_Ord_for_move_binary_format_file_format_IdentifierIndex.
  
  Module Impl_core_marker_StructuralPartialEq_for_move_binary_format_file_format_IdentifierIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::IdentifierIndex".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_move_binary_format_file_format_IdentifierIndex.
  
  Module Impl_core_cmp_PartialEq_move_binary_format_file_format_IdentifierIndex_for_move_binary_format_file_format_IdentifierIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::IdentifierIndex".
    
    (*         PartialEq *)
    Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.path "bool",
            BinOp.eq,
            [
              M.read (|
                M.SubPointer.get_struct_tuple_field (|
                  M.deref (| M.read (| self |) |),
                  "move_binary_format::file_format::IdentifierIndex",
                  0
                |)
              |);
              M.read (|
                M.SubPointer.get_struct_tuple_field (|
                  M.deref (| M.read (| other |) |),
                  "move_binary_format::file_format::IdentifierIndex",
                  0
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "move_binary_format::file_format::IdentifierIndex" ]
        Self
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_move_binary_format_file_format_IdentifierIndex_for_move_binary_format_file_format_IdentifierIndex.
  
  Module Impl_core_cmp_PartialOrd_move_binary_format_file_format_IdentifierIndex_for_move_binary_format_file_format_IdentifierIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::IdentifierIndex".
    
    (*         PartialOrd *)
    Definition partial_cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "core::cmp::Ordering" ],
            M.get_trait_method (|
              "core::cmp::PartialOrd",
              Ty.path "u16",
              [],
              [ Ty.path "u16" ],
              "partial_cmp",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| self |) |),
                      "move_binary_format::file_format::IdentifierIndex",
                      0
                    |)
                  |)
                |)
              |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| other |) |),
                      "move_binary_format::file_format::IdentifierIndex",
                      0
                    |)
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialOrd"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "move_binary_format::file_format::IdentifierIndex" ]
        Self
        (* Instance *) [ ("partial_cmp", InstanceField.Method partial_cmp) ].
  End Impl_core_cmp_PartialOrd_move_binary_format_file_format_IdentifierIndex_for_move_binary_format_file_format_IdentifierIndex.
  
  Module Impl_move_binary_format_file_format_IdentifierIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::IdentifierIndex".
    
    (*
                pub fn new(idx: TableIndex) -> Self {
                    Self(idx)
                }
    *)
    Definition new (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ idx ] =>
        ltac:(M.monadic
          (let idx := M.alloc (| idx |) in
          Value.StructTuple
            "move_binary_format::file_format::IdentifierIndex"
            []
            []
            [ M.read (| idx |) ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_new : M.IsAssociatedFunction.C Self "new" new.
    Admitted.
    Global Typeclasses Opaque new.
  End Impl_move_binary_format_file_format_IdentifierIndex.
  
  Module Impl_core_fmt_Display_for_move_binary_format_file_format_IdentifierIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::IdentifierIndex".
    
    (*
                fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "{}", self.0)
                }
    *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_fmt", [], [] |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
              M.call_closure (|
                Ty.path "core::fmt::Arguments",
                M.get_associated_function (|
                  Ty.path "core::fmt::Arguments",
                  "new_v1",
                  [ Value.Integer IntegerKind.Usize 1; Value.Integer IntegerKind.Usize 1 ],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (| Pointer.Kind.Ref, M.alloc (| Value.Array [ mk_str (| "" |) ] |) |)
                    |)
                  |);
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          Value.Array
                            [
                              M.call_closure (|
                                Ty.path "core::fmt::rt::Argument",
                                M.get_associated_function (|
                                  Ty.path "core::fmt::rt::Argument",
                                  "new_display",
                                  [],
                                  [ Ty.path "u16" ]
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.SubPointer.get_struct_tuple_field (|
                                          M.deref (| M.read (| self |) |),
                                          "move_binary_format::file_format::IdentifierIndex",
                                          0
                                        |)
                                      |)
                                    |)
                                  |)
                                ]
                              |)
                            ]
                        |)
                      |)
                    |)
                  |)
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Display"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Display_for_move_binary_format_file_format_IdentifierIndex.
  
  Module Impl_core_fmt_Debug_for_move_binary_format_file_format_IdentifierIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::IdentifierIndex".
    
    (*
                fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "{}({})", stringify!($name), self.0)
                }
    *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_fmt", [], [] |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
              M.call_closure (|
                Ty.path "core::fmt::Arguments",
                M.get_associated_function (|
                  Ty.path "core::fmt::Arguments",
                  "new_v1",
                  [ Value.Integer IntegerKind.Usize 2; Value.Integer IntegerKind.Usize 1 ],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          Value.Array [ mk_str (| "IdentifierIndex(" |); mk_str (| ")" |) ]
                        |)
                      |)
                    |)
                  |);
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          Value.Array
                            [
                              M.call_closure (|
                                Ty.path "core::fmt::rt::Argument",
                                M.get_associated_function (|
                                  Ty.path "core::fmt::rt::Argument",
                                  "new_display",
                                  [],
                                  [ Ty.path "u16" ]
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.SubPointer.get_struct_tuple_field (|
                                          M.deref (| M.read (| self |) |),
                                          "move_binary_format::file_format::IdentifierIndex",
                                          0
                                        |)
                                      |)
                                    |)
                                  |)
                                ]
                              |)
                            ]
                        |)
                      |)
                    |)
                  |)
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_move_binary_format_file_format_IdentifierIndex.
  
  Module Impl_move_binary_format_internals_ModuleIndex_for_move_binary_format_file_format_IdentifierIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::IdentifierIndex".
    
    (*             const KIND: IndexKind = IndexKind::$kind; *)
    (* Ty.path "move_binary_format::IndexKind" *)
    Definition value_KIND (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      ltac:(M.monadic
        (M.alloc (| Value.StructTuple "move_binary_format::IndexKind::Identifier" [] [] [] |))).
    
    (*
                fn into_index(self) -> usize {
                    self.0 as usize
                }
    *)
    Definition into_index (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.cast
            (Ty.path "usize")
            (M.read (|
              M.SubPointer.get_struct_tuple_field (|
                self,
                "move_binary_format::file_format::IdentifierIndex",
                0
              |)
            |))))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "move_binary_format::internals::ModuleIndex"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *)
        [
          ("value_KIND", InstanceField.Method value_KIND);
          ("into_index", InstanceField.Method into_index)
        ].
  End Impl_move_binary_format_internals_ModuleIndex_for_move_binary_format_file_format_IdentifierIndex.
  
  (* StructTuple
    {
      name := "AddressIdentifierIndex";
      const_params := [];
      ty_params := [];
      fields := [ Ty.path "u16" ];
    } *)
  
  Module Impl_core_clone_Clone_for_move_binary_format_file_format_AddressIdentifierIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::AddressIdentifierIndex".
    
    (*         Clone *)
    Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Ty.apply
                (Ty.path "*")
                []
                [ Ty.path "move_binary_format::file_format::AddressIdentifierIndex" ],
              Value.DeclaredButUndefined,
              [ fun γ => ltac:(M.monadic (M.deref (| M.read (| self |) |))) ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_move_binary_format_file_format_AddressIdentifierIndex.
  
  Module Impl_core_marker_Copy_for_move_binary_format_file_format_AddressIdentifierIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::AddressIdentifierIndex".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::Copy"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_Copy_for_move_binary_format_file_format_AddressIdentifierIndex.
  
  Module Impl_core_default_Default_for_move_binary_format_file_format_AddressIdentifierIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::AddressIdentifierIndex".
    
    (*         Default *)
    Definition default (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [] =>
        ltac:(M.monadic
          (Value.StructTuple
            "move_binary_format::file_format::AddressIdentifierIndex"
            []
            []
            [
              M.call_closure (|
                Ty.path "u16",
                M.get_trait_method (|
                  "core::default::Default",
                  Ty.path "u16",
                  [],
                  [],
                  "default",
                  [],
                  []
                |),
                []
              |)
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::default::Default"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("default", InstanceField.Method default) ].
  End Impl_core_default_Default_for_move_binary_format_file_format_AddressIdentifierIndex.
  
  Module Impl_core_cmp_Eq_for_move_binary_format_file_format_AddressIdentifierIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::AddressIdentifierIndex".
    
    (*         Eq *)
    Definition assert_receiver_is_total_eq
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              Value.DeclaredButUndefined,
              [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_move_binary_format_file_format_AddressIdentifierIndex.
  
  Module Impl_core_hash_Hash_for_move_binary_format_file_format_AddressIdentifierIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::AddressIdentifierIndex".
    
    (*         Hash *)
    Definition hash (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ __H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let state := M.alloc (| state |) in
          M.call_closure (|
            Ty.tuple [],
            M.get_trait_method (| "core::hash::Hash", Ty.path "u16", [], [], "hash", [], [ __H ] |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| self |) |),
                      "move_binary_format::file_format::AddressIdentifierIndex",
                      0
                    |)
                  |)
                |)
              |);
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::hash::Hash"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("hash", InstanceField.Method hash) ].
  End Impl_core_hash_Hash_for_move_binary_format_file_format_AddressIdentifierIndex.
  
  Module Impl_core_cmp_Ord_for_move_binary_format_file_format_AddressIdentifierIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::AddressIdentifierIndex".
    
    (*         Ord *)
    Definition cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.path "core::cmp::Ordering",
            M.get_trait_method (| "core::cmp::Ord", Ty.path "u16", [], [], "cmp", [], [] |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| self |) |),
                      "move_binary_format::file_format::AddressIdentifierIndex",
                      0
                    |)
                  |)
                |)
              |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| other |) |),
                      "move_binary_format::file_format::AddressIdentifierIndex",
                      0
                    |)
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Ord"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("cmp", InstanceField.Method cmp) ].
  End Impl_core_cmp_Ord_for_move_binary_format_file_format_AddressIdentifierIndex.
  
  Module Impl_core_marker_StructuralPartialEq_for_move_binary_format_file_format_AddressIdentifierIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::AddressIdentifierIndex".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_move_binary_format_file_format_AddressIdentifierIndex.
  
  Module Impl_core_cmp_PartialEq_move_binary_format_file_format_AddressIdentifierIndex_for_move_binary_format_file_format_AddressIdentifierIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::AddressIdentifierIndex".
    
    (*         PartialEq *)
    Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.path "bool",
            BinOp.eq,
            [
              M.read (|
                M.SubPointer.get_struct_tuple_field (|
                  M.deref (| M.read (| self |) |),
                  "move_binary_format::file_format::AddressIdentifierIndex",
                  0
                |)
              |);
              M.read (|
                M.SubPointer.get_struct_tuple_field (|
                  M.deref (| M.read (| other |) |),
                  "move_binary_format::file_format::AddressIdentifierIndex",
                  0
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.path "move_binary_format::file_format::AddressIdentifierIndex" ]
        Self
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_move_binary_format_file_format_AddressIdentifierIndex_for_move_binary_format_file_format_AddressIdentifierIndex.
  
  Module Impl_core_cmp_PartialOrd_move_binary_format_file_format_AddressIdentifierIndex_for_move_binary_format_file_format_AddressIdentifierIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::AddressIdentifierIndex".
    
    (*         PartialOrd *)
    Definition partial_cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "core::cmp::Ordering" ],
            M.get_trait_method (|
              "core::cmp::PartialOrd",
              Ty.path "u16",
              [],
              [ Ty.path "u16" ],
              "partial_cmp",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| self |) |),
                      "move_binary_format::file_format::AddressIdentifierIndex",
                      0
                    |)
                  |)
                |)
              |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| other |) |),
                      "move_binary_format::file_format::AddressIdentifierIndex",
                      0
                    |)
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialOrd"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.path "move_binary_format::file_format::AddressIdentifierIndex" ]
        Self
        (* Instance *) [ ("partial_cmp", InstanceField.Method partial_cmp) ].
  End Impl_core_cmp_PartialOrd_move_binary_format_file_format_AddressIdentifierIndex_for_move_binary_format_file_format_AddressIdentifierIndex.
  
  Module Impl_move_binary_format_file_format_AddressIdentifierIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::AddressIdentifierIndex".
    
    (*
                pub fn new(idx: TableIndex) -> Self {
                    Self(idx)
                }
    *)
    Definition new (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ idx ] =>
        ltac:(M.monadic
          (let idx := M.alloc (| idx |) in
          Value.StructTuple
            "move_binary_format::file_format::AddressIdentifierIndex"
            []
            []
            [ M.read (| idx |) ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_new : M.IsAssociatedFunction.C Self "new" new.
    Admitted.
    Global Typeclasses Opaque new.
  End Impl_move_binary_format_file_format_AddressIdentifierIndex.
  
  Module Impl_core_fmt_Display_for_move_binary_format_file_format_AddressIdentifierIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::AddressIdentifierIndex".
    
    (*
                fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "{}", self.0)
                }
    *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_fmt", [], [] |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
              M.call_closure (|
                Ty.path "core::fmt::Arguments",
                M.get_associated_function (|
                  Ty.path "core::fmt::Arguments",
                  "new_v1",
                  [ Value.Integer IntegerKind.Usize 1; Value.Integer IntegerKind.Usize 1 ],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (| Pointer.Kind.Ref, M.alloc (| Value.Array [ mk_str (| "" |) ] |) |)
                    |)
                  |);
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          Value.Array
                            [
                              M.call_closure (|
                                Ty.path "core::fmt::rt::Argument",
                                M.get_associated_function (|
                                  Ty.path "core::fmt::rt::Argument",
                                  "new_display",
                                  [],
                                  [ Ty.path "u16" ]
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.SubPointer.get_struct_tuple_field (|
                                          M.deref (| M.read (| self |) |),
                                          "move_binary_format::file_format::AddressIdentifierIndex",
                                          0
                                        |)
                                      |)
                                    |)
                                  |)
                                ]
                              |)
                            ]
                        |)
                      |)
                    |)
                  |)
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Display"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Display_for_move_binary_format_file_format_AddressIdentifierIndex.
  
  Module Impl_core_fmt_Debug_for_move_binary_format_file_format_AddressIdentifierIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::AddressIdentifierIndex".
    
    (*
                fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "{}({})", stringify!($name), self.0)
                }
    *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_fmt", [], [] |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
              M.call_closure (|
                Ty.path "core::fmt::Arguments",
                M.get_associated_function (|
                  Ty.path "core::fmt::Arguments",
                  "new_v1",
                  [ Value.Integer IntegerKind.Usize 2; Value.Integer IntegerKind.Usize 1 ],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          Value.Array [ mk_str (| "AddressIdentifierIndex(" |); mk_str (| ")" |) ]
                        |)
                      |)
                    |)
                  |);
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          Value.Array
                            [
                              M.call_closure (|
                                Ty.path "core::fmt::rt::Argument",
                                M.get_associated_function (|
                                  Ty.path "core::fmt::rt::Argument",
                                  "new_display",
                                  [],
                                  [ Ty.path "u16" ]
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.SubPointer.get_struct_tuple_field (|
                                          M.deref (| M.read (| self |) |),
                                          "move_binary_format::file_format::AddressIdentifierIndex",
                                          0
                                        |)
                                      |)
                                    |)
                                  |)
                                ]
                              |)
                            ]
                        |)
                      |)
                    |)
                  |)
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_move_binary_format_file_format_AddressIdentifierIndex.
  
  Module Impl_move_binary_format_internals_ModuleIndex_for_move_binary_format_file_format_AddressIdentifierIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::AddressIdentifierIndex".
    
    (*             const KIND: IndexKind = IndexKind::$kind; *)
    (* Ty.path "move_binary_format::IndexKind" *)
    Definition value_KIND (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      ltac:(M.monadic
        (M.alloc (|
          Value.StructTuple "move_binary_format::IndexKind::AddressIdentifier" [] [] []
        |))).
    
    (*
                fn into_index(self) -> usize {
                    self.0 as usize
                }
    *)
    Definition into_index (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.cast
            (Ty.path "usize")
            (M.read (|
              M.SubPointer.get_struct_tuple_field (|
                self,
                "move_binary_format::file_format::AddressIdentifierIndex",
                0
              |)
            |))))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "move_binary_format::internals::ModuleIndex"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *)
        [
          ("value_KIND", InstanceField.Method value_KIND);
          ("into_index", InstanceField.Method into_index)
        ].
  End Impl_move_binary_format_internals_ModuleIndex_for_move_binary_format_file_format_AddressIdentifierIndex.
  
  (* StructTuple
    {
      name := "ConstantPoolIndex";
      const_params := [];
      ty_params := [];
      fields := [ Ty.path "u16" ];
    } *)
  
  Module Impl_core_clone_Clone_for_move_binary_format_file_format_ConstantPoolIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::ConstantPoolIndex".
    
    (*         Clone *)
    Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Ty.apply
                (Ty.path "*")
                []
                [ Ty.path "move_binary_format::file_format::ConstantPoolIndex" ],
              Value.DeclaredButUndefined,
              [ fun γ => ltac:(M.monadic (M.deref (| M.read (| self |) |))) ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_move_binary_format_file_format_ConstantPoolIndex.
  
  Module Impl_core_marker_Copy_for_move_binary_format_file_format_ConstantPoolIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::ConstantPoolIndex".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::Copy"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_Copy_for_move_binary_format_file_format_ConstantPoolIndex.
  
  Module Impl_core_default_Default_for_move_binary_format_file_format_ConstantPoolIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::ConstantPoolIndex".
    
    (*         Default *)
    Definition default (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [] =>
        ltac:(M.monadic
          (Value.StructTuple
            "move_binary_format::file_format::ConstantPoolIndex"
            []
            []
            [
              M.call_closure (|
                Ty.path "u16",
                M.get_trait_method (|
                  "core::default::Default",
                  Ty.path "u16",
                  [],
                  [],
                  "default",
                  [],
                  []
                |),
                []
              |)
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::default::Default"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("default", InstanceField.Method default) ].
  End Impl_core_default_Default_for_move_binary_format_file_format_ConstantPoolIndex.
  
  Module Impl_core_cmp_Eq_for_move_binary_format_file_format_ConstantPoolIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::ConstantPoolIndex".
    
    (*         Eq *)
    Definition assert_receiver_is_total_eq
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              Value.DeclaredButUndefined,
              [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_move_binary_format_file_format_ConstantPoolIndex.
  
  Module Impl_core_hash_Hash_for_move_binary_format_file_format_ConstantPoolIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::ConstantPoolIndex".
    
    (*         Hash *)
    Definition hash (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ __H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let state := M.alloc (| state |) in
          M.call_closure (|
            Ty.tuple [],
            M.get_trait_method (| "core::hash::Hash", Ty.path "u16", [], [], "hash", [], [ __H ] |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| self |) |),
                      "move_binary_format::file_format::ConstantPoolIndex",
                      0
                    |)
                  |)
                |)
              |);
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::hash::Hash"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("hash", InstanceField.Method hash) ].
  End Impl_core_hash_Hash_for_move_binary_format_file_format_ConstantPoolIndex.
  
  Module Impl_core_cmp_Ord_for_move_binary_format_file_format_ConstantPoolIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::ConstantPoolIndex".
    
    (*         Ord *)
    Definition cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.path "core::cmp::Ordering",
            M.get_trait_method (| "core::cmp::Ord", Ty.path "u16", [], [], "cmp", [], [] |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| self |) |),
                      "move_binary_format::file_format::ConstantPoolIndex",
                      0
                    |)
                  |)
                |)
              |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| other |) |),
                      "move_binary_format::file_format::ConstantPoolIndex",
                      0
                    |)
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Ord"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("cmp", InstanceField.Method cmp) ].
  End Impl_core_cmp_Ord_for_move_binary_format_file_format_ConstantPoolIndex.
  
  Module Impl_core_marker_StructuralPartialEq_for_move_binary_format_file_format_ConstantPoolIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::ConstantPoolIndex".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_move_binary_format_file_format_ConstantPoolIndex.
  
  Module Impl_core_cmp_PartialEq_move_binary_format_file_format_ConstantPoolIndex_for_move_binary_format_file_format_ConstantPoolIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::ConstantPoolIndex".
    
    (*         PartialEq *)
    Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.path "bool",
            BinOp.eq,
            [
              M.read (|
                M.SubPointer.get_struct_tuple_field (|
                  M.deref (| M.read (| self |) |),
                  "move_binary_format::file_format::ConstantPoolIndex",
                  0
                |)
              |);
              M.read (|
                M.SubPointer.get_struct_tuple_field (|
                  M.deref (| M.read (| other |) |),
                  "move_binary_format::file_format::ConstantPoolIndex",
                  0
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.path "move_binary_format::file_format::ConstantPoolIndex" ]
        Self
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_move_binary_format_file_format_ConstantPoolIndex_for_move_binary_format_file_format_ConstantPoolIndex.
  
  Module Impl_core_cmp_PartialOrd_move_binary_format_file_format_ConstantPoolIndex_for_move_binary_format_file_format_ConstantPoolIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::ConstantPoolIndex".
    
    (*         PartialOrd *)
    Definition partial_cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "core::cmp::Ordering" ],
            M.get_trait_method (|
              "core::cmp::PartialOrd",
              Ty.path "u16",
              [],
              [ Ty.path "u16" ],
              "partial_cmp",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| self |) |),
                      "move_binary_format::file_format::ConstantPoolIndex",
                      0
                    |)
                  |)
                |)
              |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| other |) |),
                      "move_binary_format::file_format::ConstantPoolIndex",
                      0
                    |)
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialOrd"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.path "move_binary_format::file_format::ConstantPoolIndex" ]
        Self
        (* Instance *) [ ("partial_cmp", InstanceField.Method partial_cmp) ].
  End Impl_core_cmp_PartialOrd_move_binary_format_file_format_ConstantPoolIndex_for_move_binary_format_file_format_ConstantPoolIndex.
  
  Module Impl_move_binary_format_file_format_ConstantPoolIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::ConstantPoolIndex".
    
    (*
                pub fn new(idx: TableIndex) -> Self {
                    Self(idx)
                }
    *)
    Definition new (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ idx ] =>
        ltac:(M.monadic
          (let idx := M.alloc (| idx |) in
          Value.StructTuple
            "move_binary_format::file_format::ConstantPoolIndex"
            []
            []
            [ M.read (| idx |) ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_new : M.IsAssociatedFunction.C Self "new" new.
    Admitted.
    Global Typeclasses Opaque new.
  End Impl_move_binary_format_file_format_ConstantPoolIndex.
  
  Module Impl_core_fmt_Display_for_move_binary_format_file_format_ConstantPoolIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::ConstantPoolIndex".
    
    (*
                fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "{}", self.0)
                }
    *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_fmt", [], [] |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
              M.call_closure (|
                Ty.path "core::fmt::Arguments",
                M.get_associated_function (|
                  Ty.path "core::fmt::Arguments",
                  "new_v1",
                  [ Value.Integer IntegerKind.Usize 1; Value.Integer IntegerKind.Usize 1 ],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (| Pointer.Kind.Ref, M.alloc (| Value.Array [ mk_str (| "" |) ] |) |)
                    |)
                  |);
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          Value.Array
                            [
                              M.call_closure (|
                                Ty.path "core::fmt::rt::Argument",
                                M.get_associated_function (|
                                  Ty.path "core::fmt::rt::Argument",
                                  "new_display",
                                  [],
                                  [ Ty.path "u16" ]
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.SubPointer.get_struct_tuple_field (|
                                          M.deref (| M.read (| self |) |),
                                          "move_binary_format::file_format::ConstantPoolIndex",
                                          0
                                        |)
                                      |)
                                    |)
                                  |)
                                ]
                              |)
                            ]
                        |)
                      |)
                    |)
                  |)
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Display"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Display_for_move_binary_format_file_format_ConstantPoolIndex.
  
  Module Impl_core_fmt_Debug_for_move_binary_format_file_format_ConstantPoolIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::ConstantPoolIndex".
    
    (*
                fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "{}({})", stringify!($name), self.0)
                }
    *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_fmt", [], [] |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
              M.call_closure (|
                Ty.path "core::fmt::Arguments",
                M.get_associated_function (|
                  Ty.path "core::fmt::Arguments",
                  "new_v1",
                  [ Value.Integer IntegerKind.Usize 2; Value.Integer IntegerKind.Usize 1 ],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          Value.Array [ mk_str (| "ConstantPoolIndex(" |); mk_str (| ")" |) ]
                        |)
                      |)
                    |)
                  |);
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          Value.Array
                            [
                              M.call_closure (|
                                Ty.path "core::fmt::rt::Argument",
                                M.get_associated_function (|
                                  Ty.path "core::fmt::rt::Argument",
                                  "new_display",
                                  [],
                                  [ Ty.path "u16" ]
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.SubPointer.get_struct_tuple_field (|
                                          M.deref (| M.read (| self |) |),
                                          "move_binary_format::file_format::ConstantPoolIndex",
                                          0
                                        |)
                                      |)
                                    |)
                                  |)
                                ]
                              |)
                            ]
                        |)
                      |)
                    |)
                  |)
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_move_binary_format_file_format_ConstantPoolIndex.
  
  Module Impl_move_binary_format_internals_ModuleIndex_for_move_binary_format_file_format_ConstantPoolIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::ConstantPoolIndex".
    
    (*             const KIND: IndexKind = IndexKind::$kind; *)
    (* Ty.path "move_binary_format::IndexKind" *)
    Definition value_KIND (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      ltac:(M.monadic
        (M.alloc (| Value.StructTuple "move_binary_format::IndexKind::ConstantPool" [] [] [] |))).
    
    (*
                fn into_index(self) -> usize {
                    self.0 as usize
                }
    *)
    Definition into_index (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.cast
            (Ty.path "usize")
            (M.read (|
              M.SubPointer.get_struct_tuple_field (|
                self,
                "move_binary_format::file_format::ConstantPoolIndex",
                0
              |)
            |))))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "move_binary_format::internals::ModuleIndex"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *)
        [
          ("value_KIND", InstanceField.Method value_KIND);
          ("into_index", InstanceField.Method into_index)
        ].
  End Impl_move_binary_format_internals_ModuleIndex_for_move_binary_format_file_format_ConstantPoolIndex.
  
  (* StructTuple
    {
      name := "SignatureIndex";
      const_params := [];
      ty_params := [];
      fields := [ Ty.path "u16" ];
    } *)
  
  Module Impl_core_clone_Clone_for_move_binary_format_file_format_SignatureIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::SignatureIndex".
    
    (*         Clone *)
    Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Ty.apply
                (Ty.path "*")
                []
                [ Ty.path "move_binary_format::file_format::SignatureIndex" ],
              Value.DeclaredButUndefined,
              [ fun γ => ltac:(M.monadic (M.deref (| M.read (| self |) |))) ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_move_binary_format_file_format_SignatureIndex.
  
  Module Impl_core_marker_Copy_for_move_binary_format_file_format_SignatureIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::SignatureIndex".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::Copy"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_Copy_for_move_binary_format_file_format_SignatureIndex.
  
  Module Impl_core_default_Default_for_move_binary_format_file_format_SignatureIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::SignatureIndex".
    
    (*         Default *)
    Definition default (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [] =>
        ltac:(M.monadic
          (Value.StructTuple
            "move_binary_format::file_format::SignatureIndex"
            []
            []
            [
              M.call_closure (|
                Ty.path "u16",
                M.get_trait_method (|
                  "core::default::Default",
                  Ty.path "u16",
                  [],
                  [],
                  "default",
                  [],
                  []
                |),
                []
              |)
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::default::Default"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("default", InstanceField.Method default) ].
  End Impl_core_default_Default_for_move_binary_format_file_format_SignatureIndex.
  
  Module Impl_core_cmp_Eq_for_move_binary_format_file_format_SignatureIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::SignatureIndex".
    
    (*         Eq *)
    Definition assert_receiver_is_total_eq
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              Value.DeclaredButUndefined,
              [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_move_binary_format_file_format_SignatureIndex.
  
  Module Impl_core_hash_Hash_for_move_binary_format_file_format_SignatureIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::SignatureIndex".
    
    (*         Hash *)
    Definition hash (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ __H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let state := M.alloc (| state |) in
          M.call_closure (|
            Ty.tuple [],
            M.get_trait_method (| "core::hash::Hash", Ty.path "u16", [], [], "hash", [], [ __H ] |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| self |) |),
                      "move_binary_format::file_format::SignatureIndex",
                      0
                    |)
                  |)
                |)
              |);
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::hash::Hash"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("hash", InstanceField.Method hash) ].
  End Impl_core_hash_Hash_for_move_binary_format_file_format_SignatureIndex.
  
  Module Impl_core_cmp_Ord_for_move_binary_format_file_format_SignatureIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::SignatureIndex".
    
    (*         Ord *)
    Definition cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.path "core::cmp::Ordering",
            M.get_trait_method (| "core::cmp::Ord", Ty.path "u16", [], [], "cmp", [], [] |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| self |) |),
                      "move_binary_format::file_format::SignatureIndex",
                      0
                    |)
                  |)
                |)
              |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| other |) |),
                      "move_binary_format::file_format::SignatureIndex",
                      0
                    |)
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Ord"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("cmp", InstanceField.Method cmp) ].
  End Impl_core_cmp_Ord_for_move_binary_format_file_format_SignatureIndex.
  
  Module Impl_core_marker_StructuralPartialEq_for_move_binary_format_file_format_SignatureIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::SignatureIndex".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_move_binary_format_file_format_SignatureIndex.
  
  Module Impl_core_cmp_PartialEq_move_binary_format_file_format_SignatureIndex_for_move_binary_format_file_format_SignatureIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::SignatureIndex".
    
    (*         PartialEq *)
    Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.path "bool",
            BinOp.eq,
            [
              M.read (|
                M.SubPointer.get_struct_tuple_field (|
                  M.deref (| M.read (| self |) |),
                  "move_binary_format::file_format::SignatureIndex",
                  0
                |)
              |);
              M.read (|
                M.SubPointer.get_struct_tuple_field (|
                  M.deref (| M.read (| other |) |),
                  "move_binary_format::file_format::SignatureIndex",
                  0
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "move_binary_format::file_format::SignatureIndex" ]
        Self
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_move_binary_format_file_format_SignatureIndex_for_move_binary_format_file_format_SignatureIndex.
  
  Module Impl_core_cmp_PartialOrd_move_binary_format_file_format_SignatureIndex_for_move_binary_format_file_format_SignatureIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::SignatureIndex".
    
    (*         PartialOrd *)
    Definition partial_cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "core::cmp::Ordering" ],
            M.get_trait_method (|
              "core::cmp::PartialOrd",
              Ty.path "u16",
              [],
              [ Ty.path "u16" ],
              "partial_cmp",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| self |) |),
                      "move_binary_format::file_format::SignatureIndex",
                      0
                    |)
                  |)
                |)
              |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| other |) |),
                      "move_binary_format::file_format::SignatureIndex",
                      0
                    |)
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialOrd"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "move_binary_format::file_format::SignatureIndex" ]
        Self
        (* Instance *) [ ("partial_cmp", InstanceField.Method partial_cmp) ].
  End Impl_core_cmp_PartialOrd_move_binary_format_file_format_SignatureIndex_for_move_binary_format_file_format_SignatureIndex.
  
  Module Impl_move_binary_format_file_format_SignatureIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::SignatureIndex".
    
    (*
                pub fn new(idx: TableIndex) -> Self {
                    Self(idx)
                }
    *)
    Definition new (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ idx ] =>
        ltac:(M.monadic
          (let idx := M.alloc (| idx |) in
          Value.StructTuple
            "move_binary_format::file_format::SignatureIndex"
            []
            []
            [ M.read (| idx |) ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_new : M.IsAssociatedFunction.C Self "new" new.
    Admitted.
    Global Typeclasses Opaque new.
  End Impl_move_binary_format_file_format_SignatureIndex.
  
  Module Impl_core_fmt_Display_for_move_binary_format_file_format_SignatureIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::SignatureIndex".
    
    (*
                fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "{}", self.0)
                }
    *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_fmt", [], [] |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
              M.call_closure (|
                Ty.path "core::fmt::Arguments",
                M.get_associated_function (|
                  Ty.path "core::fmt::Arguments",
                  "new_v1",
                  [ Value.Integer IntegerKind.Usize 1; Value.Integer IntegerKind.Usize 1 ],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (| Pointer.Kind.Ref, M.alloc (| Value.Array [ mk_str (| "" |) ] |) |)
                    |)
                  |);
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          Value.Array
                            [
                              M.call_closure (|
                                Ty.path "core::fmt::rt::Argument",
                                M.get_associated_function (|
                                  Ty.path "core::fmt::rt::Argument",
                                  "new_display",
                                  [],
                                  [ Ty.path "u16" ]
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.SubPointer.get_struct_tuple_field (|
                                          M.deref (| M.read (| self |) |),
                                          "move_binary_format::file_format::SignatureIndex",
                                          0
                                        |)
                                      |)
                                    |)
                                  |)
                                ]
                              |)
                            ]
                        |)
                      |)
                    |)
                  |)
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Display"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Display_for_move_binary_format_file_format_SignatureIndex.
  
  Module Impl_core_fmt_Debug_for_move_binary_format_file_format_SignatureIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::SignatureIndex".
    
    (*
                fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "{}({})", stringify!($name), self.0)
                }
    *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_fmt", [], [] |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
              M.call_closure (|
                Ty.path "core::fmt::Arguments",
                M.get_associated_function (|
                  Ty.path "core::fmt::Arguments",
                  "new_v1",
                  [ Value.Integer IntegerKind.Usize 2; Value.Integer IntegerKind.Usize 1 ],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          Value.Array [ mk_str (| "SignatureIndex(" |); mk_str (| ")" |) ]
                        |)
                      |)
                    |)
                  |);
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          Value.Array
                            [
                              M.call_closure (|
                                Ty.path "core::fmt::rt::Argument",
                                M.get_associated_function (|
                                  Ty.path "core::fmt::rt::Argument",
                                  "new_display",
                                  [],
                                  [ Ty.path "u16" ]
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.SubPointer.get_struct_tuple_field (|
                                          M.deref (| M.read (| self |) |),
                                          "move_binary_format::file_format::SignatureIndex",
                                          0
                                        |)
                                      |)
                                    |)
                                  |)
                                ]
                              |)
                            ]
                        |)
                      |)
                    |)
                  |)
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_move_binary_format_file_format_SignatureIndex.
  
  Module Impl_move_binary_format_internals_ModuleIndex_for_move_binary_format_file_format_SignatureIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::SignatureIndex".
    
    (*             const KIND: IndexKind = IndexKind::$kind; *)
    (* Ty.path "move_binary_format::IndexKind" *)
    Definition value_KIND (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      ltac:(M.monadic
        (M.alloc (| Value.StructTuple "move_binary_format::IndexKind::Signature" [] [] [] |))).
    
    (*
                fn into_index(self) -> usize {
                    self.0 as usize
                }
    *)
    Definition into_index (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.cast
            (Ty.path "usize")
            (M.read (|
              M.SubPointer.get_struct_tuple_field (|
                self,
                "move_binary_format::file_format::SignatureIndex",
                0
              |)
            |))))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "move_binary_format::internals::ModuleIndex"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *)
        [
          ("value_KIND", InstanceField.Method value_KIND);
          ("into_index", InstanceField.Method into_index)
        ].
  End Impl_move_binary_format_internals_ModuleIndex_for_move_binary_format_file_format_SignatureIndex.
  
  (* StructTuple
    {
      name := "StructDefinitionIndex";
      const_params := [];
      ty_params := [];
      fields := [ Ty.path "u16" ];
    } *)
  
  Module Impl_core_clone_Clone_for_move_binary_format_file_format_StructDefinitionIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::StructDefinitionIndex".
    
    (*         Clone *)
    Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Ty.apply
                (Ty.path "*")
                []
                [ Ty.path "move_binary_format::file_format::StructDefinitionIndex" ],
              Value.DeclaredButUndefined,
              [ fun γ => ltac:(M.monadic (M.deref (| M.read (| self |) |))) ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_move_binary_format_file_format_StructDefinitionIndex.
  
  Module Impl_core_marker_Copy_for_move_binary_format_file_format_StructDefinitionIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::StructDefinitionIndex".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::Copy"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_Copy_for_move_binary_format_file_format_StructDefinitionIndex.
  
  Module Impl_core_default_Default_for_move_binary_format_file_format_StructDefinitionIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::StructDefinitionIndex".
    
    (*         Default *)
    Definition default (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [] =>
        ltac:(M.monadic
          (Value.StructTuple
            "move_binary_format::file_format::StructDefinitionIndex"
            []
            []
            [
              M.call_closure (|
                Ty.path "u16",
                M.get_trait_method (|
                  "core::default::Default",
                  Ty.path "u16",
                  [],
                  [],
                  "default",
                  [],
                  []
                |),
                []
              |)
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::default::Default"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("default", InstanceField.Method default) ].
  End Impl_core_default_Default_for_move_binary_format_file_format_StructDefinitionIndex.
  
  Module Impl_core_cmp_Eq_for_move_binary_format_file_format_StructDefinitionIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::StructDefinitionIndex".
    
    (*         Eq *)
    Definition assert_receiver_is_total_eq
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              Value.DeclaredButUndefined,
              [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_move_binary_format_file_format_StructDefinitionIndex.
  
  Module Impl_core_hash_Hash_for_move_binary_format_file_format_StructDefinitionIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::StructDefinitionIndex".
    
    (*         Hash *)
    Definition hash (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ __H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let state := M.alloc (| state |) in
          M.call_closure (|
            Ty.tuple [],
            M.get_trait_method (| "core::hash::Hash", Ty.path "u16", [], [], "hash", [], [ __H ] |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| self |) |),
                      "move_binary_format::file_format::StructDefinitionIndex",
                      0
                    |)
                  |)
                |)
              |);
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::hash::Hash"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("hash", InstanceField.Method hash) ].
  End Impl_core_hash_Hash_for_move_binary_format_file_format_StructDefinitionIndex.
  
  Module Impl_core_cmp_Ord_for_move_binary_format_file_format_StructDefinitionIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::StructDefinitionIndex".
    
    (*         Ord *)
    Definition cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.path "core::cmp::Ordering",
            M.get_trait_method (| "core::cmp::Ord", Ty.path "u16", [], [], "cmp", [], [] |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| self |) |),
                      "move_binary_format::file_format::StructDefinitionIndex",
                      0
                    |)
                  |)
                |)
              |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| other |) |),
                      "move_binary_format::file_format::StructDefinitionIndex",
                      0
                    |)
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Ord"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("cmp", InstanceField.Method cmp) ].
  End Impl_core_cmp_Ord_for_move_binary_format_file_format_StructDefinitionIndex.
  
  Module Impl_core_marker_StructuralPartialEq_for_move_binary_format_file_format_StructDefinitionIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::StructDefinitionIndex".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_move_binary_format_file_format_StructDefinitionIndex.
  
  Module Impl_core_cmp_PartialEq_move_binary_format_file_format_StructDefinitionIndex_for_move_binary_format_file_format_StructDefinitionIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::StructDefinitionIndex".
    
    (*         PartialEq *)
    Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.path "bool",
            BinOp.eq,
            [
              M.read (|
                M.SubPointer.get_struct_tuple_field (|
                  M.deref (| M.read (| self |) |),
                  "move_binary_format::file_format::StructDefinitionIndex",
                  0
                |)
              |);
              M.read (|
                M.SubPointer.get_struct_tuple_field (|
                  M.deref (| M.read (| other |) |),
                  "move_binary_format::file_format::StructDefinitionIndex",
                  0
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.path "move_binary_format::file_format::StructDefinitionIndex" ]
        Self
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_move_binary_format_file_format_StructDefinitionIndex_for_move_binary_format_file_format_StructDefinitionIndex.
  
  Module Impl_core_cmp_PartialOrd_move_binary_format_file_format_StructDefinitionIndex_for_move_binary_format_file_format_StructDefinitionIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::StructDefinitionIndex".
    
    (*         PartialOrd *)
    Definition partial_cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "core::cmp::Ordering" ],
            M.get_trait_method (|
              "core::cmp::PartialOrd",
              Ty.path "u16",
              [],
              [ Ty.path "u16" ],
              "partial_cmp",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| self |) |),
                      "move_binary_format::file_format::StructDefinitionIndex",
                      0
                    |)
                  |)
                |)
              |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| other |) |),
                      "move_binary_format::file_format::StructDefinitionIndex",
                      0
                    |)
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialOrd"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.path "move_binary_format::file_format::StructDefinitionIndex" ]
        Self
        (* Instance *) [ ("partial_cmp", InstanceField.Method partial_cmp) ].
  End Impl_core_cmp_PartialOrd_move_binary_format_file_format_StructDefinitionIndex_for_move_binary_format_file_format_StructDefinitionIndex.
  
  Module Impl_move_binary_format_file_format_StructDefinitionIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::StructDefinitionIndex".
    
    (*
                pub fn new(idx: TableIndex) -> Self {
                    Self(idx)
                }
    *)
    Definition new (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ idx ] =>
        ltac:(M.monadic
          (let idx := M.alloc (| idx |) in
          Value.StructTuple
            "move_binary_format::file_format::StructDefinitionIndex"
            []
            []
            [ M.read (| idx |) ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_new : M.IsAssociatedFunction.C Self "new" new.
    Admitted.
    Global Typeclasses Opaque new.
  End Impl_move_binary_format_file_format_StructDefinitionIndex.
  
  Module Impl_core_fmt_Display_for_move_binary_format_file_format_StructDefinitionIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::StructDefinitionIndex".
    
    (*
                fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "{}", self.0)
                }
    *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_fmt", [], [] |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
              M.call_closure (|
                Ty.path "core::fmt::Arguments",
                M.get_associated_function (|
                  Ty.path "core::fmt::Arguments",
                  "new_v1",
                  [ Value.Integer IntegerKind.Usize 1; Value.Integer IntegerKind.Usize 1 ],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (| Pointer.Kind.Ref, M.alloc (| Value.Array [ mk_str (| "" |) ] |) |)
                    |)
                  |);
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          Value.Array
                            [
                              M.call_closure (|
                                Ty.path "core::fmt::rt::Argument",
                                M.get_associated_function (|
                                  Ty.path "core::fmt::rt::Argument",
                                  "new_display",
                                  [],
                                  [ Ty.path "u16" ]
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.SubPointer.get_struct_tuple_field (|
                                          M.deref (| M.read (| self |) |),
                                          "move_binary_format::file_format::StructDefinitionIndex",
                                          0
                                        |)
                                      |)
                                    |)
                                  |)
                                ]
                              |)
                            ]
                        |)
                      |)
                    |)
                  |)
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Display"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Display_for_move_binary_format_file_format_StructDefinitionIndex.
  
  Module Impl_core_fmt_Debug_for_move_binary_format_file_format_StructDefinitionIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::StructDefinitionIndex".
    
    (*
                fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "{}({})", stringify!($name), self.0)
                }
    *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_fmt", [], [] |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
              M.call_closure (|
                Ty.path "core::fmt::Arguments",
                M.get_associated_function (|
                  Ty.path "core::fmt::Arguments",
                  "new_v1",
                  [ Value.Integer IntegerKind.Usize 2; Value.Integer IntegerKind.Usize 1 ],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          Value.Array [ mk_str (| "StructDefinitionIndex(" |); mk_str (| ")" |) ]
                        |)
                      |)
                    |)
                  |);
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          Value.Array
                            [
                              M.call_closure (|
                                Ty.path "core::fmt::rt::Argument",
                                M.get_associated_function (|
                                  Ty.path "core::fmt::rt::Argument",
                                  "new_display",
                                  [],
                                  [ Ty.path "u16" ]
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.SubPointer.get_struct_tuple_field (|
                                          M.deref (| M.read (| self |) |),
                                          "move_binary_format::file_format::StructDefinitionIndex",
                                          0
                                        |)
                                      |)
                                    |)
                                  |)
                                ]
                              |)
                            ]
                        |)
                      |)
                    |)
                  |)
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_move_binary_format_file_format_StructDefinitionIndex.
  
  Module Impl_move_binary_format_internals_ModuleIndex_for_move_binary_format_file_format_StructDefinitionIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::StructDefinitionIndex".
    
    (*             const KIND: IndexKind = IndexKind::$kind; *)
    (* Ty.path "move_binary_format::IndexKind" *)
    Definition value_KIND (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      ltac:(M.monadic
        (M.alloc (|
          Value.StructTuple "move_binary_format::IndexKind::StructDefinition" [] [] []
        |))).
    
    (*
                fn into_index(self) -> usize {
                    self.0 as usize
                }
    *)
    Definition into_index (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.cast
            (Ty.path "usize")
            (M.read (|
              M.SubPointer.get_struct_tuple_field (|
                self,
                "move_binary_format::file_format::StructDefinitionIndex",
                0
              |)
            |))))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "move_binary_format::internals::ModuleIndex"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *)
        [
          ("value_KIND", InstanceField.Method value_KIND);
          ("into_index", InstanceField.Method into_index)
        ].
  End Impl_move_binary_format_internals_ModuleIndex_for_move_binary_format_file_format_StructDefinitionIndex.
  
  (* StructTuple
    {
      name := "FunctionDefinitionIndex";
      const_params := [];
      ty_params := [];
      fields := [ Ty.path "u16" ];
    } *)
  
  Module Impl_core_clone_Clone_for_move_binary_format_file_format_FunctionDefinitionIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::FunctionDefinitionIndex".
    
    (*         Clone *)
    Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Ty.apply
                (Ty.path "*")
                []
                [ Ty.path "move_binary_format::file_format::FunctionDefinitionIndex" ],
              Value.DeclaredButUndefined,
              [ fun γ => ltac:(M.monadic (M.deref (| M.read (| self |) |))) ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_move_binary_format_file_format_FunctionDefinitionIndex.
  
  Module Impl_core_marker_Copy_for_move_binary_format_file_format_FunctionDefinitionIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::FunctionDefinitionIndex".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::Copy"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_Copy_for_move_binary_format_file_format_FunctionDefinitionIndex.
  
  Module Impl_core_default_Default_for_move_binary_format_file_format_FunctionDefinitionIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::FunctionDefinitionIndex".
    
    (*         Default *)
    Definition default (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [] =>
        ltac:(M.monadic
          (Value.StructTuple
            "move_binary_format::file_format::FunctionDefinitionIndex"
            []
            []
            [
              M.call_closure (|
                Ty.path "u16",
                M.get_trait_method (|
                  "core::default::Default",
                  Ty.path "u16",
                  [],
                  [],
                  "default",
                  [],
                  []
                |),
                []
              |)
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::default::Default"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("default", InstanceField.Method default) ].
  End Impl_core_default_Default_for_move_binary_format_file_format_FunctionDefinitionIndex.
  
  Module Impl_core_cmp_Eq_for_move_binary_format_file_format_FunctionDefinitionIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::FunctionDefinitionIndex".
    
    (*         Eq *)
    Definition assert_receiver_is_total_eq
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              Value.DeclaredButUndefined,
              [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_move_binary_format_file_format_FunctionDefinitionIndex.
  
  Module Impl_core_hash_Hash_for_move_binary_format_file_format_FunctionDefinitionIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::FunctionDefinitionIndex".
    
    (*         Hash *)
    Definition hash (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ __H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let state := M.alloc (| state |) in
          M.call_closure (|
            Ty.tuple [],
            M.get_trait_method (| "core::hash::Hash", Ty.path "u16", [], [], "hash", [], [ __H ] |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| self |) |),
                      "move_binary_format::file_format::FunctionDefinitionIndex",
                      0
                    |)
                  |)
                |)
              |);
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::hash::Hash"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("hash", InstanceField.Method hash) ].
  End Impl_core_hash_Hash_for_move_binary_format_file_format_FunctionDefinitionIndex.
  
  Module Impl_core_cmp_Ord_for_move_binary_format_file_format_FunctionDefinitionIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::FunctionDefinitionIndex".
    
    (*         Ord *)
    Definition cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.path "core::cmp::Ordering",
            M.get_trait_method (| "core::cmp::Ord", Ty.path "u16", [], [], "cmp", [], [] |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| self |) |),
                      "move_binary_format::file_format::FunctionDefinitionIndex",
                      0
                    |)
                  |)
                |)
              |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| other |) |),
                      "move_binary_format::file_format::FunctionDefinitionIndex",
                      0
                    |)
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Ord"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("cmp", InstanceField.Method cmp) ].
  End Impl_core_cmp_Ord_for_move_binary_format_file_format_FunctionDefinitionIndex.
  
  Module Impl_core_marker_StructuralPartialEq_for_move_binary_format_file_format_FunctionDefinitionIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::FunctionDefinitionIndex".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_move_binary_format_file_format_FunctionDefinitionIndex.
  
  Module Impl_core_cmp_PartialEq_move_binary_format_file_format_FunctionDefinitionIndex_for_move_binary_format_file_format_FunctionDefinitionIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::FunctionDefinitionIndex".
    
    (*         PartialEq *)
    Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.path "bool",
            BinOp.eq,
            [
              M.read (|
                M.SubPointer.get_struct_tuple_field (|
                  M.deref (| M.read (| self |) |),
                  "move_binary_format::file_format::FunctionDefinitionIndex",
                  0
                |)
              |);
              M.read (|
                M.SubPointer.get_struct_tuple_field (|
                  M.deref (| M.read (| other |) |),
                  "move_binary_format::file_format::FunctionDefinitionIndex",
                  0
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.path "move_binary_format::file_format::FunctionDefinitionIndex" ]
        Self
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_move_binary_format_file_format_FunctionDefinitionIndex_for_move_binary_format_file_format_FunctionDefinitionIndex.
  
  Module Impl_core_cmp_PartialOrd_move_binary_format_file_format_FunctionDefinitionIndex_for_move_binary_format_file_format_FunctionDefinitionIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::FunctionDefinitionIndex".
    
    (*         PartialOrd *)
    Definition partial_cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "core::cmp::Ordering" ],
            M.get_trait_method (|
              "core::cmp::PartialOrd",
              Ty.path "u16",
              [],
              [ Ty.path "u16" ],
              "partial_cmp",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| self |) |),
                      "move_binary_format::file_format::FunctionDefinitionIndex",
                      0
                    |)
                  |)
                |)
              |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| other |) |),
                      "move_binary_format::file_format::FunctionDefinitionIndex",
                      0
                    |)
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialOrd"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.path "move_binary_format::file_format::FunctionDefinitionIndex" ]
        Self
        (* Instance *) [ ("partial_cmp", InstanceField.Method partial_cmp) ].
  End Impl_core_cmp_PartialOrd_move_binary_format_file_format_FunctionDefinitionIndex_for_move_binary_format_file_format_FunctionDefinitionIndex.
  
  Module Impl_move_binary_format_file_format_FunctionDefinitionIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::FunctionDefinitionIndex".
    
    (*
                pub fn new(idx: TableIndex) -> Self {
                    Self(idx)
                }
    *)
    Definition new (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ idx ] =>
        ltac:(M.monadic
          (let idx := M.alloc (| idx |) in
          Value.StructTuple
            "move_binary_format::file_format::FunctionDefinitionIndex"
            []
            []
            [ M.read (| idx |) ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_new : M.IsAssociatedFunction.C Self "new" new.
    Admitted.
    Global Typeclasses Opaque new.
  End Impl_move_binary_format_file_format_FunctionDefinitionIndex.
  
  Module Impl_core_fmt_Display_for_move_binary_format_file_format_FunctionDefinitionIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::FunctionDefinitionIndex".
    
    (*
                fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "{}", self.0)
                }
    *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_fmt", [], [] |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
              M.call_closure (|
                Ty.path "core::fmt::Arguments",
                M.get_associated_function (|
                  Ty.path "core::fmt::Arguments",
                  "new_v1",
                  [ Value.Integer IntegerKind.Usize 1; Value.Integer IntegerKind.Usize 1 ],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (| Pointer.Kind.Ref, M.alloc (| Value.Array [ mk_str (| "" |) ] |) |)
                    |)
                  |);
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          Value.Array
                            [
                              M.call_closure (|
                                Ty.path "core::fmt::rt::Argument",
                                M.get_associated_function (|
                                  Ty.path "core::fmt::rt::Argument",
                                  "new_display",
                                  [],
                                  [ Ty.path "u16" ]
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.SubPointer.get_struct_tuple_field (|
                                          M.deref (| M.read (| self |) |),
                                          "move_binary_format::file_format::FunctionDefinitionIndex",
                                          0
                                        |)
                                      |)
                                    |)
                                  |)
                                ]
                              |)
                            ]
                        |)
                      |)
                    |)
                  |)
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Display"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Display_for_move_binary_format_file_format_FunctionDefinitionIndex.
  
  Module Impl_core_fmt_Debug_for_move_binary_format_file_format_FunctionDefinitionIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::FunctionDefinitionIndex".
    
    (*
                fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
                    write!(f, "{}({})", stringify!($name), self.0)
                }
    *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_fmt", [], [] |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
              M.call_closure (|
                Ty.path "core::fmt::Arguments",
                M.get_associated_function (|
                  Ty.path "core::fmt::Arguments",
                  "new_v1",
                  [ Value.Integer IntegerKind.Usize 2; Value.Integer IntegerKind.Usize 1 ],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          Value.Array [ mk_str (| "FunctionDefinitionIndex(" |); mk_str (| ")" |) ]
                        |)
                      |)
                    |)
                  |);
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          Value.Array
                            [
                              M.call_closure (|
                                Ty.path "core::fmt::rt::Argument",
                                M.get_associated_function (|
                                  Ty.path "core::fmt::rt::Argument",
                                  "new_display",
                                  [],
                                  [ Ty.path "u16" ]
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.SubPointer.get_struct_tuple_field (|
                                          M.deref (| M.read (| self |) |),
                                          "move_binary_format::file_format::FunctionDefinitionIndex",
                                          0
                                        |)
                                      |)
                                    |)
                                  |)
                                ]
                              |)
                            ]
                        |)
                      |)
                    |)
                  |)
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_move_binary_format_file_format_FunctionDefinitionIndex.
  
  Module Impl_move_binary_format_internals_ModuleIndex_for_move_binary_format_file_format_FunctionDefinitionIndex.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::FunctionDefinitionIndex".
    
    (*             const KIND: IndexKind = IndexKind::$kind; *)
    (* Ty.path "move_binary_format::IndexKind" *)
    Definition value_KIND (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      ltac:(M.monadic
        (M.alloc (|
          Value.StructTuple "move_binary_format::IndexKind::FunctionDefinition" [] [] []
        |))).
    
    (*
                fn into_index(self) -> usize {
                    self.0 as usize
                }
    *)
    Definition into_index (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.cast
            (Ty.path "usize")
            (M.read (|
              M.SubPointer.get_struct_tuple_field (|
                self,
                "move_binary_format::file_format::FunctionDefinitionIndex",
                0
              |)
            |))))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "move_binary_format::internals::ModuleIndex"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *)
        [
          ("value_KIND", InstanceField.Method value_KIND);
          ("into_index", InstanceField.Method into_index)
        ].
  End Impl_move_binary_format_internals_ModuleIndex_for_move_binary_format_file_format_FunctionDefinitionIndex.
  
  Axiom LocalIndex : (Ty.path "move_binary_format::file_format::LocalIndex") = (Ty.path "u8").
  
  Axiom MemberCount : (Ty.path "move_binary_format::file_format::MemberCount") = (Ty.path "u16").
  
  Axiom CodeOffset : (Ty.path "move_binary_format::file_format::CodeOffset") = (Ty.path "u16").
  
  Axiom IdentifierPool :
    (Ty.path "move_binary_format::file_format::IdentifierPool") =
      (Ty.apply
        (Ty.path "alloc::vec::Vec")
        []
        [ Ty.path "move_core_types::identifier::Identifier"; Ty.path "alloc::alloc::Global" ]).
  
  Axiom AddressIdentifierPool :
    (Ty.path "move_binary_format::file_format::AddressIdentifierPool") =
      (Ty.apply
        (Ty.path "alloc::vec::Vec")
        []
        [ Ty.path "move_core_types::account_address::AccountAddress"; Ty.path "alloc::alloc::Global"
        ]).
  
  Axiom ConstantPool :
    (Ty.path "move_binary_format::file_format::ConstantPool") =
      (Ty.apply
        (Ty.path "alloc::vec::Vec")
        []
        [ Ty.path "move_binary_format::file_format::Constant"; Ty.path "alloc::alloc::Global" ]).
  
  Axiom TypeSignaturePool :
    (Ty.path "move_binary_format::file_format::TypeSignaturePool") =
      (Ty.apply
        (Ty.path "alloc::vec::Vec")
        []
        [ Ty.path "move_binary_format::file_format::TypeSignature"; Ty.path "alloc::alloc::Global"
        ]).
  
  Axiom SignaturePool :
    (Ty.path "move_binary_format::file_format::SignaturePool") =
      (Ty.apply
        (Ty.path "alloc::vec::Vec")
        []
        [ Ty.path "move_binary_format::file_format::Signature"; Ty.path "alloc::alloc::Global" ]).
  
  (*
  pub fn self_module_name() -> &'static IdentStr {
      IdentStr::ref_cast("<SELF>")
  }
  *)
  Definition self_module_name (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [] =>
      ltac:(M.monadic
        (M.borrow (|
          Pointer.Kind.Ref,
          M.deref (|
            M.call_closure (|
              Ty.apply (Ty.path "&") [] [ Ty.path "move_core_types::identifier::IdentStr" ],
              M.get_trait_method (|
                "ref_cast::RefCast",
                Ty.path "move_core_types::identifier::IdentStr",
                [],
                [],
                "ref_cast",
                [],
                []
              |),
              [ M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "<SELF>" |) |) |) ]
            |)
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_self_module_name :
    M.IsFunction.C "move_binary_format::file_format::self_module_name" self_module_name.
  Admitted.
  Global Typeclasses Opaque self_module_name.
  
  Definition value_NO_TYPE_ARGUMENTS (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    ltac:(M.monadic
      (M.alloc (|
        Value.StructTuple
          "move_binary_format::file_format::SignatureIndex"
          []
          []
          [ Value.Integer IntegerKind.U16 0 ]
      |))).
  
  Global Instance Instance_IsConstant_value_NO_TYPE_ARGUMENTS :
    M.IsFunction.C "move_binary_format::file_format::NO_TYPE_ARGUMENTS" value_NO_TYPE_ARGUMENTS.
  Admitted.
  Global Typeclasses Opaque value_NO_TYPE_ARGUMENTS.
  
  (* StructRecord
    {
      name := "ModuleHandle";
      const_params := [];
      ty_params := [];
      fields :=
        [
          ("address", Ty.path "move_binary_format::file_format::AddressIdentifierIndex");
          ("name", Ty.path "move_binary_format::file_format::IdentifierIndex")
        ];
    } *)
  
  Module Impl_core_clone_Clone_for_move_binary_format_file_format_ModuleHandle.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::ModuleHandle".
    
    (* Clone *)
    Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.StructRecord
            "move_binary_format::file_format::ModuleHandle"
            []
            []
            [
              ("address",
                M.call_closure (|
                  Ty.path "move_binary_format::file_format::AddressIdentifierIndex",
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.path "move_binary_format::file_format::AddressIdentifierIndex",
                    [],
                    [],
                    "clone",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "move_binary_format::file_format::ModuleHandle",
                            "address"
                          |)
                        |)
                      |)
                    |)
                  ]
                |));
              ("name",
                M.call_closure (|
                  Ty.path "move_binary_format::file_format::IdentifierIndex",
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.path "move_binary_format::file_format::IdentifierIndex",
                    [],
                    [],
                    "clone",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "move_binary_format::file_format::ModuleHandle",
                            "name"
                          |)
                        |)
                      |)
                    |)
                  ]
                |))
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_move_binary_format_file_format_ModuleHandle.
  
  Module Impl_core_fmt_Debug_for_move_binary_format_file_format_ModuleHandle.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::ModuleHandle".
    
    (* Debug *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_associated_function (|
              Ty.path "core::fmt::Formatter",
              "debug_struct_field2_finish",
              [],
              []
            |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "ModuleHandle" |) |) |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "address" |) |) |);
              (* Unsize *)
              M.pointer_coercion
                (M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "move_binary_format::file_format::ModuleHandle",
                        "address"
                      |)
                    |)
                  |)
                |));
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "name" |) |) |);
              (* Unsize *)
              M.pointer_coercion
                (M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.alloc (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "move_binary_format::file_format::ModuleHandle",
                            "name"
                          |)
                        |)
                      |)
                    |)
                  |)
                |))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_move_binary_format_file_format_ModuleHandle.
  
  Module Impl_core_cmp_Eq_for_move_binary_format_file_format_ModuleHandle.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::ModuleHandle".
    
    (* Eq *)
    Definition assert_receiver_is_total_eq
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              Value.DeclaredButUndefined,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                      Value.DeclaredButUndefined,
                      [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_move_binary_format_file_format_ModuleHandle.
  
  Module Impl_core_hash_Hash_for_move_binary_format_file_format_ModuleHandle.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::ModuleHandle".
    
    (* Hash *)
    Definition hash (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ __H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let state := M.alloc (| state |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.call_closure (|
                Ty.tuple [],
                M.get_trait_method (|
                  "core::hash::Hash",
                  Ty.path "move_binary_format::file_format::AddressIdentifierIndex",
                  [],
                  [],
                  "hash",
                  [],
                  [ __H ]
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "move_binary_format::file_format::ModuleHandle",
                          "address"
                        |)
                      |)
                    |)
                  |);
                  M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                ]
              |) in
            M.alloc (|
              M.call_closure (|
                Ty.tuple [],
                M.get_trait_method (|
                  "core::hash::Hash",
                  Ty.path "move_binary_format::file_format::IdentifierIndex",
                  [],
                  [],
                  "hash",
                  [],
                  [ __H ]
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "move_binary_format::file_format::ModuleHandle",
                          "name"
                        |)
                      |)
                    |)
                  |);
                  M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::hash::Hash"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("hash", InstanceField.Method hash) ].
  End Impl_core_hash_Hash_for_move_binary_format_file_format_ModuleHandle.
  
  Module Impl_core_marker_StructuralPartialEq_for_move_binary_format_file_format_ModuleHandle.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::ModuleHandle".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_move_binary_format_file_format_ModuleHandle.
  
  Module Impl_core_cmp_PartialEq_move_binary_format_file_format_ModuleHandle_for_move_binary_format_file_format_ModuleHandle.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::ModuleHandle".
    
    (* PartialEq *)
    Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          LogicalOp.and (|
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (|
                "core::cmp::PartialEq",
                Ty.path "move_binary_format::file_format::AddressIdentifierIndex",
                [],
                [ Ty.path "move_binary_format::file_format::AddressIdentifierIndex" ],
                "eq",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "move_binary_format::file_format::ModuleHandle",
                    "address"
                  |)
                |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| other |) |),
                    "move_binary_format::file_format::ModuleHandle",
                    "address"
                  |)
                |)
              ]
            |),
            ltac:(M.monadic
              (M.call_closure (|
                Ty.path "bool",
                M.get_trait_method (|
                  "core::cmp::PartialEq",
                  Ty.path "move_binary_format::file_format::IdentifierIndex",
                  [],
                  [ Ty.path "move_binary_format::file_format::IdentifierIndex" ],
                  "eq",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "move_binary_format::file_format::ModuleHandle",
                      "name"
                    |)
                  |);
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| other |) |),
                      "move_binary_format::file_format::ModuleHandle",
                      "name"
                    |)
                  |)
                ]
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "move_binary_format::file_format::ModuleHandle" ]
        Self
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_move_binary_format_file_format_ModuleHandle_for_move_binary_format_file_format_ModuleHandle.
  
  Module Impl_core_cmp_PartialOrd_move_binary_format_file_format_ModuleHandle_for_move_binary_format_file_format_ModuleHandle.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::ModuleHandle".
    
    (* PartialOrd *)
    Definition partial_cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            M.match_operator (|
              Ty.apply
                (Ty.path "*")
                []
                [ Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "core::cmp::Ordering" ] ],
              M.alloc (|
                M.call_closure (|
                  Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "core::cmp::Ordering" ],
                  M.get_trait_method (|
                    "core::cmp::PartialOrd",
                    Ty.path "move_binary_format::file_format::AddressIdentifierIndex",
                    [],
                    [ Ty.path "move_binary_format::file_format::AddressIdentifierIndex" ],
                    "partial_cmp",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "move_binary_format::file_format::ModuleHandle",
                            "address"
                          |)
                        |)
                      |)
                    |);
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| other |) |),
                            "move_binary_format::file_format::ModuleHandle",
                            "address"
                          |)
                        |)
                      |)
                    |)
                  ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let _ := M.is_struct_tuple (| γ0_0, "core::cmp::Ordering::Equal" |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::option::Option")
                          []
                          [ Ty.path "core::cmp::Ordering" ],
                        M.get_trait_method (|
                          "core::cmp::PartialOrd",
                          Ty.path "move_binary_format::file_format::IdentifierIndex",
                          [],
                          [ Ty.path "move_binary_format::file_format::IdentifierIndex" ],
                          "partial_cmp",
                          [],
                          []
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (|
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "move_binary_format::file_format::ModuleHandle",
                                  "name"
                                |)
                              |)
                            |)
                          |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (|
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| other |) |),
                                  "move_binary_format::file_format::ModuleHandle",
                                  "name"
                                |)
                              |)
                            |)
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let cmp := M.copy (| γ |) in
                    cmp))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialOrd"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "move_binary_format::file_format::ModuleHandle" ]
        Self
        (* Instance *) [ ("partial_cmp", InstanceField.Method partial_cmp) ].
  End Impl_core_cmp_PartialOrd_move_binary_format_file_format_ModuleHandle_for_move_binary_format_file_format_ModuleHandle.
  
  Module Impl_core_cmp_Ord_for_move_binary_format_file_format_ModuleHandle.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::ModuleHandle".
    
    (* Ord *)
    Definition cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.path "core::cmp::Ordering" ],
              M.alloc (|
                M.call_closure (|
                  Ty.path "core::cmp::Ordering",
                  M.get_trait_method (|
                    "core::cmp::Ord",
                    Ty.path "move_binary_format::file_format::AddressIdentifierIndex",
                    [],
                    [],
                    "cmp",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "move_binary_format::file_format::ModuleHandle",
                            "address"
                          |)
                        |)
                      |)
                    |);
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| other |) |),
                            "move_binary_format::file_format::ModuleHandle",
                            "address"
                          |)
                        |)
                      |)
                    |)
                  ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_struct_tuple (| γ, "core::cmp::Ordering::Equal" |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.path "core::cmp::Ordering",
                        M.get_trait_method (|
                          "core::cmp::Ord",
                          Ty.path "move_binary_format::file_format::IdentifierIndex",
                          [],
                          [],
                          "cmp",
                          [],
                          []
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (|
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "move_binary_format::file_format::ModuleHandle",
                                  "name"
                                |)
                              |)
                            |)
                          |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (|
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| other |) |),
                                  "move_binary_format::file_format::ModuleHandle",
                                  "name"
                                |)
                              |)
                            |)
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let cmp := M.copy (| γ |) in
                    cmp))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Ord"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("cmp", InstanceField.Method cmp) ].
  End Impl_core_cmp_Ord_for_move_binary_format_file_format_ModuleHandle.
  
  (* StructRecord
    {
      name := "StructHandle";
      const_params := [];
      ty_params := [];
      fields :=
        [
          ("module", Ty.path "move_binary_format::file_format::ModuleHandleIndex");
          ("name", Ty.path "move_binary_format::file_format::IdentifierIndex");
          ("abilities", Ty.path "move_binary_format::file_format::AbilitySet");
          ("type_parameters",
            Ty.apply
              (Ty.path "alloc::vec::Vec")
              []
              [
                Ty.path "move_binary_format::file_format::StructTypeParameter";
                Ty.path "alloc::alloc::Global"
              ])
        ];
    } *)
  
  Module Impl_core_clone_Clone_for_move_binary_format_file_format_StructHandle.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::StructHandle".
    
    (* Clone *)
    Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.StructRecord
            "move_binary_format::file_format::StructHandle"
            []
            []
            [
              ("module",
                M.call_closure (|
                  Ty.path "move_binary_format::file_format::ModuleHandleIndex",
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.path "move_binary_format::file_format::ModuleHandleIndex",
                    [],
                    [],
                    "clone",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "move_binary_format::file_format::StructHandle",
                            "module"
                          |)
                        |)
                      |)
                    |)
                  ]
                |));
              ("name",
                M.call_closure (|
                  Ty.path "move_binary_format::file_format::IdentifierIndex",
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.path "move_binary_format::file_format::IdentifierIndex",
                    [],
                    [],
                    "clone",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "move_binary_format::file_format::StructHandle",
                            "name"
                          |)
                        |)
                      |)
                    |)
                  ]
                |));
              ("abilities",
                M.call_closure (|
                  Ty.path "move_binary_format::file_format::AbilitySet",
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.path "move_binary_format::file_format::AbilitySet",
                    [],
                    [],
                    "clone",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "move_binary_format::file_format::StructHandle",
                            "abilities"
                          |)
                        |)
                      |)
                    |)
                  ]
                |));
              ("type_parameters",
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [
                      Ty.path "move_binary_format::file_format::StructTypeParameter";
                      Ty.path "alloc::alloc::Global"
                    ],
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      []
                      [
                        Ty.path "move_binary_format::file_format::StructTypeParameter";
                        Ty.path "alloc::alloc::Global"
                      ],
                    [],
                    [],
                    "clone",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "move_binary_format::file_format::StructHandle",
                            "type_parameters"
                          |)
                        |)
                      |)
                    |)
                  ]
                |))
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_move_binary_format_file_format_StructHandle.
  
  Module Impl_core_fmt_Debug_for_move_binary_format_file_format_StructHandle.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::StructHandle".
    
    (* Debug *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_associated_function (|
              Ty.path "core::fmt::Formatter",
              "debug_struct_field4_finish",
              [],
              []
            |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "StructHandle" |) |) |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "module" |) |) |);
              (* Unsize *)
              M.pointer_coercion
                (M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "move_binary_format::file_format::StructHandle",
                        "module"
                      |)
                    |)
                  |)
                |));
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "name" |) |) |);
              (* Unsize *)
              M.pointer_coercion
                (M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "move_binary_format::file_format::StructHandle",
                        "name"
                      |)
                    |)
                  |)
                |));
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "abilities" |) |) |);
              (* Unsize *)
              M.pointer_coercion
                (M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "move_binary_format::file_format::StructHandle",
                        "abilities"
                      |)
                    |)
                  |)
                |));
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "type_parameters" |) |) |);
              (* Unsize *)
              M.pointer_coercion
                (M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.alloc (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "move_binary_format::file_format::StructHandle",
                            "type_parameters"
                          |)
                        |)
                      |)
                    |)
                  |)
                |))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_move_binary_format_file_format_StructHandle.
  
  Module Impl_core_cmp_Eq_for_move_binary_format_file_format_StructHandle.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::StructHandle".
    
    (* Eq *)
    Definition assert_receiver_is_total_eq
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              Value.DeclaredButUndefined,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                      Value.DeclaredButUndefined,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                              Value.DeclaredButUndefined,
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (M.match_operator (|
                                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                      Value.DeclaredButUndefined,
                                      [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                                    |)))
                              ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_move_binary_format_file_format_StructHandle.
  
  Module Impl_core_hash_Hash_for_move_binary_format_file_format_StructHandle.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::StructHandle".
    
    (* Hash *)
    Definition hash (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ __H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let state := M.alloc (| state |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.call_closure (|
                Ty.tuple [],
                M.get_trait_method (|
                  "core::hash::Hash",
                  Ty.path "move_binary_format::file_format::ModuleHandleIndex",
                  [],
                  [],
                  "hash",
                  [],
                  [ __H ]
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "move_binary_format::file_format::StructHandle",
                          "module"
                        |)
                      |)
                    |)
                  |);
                  M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                ]
              |) in
            let~ _ : Ty.tuple [] :=
              M.call_closure (|
                Ty.tuple [],
                M.get_trait_method (|
                  "core::hash::Hash",
                  Ty.path "move_binary_format::file_format::IdentifierIndex",
                  [],
                  [],
                  "hash",
                  [],
                  [ __H ]
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "move_binary_format::file_format::StructHandle",
                          "name"
                        |)
                      |)
                    |)
                  |);
                  M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                ]
              |) in
            let~ _ : Ty.tuple [] :=
              M.call_closure (|
                Ty.tuple [],
                M.get_trait_method (|
                  "core::hash::Hash",
                  Ty.path "move_binary_format::file_format::AbilitySet",
                  [],
                  [],
                  "hash",
                  [],
                  [ __H ]
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "move_binary_format::file_format::StructHandle",
                          "abilities"
                        |)
                      |)
                    |)
                  |);
                  M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                ]
              |) in
            M.alloc (|
              M.call_closure (|
                Ty.tuple [],
                M.get_trait_method (|
                  "core::hash::Hash",
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [
                      Ty.path "move_binary_format::file_format::StructTypeParameter";
                      Ty.path "alloc::alloc::Global"
                    ],
                  [],
                  [],
                  "hash",
                  [],
                  [ __H ]
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "move_binary_format::file_format::StructHandle",
                          "type_parameters"
                        |)
                      |)
                    |)
                  |);
                  M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::hash::Hash"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("hash", InstanceField.Method hash) ].
  End Impl_core_hash_Hash_for_move_binary_format_file_format_StructHandle.
  
  Module Impl_core_marker_StructuralPartialEq_for_move_binary_format_file_format_StructHandle.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::StructHandle".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_move_binary_format_file_format_StructHandle.
  
  Module Impl_core_cmp_PartialEq_move_binary_format_file_format_StructHandle_for_move_binary_format_file_format_StructHandle.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::StructHandle".
    
    (* PartialEq *)
    Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          LogicalOp.and (|
            LogicalOp.and (|
              LogicalOp.and (|
                M.call_closure (|
                  Ty.path "bool",
                  M.get_trait_method (|
                    "core::cmp::PartialEq",
                    Ty.path "move_binary_format::file_format::ModuleHandleIndex",
                    [],
                    [ Ty.path "move_binary_format::file_format::ModuleHandleIndex" ],
                    "eq",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "move_binary_format::file_format::StructHandle",
                        "module"
                      |)
                    |);
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| other |) |),
                        "move_binary_format::file_format::StructHandle",
                        "module"
                      |)
                    |)
                  ]
                |),
                ltac:(M.monadic
                  (M.call_closure (|
                    Ty.path "bool",
                    M.get_trait_method (|
                      "core::cmp::PartialEq",
                      Ty.path "move_binary_format::file_format::IdentifierIndex",
                      [],
                      [ Ty.path "move_binary_format::file_format::IdentifierIndex" ],
                      "eq",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "move_binary_format::file_format::StructHandle",
                          "name"
                        |)
                      |);
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| other |) |),
                          "move_binary_format::file_format::StructHandle",
                          "name"
                        |)
                      |)
                    ]
                  |)))
              |),
              ltac:(M.monadic
                (M.call_closure (|
                  Ty.path "bool",
                  M.get_trait_method (|
                    "core::cmp::PartialEq",
                    Ty.path "move_binary_format::file_format::AbilitySet",
                    [],
                    [ Ty.path "move_binary_format::file_format::AbilitySet" ],
                    "eq",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "move_binary_format::file_format::StructHandle",
                        "abilities"
                      |)
                    |);
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| other |) |),
                        "move_binary_format::file_format::StructHandle",
                        "abilities"
                      |)
                    |)
                  ]
                |)))
            |),
            ltac:(M.monadic
              (M.call_closure (|
                Ty.path "bool",
                M.get_trait_method (|
                  "core::cmp::PartialEq",
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [
                      Ty.path "move_binary_format::file_format::StructTypeParameter";
                      Ty.path "alloc::alloc::Global"
                    ],
                  [],
                  [
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      []
                      [
                        Ty.path "move_binary_format::file_format::StructTypeParameter";
                        Ty.path "alloc::alloc::Global"
                      ]
                  ],
                  "eq",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "move_binary_format::file_format::StructHandle",
                      "type_parameters"
                    |)
                  |);
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| other |) |),
                      "move_binary_format::file_format::StructHandle",
                      "type_parameters"
                    |)
                  |)
                ]
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "move_binary_format::file_format::StructHandle" ]
        Self
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_move_binary_format_file_format_StructHandle_for_move_binary_format_file_format_StructHandle.
  
  Module Impl_core_cmp_PartialOrd_move_binary_format_file_format_StructHandle_for_move_binary_format_file_format_StructHandle.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::StructHandle".
    
    (* PartialOrd *)
    Definition partial_cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            M.match_operator (|
              Ty.apply
                (Ty.path "*")
                []
                [ Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "core::cmp::Ordering" ] ],
              M.alloc (|
                M.call_closure (|
                  Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "core::cmp::Ordering" ],
                  M.get_trait_method (|
                    "core::cmp::PartialOrd",
                    Ty.path "move_binary_format::file_format::ModuleHandleIndex",
                    [],
                    [ Ty.path "move_binary_format::file_format::ModuleHandleIndex" ],
                    "partial_cmp",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "move_binary_format::file_format::StructHandle",
                            "module"
                          |)
                        |)
                      |)
                    |);
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| other |) |),
                            "move_binary_format::file_format::StructHandle",
                            "module"
                          |)
                        |)
                      |)
                    |)
                  ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let _ := M.is_struct_tuple (| γ0_0, "core::cmp::Ordering::Equal" |) in
                    M.match_operator (|
                      Ty.apply
                        (Ty.path "*")
                        []
                        [
                          Ty.apply
                            (Ty.path "core::option::Option")
                            []
                            [ Ty.path "core::cmp::Ordering" ]
                        ],
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::option::Option")
                            []
                            [ Ty.path "core::cmp::Ordering" ],
                          M.get_trait_method (|
                            "core::cmp::PartialOrd",
                            Ty.path "move_binary_format::file_format::IdentifierIndex",
                            [],
                            [ Ty.path "move_binary_format::file_format::IdentifierIndex" ],
                            "partial_cmp",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "move_binary_format::file_format::StructHandle",
                                    "name"
                                  |)
                                |)
                              |)
                            |);
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| other |) |),
                                    "move_binary_format::file_format::StructHandle",
                                    "name"
                                  |)
                                |)
                              |)
                            |)
                          ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::option::Option::Some",
                                0
                              |) in
                            let _ := M.is_struct_tuple (| γ0_0, "core::cmp::Ordering::Equal" |) in
                            M.match_operator (|
                              Ty.apply
                                (Ty.path "*")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "core::option::Option")
                                    []
                                    [ Ty.path "core::cmp::Ordering" ]
                                ],
                              M.alloc (|
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "core::option::Option")
                                    []
                                    [ Ty.path "core::cmp::Ordering" ],
                                  M.get_trait_method (|
                                    "core::cmp::PartialOrd",
                                    Ty.path "move_binary_format::file_format::AbilitySet",
                                    [],
                                    [ Ty.path "move_binary_format::file_format::AbilitySet" ],
                                    "partial_cmp",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (|
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.SubPointer.get_struct_record_field (|
                                            M.deref (| M.read (| self |) |),
                                            "move_binary_format::file_format::StructHandle",
                                            "abilities"
                                          |)
                                        |)
                                      |)
                                    |);
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (|
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.SubPointer.get_struct_record_field (|
                                            M.deref (| M.read (| other |) |),
                                            "move_binary_format::file_format::StructHandle",
                                            "abilities"
                                          |)
                                        |)
                                      |)
                                    |)
                                  ]
                                |)
                              |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ0_0 :=
                                      M.SubPointer.get_struct_tuple_field (|
                                        γ,
                                        "core::option::Option::Some",
                                        0
                                      |) in
                                    let _ :=
                                      M.is_struct_tuple (| γ0_0, "core::cmp::Ordering::Equal" |) in
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "core::option::Option")
                                          []
                                          [ Ty.path "core::cmp::Ordering" ],
                                        M.get_trait_method (|
                                          "core::cmp::PartialOrd",
                                          Ty.apply
                                            (Ty.path "alloc::vec::Vec")
                                            []
                                            [
                                              Ty.path
                                                "move_binary_format::file_format::StructTypeParameter";
                                              Ty.path "alloc::alloc::Global"
                                            ],
                                          [],
                                          [
                                            Ty.apply
                                              (Ty.path "alloc::vec::Vec")
                                              []
                                              [
                                                Ty.path
                                                  "move_binary_format::file_format::StructTypeParameter";
                                                Ty.path "alloc::alloc::Global"
                                              ]
                                          ],
                                          "partial_cmp",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (|
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.SubPointer.get_struct_record_field (|
                                                  M.deref (| M.read (| self |) |),
                                                  "move_binary_format::file_format::StructHandle",
                                                  "type_parameters"
                                                |)
                                              |)
                                            |)
                                          |);
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (|
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.SubPointer.get_struct_record_field (|
                                                  M.deref (| M.read (| other |) |),
                                                  "move_binary_format::file_format::StructHandle",
                                                  "type_parameters"
                                                |)
                                              |)
                                            |)
                                          |)
                                        ]
                                      |)
                                    |)));
                                fun γ =>
                                  ltac:(M.monadic
                                    (let cmp := M.copy (| γ |) in
                                    cmp))
                              ]
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let cmp := M.copy (| γ |) in
                            cmp))
                      ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let cmp := M.copy (| γ |) in
                    cmp))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialOrd"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "move_binary_format::file_format::StructHandle" ]
        Self
        (* Instance *) [ ("partial_cmp", InstanceField.Method partial_cmp) ].
  End Impl_core_cmp_PartialOrd_move_binary_format_file_format_StructHandle_for_move_binary_format_file_format_StructHandle.
  
  Module Impl_core_cmp_Ord_for_move_binary_format_file_format_StructHandle.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::StructHandle".
    
    (* Ord *)
    Definition cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.path "core::cmp::Ordering" ],
              M.alloc (|
                M.call_closure (|
                  Ty.path "core::cmp::Ordering",
                  M.get_trait_method (|
                    "core::cmp::Ord",
                    Ty.path "move_binary_format::file_format::ModuleHandleIndex",
                    [],
                    [],
                    "cmp",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "move_binary_format::file_format::StructHandle",
                            "module"
                          |)
                        |)
                      |)
                    |);
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| other |) |),
                            "move_binary_format::file_format::StructHandle",
                            "module"
                          |)
                        |)
                      |)
                    |)
                  ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_struct_tuple (| γ, "core::cmp::Ordering::Equal" |) in
                    M.match_operator (|
                      Ty.apply (Ty.path "*") [] [ Ty.path "core::cmp::Ordering" ],
                      M.alloc (|
                        M.call_closure (|
                          Ty.path "core::cmp::Ordering",
                          M.get_trait_method (|
                            "core::cmp::Ord",
                            Ty.path "move_binary_format::file_format::IdentifierIndex",
                            [],
                            [],
                            "cmp",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "move_binary_format::file_format::StructHandle",
                                    "name"
                                  |)
                                |)
                              |)
                            |);
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| other |) |),
                                    "move_binary_format::file_format::StructHandle",
                                    "name"
                                  |)
                                |)
                              |)
                            |)
                          ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let _ := M.is_struct_tuple (| γ, "core::cmp::Ordering::Equal" |) in
                            M.match_operator (|
                              Ty.apply (Ty.path "*") [] [ Ty.path "core::cmp::Ordering" ],
                              M.alloc (|
                                M.call_closure (|
                                  Ty.path "core::cmp::Ordering",
                                  M.get_trait_method (|
                                    "core::cmp::Ord",
                                    Ty.path "move_binary_format::file_format::AbilitySet",
                                    [],
                                    [],
                                    "cmp",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (|
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.SubPointer.get_struct_record_field (|
                                            M.deref (| M.read (| self |) |),
                                            "move_binary_format::file_format::StructHandle",
                                            "abilities"
                                          |)
                                        |)
                                      |)
                                    |);
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (|
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.SubPointer.get_struct_record_field (|
                                            M.deref (| M.read (| other |) |),
                                            "move_binary_format::file_format::StructHandle",
                                            "abilities"
                                          |)
                                        |)
                                      |)
                                    |)
                                  ]
                                |)
                              |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let _ :=
                                      M.is_struct_tuple (| γ, "core::cmp::Ordering::Equal" |) in
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.path "core::cmp::Ordering",
                                        M.get_trait_method (|
                                          "core::cmp::Ord",
                                          Ty.apply
                                            (Ty.path "alloc::vec::Vec")
                                            []
                                            [
                                              Ty.path
                                                "move_binary_format::file_format::StructTypeParameter";
                                              Ty.path "alloc::alloc::Global"
                                            ],
                                          [],
                                          [],
                                          "cmp",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (|
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.SubPointer.get_struct_record_field (|
                                                  M.deref (| M.read (| self |) |),
                                                  "move_binary_format::file_format::StructHandle",
                                                  "type_parameters"
                                                |)
                                              |)
                                            |)
                                          |);
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (|
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.SubPointer.get_struct_record_field (|
                                                  M.deref (| M.read (| other |) |),
                                                  "move_binary_format::file_format::StructHandle",
                                                  "type_parameters"
                                                |)
                                              |)
                                            |)
                                          |)
                                        ]
                                      |)
                                    |)));
                                fun γ =>
                                  ltac:(M.monadic
                                    (let cmp := M.copy (| γ |) in
                                    cmp))
                              ]
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let cmp := M.copy (| γ |) in
                            cmp))
                      ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let cmp := M.copy (| γ |) in
                    cmp))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Ord"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("cmp", InstanceField.Method cmp) ].
  End Impl_core_cmp_Ord_for_move_binary_format_file_format_StructHandle.
  
  Module Impl_move_binary_format_file_format_StructHandle.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::StructHandle".
    
    (*
        pub fn type_param_constraints(&self) -> impl ExactSizeIterator<Item = AbilitySet> + '_ {
            self.type_parameters.iter().map(|param| param.constraints)
        }
    *)
    Definition type_param_constraints (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::iter::adapters::map::Map")
              []
              [
                Ty.apply
                  (Ty.path "core::slice::iter::Iter")
                  []
                  [ Ty.path "move_binary_format::file_format::StructTypeParameter" ];
                Ty.function
                  [
                    Ty.tuple
                      [
                        Ty.apply
                          (Ty.path "&")
                          []
                          [ Ty.path "move_binary_format::file_format::StructTypeParameter" ]
                      ]
                  ]
                  (Ty.path "move_binary_format::file_format::AbilitySet")
              ],
            M.get_trait_method (|
              "core::iter::traits::iterator::Iterator",
              Ty.apply
                (Ty.path "core::slice::iter::Iter")
                []
                [ Ty.path "move_binary_format::file_format::StructTypeParameter" ],
              [],
              [],
              "map",
              [],
              [
                Ty.path "move_binary_format::file_format::AbilitySet";
                Ty.function
                  [
                    Ty.tuple
                      [
                        Ty.apply
                          (Ty.path "&")
                          []
                          [ Ty.path "move_binary_format::file_format::StructTypeParameter" ]
                      ]
                  ]
                  (Ty.path "move_binary_format::file_format::AbilitySet")
              ]
            |),
            [
              M.call_closure (|
                Ty.apply
                  (Ty.path "core::slice::iter::Iter")
                  []
                  [ Ty.path "move_binary_format::file_format::StructTypeParameter" ],
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "slice")
                    []
                    [ Ty.path "move_binary_format::file_format::StructTypeParameter" ],
                  "iter",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "&")
                          []
                          [
                            Ty.apply
                              (Ty.path "slice")
                              []
                              [ Ty.path "move_binary_format::file_format::StructTypeParameter" ]
                          ],
                        M.get_trait_method (|
                          "core::ops::deref::Deref",
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            []
                            [
                              Ty.path "move_binary_format::file_format::StructTypeParameter";
                              Ty.path "alloc::alloc::Global"
                            ],
                          [],
                          [],
                          "deref",
                          [],
                          []
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "move_binary_format::file_format::StructHandle",
                              "type_parameters"
                            |)
                          |)
                        ]
                      |)
                    |)
                  |)
                ]
              |);
              M.closure
                (fun γ =>
                  ltac:(M.monadic
                    match γ with
                    | [ α0 ] =>
                      ltac:(M.monadic
                        (M.match_operator (|
                          Ty.apply
                            (Ty.path "*")
                            []
                            [
                              Ty.function
                                [
                                  Ty.tuple
                                    [
                                      Ty.apply
                                        (Ty.path "&")
                                        []
                                        [
                                          Ty.path
                                            "move_binary_format::file_format::StructTypeParameter"
                                        ]
                                    ]
                                ]
                                (Ty.path "move_binary_format::file_format::AbilitySet")
                            ],
                          M.alloc (| α0 |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let param := M.copy (| γ |) in
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| param |) |),
                                    "move_binary_format::file_format::StructTypeParameter",
                                    "constraints"
                                  |)
                                |)))
                          ]
                        |)))
                    | _ => M.impossible "wrong number of arguments"
                    end))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_type_param_constraints :
      M.IsAssociatedFunction.C Self "type_param_constraints" type_param_constraints.
    Admitted.
    Global Typeclasses Opaque type_param_constraints.
  End Impl_move_binary_format_file_format_StructHandle.
  
  (* StructRecord
    {
      name := "StructTypeParameter";
      const_params := [];
      ty_params := [];
      fields :=
        [
          ("constraints", Ty.path "move_binary_format::file_format::AbilitySet");
          ("is_phantom", Ty.path "bool")
        ];
    } *)
  
  Module Impl_core_clone_Clone_for_move_binary_format_file_format_StructTypeParameter.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::StructTypeParameter".
    
    (* Clone *)
    Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Ty.apply
                (Ty.path "*")
                []
                [ Ty.path "move_binary_format::file_format::StructTypeParameter" ],
              Value.DeclaredButUndefined,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      Ty.apply
                        (Ty.path "*")
                        []
                        [ Ty.path "move_binary_format::file_format::StructTypeParameter" ],
                      Value.DeclaredButUndefined,
                      [ fun γ => ltac:(M.monadic (M.deref (| M.read (| self |) |))) ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_move_binary_format_file_format_StructTypeParameter.
  
  Module Impl_core_marker_Copy_for_move_binary_format_file_format_StructTypeParameter.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::StructTypeParameter".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::Copy"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_Copy_for_move_binary_format_file_format_StructTypeParameter.
  
  Module Impl_core_fmt_Debug_for_move_binary_format_file_format_StructTypeParameter.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::StructTypeParameter".
    
    (* Debug *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_associated_function (|
              Ty.path "core::fmt::Formatter",
              "debug_struct_field2_finish",
              [],
              []
            |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "StructTypeParameter" |) |) |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "constraints" |) |) |);
              (* Unsize *)
              M.pointer_coercion
                (M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "move_binary_format::file_format::StructTypeParameter",
                        "constraints"
                      |)
                    |)
                  |)
                |));
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "is_phantom" |) |) |);
              (* Unsize *)
              M.pointer_coercion
                (M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.alloc (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "move_binary_format::file_format::StructTypeParameter",
                            "is_phantom"
                          |)
                        |)
                      |)
                    |)
                  |)
                |))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_move_binary_format_file_format_StructTypeParameter.
  
  Module Impl_core_cmp_Eq_for_move_binary_format_file_format_StructTypeParameter.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::StructTypeParameter".
    
    (* Eq *)
    Definition assert_receiver_is_total_eq
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              Value.DeclaredButUndefined,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                      Value.DeclaredButUndefined,
                      [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_move_binary_format_file_format_StructTypeParameter.
  
  Module Impl_core_hash_Hash_for_move_binary_format_file_format_StructTypeParameter.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::StructTypeParameter".
    
    (* Hash *)
    Definition hash (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ __H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let state := M.alloc (| state |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.call_closure (|
                Ty.tuple [],
                M.get_trait_method (|
                  "core::hash::Hash",
                  Ty.path "move_binary_format::file_format::AbilitySet",
                  [],
                  [],
                  "hash",
                  [],
                  [ __H ]
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "move_binary_format::file_format::StructTypeParameter",
                          "constraints"
                        |)
                      |)
                    |)
                  |);
                  M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                ]
              |) in
            M.alloc (|
              M.call_closure (|
                Ty.tuple [],
                M.get_trait_method (|
                  "core::hash::Hash",
                  Ty.path "bool",
                  [],
                  [],
                  "hash",
                  [],
                  [ __H ]
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "move_binary_format::file_format::StructTypeParameter",
                          "is_phantom"
                        |)
                      |)
                    |)
                  |);
                  M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::hash::Hash"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("hash", InstanceField.Method hash) ].
  End Impl_core_hash_Hash_for_move_binary_format_file_format_StructTypeParameter.
  
  Module Impl_core_marker_StructuralPartialEq_for_move_binary_format_file_format_StructTypeParameter.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::StructTypeParameter".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_move_binary_format_file_format_StructTypeParameter.
  
  Module Impl_core_cmp_PartialEq_move_binary_format_file_format_StructTypeParameter_for_move_binary_format_file_format_StructTypeParameter.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::StructTypeParameter".
    
    (* PartialEq *)
    Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          LogicalOp.and (|
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (|
                "core::cmp::PartialEq",
                Ty.path "move_binary_format::file_format::AbilitySet",
                [],
                [ Ty.path "move_binary_format::file_format::AbilitySet" ],
                "eq",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "move_binary_format::file_format::StructTypeParameter",
                    "constraints"
                  |)
                |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| other |) |),
                    "move_binary_format::file_format::StructTypeParameter",
                    "constraints"
                  |)
                |)
              ]
            |),
            ltac:(M.monadic
              (M.call_closure (|
                Ty.path "bool",
                BinOp.eq,
                [
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "move_binary_format::file_format::StructTypeParameter",
                      "is_phantom"
                    |)
                  |);
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| other |) |),
                      "move_binary_format::file_format::StructTypeParameter",
                      "is_phantom"
                    |)
                  |)
                ]
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.path "move_binary_format::file_format::StructTypeParameter" ]
        Self
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_move_binary_format_file_format_StructTypeParameter_for_move_binary_format_file_format_StructTypeParameter.
  
  Module Impl_core_cmp_PartialOrd_move_binary_format_file_format_StructTypeParameter_for_move_binary_format_file_format_StructTypeParameter.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::StructTypeParameter".
    
    (* PartialOrd *)
    Definition partial_cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            M.match_operator (|
              Ty.apply
                (Ty.path "*")
                []
                [ Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "core::cmp::Ordering" ] ],
              M.alloc (|
                M.call_closure (|
                  Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "core::cmp::Ordering" ],
                  M.get_trait_method (|
                    "core::cmp::PartialOrd",
                    Ty.path "move_binary_format::file_format::AbilitySet",
                    [],
                    [ Ty.path "move_binary_format::file_format::AbilitySet" ],
                    "partial_cmp",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "move_binary_format::file_format::StructTypeParameter",
                            "constraints"
                          |)
                        |)
                      |)
                    |);
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| other |) |),
                            "move_binary_format::file_format::StructTypeParameter",
                            "constraints"
                          |)
                        |)
                      |)
                    |)
                  ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let _ := M.is_struct_tuple (| γ0_0, "core::cmp::Ordering::Equal" |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::option::Option")
                          []
                          [ Ty.path "core::cmp::Ordering" ],
                        M.get_trait_method (|
                          "core::cmp::PartialOrd",
                          Ty.path "bool",
                          [],
                          [ Ty.path "bool" ],
                          "partial_cmp",
                          [],
                          []
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (|
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "move_binary_format::file_format::StructTypeParameter",
                                  "is_phantom"
                                |)
                              |)
                            |)
                          |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (|
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| other |) |),
                                  "move_binary_format::file_format::StructTypeParameter",
                                  "is_phantom"
                                |)
                              |)
                            |)
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let cmp := M.copy (| γ |) in
                    cmp))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialOrd"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.path "move_binary_format::file_format::StructTypeParameter" ]
        Self
        (* Instance *) [ ("partial_cmp", InstanceField.Method partial_cmp) ].
  End Impl_core_cmp_PartialOrd_move_binary_format_file_format_StructTypeParameter_for_move_binary_format_file_format_StructTypeParameter.
  
  Module Impl_core_cmp_Ord_for_move_binary_format_file_format_StructTypeParameter.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::StructTypeParameter".
    
    (* Ord *)
    Definition cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.path "core::cmp::Ordering" ],
              M.alloc (|
                M.call_closure (|
                  Ty.path "core::cmp::Ordering",
                  M.get_trait_method (|
                    "core::cmp::Ord",
                    Ty.path "move_binary_format::file_format::AbilitySet",
                    [],
                    [],
                    "cmp",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "move_binary_format::file_format::StructTypeParameter",
                            "constraints"
                          |)
                        |)
                      |)
                    |);
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| other |) |),
                            "move_binary_format::file_format::StructTypeParameter",
                            "constraints"
                          |)
                        |)
                      |)
                    |)
                  ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_struct_tuple (| γ, "core::cmp::Ordering::Equal" |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.path "core::cmp::Ordering",
                        M.get_trait_method (|
                          "core::cmp::Ord",
                          Ty.path "bool",
                          [],
                          [],
                          "cmp",
                          [],
                          []
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (|
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "move_binary_format::file_format::StructTypeParameter",
                                  "is_phantom"
                                |)
                              |)
                            |)
                          |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (|
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| other |) |),
                                  "move_binary_format::file_format::StructTypeParameter",
                                  "is_phantom"
                                |)
                              |)
                            |)
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let cmp := M.copy (| γ |) in
                    cmp))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Ord"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("cmp", InstanceField.Method cmp) ].
  End Impl_core_cmp_Ord_for_move_binary_format_file_format_StructTypeParameter.
  
  Module underscore.
    Module Impl_serde_ser_Serialize_for_move_binary_format_file_format_StructTypeParameter.
      Definition Self : Ty.t := Ty.path "move_binary_format::file_format::StructTypeParameter".
      
      (* Serialize *)
      Definition serialize (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [ __S ], [ self; __serializer ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let __serializer := M.alloc (| __serializer |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.associated_in_trait "serde::ser::Serializer" [] [] __S "Ok";
                  Ty.associated_in_trait "serde::ser::Serializer" [] [] __S "Error"
                ]) (|
              ltac:(M.monadic
                (M.read (|
                  let~ __serde_state :
                      Ty.associated_in_trait "serde::ser::Serializer" [] [] __S "SerializeStruct" :=
                    M.read (|
                      M.match_operator (|
                        Ty.apply
                          (Ty.path "*")
                          []
                          [
                            Ty.associated_in_trait
                              "serde::ser::Serializer"
                              []
                              []
                              __S
                              "SerializeStruct"
                          ],
                        M.alloc (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "core::result::Result")
                              []
                              [
                                Ty.associated_in_trait
                                  "serde::ser::Serializer"
                                  []
                                  []
                                  __S
                                  "SerializeStruct";
                                Ty.associated_in_trait "serde::ser::Serializer" [] [] __S "Error"
                              ],
                            M.get_trait_method (|
                              "serde::ser::Serializer",
                              __S,
                              [],
                              [],
                              "serialize_struct",
                              [],
                              []
                            |),
                            [
                              M.read (| __serializer |);
                              mk_str (| "StructTypeParameter" |);
                              M.call_closure (|
                                Ty.path "usize",
                                BinOp.Wrap.add,
                                [
                                  M.call_closure (|
                                    Ty.path "usize",
                                    BinOp.Wrap.add,
                                    [
                                      M.cast (Ty.path "usize") (Value.Bool false);
                                      Value.Integer IntegerKind.Usize 1
                                    ]
                                  |);
                                  Value.Integer IntegerKind.Usize 1
                                ]
                              |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::result::Result::Ok",
                                  0
                                |) in
                              let __val := M.copy (| γ0_0 |) in
                              __val));
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::result::Result::Err",
                                  0
                                |) in
                              let __err := M.copy (| γ0_0 |) in
                              M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    M.return_ (|
                                      Value.StructTuple
                                        "core::result::Result::Err"
                                        []
                                        [
                                          Ty.associated_in_trait
                                            "serde::ser::Serializer"
                                            []
                                            []
                                            __S
                                            "Ok";
                                          Ty.associated_in_trait
                                            "serde::ser::Serializer"
                                            []
                                            []
                                            __S
                                            "Error"
                                        ]
                                        [ M.read (| __err |) ]
                                    |)
                                  |)
                                |)
                              |)))
                        ]
                      |)
                    |) in
                  let~ _ : Ty.tuple [] :=
                    M.read (|
                      M.match_operator (|
                        Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                        M.alloc (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "core::result::Result")
                              []
                              [
                                Ty.tuple [];
                                Ty.associated_in_trait "serde::ser::Serializer" [] [] __S "Error"
                              ],
                            M.get_trait_method (|
                              "serde::ser::SerializeStruct",
                              Ty.associated_in_trait
                                "serde::ser::Serializer"
                                []
                                []
                                __S
                                "SerializeStruct",
                              [],
                              [],
                              "serialize_field",
                              [],
                              [ Ty.path "move_binary_format::file_format::AbilitySet" ]
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.MutRef,
                                M.deref (| M.borrow (| Pointer.Kind.MutRef, __serde_state |) |)
                              |);
                              mk_str (| "constraints" |);
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "move_binary_format::file_format::StructTypeParameter",
                                      "constraints"
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::result::Result::Ok",
                                  0
                                |) in
                              let __val := M.copy (| γ0_0 |) in
                              __val));
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::result::Result::Err",
                                  0
                                |) in
                              let __err := M.copy (| γ0_0 |) in
                              M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    M.return_ (|
                                      Value.StructTuple
                                        "core::result::Result::Err"
                                        []
                                        [
                                          Ty.associated_in_trait
                                            "serde::ser::Serializer"
                                            []
                                            []
                                            __S
                                            "Ok";
                                          Ty.associated_in_trait
                                            "serde::ser::Serializer"
                                            []
                                            []
                                            __S
                                            "Error"
                                        ]
                                        [ M.read (| __err |) ]
                                    |)
                                  |)
                                |)
                              |)))
                        ]
                      |)
                    |) in
                  let~ _ : Ty.tuple [] :=
                    M.read (|
                      M.match_operator (|
                        Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                        M.alloc (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "core::result::Result")
                              []
                              [
                                Ty.tuple [];
                                Ty.associated_in_trait "serde::ser::Serializer" [] [] __S "Error"
                              ],
                            M.get_trait_method (|
                              "serde::ser::SerializeStruct",
                              Ty.associated_in_trait
                                "serde::ser::Serializer"
                                []
                                []
                                __S
                                "SerializeStruct",
                              [],
                              [],
                              "serialize_field",
                              [],
                              [ Ty.path "bool" ]
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.MutRef,
                                M.deref (| M.borrow (| Pointer.Kind.MutRef, __serde_state |) |)
                              |);
                              mk_str (| "is_phantom" |);
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "move_binary_format::file_format::StructTypeParameter",
                                      "is_phantom"
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::result::Result::Ok",
                                  0
                                |) in
                              let __val := M.copy (| γ0_0 |) in
                              __val));
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::result::Result::Err",
                                  0
                                |) in
                              let __err := M.copy (| γ0_0 |) in
                              M.alloc (|
                                M.never_to_any (|
                                  M.read (|
                                    M.return_ (|
                                      Value.StructTuple
                                        "core::result::Result::Err"
                                        []
                                        [
                                          Ty.associated_in_trait
                                            "serde::ser::Serializer"
                                            []
                                            []
                                            __S
                                            "Ok";
                                          Ty.associated_in_trait
                                            "serde::ser::Serializer"
                                            []
                                            []
                                            __S
                                            "Error"
                                        ]
                                        [ M.read (| __err |) ]
                                    |)
                                  |)
                                |)
                              |)))
                        ]
                      |)
                    |) in
                  M.alloc (|
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [
                          Ty.associated_in_trait "serde::ser::Serializer" [] [] __S "Ok";
                          Ty.associated_in_trait "serde::ser::Serializer" [] [] __S "Error"
                        ],
                      M.get_trait_method (|
                        "serde::ser::SerializeStruct",
                        Ty.associated_in_trait "serde::ser::Serializer" [] [] __S "SerializeStruct",
                        [],
                        [],
                        "end",
                        [],
                        []
                      |),
                      [ M.read (| __serde_state |) ]
                    |)
                  |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "serde::ser::Serialize"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("serialize", InstanceField.Method serialize) ].
    End Impl_serde_ser_Serialize_for_move_binary_format_file_format_StructTypeParameter.
    Module Impl_serde_de_Deserialize_for_move_binary_format_file_format_StructTypeParameter.
      Definition Self : Ty.t := Ty.path "move_binary_format::file_format::StructTypeParameter".
      
      (* Deserialize *)
      Definition deserialize (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [ __D ], [ __deserializer ] =>
          ltac:(M.monadic
            (let __deserializer := M.alloc (| __deserializer |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.path "move_binary_format::file_format::StructTypeParameter";
                  Ty.associated_in_trait "serde::de::Deserializer" [] [] __D "Error"
                ],
              M.get_trait_method (|
                "serde::de::Deserializer",
                __D,
                [],
                [],
                "deserialize_struct",
                [],
                [ Ty.path "move_binary_format::file_format::_'1::deserialize::__Visitor" ]
              |),
              [
                M.read (| __deserializer |);
                mk_str (| "StructTypeParameter" |);
                M.read (|
                  get_constant (|
                    "move_binary_format::file_format::_'1::deserialize::FIELDS",
                    Ty.apply
                      (Ty.path "&")
                      []
                      [
                        Ty.apply
                          (Ty.path "slice")
                          []
                          [ Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ]
                      ]
                  |)
                |);
                Value.StructRecord
                  "move_binary_format::file_format::_'1::deserialize::__Visitor"
                  []
                  []
                  [
                    ("marker",
                      Value.StructTuple
                        "core::marker::PhantomData"
                        []
                        [ Ty.path "move_binary_format::file_format::StructTypeParameter" ]
                        []);
                    ("lifetime",
                      Value.StructTuple
                        "core::marker::PhantomData"
                        []
                        [ Ty.apply (Ty.path "&") [] [ Ty.tuple [] ] ]
                        [])
                  ]
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "serde::de::Deserialize"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("deserialize", InstanceField.Method deserialize) ].
    End Impl_serde_de_Deserialize_for_move_binary_format_file_format_StructTypeParameter.
    Module Impl_serde_ser_Serialize_for_move_binary_format_file_format_Visibility.
      Definition Self : Ty.t := Ty.path "move_binary_format::file_format::Visibility".
      
      (* Serialize *)
      Definition serialize (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [ __S ], [ self; __serializer ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let __serializer := M.alloc (| __serializer |) in
            M.read (|
              M.match_operator (|
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [
                        Ty.associated_in_trait "serde::ser::Serializer" [] [] __S "Ok";
                        Ty.associated_in_trait "serde::ser::Serializer" [] [] __S "Error"
                      ]
                  ],
                M.deref (| M.read (| self |) |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let _ :=
                        M.is_struct_tuple (|
                          γ,
                          "move_binary_format::file_format::Visibility::Private"
                        |) in
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::result::Result")
                            []
                            [
                              Ty.associated_in_trait "serde::ser::Serializer" [] [] __S "Ok";
                              Ty.associated_in_trait "serde::ser::Serializer" [] [] __S "Error"
                            ],
                          M.get_trait_method (|
                            "serde::ser::Serializer",
                            __S,
                            [],
                            [],
                            "serialize_unit_variant",
                            [],
                            []
                          |),
                          [
                            M.read (| __serializer |);
                            mk_str (| "Visibility" |);
                            Value.Integer IntegerKind.U32 0;
                            mk_str (| "Private" |)
                          ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let _ :=
                        M.is_struct_tuple (|
                          γ,
                          "move_binary_format::file_format::Visibility::Public"
                        |) in
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::result::Result")
                            []
                            [
                              Ty.associated_in_trait "serde::ser::Serializer" [] [] __S "Ok";
                              Ty.associated_in_trait "serde::ser::Serializer" [] [] __S "Error"
                            ],
                          M.get_trait_method (|
                            "serde::ser::Serializer",
                            __S,
                            [],
                            [],
                            "serialize_unit_variant",
                            [],
                            []
                          |),
                          [
                            M.read (| __serializer |);
                            mk_str (| "Visibility" |);
                            Value.Integer IntegerKind.U32 1;
                            mk_str (| "Public" |)
                          ]
                        |)
                      |)));
                  fun γ =>
                    ltac:(M.monadic
                      (let _ :=
                        M.is_struct_tuple (|
                          γ,
                          "move_binary_format::file_format::Visibility::Friend"
                        |) in
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::result::Result")
                            []
                            [
                              Ty.associated_in_trait "serde::ser::Serializer" [] [] __S "Ok";
                              Ty.associated_in_trait "serde::ser::Serializer" [] [] __S "Error"
                            ],
                          M.get_trait_method (|
                            "serde::ser::Serializer",
                            __S,
                            [],
                            [],
                            "serialize_unit_variant",
                            [],
                            []
                          |),
                          [
                            M.read (| __serializer |);
                            mk_str (| "Visibility" |);
                            Value.Integer IntegerKind.U32 2;
                            mk_str (| "Friend" |)
                          ]
                        |)
                      |)))
                ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "serde::ser::Serialize"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("serialize", InstanceField.Method serialize) ].
    End Impl_serde_ser_Serialize_for_move_binary_format_file_format_Visibility.
    Module Impl_serde_de_Deserialize_for_move_binary_format_file_format_Visibility.
      Definition Self : Ty.t := Ty.path "move_binary_format::file_format::Visibility".
      
      (* Deserialize *)
      Definition deserialize (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [ __D ], [ __deserializer ] =>
          ltac:(M.monadic
            (let __deserializer := M.alloc (| __deserializer |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.path "move_binary_format::file_format::Visibility";
                  Ty.associated_in_trait "serde::de::Deserializer" [] [] __D "Error"
                ],
              M.get_trait_method (|
                "serde::de::Deserializer",
                __D,
                [],
                [],
                "deserialize_enum",
                [],
                [ Ty.path "move_binary_format::file_format::_'3::deserialize::__Visitor" ]
              |),
              [
                M.read (| __deserializer |);
                mk_str (| "Visibility" |);
                M.read (|
                  get_constant (|
                    "move_binary_format::file_format::_'3::deserialize::VARIANTS",
                    Ty.apply
                      (Ty.path "&")
                      []
                      [
                        Ty.apply
                          (Ty.path "slice")
                          []
                          [ Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ]
                      ]
                  |)
                |);
                Value.StructRecord
                  "move_binary_format::file_format::_'3::deserialize::__Visitor"
                  []
                  []
                  [
                    ("marker",
                      Value.StructTuple
                        "core::marker::PhantomData"
                        []
                        [ Ty.path "move_binary_format::file_format::Visibility" ]
                        []);
                    ("lifetime",
                      Value.StructTuple
                        "core::marker::PhantomData"
                        []
                        [ Ty.apply (Ty.path "&") [] [ Ty.tuple [] ] ]
                        [])
                  ]
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "serde::de::Deserialize"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("deserialize", InstanceField.Method deserialize) ].
    End Impl_serde_de_Deserialize_for_move_binary_format_file_format_Visibility.
    Module Impl_serde_ser_Serialize_for_move_binary_format_file_format_AbilitySet.
      Definition Self : Ty.t := Ty.path "move_binary_format::file_format::AbilitySet".
      
      (* Serialize *)
      Definition serialize (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [ __S ], [ self; __serializer ] =>
          ltac:(M.monadic
            (let self := M.alloc (| self |) in
            let __serializer := M.alloc (| __serializer |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.associated_in_trait "serde::ser::Serializer" [] [] __S "Ok";
                  Ty.associated_in_trait "serde::ser::Serializer" [] [] __S "Error"
                ],
              M.get_trait_method (|
                "serde::ser::Serializer",
                __S,
                [],
                [],
                "serialize_newtype_struct",
                [],
                [ Ty.path "u8" ]
              |),
              [
                M.read (| __serializer |);
                mk_str (| "AbilitySet" |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_tuple_field (|
                        M.deref (| M.read (| self |) |),
                        "move_binary_format::file_format::AbilitySet",
                        0
                      |)
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "serde::ser::Serialize"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("serialize", InstanceField.Method serialize) ].
    End Impl_serde_ser_Serialize_for_move_binary_format_file_format_AbilitySet.
    Module Impl_serde_de_Deserialize_for_move_binary_format_file_format_AbilitySet.
      Definition Self : Ty.t := Ty.path "move_binary_format::file_format::AbilitySet".
      
      (* Deserialize *)
      Definition deserialize (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [ __D ], [ __deserializer ] =>
          ltac:(M.monadic
            (let __deserializer := M.alloc (| __deserializer |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.path "move_binary_format::file_format::AbilitySet";
                  Ty.associated_in_trait "serde::de::Deserializer" [] [] __D "Error"
                ],
              M.get_trait_method (|
                "serde::de::Deserializer",
                __D,
                [],
                [],
                "deserialize_newtype_struct",
                [],
                [ Ty.path "move_binary_format::file_format::_'5::deserialize::__Visitor" ]
              |),
              [
                M.read (| __deserializer |);
                mk_str (| "AbilitySet" |);
                Value.StructRecord
                  "move_binary_format::file_format::_'5::deserialize::__Visitor"
                  []
                  []
                  [
                    ("marker",
                      Value.StructTuple
                        "core::marker::PhantomData"
                        []
                        [ Ty.path "move_binary_format::file_format::AbilitySet" ]
                        []);
                    ("lifetime",
                      Value.StructTuple
                        "core::marker::PhantomData"
                        []
                        [ Ty.apply (Ty.path "&") [] [ Ty.tuple [] ] ]
                        [])
                  ]
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "serde::de::Deserialize"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("deserialize", InstanceField.Method deserialize) ].
    End Impl_serde_de_Deserialize_for_move_binary_format_file_format_AbilitySet.
  End underscore.
  
  
  (* StructRecord
    {
      name := "FunctionHandle";
      const_params := [];
      ty_params := [];
      fields :=
        [
          ("module", Ty.path "move_binary_format::file_format::ModuleHandleIndex");
          ("name", Ty.path "move_binary_format::file_format::IdentifierIndex");
          ("parameters", Ty.path "move_binary_format::file_format::SignatureIndex");
          ("return_", Ty.path "move_binary_format::file_format::SignatureIndex");
          ("type_parameters",
            Ty.apply
              (Ty.path "alloc::vec::Vec")
              []
              [
                Ty.path "move_binary_format::file_format::AbilitySet";
                Ty.path "alloc::alloc::Global"
              ])
        ];
    } *)
  
  Module Impl_core_clone_Clone_for_move_binary_format_file_format_FunctionHandle.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::FunctionHandle".
    
    (* Clone *)
    Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.StructRecord
            "move_binary_format::file_format::FunctionHandle"
            []
            []
            [
              ("module",
                M.call_closure (|
                  Ty.path "move_binary_format::file_format::ModuleHandleIndex",
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.path "move_binary_format::file_format::ModuleHandleIndex",
                    [],
                    [],
                    "clone",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "move_binary_format::file_format::FunctionHandle",
                            "module"
                          |)
                        |)
                      |)
                    |)
                  ]
                |));
              ("name",
                M.call_closure (|
                  Ty.path "move_binary_format::file_format::IdentifierIndex",
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.path "move_binary_format::file_format::IdentifierIndex",
                    [],
                    [],
                    "clone",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "move_binary_format::file_format::FunctionHandle",
                            "name"
                          |)
                        |)
                      |)
                    |)
                  ]
                |));
              ("parameters",
                M.call_closure (|
                  Ty.path "move_binary_format::file_format::SignatureIndex",
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.path "move_binary_format::file_format::SignatureIndex",
                    [],
                    [],
                    "clone",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "move_binary_format::file_format::FunctionHandle",
                            "parameters"
                          |)
                        |)
                      |)
                    |)
                  ]
                |));
              ("return_",
                M.call_closure (|
                  Ty.path "move_binary_format::file_format::SignatureIndex",
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.path "move_binary_format::file_format::SignatureIndex",
                    [],
                    [],
                    "clone",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "move_binary_format::file_format::FunctionHandle",
                            "return_"
                          |)
                        |)
                      |)
                    |)
                  ]
                |));
              ("type_parameters",
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [
                      Ty.path "move_binary_format::file_format::AbilitySet";
                      Ty.path "alloc::alloc::Global"
                    ],
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      []
                      [
                        Ty.path "move_binary_format::file_format::AbilitySet";
                        Ty.path "alloc::alloc::Global"
                      ],
                    [],
                    [],
                    "clone",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "move_binary_format::file_format::FunctionHandle",
                            "type_parameters"
                          |)
                        |)
                      |)
                    |)
                  ]
                |))
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_move_binary_format_file_format_FunctionHandle.
  
  Module Impl_core_fmt_Debug_for_move_binary_format_file_format_FunctionHandle.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::FunctionHandle".
    
    (* Debug *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_associated_function (|
              Ty.path "core::fmt::Formatter",
              "debug_struct_field5_finish",
              [],
              []
            |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "FunctionHandle" |) |) |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "module" |) |) |);
              (* Unsize *)
              M.pointer_coercion
                (M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "move_binary_format::file_format::FunctionHandle",
                        "module"
                      |)
                    |)
                  |)
                |));
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "name" |) |) |);
              (* Unsize *)
              M.pointer_coercion
                (M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "move_binary_format::file_format::FunctionHandle",
                        "name"
                      |)
                    |)
                  |)
                |));
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "parameters" |) |) |);
              (* Unsize *)
              M.pointer_coercion
                (M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "move_binary_format::file_format::FunctionHandle",
                        "parameters"
                      |)
                    |)
                  |)
                |));
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "return_" |) |) |);
              (* Unsize *)
              M.pointer_coercion
                (M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "move_binary_format::file_format::FunctionHandle",
                        "return_"
                      |)
                    |)
                  |)
                |));
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "type_parameters" |) |) |);
              (* Unsize *)
              M.pointer_coercion
                (M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.alloc (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "move_binary_format::file_format::FunctionHandle",
                            "type_parameters"
                          |)
                        |)
                      |)
                    |)
                  |)
                |))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_move_binary_format_file_format_FunctionHandle.
  
  Module Impl_core_cmp_Eq_for_move_binary_format_file_format_FunctionHandle.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::FunctionHandle".
    
    (* Eq *)
    Definition assert_receiver_is_total_eq
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              Value.DeclaredButUndefined,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                      Value.DeclaredButUndefined,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                              Value.DeclaredButUndefined,
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (M.match_operator (|
                                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                      Value.DeclaredButUndefined,
                                      [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                                    |)))
                              ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_move_binary_format_file_format_FunctionHandle.
  
  Module Impl_core_hash_Hash_for_move_binary_format_file_format_FunctionHandle.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::FunctionHandle".
    
    (* Hash *)
    Definition hash (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ __H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let state := M.alloc (| state |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.call_closure (|
                Ty.tuple [],
                M.get_trait_method (|
                  "core::hash::Hash",
                  Ty.path "move_binary_format::file_format::ModuleHandleIndex",
                  [],
                  [],
                  "hash",
                  [],
                  [ __H ]
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "move_binary_format::file_format::FunctionHandle",
                          "module"
                        |)
                      |)
                    |)
                  |);
                  M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                ]
              |) in
            let~ _ : Ty.tuple [] :=
              M.call_closure (|
                Ty.tuple [],
                M.get_trait_method (|
                  "core::hash::Hash",
                  Ty.path "move_binary_format::file_format::IdentifierIndex",
                  [],
                  [],
                  "hash",
                  [],
                  [ __H ]
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "move_binary_format::file_format::FunctionHandle",
                          "name"
                        |)
                      |)
                    |)
                  |);
                  M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                ]
              |) in
            let~ _ : Ty.tuple [] :=
              M.call_closure (|
                Ty.tuple [],
                M.get_trait_method (|
                  "core::hash::Hash",
                  Ty.path "move_binary_format::file_format::SignatureIndex",
                  [],
                  [],
                  "hash",
                  [],
                  [ __H ]
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "move_binary_format::file_format::FunctionHandle",
                          "parameters"
                        |)
                      |)
                    |)
                  |);
                  M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                ]
              |) in
            let~ _ : Ty.tuple [] :=
              M.call_closure (|
                Ty.tuple [],
                M.get_trait_method (|
                  "core::hash::Hash",
                  Ty.path "move_binary_format::file_format::SignatureIndex",
                  [],
                  [],
                  "hash",
                  [],
                  [ __H ]
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "move_binary_format::file_format::FunctionHandle",
                          "return_"
                        |)
                      |)
                    |)
                  |);
                  M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                ]
              |) in
            M.alloc (|
              M.call_closure (|
                Ty.tuple [],
                M.get_trait_method (|
                  "core::hash::Hash",
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [
                      Ty.path "move_binary_format::file_format::AbilitySet";
                      Ty.path "alloc::alloc::Global"
                    ],
                  [],
                  [],
                  "hash",
                  [],
                  [ __H ]
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "move_binary_format::file_format::FunctionHandle",
                          "type_parameters"
                        |)
                      |)
                    |)
                  |);
                  M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::hash::Hash"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("hash", InstanceField.Method hash) ].
  End Impl_core_hash_Hash_for_move_binary_format_file_format_FunctionHandle.
  
  Module Impl_core_marker_StructuralPartialEq_for_move_binary_format_file_format_FunctionHandle.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::FunctionHandle".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_move_binary_format_file_format_FunctionHandle.
  
  Module Impl_core_cmp_PartialEq_move_binary_format_file_format_FunctionHandle_for_move_binary_format_file_format_FunctionHandle.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::FunctionHandle".
    
    (* PartialEq *)
    Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          LogicalOp.and (|
            LogicalOp.and (|
              LogicalOp.and (|
                LogicalOp.and (|
                  M.call_closure (|
                    Ty.path "bool",
                    M.get_trait_method (|
                      "core::cmp::PartialEq",
                      Ty.path "move_binary_format::file_format::ModuleHandleIndex",
                      [],
                      [ Ty.path "move_binary_format::file_format::ModuleHandleIndex" ],
                      "eq",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "move_binary_format::file_format::FunctionHandle",
                          "module"
                        |)
                      |);
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| other |) |),
                          "move_binary_format::file_format::FunctionHandle",
                          "module"
                        |)
                      |)
                    ]
                  |),
                  ltac:(M.monadic
                    (M.call_closure (|
                      Ty.path "bool",
                      M.get_trait_method (|
                        "core::cmp::PartialEq",
                        Ty.path "move_binary_format::file_format::IdentifierIndex",
                        [],
                        [ Ty.path "move_binary_format::file_format::IdentifierIndex" ],
                        "eq",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "move_binary_format::file_format::FunctionHandle",
                            "name"
                          |)
                        |);
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| other |) |),
                            "move_binary_format::file_format::FunctionHandle",
                            "name"
                          |)
                        |)
                      ]
                    |)))
                |),
                ltac:(M.monadic
                  (M.call_closure (|
                    Ty.path "bool",
                    M.get_trait_method (|
                      "core::cmp::PartialEq",
                      Ty.path "move_binary_format::file_format::SignatureIndex",
                      [],
                      [ Ty.path "move_binary_format::file_format::SignatureIndex" ],
                      "eq",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "move_binary_format::file_format::FunctionHandle",
                          "parameters"
                        |)
                      |);
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| other |) |),
                          "move_binary_format::file_format::FunctionHandle",
                          "parameters"
                        |)
                      |)
                    ]
                  |)))
              |),
              ltac:(M.monadic
                (M.call_closure (|
                  Ty.path "bool",
                  M.get_trait_method (|
                    "core::cmp::PartialEq",
                    Ty.path "move_binary_format::file_format::SignatureIndex",
                    [],
                    [ Ty.path "move_binary_format::file_format::SignatureIndex" ],
                    "eq",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "move_binary_format::file_format::FunctionHandle",
                        "return_"
                      |)
                    |);
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| other |) |),
                        "move_binary_format::file_format::FunctionHandle",
                        "return_"
                      |)
                    |)
                  ]
                |)))
            |),
            ltac:(M.monadic
              (M.call_closure (|
                Ty.path "bool",
                M.get_trait_method (|
                  "core::cmp::PartialEq",
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [
                      Ty.path "move_binary_format::file_format::AbilitySet";
                      Ty.path "alloc::alloc::Global"
                    ],
                  [],
                  [
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      []
                      [
                        Ty.path "move_binary_format::file_format::AbilitySet";
                        Ty.path "alloc::alloc::Global"
                      ]
                  ],
                  "eq",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "move_binary_format::file_format::FunctionHandle",
                      "type_parameters"
                    |)
                  |);
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| other |) |),
                      "move_binary_format::file_format::FunctionHandle",
                      "type_parameters"
                    |)
                  |)
                ]
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "move_binary_format::file_format::FunctionHandle" ]
        Self
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_move_binary_format_file_format_FunctionHandle_for_move_binary_format_file_format_FunctionHandle.
  
  (* StructRecord
    {
      name := "FieldHandle";
      const_params := [];
      ty_params := [];
      fields :=
        [
          ("owner", Ty.path "move_binary_format::file_format::StructDefinitionIndex");
          ("field", Ty.path "u16")
        ];
    } *)
  
  Module Impl_core_clone_Clone_for_move_binary_format_file_format_FieldHandle.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::FieldHandle".
    
    (* Clone *)
    Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.StructRecord
            "move_binary_format::file_format::FieldHandle"
            []
            []
            [
              ("owner",
                M.call_closure (|
                  Ty.path "move_binary_format::file_format::StructDefinitionIndex",
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.path "move_binary_format::file_format::StructDefinitionIndex",
                    [],
                    [],
                    "clone",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "move_binary_format::file_format::FieldHandle",
                            "owner"
                          |)
                        |)
                      |)
                    |)
                  ]
                |));
              ("field",
                M.call_closure (|
                  Ty.path "u16",
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.path "u16",
                    [],
                    [],
                    "clone",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "move_binary_format::file_format::FieldHandle",
                            "field"
                          |)
                        |)
                      |)
                    |)
                  ]
                |))
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_move_binary_format_file_format_FieldHandle.
  
  Module Impl_core_fmt_Debug_for_move_binary_format_file_format_FieldHandle.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::FieldHandle".
    
    (* Debug *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_associated_function (|
              Ty.path "core::fmt::Formatter",
              "debug_struct_field2_finish",
              [],
              []
            |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "FieldHandle" |) |) |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "owner" |) |) |);
              (* Unsize *)
              M.pointer_coercion
                (M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "move_binary_format::file_format::FieldHandle",
                        "owner"
                      |)
                    |)
                  |)
                |));
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "field" |) |) |);
              (* Unsize *)
              M.pointer_coercion
                (M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.alloc (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "move_binary_format::file_format::FieldHandle",
                            "field"
                          |)
                        |)
                      |)
                    |)
                  |)
                |))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_move_binary_format_file_format_FieldHandle.
  
  Module Impl_core_cmp_Eq_for_move_binary_format_file_format_FieldHandle.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::FieldHandle".
    
    (* Eq *)
    Definition assert_receiver_is_total_eq
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              Value.DeclaredButUndefined,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                      Value.DeclaredButUndefined,
                      [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_move_binary_format_file_format_FieldHandle.
  
  Module Impl_core_hash_Hash_for_move_binary_format_file_format_FieldHandle.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::FieldHandle".
    
    (* Hash *)
    Definition hash (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ __H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let state := M.alloc (| state |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.call_closure (|
                Ty.tuple [],
                M.get_trait_method (|
                  "core::hash::Hash",
                  Ty.path "move_binary_format::file_format::StructDefinitionIndex",
                  [],
                  [],
                  "hash",
                  [],
                  [ __H ]
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "move_binary_format::file_format::FieldHandle",
                          "owner"
                        |)
                      |)
                    |)
                  |);
                  M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                ]
              |) in
            M.alloc (|
              M.call_closure (|
                Ty.tuple [],
                M.get_trait_method (|
                  "core::hash::Hash",
                  Ty.path "u16",
                  [],
                  [],
                  "hash",
                  [],
                  [ __H ]
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "move_binary_format::file_format::FieldHandle",
                          "field"
                        |)
                      |)
                    |)
                  |);
                  M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::hash::Hash"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("hash", InstanceField.Method hash) ].
  End Impl_core_hash_Hash_for_move_binary_format_file_format_FieldHandle.
  
  Module Impl_core_marker_StructuralPartialEq_for_move_binary_format_file_format_FieldHandle.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::FieldHandle".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_move_binary_format_file_format_FieldHandle.
  
  Module Impl_core_cmp_PartialEq_move_binary_format_file_format_FieldHandle_for_move_binary_format_file_format_FieldHandle.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::FieldHandle".
    
    (* PartialEq *)
    Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          LogicalOp.and (|
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (|
                "core::cmp::PartialEq",
                Ty.path "move_binary_format::file_format::StructDefinitionIndex",
                [],
                [ Ty.path "move_binary_format::file_format::StructDefinitionIndex" ],
                "eq",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "move_binary_format::file_format::FieldHandle",
                    "owner"
                  |)
                |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| other |) |),
                    "move_binary_format::file_format::FieldHandle",
                    "owner"
                  |)
                |)
              ]
            |),
            ltac:(M.monadic
              (M.call_closure (|
                Ty.path "bool",
                BinOp.eq,
                [
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "move_binary_format::file_format::FieldHandle",
                      "field"
                    |)
                  |);
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| other |) |),
                      "move_binary_format::file_format::FieldHandle",
                      "field"
                    |)
                  |)
                ]
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "move_binary_format::file_format::FieldHandle" ]
        Self
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_move_binary_format_file_format_FieldHandle_for_move_binary_format_file_format_FieldHandle.
  
  (*
  Enum StructFieldInformation
  {
    const_params := [];
    ty_params := [];
    variants :=
      [
        {
          name := "Native";
          item := StructTuple [];
        };
        {
          name := "Declared";
          item :=
            StructTuple
              [
                Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  []
                  [
                    Ty.path "move_binary_format::file_format::FieldDefinition";
                    Ty.path "alloc::alloc::Global"
                  ]
              ];
        }
      ];
  }
  *)
  
  Axiom IsDiscriminant_StructFieldInformation_Native :
    M.IsDiscriminant "move_binary_format::file_format::StructFieldInformation::Native" 0.
  Axiom IsDiscriminant_StructFieldInformation_Declared :
    M.IsDiscriminant "move_binary_format::file_format::StructFieldInformation::Declared" 1.
  
  Module Impl_core_clone_Clone_for_move_binary_format_file_format_StructFieldInformation.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::StructFieldInformation".
    
    (* Clone *)
    Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Ty.apply
                (Ty.path "*")
                []
                [ Ty.path "move_binary_format::file_format::StructFieldInformation" ],
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "move_binary_format::file_format::StructFieldInformation::Native"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_binary_format::file_format::StructFieldInformation::Native"
                        []
                        []
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::StructFieldInformation::Declared",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_binary_format::file_format::StructFieldInformation::Declared"
                        []
                        []
                        [
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              []
                              [
                                Ty.path "move_binary_format::file_format::FieldDefinition";
                                Ty.path "alloc::alloc::Global"
                              ],
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                []
                                [
                                  Ty.path "move_binary_format::file_format::FieldDefinition";
                                  Ty.path "alloc::alloc::Global"
                                ],
                              [],
                              [],
                              "clone",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |) ]
                          |)
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_move_binary_format_file_format_StructFieldInformation.
  
  Module Impl_core_fmt_Debug_for_move_binary_format_file_format_StructFieldInformation.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::StructFieldInformation".
    
    (* Debug *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.read (|
            M.match_operator (|
              Ty.apply
                (Ty.path "*")
                []
                [
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [ Ty.tuple []; Ty.path "core::fmt::Error" ]
                ],
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "move_binary_format::file_format::StructFieldInformation::Native"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_str",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "Native" |) |) |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::StructFieldInformation::Declared",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "debug_tuple_field1_finish",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "Declared" |) |) |);
                          (* Unsize *)
                          M.pointer_coercion
                            (M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (| M.borrow (| Pointer.Kind.Ref, __self_0 |) |)
                            |))
                        ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_move_binary_format_file_format_StructFieldInformation.
  
  Module Impl_core_cmp_Eq_for_move_binary_format_file_format_StructFieldInformation.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::StructFieldInformation".
    
    (* Eq *)
    Definition assert_receiver_is_total_eq
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              Value.DeclaredButUndefined,
              [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_move_binary_format_file_format_StructFieldInformation.
  
  Module Impl_core_marker_StructuralPartialEq_for_move_binary_format_file_format_StructFieldInformation.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::StructFieldInformation".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_move_binary_format_file_format_StructFieldInformation.
  
  Module Impl_core_cmp_PartialEq_move_binary_format_file_format_StructFieldInformation_for_move_binary_format_file_format_StructFieldInformation.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::StructFieldInformation".
    
    (* PartialEq *)
    Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            let~ __self_discr : Ty.path "isize" :=
              M.call_closure (|
                Ty.path "isize",
                M.get_function (|
                  "core::intrinsics::discriminant_value",
                  [],
                  [ Ty.path "move_binary_format::file_format::StructFieldInformation" ]
                |),
                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
              |) in
            let~ __arg1_discr : Ty.path "isize" :=
              M.call_closure (|
                Ty.path "isize",
                M.get_function (|
                  "core::intrinsics::discriminant_value",
                  [],
                  [ Ty.path "move_binary_format::file_format::StructFieldInformation" ]
                |),
                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |) ]
              |) in
            M.alloc (|
              LogicalOp.and (|
                M.call_closure (|
                  Ty.path "bool",
                  BinOp.eq,
                  [ M.read (| __self_discr |); M.read (| __arg1_discr |) ]
                |),
                ltac:(M.monadic
                  (M.read (|
                    M.match_operator (|
                      Ty.apply (Ty.path "*") [] [ Ty.path "bool" ],
                      M.alloc (| Value.Tuple [ M.read (| self |); M.read (| other |) ] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_0,
                                "move_binary_format::file_format::StructFieldInformation::Declared",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_1,
                                "move_binary_format::file_format::StructFieldInformation::Declared",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.apply
                                    (Ty.path "&")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "alloc::vec::Vec")
                                        []
                                        [
                                          Ty.path
                                            "move_binary_format::file_format::FieldDefinition";
                                          Ty.path "alloc::alloc::Global"
                                        ]
                                    ],
                                  [],
                                  [
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "alloc::vec::Vec")
                                          []
                                          [
                                            Ty.path
                                              "move_binary_format::file_format::FieldDefinition";
                                            Ty.path "alloc::alloc::Global"
                                          ]
                                      ]
                                  ],
                                  "eq",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (| Pointer.Kind.Ref, __self_0 |);
                                  M.borrow (| Pointer.Kind.Ref, __arg1_0 |)
                                ]
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Bool true |)))
                      ]
                    |)
                  |)))
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.path "move_binary_format::file_format::StructFieldInformation" ]
        Self
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_move_binary_format_file_format_StructFieldInformation_for_move_binary_format_file_format_StructFieldInformation.
  
  (* StructRecord
    {
      name := "StructDefInstantiation";
      const_params := [];
      ty_params := [];
      fields :=
        [
          ("def", Ty.path "move_binary_format::file_format::StructDefinitionIndex");
          ("type_parameters", Ty.path "move_binary_format::file_format::SignatureIndex")
        ];
    } *)
  
  Module Impl_core_clone_Clone_for_move_binary_format_file_format_StructDefInstantiation.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::StructDefInstantiation".
    
    (* Clone *)
    Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.StructRecord
            "move_binary_format::file_format::StructDefInstantiation"
            []
            []
            [
              ("def",
                M.call_closure (|
                  Ty.path "move_binary_format::file_format::StructDefinitionIndex",
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.path "move_binary_format::file_format::StructDefinitionIndex",
                    [],
                    [],
                    "clone",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "move_binary_format::file_format::StructDefInstantiation",
                            "def"
                          |)
                        |)
                      |)
                    |)
                  ]
                |));
              ("type_parameters",
                M.call_closure (|
                  Ty.path "move_binary_format::file_format::SignatureIndex",
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.path "move_binary_format::file_format::SignatureIndex",
                    [],
                    [],
                    "clone",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "move_binary_format::file_format::StructDefInstantiation",
                            "type_parameters"
                          |)
                        |)
                      |)
                    |)
                  ]
                |))
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_move_binary_format_file_format_StructDefInstantiation.
  
  Module Impl_core_fmt_Debug_for_move_binary_format_file_format_StructDefInstantiation.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::StructDefInstantiation".
    
    (* Debug *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_associated_function (|
              Ty.path "core::fmt::Formatter",
              "debug_struct_field2_finish",
              [],
              []
            |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "StructDefInstantiation" |) |) |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "def" |) |) |);
              (* Unsize *)
              M.pointer_coercion
                (M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "move_binary_format::file_format::StructDefInstantiation",
                        "def"
                      |)
                    |)
                  |)
                |));
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "type_parameters" |) |) |);
              (* Unsize *)
              M.pointer_coercion
                (M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.alloc (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "move_binary_format::file_format::StructDefInstantiation",
                            "type_parameters"
                          |)
                        |)
                      |)
                    |)
                  |)
                |))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_move_binary_format_file_format_StructDefInstantiation.
  
  Module Impl_core_cmp_Eq_for_move_binary_format_file_format_StructDefInstantiation.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::StructDefInstantiation".
    
    (* Eq *)
    Definition assert_receiver_is_total_eq
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              Value.DeclaredButUndefined,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                      Value.DeclaredButUndefined,
                      [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_move_binary_format_file_format_StructDefInstantiation.
  
  Module Impl_core_hash_Hash_for_move_binary_format_file_format_StructDefInstantiation.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::StructDefInstantiation".
    
    (* Hash *)
    Definition hash (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ __H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let state := M.alloc (| state |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.call_closure (|
                Ty.tuple [],
                M.get_trait_method (|
                  "core::hash::Hash",
                  Ty.path "move_binary_format::file_format::StructDefinitionIndex",
                  [],
                  [],
                  "hash",
                  [],
                  [ __H ]
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "move_binary_format::file_format::StructDefInstantiation",
                          "def"
                        |)
                      |)
                    |)
                  |);
                  M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                ]
              |) in
            M.alloc (|
              M.call_closure (|
                Ty.tuple [],
                M.get_trait_method (|
                  "core::hash::Hash",
                  Ty.path "move_binary_format::file_format::SignatureIndex",
                  [],
                  [],
                  "hash",
                  [],
                  [ __H ]
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "move_binary_format::file_format::StructDefInstantiation",
                          "type_parameters"
                        |)
                      |)
                    |)
                  |);
                  M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::hash::Hash"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("hash", InstanceField.Method hash) ].
  End Impl_core_hash_Hash_for_move_binary_format_file_format_StructDefInstantiation.
  
  Module Impl_core_marker_StructuralPartialEq_for_move_binary_format_file_format_StructDefInstantiation.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::StructDefInstantiation".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_move_binary_format_file_format_StructDefInstantiation.
  
  Module Impl_core_cmp_PartialEq_move_binary_format_file_format_StructDefInstantiation_for_move_binary_format_file_format_StructDefInstantiation.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::StructDefInstantiation".
    
    (* PartialEq *)
    Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          LogicalOp.and (|
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (|
                "core::cmp::PartialEq",
                Ty.path "move_binary_format::file_format::StructDefinitionIndex",
                [],
                [ Ty.path "move_binary_format::file_format::StructDefinitionIndex" ],
                "eq",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "move_binary_format::file_format::StructDefInstantiation",
                    "def"
                  |)
                |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| other |) |),
                    "move_binary_format::file_format::StructDefInstantiation",
                    "def"
                  |)
                |)
              ]
            |),
            ltac:(M.monadic
              (M.call_closure (|
                Ty.path "bool",
                M.get_trait_method (|
                  "core::cmp::PartialEq",
                  Ty.path "move_binary_format::file_format::SignatureIndex",
                  [],
                  [ Ty.path "move_binary_format::file_format::SignatureIndex" ],
                  "eq",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "move_binary_format::file_format::StructDefInstantiation",
                      "type_parameters"
                    |)
                  |);
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| other |) |),
                      "move_binary_format::file_format::StructDefInstantiation",
                      "type_parameters"
                    |)
                  |)
                ]
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.path "move_binary_format::file_format::StructDefInstantiation" ]
        Self
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_move_binary_format_file_format_StructDefInstantiation_for_move_binary_format_file_format_StructDefInstantiation.
  
  (* StructRecord
    {
      name := "FunctionInstantiation";
      const_params := [];
      ty_params := [];
      fields :=
        [
          ("handle", Ty.path "move_binary_format::file_format::FunctionHandleIndex");
          ("type_parameters", Ty.path "move_binary_format::file_format::SignatureIndex")
        ];
    } *)
  
  Module Impl_core_clone_Clone_for_move_binary_format_file_format_FunctionInstantiation.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::FunctionInstantiation".
    
    (* Clone *)
    Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.StructRecord
            "move_binary_format::file_format::FunctionInstantiation"
            []
            []
            [
              ("handle",
                M.call_closure (|
                  Ty.path "move_binary_format::file_format::FunctionHandleIndex",
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.path "move_binary_format::file_format::FunctionHandleIndex",
                    [],
                    [],
                    "clone",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "move_binary_format::file_format::FunctionInstantiation",
                            "handle"
                          |)
                        |)
                      |)
                    |)
                  ]
                |));
              ("type_parameters",
                M.call_closure (|
                  Ty.path "move_binary_format::file_format::SignatureIndex",
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.path "move_binary_format::file_format::SignatureIndex",
                    [],
                    [],
                    "clone",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "move_binary_format::file_format::FunctionInstantiation",
                            "type_parameters"
                          |)
                        |)
                      |)
                    |)
                  ]
                |))
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_move_binary_format_file_format_FunctionInstantiation.
  
  Module Impl_core_fmt_Debug_for_move_binary_format_file_format_FunctionInstantiation.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::FunctionInstantiation".
    
    (* Debug *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_associated_function (|
              Ty.path "core::fmt::Formatter",
              "debug_struct_field2_finish",
              [],
              []
            |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "FunctionInstantiation" |) |) |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "handle" |) |) |);
              (* Unsize *)
              M.pointer_coercion
                (M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "move_binary_format::file_format::FunctionInstantiation",
                        "handle"
                      |)
                    |)
                  |)
                |));
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "type_parameters" |) |) |);
              (* Unsize *)
              M.pointer_coercion
                (M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.alloc (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "move_binary_format::file_format::FunctionInstantiation",
                            "type_parameters"
                          |)
                        |)
                      |)
                    |)
                  |)
                |))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_move_binary_format_file_format_FunctionInstantiation.
  
  Module Impl_core_cmp_Eq_for_move_binary_format_file_format_FunctionInstantiation.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::FunctionInstantiation".
    
    (* Eq *)
    Definition assert_receiver_is_total_eq
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              Value.DeclaredButUndefined,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                      Value.DeclaredButUndefined,
                      [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_move_binary_format_file_format_FunctionInstantiation.
  
  Module Impl_core_hash_Hash_for_move_binary_format_file_format_FunctionInstantiation.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::FunctionInstantiation".
    
    (* Hash *)
    Definition hash (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ __H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let state := M.alloc (| state |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.call_closure (|
                Ty.tuple [],
                M.get_trait_method (|
                  "core::hash::Hash",
                  Ty.path "move_binary_format::file_format::FunctionHandleIndex",
                  [],
                  [],
                  "hash",
                  [],
                  [ __H ]
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "move_binary_format::file_format::FunctionInstantiation",
                          "handle"
                        |)
                      |)
                    |)
                  |);
                  M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                ]
              |) in
            M.alloc (|
              M.call_closure (|
                Ty.tuple [],
                M.get_trait_method (|
                  "core::hash::Hash",
                  Ty.path "move_binary_format::file_format::SignatureIndex",
                  [],
                  [],
                  "hash",
                  [],
                  [ __H ]
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "move_binary_format::file_format::FunctionInstantiation",
                          "type_parameters"
                        |)
                      |)
                    |)
                  |);
                  M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::hash::Hash"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("hash", InstanceField.Method hash) ].
  End Impl_core_hash_Hash_for_move_binary_format_file_format_FunctionInstantiation.
  
  Module Impl_core_marker_StructuralPartialEq_for_move_binary_format_file_format_FunctionInstantiation.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::FunctionInstantiation".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_move_binary_format_file_format_FunctionInstantiation.
  
  Module Impl_core_cmp_PartialEq_move_binary_format_file_format_FunctionInstantiation_for_move_binary_format_file_format_FunctionInstantiation.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::FunctionInstantiation".
    
    (* PartialEq *)
    Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          LogicalOp.and (|
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (|
                "core::cmp::PartialEq",
                Ty.path "move_binary_format::file_format::FunctionHandleIndex",
                [],
                [ Ty.path "move_binary_format::file_format::FunctionHandleIndex" ],
                "eq",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "move_binary_format::file_format::FunctionInstantiation",
                    "handle"
                  |)
                |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| other |) |),
                    "move_binary_format::file_format::FunctionInstantiation",
                    "handle"
                  |)
                |)
              ]
            |),
            ltac:(M.monadic
              (M.call_closure (|
                Ty.path "bool",
                M.get_trait_method (|
                  "core::cmp::PartialEq",
                  Ty.path "move_binary_format::file_format::SignatureIndex",
                  [],
                  [ Ty.path "move_binary_format::file_format::SignatureIndex" ],
                  "eq",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "move_binary_format::file_format::FunctionInstantiation",
                      "type_parameters"
                    |)
                  |);
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| other |) |),
                      "move_binary_format::file_format::FunctionInstantiation",
                      "type_parameters"
                    |)
                  |)
                ]
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.path "move_binary_format::file_format::FunctionInstantiation" ]
        Self
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_move_binary_format_file_format_FunctionInstantiation_for_move_binary_format_file_format_FunctionInstantiation.
  
  (* StructRecord
    {
      name := "FieldInstantiation";
      const_params := [];
      ty_params := [];
      fields :=
        [
          ("handle", Ty.path "move_binary_format::file_format::FieldHandleIndex");
          ("type_parameters", Ty.path "move_binary_format::file_format::SignatureIndex")
        ];
    } *)
  
  Module Impl_core_clone_Clone_for_move_binary_format_file_format_FieldInstantiation.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::FieldInstantiation".
    
    (* Clone *)
    Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.StructRecord
            "move_binary_format::file_format::FieldInstantiation"
            []
            []
            [
              ("handle",
                M.call_closure (|
                  Ty.path "move_binary_format::file_format::FieldHandleIndex",
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.path "move_binary_format::file_format::FieldHandleIndex",
                    [],
                    [],
                    "clone",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "move_binary_format::file_format::FieldInstantiation",
                            "handle"
                          |)
                        |)
                      |)
                    |)
                  ]
                |));
              ("type_parameters",
                M.call_closure (|
                  Ty.path "move_binary_format::file_format::SignatureIndex",
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.path "move_binary_format::file_format::SignatureIndex",
                    [],
                    [],
                    "clone",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "move_binary_format::file_format::FieldInstantiation",
                            "type_parameters"
                          |)
                        |)
                      |)
                    |)
                  ]
                |))
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_move_binary_format_file_format_FieldInstantiation.
  
  Module Impl_core_fmt_Debug_for_move_binary_format_file_format_FieldInstantiation.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::FieldInstantiation".
    
    (* Debug *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_associated_function (|
              Ty.path "core::fmt::Formatter",
              "debug_struct_field2_finish",
              [],
              []
            |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "FieldInstantiation" |) |) |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "handle" |) |) |);
              (* Unsize *)
              M.pointer_coercion
                (M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "move_binary_format::file_format::FieldInstantiation",
                        "handle"
                      |)
                    |)
                  |)
                |));
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "type_parameters" |) |) |);
              (* Unsize *)
              M.pointer_coercion
                (M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.alloc (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "move_binary_format::file_format::FieldInstantiation",
                            "type_parameters"
                          |)
                        |)
                      |)
                    |)
                  |)
                |))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_move_binary_format_file_format_FieldInstantiation.
  
  Module Impl_core_cmp_Eq_for_move_binary_format_file_format_FieldInstantiation.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::FieldInstantiation".
    
    (* Eq *)
    Definition assert_receiver_is_total_eq
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              Value.DeclaredButUndefined,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                      Value.DeclaredButUndefined,
                      [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_move_binary_format_file_format_FieldInstantiation.
  
  Module Impl_core_hash_Hash_for_move_binary_format_file_format_FieldInstantiation.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::FieldInstantiation".
    
    (* Hash *)
    Definition hash (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ __H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let state := M.alloc (| state |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.call_closure (|
                Ty.tuple [],
                M.get_trait_method (|
                  "core::hash::Hash",
                  Ty.path "move_binary_format::file_format::FieldHandleIndex",
                  [],
                  [],
                  "hash",
                  [],
                  [ __H ]
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "move_binary_format::file_format::FieldInstantiation",
                          "handle"
                        |)
                      |)
                    |)
                  |);
                  M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                ]
              |) in
            M.alloc (|
              M.call_closure (|
                Ty.tuple [],
                M.get_trait_method (|
                  "core::hash::Hash",
                  Ty.path "move_binary_format::file_format::SignatureIndex",
                  [],
                  [],
                  "hash",
                  [],
                  [ __H ]
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "move_binary_format::file_format::FieldInstantiation",
                          "type_parameters"
                        |)
                      |)
                    |)
                  |);
                  M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::hash::Hash"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("hash", InstanceField.Method hash) ].
  End Impl_core_hash_Hash_for_move_binary_format_file_format_FieldInstantiation.
  
  Module Impl_core_marker_StructuralPartialEq_for_move_binary_format_file_format_FieldInstantiation.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::FieldInstantiation".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_move_binary_format_file_format_FieldInstantiation.
  
  Module Impl_core_cmp_PartialEq_move_binary_format_file_format_FieldInstantiation_for_move_binary_format_file_format_FieldInstantiation.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::FieldInstantiation".
    
    (* PartialEq *)
    Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          LogicalOp.and (|
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (|
                "core::cmp::PartialEq",
                Ty.path "move_binary_format::file_format::FieldHandleIndex",
                [],
                [ Ty.path "move_binary_format::file_format::FieldHandleIndex" ],
                "eq",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "move_binary_format::file_format::FieldInstantiation",
                    "handle"
                  |)
                |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| other |) |),
                    "move_binary_format::file_format::FieldInstantiation",
                    "handle"
                  |)
                |)
              ]
            |),
            ltac:(M.monadic
              (M.call_closure (|
                Ty.path "bool",
                M.get_trait_method (|
                  "core::cmp::PartialEq",
                  Ty.path "move_binary_format::file_format::SignatureIndex",
                  [],
                  [ Ty.path "move_binary_format::file_format::SignatureIndex" ],
                  "eq",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "move_binary_format::file_format::FieldInstantiation",
                      "type_parameters"
                    |)
                  |);
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| other |) |),
                      "move_binary_format::file_format::FieldInstantiation",
                      "type_parameters"
                    |)
                  |)
                ]
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.path "move_binary_format::file_format::FieldInstantiation" ]
        Self
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_move_binary_format_file_format_FieldInstantiation_for_move_binary_format_file_format_FieldInstantiation.
  
  (* StructRecord
    {
      name := "StructDefinition";
      const_params := [];
      ty_params := [];
      fields :=
        [
          ("struct_handle", Ty.path "move_binary_format::file_format::StructHandleIndex");
          ("field_information", Ty.path "move_binary_format::file_format::StructFieldInformation")
        ];
    } *)
  
  Module Impl_core_clone_Clone_for_move_binary_format_file_format_StructDefinition.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::StructDefinition".
    
    (* Clone *)
    Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.StructRecord
            "move_binary_format::file_format::StructDefinition"
            []
            []
            [
              ("struct_handle",
                M.call_closure (|
                  Ty.path "move_binary_format::file_format::StructHandleIndex",
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.path "move_binary_format::file_format::StructHandleIndex",
                    [],
                    [],
                    "clone",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "move_binary_format::file_format::StructDefinition",
                            "struct_handle"
                          |)
                        |)
                      |)
                    |)
                  ]
                |));
              ("field_information",
                M.call_closure (|
                  Ty.path "move_binary_format::file_format::StructFieldInformation",
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.path "move_binary_format::file_format::StructFieldInformation",
                    [],
                    [],
                    "clone",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "move_binary_format::file_format::StructDefinition",
                            "field_information"
                          |)
                        |)
                      |)
                    |)
                  ]
                |))
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_move_binary_format_file_format_StructDefinition.
  
  Module Impl_core_fmt_Debug_for_move_binary_format_file_format_StructDefinition.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::StructDefinition".
    
    (* Debug *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_associated_function (|
              Ty.path "core::fmt::Formatter",
              "debug_struct_field2_finish",
              [],
              []
            |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "StructDefinition" |) |) |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "struct_handle" |) |) |);
              (* Unsize *)
              M.pointer_coercion
                (M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "move_binary_format::file_format::StructDefinition",
                        "struct_handle"
                      |)
                    |)
                  |)
                |));
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "field_information" |) |) |);
              (* Unsize *)
              M.pointer_coercion
                (M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.alloc (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "move_binary_format::file_format::StructDefinition",
                            "field_information"
                          |)
                        |)
                      |)
                    |)
                  |)
                |))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_move_binary_format_file_format_StructDefinition.
  
  Module Impl_core_cmp_Eq_for_move_binary_format_file_format_StructDefinition.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::StructDefinition".
    
    (* Eq *)
    Definition assert_receiver_is_total_eq
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              Value.DeclaredButUndefined,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                      Value.DeclaredButUndefined,
                      [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_move_binary_format_file_format_StructDefinition.
  
  Module Impl_core_marker_StructuralPartialEq_for_move_binary_format_file_format_StructDefinition.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::StructDefinition".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_move_binary_format_file_format_StructDefinition.
  
  Module Impl_core_cmp_PartialEq_move_binary_format_file_format_StructDefinition_for_move_binary_format_file_format_StructDefinition.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::StructDefinition".
    
    (* PartialEq *)
    Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          LogicalOp.and (|
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (|
                "core::cmp::PartialEq",
                Ty.path "move_binary_format::file_format::StructHandleIndex",
                [],
                [ Ty.path "move_binary_format::file_format::StructHandleIndex" ],
                "eq",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "move_binary_format::file_format::StructDefinition",
                    "struct_handle"
                  |)
                |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| other |) |),
                    "move_binary_format::file_format::StructDefinition",
                    "struct_handle"
                  |)
                |)
              ]
            |),
            ltac:(M.monadic
              (M.call_closure (|
                Ty.path "bool",
                M.get_trait_method (|
                  "core::cmp::PartialEq",
                  Ty.path "move_binary_format::file_format::StructFieldInformation",
                  [],
                  [ Ty.path "move_binary_format::file_format::StructFieldInformation" ],
                  "eq",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "move_binary_format::file_format::StructDefinition",
                      "field_information"
                    |)
                  |);
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| other |) |),
                      "move_binary_format::file_format::StructDefinition",
                      "field_information"
                    |)
                  |)
                ]
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.path "move_binary_format::file_format::StructDefinition" ]
        Self
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_move_binary_format_file_format_StructDefinition_for_move_binary_format_file_format_StructDefinition.
  
  Module Impl_move_binary_format_file_format_StructDefinition.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::StructDefinition".
    
    (*
        pub fn declared_field_count(&self) -> PartialVMResult<MemberCount> {
            match &self.field_information {
                // TODO we might want a more informative error here
                StructFieldInformation::Native => Err(PartialVMError::new(StatusCode::LINKER_ERROR)
                    .with_message("Looking for field in native structure".to_string())),
                StructFieldInformation::Declared(fields) => Ok(fields.len() as u16),
            }
        }
    *)
    Definition declared_field_count (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Ty.apply
                (Ty.path "*")
                []
                [
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [ Ty.path "u16"; Ty.path "move_binary_format::errors::PartialVMError" ]
                ],
              M.alloc (|
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "move_binary_format::file_format::StructDefinition",
                    "field_information"
                  |)
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "move_binary_format::file_format::StructFieldInformation::Native"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Err"
                        []
                        [ Ty.path "u16"; Ty.path "move_binary_format::errors::PartialVMError" ]
                        [
                          M.call_closure (|
                            Ty.path "move_binary_format::errors::PartialVMError",
                            M.get_associated_function (|
                              Ty.path "move_binary_format::errors::PartialVMError",
                              "with_message",
                              [],
                              []
                            |),
                            [
                              M.call_closure (|
                                Ty.path "move_binary_format::errors::PartialVMError",
                                M.get_associated_function (|
                                  Ty.path "move_binary_format::errors::PartialVMError",
                                  "new",
                                  [],
                                  []
                                |),
                                [
                                  Value.StructTuple
                                    "move_core_types::vm_status::StatusCode::LINKER_ERROR"
                                    []
                                    []
                                    []
                                ]
                              |);
                              M.call_closure (|
                                Ty.path "alloc::string::String",
                                M.get_trait_method (|
                                  "alloc::string::ToString",
                                  Ty.path "str",
                                  [],
                                  [],
                                  "to_string",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      mk_str (| "Looking for field in native structure" |)
                                    |)
                                  |)
                                ]
                              |)
                            ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::StructFieldInformation::Declared",
                        0
                      |) in
                    let fields := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        []
                        [ Ty.path "u16"; Ty.path "move_binary_format::errors::PartialVMError" ]
                        [
                          M.cast
                            (Ty.path "u16")
                            (M.call_closure (|
                              Ty.path "usize",
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "alloc::vec::Vec")
                                  []
                                  [
                                    Ty.path "move_binary_format::file_format::FieldDefinition";
                                    Ty.path "alloc::alloc::Global"
                                  ],
                                "len",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| fields |) |) |) ]
                            |))
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_declared_field_count :
      M.IsAssociatedFunction.C Self "declared_field_count" declared_field_count.
    Admitted.
    Global Typeclasses Opaque declared_field_count.
    
    (*
        pub fn field(&self, offset: usize) -> Option<&FieldDefinition> {
            match &self.field_information {
                StructFieldInformation::Native => None,
                StructFieldInformation::Declared(fields) => fields.get(offset),
            }
        }
    *)
    Definition field (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; offset ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let offset := M.alloc (| offset |) in
          M.read (|
            M.match_operator (|
              Ty.apply
                (Ty.path "*")
                []
                [
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [
                      Ty.apply
                        (Ty.path "&")
                        []
                        [ Ty.path "move_binary_format::file_format::FieldDefinition" ]
                    ]
                ],
              M.alloc (|
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "move_binary_format::file_format::StructDefinition",
                    "field_information"
                  |)
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "move_binary_format::file_format::StructFieldInformation::Native"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::option::Option::None"
                        []
                        [
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.path "move_binary_format::file_format::FieldDefinition" ]
                        ]
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::StructFieldInformation::Declared",
                        0
                      |) in
                    let fields := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::option::Option")
                          []
                          [
                            Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.path "move_binary_format::file_format::FieldDefinition" ]
                          ],
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "slice")
                            []
                            [ Ty.path "move_binary_format::file_format::FieldDefinition" ],
                          "get",
                          [],
                          [ Ty.path "usize" ]
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "slice")
                                      []
                                      [ Ty.path "move_binary_format::file_format::FieldDefinition" ]
                                  ],
                                M.get_trait_method (|
                                  "core::ops::deref::Deref",
                                  Ty.apply
                                    (Ty.path "alloc::vec::Vec")
                                    []
                                    [
                                      Ty.path "move_binary_format::file_format::FieldDefinition";
                                      Ty.path "alloc::alloc::Global"
                                    ],
                                  [],
                                  [],
                                  "deref",
                                  [],
                                  []
                                |),
                                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| fields |) |) |)
                                ]
                              |)
                            |)
                          |);
                          M.read (| offset |)
                        ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_field : M.IsAssociatedFunction.C Self "field" field.
    Admitted.
    Global Typeclasses Opaque field.
    
    (*
        pub fn fields(&self) -> Option<&[FieldDefinition]> {
            match &self.field_information {
                StructFieldInformation::Native => None,
                StructFieldInformation::Declared(fields) => Some(fields),
            }
        }
    *)
    Definition fields (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Ty.apply
                (Ty.path "*")
                []
                [
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [
                      Ty.apply
                        (Ty.path "&")
                        []
                        [
                          Ty.apply
                            (Ty.path "slice")
                            []
                            [ Ty.path "move_binary_format::file_format::FieldDefinition" ]
                        ]
                    ]
                ],
              M.alloc (|
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "move_binary_format::file_format::StructDefinition",
                    "field_information"
                  |)
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "move_binary_format::file_format::StructFieldInformation::Native"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::option::Option::None"
                        []
                        [
                          Ty.apply
                            (Ty.path "&")
                            []
                            [
                              Ty.apply
                                (Ty.path "slice")
                                []
                                [ Ty.path "move_binary_format::file_format::FieldDefinition" ]
                            ]
                        ]
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::StructFieldInformation::Declared",
                        0
                      |) in
                    let fields := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        []
                        [
                          Ty.apply
                            (Ty.path "&")
                            []
                            [
                              Ty.apply
                                (Ty.path "slice")
                                []
                                [ Ty.path "move_binary_format::file_format::FieldDefinition" ]
                            ]
                        ]
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "slice")
                                      []
                                      [ Ty.path "move_binary_format::file_format::FieldDefinition" ]
                                  ],
                                M.get_trait_method (|
                                  "core::ops::deref::Deref",
                                  Ty.apply
                                    (Ty.path "alloc::vec::Vec")
                                    []
                                    [
                                      Ty.path "move_binary_format::file_format::FieldDefinition";
                                      Ty.path "alloc::alloc::Global"
                                    ],
                                  [],
                                  [],
                                  "deref",
                                  [],
                                  []
                                |),
                                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| fields |) |) |)
                                ]
                              |)
                            |)
                          |)
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_fields : M.IsAssociatedFunction.C Self "fields" fields.
    Admitted.
    Global Typeclasses Opaque fields.
  End Impl_move_binary_format_file_format_StructDefinition.
  
  (* StructRecord
    {
      name := "FieldDefinition";
      const_params := [];
      ty_params := [];
      fields :=
        [
          ("name", Ty.path "move_binary_format::file_format::IdentifierIndex");
          ("signature", Ty.path "move_binary_format::file_format::TypeSignature")
        ];
    } *)
  
  Module Impl_core_clone_Clone_for_move_binary_format_file_format_FieldDefinition.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::FieldDefinition".
    
    (* Clone *)
    Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.StructRecord
            "move_binary_format::file_format::FieldDefinition"
            []
            []
            [
              ("name",
                M.call_closure (|
                  Ty.path "move_binary_format::file_format::IdentifierIndex",
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.path "move_binary_format::file_format::IdentifierIndex",
                    [],
                    [],
                    "clone",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "move_binary_format::file_format::FieldDefinition",
                            "name"
                          |)
                        |)
                      |)
                    |)
                  ]
                |));
              ("signature",
                M.call_closure (|
                  Ty.path "move_binary_format::file_format::TypeSignature",
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.path "move_binary_format::file_format::TypeSignature",
                    [],
                    [],
                    "clone",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "move_binary_format::file_format::FieldDefinition",
                            "signature"
                          |)
                        |)
                      |)
                    |)
                  ]
                |))
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_move_binary_format_file_format_FieldDefinition.
  
  Module Impl_core_fmt_Debug_for_move_binary_format_file_format_FieldDefinition.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::FieldDefinition".
    
    (* Debug *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_associated_function (|
              Ty.path "core::fmt::Formatter",
              "debug_struct_field2_finish",
              [],
              []
            |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "FieldDefinition" |) |) |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "name" |) |) |);
              (* Unsize *)
              M.pointer_coercion
                (M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "move_binary_format::file_format::FieldDefinition",
                        "name"
                      |)
                    |)
                  |)
                |));
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "signature" |) |) |);
              (* Unsize *)
              M.pointer_coercion
                (M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.alloc (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "move_binary_format::file_format::FieldDefinition",
                            "signature"
                          |)
                        |)
                      |)
                    |)
                  |)
                |))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_move_binary_format_file_format_FieldDefinition.
  
  Module Impl_core_cmp_Eq_for_move_binary_format_file_format_FieldDefinition.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::FieldDefinition".
    
    (* Eq *)
    Definition assert_receiver_is_total_eq
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              Value.DeclaredButUndefined,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                      Value.DeclaredButUndefined,
                      [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_move_binary_format_file_format_FieldDefinition.
  
  Module Impl_core_marker_StructuralPartialEq_for_move_binary_format_file_format_FieldDefinition.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::FieldDefinition".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_move_binary_format_file_format_FieldDefinition.
  
  Module Impl_core_cmp_PartialEq_move_binary_format_file_format_FieldDefinition_for_move_binary_format_file_format_FieldDefinition.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::FieldDefinition".
    
    (* PartialEq *)
    Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          LogicalOp.and (|
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (|
                "core::cmp::PartialEq",
                Ty.path "move_binary_format::file_format::IdentifierIndex",
                [],
                [ Ty.path "move_binary_format::file_format::IdentifierIndex" ],
                "eq",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "move_binary_format::file_format::FieldDefinition",
                    "name"
                  |)
                |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| other |) |),
                    "move_binary_format::file_format::FieldDefinition",
                    "name"
                  |)
                |)
              ]
            |),
            ltac:(M.monadic
              (M.call_closure (|
                Ty.path "bool",
                M.get_trait_method (|
                  "core::cmp::PartialEq",
                  Ty.path "move_binary_format::file_format::TypeSignature",
                  [],
                  [ Ty.path "move_binary_format::file_format::TypeSignature" ],
                  "eq",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "move_binary_format::file_format::FieldDefinition",
                      "signature"
                    |)
                  |);
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| other |) |),
                      "move_binary_format::file_format::FieldDefinition",
                      "signature"
                    |)
                  |)
                ]
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "move_binary_format::file_format::FieldDefinition" ]
        Self
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_move_binary_format_file_format_FieldDefinition_for_move_binary_format_file_format_FieldDefinition.
  
  (*
  Enum Visibility
  {
    const_params := [];
    ty_params := [];
    variants :=
      [
        {
          name := "Private";
          item := StructTuple [];
        };
        {
          name := "Public";
          item := StructTuple [];
        };
        {
          name := "Friend";
          item := StructTuple [];
        }
      ];
  }
  *)
  
  Axiom IsDiscriminant_Visibility_Private :
    M.IsDiscriminant "move_binary_format::file_format::Visibility::Private" 0.
  Axiom IsDiscriminant_Visibility_Public :
    M.IsDiscriminant "move_binary_format::file_format::Visibility::Public" 1.
  Axiom IsDiscriminant_Visibility_Friend :
    M.IsDiscriminant "move_binary_format::file_format::Visibility::Friend" 3.
  
  Module Impl_core_default_Default_for_move_binary_format_file_format_Visibility.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::Visibility".
    
    (* Default *)
    Definition default (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [] =>
        ltac:(M.monadic
          (Value.StructTuple "move_binary_format::file_format::Visibility::Private" [] [] []))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::default::Default"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("default", InstanceField.Method default) ].
  End Impl_core_default_Default_for_move_binary_format_file_format_Visibility.
  
  Module Impl_core_clone_Clone_for_move_binary_format_file_format_Visibility.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::Visibility".
    
    (* Clone *)
    Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (| M.deref (| M.read (| self |) |) |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_move_binary_format_file_format_Visibility.
  
  Module Impl_core_marker_Copy_for_move_binary_format_file_format_Visibility.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::Visibility".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::Copy"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_Copy_for_move_binary_format_file_format_Visibility.
  
  Module Impl_core_fmt_Debug_for_move_binary_format_file_format_Visibility.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::Visibility".
    
    (* Debug *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_str", [], [] |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
              M.read (|
                M.match_operator (|
                  Ty.apply (Ty.path "*") [] [ Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ],
                  self,
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "move_binary_format::file_format::Visibility::Private"
                          |) in
                        M.alloc (|
                          M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "Private" |) |) |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "move_binary_format::file_format::Visibility::Public"
                          |) in
                        M.alloc (|
                          M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "Public" |) |) |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "move_binary_format::file_format::Visibility::Friend"
                          |) in
                        M.alloc (|
                          M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "Friend" |) |) |)
                        |)))
                  ]
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_move_binary_format_file_format_Visibility.
  
  Module Impl_core_cmp_Eq_for_move_binary_format_file_format_Visibility.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::Visibility".
    
    (* Eq *)
    Definition assert_receiver_is_total_eq
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.Tuple []))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_move_binary_format_file_format_Visibility.
  
  Module Impl_core_marker_StructuralPartialEq_for_move_binary_format_file_format_Visibility.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::Visibility".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_move_binary_format_file_format_Visibility.
  
  Module Impl_core_cmp_PartialEq_move_binary_format_file_format_Visibility_for_move_binary_format_file_format_Visibility.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::Visibility".
    
    (* PartialEq *)
    Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            let~ __self_discr : Ty.path "u8" :=
              M.call_closure (|
                Ty.path "u8",
                M.get_function (|
                  "core::intrinsics::discriminant_value",
                  [],
                  [ Ty.path "move_binary_format::file_format::Visibility" ]
                |),
                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
              |) in
            let~ __arg1_discr : Ty.path "u8" :=
              M.call_closure (|
                Ty.path "u8",
                M.get_function (|
                  "core::intrinsics::discriminant_value",
                  [],
                  [ Ty.path "move_binary_format::file_format::Visibility" ]
                |),
                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |) ]
              |) in
            M.alloc (|
              M.call_closure (|
                Ty.path "bool",
                BinOp.eq,
                [ M.read (| __self_discr |); M.read (| __arg1_discr |) ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "move_binary_format::file_format::Visibility" ]
        Self
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_move_binary_format_file_format_Visibility_for_move_binary_format_file_format_Visibility.
  
  Module Impl_core_cmp_PartialOrd_move_binary_format_file_format_Visibility_for_move_binary_format_file_format_Visibility.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::Visibility".
    
    (* PartialOrd *)
    Definition partial_cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            let~ __self_discr : Ty.path "u8" :=
              M.call_closure (|
                Ty.path "u8",
                M.get_function (|
                  "core::intrinsics::discriminant_value",
                  [],
                  [ Ty.path "move_binary_format::file_format::Visibility" ]
                |),
                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
              |) in
            let~ __arg1_discr : Ty.path "u8" :=
              M.call_closure (|
                Ty.path "u8",
                M.get_function (|
                  "core::intrinsics::discriminant_value",
                  [],
                  [ Ty.path "move_binary_format::file_format::Visibility" ]
                |),
                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |) ]
              |) in
            M.alloc (|
              M.call_closure (|
                Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "core::cmp::Ordering" ],
                M.get_trait_method (|
                  "core::cmp::PartialOrd",
                  Ty.path "u8",
                  [],
                  [ Ty.path "u8" ],
                  "partial_cmp",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (| M.borrow (| Pointer.Kind.Ref, __self_discr |) |)
                  |);
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (| M.borrow (| Pointer.Kind.Ref, __arg1_discr |) |)
                  |)
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialOrd"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "move_binary_format::file_format::Visibility" ]
        Self
        (* Instance *) [ ("partial_cmp", InstanceField.Method partial_cmp) ].
  End Impl_core_cmp_PartialOrd_move_binary_format_file_format_Visibility_for_move_binary_format_file_format_Visibility.
  
  Module Impl_core_cmp_Ord_for_move_binary_format_file_format_Visibility.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::Visibility".
    
    (* Ord *)
    Definition cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            let~ __self_discr : Ty.path "u8" :=
              M.call_closure (|
                Ty.path "u8",
                M.get_function (|
                  "core::intrinsics::discriminant_value",
                  [],
                  [ Ty.path "move_binary_format::file_format::Visibility" ]
                |),
                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
              |) in
            let~ __arg1_discr : Ty.path "u8" :=
              M.call_closure (|
                Ty.path "u8",
                M.get_function (|
                  "core::intrinsics::discriminant_value",
                  [],
                  [ Ty.path "move_binary_format::file_format::Visibility" ]
                |),
                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |) ]
              |) in
            M.alloc (|
              M.call_closure (|
                Ty.path "core::cmp::Ordering",
                M.get_trait_method (| "core::cmp::Ord", Ty.path "u8", [], [], "cmp", [], [] |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (| M.borrow (| Pointer.Kind.Ref, __self_discr |) |)
                  |);
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (| M.borrow (| Pointer.Kind.Ref, __arg1_discr |) |)
                  |)
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Ord"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("cmp", InstanceField.Method cmp) ].
  End Impl_core_cmp_Ord_for_move_binary_format_file_format_Visibility.
  
  
  
  Module Impl_move_binary_format_file_format_Visibility.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::Visibility".
    
    (*     pub const DEPRECATED_SCRIPT: u8 = 0x2; *)
    (* Ty.path "u8" *)
    Definition value_DEPRECATED_SCRIPT (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 2 |))).
    
    Global Instance AssociatedConstant_value_DEPRECATED_SCRIPT :
      M.IsAssociatedFunction.C Self "DEPRECATED_SCRIPT" value_DEPRECATED_SCRIPT.
    Admitted.
    Global Typeclasses Opaque value_DEPRECATED_SCRIPT.
  End Impl_move_binary_format_file_format_Visibility.
  
  Module Impl_core_convert_TryFrom_u8_for_move_binary_format_file_format_Visibility.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::Visibility".
    
    (*     type Error = (); *)
    Definition _Error : Ty.t := Ty.tuple [].
    
    (*
        fn try_from(v: u8) -> Result<Self, Self::Error> {
            match v {
                x if x == Visibility::Private as u8 => Ok(Visibility::Private),
                x if x == Visibility::Public as u8 => Ok(Visibility::Public),
                x if x == Visibility::Friend as u8 => Ok(Visibility::Friend),
                _ => Err(()),
            }
        }
    *)
    Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ v ] =>
        ltac:(M.monadic
          (let v := M.alloc (| v |) in
          M.read (|
            M.match_operator (|
              Ty.apply
                (Ty.path "*")
                []
                [
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [ Ty.path "move_binary_format::file_format::Visibility"; Ty.tuple [] ]
                ],
              v,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let x := M.copy (| γ |) in
                    let γ :=
                      M.alloc (|
                        M.call_closure (|
                          Ty.path "bool",
                          BinOp.eq,
                          [
                            M.read (| x |);
                            M.cast
                              (Ty.path "u8")
                              (M.call_closure (|
                                Ty.path "u8",
                                BinOp.Wrap.add,
                                [
                                  M.read (|
                                    get_constant (|
                                      "move_binary_format::file_format::Visibility::Private_discriminant",
                                      Ty.path "u8"
                                    |)
                                  |);
                                  Value.Integer IntegerKind.U8 0
                                ]
                              |))
                          ]
                        |)
                      |) in
                    let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        []
                        [ Ty.path "move_binary_format::file_format::Visibility"; Ty.tuple [] ]
                        [
                          Value.StructTuple
                            "move_binary_format::file_format::Visibility::Private"
                            []
                            []
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let x := M.copy (| γ |) in
                    let γ :=
                      M.alloc (|
                        M.call_closure (|
                          Ty.path "bool",
                          BinOp.eq,
                          [
                            M.read (| x |);
                            M.cast
                              (Ty.path "u8")
                              (M.call_closure (|
                                Ty.path "u8",
                                BinOp.Wrap.add,
                                [
                                  M.read (|
                                    get_constant (|
                                      "move_binary_format::file_format::Visibility::Public_discriminant",
                                      Ty.path "u8"
                                    |)
                                  |);
                                  Value.Integer IntegerKind.U8 0
                                ]
                              |))
                          ]
                        |)
                      |) in
                    let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        []
                        [ Ty.path "move_binary_format::file_format::Visibility"; Ty.tuple [] ]
                        [
                          Value.StructTuple
                            "move_binary_format::file_format::Visibility::Public"
                            []
                            []
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let x := M.copy (| γ |) in
                    let γ :=
                      M.alloc (|
                        M.call_closure (|
                          Ty.path "bool",
                          BinOp.eq,
                          [
                            M.read (| x |);
                            M.cast
                              (Ty.path "u8")
                              (M.call_closure (|
                                Ty.path "u8",
                                BinOp.Wrap.add,
                                [
                                  M.read (|
                                    get_constant (|
                                      "move_binary_format::file_format::Visibility::Friend_discriminant",
                                      Ty.path "u8"
                                    |)
                                  |);
                                  Value.Integer IntegerKind.U8 0
                                ]
                              |))
                          ]
                        |)
                      |) in
                    let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        []
                        [ Ty.path "move_binary_format::file_format::Visibility"; Ty.tuple [] ]
                        [
                          Value.StructTuple
                            "move_binary_format::file_format::Visibility::Friend"
                            []
                            []
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Err"
                        []
                        [ Ty.path "move_binary_format::file_format::Visibility"; Ty.tuple [] ]
                        [ Value.Tuple [] ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::convert::TryFrom"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "u8" ]
        Self
        (* Instance *)
        [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
  End Impl_core_convert_TryFrom_u8_for_move_binary_format_file_format_Visibility.
  
  (* StructRecord
    {
      name := "FunctionDefinition";
      const_params := [];
      ty_params := [];
      fields :=
        [
          ("function", Ty.path "move_binary_format::file_format::FunctionHandleIndex");
          ("visibility", Ty.path "move_binary_format::file_format::Visibility");
          ("is_entry", Ty.path "bool");
          ("acquires_global_resources",
            Ty.apply
              (Ty.path "alloc::vec::Vec")
              []
              [
                Ty.path "move_binary_format::file_format::StructDefinitionIndex";
                Ty.path "alloc::alloc::Global"
              ]);
          ("code",
            Ty.apply
              (Ty.path "core::option::Option")
              []
              [ Ty.path "move_binary_format::file_format::CodeUnit" ])
        ];
    } *)
  
  Module Impl_core_clone_Clone_for_move_binary_format_file_format_FunctionDefinition.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::FunctionDefinition".
    
    (* Clone *)
    Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.StructRecord
            "move_binary_format::file_format::FunctionDefinition"
            []
            []
            [
              ("function",
                M.call_closure (|
                  Ty.path "move_binary_format::file_format::FunctionHandleIndex",
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.path "move_binary_format::file_format::FunctionHandleIndex",
                    [],
                    [],
                    "clone",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "move_binary_format::file_format::FunctionDefinition",
                            "function"
                          |)
                        |)
                      |)
                    |)
                  ]
                |));
              ("visibility",
                M.call_closure (|
                  Ty.path "move_binary_format::file_format::Visibility",
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.path "move_binary_format::file_format::Visibility",
                    [],
                    [],
                    "clone",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "move_binary_format::file_format::FunctionDefinition",
                            "visibility"
                          |)
                        |)
                      |)
                    |)
                  ]
                |));
              ("is_entry",
                M.call_closure (|
                  Ty.path "bool",
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.path "bool",
                    [],
                    [],
                    "clone",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "move_binary_format::file_format::FunctionDefinition",
                            "is_entry"
                          |)
                        |)
                      |)
                    |)
                  ]
                |));
              ("acquires_global_resources",
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [
                      Ty.path "move_binary_format::file_format::StructDefinitionIndex";
                      Ty.path "alloc::alloc::Global"
                    ],
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      []
                      [
                        Ty.path "move_binary_format::file_format::StructDefinitionIndex";
                        Ty.path "alloc::alloc::Global"
                      ],
                    [],
                    [],
                    "clone",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "move_binary_format::file_format::FunctionDefinition",
                            "acquires_global_resources"
                          |)
                        |)
                      |)
                    |)
                  ]
                |));
              ("code",
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [ Ty.path "move_binary_format::file_format::CodeUnit" ],
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.apply
                      (Ty.path "core::option::Option")
                      []
                      [ Ty.path "move_binary_format::file_format::CodeUnit" ],
                    [],
                    [],
                    "clone",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "move_binary_format::file_format::FunctionDefinition",
                            "code"
                          |)
                        |)
                      |)
                    |)
                  ]
                |))
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_move_binary_format_file_format_FunctionDefinition.
  
  Module Impl_core_fmt_Debug_for_move_binary_format_file_format_FunctionDefinition.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::FunctionDefinition".
    
    (* Debug *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_associated_function (|
              Ty.path "core::fmt::Formatter",
              "debug_struct_field5_finish",
              [],
              []
            |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "FunctionDefinition" |) |) |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "function" |) |) |);
              (* Unsize *)
              M.pointer_coercion
                (M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "move_binary_format::file_format::FunctionDefinition",
                        "function"
                      |)
                    |)
                  |)
                |));
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "visibility" |) |) |);
              (* Unsize *)
              M.pointer_coercion
                (M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "move_binary_format::file_format::FunctionDefinition",
                        "visibility"
                      |)
                    |)
                  |)
                |));
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "is_entry" |) |) |);
              (* Unsize *)
              M.pointer_coercion
                (M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "move_binary_format::file_format::FunctionDefinition",
                        "is_entry"
                      |)
                    |)
                  |)
                |));
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (| mk_str (| "acquires_global_resources" |) |)
              |);
              (* Unsize *)
              M.pointer_coercion
                (M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "move_binary_format::file_format::FunctionDefinition",
                        "acquires_global_resources"
                      |)
                    |)
                  |)
                |));
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "code" |) |) |);
              (* Unsize *)
              M.pointer_coercion
                (M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.alloc (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "move_binary_format::file_format::FunctionDefinition",
                            "code"
                          |)
                        |)
                      |)
                    |)
                  |)
                |))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_move_binary_format_file_format_FunctionDefinition.
  
  Module Impl_core_default_Default_for_move_binary_format_file_format_FunctionDefinition.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::FunctionDefinition".
    
    (* Default *)
    Definition default (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [] =>
        ltac:(M.monadic
          (Value.StructRecord
            "move_binary_format::file_format::FunctionDefinition"
            []
            []
            [
              ("function",
                M.call_closure (|
                  Ty.path "move_binary_format::file_format::FunctionHandleIndex",
                  M.get_trait_method (|
                    "core::default::Default",
                    Ty.path "move_binary_format::file_format::FunctionHandleIndex",
                    [],
                    [],
                    "default",
                    [],
                    []
                  |),
                  []
                |));
              ("visibility",
                M.call_closure (|
                  Ty.path "move_binary_format::file_format::Visibility",
                  M.get_trait_method (|
                    "core::default::Default",
                    Ty.path "move_binary_format::file_format::Visibility",
                    [],
                    [],
                    "default",
                    [],
                    []
                  |),
                  []
                |));
              ("is_entry",
                M.call_closure (|
                  Ty.path "bool",
                  M.get_trait_method (|
                    "core::default::Default",
                    Ty.path "bool",
                    [],
                    [],
                    "default",
                    [],
                    []
                  |),
                  []
                |));
              ("acquires_global_resources",
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [
                      Ty.path "move_binary_format::file_format::StructDefinitionIndex";
                      Ty.path "alloc::alloc::Global"
                    ],
                  M.get_trait_method (|
                    "core::default::Default",
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      []
                      [
                        Ty.path "move_binary_format::file_format::StructDefinitionIndex";
                        Ty.path "alloc::alloc::Global"
                      ],
                    [],
                    [],
                    "default",
                    [],
                    []
                  |),
                  []
                |));
              ("code",
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [ Ty.path "move_binary_format::file_format::CodeUnit" ],
                  M.get_trait_method (|
                    "core::default::Default",
                    Ty.apply
                      (Ty.path "core::option::Option")
                      []
                      [ Ty.path "move_binary_format::file_format::CodeUnit" ],
                    [],
                    [],
                    "default",
                    [],
                    []
                  |),
                  []
                |))
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::default::Default"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("default", InstanceField.Method default) ].
  End Impl_core_default_Default_for_move_binary_format_file_format_FunctionDefinition.
  
  Module Impl_core_cmp_Eq_for_move_binary_format_file_format_FunctionDefinition.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::FunctionDefinition".
    
    (* Eq *)
    Definition assert_receiver_is_total_eq
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              Value.DeclaredButUndefined,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                      Value.DeclaredButUndefined,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                              Value.DeclaredButUndefined,
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (M.match_operator (|
                                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                      Value.DeclaredButUndefined,
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (M.match_operator (|
                                              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                              Value.DeclaredButUndefined,
                                              [
                                                fun γ =>
                                                  ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                              ]
                                            |)))
                                      ]
                                    |)))
                              ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_move_binary_format_file_format_FunctionDefinition.
  
  Module Impl_core_marker_StructuralPartialEq_for_move_binary_format_file_format_FunctionDefinition.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::FunctionDefinition".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_move_binary_format_file_format_FunctionDefinition.
  
  Module Impl_core_cmp_PartialEq_move_binary_format_file_format_FunctionDefinition_for_move_binary_format_file_format_FunctionDefinition.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::FunctionDefinition".
    
    (* PartialEq *)
    Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          LogicalOp.and (|
            LogicalOp.and (|
              LogicalOp.and (|
                LogicalOp.and (|
                  M.call_closure (|
                    Ty.path "bool",
                    M.get_trait_method (|
                      "core::cmp::PartialEq",
                      Ty.path "move_binary_format::file_format::FunctionHandleIndex",
                      [],
                      [ Ty.path "move_binary_format::file_format::FunctionHandleIndex" ],
                      "eq",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "move_binary_format::file_format::FunctionDefinition",
                          "function"
                        |)
                      |);
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| other |) |),
                          "move_binary_format::file_format::FunctionDefinition",
                          "function"
                        |)
                      |)
                    ]
                  |),
                  ltac:(M.monadic
                    (M.call_closure (|
                      Ty.path "bool",
                      M.get_trait_method (|
                        "core::cmp::PartialEq",
                        Ty.path "move_binary_format::file_format::Visibility",
                        [],
                        [ Ty.path "move_binary_format::file_format::Visibility" ],
                        "eq",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "move_binary_format::file_format::FunctionDefinition",
                            "visibility"
                          |)
                        |);
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| other |) |),
                            "move_binary_format::file_format::FunctionDefinition",
                            "visibility"
                          |)
                        |)
                      ]
                    |)))
                |),
                ltac:(M.monadic
                  (M.call_closure (|
                    Ty.path "bool",
                    BinOp.eq,
                    [
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "move_binary_format::file_format::FunctionDefinition",
                          "is_entry"
                        |)
                      |);
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| other |) |),
                          "move_binary_format::file_format::FunctionDefinition",
                          "is_entry"
                        |)
                      |)
                    ]
                  |)))
              |),
              ltac:(M.monadic
                (M.call_closure (|
                  Ty.path "bool",
                  M.get_trait_method (|
                    "core::cmp::PartialEq",
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      []
                      [
                        Ty.path "move_binary_format::file_format::StructDefinitionIndex";
                        Ty.path "alloc::alloc::Global"
                      ],
                    [],
                    [
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        []
                        [
                          Ty.path "move_binary_format::file_format::StructDefinitionIndex";
                          Ty.path "alloc::alloc::Global"
                        ]
                    ],
                    "eq",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "move_binary_format::file_format::FunctionDefinition",
                        "acquires_global_resources"
                      |)
                    |);
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| other |) |),
                        "move_binary_format::file_format::FunctionDefinition",
                        "acquires_global_resources"
                      |)
                    |)
                  ]
                |)))
            |),
            ltac:(M.monadic
              (M.call_closure (|
                Ty.path "bool",
                M.get_trait_method (|
                  "core::cmp::PartialEq",
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [ Ty.path "move_binary_format::file_format::CodeUnit" ],
                  [],
                  [
                    Ty.apply
                      (Ty.path "core::option::Option")
                      []
                      [ Ty.path "move_binary_format::file_format::CodeUnit" ]
                  ],
                  "eq",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "move_binary_format::file_format::FunctionDefinition",
                      "code"
                    |)
                  |);
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| other |) |),
                      "move_binary_format::file_format::FunctionDefinition",
                      "code"
                    |)
                  |)
                ]
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.path "move_binary_format::file_format::FunctionDefinition" ]
        Self
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_move_binary_format_file_format_FunctionDefinition_for_move_binary_format_file_format_FunctionDefinition.
  
  Module Impl_move_binary_format_file_format_FunctionDefinition.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::FunctionDefinition".
    
    (*
        pub fn is_native(&self) -> bool {
            self.code.is_none()
        }
    *)
    Definition is_native (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            Ty.path "bool",
            M.get_associated_function (|
              Ty.apply
                (Ty.path "core::option::Option")
                []
                [ Ty.path "move_binary_format::file_format::CodeUnit" ],
              "is_none",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.SubPointer.get_struct_record_field (|
                  M.deref (| M.read (| self |) |),
                  "move_binary_format::file_format::FunctionDefinition",
                  "code"
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_is_native :
      M.IsAssociatedFunction.C Self "is_native" is_native.
    Admitted.
    Global Typeclasses Opaque is_native.
    
    (*     pub const DEPRECATED_PUBLIC_BIT: u8 = 0b01; *)
    (* Ty.path "u8" *)
    Definition value_DEPRECATED_PUBLIC_BIT
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 1 |))).
    
    Global Instance AssociatedConstant_value_DEPRECATED_PUBLIC_BIT :
      M.IsAssociatedFunction.C Self "DEPRECATED_PUBLIC_BIT" value_DEPRECATED_PUBLIC_BIT.
    Admitted.
    Global Typeclasses Opaque value_DEPRECATED_PUBLIC_BIT.
    
    (*     pub const NATIVE: u8 = 0b10; *)
    (* Ty.path "u8" *)
    Definition value_NATIVE (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 2 |))).
    
    Global Instance AssociatedConstant_value_NATIVE :
      M.IsAssociatedFunction.C Self "NATIVE" value_NATIVE.
    Admitted.
    Global Typeclasses Opaque value_NATIVE.
    
    (*     pub const ENTRY: u8 = 0b100; *)
    (* Ty.path "u8" *)
    Definition value_ENTRY (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.U8 4 |))).
    
    Global Instance AssociatedConstant_value_ENTRY :
      M.IsAssociatedFunction.C Self "ENTRY" value_ENTRY.
    Admitted.
    Global Typeclasses Opaque value_ENTRY.
  End Impl_move_binary_format_file_format_FunctionDefinition.
  
  (* StructTuple
    {
      name := "TypeSignature";
      const_params := [];
      ty_params := [];
      fields := [ Ty.path "move_binary_format::file_format::SignatureToken" ];
    } *)
  
  Module Impl_core_clone_Clone_for_move_binary_format_file_format_TypeSignature.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::TypeSignature".
    
    (* Clone *)
    Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.StructTuple
            "move_binary_format::file_format::TypeSignature"
            []
            []
            [
              M.call_closure (|
                Ty.path "move_binary_format::file_format::SignatureToken",
                M.get_trait_method (|
                  "core::clone::Clone",
                  Ty.path "move_binary_format::file_format::SignatureToken",
                  [],
                  [],
                  "clone",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_tuple_field (|
                          M.deref (| M.read (| self |) |),
                          "move_binary_format::file_format::TypeSignature",
                          0
                        |)
                      |)
                    |)
                  |)
                ]
              |)
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_move_binary_format_file_format_TypeSignature.
  
  Module Impl_core_fmt_Debug_for_move_binary_format_file_format_TypeSignature.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::TypeSignature".
    
    (* Debug *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_associated_function (|
              Ty.path "core::fmt::Formatter",
              "debug_tuple_field1_finish",
              [],
              []
            |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "TypeSignature" |) |) |);
              (* Unsize *)
              M.pointer_coercion
                (M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.alloc (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_tuple_field (|
                            M.deref (| M.read (| self |) |),
                            "move_binary_format::file_format::TypeSignature",
                            0
                          |)
                        |)
                      |)
                    |)
                  |)
                |))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_move_binary_format_file_format_TypeSignature.
  
  Module Impl_core_cmp_Eq_for_move_binary_format_file_format_TypeSignature.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::TypeSignature".
    
    (* Eq *)
    Definition assert_receiver_is_total_eq
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              Value.DeclaredButUndefined,
              [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_move_binary_format_file_format_TypeSignature.
  
  Module Impl_core_hash_Hash_for_move_binary_format_file_format_TypeSignature.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::TypeSignature".
    
    (* Hash *)
    Definition hash (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ __H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let state := M.alloc (| state |) in
          M.call_closure (|
            Ty.tuple [],
            M.get_trait_method (|
              "core::hash::Hash",
              Ty.path "move_binary_format::file_format::SignatureToken",
              [],
              [],
              "hash",
              [],
              [ __H ]
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| self |) |),
                      "move_binary_format::file_format::TypeSignature",
                      0
                    |)
                  |)
                |)
              |);
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::hash::Hash"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("hash", InstanceField.Method hash) ].
  End Impl_core_hash_Hash_for_move_binary_format_file_format_TypeSignature.
  
  Module Impl_core_marker_StructuralPartialEq_for_move_binary_format_file_format_TypeSignature.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::TypeSignature".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_move_binary_format_file_format_TypeSignature.
  
  Module Impl_core_cmp_PartialEq_move_binary_format_file_format_TypeSignature_for_move_binary_format_file_format_TypeSignature.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::TypeSignature".
    
    (* PartialEq *)
    Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.path "bool",
            M.get_trait_method (|
              "core::cmp::PartialEq",
              Ty.path "move_binary_format::file_format::SignatureToken",
              [],
              [ Ty.path "move_binary_format::file_format::SignatureToken" ],
              "eq",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.SubPointer.get_struct_tuple_field (|
                  M.deref (| M.read (| self |) |),
                  "move_binary_format::file_format::TypeSignature",
                  0
                |)
              |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.SubPointer.get_struct_tuple_field (|
                  M.deref (| M.read (| other |) |),
                  "move_binary_format::file_format::TypeSignature",
                  0
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "move_binary_format::file_format::TypeSignature" ]
        Self
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_move_binary_format_file_format_TypeSignature_for_move_binary_format_file_format_TypeSignature.
  
  (* StructRecord
    {
      name := "FunctionSignature";
      const_params := [];
      ty_params := [];
      fields :=
        [
          ("return_",
            Ty.apply
              (Ty.path "alloc::vec::Vec")
              []
              [
                Ty.path "move_binary_format::file_format::SignatureToken";
                Ty.path "alloc::alloc::Global"
              ]);
          ("parameters",
            Ty.apply
              (Ty.path "alloc::vec::Vec")
              []
              [
                Ty.path "move_binary_format::file_format::SignatureToken";
                Ty.path "alloc::alloc::Global"
              ]);
          ("type_parameters",
            Ty.apply
              (Ty.path "alloc::vec::Vec")
              []
              [
                Ty.path "move_binary_format::file_format::AbilitySet";
                Ty.path "alloc::alloc::Global"
              ])
        ];
    } *)
  
  Module Impl_core_clone_Clone_for_move_binary_format_file_format_FunctionSignature.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::FunctionSignature".
    
    (* Clone *)
    Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.StructRecord
            "move_binary_format::file_format::FunctionSignature"
            []
            []
            [
              ("return_",
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [
                      Ty.path "move_binary_format::file_format::SignatureToken";
                      Ty.path "alloc::alloc::Global"
                    ],
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      []
                      [
                        Ty.path "move_binary_format::file_format::SignatureToken";
                        Ty.path "alloc::alloc::Global"
                      ],
                    [],
                    [],
                    "clone",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "move_binary_format::file_format::FunctionSignature",
                            "return_"
                          |)
                        |)
                      |)
                    |)
                  ]
                |));
              ("parameters",
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [
                      Ty.path "move_binary_format::file_format::SignatureToken";
                      Ty.path "alloc::alloc::Global"
                    ],
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      []
                      [
                        Ty.path "move_binary_format::file_format::SignatureToken";
                        Ty.path "alloc::alloc::Global"
                      ],
                    [],
                    [],
                    "clone",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "move_binary_format::file_format::FunctionSignature",
                            "parameters"
                          |)
                        |)
                      |)
                    |)
                  ]
                |));
              ("type_parameters",
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [
                      Ty.path "move_binary_format::file_format::AbilitySet";
                      Ty.path "alloc::alloc::Global"
                    ],
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      []
                      [
                        Ty.path "move_binary_format::file_format::AbilitySet";
                        Ty.path "alloc::alloc::Global"
                      ],
                    [],
                    [],
                    "clone",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "move_binary_format::file_format::FunctionSignature",
                            "type_parameters"
                          |)
                        |)
                      |)
                    |)
                  ]
                |))
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_move_binary_format_file_format_FunctionSignature.
  
  Module Impl_core_fmt_Debug_for_move_binary_format_file_format_FunctionSignature.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::FunctionSignature".
    
    (* Debug *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_associated_function (|
              Ty.path "core::fmt::Formatter",
              "debug_struct_field3_finish",
              [],
              []
            |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "FunctionSignature" |) |) |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "return_" |) |) |);
              (* Unsize *)
              M.pointer_coercion
                (M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "move_binary_format::file_format::FunctionSignature",
                        "return_"
                      |)
                    |)
                  |)
                |));
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "parameters" |) |) |);
              (* Unsize *)
              M.pointer_coercion
                (M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "move_binary_format::file_format::FunctionSignature",
                        "parameters"
                      |)
                    |)
                  |)
                |));
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "type_parameters" |) |) |);
              (* Unsize *)
              M.pointer_coercion
                (M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.alloc (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "move_binary_format::file_format::FunctionSignature",
                            "type_parameters"
                          |)
                        |)
                      |)
                    |)
                  |)
                |))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_move_binary_format_file_format_FunctionSignature.
  
  Module Impl_core_cmp_Eq_for_move_binary_format_file_format_FunctionSignature.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::FunctionSignature".
    
    (* Eq *)
    Definition assert_receiver_is_total_eq
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              Value.DeclaredButUndefined,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                      Value.DeclaredButUndefined,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                              Value.DeclaredButUndefined,
                              [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_move_binary_format_file_format_FunctionSignature.
  
  Module Impl_core_hash_Hash_for_move_binary_format_file_format_FunctionSignature.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::FunctionSignature".
    
    (* Hash *)
    Definition hash (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ __H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let state := M.alloc (| state |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.call_closure (|
                Ty.tuple [],
                M.get_trait_method (|
                  "core::hash::Hash",
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [
                      Ty.path "move_binary_format::file_format::SignatureToken";
                      Ty.path "alloc::alloc::Global"
                    ],
                  [],
                  [],
                  "hash",
                  [],
                  [ __H ]
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "move_binary_format::file_format::FunctionSignature",
                          "return_"
                        |)
                      |)
                    |)
                  |);
                  M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                ]
              |) in
            let~ _ : Ty.tuple [] :=
              M.call_closure (|
                Ty.tuple [],
                M.get_trait_method (|
                  "core::hash::Hash",
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [
                      Ty.path "move_binary_format::file_format::SignatureToken";
                      Ty.path "alloc::alloc::Global"
                    ],
                  [],
                  [],
                  "hash",
                  [],
                  [ __H ]
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "move_binary_format::file_format::FunctionSignature",
                          "parameters"
                        |)
                      |)
                    |)
                  |);
                  M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                ]
              |) in
            M.alloc (|
              M.call_closure (|
                Ty.tuple [],
                M.get_trait_method (|
                  "core::hash::Hash",
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [
                      Ty.path "move_binary_format::file_format::AbilitySet";
                      Ty.path "alloc::alloc::Global"
                    ],
                  [],
                  [],
                  "hash",
                  [],
                  [ __H ]
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "move_binary_format::file_format::FunctionSignature",
                          "type_parameters"
                        |)
                      |)
                    |)
                  |);
                  M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::hash::Hash"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("hash", InstanceField.Method hash) ].
  End Impl_core_hash_Hash_for_move_binary_format_file_format_FunctionSignature.
  
  Module Impl_core_marker_StructuralPartialEq_for_move_binary_format_file_format_FunctionSignature.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::FunctionSignature".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_move_binary_format_file_format_FunctionSignature.
  
  Module Impl_core_cmp_PartialEq_move_binary_format_file_format_FunctionSignature_for_move_binary_format_file_format_FunctionSignature.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::FunctionSignature".
    
    (* PartialEq *)
    Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          LogicalOp.and (|
            LogicalOp.and (|
              M.call_closure (|
                Ty.path "bool",
                M.get_trait_method (|
                  "core::cmp::PartialEq",
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [
                      Ty.path "move_binary_format::file_format::SignatureToken";
                      Ty.path "alloc::alloc::Global"
                    ],
                  [],
                  [
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      []
                      [
                        Ty.path "move_binary_format::file_format::SignatureToken";
                        Ty.path "alloc::alloc::Global"
                      ]
                  ],
                  "eq",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "move_binary_format::file_format::FunctionSignature",
                      "return_"
                    |)
                  |);
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| other |) |),
                      "move_binary_format::file_format::FunctionSignature",
                      "return_"
                    |)
                  |)
                ]
              |),
              ltac:(M.monadic
                (M.call_closure (|
                  Ty.path "bool",
                  M.get_trait_method (|
                    "core::cmp::PartialEq",
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      []
                      [
                        Ty.path "move_binary_format::file_format::SignatureToken";
                        Ty.path "alloc::alloc::Global"
                      ],
                    [],
                    [
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        []
                        [
                          Ty.path "move_binary_format::file_format::SignatureToken";
                          Ty.path "alloc::alloc::Global"
                        ]
                    ],
                    "eq",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "move_binary_format::file_format::FunctionSignature",
                        "parameters"
                      |)
                    |);
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| other |) |),
                        "move_binary_format::file_format::FunctionSignature",
                        "parameters"
                      |)
                    |)
                  ]
                |)))
            |),
            ltac:(M.monadic
              (M.call_closure (|
                Ty.path "bool",
                M.get_trait_method (|
                  "core::cmp::PartialEq",
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [
                      Ty.path "move_binary_format::file_format::AbilitySet";
                      Ty.path "alloc::alloc::Global"
                    ],
                  [],
                  [
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      []
                      [
                        Ty.path "move_binary_format::file_format::AbilitySet";
                        Ty.path "alloc::alloc::Global"
                      ]
                  ],
                  "eq",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "move_binary_format::file_format::FunctionSignature",
                      "type_parameters"
                    |)
                  |);
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| other |) |),
                      "move_binary_format::file_format::FunctionSignature",
                      "type_parameters"
                    |)
                  |)
                ]
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.path "move_binary_format::file_format::FunctionSignature" ]
        Self
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_move_binary_format_file_format_FunctionSignature_for_move_binary_format_file_format_FunctionSignature.
  
  (* StructTuple
    {
      name := "Signature";
      const_params := [];
      ty_params := [];
      fields :=
        [
          Ty.apply
            (Ty.path "alloc::vec::Vec")
            []
            [
              Ty.path "move_binary_format::file_format::SignatureToken";
              Ty.path "alloc::alloc::Global"
            ]
        ];
    } *)
  
  Module Impl_core_clone_Clone_for_move_binary_format_file_format_Signature.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::Signature".
    
    (* Clone *)
    Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.StructTuple
            "move_binary_format::file_format::Signature"
            []
            []
            [
              M.call_closure (|
                Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  []
                  [
                    Ty.path "move_binary_format::file_format::SignatureToken";
                    Ty.path "alloc::alloc::Global"
                  ],
                M.get_trait_method (|
                  "core::clone::Clone",
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [
                      Ty.path "move_binary_format::file_format::SignatureToken";
                      Ty.path "alloc::alloc::Global"
                    ],
                  [],
                  [],
                  "clone",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_tuple_field (|
                          M.deref (| M.read (| self |) |),
                          "move_binary_format::file_format::Signature",
                          0
                        |)
                      |)
                    |)
                  |)
                ]
              |)
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_move_binary_format_file_format_Signature.
  
  Module Impl_core_fmt_Debug_for_move_binary_format_file_format_Signature.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::Signature".
    
    (* Debug *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_associated_function (|
              Ty.path "core::fmt::Formatter",
              "debug_tuple_field1_finish",
              [],
              []
            |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "Signature" |) |) |);
              (* Unsize *)
              M.pointer_coercion
                (M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.alloc (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_tuple_field (|
                            M.deref (| M.read (| self |) |),
                            "move_binary_format::file_format::Signature",
                            0
                          |)
                        |)
                      |)
                    |)
                  |)
                |))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_move_binary_format_file_format_Signature.
  
  Module Impl_core_default_Default_for_move_binary_format_file_format_Signature.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::Signature".
    
    (* Default *)
    Definition default (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [] =>
        ltac:(M.monadic
          (Value.StructTuple
            "move_binary_format::file_format::Signature"
            []
            []
            [
              M.call_closure (|
                Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  []
                  [
                    Ty.path "move_binary_format::file_format::SignatureToken";
                    Ty.path "alloc::alloc::Global"
                  ],
                M.get_trait_method (|
                  "core::default::Default",
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [
                      Ty.path "move_binary_format::file_format::SignatureToken";
                      Ty.path "alloc::alloc::Global"
                    ],
                  [],
                  [],
                  "default",
                  [],
                  []
                |),
                []
              |)
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::default::Default"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("default", InstanceField.Method default) ].
  End Impl_core_default_Default_for_move_binary_format_file_format_Signature.
  
  Module Impl_core_cmp_Eq_for_move_binary_format_file_format_Signature.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::Signature".
    
    (* Eq *)
    Definition assert_receiver_is_total_eq
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              Value.DeclaredButUndefined,
              [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_move_binary_format_file_format_Signature.
  
  Module Impl_core_hash_Hash_for_move_binary_format_file_format_Signature.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::Signature".
    
    (* Hash *)
    Definition hash (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ __H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let state := M.alloc (| state |) in
          M.call_closure (|
            Ty.tuple [],
            M.get_trait_method (|
              "core::hash::Hash",
              Ty.apply
                (Ty.path "alloc::vec::Vec")
                []
                [
                  Ty.path "move_binary_format::file_format::SignatureToken";
                  Ty.path "alloc::alloc::Global"
                ],
              [],
              [],
              "hash",
              [],
              [ __H ]
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| self |) |),
                      "move_binary_format::file_format::Signature",
                      0
                    |)
                  |)
                |)
              |);
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::hash::Hash"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("hash", InstanceField.Method hash) ].
  End Impl_core_hash_Hash_for_move_binary_format_file_format_Signature.
  
  Module Impl_core_marker_StructuralPartialEq_for_move_binary_format_file_format_Signature.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::Signature".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_move_binary_format_file_format_Signature.
  
  Module Impl_core_cmp_PartialEq_move_binary_format_file_format_Signature_for_move_binary_format_file_format_Signature.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::Signature".
    
    (* PartialEq *)
    Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.path "bool",
            M.get_trait_method (|
              "core::cmp::PartialEq",
              Ty.apply
                (Ty.path "alloc::vec::Vec")
                []
                [
                  Ty.path "move_binary_format::file_format::SignatureToken";
                  Ty.path "alloc::alloc::Global"
                ],
              [],
              [
                Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  []
                  [
                    Ty.path "move_binary_format::file_format::SignatureToken";
                    Ty.path "alloc::alloc::Global"
                  ]
              ],
              "eq",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.SubPointer.get_struct_tuple_field (|
                  M.deref (| M.read (| self |) |),
                  "move_binary_format::file_format::Signature",
                  0
                |)
              |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.SubPointer.get_struct_tuple_field (|
                  M.deref (| M.read (| other |) |),
                  "move_binary_format::file_format::Signature",
                  0
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "move_binary_format::file_format::Signature" ]
        Self
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_move_binary_format_file_format_Signature_for_move_binary_format_file_format_Signature.
  
  Module Impl_core_cmp_Ord_for_move_binary_format_file_format_Signature.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::Signature".
    
    (* Ord *)
    Definition cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.path "core::cmp::Ordering",
            M.get_trait_method (|
              "core::cmp::Ord",
              Ty.apply
                (Ty.path "alloc::vec::Vec")
                []
                [
                  Ty.path "move_binary_format::file_format::SignatureToken";
                  Ty.path "alloc::alloc::Global"
                ],
              [],
              [],
              "cmp",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| self |) |),
                      "move_binary_format::file_format::Signature",
                      0
                    |)
                  |)
                |)
              |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| other |) |),
                      "move_binary_format::file_format::Signature",
                      0
                    |)
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Ord"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("cmp", InstanceField.Method cmp) ].
  End Impl_core_cmp_Ord_for_move_binary_format_file_format_Signature.
  
  Module Impl_core_cmp_PartialOrd_move_binary_format_file_format_Signature_for_move_binary_format_file_format_Signature.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::Signature".
    
    (* PartialOrd *)
    Definition partial_cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "core::cmp::Ordering" ],
            M.get_trait_method (|
              "core::cmp::PartialOrd",
              Ty.apply
                (Ty.path "alloc::vec::Vec")
                []
                [
                  Ty.path "move_binary_format::file_format::SignatureToken";
                  Ty.path "alloc::alloc::Global"
                ],
              [],
              [
                Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  []
                  [
                    Ty.path "move_binary_format::file_format::SignatureToken";
                    Ty.path "alloc::alloc::Global"
                  ]
              ],
              "partial_cmp",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| self |) |),
                      "move_binary_format::file_format::Signature",
                      0
                    |)
                  |)
                |)
              |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| other |) |),
                      "move_binary_format::file_format::Signature",
                      0
                    |)
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialOrd"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "move_binary_format::file_format::Signature" ]
        Self
        (* Instance *) [ ("partial_cmp", InstanceField.Method partial_cmp) ].
  End Impl_core_cmp_PartialOrd_move_binary_format_file_format_Signature_for_move_binary_format_file_format_Signature.
  
  Module Impl_move_binary_format_file_format_Signature.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::Signature".
    
    (*
        pub fn len(&self) -> usize {
            self.0.len()
        }
    *)
    Definition len (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            Ty.path "usize",
            M.get_associated_function (|
              Ty.apply
                (Ty.path "alloc::vec::Vec")
                []
                [
                  Ty.path "move_binary_format::file_format::SignatureToken";
                  Ty.path "alloc::alloc::Global"
                ],
              "len",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.SubPointer.get_struct_tuple_field (|
                  M.deref (| M.read (| self |) |),
                  "move_binary_format::file_format::Signature",
                  0
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_len : M.IsAssociatedFunction.C Self "len" len.
    Admitted.
    Global Typeclasses Opaque len.
    
    (*
        pub fn is_empty(&self) -> bool {
            self.0.is_empty()
        }
    *)
    Definition is_empty (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            Ty.path "bool",
            M.get_associated_function (|
              Ty.apply
                (Ty.path "alloc::vec::Vec")
                []
                [
                  Ty.path "move_binary_format::file_format::SignatureToken";
                  Ty.path "alloc::alloc::Global"
                ],
              "is_empty",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.SubPointer.get_struct_tuple_field (|
                  M.deref (| M.read (| self |) |),
                  "move_binary_format::file_format::Signature",
                  0
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_is_empty : M.IsAssociatedFunction.C Self "is_empty" is_empty.
    Admitted.
    Global Typeclasses Opaque is_empty.
  End Impl_move_binary_format_file_format_Signature.
  
  Axiom TypeParameterIndex :
    (Ty.path "move_binary_format::file_format::TypeParameterIndex") = (Ty.path "u16").
  
  (*
  Enum Ability
  {
    const_params := [];
    ty_params := [];
    variants :=
      [
        {
          name := "Copy";
          item := StructTuple [];
        };
        {
          name := "Drop";
          item := StructTuple [];
        };
        {
          name := "Store";
          item := StructTuple [];
        };
        {
          name := "Key";
          item := StructTuple [];
        }
      ];
  }
  *)
  
  Axiom IsDiscriminant_Ability_Copy :
    M.IsDiscriminant "move_binary_format::file_format::Ability::Copy" 1.
  Axiom IsDiscriminant_Ability_Drop :
    M.IsDiscriminant "move_binary_format::file_format::Ability::Drop" 2.
  Axiom IsDiscriminant_Ability_Store :
    M.IsDiscriminant "move_binary_format::file_format::Ability::Store" 4.
  Axiom IsDiscriminant_Ability_Key :
    M.IsDiscriminant "move_binary_format::file_format::Ability::Key" 8.
  
  Module Impl_core_fmt_Debug_for_move_binary_format_file_format_Ability.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::Ability".
    
    (* Debug *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_str", [], [] |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
              M.read (|
                M.match_operator (|
                  Ty.apply (Ty.path "*") [] [ Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ],
                  self,
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "move_binary_format::file_format::Ability::Copy"
                          |) in
                        M.alloc (|
                          M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "Copy" |) |) |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "move_binary_format::file_format::Ability::Drop"
                          |) in
                        M.alloc (|
                          M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "Drop" |) |) |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "move_binary_format::file_format::Ability::Store"
                          |) in
                        M.alloc (|
                          M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "Store" |) |) |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "move_binary_format::file_format::Ability::Key"
                          |) in
                        M.alloc (|
                          M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "Key" |) |) |)
                        |)))
                  ]
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_move_binary_format_file_format_Ability.
  
  Module Impl_core_clone_Clone_for_move_binary_format_file_format_Ability.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::Ability".
    
    (* Clone *)
    Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (| M.deref (| M.read (| self |) |) |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_move_binary_format_file_format_Ability.
  
  Module Impl_core_cmp_Eq_for_move_binary_format_file_format_Ability.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::Ability".
    
    (* Eq *)
    Definition assert_receiver_is_total_eq
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.Tuple []))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_move_binary_format_file_format_Ability.
  
  Module Impl_core_marker_Copy_for_move_binary_format_file_format_Ability.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::Ability".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::Copy"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_Copy_for_move_binary_format_file_format_Ability.
  
  Module Impl_core_hash_Hash_for_move_binary_format_file_format_Ability.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::Ability".
    
    (* Hash *)
    Definition hash (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ __H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let state := M.alloc (| state |) in
          M.read (|
            let~ __self_discr : Ty.path "u8" :=
              M.call_closure (|
                Ty.path "u8",
                M.get_function (|
                  "core::intrinsics::discriminant_value",
                  [],
                  [ Ty.path "move_binary_format::file_format::Ability" ]
                |),
                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
              |) in
            M.alloc (|
              M.call_closure (|
                Ty.tuple [],
                M.get_trait_method (|
                  "core::hash::Hash",
                  Ty.path "u8",
                  [],
                  [],
                  "hash",
                  [],
                  [ __H ]
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (| M.borrow (| Pointer.Kind.Ref, __self_discr |) |)
                  |);
                  M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::hash::Hash"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("hash", InstanceField.Method hash) ].
  End Impl_core_hash_Hash_for_move_binary_format_file_format_Ability.
  
  Module Impl_core_cmp_Ord_for_move_binary_format_file_format_Ability.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::Ability".
    
    (* Ord *)
    Definition cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            let~ __self_discr : Ty.path "u8" :=
              M.call_closure (|
                Ty.path "u8",
                M.get_function (|
                  "core::intrinsics::discriminant_value",
                  [],
                  [ Ty.path "move_binary_format::file_format::Ability" ]
                |),
                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
              |) in
            let~ __arg1_discr : Ty.path "u8" :=
              M.call_closure (|
                Ty.path "u8",
                M.get_function (|
                  "core::intrinsics::discriminant_value",
                  [],
                  [ Ty.path "move_binary_format::file_format::Ability" ]
                |),
                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |) ]
              |) in
            M.alloc (|
              M.call_closure (|
                Ty.path "core::cmp::Ordering",
                M.get_trait_method (| "core::cmp::Ord", Ty.path "u8", [], [], "cmp", [], [] |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (| M.borrow (| Pointer.Kind.Ref, __self_discr |) |)
                  |);
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (| M.borrow (| Pointer.Kind.Ref, __arg1_discr |) |)
                  |)
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Ord"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("cmp", InstanceField.Method cmp) ].
  End Impl_core_cmp_Ord_for_move_binary_format_file_format_Ability.
  
  Module Impl_core_marker_StructuralPartialEq_for_move_binary_format_file_format_Ability.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::Ability".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_move_binary_format_file_format_Ability.
  
  Module Impl_core_cmp_PartialEq_move_binary_format_file_format_Ability_for_move_binary_format_file_format_Ability.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::Ability".
    
    (* PartialEq *)
    Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            let~ __self_discr : Ty.path "u8" :=
              M.call_closure (|
                Ty.path "u8",
                M.get_function (|
                  "core::intrinsics::discriminant_value",
                  [],
                  [ Ty.path "move_binary_format::file_format::Ability" ]
                |),
                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
              |) in
            let~ __arg1_discr : Ty.path "u8" :=
              M.call_closure (|
                Ty.path "u8",
                M.get_function (|
                  "core::intrinsics::discriminant_value",
                  [],
                  [ Ty.path "move_binary_format::file_format::Ability" ]
                |),
                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |) ]
              |) in
            M.alloc (|
              M.call_closure (|
                Ty.path "bool",
                BinOp.eq,
                [ M.read (| __self_discr |); M.read (| __arg1_discr |) ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "move_binary_format::file_format::Ability" ]
        Self
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_move_binary_format_file_format_Ability_for_move_binary_format_file_format_Ability.
  
  Module Impl_core_cmp_PartialOrd_move_binary_format_file_format_Ability_for_move_binary_format_file_format_Ability.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::Ability".
    
    (* PartialOrd *)
    Definition partial_cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            let~ __self_discr : Ty.path "u8" :=
              M.call_closure (|
                Ty.path "u8",
                M.get_function (|
                  "core::intrinsics::discriminant_value",
                  [],
                  [ Ty.path "move_binary_format::file_format::Ability" ]
                |),
                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
              |) in
            let~ __arg1_discr : Ty.path "u8" :=
              M.call_closure (|
                Ty.path "u8",
                M.get_function (|
                  "core::intrinsics::discriminant_value",
                  [],
                  [ Ty.path "move_binary_format::file_format::Ability" ]
                |),
                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |) ]
              |) in
            M.alloc (|
              M.call_closure (|
                Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "core::cmp::Ordering" ],
                M.get_trait_method (|
                  "core::cmp::PartialOrd",
                  Ty.path "u8",
                  [],
                  [ Ty.path "u8" ],
                  "partial_cmp",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (| M.borrow (| Pointer.Kind.Ref, __self_discr |) |)
                  |);
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (| M.borrow (| Pointer.Kind.Ref, __arg1_discr |) |)
                  |)
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialOrd"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "move_binary_format::file_format::Ability" ]
        Self
        (* Instance *) [ ("partial_cmp", InstanceField.Method partial_cmp) ].
  End Impl_core_cmp_PartialOrd_move_binary_format_file_format_Ability_for_move_binary_format_file_format_Ability.
  
  Module Impl_move_binary_format_file_format_Ability.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::Ability".
    
    (*
        fn from_u8(u: u8) -> Option<Self> {
            match u {
                0x1 => Some(Ability::Copy),
                0x2 => Some(Ability::Drop),
                0x4 => Some(Ability::Store),
                0x8 => Some(Ability::Key),
                _ => None,
            }
        }
    *)
    Definition from_u8 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ u ] =>
        ltac:(M.monadic
          (let u := M.alloc (| u |) in
          M.read (|
            M.match_operator (|
              Ty.apply
                (Ty.path "*")
                []
                [
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [ Ty.path "move_binary_format::file_format::Ability" ]
                ],
              u,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer IntegerKind.U8 1
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        []
                        [ Ty.path "move_binary_format::file_format::Ability" ]
                        [
                          Value.StructTuple
                            "move_binary_format::file_format::Ability::Copy"
                            []
                            []
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer IntegerKind.U8 2
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        []
                        [ Ty.path "move_binary_format::file_format::Ability" ]
                        [
                          Value.StructTuple
                            "move_binary_format::file_format::Ability::Drop"
                            []
                            []
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer IntegerKind.U8 4
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        []
                        [ Ty.path "move_binary_format::file_format::Ability" ]
                        [
                          Value.StructTuple
                            "move_binary_format::file_format::Ability::Store"
                            []
                            []
                            []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      is_constant_or_break_match (|
                        M.read (| γ |),
                        Value.Integer IntegerKind.U8 8
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        []
                        [ Ty.path "move_binary_format::file_format::Ability" ]
                        [ Value.StructTuple "move_binary_format::file_format::Ability::Key" [] [] []
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.StructTuple
                        "core::option::Option::None"
                        []
                        [ Ty.path "move_binary_format::file_format::Ability" ]
                        []
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_from_u8 : M.IsAssociatedFunction.C Self "from_u8" from_u8.
    Admitted.
    Global Typeclasses Opaque from_u8.
    
    (*
        pub fn requires(self) -> Self {
            match self {
                Self::Copy => Ability::Copy,
                Self::Drop => Ability::Drop,
                Self::Store => Ability::Store,
                Self::Key => Ability::Store,
            }
        }
    *)
    Definition requires (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.path "move_binary_format::file_format::Ability" ],
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_struct_tuple (| γ, "move_binary_format::file_format::Ability::Copy" |) in
                    M.alloc (|
                      Value.StructTuple "move_binary_format::file_format::Ability::Copy" [] [] []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_struct_tuple (| γ, "move_binary_format::file_format::Ability::Drop" |) in
                    M.alloc (|
                      Value.StructTuple "move_binary_format::file_format::Ability::Drop" [] [] []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "move_binary_format::file_format::Ability::Store"
                      |) in
                    M.alloc (|
                      Value.StructTuple "move_binary_format::file_format::Ability::Store" [] [] []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_struct_tuple (| γ, "move_binary_format::file_format::Ability::Key" |) in
                    M.alloc (|
                      Value.StructTuple "move_binary_format::file_format::Ability::Store" [] [] []
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_requires : M.IsAssociatedFunction.C Self "requires" requires.
    Admitted.
    Global Typeclasses Opaque requires.
    
    (*
        pub fn required_by(self) -> AbilitySet {
            match self {
                Self::Copy => AbilitySet::EMPTY | Ability::Copy,
                Self::Drop => AbilitySet::EMPTY | Ability::Drop,
                Self::Store => AbilitySet::EMPTY | Ability::Store | Ability::Key,
                Self::Key => AbilitySet::EMPTY,
            }
        }
    *)
    Definition required_by (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.path "move_binary_format::file_format::AbilitySet" ],
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_struct_tuple (| γ, "move_binary_format::file_format::Ability::Copy" |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.path "move_binary_format::file_format::AbilitySet",
                        M.get_trait_method (|
                          "core::ops::bit::BitOr",
                          Ty.path "move_binary_format::file_format::AbilitySet",
                          [],
                          [ Ty.path "move_binary_format::file_format::Ability" ],
                          "bitor",
                          [],
                          []
                        |),
                        [
                          M.read (|
                            get_associated_constant (|
                              Ty.path "move_binary_format::file_format::AbilitySet",
                              "EMPTY",
                              Ty.path "move_binary_format::file_format::AbilitySet"
                            |)
                          |);
                          Value.StructTuple
                            "move_binary_format::file_format::Ability::Copy"
                            []
                            []
                            []
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_struct_tuple (| γ, "move_binary_format::file_format::Ability::Drop" |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.path "move_binary_format::file_format::AbilitySet",
                        M.get_trait_method (|
                          "core::ops::bit::BitOr",
                          Ty.path "move_binary_format::file_format::AbilitySet",
                          [],
                          [ Ty.path "move_binary_format::file_format::Ability" ],
                          "bitor",
                          [],
                          []
                        |),
                        [
                          M.read (|
                            get_associated_constant (|
                              Ty.path "move_binary_format::file_format::AbilitySet",
                              "EMPTY",
                              Ty.path "move_binary_format::file_format::AbilitySet"
                            |)
                          |);
                          Value.StructTuple
                            "move_binary_format::file_format::Ability::Drop"
                            []
                            []
                            []
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "move_binary_format::file_format::Ability::Store"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.path "move_binary_format::file_format::AbilitySet",
                        M.get_trait_method (|
                          "core::ops::bit::BitOr",
                          Ty.path "move_binary_format::file_format::AbilitySet",
                          [],
                          [ Ty.path "move_binary_format::file_format::Ability" ],
                          "bitor",
                          [],
                          []
                        |),
                        [
                          M.call_closure (|
                            Ty.path "move_binary_format::file_format::AbilitySet",
                            M.get_trait_method (|
                              "core::ops::bit::BitOr",
                              Ty.path "move_binary_format::file_format::AbilitySet",
                              [],
                              [ Ty.path "move_binary_format::file_format::Ability" ],
                              "bitor",
                              [],
                              []
                            |),
                            [
                              M.read (|
                                get_associated_constant (|
                                  Ty.path "move_binary_format::file_format::AbilitySet",
                                  "EMPTY",
                                  Ty.path "move_binary_format::file_format::AbilitySet"
                                |)
                              |);
                              Value.StructTuple
                                "move_binary_format::file_format::Ability::Store"
                                []
                                []
                                []
                            ]
                          |);
                          Value.StructTuple "move_binary_format::file_format::Ability::Key" [] [] []
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_struct_tuple (| γ, "move_binary_format::file_format::Ability::Key" |) in
                    get_associated_constant (|
                      Ty.path "move_binary_format::file_format::AbilitySet",
                      "EMPTY",
                      Ty.path "move_binary_format::file_format::AbilitySet"
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_required_by :
      M.IsAssociatedFunction.C Self "required_by" required_by.
    Admitted.
    Global Typeclasses Opaque required_by.
  End Impl_move_binary_format_file_format_Ability.
  
  (* StructTuple
    {
      name := "AbilitySet";
      const_params := [];
      ty_params := [];
      fields := [ Ty.path "u8" ];
    } *)
  
  Module Impl_core_clone_Clone_for_move_binary_format_file_format_AbilitySet.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::AbilitySet".
    
    (* Clone *)
    Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.path "move_binary_format::file_format::AbilitySet" ],
              Value.DeclaredButUndefined,
              [ fun γ => ltac:(M.monadic (M.deref (| M.read (| self |) |))) ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_move_binary_format_file_format_AbilitySet.
  
  Module Impl_core_cmp_Eq_for_move_binary_format_file_format_AbilitySet.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::AbilitySet".
    
    (* Eq *)
    Definition assert_receiver_is_total_eq
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              Value.DeclaredButUndefined,
              [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_move_binary_format_file_format_AbilitySet.
  
  Module Impl_core_marker_Copy_for_move_binary_format_file_format_AbilitySet.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::AbilitySet".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::Copy"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_Copy_for_move_binary_format_file_format_AbilitySet.
  
  Module Impl_core_hash_Hash_for_move_binary_format_file_format_AbilitySet.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::AbilitySet".
    
    (* Hash *)
    Definition hash (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ __H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let state := M.alloc (| state |) in
          M.call_closure (|
            Ty.tuple [],
            M.get_trait_method (| "core::hash::Hash", Ty.path "u8", [], [], "hash", [], [ __H ] |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| self |) |),
                      "move_binary_format::file_format::AbilitySet",
                      0
                    |)
                  |)
                |)
              |);
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::hash::Hash"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("hash", InstanceField.Method hash) ].
  End Impl_core_hash_Hash_for_move_binary_format_file_format_AbilitySet.
  
  Module Impl_core_cmp_Ord_for_move_binary_format_file_format_AbilitySet.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::AbilitySet".
    
    (* Ord *)
    Definition cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.path "core::cmp::Ordering",
            M.get_trait_method (| "core::cmp::Ord", Ty.path "u8", [], [], "cmp", [], [] |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| self |) |),
                      "move_binary_format::file_format::AbilitySet",
                      0
                    |)
                  |)
                |)
              |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| other |) |),
                      "move_binary_format::file_format::AbilitySet",
                      0
                    |)
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Ord"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("cmp", InstanceField.Method cmp) ].
  End Impl_core_cmp_Ord_for_move_binary_format_file_format_AbilitySet.
  
  Module Impl_core_marker_StructuralPartialEq_for_move_binary_format_file_format_AbilitySet.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::AbilitySet".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_move_binary_format_file_format_AbilitySet.
  
  Module Impl_core_cmp_PartialEq_move_binary_format_file_format_AbilitySet_for_move_binary_format_file_format_AbilitySet.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::AbilitySet".
    
    (* PartialEq *)
    Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.path "bool",
            BinOp.eq,
            [
              M.read (|
                M.SubPointer.get_struct_tuple_field (|
                  M.deref (| M.read (| self |) |),
                  "move_binary_format::file_format::AbilitySet",
                  0
                |)
              |);
              M.read (|
                M.SubPointer.get_struct_tuple_field (|
                  M.deref (| M.read (| other |) |),
                  "move_binary_format::file_format::AbilitySet",
                  0
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "move_binary_format::file_format::AbilitySet" ]
        Self
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_move_binary_format_file_format_AbilitySet_for_move_binary_format_file_format_AbilitySet.
  
  Module Impl_core_cmp_PartialOrd_move_binary_format_file_format_AbilitySet_for_move_binary_format_file_format_AbilitySet.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::AbilitySet".
    
    (* PartialOrd *)
    Definition partial_cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "core::cmp::Ordering" ],
            M.get_trait_method (|
              "core::cmp::PartialOrd",
              Ty.path "u8",
              [],
              [ Ty.path "u8" ],
              "partial_cmp",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| self |) |),
                      "move_binary_format::file_format::AbilitySet",
                      0
                    |)
                  |)
                |)
              |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| other |) |),
                      "move_binary_format::file_format::AbilitySet",
                      0
                    |)
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialOrd"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "move_binary_format::file_format::AbilitySet" ]
        Self
        (* Instance *) [ ("partial_cmp", InstanceField.Method partial_cmp) ].
  End Impl_core_cmp_PartialOrd_move_binary_format_file_format_AbilitySet_for_move_binary_format_file_format_AbilitySet.
  
  
  
  Module Impl_move_binary_format_file_format_AbilitySet.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::AbilitySet".
    
    (*     pub const EMPTY: Self = Self(0); *)
    (* Ty.path "move_binary_format::file_format::AbilitySet" *)
    Definition value_EMPTY (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      ltac:(M.monadic
        (M.alloc (|
          Value.StructTuple
            "move_binary_format::file_format::AbilitySet"
            []
            []
            [ Value.Integer IntegerKind.U8 0 ]
        |))).
    
    Global Instance AssociatedConstant_value_EMPTY :
      M.IsAssociatedFunction.C Self "EMPTY" value_EMPTY.
    Admitted.
    Global Typeclasses Opaque value_EMPTY.
    
    (*
        pub const PRIMITIVES: AbilitySet =
            Self((Ability::Copy as u8) | (Ability::Drop as u8) | (Ability::Store as u8));
    *)
    (* Ty.path "move_binary_format::file_format::AbilitySet" *)
    Definition value_PRIMITIVES (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      ltac:(M.monadic
        (M.alloc (|
          Value.StructTuple
            "move_binary_format::file_format::AbilitySet"
            []
            []
            [
              M.call_closure (|
                Ty.path "u8",
                BinOp.Wrap.bit_or,
                [
                  M.call_closure (|
                    Ty.path "u8",
                    BinOp.Wrap.bit_or,
                    [
                      M.cast
                        (Ty.path "u8")
                        (M.call_closure (|
                          Ty.path "u8",
                          BinOp.Wrap.add,
                          [
                            M.read (|
                              get_constant (|
                                "move_binary_format::file_format::Ability::Copy_discriminant",
                                Ty.path "u8"
                              |)
                            |);
                            Value.Integer IntegerKind.U8 0
                          ]
                        |));
                      M.cast
                        (Ty.path "u8")
                        (M.call_closure (|
                          Ty.path "u8",
                          BinOp.Wrap.add,
                          [
                            M.read (|
                              get_constant (|
                                "move_binary_format::file_format::Ability::Drop_discriminant",
                                Ty.path "u8"
                              |)
                            |);
                            Value.Integer IntegerKind.U8 0
                          ]
                        |))
                    ]
                  |);
                  M.cast
                    (Ty.path "u8")
                    (M.call_closure (|
                      Ty.path "u8",
                      BinOp.Wrap.add,
                      [
                        M.read (|
                          get_constant (|
                            "move_binary_format::file_format::Ability::Store_discriminant",
                            Ty.path "u8"
                          |)
                        |);
                        Value.Integer IntegerKind.U8 0
                      ]
                    |))
                ]
              |)
            ]
        |))).
    
    Global Instance AssociatedConstant_value_PRIMITIVES :
      M.IsAssociatedFunction.C Self "PRIMITIVES" value_PRIMITIVES.
    Admitted.
    Global Typeclasses Opaque value_PRIMITIVES.
    
    (*     pub const REFERENCES: AbilitySet = Self((Ability::Copy as u8) | (Ability::Drop as u8)); *)
    (* Ty.path "move_binary_format::file_format::AbilitySet" *)
    Definition value_REFERENCES (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      ltac:(M.monadic
        (M.alloc (|
          Value.StructTuple
            "move_binary_format::file_format::AbilitySet"
            []
            []
            [
              M.call_closure (|
                Ty.path "u8",
                BinOp.Wrap.bit_or,
                [
                  M.cast
                    (Ty.path "u8")
                    (M.call_closure (|
                      Ty.path "u8",
                      BinOp.Wrap.add,
                      [
                        M.read (|
                          get_constant (|
                            "move_binary_format::file_format::Ability::Copy_discriminant",
                            Ty.path "u8"
                          |)
                        |);
                        Value.Integer IntegerKind.U8 0
                      ]
                    |));
                  M.cast
                    (Ty.path "u8")
                    (M.call_closure (|
                      Ty.path "u8",
                      BinOp.Wrap.add,
                      [
                        M.read (|
                          get_constant (|
                            "move_binary_format::file_format::Ability::Drop_discriminant",
                            Ty.path "u8"
                          |)
                        |);
                        Value.Integer IntegerKind.U8 0
                      ]
                    |))
                ]
              |)
            ]
        |))).
    
    Global Instance AssociatedConstant_value_REFERENCES :
      M.IsAssociatedFunction.C Self "REFERENCES" value_REFERENCES.
    Admitted.
    Global Typeclasses Opaque value_REFERENCES.
    
    (*     pub const SIGNER: AbilitySet = Self(Ability::Drop as u8); *)
    (* Ty.path "move_binary_format::file_format::AbilitySet" *)
    Definition value_SIGNER (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      ltac:(M.monadic
        (M.alloc (|
          Value.StructTuple
            "move_binary_format::file_format::AbilitySet"
            []
            []
            [
              M.cast
                (Ty.path "u8")
                (M.call_closure (|
                  Ty.path "u8",
                  BinOp.Wrap.add,
                  [
                    M.read (|
                      get_constant (|
                        "move_binary_format::file_format::Ability::Drop_discriminant",
                        Ty.path "u8"
                      |)
                    |);
                    Value.Integer IntegerKind.U8 0
                  ]
                |))
            ]
        |))).
    
    Global Instance AssociatedConstant_value_SIGNER :
      M.IsAssociatedFunction.C Self "SIGNER" value_SIGNER.
    Admitted.
    Global Typeclasses Opaque value_SIGNER.
    
    (*
        pub const VECTOR: AbilitySet =
            Self((Ability::Copy as u8) | (Ability::Drop as u8) | (Ability::Store as u8));
    *)
    (* Ty.path "move_binary_format::file_format::AbilitySet" *)
    Definition value_VECTOR (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      ltac:(M.monadic
        (M.alloc (|
          Value.StructTuple
            "move_binary_format::file_format::AbilitySet"
            []
            []
            [
              M.call_closure (|
                Ty.path "u8",
                BinOp.Wrap.bit_or,
                [
                  M.call_closure (|
                    Ty.path "u8",
                    BinOp.Wrap.bit_or,
                    [
                      M.cast
                        (Ty.path "u8")
                        (M.call_closure (|
                          Ty.path "u8",
                          BinOp.Wrap.add,
                          [
                            M.read (|
                              get_constant (|
                                "move_binary_format::file_format::Ability::Copy_discriminant",
                                Ty.path "u8"
                              |)
                            |);
                            Value.Integer IntegerKind.U8 0
                          ]
                        |));
                      M.cast
                        (Ty.path "u8")
                        (M.call_closure (|
                          Ty.path "u8",
                          BinOp.Wrap.add,
                          [
                            M.read (|
                              get_constant (|
                                "move_binary_format::file_format::Ability::Drop_discriminant",
                                Ty.path "u8"
                              |)
                            |);
                            Value.Integer IntegerKind.U8 0
                          ]
                        |))
                    ]
                  |);
                  M.cast
                    (Ty.path "u8")
                    (M.call_closure (|
                      Ty.path "u8",
                      BinOp.Wrap.add,
                      [
                        M.read (|
                          get_constant (|
                            "move_binary_format::file_format::Ability::Store_discriminant",
                            Ty.path "u8"
                          |)
                        |);
                        Value.Integer IntegerKind.U8 0
                      ]
                    |))
                ]
              |)
            ]
        |))).
    
    Global Instance AssociatedConstant_value_VECTOR :
      M.IsAssociatedFunction.C Self "VECTOR" value_VECTOR.
    Admitted.
    Global Typeclasses Opaque value_VECTOR.
    
    (*
        pub const ALL: Self = Self(
            // Cannot use AbilitySet bitor because it is not const
            (Ability::Copy as u8)
                | (Ability::Drop as u8)
                | (Ability::Store as u8)
                | (Ability::Key as u8),
        );
    *)
    (* Ty.path "move_binary_format::file_format::AbilitySet" *)
    Definition value_ALL (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      ltac:(M.monadic
        (M.alloc (|
          Value.StructTuple
            "move_binary_format::file_format::AbilitySet"
            []
            []
            [
              M.call_closure (|
                Ty.path "u8",
                BinOp.Wrap.bit_or,
                [
                  M.call_closure (|
                    Ty.path "u8",
                    BinOp.Wrap.bit_or,
                    [
                      M.call_closure (|
                        Ty.path "u8",
                        BinOp.Wrap.bit_or,
                        [
                          M.cast
                            (Ty.path "u8")
                            (M.call_closure (|
                              Ty.path "u8",
                              BinOp.Wrap.add,
                              [
                                M.read (|
                                  get_constant (|
                                    "move_binary_format::file_format::Ability::Copy_discriminant",
                                    Ty.path "u8"
                                  |)
                                |);
                                Value.Integer IntegerKind.U8 0
                              ]
                            |));
                          M.cast
                            (Ty.path "u8")
                            (M.call_closure (|
                              Ty.path "u8",
                              BinOp.Wrap.add,
                              [
                                M.read (|
                                  get_constant (|
                                    "move_binary_format::file_format::Ability::Drop_discriminant",
                                    Ty.path "u8"
                                  |)
                                |);
                                Value.Integer IntegerKind.U8 0
                              ]
                            |))
                        ]
                      |);
                      M.cast
                        (Ty.path "u8")
                        (M.call_closure (|
                          Ty.path "u8",
                          BinOp.Wrap.add,
                          [
                            M.read (|
                              get_constant (|
                                "move_binary_format::file_format::Ability::Store_discriminant",
                                Ty.path "u8"
                              |)
                            |);
                            Value.Integer IntegerKind.U8 0
                          ]
                        |))
                    ]
                  |);
                  M.cast
                    (Ty.path "u8")
                    (M.call_closure (|
                      Ty.path "u8",
                      BinOp.Wrap.add,
                      [
                        M.read (|
                          get_constant (|
                            "move_binary_format::file_format::Ability::Key_discriminant",
                            Ty.path "u8"
                          |)
                        |);
                        Value.Integer IntegerKind.U8 0
                      ]
                    |))
                ]
              |)
            ]
        |))).
    
    Global Instance AssociatedConstant_value_ALL : M.IsAssociatedFunction.C Self "ALL" value_ALL.
    Admitted.
    Global Typeclasses Opaque value_ALL.
    
    (*
        pub fn singleton(ability: Ability) -> Self {
            Self(ability as u8)
        }
    *)
    Definition singleton (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ ability ] =>
        ltac:(M.monadic
          (let ability := M.alloc (| ability |) in
          Value.StructTuple
            "move_binary_format::file_format::AbilitySet"
            []
            []
            [ M.cast (Ty.path "u8") (M.read (| ability |)) ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_singleton :
      M.IsAssociatedFunction.C Self "singleton" singleton.
    Admitted.
    Global Typeclasses Opaque singleton.
    
    (*
        pub fn has_ability(self, ability: Ability) -> bool {
            let a = ability as u8;
            (a & self.0) == a
        }
    *)
    Definition has_ability (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; ability ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let ability := M.alloc (| ability |) in
          M.read (|
            let~ a : Ty.path "u8" := M.cast (Ty.path "u8") (M.read (| ability |)) in
            M.alloc (|
              M.call_closure (|
                Ty.path "bool",
                BinOp.eq,
                [
                  M.call_closure (|
                    Ty.path "u8",
                    BinOp.Wrap.bit_and,
                    [
                      M.read (| a |);
                      M.read (|
                        M.SubPointer.get_struct_tuple_field (|
                          self,
                          "move_binary_format::file_format::AbilitySet",
                          0
                        |)
                      |)
                    ]
                  |);
                  M.read (| a |)
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_has_ability :
      M.IsAssociatedFunction.C Self "has_ability" has_ability.
    Admitted.
    Global Typeclasses Opaque has_ability.
    
    (*
        pub fn has_copy(self) -> bool {
            self.has_ability(Ability::Copy)
        }
    *)
    Definition has_copy (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            Ty.path "bool",
            M.get_associated_function (|
              Ty.path "move_binary_format::file_format::AbilitySet",
              "has_ability",
              [],
              []
            |),
            [
              M.read (| self |);
              Value.StructTuple "move_binary_format::file_format::Ability::Copy" [] [] []
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_has_copy : M.IsAssociatedFunction.C Self "has_copy" has_copy.
    Admitted.
    Global Typeclasses Opaque has_copy.
    
    (*
        pub fn has_drop(self) -> bool {
            self.has_ability(Ability::Drop)
        }
    *)
    Definition has_drop (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            Ty.path "bool",
            M.get_associated_function (|
              Ty.path "move_binary_format::file_format::AbilitySet",
              "has_ability",
              [],
              []
            |),
            [
              M.read (| self |);
              Value.StructTuple "move_binary_format::file_format::Ability::Drop" [] [] []
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_has_drop : M.IsAssociatedFunction.C Self "has_drop" has_drop.
    Admitted.
    Global Typeclasses Opaque has_drop.
    
    (*
        pub fn has_store(self) -> bool {
            self.has_ability(Ability::Store)
        }
    *)
    Definition has_store (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            Ty.path "bool",
            M.get_associated_function (|
              Ty.path "move_binary_format::file_format::AbilitySet",
              "has_ability",
              [],
              []
            |),
            [
              M.read (| self |);
              Value.StructTuple "move_binary_format::file_format::Ability::Store" [] [] []
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_has_store :
      M.IsAssociatedFunction.C Self "has_store" has_store.
    Admitted.
    Global Typeclasses Opaque has_store.
    
    (*
        pub fn has_key(self) -> bool {
            self.has_ability(Ability::Key)
        }
    *)
    Definition has_key (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            Ty.path "bool",
            M.get_associated_function (|
              Ty.path "move_binary_format::file_format::AbilitySet",
              "has_ability",
              [],
              []
            |),
            [
              M.read (| self |);
              Value.StructTuple "move_binary_format::file_format::Ability::Key" [] [] []
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_has_key : M.IsAssociatedFunction.C Self "has_key" has_key.
    Admitted.
    Global Typeclasses Opaque has_key.
    
    (*
        pub fn remove(self, ability: Ability) -> Self {
            Self(self.0 & (!(ability as u8)))
        }
    *)
    Definition remove (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; ability ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let ability := M.alloc (| ability |) in
          Value.StructTuple
            "move_binary_format::file_format::AbilitySet"
            []
            []
            [
              M.call_closure (|
                Ty.path "u8",
                BinOp.Wrap.bit_and,
                [
                  M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      self,
                      "move_binary_format::file_format::AbilitySet",
                      0
                    |)
                  |);
                  UnOp.not (| M.cast (Ty.path "u8") (M.read (| ability |)) |)
                ]
              |)
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_remove : M.IsAssociatedFunction.C Self "remove" remove.
    Admitted.
    Global Typeclasses Opaque remove.
    
    (*
        pub fn intersect(self, other: Self) -> Self {
            Self(self.0 & other.0)
        }
    *)
    Definition intersect (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          Value.StructTuple
            "move_binary_format::file_format::AbilitySet"
            []
            []
            [
              M.call_closure (|
                Ty.path "u8",
                BinOp.Wrap.bit_and,
                [
                  M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      self,
                      "move_binary_format::file_format::AbilitySet",
                      0
                    |)
                  |);
                  M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      other,
                      "move_binary_format::file_format::AbilitySet",
                      0
                    |)
                  |)
                ]
              |)
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_intersect :
      M.IsAssociatedFunction.C Self "intersect" intersect.
    Admitted.
    Global Typeclasses Opaque intersect.
    
    (*
        pub fn union(self, other: Self) -> Self {
            Self(self.0 | other.0)
        }
    *)
    Definition union (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          Value.StructTuple
            "move_binary_format::file_format::AbilitySet"
            []
            []
            [
              M.call_closure (|
                Ty.path "u8",
                BinOp.Wrap.bit_or,
                [
                  M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      self,
                      "move_binary_format::file_format::AbilitySet",
                      0
                    |)
                  |);
                  M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      other,
                      "move_binary_format::file_format::AbilitySet",
                      0
                    |)
                  |)
                ]
              |)
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_union : M.IsAssociatedFunction.C Self "union" union.
    Admitted.
    Global Typeclasses Opaque union.
    
    (*
        fn is_subset_bits(sub: u8, sup: u8) -> bool {
            (sub & sup) == sub
        }
    *)
    Definition is_subset_bits (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ sub; sup ] =>
        ltac:(M.monadic
          (let sub := M.alloc (| sub |) in
          let sup := M.alloc (| sup |) in
          M.call_closure (|
            Ty.path "bool",
            BinOp.eq,
            [
              M.call_closure (|
                Ty.path "u8",
                BinOp.Wrap.bit_and,
                [ M.read (| sub |); M.read (| sup |) ]
              |);
              M.read (| sub |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_is_subset_bits :
      M.IsAssociatedFunction.C Self "is_subset_bits" is_subset_bits.
    Admitted.
    Global Typeclasses Opaque is_subset_bits.
    
    (*
        pub fn is_subset(self, other: Self) -> bool {
            Self::is_subset_bits(self.0, other.0)
        }
    *)
    Definition is_subset (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.path "bool",
            M.get_associated_function (|
              Ty.path "move_binary_format::file_format::AbilitySet",
              "is_subset_bits",
              [],
              []
            |),
            [
              M.read (|
                M.SubPointer.get_struct_tuple_field (|
                  self,
                  "move_binary_format::file_format::AbilitySet",
                  0
                |)
              |);
              M.read (|
                M.SubPointer.get_struct_tuple_field (|
                  other,
                  "move_binary_format::file_format::AbilitySet",
                  0
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_is_subset :
      M.IsAssociatedFunction.C Self "is_subset" is_subset.
    Admitted.
    Global Typeclasses Opaque is_subset.
    
    (*
        pub fn polymorphic_abilities<I1, I2>(
            declared_abilities: Self,
            declared_phantom_parameters: I1,
            type_arguments: I2,
        ) -> PartialVMResult<Self>
        where
            I1: IntoIterator<Item = bool>,
            I2: IntoIterator<Item = Self>,
            I1::IntoIter: ExactSizeIterator,
            I2::IntoIter: ExactSizeIterator,
        {
            let declared_phantom_parameters = declared_phantom_parameters.into_iter();
            let type_arguments = type_arguments.into_iter();
    
            if declared_phantom_parameters.len() != type_arguments.len() {
                return Err(
                    PartialVMError::new(StatusCode::VERIFIER_INVARIANT_VIOLATION).with_message(
                        "the length of `declared_phantom_parameters` doesn't match the length of `type_arguments`".to_string(),
                    ),
                );
            }
    
            // Conceptually this is performing the following operation:
            // For any ability 'a' in `declared_abilities`
            // 'a' is in the result only if
            //   for all (abi_i, is_phantom_i) in `type_arguments` s.t. !is_phantom then a.required() is a subset of abi_i
            //
            // So to do this efficiently, we can determine the required_by set for each ti
            // and intersect them together along with the declared abilities
            // This only works because for any ability y, |y.requires()| == 1
            let abs = type_arguments
                .zip(declared_phantom_parameters)
                .filter(|(_, is_phantom)| !is_phantom)
                .map(|(ty_arg_abilities, _)| {
                    ty_arg_abilities
                        .into_iter()
                        .map(|a| a.required_by())
                        .fold(AbilitySet::EMPTY, AbilitySet::union)
                })
                .fold(declared_abilities, |acc, ty_arg_abilities| {
                    acc.intersect(ty_arg_abilities)
                });
            Ok(abs)
        }
    *)
    Definition polymorphic_abilities (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ I1; I2 ], [ declared_abilities; declared_phantom_parameters; type_arguments ] =>
        ltac:(M.monadic
          (let declared_abilities := M.alloc (| declared_abilities |) in
          let declared_phantom_parameters := M.alloc (| declared_phantom_parameters |) in
          let type_arguments := M.alloc (| type_arguments |) in
          M.catch_return
            (Ty.apply
              (Ty.path "core::result::Result")
              []
              [
                Ty.path "move_binary_format::file_format::AbilitySet";
                Ty.path "move_binary_format::errors::PartialVMError"
              ]) (|
            ltac:(M.monadic
              (M.read (|
                let~ declared_phantom_parameters :
                    Ty.associated_in_trait
                      "core::iter::traits::collect::IntoIterator"
                      []
                      []
                      I1
                      "IntoIter" :=
                  M.call_closure (|
                    Ty.associated_in_trait
                      "core::iter::traits::collect::IntoIterator"
                      []
                      []
                      I1
                      "IntoIter",
                    M.get_trait_method (|
                      "core::iter::traits::collect::IntoIterator",
                      I1,
                      [],
                      [],
                      "into_iter",
                      [],
                      []
                    |),
                    [ M.read (| declared_phantom_parameters |) ]
                  |) in
                let~ type_arguments :
                    Ty.associated_in_trait
                      "core::iter::traits::collect::IntoIterator"
                      []
                      []
                      I2
                      "IntoIter" :=
                  M.call_closure (|
                    Ty.associated_in_trait
                      "core::iter::traits::collect::IntoIterator"
                      []
                      []
                      I2
                      "IntoIter",
                    M.get_trait_method (|
                      "core::iter::traits::collect::IntoIterator",
                      I2,
                      [],
                      [],
                      "into_iter",
                      [],
                      []
                    |),
                    [ M.read (| type_arguments |) ]
                  |) in
                let~ _ : Ty.tuple [] :=
                  M.read (|
                    M.match_operator (|
                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    Ty.path "bool",
                                    BinOp.ne,
                                    [
                                      M.call_closure (|
                                        Ty.path "usize",
                                        M.get_trait_method (|
                                          "core::iter::traits::exact_size::ExactSizeIterator",
                                          Ty.associated_in_trait
                                            "core::iter::traits::collect::IntoIterator"
                                            []
                                            []
                                            I1
                                            "IntoIter",
                                          [],
                                          [],
                                          "len",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            declared_phantom_parameters
                                          |)
                                        ]
                                      |);
                                      M.call_closure (|
                                        Ty.path "usize",
                                        M.get_trait_method (|
                                          "core::iter::traits::exact_size::ExactSizeIterator",
                                          Ty.associated_in_trait
                                            "core::iter::traits::collect::IntoIterator"
                                            []
                                            []
                                            I2
                                            "IntoIter",
                                          [],
                                          [],
                                          "len",
                                          [],
                                          []
                                        |),
                                        [ M.borrow (| Pointer.Kind.Ref, type_arguments |) ]
                                      |)
                                    ]
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    Value.StructTuple
                                      "core::result::Result::Err"
                                      []
                                      [
                                        Ty.path "move_binary_format::file_format::AbilitySet";
                                        Ty.path "move_binary_format::errors::PartialVMError"
                                      ]
                                      [
                                        M.call_closure (|
                                          Ty.path "move_binary_format::errors::PartialVMError",
                                          M.get_associated_function (|
                                            Ty.path "move_binary_format::errors::PartialVMError",
                                            "with_message",
                                            [],
                                            []
                                          |),
                                          [
                                            M.call_closure (|
                                              Ty.path "move_binary_format::errors::PartialVMError",
                                              M.get_associated_function (|
                                                Ty.path
                                                  "move_binary_format::errors::PartialVMError",
                                                "new",
                                                [],
                                                []
                                              |),
                                              [
                                                Value.StructTuple
                                                  "move_core_types::vm_status::StatusCode::VERIFIER_INVARIANT_VIOLATION"
                                                  []
                                                  []
                                                  []
                                              ]
                                            |);
                                            M.call_closure (|
                                              Ty.path "alloc::string::String",
                                              M.get_trait_method (|
                                                "alloc::string::ToString",
                                                Ty.path "str",
                                                [],
                                                [],
                                                "to_string",
                                                [],
                                                []
                                              |),
                                              [
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (|
                                                    mk_str (|
                                                      "the length of `declared_phantom_parameters` doesn't match the length of `type_arguments`"
                                                    |)
                                                  |)
                                                |)
                                              ]
                                            |)
                                          ]
                                        |)
                                      ]
                                  |)
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |)
                  |) in
                let~ abs : Ty.path "move_binary_format::file_format::AbilitySet" :=
                  M.call_closure (|
                    Ty.path "move_binary_format::file_format::AbilitySet",
                    M.get_trait_method (|
                      "core::iter::traits::iterator::Iterator",
                      Ty.apply
                        (Ty.path "core::iter::adapters::map::Map")
                        []
                        [
                          Ty.apply
                            (Ty.path "core::iter::adapters::filter::Filter")
                            []
                            [
                              Ty.apply
                                (Ty.path "core::iter::adapters::zip::Zip")
                                []
                                [
                                  Ty.associated_in_trait
                                    "core::iter::traits::collect::IntoIterator"
                                    []
                                    []
                                    I2
                                    "IntoIter";
                                  Ty.associated_in_trait
                                    "core::iter::traits::collect::IntoIterator"
                                    []
                                    []
                                    I1
                                    "IntoIter"
                                ];
                              Ty.function
                                [
                                  Ty.tuple
                                    [
                                      Ty.apply
                                        (Ty.path "&")
                                        []
                                        [
                                          Ty.tuple
                                            [
                                              Ty.path "move_binary_format::file_format::AbilitySet";
                                              Ty.path "bool"
                                            ]
                                        ]
                                    ]
                                ]
                                (Ty.path "bool")
                            ];
                          Ty.function
                            [
                              Ty.tuple
                                [
                                  Ty.tuple
                                    [
                                      Ty.path "move_binary_format::file_format::AbilitySet";
                                      Ty.path "bool"
                                    ]
                                ]
                            ]
                            (Ty.path "move_binary_format::file_format::AbilitySet")
                        ],
                      [],
                      [],
                      "fold",
                      [],
                      [
                        Ty.path "move_binary_format::file_format::AbilitySet";
                        Ty.function
                          [
                            Ty.tuple
                              [
                                Ty.path "move_binary_format::file_format::AbilitySet";
                                Ty.path "move_binary_format::file_format::AbilitySet"
                              ]
                          ]
                          (Ty.path "move_binary_format::file_format::AbilitySet")
                      ]
                    |),
                    [
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::iter::adapters::map::Map")
                          []
                          [
                            Ty.apply
                              (Ty.path "core::iter::adapters::filter::Filter")
                              []
                              [
                                Ty.apply
                                  (Ty.path "core::iter::adapters::zip::Zip")
                                  []
                                  [
                                    Ty.associated_in_trait
                                      "core::iter::traits::collect::IntoIterator"
                                      []
                                      []
                                      I2
                                      "IntoIter";
                                    Ty.associated_in_trait
                                      "core::iter::traits::collect::IntoIterator"
                                      []
                                      []
                                      I1
                                      "IntoIter"
                                  ];
                                Ty.function
                                  [
                                    Ty.tuple
                                      [
                                        Ty.apply
                                          (Ty.path "&")
                                          []
                                          [
                                            Ty.tuple
                                              [
                                                Ty.path
                                                  "move_binary_format::file_format::AbilitySet";
                                                Ty.path "bool"
                                              ]
                                          ]
                                      ]
                                  ]
                                  (Ty.path "bool")
                              ];
                            Ty.function
                              [
                                Ty.tuple
                                  [
                                    Ty.tuple
                                      [
                                        Ty.path "move_binary_format::file_format::AbilitySet";
                                        Ty.path "bool"
                                      ]
                                  ]
                              ]
                              (Ty.path "move_binary_format::file_format::AbilitySet")
                          ],
                        M.get_trait_method (|
                          "core::iter::traits::iterator::Iterator",
                          Ty.apply
                            (Ty.path "core::iter::adapters::filter::Filter")
                            []
                            [
                              Ty.apply
                                (Ty.path "core::iter::adapters::zip::Zip")
                                []
                                [
                                  Ty.associated_in_trait
                                    "core::iter::traits::collect::IntoIterator"
                                    []
                                    []
                                    I2
                                    "IntoIter";
                                  Ty.associated_in_trait
                                    "core::iter::traits::collect::IntoIterator"
                                    []
                                    []
                                    I1
                                    "IntoIter"
                                ];
                              Ty.function
                                [
                                  Ty.tuple
                                    [
                                      Ty.apply
                                        (Ty.path "&")
                                        []
                                        [
                                          Ty.tuple
                                            [
                                              Ty.path "move_binary_format::file_format::AbilitySet";
                                              Ty.path "bool"
                                            ]
                                        ]
                                    ]
                                ]
                                (Ty.path "bool")
                            ],
                          [],
                          [],
                          "map",
                          [],
                          [
                            Ty.path "move_binary_format::file_format::AbilitySet";
                            Ty.function
                              [
                                Ty.tuple
                                  [
                                    Ty.tuple
                                      [
                                        Ty.path "move_binary_format::file_format::AbilitySet";
                                        Ty.path "bool"
                                      ]
                                  ]
                              ]
                              (Ty.path "move_binary_format::file_format::AbilitySet")
                          ]
                        |),
                        [
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "core::iter::adapters::filter::Filter")
                              []
                              [
                                Ty.apply
                                  (Ty.path "core::iter::adapters::zip::Zip")
                                  []
                                  [
                                    Ty.associated_in_trait
                                      "core::iter::traits::collect::IntoIterator"
                                      []
                                      []
                                      I2
                                      "IntoIter";
                                    Ty.associated_in_trait
                                      "core::iter::traits::collect::IntoIterator"
                                      []
                                      []
                                      I1
                                      "IntoIter"
                                  ];
                                Ty.function
                                  [
                                    Ty.tuple
                                      [
                                        Ty.apply
                                          (Ty.path "&")
                                          []
                                          [
                                            Ty.tuple
                                              [
                                                Ty.path
                                                  "move_binary_format::file_format::AbilitySet";
                                                Ty.path "bool"
                                              ]
                                          ]
                                      ]
                                  ]
                                  (Ty.path "bool")
                              ],
                            M.get_trait_method (|
                              "core::iter::traits::iterator::Iterator",
                              Ty.apply
                                (Ty.path "core::iter::adapters::zip::Zip")
                                []
                                [
                                  Ty.associated_in_trait
                                    "core::iter::traits::collect::IntoIterator"
                                    []
                                    []
                                    I2
                                    "IntoIter";
                                  Ty.associated_in_trait
                                    "core::iter::traits::collect::IntoIterator"
                                    []
                                    []
                                    I1
                                    "IntoIter"
                                ],
                              [],
                              [],
                              "filter",
                              [],
                              [
                                Ty.function
                                  [
                                    Ty.tuple
                                      [
                                        Ty.apply
                                          (Ty.path "&")
                                          []
                                          [
                                            Ty.tuple
                                              [
                                                Ty.path
                                                  "move_binary_format::file_format::AbilitySet";
                                                Ty.path "bool"
                                              ]
                                          ]
                                      ]
                                  ]
                                  (Ty.path "bool")
                              ]
                            |),
                            [
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::iter::adapters::zip::Zip")
                                  []
                                  [
                                    Ty.associated_in_trait
                                      "core::iter::traits::collect::IntoIterator"
                                      []
                                      []
                                      I2
                                      "IntoIter";
                                    Ty.associated_in_trait
                                      "core::iter::traits::collect::IntoIterator"
                                      []
                                      []
                                      I1
                                      "IntoIter"
                                  ],
                                M.get_trait_method (|
                                  "core::iter::traits::iterator::Iterator",
                                  Ty.associated_in_trait
                                    "core::iter::traits::collect::IntoIterator"
                                    []
                                    []
                                    I2
                                    "IntoIter",
                                  [],
                                  [],
                                  "zip",
                                  [],
                                  [
                                    Ty.associated_in_trait
                                      "core::iter::traits::collect::IntoIterator"
                                      []
                                      []
                                      I1
                                      "IntoIter"
                                  ]
                                |),
                                [
                                  M.read (| type_arguments |);
                                  M.read (| declared_phantom_parameters |)
                                ]
                              |);
                              M.closure
                                (fun γ =>
                                  ltac:(M.monadic
                                    match γ with
                                    | [ α0 ] =>
                                      ltac:(M.monadic
                                        (M.match_operator (|
                                          Ty.apply
                                            (Ty.path "*")
                                            []
                                            [
                                              Ty.function
                                                [
                                                  Ty.tuple
                                                    [
                                                      Ty.apply
                                                        (Ty.path "&")
                                                        []
                                                        [
                                                          Ty.tuple
                                                            [
                                                              Ty.path
                                                                "move_binary_format::file_format::AbilitySet";
                                                              Ty.path "bool"
                                                            ]
                                                        ]
                                                    ]
                                                ]
                                                (Ty.path "bool")
                                            ],
                                          M.alloc (| α0 |),
                                          [
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let γ := M.read (| γ |) in
                                                let γ1_0 :=
                                                  M.SubPointer.get_tuple_field (| γ, 0 |) in
                                                let γ1_1 :=
                                                  M.SubPointer.get_tuple_field (| γ, 1 |) in
                                                let is_phantom := M.alloc (| γ1_1 |) in
                                                M.call_closure (|
                                                  Ty.path "bool",
                                                  M.get_trait_method (|
                                                    "core::ops::bit::Not",
                                                    Ty.apply (Ty.path "&") [] [ Ty.path "bool" ],
                                                    [],
                                                    [],
                                                    "not",
                                                    [],
                                                    []
                                                  |),
                                                  [ M.read (| is_phantom |) ]
                                                |)))
                                          ]
                                        |)))
                                    | _ => M.impossible "wrong number of arguments"
                                    end))
                            ]
                          |);
                          M.closure
                            (fun γ =>
                              ltac:(M.monadic
                                match γ with
                                | [ α0 ] =>
                                  ltac:(M.monadic
                                    (M.match_operator (|
                                      Ty.apply
                                        (Ty.path "*")
                                        []
                                        [
                                          Ty.function
                                            [
                                              Ty.tuple
                                                [
                                                  Ty.tuple
                                                    [
                                                      Ty.path
                                                        "move_binary_format::file_format::AbilitySet";
                                                      Ty.path "bool"
                                                    ]
                                                ]
                                            ]
                                            (Ty.path "move_binary_format::file_format::AbilitySet")
                                        ],
                                      M.alloc (| α0 |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                            let ty_arg_abilities := M.copy (| γ0_0 |) in
                                            M.call_closure (|
                                              Ty.path "move_binary_format::file_format::AbilitySet",
                                              M.get_trait_method (|
                                                "core::iter::traits::iterator::Iterator",
                                                Ty.apply
                                                  (Ty.path "core::iter::adapters::map::Map")
                                                  []
                                                  [
                                                    Ty.path
                                                      "move_binary_format::file_format::AbilitySetIterator";
                                                    Ty.function
                                                      [
                                                        Ty.tuple
                                                          [
                                                            Ty.path
                                                              "move_binary_format::file_format::Ability"
                                                          ]
                                                      ]
                                                      (Ty.path
                                                        "move_binary_format::file_format::AbilitySet")
                                                  ],
                                                [],
                                                [],
                                                "fold",
                                                [],
                                                [
                                                  Ty.path
                                                    "move_binary_format::file_format::AbilitySet";
                                                  Ty.function
                                                    [
                                                      Ty.path
                                                        "move_binary_format::file_format::AbilitySet";
                                                      Ty.path
                                                        "move_binary_format::file_format::AbilitySet"
                                                    ]
                                                    (Ty.path
                                                      "move_binary_format::file_format::AbilitySet")
                                                ]
                                              |),
                                              [
                                                M.call_closure (|
                                                  Ty.apply
                                                    (Ty.path "core::iter::adapters::map::Map")
                                                    []
                                                    [
                                                      Ty.path
                                                        "move_binary_format::file_format::AbilitySetIterator";
                                                      Ty.function
                                                        [
                                                          Ty.tuple
                                                            [
                                                              Ty.path
                                                                "move_binary_format::file_format::Ability"
                                                            ]
                                                        ]
                                                        (Ty.path
                                                          "move_binary_format::file_format::AbilitySet")
                                                    ],
                                                  M.get_trait_method (|
                                                    "core::iter::traits::iterator::Iterator",
                                                    Ty.path
                                                      "move_binary_format::file_format::AbilitySetIterator",
                                                    [],
                                                    [],
                                                    "map",
                                                    [],
                                                    [
                                                      Ty.path
                                                        "move_binary_format::file_format::AbilitySet";
                                                      Ty.function
                                                        [
                                                          Ty.tuple
                                                            [
                                                              Ty.path
                                                                "move_binary_format::file_format::Ability"
                                                            ]
                                                        ]
                                                        (Ty.path
                                                          "move_binary_format::file_format::AbilitySet")
                                                    ]
                                                  |),
                                                  [
                                                    M.call_closure (|
                                                      Ty.path
                                                        "move_binary_format::file_format::AbilitySetIterator",
                                                      M.get_trait_method (|
                                                        "core::iter::traits::collect::IntoIterator",
                                                        Ty.path
                                                          "move_binary_format::file_format::AbilitySet",
                                                        [],
                                                        [],
                                                        "into_iter",
                                                        [],
                                                        []
                                                      |),
                                                      [ M.read (| ty_arg_abilities |) ]
                                                    |);
                                                    M.closure
                                                      (fun γ =>
                                                        ltac:(M.monadic
                                                          match γ with
                                                          | [ α0 ] =>
                                                            ltac:(M.monadic
                                                              (M.match_operator (|
                                                                Ty.apply
                                                                  (Ty.path "*")
                                                                  []
                                                                  [
                                                                    Ty.function
                                                                      [
                                                                        Ty.tuple
                                                                          [
                                                                            Ty.path
                                                                              "move_binary_format::file_format::Ability"
                                                                          ]
                                                                      ]
                                                                      (Ty.path
                                                                        "move_binary_format::file_format::AbilitySet")
                                                                  ],
                                                                M.alloc (| α0 |),
                                                                [
                                                                  fun γ =>
                                                                    ltac:(M.monadic
                                                                      (let a := M.copy (| γ |) in
                                                                      M.call_closure (|
                                                                        Ty.path
                                                                          "move_binary_format::file_format::AbilitySet",
                                                                        M.get_associated_function (|
                                                                          Ty.path
                                                                            "move_binary_format::file_format::Ability",
                                                                          "required_by",
                                                                          [],
                                                                          []
                                                                        |),
                                                                        [ M.read (| a |) ]
                                                                      |)))
                                                                ]
                                                              |)))
                                                          | _ =>
                                                            M.impossible "wrong number of arguments"
                                                          end))
                                                  ]
                                                |);
                                                M.read (|
                                                  get_associated_constant (|
                                                    Ty.path
                                                      "move_binary_format::file_format::AbilitySet",
                                                    "EMPTY",
                                                    Ty.path
                                                      "move_binary_format::file_format::AbilitySet"
                                                  |)
                                                |);
                                                M.get_associated_function (|
                                                  Ty.path
                                                    "move_binary_format::file_format::AbilitySet",
                                                  "union",
                                                  [],
                                                  []
                                                |)
                                              ]
                                            |)))
                                      ]
                                    |)))
                                | _ => M.impossible "wrong number of arguments"
                                end))
                        ]
                      |);
                      M.read (| declared_abilities |);
                      M.closure
                        (fun γ =>
                          ltac:(M.monadic
                            match γ with
                            | [ α0; α1 ] =>
                              ltac:(M.monadic
                                (M.match_operator (|
                                  Ty.apply
                                    (Ty.path "*")
                                    []
                                    [
                                      Ty.function
                                        [
                                          Ty.tuple
                                            [
                                              Ty.path "move_binary_format::file_format::AbilitySet";
                                              Ty.path "move_binary_format::file_format::AbilitySet"
                                            ]
                                        ]
                                        (Ty.path "move_binary_format::file_format::AbilitySet")
                                    ],
                                  M.alloc (| α0 |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let acc := M.copy (| γ |) in
                                        M.match_operator (|
                                          Ty.apply
                                            (Ty.path "*")
                                            []
                                            [
                                              Ty.function
                                                [
                                                  Ty.tuple
                                                    [
                                                      Ty.path
                                                        "move_binary_format::file_format::AbilitySet";
                                                      Ty.path
                                                        "move_binary_format::file_format::AbilitySet"
                                                    ]
                                                ]
                                                (Ty.path
                                                  "move_binary_format::file_format::AbilitySet")
                                            ],
                                          M.alloc (| α1 |),
                                          [
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let ty_arg_abilities := M.copy (| γ |) in
                                                M.call_closure (|
                                                  Ty.path
                                                    "move_binary_format::file_format::AbilitySet",
                                                  M.get_associated_function (|
                                                    Ty.path
                                                      "move_binary_format::file_format::AbilitySet",
                                                    "intersect",
                                                    [],
                                                    []
                                                  |),
                                                  [ M.read (| acc |); M.read (| ty_arg_abilities |)
                                                  ]
                                                |)))
                                          ]
                                        |)))
                                  ]
                                |)))
                            | _ => M.impossible "wrong number of arguments"
                            end))
                    ]
                  |) in
                M.alloc (|
                  Value.StructTuple
                    "core::result::Result::Ok"
                    []
                    [
                      Ty.path "move_binary_format::file_format::AbilitySet";
                      Ty.path "move_binary_format::errors::PartialVMError"
                    ]
                    [ M.read (| abs |) ]
                |)
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_polymorphic_abilities :
      M.IsAssociatedFunction.C Self "polymorphic_abilities" polymorphic_abilities.
    Admitted.
    Global Typeclasses Opaque polymorphic_abilities.
    
    (*
        pub fn from_u8(byte: u8) -> Option<Self> {
            // If there is a bit set in the read `byte`, that bit must be set in the
            // `AbilitySet` containing all `Ability`s
            // This corresponds the byte being a bit set subset of ALL
            // The byte is a subset of ALL if the intersection of the two is the original byte
            if Self::is_subset_bits(byte, Self::ALL.0) {
                Some(Self(byte))
            } else {
                None
            }
        }
    *)
    Definition from_u8 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ byte ] =>
        ltac:(M.monadic
          (let byte := M.alloc (| byte |) in
          M.read (|
            M.match_operator (|
              Ty.apply
                (Ty.path "*")
                []
                [
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [ Ty.path "move_binary_format::file_format::AbilitySet" ]
                ],
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            Ty.path "bool",
                            M.get_associated_function (|
                              Ty.path "move_binary_format::file_format::AbilitySet",
                              "is_subset_bits",
                              [],
                              []
                            |),
                            [
                              M.read (| byte |);
                              M.read (|
                                M.SubPointer.get_struct_tuple_field (|
                                  get_associated_constant (|
                                    Ty.path "move_binary_format::file_format::AbilitySet",
                                    "ALL",
                                    Ty.path "move_binary_format::file_format::AbilitySet"
                                  |),
                                  "move_binary_format::file_format::AbilitySet",
                                  0
                                |)
                              |)
                            ]
                          |)
                        |)) in
                    let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        []
                        [ Ty.path "move_binary_format::file_format::AbilitySet" ]
                        [
                          Value.StructTuple
                            "move_binary_format::file_format::AbilitySet"
                            []
                            []
                            [ M.read (| byte |) ]
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.StructTuple
                        "core::option::Option::None"
                        []
                        [ Ty.path "move_binary_format::file_format::AbilitySet" ]
                        []
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_from_u8 : M.IsAssociatedFunction.C Self "from_u8" from_u8.
    Admitted.
    Global Typeclasses Opaque from_u8.
    
    (*
        pub fn into_u8(self) -> u8 {
            self.0
        }
    *)
    Definition into_u8 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.SubPointer.get_struct_tuple_field (|
              self,
              "move_binary_format::file_format::AbilitySet",
              0
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_into_u8 : M.IsAssociatedFunction.C Self "into_u8" into_u8.
    Admitted.
    Global Typeclasses Opaque into_u8.
  End Impl_move_binary_format_file_format_AbilitySet.
  
  Module Impl_core_ops_bit_BitOr_move_binary_format_file_format_Ability_for_move_binary_format_file_format_AbilitySet.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::AbilitySet".
    
    (*     type Output = Self; *)
    Definition _Output : Ty.t := Ty.path "move_binary_format::file_format::AbilitySet".
    
    (*
        fn bitor(self, rhs: Ability) -> Self {
            AbilitySet(self.0 | (rhs as u8))
        }
    *)
    Definition bitor (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          Value.StructTuple
            "move_binary_format::file_format::AbilitySet"
            []
            []
            [
              M.call_closure (|
                Ty.path "u8",
                BinOp.Wrap.bit_or,
                [
                  M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      self,
                      "move_binary_format::file_format::AbilitySet",
                      0
                    |)
                  |);
                  M.cast (Ty.path "u8") (M.read (| rhs |))
                ]
              |)
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::ops::bit::BitOr"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "move_binary_format::file_format::Ability" ]
        Self
        (* Instance *)
        [ ("Output", InstanceField.Ty _Output); ("bitor", InstanceField.Method bitor) ].
  End Impl_core_ops_bit_BitOr_move_binary_format_file_format_Ability_for_move_binary_format_file_format_AbilitySet.
  
  Module Impl_core_ops_bit_BitOr_move_binary_format_file_format_AbilitySet_for_move_binary_format_file_format_AbilitySet.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::AbilitySet".
    
    (*     type Output = Self; *)
    Definition _Output : Ty.t := Ty.path "move_binary_format::file_format::AbilitySet".
    
    (*
        fn bitor(self, rhs: Self) -> Self {
            AbilitySet(self.0 | rhs.0)
        }
    *)
    Definition bitor (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          Value.StructTuple
            "move_binary_format::file_format::AbilitySet"
            []
            []
            [
              M.call_closure (|
                Ty.path "u8",
                BinOp.Wrap.bit_or,
                [
                  M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      self,
                      "move_binary_format::file_format::AbilitySet",
                      0
                    |)
                  |);
                  M.read (|
                    M.SubPointer.get_struct_tuple_field (|
                      rhs,
                      "move_binary_format::file_format::AbilitySet",
                      0
                    |)
                  |)
                ]
              |)
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::ops::bit::BitOr"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "move_binary_format::file_format::AbilitySet" ]
        Self
        (* Instance *)
        [ ("Output", InstanceField.Ty _Output); ("bitor", InstanceField.Method bitor) ].
  End Impl_core_ops_bit_BitOr_move_binary_format_file_format_AbilitySet_for_move_binary_format_file_format_AbilitySet.
  
  (* StructRecord
    {
      name := "AbilitySetIterator";
      const_params := [];
      ty_params := [];
      fields :=
        [ ("set", Ty.path "move_binary_format::file_format::AbilitySet"); ("idx", Ty.path "u8") ];
    } *)
  
  Module Impl_core_iter_traits_iterator_Iterator_for_move_binary_format_file_format_AbilitySetIterator.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::AbilitySetIterator".
    
    (*     type Item = Ability; *)
    Definition _Item : Ty.t := Ty.path "move_binary_format::file_format::Ability".
    
    (*
        fn next(&mut self) -> Option<Self::Item> {
            while self.idx <= 0x8 {
                let next = Ability::from_u8(self.set.0 & self.idx);
                self.idx <<= 1;
                if next.is_some() {
                    return next;
                }
            }
            None
        }
    *)
    Definition next (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.catch_return
            (Ty.apply
              (Ty.path "core::option::Option")
              []
              [
                Ty.associated_in_trait
                  "core::iter::traits::iterator::Iterator"
                  []
                  []
                  (Ty.path "move_binary_format::file_format::AbilitySetIterator")
                  "Item"
              ]) (|
            ltac:(M.monadic
              (M.read (|
                let~ _ : Ty.tuple [] :=
                  M.read (|
                    M.loop (|
                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                      ltac:(M.monadic
                        (M.match_operator (|
                          Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                          M.alloc (| Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.use
                                    (M.alloc (|
                                      M.call_closure (|
                                        Ty.path "bool",
                                        BinOp.le,
                                        [
                                          M.read (|
                                            M.SubPointer.get_struct_record_field (|
                                              M.deref (| M.read (| self |) |),
                                              "move_binary_format::file_format::AbilitySetIterator",
                                              "idx"
                                            |)
                                          |);
                                          Value.Integer IntegerKind.U8 8
                                        ]
                                      |)
                                    |)) in
                                let _ :=
                                  is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                let~ next :
                                    Ty.apply
                                      (Ty.path "core::option::Option")
                                      []
                                      [ Ty.path "move_binary_format::file_format::Ability" ] :=
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::option::Option")
                                      []
                                      [ Ty.path "move_binary_format::file_format::Ability" ],
                                    M.get_associated_function (|
                                      Ty.path "move_binary_format::file_format::Ability",
                                      "from_u8",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.path "u8",
                                        BinOp.Wrap.bit_and,
                                        [
                                          M.read (|
                                            M.SubPointer.get_struct_tuple_field (|
                                              M.SubPointer.get_struct_record_field (|
                                                M.deref (| M.read (| self |) |),
                                                "move_binary_format::file_format::AbilitySetIterator",
                                                "set"
                                              |),
                                              "move_binary_format::file_format::AbilitySet",
                                              0
                                            |)
                                          |);
                                          M.read (|
                                            M.SubPointer.get_struct_record_field (|
                                              M.deref (| M.read (| self |) |),
                                              "move_binary_format::file_format::AbilitySetIterator",
                                              "idx"
                                            |)
                                          |)
                                        ]
                                      |)
                                    ]
                                  |) in
                                let~ _ : Ty.tuple [] :=
                                  let β :=
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "move_binary_format::file_format::AbilitySetIterator",
                                      "idx"
                                    |) in
                                  M.write (|
                                    β,
                                    M.call_closure (|
                                      Ty.path "u8",
                                      BinOp.Wrap.shl,
                                      [ M.read (| β |); Value.Integer IntegerKind.I32 1 ]
                                    |)
                                  |) in
                                M.match_operator (|
                                  Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                  M.alloc (| Value.Tuple [] |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ :=
                                          M.use
                                            (M.alloc (|
                                              M.call_closure (|
                                                Ty.path "bool",
                                                M.get_associated_function (|
                                                  Ty.apply
                                                    (Ty.path "core::option::Option")
                                                    []
                                                    [
                                                      Ty.path
                                                        "move_binary_format::file_format::Ability"
                                                    ],
                                                  "is_some",
                                                  [],
                                                  []
                                                |),
                                                [ M.borrow (| Pointer.Kind.Ref, next |) ]
                                              |)
                                            |)) in
                                        let _ :=
                                          is_constant_or_break_match (|
                                            M.read (| γ |),
                                            Value.Bool true
                                          |) in
                                        M.alloc (|
                                          M.never_to_any (|
                                            M.read (| M.return_ (| M.read (| next |) |) |)
                                          |)
                                        |)));
                                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                  ]
                                |)));
                            fun γ =>
                              ltac:(M.monadic
                                (M.alloc (|
                                  M.never_to_any (|
                                    M.read (|
                                      let~ _ : Ty.tuple [] :=
                                        M.never_to_any (| M.read (| M.break (||) |) |) in
                                      M.alloc (| Value.Tuple [] |)
                                    |)
                                  |)
                                |)))
                          ]
                        |)))
                    |)
                  |) in
                M.alloc (|
                  Value.StructTuple
                    "core::option::Option::None"
                    []
                    [ Ty.path "move_binary_format::file_format::Ability" ]
                    []
                |)
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::iter::traits::iterator::Iterator"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("Item", InstanceField.Ty _Item); ("next", InstanceField.Method next) ].
  End Impl_core_iter_traits_iterator_Iterator_for_move_binary_format_file_format_AbilitySetIterator.
  
  Module Impl_core_iter_traits_collect_IntoIterator_for_move_binary_format_file_format_AbilitySet.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::AbilitySet".
    
    (*     type Item = Ability; *)
    Definition _Item : Ty.t := Ty.path "move_binary_format::file_format::Ability".
    
    (*     type IntoIter = AbilitySetIterator; *)
    Definition _IntoIter : Ty.t := Ty.path "move_binary_format::file_format::AbilitySetIterator".
    
    (*
        fn into_iter(self) -> Self::IntoIter {
            AbilitySetIterator {
                idx: 0x1,
                set: self,
            }
        }
    *)
    Definition into_iter (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.StructRecord
            "move_binary_format::file_format::AbilitySetIterator"
            []
            []
            [ ("idx", Value.Integer IntegerKind.U8 1); ("set", M.read (| self |)) ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::iter::traits::collect::IntoIterator"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *)
        [
          ("Item", InstanceField.Ty _Item);
          ("IntoIter", InstanceField.Ty _IntoIter);
          ("into_iter", InstanceField.Method into_iter)
        ].
  End Impl_core_iter_traits_collect_IntoIterator_for_move_binary_format_file_format_AbilitySet.
  
  Module Impl_core_fmt_Debug_for_move_binary_format_file_format_AbilitySet.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::AbilitySet".
    
    (*
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
            write!(f, "[")?;
            for ability in *self {
                write!(f, "{:?}, ", ability)?;
            }
            write!(f, "]")
        }
    *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.catch_return
            (Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ]) (|
            ltac:(M.monadic
              (M.read (|
                let~ _ : Ty.tuple [] :=
                  M.read (|
                    M.match_operator (|
                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::ops::control_flow::ControlFlow")
                            []
                            [
                              Ty.apply
                                (Ty.path "core::result::Result")
                                []
                                [ Ty.path "core::convert::Infallible"; Ty.path "core::fmt::Error" ];
                              Ty.tuple []
                            ],
                          M.get_trait_method (|
                            "core::ops::try_trait::Try",
                            Ty.apply
                              (Ty.path "core::result::Result")
                              []
                              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                            [],
                            [],
                            "branch",
                            [],
                            []
                          |),
                          [
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "core::result::Result")
                                []
                                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                              M.get_associated_function (|
                                Ty.path "core::fmt::Formatter",
                                "write_fmt",
                                [],
                                []
                              |),
                              [
                                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                                M.call_closure (|
                                  Ty.path "core::fmt::Arguments",
                                  M.get_associated_function (|
                                    Ty.path "core::fmt::Arguments",
                                    "new_const",
                                    [ Value.Integer IntegerKind.Usize 1 ],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (|
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.alloc (| Value.Array [ mk_str (| "[" |) ] |)
                                        |)
                                      |)
                                    |)
                                  ]
                                |)
                              ]
                            |)
                          ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Break",
                                0
                              |) in
                            let residual := M.copy (| γ0_0 |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        []
                                        [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                                      M.get_trait_method (|
                                        "core::ops::try_trait::FromResidual",
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          []
                                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                                        [],
                                        [
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            []
                                            [
                                              Ty.path "core::convert::Infallible";
                                              Ty.path "core::fmt::Error"
                                            ]
                                        ],
                                        "from_residual",
                                        [],
                                        []
                                      |),
                                      [ M.read (| residual |) ]
                                    |)
                                  |)
                                |)
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Continue",
                                0
                              |) in
                            let val := M.copy (| γ0_0 |) in
                            val))
                      ]
                    |)
                  |) in
                let~ _ : Ty.tuple [] :=
                  M.read (|
                    M.use
                      (M.match_operator (|
                        Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                        M.alloc (|
                          M.call_closure (|
                            Ty.path "move_binary_format::file_format::AbilitySetIterator",
                            M.get_trait_method (|
                              "core::iter::traits::collect::IntoIterator",
                              Ty.path "move_binary_format::file_format::AbilitySet",
                              [],
                              [],
                              "into_iter",
                              [],
                              []
                            |),
                            [ M.read (| M.deref (| M.read (| self |) |) |) ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let iter := M.copy (| γ |) in
                              M.loop (|
                                Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                ltac:(M.monadic
                                  (let~ _ : Ty.tuple [] :=
                                    M.read (|
                                      M.match_operator (|
                                        Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                        M.alloc (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::option::Option")
                                              []
                                              [ Ty.path "move_binary_format::file_format::Ability"
                                              ],
                                            M.get_trait_method (|
                                              "core::iter::traits::iterator::Iterator",
                                              Ty.path
                                                "move_binary_format::file_format::AbilitySetIterator",
                                              [],
                                              [],
                                              "next",
                                              [],
                                              []
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.MutRef,
                                                M.deref (|
                                                  M.borrow (| Pointer.Kind.MutRef, iter |)
                                                |)
                                              |)
                                            ]
                                          |)
                                        |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let _ :=
                                                M.is_struct_tuple (|
                                                  γ,
                                                  "core::option::Option::None"
                                                |) in
                                              M.alloc (|
                                                M.never_to_any (| M.read (| M.break (||) |) |)
                                              |)));
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let γ0_0 :=
                                                M.SubPointer.get_struct_tuple_field (|
                                                  γ,
                                                  "core::option::Option::Some",
                                                  0
                                                |) in
                                              let ability := M.copy (| γ0_0 |) in
                                              let~ _ : Ty.tuple [] :=
                                                M.read (|
                                                  M.match_operator (|
                                                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                                    M.alloc (|
                                                      M.call_closure (|
                                                        Ty.apply
                                                          (Ty.path
                                                            "core::ops::control_flow::ControlFlow")
                                                          []
                                                          [
                                                            Ty.apply
                                                              (Ty.path "core::result::Result")
                                                              []
                                                              [
                                                                Ty.path "core::convert::Infallible";
                                                                Ty.path "core::fmt::Error"
                                                              ];
                                                            Ty.tuple []
                                                          ],
                                                        M.get_trait_method (|
                                                          "core::ops::try_trait::Try",
                                                          Ty.apply
                                                            (Ty.path "core::result::Result")
                                                            []
                                                            [
                                                              Ty.tuple [];
                                                              Ty.path "core::fmt::Error"
                                                            ],
                                                          [],
                                                          [],
                                                          "branch",
                                                          [],
                                                          []
                                                        |),
                                                        [
                                                          M.call_closure (|
                                                            Ty.apply
                                                              (Ty.path "core::result::Result")
                                                              []
                                                              [
                                                                Ty.tuple [];
                                                                Ty.path "core::fmt::Error"
                                                              ],
                                                            M.get_associated_function (|
                                                              Ty.path "core::fmt::Formatter",
                                                              "write_fmt",
                                                              [],
                                                              []
                                                            |),
                                                            [
                                                              M.borrow (|
                                                                Pointer.Kind.MutRef,
                                                                M.deref (| M.read (| f |) |)
                                                              |);
                                                              M.call_closure (|
                                                                Ty.path "core::fmt::Arguments",
                                                                M.get_associated_function (|
                                                                  Ty.path "core::fmt::Arguments",
                                                                  "new_v1",
                                                                  [
                                                                    Value.Integer
                                                                      IntegerKind.Usize
                                                                      2;
                                                                    Value.Integer
                                                                      IntegerKind.Usize
                                                                      1
                                                                  ],
                                                                  []
                                                                |),
                                                                [
                                                                  M.borrow (|
                                                                    Pointer.Kind.Ref,
                                                                    M.deref (|
                                                                      M.borrow (|
                                                                        Pointer.Kind.Ref,
                                                                        M.alloc (|
                                                                          Value.Array
                                                                            [
                                                                              mk_str (| "" |);
                                                                              mk_str (| ", " |)
                                                                            ]
                                                                        |)
                                                                      |)
                                                                    |)
                                                                  |);
                                                                  M.borrow (|
                                                                    Pointer.Kind.Ref,
                                                                    M.deref (|
                                                                      M.borrow (|
                                                                        Pointer.Kind.Ref,
                                                                        M.alloc (|
                                                                          Value.Array
                                                                            [
                                                                              M.call_closure (|
                                                                                Ty.path
                                                                                  "core::fmt::rt::Argument",
                                                                                M.get_associated_function (|
                                                                                  Ty.path
                                                                                    "core::fmt::rt::Argument",
                                                                                  "new_debug",
                                                                                  [],
                                                                                  [
                                                                                    Ty.path
                                                                                      "move_binary_format::file_format::Ability"
                                                                                  ]
                                                                                |),
                                                                                [
                                                                                  M.borrow (|
                                                                                    Pointer.Kind.Ref,
                                                                                    M.deref (|
                                                                                      M.borrow (|
                                                                                        Pointer.Kind.Ref,
                                                                                        ability
                                                                                      |)
                                                                                    |)
                                                                                  |)
                                                                                ]
                                                                              |)
                                                                            ]
                                                                        |)
                                                                      |)
                                                                    |)
                                                                  |)
                                                                ]
                                                              |)
                                                            ]
                                                          |)
                                                        ]
                                                      |)
                                                    |),
                                                    [
                                                      fun γ =>
                                                        ltac:(M.monadic
                                                          (let γ0_0 :=
                                                            M.SubPointer.get_struct_tuple_field (|
                                                              γ,
                                                              "core::ops::control_flow::ControlFlow::Break",
                                                              0
                                                            |) in
                                                          let residual := M.copy (| γ0_0 |) in
                                                          M.alloc (|
                                                            M.never_to_any (|
                                                              M.read (|
                                                                M.return_ (|
                                                                  M.call_closure (|
                                                                    Ty.apply
                                                                      (Ty.path
                                                                        "core::result::Result")
                                                                      []
                                                                      [
                                                                        Ty.tuple [];
                                                                        Ty.path "core::fmt::Error"
                                                                      ],
                                                                    M.get_trait_method (|
                                                                      "core::ops::try_trait::FromResidual",
                                                                      Ty.apply
                                                                        (Ty.path
                                                                          "core::result::Result")
                                                                        []
                                                                        [
                                                                          Ty.tuple [];
                                                                          Ty.path "core::fmt::Error"
                                                                        ],
                                                                      [],
                                                                      [
                                                                        Ty.apply
                                                                          (Ty.path
                                                                            "core::result::Result")
                                                                          []
                                                                          [
                                                                            Ty.path
                                                                              "core::convert::Infallible";
                                                                            Ty.path
                                                                              "core::fmt::Error"
                                                                          ]
                                                                      ],
                                                                      "from_residual",
                                                                      [],
                                                                      []
                                                                    |),
                                                                    [ M.read (| residual |) ]
                                                                  |)
                                                                |)
                                                              |)
                                                            |)
                                                          |)));
                                                      fun γ =>
                                                        ltac:(M.monadic
                                                          (let γ0_0 :=
                                                            M.SubPointer.get_struct_tuple_field (|
                                                              γ,
                                                              "core::ops::control_flow::ControlFlow::Continue",
                                                              0
                                                            |) in
                                                          let val := M.copy (| γ0_0 |) in
                                                          val))
                                                    ]
                                                  |)
                                                |) in
                                              M.alloc (| Value.Tuple [] |)))
                                        ]
                                      |)
                                    |) in
                                  M.alloc (| Value.Tuple [] |)))
                              |)))
                        ]
                      |))
                  |) in
                M.alloc (|
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                    M.get_associated_function (|
                      Ty.path "core::fmt::Formatter",
                      "write_fmt",
                      [],
                      []
                    |),
                    [
                      M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                      M.call_closure (|
                        Ty.path "core::fmt::Arguments",
                        M.get_associated_function (|
                          Ty.path "core::fmt::Arguments",
                          "new_const",
                          [ Value.Integer IntegerKind.Usize 1 ],
                          []
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (|
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.alloc (| Value.Array [ mk_str (| "]" |) ] |)
                              |)
                            |)
                          |)
                        ]
                      |)
                    ]
                  |)
                |)
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_move_binary_format_file_format_AbilitySet.
  
  (*
  Enum SignatureToken
  {
    const_params := [];
    ty_params := [];
    variants :=
      [
        {
          name := "Bool";
          item := StructTuple [];
        };
        {
          name := "U8";
          item := StructTuple [];
        };
        {
          name := "U64";
          item := StructTuple [];
        };
        {
          name := "U128";
          item := StructTuple [];
        };
        {
          name := "Address";
          item := StructTuple [];
        };
        {
          name := "Signer";
          item := StructTuple [];
        };
        {
          name := "Vector";
          item :=
            StructTuple
              [
                Ty.apply
                  (Ty.path "alloc::boxed::Box")
                  []
                  [
                    Ty.path "move_binary_format::file_format::SignatureToken";
                    Ty.path "alloc::alloc::Global"
                  ]
              ];
        };
        {
          name := "Struct";
          item := StructTuple [ Ty.path "move_binary_format::file_format::StructHandleIndex" ];
        };
        {
          name := "StructInstantiation";
          item :=
            StructTuple
              [
                Ty.apply
                  (Ty.path "alloc::boxed::Box")
                  []
                  [
                    Ty.tuple
                      [
                        Ty.path "move_binary_format::file_format::StructHandleIndex";
                        Ty.apply
                          (Ty.path "alloc::vec::Vec")
                          []
                          [
                            Ty.path "move_binary_format::file_format::SignatureToken";
                            Ty.path "alloc::alloc::Global"
                          ]
                      ];
                    Ty.path "alloc::alloc::Global"
                  ]
              ];
        };
        {
          name := "Reference";
          item :=
            StructTuple
              [
                Ty.apply
                  (Ty.path "alloc::boxed::Box")
                  []
                  [
                    Ty.path "move_binary_format::file_format::SignatureToken";
                    Ty.path "alloc::alloc::Global"
                  ]
              ];
        };
        {
          name := "MutableReference";
          item :=
            StructTuple
              [
                Ty.apply
                  (Ty.path "alloc::boxed::Box")
                  []
                  [
                    Ty.path "move_binary_format::file_format::SignatureToken";
                    Ty.path "alloc::alloc::Global"
                  ]
              ];
        };
        {
          name := "TypeParameter";
          item := StructTuple [ Ty.path "u16" ];
        };
        {
          name := "U16";
          item := StructTuple [];
        };
        {
          name := "U32";
          item := StructTuple [];
        };
        {
          name := "U256";
          item := StructTuple [];
        }
      ];
  }
  *)
  
  Axiom IsDiscriminant_SignatureToken_Bool :
    M.IsDiscriminant "move_binary_format::file_format::SignatureToken::Bool" 0.
  Axiom IsDiscriminant_SignatureToken_U8 :
    M.IsDiscriminant "move_binary_format::file_format::SignatureToken::U8" 1.
  Axiom IsDiscriminant_SignatureToken_U64 :
    M.IsDiscriminant "move_binary_format::file_format::SignatureToken::U64" 2.
  Axiom IsDiscriminant_SignatureToken_U128 :
    M.IsDiscriminant "move_binary_format::file_format::SignatureToken::U128" 3.
  Axiom IsDiscriminant_SignatureToken_Address :
    M.IsDiscriminant "move_binary_format::file_format::SignatureToken::Address" 4.
  Axiom IsDiscriminant_SignatureToken_Signer :
    M.IsDiscriminant "move_binary_format::file_format::SignatureToken::Signer" 5.
  Axiom IsDiscriminant_SignatureToken_Vector :
    M.IsDiscriminant "move_binary_format::file_format::SignatureToken::Vector" 6.
  Axiom IsDiscriminant_SignatureToken_Struct :
    M.IsDiscriminant "move_binary_format::file_format::SignatureToken::Struct" 7.
  Axiom IsDiscriminant_SignatureToken_StructInstantiation :
    M.IsDiscriminant "move_binary_format::file_format::SignatureToken::StructInstantiation" 8.
  Axiom IsDiscriminant_SignatureToken_Reference :
    M.IsDiscriminant "move_binary_format::file_format::SignatureToken::Reference" 9.
  Axiom IsDiscriminant_SignatureToken_MutableReference :
    M.IsDiscriminant "move_binary_format::file_format::SignatureToken::MutableReference" 10.
  Axiom IsDiscriminant_SignatureToken_TypeParameter :
    M.IsDiscriminant "move_binary_format::file_format::SignatureToken::TypeParameter" 11.
  Axiom IsDiscriminant_SignatureToken_U16 :
    M.IsDiscriminant "move_binary_format::file_format::SignatureToken::U16" 12.
  Axiom IsDiscriminant_SignatureToken_U32 :
    M.IsDiscriminant "move_binary_format::file_format::SignatureToken::U32" 13.
  Axiom IsDiscriminant_SignatureToken_U256 :
    M.IsDiscriminant "move_binary_format::file_format::SignatureToken::U256" 14.
  
  Module Impl_core_clone_Clone_for_move_binary_format_file_format_SignatureToken.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::SignatureToken".
    
    (* Clone *)
    Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Ty.apply
                (Ty.path "*")
                []
                [ Ty.path "move_binary_format::file_format::SignatureToken" ],
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "move_binary_format::file_format::SignatureToken::Bool"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_binary_format::file_format::SignatureToken::Bool"
                        []
                        []
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "move_binary_format::file_format::SignatureToken::U8"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_binary_format::file_format::SignatureToken::U8"
                        []
                        []
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "move_binary_format::file_format::SignatureToken::U64"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_binary_format::file_format::SignatureToken::U64"
                        []
                        []
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "move_binary_format::file_format::SignatureToken::U128"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_binary_format::file_format::SignatureToken::U128"
                        []
                        []
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "move_binary_format::file_format::SignatureToken::Address"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_binary_format::file_format::SignatureToken::Address"
                        []
                        []
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "move_binary_format::file_format::SignatureToken::Signer"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_binary_format::file_format::SignatureToken::Signer"
                        []
                        []
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::SignatureToken::Vector",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_binary_format::file_format::SignatureToken::Vector"
                        []
                        []
                        [
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "alloc::boxed::Box")
                              []
                              [
                                Ty.path "move_binary_format::file_format::SignatureToken";
                                Ty.path "alloc::alloc::Global"
                              ],
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.apply
                                (Ty.path "alloc::boxed::Box")
                                []
                                [
                                  Ty.path "move_binary_format::file_format::SignatureToken";
                                  Ty.path "alloc::alloc::Global"
                                ],
                              [],
                              [],
                              "clone",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::SignatureToken::Struct",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_binary_format::file_format::SignatureToken::Struct"
                        []
                        []
                        [
                          M.call_closure (|
                            Ty.path "move_binary_format::file_format::StructHandleIndex",
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.path "move_binary_format::file_format::StructHandleIndex",
                              [],
                              [],
                              "clone",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::SignatureToken::StructInstantiation",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_binary_format::file_format::SignatureToken::StructInstantiation"
                        []
                        []
                        [
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "alloc::boxed::Box")
                              []
                              [
                                Ty.tuple
                                  [
                                    Ty.path "move_binary_format::file_format::StructHandleIndex";
                                    Ty.apply
                                      (Ty.path "alloc::vec::Vec")
                                      []
                                      [
                                        Ty.path "move_binary_format::file_format::SignatureToken";
                                        Ty.path "alloc::alloc::Global"
                                      ]
                                  ];
                                Ty.path "alloc::alloc::Global"
                              ],
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.apply
                                (Ty.path "alloc::boxed::Box")
                                []
                                [
                                  Ty.tuple
                                    [
                                      Ty.path "move_binary_format::file_format::StructHandleIndex";
                                      Ty.apply
                                        (Ty.path "alloc::vec::Vec")
                                        []
                                        [
                                          Ty.path "move_binary_format::file_format::SignatureToken";
                                          Ty.path "alloc::alloc::Global"
                                        ]
                                    ];
                                  Ty.path "alloc::alloc::Global"
                                ],
                              [],
                              [],
                              "clone",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::SignatureToken::Reference",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_binary_format::file_format::SignatureToken::Reference"
                        []
                        []
                        [
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "alloc::boxed::Box")
                              []
                              [
                                Ty.path "move_binary_format::file_format::SignatureToken";
                                Ty.path "alloc::alloc::Global"
                              ],
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.apply
                                (Ty.path "alloc::boxed::Box")
                                []
                                [
                                  Ty.path "move_binary_format::file_format::SignatureToken";
                                  Ty.path "alloc::alloc::Global"
                                ],
                              [],
                              [],
                              "clone",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::SignatureToken::MutableReference",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_binary_format::file_format::SignatureToken::MutableReference"
                        []
                        []
                        [
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "alloc::boxed::Box")
                              []
                              [
                                Ty.path "move_binary_format::file_format::SignatureToken";
                                Ty.path "alloc::alloc::Global"
                              ],
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.apply
                                (Ty.path "alloc::boxed::Box")
                                []
                                [
                                  Ty.path "move_binary_format::file_format::SignatureToken";
                                  Ty.path "alloc::alloc::Global"
                                ],
                              [],
                              [],
                              "clone",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::SignatureToken::TypeParameter",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_binary_format::file_format::SignatureToken::TypeParameter"
                        []
                        []
                        [
                          M.call_closure (|
                            Ty.path "u16",
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.path "u16",
                              [],
                              [],
                              "clone",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "move_binary_format::file_format::SignatureToken::U16"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_binary_format::file_format::SignatureToken::U16"
                        []
                        []
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "move_binary_format::file_format::SignatureToken::U32"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_binary_format::file_format::SignatureToken::U32"
                        []
                        []
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "move_binary_format::file_format::SignatureToken::U256"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_binary_format::file_format::SignatureToken::U256"
                        []
                        []
                        []
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_move_binary_format_file_format_SignatureToken.
  
  Module Impl_core_cmp_Eq_for_move_binary_format_file_format_SignatureToken.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::SignatureToken".
    
    (* Eq *)
    Definition assert_receiver_is_total_eq
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              Value.DeclaredButUndefined,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                      Value.DeclaredButUndefined,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                              Value.DeclaredButUndefined,
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (M.match_operator (|
                                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                      Value.DeclaredButUndefined,
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (M.match_operator (|
                                              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                              Value.DeclaredButUndefined,
                                              [
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (M.match_operator (|
                                                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                                      Value.DeclaredButUndefined,
                                                      [
                                                        fun γ =>
                                                          ltac:(M.monadic
                                                            (M.alloc (| Value.Tuple [] |)))
                                                      ]
                                                    |)))
                                              ]
                                            |)))
                                      ]
                                    |)))
                              ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_move_binary_format_file_format_SignatureToken.
  
  Module Impl_core_hash_Hash_for_move_binary_format_file_format_SignatureToken.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::SignatureToken".
    
    (* Hash *)
    Definition hash (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ __H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let state := M.alloc (| state |) in
          M.read (|
            let~ __self_discr : Ty.path "isize" :=
              M.call_closure (|
                Ty.path "isize",
                M.get_function (|
                  "core::intrinsics::discriminant_value",
                  [],
                  [ Ty.path "move_binary_format::file_format::SignatureToken" ]
                |),
                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
              |) in
            let~ _ : Ty.tuple [] :=
              M.call_closure (|
                Ty.tuple [],
                M.get_trait_method (|
                  "core::hash::Hash",
                  Ty.path "isize",
                  [],
                  [],
                  "hash",
                  [],
                  [ __H ]
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (| M.borrow (| Pointer.Kind.Ref, __self_discr |) |)
                  |);
                  M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                ]
              |) in
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::SignatureToken::Vector",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.apply
                            (Ty.path "alloc::boxed::Box")
                            []
                            [
                              Ty.path "move_binary_format::file_format::SignatureToken";
                              Ty.path "alloc::alloc::Global"
                            ],
                          [],
                          [],
                          "hash",
                          [],
                          [ __H ]
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |);
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::SignatureToken::Struct",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.path "move_binary_format::file_format::StructHandleIndex",
                          [],
                          [],
                          "hash",
                          [],
                          [ __H ]
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |);
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::SignatureToken::StructInstantiation",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.apply
                            (Ty.path "alloc::boxed::Box")
                            []
                            [
                              Ty.tuple
                                [
                                  Ty.path "move_binary_format::file_format::StructHandleIndex";
                                  Ty.apply
                                    (Ty.path "alloc::vec::Vec")
                                    []
                                    [
                                      Ty.path "move_binary_format::file_format::SignatureToken";
                                      Ty.path "alloc::alloc::Global"
                                    ]
                                ];
                              Ty.path "alloc::alloc::Global"
                            ],
                          [],
                          [],
                          "hash",
                          [],
                          [ __H ]
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |);
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::SignatureToken::Reference",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.apply
                            (Ty.path "alloc::boxed::Box")
                            []
                            [
                              Ty.path "move_binary_format::file_format::SignatureToken";
                              Ty.path "alloc::alloc::Global"
                            ],
                          [],
                          [],
                          "hash",
                          [],
                          [ __H ]
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |);
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::SignatureToken::MutableReference",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.apply
                            (Ty.path "alloc::boxed::Box")
                            []
                            [
                              Ty.path "move_binary_format::file_format::SignatureToken";
                              Ty.path "alloc::alloc::Global"
                            ],
                          [],
                          [],
                          "hash",
                          [],
                          [ __H ]
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |);
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::SignatureToken::TypeParameter",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.path "u16",
                          [],
                          [],
                          "hash",
                          [],
                          [ __H ]
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |);
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                        ]
                      |)
                    |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::hash::Hash"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("hash", InstanceField.Method hash) ].
  End Impl_core_hash_Hash_for_move_binary_format_file_format_SignatureToken.
  
  Module Impl_core_cmp_Ord_for_move_binary_format_file_format_SignatureToken.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::SignatureToken".
    
    (* Ord *)
    Definition cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            let~ __self_discr : Ty.path "isize" :=
              M.call_closure (|
                Ty.path "isize",
                M.get_function (|
                  "core::intrinsics::discriminant_value",
                  [],
                  [ Ty.path "move_binary_format::file_format::SignatureToken" ]
                |),
                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
              |) in
            let~ __arg1_discr : Ty.path "isize" :=
              M.call_closure (|
                Ty.path "isize",
                M.get_function (|
                  "core::intrinsics::discriminant_value",
                  [],
                  [ Ty.path "move_binary_format::file_format::SignatureToken" ]
                |),
                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |) ]
              |) in
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.path "core::cmp::Ordering" ],
              M.alloc (|
                M.call_closure (|
                  Ty.path "core::cmp::Ordering",
                  M.get_trait_method (| "core::cmp::Ord", Ty.path "isize", [], [], "cmp", [], [] |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (| M.borrow (| Pointer.Kind.Ref, __self_discr |) |)
                    |);
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (| M.borrow (| Pointer.Kind.Ref, __arg1_discr |) |)
                    |)
                  ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_struct_tuple (| γ, "core::cmp::Ordering::Equal" |) in
                    M.match_operator (|
                      Ty.apply (Ty.path "*") [] [ Ty.path "core::cmp::Ordering" ],
                      M.alloc (| Value.Tuple [ M.read (| self |); M.read (| other |) ] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_0,
                                "move_binary_format::file_format::SignatureToken::Vector",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_1,
                                "move_binary_format::file_format::SignatureToken::Vector",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                Ty.path "core::cmp::Ordering",
                                M.get_trait_method (|
                                  "core::cmp::Ord",
                                  Ty.apply
                                    (Ty.path "alloc::boxed::Box")
                                    []
                                    [
                                      Ty.path "move_binary_format::file_format::SignatureToken";
                                      Ty.path "alloc::alloc::Global"
                                    ],
                                  [],
                                  [],
                                  "cmp",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| __self_0 |) |)
                                  |);
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| __arg1_0 |) |)
                                  |)
                                ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_0,
                                "move_binary_format::file_format::SignatureToken::Struct",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_1,
                                "move_binary_format::file_format::SignatureToken::Struct",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                Ty.path "core::cmp::Ordering",
                                M.get_trait_method (|
                                  "core::cmp::Ord",
                                  Ty.path "move_binary_format::file_format::StructHandleIndex",
                                  [],
                                  [],
                                  "cmp",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| __self_0 |) |)
                                  |);
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| __arg1_0 |) |)
                                  |)
                                ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_0,
                                "move_binary_format::file_format::SignatureToken::StructInstantiation",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_1,
                                "move_binary_format::file_format::SignatureToken::StructInstantiation",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                Ty.path "core::cmp::Ordering",
                                M.get_trait_method (|
                                  "core::cmp::Ord",
                                  Ty.apply
                                    (Ty.path "alloc::boxed::Box")
                                    []
                                    [
                                      Ty.tuple
                                        [
                                          Ty.path
                                            "move_binary_format::file_format::StructHandleIndex";
                                          Ty.apply
                                            (Ty.path "alloc::vec::Vec")
                                            []
                                            [
                                              Ty.path
                                                "move_binary_format::file_format::SignatureToken";
                                              Ty.path "alloc::alloc::Global"
                                            ]
                                        ];
                                      Ty.path "alloc::alloc::Global"
                                    ],
                                  [],
                                  [],
                                  "cmp",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| __self_0 |) |)
                                  |);
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| __arg1_0 |) |)
                                  |)
                                ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_0,
                                "move_binary_format::file_format::SignatureToken::Reference",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_1,
                                "move_binary_format::file_format::SignatureToken::Reference",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                Ty.path "core::cmp::Ordering",
                                M.get_trait_method (|
                                  "core::cmp::Ord",
                                  Ty.apply
                                    (Ty.path "alloc::boxed::Box")
                                    []
                                    [
                                      Ty.path "move_binary_format::file_format::SignatureToken";
                                      Ty.path "alloc::alloc::Global"
                                    ],
                                  [],
                                  [],
                                  "cmp",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| __self_0 |) |)
                                  |);
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| __arg1_0 |) |)
                                  |)
                                ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_0,
                                "move_binary_format::file_format::SignatureToken::MutableReference",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_1,
                                "move_binary_format::file_format::SignatureToken::MutableReference",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                Ty.path "core::cmp::Ordering",
                                M.get_trait_method (|
                                  "core::cmp::Ord",
                                  Ty.apply
                                    (Ty.path "alloc::boxed::Box")
                                    []
                                    [
                                      Ty.path "move_binary_format::file_format::SignatureToken";
                                      Ty.path "alloc::alloc::Global"
                                    ],
                                  [],
                                  [],
                                  "cmp",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| __self_0 |) |)
                                  |);
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| __arg1_0 |) |)
                                  |)
                                ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_0,
                                "move_binary_format::file_format::SignatureToken::TypeParameter",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_1,
                                "move_binary_format::file_format::SignatureToken::TypeParameter",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                Ty.path "core::cmp::Ordering",
                                M.get_trait_method (|
                                  "core::cmp::Ord",
                                  Ty.path "u16",
                                  [],
                                  [],
                                  "cmp",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| __self_0 |) |)
                                  |);
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| M.read (| __arg1_0 |) |)
                                  |)
                                ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (| Value.StructTuple "core::cmp::Ordering::Equal" [] [] [] |)))
                      ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let cmp := M.copy (| γ |) in
                    cmp))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Ord"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("cmp", InstanceField.Method cmp) ].
  End Impl_core_cmp_Ord_for_move_binary_format_file_format_SignatureToken.
  
  Module Impl_core_marker_StructuralPartialEq_for_move_binary_format_file_format_SignatureToken.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::SignatureToken".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_move_binary_format_file_format_SignatureToken.
  
  Module Impl_core_cmp_PartialEq_move_binary_format_file_format_SignatureToken_for_move_binary_format_file_format_SignatureToken.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::SignatureToken".
    
    (* PartialEq *)
    Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            let~ __self_discr : Ty.path "isize" :=
              M.call_closure (|
                Ty.path "isize",
                M.get_function (|
                  "core::intrinsics::discriminant_value",
                  [],
                  [ Ty.path "move_binary_format::file_format::SignatureToken" ]
                |),
                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
              |) in
            let~ __arg1_discr : Ty.path "isize" :=
              M.call_closure (|
                Ty.path "isize",
                M.get_function (|
                  "core::intrinsics::discriminant_value",
                  [],
                  [ Ty.path "move_binary_format::file_format::SignatureToken" ]
                |),
                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |) ]
              |) in
            M.alloc (|
              LogicalOp.and (|
                M.call_closure (|
                  Ty.path "bool",
                  BinOp.eq,
                  [ M.read (| __self_discr |); M.read (| __arg1_discr |) ]
                |),
                ltac:(M.monadic
                  (M.read (|
                    M.match_operator (|
                      Ty.apply (Ty.path "*") [] [ Ty.path "bool" ],
                      M.alloc (| Value.Tuple [ M.read (| self |); M.read (| other |) ] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_0,
                                "move_binary_format::file_format::SignatureToken::Vector",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_1,
                                "move_binary_format::file_format::SignatureToken::Vector",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.apply
                                    (Ty.path "&")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "alloc::boxed::Box")
                                        []
                                        [
                                          Ty.path "move_binary_format::file_format::SignatureToken";
                                          Ty.path "alloc::alloc::Global"
                                        ]
                                    ],
                                  [],
                                  [
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "alloc::boxed::Box")
                                          []
                                          [
                                            Ty.path
                                              "move_binary_format::file_format::SignatureToken";
                                            Ty.path "alloc::alloc::Global"
                                          ]
                                      ]
                                  ],
                                  "eq",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (| Pointer.Kind.Ref, __self_0 |);
                                  M.borrow (| Pointer.Kind.Ref, __arg1_0 |)
                                ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_0,
                                "move_binary_format::file_format::SignatureToken::Struct",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_1,
                                "move_binary_format::file_format::SignatureToken::Struct",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.apply
                                    (Ty.path "&")
                                    []
                                    [ Ty.path "move_binary_format::file_format::StructHandleIndex"
                                    ],
                                  [],
                                  [
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [ Ty.path "move_binary_format::file_format::StructHandleIndex"
                                      ]
                                  ],
                                  "eq",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (| Pointer.Kind.Ref, __self_0 |);
                                  M.borrow (| Pointer.Kind.Ref, __arg1_0 |)
                                ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_0,
                                "move_binary_format::file_format::SignatureToken::StructInstantiation",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_1,
                                "move_binary_format::file_format::SignatureToken::StructInstantiation",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.apply
                                    (Ty.path "&")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "alloc::boxed::Box")
                                        []
                                        [
                                          Ty.tuple
                                            [
                                              Ty.path
                                                "move_binary_format::file_format::StructHandleIndex";
                                              Ty.apply
                                                (Ty.path "alloc::vec::Vec")
                                                []
                                                [
                                                  Ty.path
                                                    "move_binary_format::file_format::SignatureToken";
                                                  Ty.path "alloc::alloc::Global"
                                                ]
                                            ];
                                          Ty.path "alloc::alloc::Global"
                                        ]
                                    ],
                                  [],
                                  [
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "alloc::boxed::Box")
                                          []
                                          [
                                            Ty.tuple
                                              [
                                                Ty.path
                                                  "move_binary_format::file_format::StructHandleIndex";
                                                Ty.apply
                                                  (Ty.path "alloc::vec::Vec")
                                                  []
                                                  [
                                                    Ty.path
                                                      "move_binary_format::file_format::SignatureToken";
                                                    Ty.path "alloc::alloc::Global"
                                                  ]
                                              ];
                                            Ty.path "alloc::alloc::Global"
                                          ]
                                      ]
                                  ],
                                  "eq",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (| Pointer.Kind.Ref, __self_0 |);
                                  M.borrow (| Pointer.Kind.Ref, __arg1_0 |)
                                ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_0,
                                "move_binary_format::file_format::SignatureToken::Reference",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_1,
                                "move_binary_format::file_format::SignatureToken::Reference",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.apply
                                    (Ty.path "&")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "alloc::boxed::Box")
                                        []
                                        [
                                          Ty.path "move_binary_format::file_format::SignatureToken";
                                          Ty.path "alloc::alloc::Global"
                                        ]
                                    ],
                                  [],
                                  [
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "alloc::boxed::Box")
                                          []
                                          [
                                            Ty.path
                                              "move_binary_format::file_format::SignatureToken";
                                            Ty.path "alloc::alloc::Global"
                                          ]
                                      ]
                                  ],
                                  "eq",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (| Pointer.Kind.Ref, __self_0 |);
                                  M.borrow (| Pointer.Kind.Ref, __arg1_0 |)
                                ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_0,
                                "move_binary_format::file_format::SignatureToken::MutableReference",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_1,
                                "move_binary_format::file_format::SignatureToken::MutableReference",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.apply
                                    (Ty.path "&")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "alloc::boxed::Box")
                                        []
                                        [
                                          Ty.path "move_binary_format::file_format::SignatureToken";
                                          Ty.path "alloc::alloc::Global"
                                        ]
                                    ],
                                  [],
                                  [
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "alloc::boxed::Box")
                                          []
                                          [
                                            Ty.path
                                              "move_binary_format::file_format::SignatureToken";
                                            Ty.path "alloc::alloc::Global"
                                          ]
                                      ]
                                  ],
                                  "eq",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (| Pointer.Kind.Ref, __self_0 |);
                                  M.borrow (| Pointer.Kind.Ref, __arg1_0 |)
                                ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_0,
                                "move_binary_format::file_format::SignatureToken::TypeParameter",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_1,
                                "move_binary_format::file_format::SignatureToken::TypeParameter",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.apply (Ty.path "&") [] [ Ty.path "u16" ],
                                  [],
                                  [ Ty.apply (Ty.path "&") [] [ Ty.path "u16" ] ],
                                  "eq",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (| Pointer.Kind.Ref, __self_0 |);
                                  M.borrow (| Pointer.Kind.Ref, __arg1_0 |)
                                ]
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Bool true |)))
                      ]
                    |)
                  |)))
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "move_binary_format::file_format::SignatureToken" ]
        Self
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_move_binary_format_file_format_SignatureToken_for_move_binary_format_file_format_SignatureToken.
  
  Module Impl_core_cmp_PartialOrd_move_binary_format_file_format_SignatureToken_for_move_binary_format_file_format_SignatureToken.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::SignatureToken".
    
    (* PartialOrd *)
    Definition partial_cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            let~ __self_discr : Ty.path "isize" :=
              M.call_closure (|
                Ty.path "isize",
                M.get_function (|
                  "core::intrinsics::discriminant_value",
                  [],
                  [ Ty.path "move_binary_format::file_format::SignatureToken" ]
                |),
                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
              |) in
            let~ __arg1_discr : Ty.path "isize" :=
              M.call_closure (|
                Ty.path "isize",
                M.get_function (|
                  "core::intrinsics::discriminant_value",
                  [],
                  [ Ty.path "move_binary_format::file_format::SignatureToken" ]
                |),
                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |) ]
              |) in
            M.match_operator (|
              Ty.apply
                (Ty.path "*")
                []
                [ Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "core::cmp::Ordering" ] ],
              M.alloc (| Value.Tuple [ M.read (| self |); M.read (| other |) ] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let γ0_0 := M.read (| γ0_0 |) in
                    let γ2_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ0_0,
                        "move_binary_format::file_format::SignatureToken::Vector",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ2_0 |) in
                    let γ0_1 := M.read (| γ0_1 |) in
                    let γ2_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ0_1,
                        "move_binary_format::file_format::SignatureToken::Vector",
                        0
                      |) in
                    let __arg1_0 := M.alloc (| γ2_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::option::Option")
                          []
                          [ Ty.path "core::cmp::Ordering" ],
                        M.get_trait_method (|
                          "core::cmp::PartialOrd",
                          Ty.apply
                            (Ty.path "alloc::boxed::Box")
                            []
                            [
                              Ty.path "move_binary_format::file_format::SignatureToken";
                              Ty.path "alloc::alloc::Global"
                            ],
                          [],
                          [
                            Ty.apply
                              (Ty.path "alloc::boxed::Box")
                              []
                              [
                                Ty.path "move_binary_format::file_format::SignatureToken";
                                Ty.path "alloc::alloc::Global"
                              ]
                          ],
                          "partial_cmp",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |);
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __arg1_0 |) |) |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let γ0_0 := M.read (| γ0_0 |) in
                    let γ2_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ0_0,
                        "move_binary_format::file_format::SignatureToken::Struct",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ2_0 |) in
                    let γ0_1 := M.read (| γ0_1 |) in
                    let γ2_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ0_1,
                        "move_binary_format::file_format::SignatureToken::Struct",
                        0
                      |) in
                    let __arg1_0 := M.alloc (| γ2_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::option::Option")
                          []
                          [ Ty.path "core::cmp::Ordering" ],
                        M.get_trait_method (|
                          "core::cmp::PartialOrd",
                          Ty.path "move_binary_format::file_format::StructHandleIndex",
                          [],
                          [ Ty.path "move_binary_format::file_format::StructHandleIndex" ],
                          "partial_cmp",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |);
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __arg1_0 |) |) |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let γ0_0 := M.read (| γ0_0 |) in
                    let γ2_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ0_0,
                        "move_binary_format::file_format::SignatureToken::StructInstantiation",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ2_0 |) in
                    let γ0_1 := M.read (| γ0_1 |) in
                    let γ2_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ0_1,
                        "move_binary_format::file_format::SignatureToken::StructInstantiation",
                        0
                      |) in
                    let __arg1_0 := M.alloc (| γ2_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::option::Option")
                          []
                          [ Ty.path "core::cmp::Ordering" ],
                        M.get_trait_method (|
                          "core::cmp::PartialOrd",
                          Ty.apply
                            (Ty.path "alloc::boxed::Box")
                            []
                            [
                              Ty.tuple
                                [
                                  Ty.path "move_binary_format::file_format::StructHandleIndex";
                                  Ty.apply
                                    (Ty.path "alloc::vec::Vec")
                                    []
                                    [
                                      Ty.path "move_binary_format::file_format::SignatureToken";
                                      Ty.path "alloc::alloc::Global"
                                    ]
                                ];
                              Ty.path "alloc::alloc::Global"
                            ],
                          [],
                          [
                            Ty.apply
                              (Ty.path "alloc::boxed::Box")
                              []
                              [
                                Ty.tuple
                                  [
                                    Ty.path "move_binary_format::file_format::StructHandleIndex";
                                    Ty.apply
                                      (Ty.path "alloc::vec::Vec")
                                      []
                                      [
                                        Ty.path "move_binary_format::file_format::SignatureToken";
                                        Ty.path "alloc::alloc::Global"
                                      ]
                                  ];
                                Ty.path "alloc::alloc::Global"
                              ]
                          ],
                          "partial_cmp",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |);
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __arg1_0 |) |) |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let γ0_0 := M.read (| γ0_0 |) in
                    let γ2_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ0_0,
                        "move_binary_format::file_format::SignatureToken::Reference",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ2_0 |) in
                    let γ0_1 := M.read (| γ0_1 |) in
                    let γ2_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ0_1,
                        "move_binary_format::file_format::SignatureToken::Reference",
                        0
                      |) in
                    let __arg1_0 := M.alloc (| γ2_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::option::Option")
                          []
                          [ Ty.path "core::cmp::Ordering" ],
                        M.get_trait_method (|
                          "core::cmp::PartialOrd",
                          Ty.apply
                            (Ty.path "alloc::boxed::Box")
                            []
                            [
                              Ty.path "move_binary_format::file_format::SignatureToken";
                              Ty.path "alloc::alloc::Global"
                            ],
                          [],
                          [
                            Ty.apply
                              (Ty.path "alloc::boxed::Box")
                              []
                              [
                                Ty.path "move_binary_format::file_format::SignatureToken";
                                Ty.path "alloc::alloc::Global"
                              ]
                          ],
                          "partial_cmp",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |);
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __arg1_0 |) |) |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let γ0_0 := M.read (| γ0_0 |) in
                    let γ2_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ0_0,
                        "move_binary_format::file_format::SignatureToken::MutableReference",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ2_0 |) in
                    let γ0_1 := M.read (| γ0_1 |) in
                    let γ2_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ0_1,
                        "move_binary_format::file_format::SignatureToken::MutableReference",
                        0
                      |) in
                    let __arg1_0 := M.alloc (| γ2_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::option::Option")
                          []
                          [ Ty.path "core::cmp::Ordering" ],
                        M.get_trait_method (|
                          "core::cmp::PartialOrd",
                          Ty.apply
                            (Ty.path "alloc::boxed::Box")
                            []
                            [
                              Ty.path "move_binary_format::file_format::SignatureToken";
                              Ty.path "alloc::alloc::Global"
                            ],
                          [],
                          [
                            Ty.apply
                              (Ty.path "alloc::boxed::Box")
                              []
                              [
                                Ty.path "move_binary_format::file_format::SignatureToken";
                                Ty.path "alloc::alloc::Global"
                              ]
                          ],
                          "partial_cmp",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |);
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __arg1_0 |) |) |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let γ0_0 := M.read (| γ0_0 |) in
                    let γ2_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ0_0,
                        "move_binary_format::file_format::SignatureToken::TypeParameter",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ2_0 |) in
                    let γ0_1 := M.read (| γ0_1 |) in
                    let γ2_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ0_1,
                        "move_binary_format::file_format::SignatureToken::TypeParameter",
                        0
                      |) in
                    let __arg1_0 := M.alloc (| γ2_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::option::Option")
                          []
                          [ Ty.path "core::cmp::Ordering" ],
                        M.get_trait_method (|
                          "core::cmp::PartialOrd",
                          Ty.path "u16",
                          [],
                          [ Ty.path "u16" ],
                          "partial_cmp",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |);
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __arg1_0 |) |) |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::option::Option")
                          []
                          [ Ty.path "core::cmp::Ordering" ],
                        M.get_trait_method (|
                          "core::cmp::PartialOrd",
                          Ty.path "isize",
                          [],
                          [ Ty.path "isize" ],
                          "partial_cmp",
                          [],
                          []
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| M.borrow (| Pointer.Kind.Ref, __self_discr |) |)
                          |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| M.borrow (| Pointer.Kind.Ref, __arg1_discr |) |)
                          |)
                        ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialOrd"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "move_binary_format::file_format::SignatureToken" ]
        Self
        (* Instance *) [ ("partial_cmp", InstanceField.Method partial_cmp) ].
  End Impl_core_cmp_PartialOrd_move_binary_format_file_format_SignatureToken_for_move_binary_format_file_format_SignatureToken.
  
  (* StructRecord
    {
      name := "SignatureTokenPreorderTraversalIter";
      const_params := [];
      ty_params := [];
      fields :=
        [
          ("stack",
            Ty.apply
              (Ty.path "alloc::vec::Vec")
              []
              [
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.path "move_binary_format::file_format::SignatureToken" ];
                Ty.path "alloc::alloc::Global"
              ])
        ];
    } *)
  
  Module Impl_core_iter_traits_iterator_Iterator_for_move_binary_format_file_format_SignatureTokenPreorderTraversalIter.
    Definition Self : Ty.t :=
      Ty.path "move_binary_format::file_format::SignatureTokenPreorderTraversalIter".
    
    (*     type Item = &'a SignatureToken; *)
    Definition _Item : Ty.t :=
      Ty.apply (Ty.path "&") [] [ Ty.path "move_binary_format::file_format::SignatureToken" ].
    
    (*
        fn next(&mut self) -> Option<Self::Item> {
            use SignatureToken::*;
    
            match self.stack.pop() {
                Some(tok) => {
                    match tok {
                        Reference(inner_tok) | MutableReference(inner_tok) | Vector(inner_tok) => {
                            self.stack.push(inner_tok)
                        }
    
                        StructInstantiation(struct_inst) => {
                            let (_, inner_toks) = &**struct_inst;
                            self.stack.extend(inner_toks.iter().rev())
                        }
    
                        Signer | Bool | Address | U8 | U16 | U32 | U64 | U128 | U256 | Struct(_)
                        | TypeParameter(_) => (),
                    }
                    Some(tok)
                }
                None => None,
            }
        }
    *)
    Definition next (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Ty.apply
                (Ty.path "*")
                []
                [
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [
                      Ty.apply
                        (Ty.path "&")
                        []
                        [ Ty.path "move_binary_format::file_format::SignatureToken" ]
                    ]
                ],
              M.alloc (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [
                      Ty.apply
                        (Ty.path "&")
                        []
                        [ Ty.path "move_binary_format::file_format::SignatureToken" ]
                    ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      []
                      [
                        Ty.apply
                          (Ty.path "&")
                          []
                          [ Ty.path "move_binary_format::file_format::SignatureToken" ];
                        Ty.path "alloc::alloc::Global"
                      ],
                    "pop",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "move_binary_format::file_format::SignatureTokenPreorderTraversalIter",
                        "stack"
                      |)
                    |)
                  ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let tok := M.copy (| γ0_0 |) in
                    let~ _ : Ty.tuple [] :=
                      M.read (|
                        M.match_operator (|
                          Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                          tok,
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (M.find_or_pattern
                                  (Ty.tuple
                                    [
                                      Ty.apply
                                        (Ty.path "&")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "alloc::boxed::Box")
                                            []
                                            [
                                              Ty.path
                                                "move_binary_format::file_format::SignatureToken";
                                              Ty.path "alloc::alloc::Global"
                                            ]
                                        ]
                                    ]) (|
                                  γ,
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ := M.read (| γ |) in
                                        let γ1_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "move_binary_format::file_format::SignatureToken::Reference",
                                            0
                                          |) in
                                        let inner_tok := M.alloc (| γ1_0 |) in
                                        Value.Tuple [ inner_tok ]));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ := M.read (| γ |) in
                                        let γ1_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "move_binary_format::file_format::SignatureToken::MutableReference",
                                            0
                                          |) in
                                        let inner_tok := M.alloc (| γ1_0 |) in
                                        Value.Tuple [ inner_tok ]));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ := M.read (| γ |) in
                                        let γ1_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "move_binary_format::file_format::SignatureToken::Vector",
                                            0
                                          |) in
                                        let inner_tok := M.alloc (| γ1_0 |) in
                                        Value.Tuple [ inner_tok ]))
                                  ],
                                  fun γ =>
                                    ltac:(M.monadic
                                      match γ with
                                      | [ inner_tok ] =>
                                        ltac:(M.monadic
                                          (M.alloc (|
                                            M.call_closure (|
                                              Ty.tuple [],
                                              M.get_associated_function (|
                                                Ty.apply
                                                  (Ty.path "alloc::vec::Vec")
                                                  []
                                                  [
                                                    Ty.apply
                                                      (Ty.path "&")
                                                      []
                                                      [
                                                        Ty.path
                                                          "move_binary_format::file_format::SignatureToken"
                                                      ];
                                                    Ty.path "alloc::alloc::Global"
                                                  ],
                                                "push",
                                                [],
                                                []
                                              |),
                                              [
                                                M.borrow (|
                                                  Pointer.Kind.MutRef,
                                                  M.SubPointer.get_struct_record_field (|
                                                    M.deref (| M.read (| self |) |),
                                                    "move_binary_format::file_format::SignatureTokenPreorderTraversalIter",
                                                    "stack"
                                                  |)
                                                |);
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (|
                                                    M.read (|
                                                      M.deref (| M.read (| inner_tok |) |)
                                                    |)
                                                  |)
                                                |)
                                              ]
                                            |)
                                          |)))
                                      | _ => M.impossible "wrong number of arguments"
                                      end)
                                |)));
                            fun γ =>
                              ltac:(M.monadic
                                (let γ := M.read (| γ |) in
                                let γ1_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "move_binary_format::file_format::SignatureToken::StructInstantiation",
                                    0
                                  |) in
                                let struct_inst := M.alloc (| γ1_0 |) in
                                M.match_operator (|
                                  Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                  M.alloc (|
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (|
                                        M.read (| M.deref (| M.read (| struct_inst |) |) |)
                                      |)
                                    |)
                                  |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ := M.read (| γ |) in
                                        let γ1_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                        let γ1_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                        let inner_toks := M.alloc (| γ1_1 |) in
                                        M.alloc (|
                                          M.call_closure (|
                                            Ty.tuple [],
                                            M.get_trait_method (|
                                              "core::iter::traits::collect::Extend",
                                              Ty.apply
                                                (Ty.path "alloc::vec::Vec")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "&")
                                                    []
                                                    [
                                                      Ty.path
                                                        "move_binary_format::file_format::SignatureToken"
                                                    ];
                                                  Ty.path "alloc::alloc::Global"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "&")
                                                  []
                                                  [
                                                    Ty.path
                                                      "move_binary_format::file_format::SignatureToken"
                                                  ]
                                              ],
                                              "extend",
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::iter::adapters::rev::Rev")
                                                  []
                                                  [
                                                    Ty.apply
                                                      (Ty.path "core::slice::iter::Iter")
                                                      []
                                                      [
                                                        Ty.path
                                                          "move_binary_format::file_format::SignatureToken"
                                                      ]
                                                  ]
                                              ]
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.MutRef,
                                                M.SubPointer.get_struct_record_field (|
                                                  M.deref (| M.read (| self |) |),
                                                  "move_binary_format::file_format::SignatureTokenPreorderTraversalIter",
                                                  "stack"
                                                |)
                                              |);
                                              M.call_closure (|
                                                Ty.apply
                                                  (Ty.path "core::iter::adapters::rev::Rev")
                                                  []
                                                  [
                                                    Ty.apply
                                                      (Ty.path "core::slice::iter::Iter")
                                                      []
                                                      [
                                                        Ty.path
                                                          "move_binary_format::file_format::SignatureToken"
                                                      ]
                                                  ],
                                                M.get_trait_method (|
                                                  "core::iter::traits::iterator::Iterator",
                                                  Ty.apply
                                                    (Ty.path "core::slice::iter::Iter")
                                                    []
                                                    [
                                                      Ty.path
                                                        "move_binary_format::file_format::SignatureToken"
                                                    ],
                                                  [],
                                                  [],
                                                  "rev",
                                                  [],
                                                  []
                                                |),
                                                [
                                                  M.call_closure (|
                                                    Ty.apply
                                                      (Ty.path "core::slice::iter::Iter")
                                                      []
                                                      [
                                                        Ty.path
                                                          "move_binary_format::file_format::SignatureToken"
                                                      ],
                                                    M.get_associated_function (|
                                                      Ty.apply
                                                        (Ty.path "slice")
                                                        []
                                                        [
                                                          Ty.path
                                                            "move_binary_format::file_format::SignatureToken"
                                                        ],
                                                      "iter",
                                                      [],
                                                      []
                                                    |),
                                                    [
                                                      M.borrow (|
                                                        Pointer.Kind.Ref,
                                                        M.deref (|
                                                          M.call_closure (|
                                                            Ty.apply
                                                              (Ty.path "&")
                                                              []
                                                              [
                                                                Ty.apply
                                                                  (Ty.path "slice")
                                                                  []
                                                                  [
                                                                    Ty.path
                                                                      "move_binary_format::file_format::SignatureToken"
                                                                  ]
                                                              ],
                                                            M.get_trait_method (|
                                                              "core::ops::deref::Deref",
                                                              Ty.apply
                                                                (Ty.path "alloc::vec::Vec")
                                                                []
                                                                [
                                                                  Ty.path
                                                                    "move_binary_format::file_format::SignatureToken";
                                                                  Ty.path "alloc::alloc::Global"
                                                                ],
                                                              [],
                                                              [],
                                                              "deref",
                                                              [],
                                                              []
                                                            |),
                                                            [
                                                              M.borrow (|
                                                                Pointer.Kind.Ref,
                                                                M.deref (|
                                                                  M.read (| inner_toks |)
                                                                |)
                                                              |)
                                                            ]
                                                          |)
                                                        |)
                                                      |)
                                                    ]
                                                  |)
                                                ]
                                              |)
                                            ]
                                          |)
                                        |)))
                                  ]
                                |)));
                            fun γ =>
                              ltac:(M.monadic
                                (M.find_or_pattern (Ty.tuple []) (|
                                  γ,
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ := M.read (| γ |) in
                                        let _ :=
                                          M.is_struct_tuple (|
                                            γ,
                                            "move_binary_format::file_format::SignatureToken::Signer"
                                          |) in
                                        Value.Tuple []));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ := M.read (| γ |) in
                                        let _ :=
                                          M.is_struct_tuple (|
                                            γ,
                                            "move_binary_format::file_format::SignatureToken::Bool"
                                          |) in
                                        Value.Tuple []));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ := M.read (| γ |) in
                                        let _ :=
                                          M.is_struct_tuple (|
                                            γ,
                                            "move_binary_format::file_format::SignatureToken::Address"
                                          |) in
                                        Value.Tuple []));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ := M.read (| γ |) in
                                        let _ :=
                                          M.is_struct_tuple (|
                                            γ,
                                            "move_binary_format::file_format::SignatureToken::U8"
                                          |) in
                                        Value.Tuple []));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ := M.read (| γ |) in
                                        let _ :=
                                          M.is_struct_tuple (|
                                            γ,
                                            "move_binary_format::file_format::SignatureToken::U16"
                                          |) in
                                        Value.Tuple []));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ := M.read (| γ |) in
                                        let _ :=
                                          M.is_struct_tuple (|
                                            γ,
                                            "move_binary_format::file_format::SignatureToken::U32"
                                          |) in
                                        Value.Tuple []));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ := M.read (| γ |) in
                                        let _ :=
                                          M.is_struct_tuple (|
                                            γ,
                                            "move_binary_format::file_format::SignatureToken::U64"
                                          |) in
                                        Value.Tuple []));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ := M.read (| γ |) in
                                        let _ :=
                                          M.is_struct_tuple (|
                                            γ,
                                            "move_binary_format::file_format::SignatureToken::U128"
                                          |) in
                                        Value.Tuple []));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ := M.read (| γ |) in
                                        let _ :=
                                          M.is_struct_tuple (|
                                            γ,
                                            "move_binary_format::file_format::SignatureToken::U256"
                                          |) in
                                        Value.Tuple []));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ := M.read (| γ |) in
                                        let γ1_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "move_binary_format::file_format::SignatureToken::Struct",
                                            0
                                          |) in
                                        Value.Tuple []));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ := M.read (| γ |) in
                                        let γ1_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "move_binary_format::file_format::SignatureToken::TypeParameter",
                                            0
                                          |) in
                                        Value.Tuple []))
                                  ],
                                  fun γ =>
                                    ltac:(M.monadic
                                      match γ with
                                      | [] => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                      | _ => M.impossible "wrong number of arguments"
                                      end)
                                |)))
                          ]
                        |)
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        []
                        [
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.path "move_binary_format::file_format::SignatureToken" ]
                        ]
                        [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| tok |) |) |) ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::option::Option::None"
                        []
                        [
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.path "move_binary_format::file_format::SignatureToken" ]
                        ]
                        []
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::iter::traits::iterator::Iterator"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("Item", InstanceField.Ty _Item); ("next", InstanceField.Method next) ].
  End Impl_core_iter_traits_iterator_Iterator_for_move_binary_format_file_format_SignatureTokenPreorderTraversalIter.
  
  (* StructRecord
    {
      name := "SignatureTokenPreorderTraversalIterWithDepth";
      const_params := [];
      ty_params := [];
      fields :=
        [
          ("stack",
            Ty.apply
              (Ty.path "alloc::vec::Vec")
              []
              [
                Ty.tuple
                  [
                    Ty.apply
                      (Ty.path "&")
                      []
                      [ Ty.path "move_binary_format::file_format::SignatureToken" ];
                    Ty.path "usize"
                  ];
                Ty.path "alloc::alloc::Global"
              ])
        ];
    } *)
  
  Module Impl_core_iter_traits_iterator_Iterator_for_move_binary_format_file_format_SignatureTokenPreorderTraversalIterWithDepth.
    Definition Self : Ty.t :=
      Ty.path "move_binary_format::file_format::SignatureTokenPreorderTraversalIterWithDepth".
    
    (*     type Item = (&'a SignatureToken, usize); *)
    Definition _Item : Ty.t :=
      Ty.tuple
        [
          Ty.apply (Ty.path "&") [] [ Ty.path "move_binary_format::file_format::SignatureToken" ];
          Ty.path "usize"
        ].
    
    (*
        fn next(&mut self) -> Option<Self::Item> {
            use SignatureToken::*;
    
            match self.stack.pop() {
                Some((tok, depth)) => {
                    match tok {
                        Reference(inner_tok) | MutableReference(inner_tok) | Vector(inner_tok) => {
                            self.stack.push((inner_tok, depth + 1))
                        }
    
                        StructInstantiation(struct_inst) => {
                            let (_, inner_toks) = &**struct_inst;
                            self.stack
                                .extend(inner_toks.iter().map(|tok| (tok, depth + 1)).rev())
                        }
    
                        Signer | Bool | Address | U8 | U16 | U32 | U64 | U128 | U256 | Struct(_)
                        | TypeParameter(_) => (),
                    }
                    Some((tok, depth))
                }
                None => None,
            }
        }
    *)
    Definition next (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Ty.apply
                (Ty.path "*")
                []
                [
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [
                      Ty.tuple
                        [
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.path "move_binary_format::file_format::SignatureToken" ];
                          Ty.path "usize"
                        ]
                    ]
                ],
              M.alloc (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [
                      Ty.tuple
                        [
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.path "move_binary_format::file_format::SignatureToken" ];
                          Ty.path "usize"
                        ]
                    ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      []
                      [
                        Ty.tuple
                          [
                            Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.path "move_binary_format::file_format::SignatureToken" ];
                            Ty.path "usize"
                          ];
                        Ty.path "alloc::alloc::Global"
                      ],
                    "pop",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "move_binary_format::file_format::SignatureTokenPreorderTraversalIterWithDepth",
                        "stack"
                      |)
                    |)
                  ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "core::option::Option::Some",
                        0
                      |) in
                    let γ1_0 := M.SubPointer.get_tuple_field (| γ0_0, 0 |) in
                    let γ1_1 := M.SubPointer.get_tuple_field (| γ0_0, 1 |) in
                    let tok := M.copy (| γ1_0 |) in
                    let depth := M.copy (| γ1_1 |) in
                    let~ _ : Ty.tuple [] :=
                      M.read (|
                        M.match_operator (|
                          Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                          tok,
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (M.find_or_pattern
                                  (Ty.tuple
                                    [
                                      Ty.apply
                                        (Ty.path "&")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "alloc::boxed::Box")
                                            []
                                            [
                                              Ty.path
                                                "move_binary_format::file_format::SignatureToken";
                                              Ty.path "alloc::alloc::Global"
                                            ]
                                        ]
                                    ]) (|
                                  γ,
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ := M.read (| γ |) in
                                        let γ1_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "move_binary_format::file_format::SignatureToken::Reference",
                                            0
                                          |) in
                                        let inner_tok := M.alloc (| γ1_0 |) in
                                        Value.Tuple [ inner_tok ]));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ := M.read (| γ |) in
                                        let γ1_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "move_binary_format::file_format::SignatureToken::MutableReference",
                                            0
                                          |) in
                                        let inner_tok := M.alloc (| γ1_0 |) in
                                        Value.Tuple [ inner_tok ]));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ := M.read (| γ |) in
                                        let γ1_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "move_binary_format::file_format::SignatureToken::Vector",
                                            0
                                          |) in
                                        let inner_tok := M.alloc (| γ1_0 |) in
                                        Value.Tuple [ inner_tok ]))
                                  ],
                                  fun γ =>
                                    ltac:(M.monadic
                                      match γ with
                                      | [ inner_tok ] =>
                                        ltac:(M.monadic
                                          (M.alloc (|
                                            M.call_closure (|
                                              Ty.tuple [],
                                              M.get_associated_function (|
                                                Ty.apply
                                                  (Ty.path "alloc::vec::Vec")
                                                  []
                                                  [
                                                    Ty.tuple
                                                      [
                                                        Ty.apply
                                                          (Ty.path "&")
                                                          []
                                                          [
                                                            Ty.path
                                                              "move_binary_format::file_format::SignatureToken"
                                                          ];
                                                        Ty.path "usize"
                                                      ];
                                                    Ty.path "alloc::alloc::Global"
                                                  ],
                                                "push",
                                                [],
                                                []
                                              |),
                                              [
                                                M.borrow (|
                                                  Pointer.Kind.MutRef,
                                                  M.SubPointer.get_struct_record_field (|
                                                    M.deref (| M.read (| self |) |),
                                                    "move_binary_format::file_format::SignatureTokenPreorderTraversalIterWithDepth",
                                                    "stack"
                                                  |)
                                                |);
                                                Value.Tuple
                                                  [
                                                    M.borrow (|
                                                      Pointer.Kind.Ref,
                                                      M.deref (|
                                                        M.read (|
                                                          M.deref (| M.read (| inner_tok |) |)
                                                        |)
                                                      |)
                                                    |);
                                                    M.call_closure (|
                                                      Ty.path "usize",
                                                      BinOp.Wrap.add,
                                                      [
                                                        M.read (| depth |);
                                                        Value.Integer IntegerKind.Usize 1
                                                      ]
                                                    |)
                                                  ]
                                              ]
                                            |)
                                          |)))
                                      | _ => M.impossible "wrong number of arguments"
                                      end)
                                |)));
                            fun γ =>
                              ltac:(M.monadic
                                (let γ := M.read (| γ |) in
                                let γ1_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "move_binary_format::file_format::SignatureToken::StructInstantiation",
                                    0
                                  |) in
                                let struct_inst := M.alloc (| γ1_0 |) in
                                M.match_operator (|
                                  Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                  M.alloc (|
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (|
                                        M.read (| M.deref (| M.read (| struct_inst |) |) |)
                                      |)
                                    |)
                                  |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ := M.read (| γ |) in
                                        let γ1_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                        let γ1_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                        let inner_toks := M.alloc (| γ1_1 |) in
                                        M.alloc (|
                                          M.call_closure (|
                                            Ty.tuple [],
                                            M.get_trait_method (|
                                              "core::iter::traits::collect::Extend",
                                              Ty.apply
                                                (Ty.path "alloc::vec::Vec")
                                                []
                                                [
                                                  Ty.tuple
                                                    [
                                                      Ty.apply
                                                        (Ty.path "&")
                                                        []
                                                        [
                                                          Ty.path
                                                            "move_binary_format::file_format::SignatureToken"
                                                        ];
                                                      Ty.path "usize"
                                                    ];
                                                  Ty.path "alloc::alloc::Global"
                                                ],
                                              [],
                                              [
                                                Ty.tuple
                                                  [
                                                    Ty.apply
                                                      (Ty.path "&")
                                                      []
                                                      [
                                                        Ty.path
                                                          "move_binary_format::file_format::SignatureToken"
                                                      ];
                                                    Ty.path "usize"
                                                  ]
                                              ],
                                              "extend",
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::iter::adapters::rev::Rev")
                                                  []
                                                  [
                                                    Ty.apply
                                                      (Ty.path "core::iter::adapters::map::Map")
                                                      []
                                                      [
                                                        Ty.apply
                                                          (Ty.path "core::slice::iter::Iter")
                                                          []
                                                          [
                                                            Ty.path
                                                              "move_binary_format::file_format::SignatureToken"
                                                          ];
                                                        Ty.function
                                                          [
                                                            Ty.tuple
                                                              [
                                                                Ty.apply
                                                                  (Ty.path "&")
                                                                  []
                                                                  [
                                                                    Ty.path
                                                                      "move_binary_format::file_format::SignatureToken"
                                                                  ]
                                                              ]
                                                          ]
                                                          (Ty.tuple
                                                            [
                                                              Ty.apply
                                                                (Ty.path "&")
                                                                []
                                                                [
                                                                  Ty.path
                                                                    "move_binary_format::file_format::SignatureToken"
                                                                ];
                                                              Ty.path "usize"
                                                            ])
                                                      ]
                                                  ]
                                              ]
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.MutRef,
                                                M.SubPointer.get_struct_record_field (|
                                                  M.deref (| M.read (| self |) |),
                                                  "move_binary_format::file_format::SignatureTokenPreorderTraversalIterWithDepth",
                                                  "stack"
                                                |)
                                              |);
                                              M.call_closure (|
                                                Ty.apply
                                                  (Ty.path "core::iter::adapters::rev::Rev")
                                                  []
                                                  [
                                                    Ty.apply
                                                      (Ty.path "core::iter::adapters::map::Map")
                                                      []
                                                      [
                                                        Ty.apply
                                                          (Ty.path "core::slice::iter::Iter")
                                                          []
                                                          [
                                                            Ty.path
                                                              "move_binary_format::file_format::SignatureToken"
                                                          ];
                                                        Ty.function
                                                          [
                                                            Ty.tuple
                                                              [
                                                                Ty.apply
                                                                  (Ty.path "&")
                                                                  []
                                                                  [
                                                                    Ty.path
                                                                      "move_binary_format::file_format::SignatureToken"
                                                                  ]
                                                              ]
                                                          ]
                                                          (Ty.tuple
                                                            [
                                                              Ty.apply
                                                                (Ty.path "&")
                                                                []
                                                                [
                                                                  Ty.path
                                                                    "move_binary_format::file_format::SignatureToken"
                                                                ];
                                                              Ty.path "usize"
                                                            ])
                                                      ]
                                                  ],
                                                M.get_trait_method (|
                                                  "core::iter::traits::iterator::Iterator",
                                                  Ty.apply
                                                    (Ty.path "core::iter::adapters::map::Map")
                                                    []
                                                    [
                                                      Ty.apply
                                                        (Ty.path "core::slice::iter::Iter")
                                                        []
                                                        [
                                                          Ty.path
                                                            "move_binary_format::file_format::SignatureToken"
                                                        ];
                                                      Ty.function
                                                        [
                                                          Ty.tuple
                                                            [
                                                              Ty.apply
                                                                (Ty.path "&")
                                                                []
                                                                [
                                                                  Ty.path
                                                                    "move_binary_format::file_format::SignatureToken"
                                                                ]
                                                            ]
                                                        ]
                                                        (Ty.tuple
                                                          [
                                                            Ty.apply
                                                              (Ty.path "&")
                                                              []
                                                              [
                                                                Ty.path
                                                                  "move_binary_format::file_format::SignatureToken"
                                                              ];
                                                            Ty.path "usize"
                                                          ])
                                                    ],
                                                  [],
                                                  [],
                                                  "rev",
                                                  [],
                                                  []
                                                |),
                                                [
                                                  M.call_closure (|
                                                    Ty.apply
                                                      (Ty.path "core::iter::adapters::map::Map")
                                                      []
                                                      [
                                                        Ty.apply
                                                          (Ty.path "core::slice::iter::Iter")
                                                          []
                                                          [
                                                            Ty.path
                                                              "move_binary_format::file_format::SignatureToken"
                                                          ];
                                                        Ty.function
                                                          [
                                                            Ty.tuple
                                                              [
                                                                Ty.apply
                                                                  (Ty.path "&")
                                                                  []
                                                                  [
                                                                    Ty.path
                                                                      "move_binary_format::file_format::SignatureToken"
                                                                  ]
                                                              ]
                                                          ]
                                                          (Ty.tuple
                                                            [
                                                              Ty.apply
                                                                (Ty.path "&")
                                                                []
                                                                [
                                                                  Ty.path
                                                                    "move_binary_format::file_format::SignatureToken"
                                                                ];
                                                              Ty.path "usize"
                                                            ])
                                                      ],
                                                    M.get_trait_method (|
                                                      "core::iter::traits::iterator::Iterator",
                                                      Ty.apply
                                                        (Ty.path "core::slice::iter::Iter")
                                                        []
                                                        [
                                                          Ty.path
                                                            "move_binary_format::file_format::SignatureToken"
                                                        ],
                                                      [],
                                                      [],
                                                      "map",
                                                      [],
                                                      [
                                                        Ty.tuple
                                                          [
                                                            Ty.apply
                                                              (Ty.path "&")
                                                              []
                                                              [
                                                                Ty.path
                                                                  "move_binary_format::file_format::SignatureToken"
                                                              ];
                                                            Ty.path "usize"
                                                          ];
                                                        Ty.function
                                                          [
                                                            Ty.tuple
                                                              [
                                                                Ty.apply
                                                                  (Ty.path "&")
                                                                  []
                                                                  [
                                                                    Ty.path
                                                                      "move_binary_format::file_format::SignatureToken"
                                                                  ]
                                                              ]
                                                          ]
                                                          (Ty.tuple
                                                            [
                                                              Ty.apply
                                                                (Ty.path "&")
                                                                []
                                                                [
                                                                  Ty.path
                                                                    "move_binary_format::file_format::SignatureToken"
                                                                ];
                                                              Ty.path "usize"
                                                            ])
                                                      ]
                                                    |),
                                                    [
                                                      M.call_closure (|
                                                        Ty.apply
                                                          (Ty.path "core::slice::iter::Iter")
                                                          []
                                                          [
                                                            Ty.path
                                                              "move_binary_format::file_format::SignatureToken"
                                                          ],
                                                        M.get_associated_function (|
                                                          Ty.apply
                                                            (Ty.path "slice")
                                                            []
                                                            [
                                                              Ty.path
                                                                "move_binary_format::file_format::SignatureToken"
                                                            ],
                                                          "iter",
                                                          [],
                                                          []
                                                        |),
                                                        [
                                                          M.borrow (|
                                                            Pointer.Kind.Ref,
                                                            M.deref (|
                                                              M.call_closure (|
                                                                Ty.apply
                                                                  (Ty.path "&")
                                                                  []
                                                                  [
                                                                    Ty.apply
                                                                      (Ty.path "slice")
                                                                      []
                                                                      [
                                                                        Ty.path
                                                                          "move_binary_format::file_format::SignatureToken"
                                                                      ]
                                                                  ],
                                                                M.get_trait_method (|
                                                                  "core::ops::deref::Deref",
                                                                  Ty.apply
                                                                    (Ty.path "alloc::vec::Vec")
                                                                    []
                                                                    [
                                                                      Ty.path
                                                                        "move_binary_format::file_format::SignatureToken";
                                                                      Ty.path "alloc::alloc::Global"
                                                                    ],
                                                                  [],
                                                                  [],
                                                                  "deref",
                                                                  [],
                                                                  []
                                                                |),
                                                                [
                                                                  M.borrow (|
                                                                    Pointer.Kind.Ref,
                                                                    M.deref (|
                                                                      M.read (| inner_toks |)
                                                                    |)
                                                                  |)
                                                                ]
                                                              |)
                                                            |)
                                                          |)
                                                        ]
                                                      |);
                                                      M.closure
                                                        (fun γ =>
                                                          ltac:(M.monadic
                                                            match γ with
                                                            | [ α0 ] =>
                                                              ltac:(M.monadic
                                                                (M.match_operator (|
                                                                  Ty.apply
                                                                    (Ty.path "*")
                                                                    []
                                                                    [
                                                                      Ty.function
                                                                        [
                                                                          Ty.tuple
                                                                            [
                                                                              Ty.apply
                                                                                (Ty.path "&")
                                                                                []
                                                                                [
                                                                                  Ty.path
                                                                                    "move_binary_format::file_format::SignatureToken"
                                                                                ]
                                                                            ]
                                                                        ]
                                                                        (Ty.tuple
                                                                          [
                                                                            Ty.apply
                                                                              (Ty.path "&")
                                                                              []
                                                                              [
                                                                                Ty.path
                                                                                  "move_binary_format::file_format::SignatureToken"
                                                                              ];
                                                                            Ty.path "usize"
                                                                          ])
                                                                    ],
                                                                  M.alloc (| α0 |),
                                                                  [
                                                                    fun γ =>
                                                                      ltac:(M.monadic
                                                                        (let tok :=
                                                                          M.copy (| γ |) in
                                                                        Value.Tuple
                                                                          [
                                                                            M.read (| tok |);
                                                                            M.call_closure (|
                                                                              Ty.path "usize",
                                                                              BinOp.Wrap.add,
                                                                              [
                                                                                M.read (| depth |);
                                                                                Value.Integer
                                                                                  IntegerKind.Usize
                                                                                  1
                                                                              ]
                                                                            |)
                                                                          ]))
                                                                  ]
                                                                |)))
                                                            | _ =>
                                                              M.impossible
                                                                "wrong number of arguments"
                                                            end))
                                                    ]
                                                  |)
                                                ]
                                              |)
                                            ]
                                          |)
                                        |)))
                                  ]
                                |)));
                            fun γ =>
                              ltac:(M.monadic
                                (M.find_or_pattern (Ty.tuple []) (|
                                  γ,
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ := M.read (| γ |) in
                                        let _ :=
                                          M.is_struct_tuple (|
                                            γ,
                                            "move_binary_format::file_format::SignatureToken::Signer"
                                          |) in
                                        Value.Tuple []));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ := M.read (| γ |) in
                                        let _ :=
                                          M.is_struct_tuple (|
                                            γ,
                                            "move_binary_format::file_format::SignatureToken::Bool"
                                          |) in
                                        Value.Tuple []));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ := M.read (| γ |) in
                                        let _ :=
                                          M.is_struct_tuple (|
                                            γ,
                                            "move_binary_format::file_format::SignatureToken::Address"
                                          |) in
                                        Value.Tuple []));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ := M.read (| γ |) in
                                        let _ :=
                                          M.is_struct_tuple (|
                                            γ,
                                            "move_binary_format::file_format::SignatureToken::U8"
                                          |) in
                                        Value.Tuple []));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ := M.read (| γ |) in
                                        let _ :=
                                          M.is_struct_tuple (|
                                            γ,
                                            "move_binary_format::file_format::SignatureToken::U16"
                                          |) in
                                        Value.Tuple []));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ := M.read (| γ |) in
                                        let _ :=
                                          M.is_struct_tuple (|
                                            γ,
                                            "move_binary_format::file_format::SignatureToken::U32"
                                          |) in
                                        Value.Tuple []));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ := M.read (| γ |) in
                                        let _ :=
                                          M.is_struct_tuple (|
                                            γ,
                                            "move_binary_format::file_format::SignatureToken::U64"
                                          |) in
                                        Value.Tuple []));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ := M.read (| γ |) in
                                        let _ :=
                                          M.is_struct_tuple (|
                                            γ,
                                            "move_binary_format::file_format::SignatureToken::U128"
                                          |) in
                                        Value.Tuple []));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ := M.read (| γ |) in
                                        let _ :=
                                          M.is_struct_tuple (|
                                            γ,
                                            "move_binary_format::file_format::SignatureToken::U256"
                                          |) in
                                        Value.Tuple []));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ := M.read (| γ |) in
                                        let γ1_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "move_binary_format::file_format::SignatureToken::Struct",
                                            0
                                          |) in
                                        Value.Tuple []));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ := M.read (| γ |) in
                                        let γ1_0 :=
                                          M.SubPointer.get_struct_tuple_field (|
                                            γ,
                                            "move_binary_format::file_format::SignatureToken::TypeParameter",
                                            0
                                          |) in
                                        Value.Tuple []))
                                  ],
                                  fun γ =>
                                    ltac:(M.monadic
                                      match γ with
                                      | [] => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                      | _ => M.impossible "wrong number of arguments"
                                      end)
                                |)))
                          ]
                        |)
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::option::Option::Some"
                        []
                        [
                          Ty.tuple
                            [
                              Ty.apply
                                (Ty.path "&")
                                []
                                [ Ty.path "move_binary_format::file_format::SignatureToken" ];
                              Ty.path "usize"
                            ]
                        ]
                        [
                          Value.Tuple
                            [
                              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| tok |) |) |);
                              M.read (| depth |)
                            ]
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ := M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::option::Option::None"
                        []
                        [
                          Ty.tuple
                            [
                              Ty.apply
                                (Ty.path "&")
                                []
                                [ Ty.path "move_binary_format::file_format::SignatureToken" ];
                              Ty.path "usize"
                            ]
                        ]
                        []
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::iter::traits::iterator::Iterator"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("Item", InstanceField.Ty _Item); ("next", InstanceField.Method next) ].
  End Impl_core_iter_traits_iterator_Iterator_for_move_binary_format_file_format_SignatureTokenPreorderTraversalIterWithDepth.
  
  Module Impl_core_fmt_Debug_for_move_binary_format_file_format_SignatureToken.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::SignatureToken".
    
    (*
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match self {
                SignatureToken::Bool => write!(f, "Bool"),
                SignatureToken::U8 => write!(f, "U8"),
                SignatureToken::U16 => write!(f, "U16"),
                SignatureToken::U32 => write!(f, "U32"),
                SignatureToken::U64 => write!(f, "U64"),
                SignatureToken::U128 => write!(f, "U128"),
                SignatureToken::U256 => write!(f, "U256"),
                SignatureToken::Address => write!(f, "Address"),
                SignatureToken::Signer => write!(f, "Signer"),
                SignatureToken::Vector(boxed) => write!(f, "Vector({:?})", boxed),
                SignatureToken::Struct(idx) => write!(f, "Struct({:?})", idx),
                SignatureToken::StructInstantiation(struct_inst) => {
                    let (idx, types) = &**struct_inst;
                    write!(f, "StructInstantiation({:?}, {:?})", idx, types)
                }
                SignatureToken::Reference(boxed) => write!(f, "Reference({:?})", boxed),
                SignatureToken::MutableReference(boxed) => write!(f, "MutableReference({:?})", boxed),
                SignatureToken::TypeParameter(idx) => write!(f, "TypeParameter({:?})", idx),
            }
        }
    *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.read (|
            M.match_operator (|
              Ty.apply
                (Ty.path "*")
                []
                [
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [ Ty.tuple []; Ty.path "core::fmt::Error" ]
                ],
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "move_binary_format::file_format::SignatureToken::Bool"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [ Value.Integer IntegerKind.Usize 1 ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (| Value.Array [ mk_str (| "Bool" |) ] |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "move_binary_format::file_format::SignatureToken::U8"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [ Value.Integer IntegerKind.Usize 1 ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (| Value.Array [ mk_str (| "U8" |) ] |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "move_binary_format::file_format::SignatureToken::U16"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [ Value.Integer IntegerKind.Usize 1 ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (| Value.Array [ mk_str (| "U16" |) ] |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "move_binary_format::file_format::SignatureToken::U32"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [ Value.Integer IntegerKind.Usize 1 ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (| Value.Array [ mk_str (| "U32" |) ] |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "move_binary_format::file_format::SignatureToken::U64"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [ Value.Integer IntegerKind.Usize 1 ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (| Value.Array [ mk_str (| "U64" |) ] |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "move_binary_format::file_format::SignatureToken::U128"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [ Value.Integer IntegerKind.Usize 1 ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (| Value.Array [ mk_str (| "U128" |) ] |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "move_binary_format::file_format::SignatureToken::U256"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [ Value.Integer IntegerKind.Usize 1 ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (| Value.Array [ mk_str (| "U256" |) ] |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "move_binary_format::file_format::SignatureToken::Address"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [ Value.Integer IntegerKind.Usize 1 ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (| Value.Array [ mk_str (| "Address" |) ] |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "move_binary_format::file_format::SignatureToken::Signer"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [ Value.Integer IntegerKind.Usize 1 ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (| Value.Array [ mk_str (| "Signer" |) ] |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::SignatureToken::Vector",
                        0
                      |) in
                    let boxed := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_v1",
                              [ Value.Integer IntegerKind.Usize 2; Value.Integer IntegerKind.Usize 1
                              ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array [ mk_str (| "Vector(" |); mk_str (| ")" |) ]
                                    |)
                                  |)
                                |)
                              |);
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.call_closure (|
                                            Ty.path "core::fmt::rt::Argument",
                                            M.get_associated_function (|
                                              Ty.path "core::fmt::rt::Argument",
                                              "new_debug",
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "&")
                                                  []
                                                  [
                                                    Ty.apply
                                                      (Ty.path "alloc::boxed::Box")
                                                      []
                                                      [
                                                        Ty.path
                                                          "move_binary_format::file_format::SignatureToken";
                                                        Ty.path "alloc::alloc::Global"
                                                      ]
                                                  ]
                                              ]
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.borrow (| Pointer.Kind.Ref, boxed |) |)
                                              |)
                                            ]
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::SignatureToken::Struct",
                        0
                      |) in
                    let idx := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_v1",
                              [ Value.Integer IntegerKind.Usize 2; Value.Integer IntegerKind.Usize 1
                              ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array [ mk_str (| "Struct(" |); mk_str (| ")" |) ]
                                    |)
                                  |)
                                |)
                              |);
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.call_closure (|
                                            Ty.path "core::fmt::rt::Argument",
                                            M.get_associated_function (|
                                              Ty.path "core::fmt::rt::Argument",
                                              "new_debug",
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "&")
                                                  []
                                                  [
                                                    Ty.path
                                                      "move_binary_format::file_format::StructHandleIndex"
                                                  ]
                                              ]
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.borrow (| Pointer.Kind.Ref, idx |) |)
                                              |)
                                            ]
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::SignatureToken::StructInstantiation",
                        0
                      |) in
                    let struct_inst := M.alloc (| γ1_0 |) in
                    M.match_operator (|
                      Ty.apply
                        (Ty.path "*")
                        []
                        [
                          Ty.apply
                            (Ty.path "core::result::Result")
                            []
                            [ Ty.tuple []; Ty.path "core::fmt::Error" ]
                        ],
                      M.alloc (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (| M.read (| M.deref (| M.read (| struct_inst |) |) |) |)
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.read (| γ |) in
                            let γ1_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ1_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let idx := M.alloc (| γ1_0 |) in
                            let types := M.alloc (| γ1_1 |) in
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  []
                                  [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                                M.get_associated_function (|
                                  Ty.path "core::fmt::Formatter",
                                  "write_fmt",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                                  M.call_closure (|
                                    Ty.path "core::fmt::Arguments",
                                    M.get_associated_function (|
                                      Ty.path "core::fmt::Arguments",
                                      "new_v1",
                                      [
                                        Value.Integer IntegerKind.Usize 3;
                                        Value.Integer IntegerKind.Usize 2
                                      ],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (|
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.alloc (|
                                              Value.Array
                                                [
                                                  mk_str (| "StructInstantiation(" |);
                                                  mk_str (| ", " |);
                                                  mk_str (| ")" |)
                                                ]
                                            |)
                                          |)
                                        |)
                                      |);
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (|
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.alloc (|
                                              Value.Array
                                                [
                                                  M.call_closure (|
                                                    Ty.path "core::fmt::rt::Argument",
                                                    M.get_associated_function (|
                                                      Ty.path "core::fmt::rt::Argument",
                                                      "new_debug",
                                                      [],
                                                      [
                                                        Ty.apply
                                                          (Ty.path "&")
                                                          []
                                                          [
                                                            Ty.path
                                                              "move_binary_format::file_format::StructHandleIndex"
                                                          ]
                                                      ]
                                                    |),
                                                    [
                                                      M.borrow (|
                                                        Pointer.Kind.Ref,
                                                        M.deref (|
                                                          M.borrow (| Pointer.Kind.Ref, idx |)
                                                        |)
                                                      |)
                                                    ]
                                                  |);
                                                  M.call_closure (|
                                                    Ty.path "core::fmt::rt::Argument",
                                                    M.get_associated_function (|
                                                      Ty.path "core::fmt::rt::Argument",
                                                      "new_debug",
                                                      [],
                                                      [
                                                        Ty.apply
                                                          (Ty.path "&")
                                                          []
                                                          [
                                                            Ty.apply
                                                              (Ty.path "alloc::vec::Vec")
                                                              []
                                                              [
                                                                Ty.path
                                                                  "move_binary_format::file_format::SignatureToken";
                                                                Ty.path "alloc::alloc::Global"
                                                              ]
                                                          ]
                                                      ]
                                                    |),
                                                    [
                                                      M.borrow (|
                                                        Pointer.Kind.Ref,
                                                        M.deref (|
                                                          M.borrow (| Pointer.Kind.Ref, types |)
                                                        |)
                                                      |)
                                                    ]
                                                  |)
                                                ]
                                            |)
                                          |)
                                        |)
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |)))
                      ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::SignatureToken::Reference",
                        0
                      |) in
                    let boxed := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_v1",
                              [ Value.Integer IntegerKind.Usize 2; Value.Integer IntegerKind.Usize 1
                              ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array [ mk_str (| "Reference(" |); mk_str (| ")" |) ]
                                    |)
                                  |)
                                |)
                              |);
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.call_closure (|
                                            Ty.path "core::fmt::rt::Argument",
                                            M.get_associated_function (|
                                              Ty.path "core::fmt::rt::Argument",
                                              "new_debug",
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "&")
                                                  []
                                                  [
                                                    Ty.apply
                                                      (Ty.path "alloc::boxed::Box")
                                                      []
                                                      [
                                                        Ty.path
                                                          "move_binary_format::file_format::SignatureToken";
                                                        Ty.path "alloc::alloc::Global"
                                                      ]
                                                  ]
                                              ]
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.borrow (| Pointer.Kind.Ref, boxed |) |)
                                              |)
                                            ]
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::SignatureToken::MutableReference",
                        0
                      |) in
                    let boxed := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_v1",
                              [ Value.Integer IntegerKind.Usize 2; Value.Integer IntegerKind.Usize 1
                              ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [ mk_str (| "MutableReference(" |); mk_str (| ")" |) ]
                                    |)
                                  |)
                                |)
                              |);
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.call_closure (|
                                            Ty.path "core::fmt::rt::Argument",
                                            M.get_associated_function (|
                                              Ty.path "core::fmt::rt::Argument",
                                              "new_debug",
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "&")
                                                  []
                                                  [
                                                    Ty.apply
                                                      (Ty.path "alloc::boxed::Box")
                                                      []
                                                      [
                                                        Ty.path
                                                          "move_binary_format::file_format::SignatureToken";
                                                        Ty.path "alloc::alloc::Global"
                                                      ]
                                                  ]
                                              ]
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.borrow (| Pointer.Kind.Ref, boxed |) |)
                                              |)
                                            ]
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::SignatureToken::TypeParameter",
                        0
                      |) in
                    let idx := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_v1",
                              [ Value.Integer IntegerKind.Usize 2; Value.Integer IntegerKind.Usize 1
                              ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [ mk_str (| "TypeParameter(" |); mk_str (| ")" |) ]
                                    |)
                                  |)
                                |)
                              |);
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.call_closure (|
                                            Ty.path "core::fmt::rt::Argument",
                                            M.get_associated_function (|
                                              Ty.path "core::fmt::rt::Argument",
                                              "new_debug",
                                              [],
                                              [ Ty.apply (Ty.path "&") [] [ Ty.path "u16" ] ]
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.borrow (| Pointer.Kind.Ref, idx |) |)
                                              |)
                                            ]
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_move_binary_format_file_format_SignatureToken.
  
  Module Impl_move_binary_format_file_format_SignatureToken.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::SignatureToken".
    
    (*
        pub fn signature_token_kind(&self) -> SignatureTokenKind {
            // TODO: SignatureTokenKind is out-dated. fix/update/remove SignatureTokenKind and see if
            // this function needs to be cleaned up
            use SignatureToken::*;
    
            match self {
                Reference(_) => SignatureTokenKind::Reference,
                MutableReference(_) => SignatureTokenKind::MutableReference,
                Bool
                | U8
                | U16
                | U32
                | U64
                | U128
                | U256
                | Address
                | Signer
                | Struct(_)
                | StructInstantiation(_)
                | Vector(_) => SignatureTokenKind::Value,
                // TODO: This is a temporary hack to please the verifier. SignatureTokenKind will soon
                // be completely removed. `SignatureTokenView::kind()` should be used instead.
                TypeParameter(_) => SignatureTokenKind::Value,
            }
        }
    *)
    Definition signature_token_kind (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.path "move_binary_format::SignatureTokenKind" ],
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::SignatureToken::Reference",
                        0
                      |) in
                    M.alloc (|
                      Value.StructTuple "move_binary_format::SignatureTokenKind::Reference" [] [] []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::SignatureToken::MutableReference",
                        0
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_binary_format::SignatureTokenKind::MutableReference"
                        []
                        []
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.find_or_pattern (Ty.tuple []) (|
                      γ,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.read (| γ |) in
                            let _ :=
                              M.is_struct_tuple (|
                                γ,
                                "move_binary_format::file_format::SignatureToken::Bool"
                              |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.read (| γ |) in
                            let _ :=
                              M.is_struct_tuple (|
                                γ,
                                "move_binary_format::file_format::SignatureToken::U8"
                              |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.read (| γ |) in
                            let _ :=
                              M.is_struct_tuple (|
                                γ,
                                "move_binary_format::file_format::SignatureToken::U16"
                              |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.read (| γ |) in
                            let _ :=
                              M.is_struct_tuple (|
                                γ,
                                "move_binary_format::file_format::SignatureToken::U32"
                              |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.read (| γ |) in
                            let _ :=
                              M.is_struct_tuple (|
                                γ,
                                "move_binary_format::file_format::SignatureToken::U64"
                              |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.read (| γ |) in
                            let _ :=
                              M.is_struct_tuple (|
                                γ,
                                "move_binary_format::file_format::SignatureToken::U128"
                              |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.read (| γ |) in
                            let _ :=
                              M.is_struct_tuple (|
                                γ,
                                "move_binary_format::file_format::SignatureToken::U256"
                              |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.read (| γ |) in
                            let _ :=
                              M.is_struct_tuple (|
                                γ,
                                "move_binary_format::file_format::SignatureToken::Address"
                              |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.read (| γ |) in
                            let _ :=
                              M.is_struct_tuple (|
                                γ,
                                "move_binary_format::file_format::SignatureToken::Signer"
                              |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.read (| γ |) in
                            let γ1_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "move_binary_format::file_format::SignatureToken::Struct",
                                0
                              |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.read (| γ |) in
                            let γ1_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "move_binary_format::file_format::SignatureToken::StructInstantiation",
                                0
                              |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.read (| γ |) in
                            let γ1_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "move_binary_format::file_format::SignatureToken::Vector",
                                0
                              |) in
                            Value.Tuple []))
                      ],
                      fun γ =>
                        ltac:(M.monadic
                          match γ with
                          | [] =>
                            ltac:(M.monadic
                              (M.alloc (|
                                Value.StructTuple
                                  "move_binary_format::SignatureTokenKind::Value"
                                  []
                                  []
                                  []
                              |)))
                          | _ => M.impossible "wrong number of arguments"
                          end)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::SignatureToken::TypeParameter",
                        0
                      |) in
                    M.alloc (|
                      Value.StructTuple "move_binary_format::SignatureTokenKind::Value" [] [] []
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_signature_token_kind :
      M.IsAssociatedFunction.C Self "signature_token_kind" signature_token_kind.
    Admitted.
    Global Typeclasses Opaque signature_token_kind.
    
    (*
        pub fn is_integer(&self) -> bool {
            use SignatureToken::*;
            match self {
                U8 | U16 | U32 | U64 | U128 | U256 => true,
                Bool
                | Address
                | Signer
                | Vector(_)
                | Struct(_)
                | StructInstantiation(_)
                | Reference(_)
                | MutableReference(_)
                | TypeParameter(_) => false,
            }
        }
    *)
    Definition is_integer (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.path "bool" ],
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.find_or_pattern (Ty.tuple []) (|
                      γ,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.read (| γ |) in
                            let _ :=
                              M.is_struct_tuple (|
                                γ,
                                "move_binary_format::file_format::SignatureToken::U8"
                              |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.read (| γ |) in
                            let _ :=
                              M.is_struct_tuple (|
                                γ,
                                "move_binary_format::file_format::SignatureToken::U16"
                              |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.read (| γ |) in
                            let _ :=
                              M.is_struct_tuple (|
                                γ,
                                "move_binary_format::file_format::SignatureToken::U32"
                              |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.read (| γ |) in
                            let _ :=
                              M.is_struct_tuple (|
                                γ,
                                "move_binary_format::file_format::SignatureToken::U64"
                              |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.read (| γ |) in
                            let _ :=
                              M.is_struct_tuple (|
                                γ,
                                "move_binary_format::file_format::SignatureToken::U128"
                              |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.read (| γ |) in
                            let _ :=
                              M.is_struct_tuple (|
                                γ,
                                "move_binary_format::file_format::SignatureToken::U256"
                              |) in
                            Value.Tuple []))
                      ],
                      fun γ =>
                        ltac:(M.monadic
                          match γ with
                          | [] => ltac:(M.monadic (M.alloc (| Value.Bool true |)))
                          | _ => M.impossible "wrong number of arguments"
                          end)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.find_or_pattern (Ty.tuple []) (|
                      γ,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.read (| γ |) in
                            let _ :=
                              M.is_struct_tuple (|
                                γ,
                                "move_binary_format::file_format::SignatureToken::Bool"
                              |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.read (| γ |) in
                            let _ :=
                              M.is_struct_tuple (|
                                γ,
                                "move_binary_format::file_format::SignatureToken::Address"
                              |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.read (| γ |) in
                            let _ :=
                              M.is_struct_tuple (|
                                γ,
                                "move_binary_format::file_format::SignatureToken::Signer"
                              |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.read (| γ |) in
                            let γ1_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "move_binary_format::file_format::SignatureToken::Vector",
                                0
                              |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.read (| γ |) in
                            let γ1_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "move_binary_format::file_format::SignatureToken::Struct",
                                0
                              |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.read (| γ |) in
                            let γ1_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "move_binary_format::file_format::SignatureToken::StructInstantiation",
                                0
                              |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.read (| γ |) in
                            let γ1_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "move_binary_format::file_format::SignatureToken::Reference",
                                0
                              |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.read (| γ |) in
                            let γ1_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "move_binary_format::file_format::SignatureToken::MutableReference",
                                0
                              |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.read (| γ |) in
                            let γ1_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "move_binary_format::file_format::SignatureToken::TypeParameter",
                                0
                              |) in
                            Value.Tuple []))
                      ],
                      fun γ =>
                        ltac:(M.monadic
                          match γ with
                          | [] => ltac:(M.monadic (M.alloc (| Value.Bool false |)))
                          | _ => M.impossible "wrong number of arguments"
                          end)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_is_integer :
      M.IsAssociatedFunction.C Self "is_integer" is_integer.
    Admitted.
    Global Typeclasses Opaque is_integer.
    
    (*
        pub fn is_reference(&self) -> bool {
            use SignatureToken::*;
    
            matches!(self, Reference(_) | MutableReference(_))
        }
    *)
    Definition is_reference (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.path "bool" ],
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.find_or_pattern (Ty.tuple []) (|
                      γ,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.read (| γ |) in
                            let γ1_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "move_binary_format::file_format::SignatureToken::Reference",
                                0
                              |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.read (| γ |) in
                            let γ1_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "move_binary_format::file_format::SignatureToken::MutableReference",
                                0
                              |) in
                            Value.Tuple []))
                      ],
                      fun γ =>
                        ltac:(M.monadic
                          match γ with
                          | [] => ltac:(M.monadic (M.alloc (| Value.Bool true |)))
                          | _ => M.impossible "wrong number of arguments"
                          end)
                    |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Bool false |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_is_reference :
      M.IsAssociatedFunction.C Self "is_reference" is_reference.
    Admitted.
    Global Typeclasses Opaque is_reference.
    
    (*
        pub fn is_mutable_reference(&self) -> bool {
            use SignatureToken::*;
    
            matches!(self, MutableReference(_))
        }
    *)
    Definition is_mutable_reference (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.path "bool" ],
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::SignatureToken::MutableReference",
                        0
                      |) in
                    M.alloc (| Value.Bool true |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Bool false |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_is_mutable_reference :
      M.IsAssociatedFunction.C Self "is_mutable_reference" is_mutable_reference.
    Admitted.
    Global Typeclasses Opaque is_mutable_reference.
    
    (*
        pub fn is_signer(&self) -> bool {
            use SignatureToken::*;
    
            matches!(self, Signer)
        }
    *)
    Definition is_signer (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.path "bool" ],
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "move_binary_format::file_format::SignatureToken::Signer"
                      |) in
                    M.alloc (| Value.Bool true |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Bool false |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_is_signer :
      M.IsAssociatedFunction.C Self "is_signer" is_signer.
    Admitted.
    Global Typeclasses Opaque is_signer.
    
    (*
        pub fn is_valid_for_constant(&self) -> bool {
            use SignatureToken::*;
    
            match self {
                Bool | U8 | U16 | U32 | U64 | U128 | U256 | Address => true,
                Vector(inner) => inner.is_valid_for_constant(),
                Signer
                | Struct(_)
                | StructInstantiation(_)
                | Reference(_)
                | MutableReference(_)
                | TypeParameter(_) => false,
            }
        }
    *)
    Definition is_valid_for_constant (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.path "bool" ],
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.find_or_pattern (Ty.tuple []) (|
                      γ,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.read (| γ |) in
                            let _ :=
                              M.is_struct_tuple (|
                                γ,
                                "move_binary_format::file_format::SignatureToken::Bool"
                              |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.read (| γ |) in
                            let _ :=
                              M.is_struct_tuple (|
                                γ,
                                "move_binary_format::file_format::SignatureToken::U8"
                              |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.read (| γ |) in
                            let _ :=
                              M.is_struct_tuple (|
                                γ,
                                "move_binary_format::file_format::SignatureToken::U16"
                              |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.read (| γ |) in
                            let _ :=
                              M.is_struct_tuple (|
                                γ,
                                "move_binary_format::file_format::SignatureToken::U32"
                              |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.read (| γ |) in
                            let _ :=
                              M.is_struct_tuple (|
                                γ,
                                "move_binary_format::file_format::SignatureToken::U64"
                              |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.read (| γ |) in
                            let _ :=
                              M.is_struct_tuple (|
                                γ,
                                "move_binary_format::file_format::SignatureToken::U128"
                              |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.read (| γ |) in
                            let _ :=
                              M.is_struct_tuple (|
                                γ,
                                "move_binary_format::file_format::SignatureToken::U256"
                              |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.read (| γ |) in
                            let _ :=
                              M.is_struct_tuple (|
                                γ,
                                "move_binary_format::file_format::SignatureToken::Address"
                              |) in
                            Value.Tuple []))
                      ],
                      fun γ =>
                        ltac:(M.monadic
                          match γ with
                          | [] => ltac:(M.monadic (M.alloc (| Value.Bool true |)))
                          | _ => M.impossible "wrong number of arguments"
                          end)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::SignatureToken::Vector",
                        0
                      |) in
                    let inner := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.path "bool",
                        M.get_associated_function (|
                          Ty.path "move_binary_format::file_format::SignatureToken",
                          "is_valid_for_constant",
                          [],
                          []
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| M.read (| M.deref (| M.read (| inner |) |) |) |)
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.find_or_pattern (Ty.tuple []) (|
                      γ,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.read (| γ |) in
                            let _ :=
                              M.is_struct_tuple (|
                                γ,
                                "move_binary_format::file_format::SignatureToken::Signer"
                              |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.read (| γ |) in
                            let γ1_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "move_binary_format::file_format::SignatureToken::Struct",
                                0
                              |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.read (| γ |) in
                            let γ1_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "move_binary_format::file_format::SignatureToken::StructInstantiation",
                                0
                              |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.read (| γ |) in
                            let γ1_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "move_binary_format::file_format::SignatureToken::Reference",
                                0
                              |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.read (| γ |) in
                            let γ1_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "move_binary_format::file_format::SignatureToken::MutableReference",
                                0
                              |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.read (| γ |) in
                            let γ1_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "move_binary_format::file_format::SignatureToken::TypeParameter",
                                0
                              |) in
                            Value.Tuple []))
                      ],
                      fun γ =>
                        ltac:(M.monadic
                          match γ with
                          | [] => ltac:(M.monadic (M.alloc (| Value.Bool false |)))
                          | _ => M.impossible "wrong number of arguments"
                          end)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_is_valid_for_constant :
      M.IsAssociatedFunction.C Self "is_valid_for_constant" is_valid_for_constant.
    Admitted.
    Global Typeclasses Opaque is_valid_for_constant.
    
    (*
        pub fn debug_set_sh_idx(&mut self, sh_idx: StructHandleIndex) {
            match self {
                SignatureToken::Struct(ref mut wrapped) => *wrapped = sh_idx,
                SignatureToken::StructInstantiation(ref mut struct_inst) => {
                    Box::as_mut(struct_inst).0 = sh_idx
                }
                SignatureToken::Reference(ref mut token)
                | SignatureToken::MutableReference(ref mut token) => token.debug_set_sh_idx(sh_idx),
                other => panic!(
                    "debug_set_sh_idx (to {}) called for non-struct token {:?}",
                    sh_idx, other
                ),
            }
        }
    *)
    Definition debug_set_sh_idx (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; sh_idx ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let sh_idx := M.alloc (| sh_idx |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::SignatureToken::Struct",
                        0
                      |) in
                    let wrapped := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.write (| M.deref (| M.read (| wrapped |) |), M.read (| sh_idx |) |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::SignatureToken::StructInstantiation",
                        0
                      |) in
                    let struct_inst := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.write (|
                        M.SubPointer.get_tuple_field (|
                          M.deref (|
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "&mut")
                                []
                                [
                                  Ty.tuple
                                    [
                                      Ty.path "move_binary_format::file_format::StructHandleIndex";
                                      Ty.apply
                                        (Ty.path "alloc::vec::Vec")
                                        []
                                        [
                                          Ty.path "move_binary_format::file_format::SignatureToken";
                                          Ty.path "alloc::alloc::Global"
                                        ]
                                    ]
                                ],
                              M.get_trait_method (|
                                "core::convert::AsMut",
                                Ty.apply
                                  (Ty.path "alloc::boxed::Box")
                                  []
                                  [
                                    Ty.tuple
                                      [
                                        Ty.path
                                          "move_binary_format::file_format::StructHandleIndex";
                                        Ty.apply
                                          (Ty.path "alloc::vec::Vec")
                                          []
                                          [
                                            Ty.path
                                              "move_binary_format::file_format::SignatureToken";
                                            Ty.path "alloc::alloc::Global"
                                          ]
                                      ];
                                    Ty.path "alloc::alloc::Global"
                                  ],
                                [],
                                [
                                  Ty.tuple
                                    [
                                      Ty.path "move_binary_format::file_format::StructHandleIndex";
                                      Ty.apply
                                        (Ty.path "alloc::vec::Vec")
                                        []
                                        [
                                          Ty.path "move_binary_format::file_format::SignatureToken";
                                          Ty.path "alloc::alloc::Global"
                                        ]
                                    ]
                                ],
                                "as_mut",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.MutRef,
                                  M.deref (| M.read (| struct_inst |) |)
                                |)
                              ]
                            |)
                          |),
                          0
                        |),
                        M.read (| sh_idx |)
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.find_or_pattern
                      (Ty.tuple
                        [
                          Ty.apply
                            (Ty.path "&mut")
                            []
                            [
                              Ty.apply
                                (Ty.path "alloc::boxed::Box")
                                []
                                [
                                  Ty.path "move_binary_format::file_format::SignatureToken";
                                  Ty.path "alloc::alloc::Global"
                                ]
                            ]
                        ]) (|
                      γ,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.read (| γ |) in
                            let γ1_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "move_binary_format::file_format::SignatureToken::Reference",
                                0
                              |) in
                            let token := M.alloc (| γ1_0 |) in
                            Value.Tuple [ token ]));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.read (| γ |) in
                            let γ1_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "move_binary_format::file_format::SignatureToken::MutableReference",
                                0
                              |) in
                            let token := M.alloc (| γ1_0 |) in
                            Value.Tuple [ token ]))
                      ],
                      fun γ =>
                        ltac:(M.monadic
                          match γ with
                          | [ token ] =>
                            ltac:(M.monadic
                              (M.alloc (|
                                M.call_closure (|
                                  Ty.tuple [],
                                  M.get_associated_function (|
                                    Ty.path "move_binary_format::file_format::SignatureToken",
                                    "debug_set_sh_idx",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.MutRef,
                                      M.deref (| M.read (| M.deref (| M.read (| token |) |) |) |)
                                    |);
                                    M.read (| sh_idx |)
                                  ]
                                |)
                              |)))
                          | _ => M.impossible "wrong number of arguments"
                          end)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let other := M.copy (| γ |) in
                    M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          Ty.path "never",
                          M.get_function (| "core::panicking::panic_fmt", [], [] |),
                          [
                            M.call_closure (|
                              Ty.path "core::fmt::Arguments",
                              M.get_associated_function (|
                                Ty.path "core::fmt::Arguments",
                                "new_v1",
                                [
                                  Value.Integer IntegerKind.Usize 2;
                                  Value.Integer IntegerKind.Usize 2
                                ],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.alloc (|
                                        Value.Array
                                          [
                                            mk_str (| "debug_set_sh_idx (to " |);
                                            mk_str (| ") called for non-struct token " |)
                                          ]
                                      |)
                                    |)
                                  |)
                                |);
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.alloc (|
                                        Value.Array
                                          [
                                            M.call_closure (|
                                              Ty.path "core::fmt::rt::Argument",
                                              M.get_associated_function (|
                                                Ty.path "core::fmt::rt::Argument",
                                                "new_display",
                                                [],
                                                [
                                                  Ty.path
                                                    "move_binary_format::file_format::StructHandleIndex"
                                                ]
                                              |),
                                              [
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (|
                                                    M.borrow (| Pointer.Kind.Ref, sh_idx |)
                                                  |)
                                                |)
                                              ]
                                            |);
                                            M.call_closure (|
                                              Ty.path "core::fmt::rt::Argument",
                                              M.get_associated_function (|
                                                Ty.path "core::fmt::rt::Argument",
                                                "new_debug",
                                                [],
                                                [
                                                  Ty.apply
                                                    (Ty.path "&mut")
                                                    []
                                                    [
                                                      Ty.path
                                                        "move_binary_format::file_format::SignatureToken"
                                                    ]
                                                ]
                                              |),
                                              [
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (|
                                                    M.borrow (| Pointer.Kind.Ref, other |)
                                                  |)
                                                |)
                                              ]
                                            |)
                                          ]
                                      |)
                                    |)
                                  |)
                                |)
                              ]
                            |)
                          ]
                        |)
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_debug_set_sh_idx :
      M.IsAssociatedFunction.C Self "debug_set_sh_idx" debug_set_sh_idx.
    Admitted.
    Global Typeclasses Opaque debug_set_sh_idx.
    
    (*
        pub fn preorder_traversal(&self) -> SignatureTokenPreorderTraversalIter<'_> {
            SignatureTokenPreorderTraversalIter { stack: vec![self] }
        }
    *)
    Definition preorder_traversal (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.StructRecord
            "move_binary_format::file_format::SignatureTokenPreorderTraversalIter"
            []
            []
            [
              ("stack",
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [
                      Ty.apply
                        (Ty.path "&")
                        []
                        [ Ty.path "move_binary_format::file_format::SignatureToken" ];
                      Ty.path "alloc::alloc::Global"
                    ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "slice")
                      []
                      [
                        Ty.apply
                          (Ty.path "&")
                          []
                          [ Ty.path "move_binary_format::file_format::SignatureToken" ]
                      ],
                    "into_vec",
                    [],
                    [ Ty.path "alloc::alloc::Global" ]
                  |),
                  [
                    (* Unsize *)
                    M.pointer_coercion
                      (M.read (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "alloc::boxed::Box")
                            []
                            [
                              Ty.apply
                                (Ty.path "array")
                                [ Value.Integer IntegerKind.Usize 1 ]
                                [
                                  Ty.apply
                                    (Ty.path "&")
                                    []
                                    [ Ty.path "move_binary_format::file_format::SignatureToken" ]
                                ];
                              Ty.path "alloc::alloc::Global"
                            ],
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloc::boxed::Box")
                              []
                              [
                                Ty.apply
                                  (Ty.path "array")
                                  [ Value.Integer IntegerKind.Usize 1 ]
                                  [
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [ Ty.path "move_binary_format::file_format::SignatureToken" ]
                                  ];
                                Ty.path "alloc::alloc::Global"
                              ],
                            "new",
                            [],
                            []
                          |),
                          [
                            M.alloc (|
                              Value.Array
                                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                            |)
                          ]
                        |)
                      |))
                  ]
                |))
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_preorder_traversal :
      M.IsAssociatedFunction.C Self "preorder_traversal" preorder_traversal.
    Admitted.
    Global Typeclasses Opaque preorder_traversal.
    
    (*
        pub fn preorder_traversal_with_depth(
            &self,
        ) -> SignatureTokenPreorderTraversalIterWithDepth<'_> {
            SignatureTokenPreorderTraversalIterWithDepth {
                stack: vec![(self, 1)],
            }
        }
    *)
    Definition preorder_traversal_with_depth
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.StructRecord
            "move_binary_format::file_format::SignatureTokenPreorderTraversalIterWithDepth"
            []
            []
            [
              ("stack",
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [
                      Ty.tuple
                        [
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.path "move_binary_format::file_format::SignatureToken" ];
                          Ty.path "usize"
                        ];
                      Ty.path "alloc::alloc::Global"
                    ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "slice")
                      []
                      [
                        Ty.tuple
                          [
                            Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.path "move_binary_format::file_format::SignatureToken" ];
                            Ty.path "usize"
                          ]
                      ],
                    "into_vec",
                    [],
                    [ Ty.path "alloc::alloc::Global" ]
                  |),
                  [
                    (* Unsize *)
                    M.pointer_coercion
                      (M.read (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "alloc::boxed::Box")
                            []
                            [
                              Ty.apply
                                (Ty.path "array")
                                [ Value.Integer IntegerKind.Usize 1 ]
                                [
                                  Ty.tuple
                                    [
                                      Ty.apply
                                        (Ty.path "&")
                                        []
                                        [ Ty.path "move_binary_format::file_format::SignatureToken"
                                        ];
                                      Ty.path "usize"
                                    ]
                                ];
                              Ty.path "alloc::alloc::Global"
                            ],
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloc::boxed::Box")
                              []
                              [
                                Ty.apply
                                  (Ty.path "array")
                                  [ Value.Integer IntegerKind.Usize 1 ]
                                  [
                                    Ty.tuple
                                      [
                                        Ty.apply
                                          (Ty.path "&")
                                          []
                                          [
                                            Ty.path
                                              "move_binary_format::file_format::SignatureToken"
                                          ];
                                        Ty.path "usize"
                                      ]
                                  ];
                                Ty.path "alloc::alloc::Global"
                              ],
                            "new",
                            [],
                            []
                          |),
                          [
                            M.alloc (|
                              Value.Array
                                [
                                  Value.Tuple
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (| M.read (| self |) |)
                                      |);
                                      Value.Integer IntegerKind.Usize 1
                                    ]
                                ]
                            |)
                          ]
                        |)
                      |))
                  ]
                |))
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_preorder_traversal_with_depth :
      M.IsAssociatedFunction.C Self "preorder_traversal_with_depth" preorder_traversal_with_depth.
    Admitted.
    Global Typeclasses Opaque preorder_traversal_with_depth.
  End Impl_move_binary_format_file_format_SignatureToken.
  
  (* StructRecord
    {
      name := "Constant";
      const_params := [];
      ty_params := [];
      fields :=
        [
          ("type_", Ty.path "move_binary_format::file_format::SignatureToken");
          ("data",
            Ty.apply
              (Ty.path "alloc::vec::Vec")
              []
              [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ])
        ];
    } *)
  
  Module Impl_core_clone_Clone_for_move_binary_format_file_format_Constant.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::Constant".
    
    (* Clone *)
    Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.StructRecord
            "move_binary_format::file_format::Constant"
            []
            []
            [
              ("type_",
                M.call_closure (|
                  Ty.path "move_binary_format::file_format::SignatureToken",
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.path "move_binary_format::file_format::SignatureToken",
                    [],
                    [],
                    "clone",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "move_binary_format::file_format::Constant",
                            "type_"
                          |)
                        |)
                      |)
                    |)
                  ]
                |));
              ("data",
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      []
                      [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                    [],
                    [],
                    "clone",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "move_binary_format::file_format::Constant",
                            "data"
                          |)
                        |)
                      |)
                    |)
                  ]
                |))
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_move_binary_format_file_format_Constant.
  
  Module Impl_core_fmt_Debug_for_move_binary_format_file_format_Constant.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::Constant".
    
    (* Debug *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_associated_function (|
              Ty.path "core::fmt::Formatter",
              "debug_struct_field2_finish",
              [],
              []
            |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "Constant" |) |) |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "type_" |) |) |);
              (* Unsize *)
              M.pointer_coercion
                (M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "move_binary_format::file_format::Constant",
                        "type_"
                      |)
                    |)
                  |)
                |));
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "data" |) |) |);
              (* Unsize *)
              M.pointer_coercion
                (M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.alloc (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "move_binary_format::file_format::Constant",
                            "data"
                          |)
                        |)
                      |)
                    |)
                  |)
                |))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_move_binary_format_file_format_Constant.
  
  Module Impl_core_cmp_Eq_for_move_binary_format_file_format_Constant.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::Constant".
    
    (* Eq *)
    Definition assert_receiver_is_total_eq
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              Value.DeclaredButUndefined,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                      Value.DeclaredButUndefined,
                      [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_move_binary_format_file_format_Constant.
  
  Module Impl_core_marker_StructuralPartialEq_for_move_binary_format_file_format_Constant.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::Constant".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_move_binary_format_file_format_Constant.
  
  Module Impl_core_cmp_PartialEq_move_binary_format_file_format_Constant_for_move_binary_format_file_format_Constant.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::Constant".
    
    (* PartialEq *)
    Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          LogicalOp.and (|
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (|
                "core::cmp::PartialEq",
                Ty.path "move_binary_format::file_format::SignatureToken",
                [],
                [ Ty.path "move_binary_format::file_format::SignatureToken" ],
                "eq",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "move_binary_format::file_format::Constant",
                    "type_"
                  |)
                |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| other |) |),
                    "move_binary_format::file_format::Constant",
                    "type_"
                  |)
                |)
              ]
            |),
            ltac:(M.monadic
              (M.call_closure (|
                Ty.path "bool",
                M.get_trait_method (|
                  "core::cmp::PartialEq",
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                  [],
                  [
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      []
                      [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                  ],
                  "eq",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "move_binary_format::file_format::Constant",
                      "data"
                    |)
                  |);
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| other |) |),
                      "move_binary_format::file_format::Constant",
                      "data"
                    |)
                  |)
                ]
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "move_binary_format::file_format::Constant" ]
        Self
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_move_binary_format_file_format_Constant_for_move_binary_format_file_format_Constant.
  
  Module Impl_core_hash_Hash_for_move_binary_format_file_format_Constant.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::Constant".
    
    (* Hash *)
    Definition hash (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ __H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let state := M.alloc (| state |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.call_closure (|
                Ty.tuple [],
                M.get_trait_method (|
                  "core::hash::Hash",
                  Ty.path "move_binary_format::file_format::SignatureToken",
                  [],
                  [],
                  "hash",
                  [],
                  [ __H ]
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "move_binary_format::file_format::Constant",
                          "type_"
                        |)
                      |)
                    |)
                  |);
                  M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                ]
              |) in
            M.alloc (|
              M.call_closure (|
                Ty.tuple [],
                M.get_trait_method (|
                  "core::hash::Hash",
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                  [],
                  [],
                  "hash",
                  [],
                  [ __H ]
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "move_binary_format::file_format::Constant",
                          "data"
                        |)
                      |)
                    |)
                  |);
                  M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::hash::Hash"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("hash", InstanceField.Method hash) ].
  End Impl_core_hash_Hash_for_move_binary_format_file_format_Constant.
  
  (* StructRecord
    {
      name := "CodeUnit";
      const_params := [];
      ty_params := [];
      fields :=
        [
          ("locals", Ty.path "move_binary_format::file_format::SignatureIndex");
          ("code",
            Ty.apply
              (Ty.path "alloc::vec::Vec")
              []
              [ Ty.path "move_binary_format::file_format::Bytecode"; Ty.path "alloc::alloc::Global"
              ])
        ];
    } *)
  
  Module Impl_core_clone_Clone_for_move_binary_format_file_format_CodeUnit.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::CodeUnit".
    
    (* Clone *)
    Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.StructRecord
            "move_binary_format::file_format::CodeUnit"
            []
            []
            [
              ("locals",
                M.call_closure (|
                  Ty.path "move_binary_format::file_format::SignatureIndex",
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.path "move_binary_format::file_format::SignatureIndex",
                    [],
                    [],
                    "clone",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "move_binary_format::file_format::CodeUnit",
                            "locals"
                          |)
                        |)
                      |)
                    |)
                  ]
                |));
              ("code",
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [
                      Ty.path "move_binary_format::file_format::Bytecode";
                      Ty.path "alloc::alloc::Global"
                    ],
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      []
                      [
                        Ty.path "move_binary_format::file_format::Bytecode";
                        Ty.path "alloc::alloc::Global"
                      ],
                    [],
                    [],
                    "clone",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "move_binary_format::file_format::CodeUnit",
                            "code"
                          |)
                        |)
                      |)
                    |)
                  ]
                |))
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_move_binary_format_file_format_CodeUnit.
  
  Module Impl_core_fmt_Debug_for_move_binary_format_file_format_CodeUnit.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::CodeUnit".
    
    (* Debug *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_associated_function (|
              Ty.path "core::fmt::Formatter",
              "debug_struct_field2_finish",
              [],
              []
            |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "CodeUnit" |) |) |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "locals" |) |) |);
              (* Unsize *)
              M.pointer_coercion
                (M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "move_binary_format::file_format::CodeUnit",
                        "locals"
                      |)
                    |)
                  |)
                |));
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "code" |) |) |);
              (* Unsize *)
              M.pointer_coercion
                (M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.alloc (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "move_binary_format::file_format::CodeUnit",
                            "code"
                          |)
                        |)
                      |)
                    |)
                  |)
                |))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_move_binary_format_file_format_CodeUnit.
  
  Module Impl_core_default_Default_for_move_binary_format_file_format_CodeUnit.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::CodeUnit".
    
    (* Default *)
    Definition default (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [] =>
        ltac:(M.monadic
          (Value.StructRecord
            "move_binary_format::file_format::CodeUnit"
            []
            []
            [
              ("locals",
                M.call_closure (|
                  Ty.path "move_binary_format::file_format::SignatureIndex",
                  M.get_trait_method (|
                    "core::default::Default",
                    Ty.path "move_binary_format::file_format::SignatureIndex",
                    [],
                    [],
                    "default",
                    [],
                    []
                  |),
                  []
                |));
              ("code",
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [
                      Ty.path "move_binary_format::file_format::Bytecode";
                      Ty.path "alloc::alloc::Global"
                    ],
                  M.get_trait_method (|
                    "core::default::Default",
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      []
                      [
                        Ty.path "move_binary_format::file_format::Bytecode";
                        Ty.path "alloc::alloc::Global"
                      ],
                    [],
                    [],
                    "default",
                    [],
                    []
                  |),
                  []
                |))
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::default::Default"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("default", InstanceField.Method default) ].
  End Impl_core_default_Default_for_move_binary_format_file_format_CodeUnit.
  
  Module Impl_core_cmp_Eq_for_move_binary_format_file_format_CodeUnit.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::CodeUnit".
    
    (* Eq *)
    Definition assert_receiver_is_total_eq
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              Value.DeclaredButUndefined,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                      Value.DeclaredButUndefined,
                      [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_move_binary_format_file_format_CodeUnit.
  
  Module Impl_core_marker_StructuralPartialEq_for_move_binary_format_file_format_CodeUnit.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::CodeUnit".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_move_binary_format_file_format_CodeUnit.
  
  Module Impl_core_cmp_PartialEq_move_binary_format_file_format_CodeUnit_for_move_binary_format_file_format_CodeUnit.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::CodeUnit".
    
    (* PartialEq *)
    Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          LogicalOp.and (|
            M.call_closure (|
              Ty.path "bool",
              M.get_trait_method (|
                "core::cmp::PartialEq",
                Ty.path "move_binary_format::file_format::SignatureIndex",
                [],
                [ Ty.path "move_binary_format::file_format::SignatureIndex" ],
                "eq",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "move_binary_format::file_format::CodeUnit",
                    "locals"
                  |)
                |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| other |) |),
                    "move_binary_format::file_format::CodeUnit",
                    "locals"
                  |)
                |)
              ]
            |),
            ltac:(M.monadic
              (M.call_closure (|
                Ty.path "bool",
                M.get_trait_method (|
                  "core::cmp::PartialEq",
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [
                      Ty.path "move_binary_format::file_format::Bytecode";
                      Ty.path "alloc::alloc::Global"
                    ],
                  [],
                  [
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      []
                      [
                        Ty.path "move_binary_format::file_format::Bytecode";
                        Ty.path "alloc::alloc::Global"
                      ]
                  ],
                  "eq",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "move_binary_format::file_format::CodeUnit",
                      "code"
                    |)
                  |);
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| other |) |),
                      "move_binary_format::file_format::CodeUnit",
                      "code"
                    |)
                  |)
                ]
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "move_binary_format::file_format::CodeUnit" ]
        Self
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_move_binary_format_file_format_CodeUnit_for_move_binary_format_file_format_CodeUnit.
  
  (*
  Enum Bytecode
  {
    const_params := [];
    ty_params := [];
    variants :=
      [
        {
          name := "Pop";
          item := StructTuple [];
        };
        {
          name := "Ret";
          item := StructTuple [];
        };
        {
          name := "BrTrue";
          item := StructTuple [ Ty.path "u16" ];
        };
        {
          name := "BrFalse";
          item := StructTuple [ Ty.path "u16" ];
        };
        {
          name := "Branch";
          item := StructTuple [ Ty.path "u16" ];
        };
        {
          name := "LdU8";
          item := StructTuple [ Ty.path "u8" ];
        };
        {
          name := "LdU64";
          item := StructTuple [ Ty.path "u64" ];
        };
        {
          name := "LdU128";
          item :=
            StructTuple
              [
                Ty.apply
                  (Ty.path "alloc::boxed::Box")
                  []
                  [ Ty.path "u128"; Ty.path "alloc::alloc::Global" ]
              ];
        };
        {
          name := "CastU8";
          item := StructTuple [];
        };
        {
          name := "CastU64";
          item := StructTuple [];
        };
        {
          name := "CastU128";
          item := StructTuple [];
        };
        {
          name := "LdConst";
          item := StructTuple [ Ty.path "move_binary_format::file_format::ConstantPoolIndex" ];
        };
        {
          name := "LdTrue";
          item := StructTuple [];
        };
        {
          name := "LdFalse";
          item := StructTuple [];
        };
        {
          name := "CopyLoc";
          item := StructTuple [ Ty.path "u8" ];
        };
        {
          name := "MoveLoc";
          item := StructTuple [ Ty.path "u8" ];
        };
        {
          name := "StLoc";
          item := StructTuple [ Ty.path "u8" ];
        };
        {
          name := "Call";
          item := StructTuple [ Ty.path "move_binary_format::file_format::FunctionHandleIndex" ];
        };
        {
          name := "CallGeneric";
          item :=
            StructTuple [ Ty.path "move_binary_format::file_format::FunctionInstantiationIndex" ];
        };
        {
          name := "Pack";
          item := StructTuple [ Ty.path "move_binary_format::file_format::StructDefinitionIndex" ];
        };
        {
          name := "PackGeneric";
          item :=
            StructTuple [ Ty.path "move_binary_format::file_format::StructDefInstantiationIndex" ];
        };
        {
          name := "Unpack";
          item := StructTuple [ Ty.path "move_binary_format::file_format::StructDefinitionIndex" ];
        };
        {
          name := "UnpackGeneric";
          item :=
            StructTuple [ Ty.path "move_binary_format::file_format::StructDefInstantiationIndex" ];
        };
        {
          name := "ReadRef";
          item := StructTuple [];
        };
        {
          name := "WriteRef";
          item := StructTuple [];
        };
        {
          name := "FreezeRef";
          item := StructTuple [];
        };
        {
          name := "MutBorrowLoc";
          item := StructTuple [ Ty.path "u8" ];
        };
        {
          name := "ImmBorrowLoc";
          item := StructTuple [ Ty.path "u8" ];
        };
        {
          name := "MutBorrowField";
          item := StructTuple [ Ty.path "move_binary_format::file_format::FieldHandleIndex" ];
        };
        {
          name := "MutBorrowFieldGeneric";
          item :=
            StructTuple [ Ty.path "move_binary_format::file_format::FieldInstantiationIndex" ];
        };
        {
          name := "ImmBorrowField";
          item := StructTuple [ Ty.path "move_binary_format::file_format::FieldHandleIndex" ];
        };
        {
          name := "ImmBorrowFieldGeneric";
          item :=
            StructTuple [ Ty.path "move_binary_format::file_format::FieldInstantiationIndex" ];
        };
        {
          name := "Add";
          item := StructTuple [];
        };
        {
          name := "Sub";
          item := StructTuple [];
        };
        {
          name := "Mul";
          item := StructTuple [];
        };
        {
          name := "Mod";
          item := StructTuple [];
        };
        {
          name := "Div";
          item := StructTuple [];
        };
        {
          name := "BitOr";
          item := StructTuple [];
        };
        {
          name := "BitAnd";
          item := StructTuple [];
        };
        {
          name := "Xor";
          item := StructTuple [];
        };
        {
          name := "Or";
          item := StructTuple [];
        };
        {
          name := "And";
          item := StructTuple [];
        };
        {
          name := "Not";
          item := StructTuple [];
        };
        {
          name := "Eq";
          item := StructTuple [];
        };
        {
          name := "Neq";
          item := StructTuple [];
        };
        {
          name := "Lt";
          item := StructTuple [];
        };
        {
          name := "Gt";
          item := StructTuple [];
        };
        {
          name := "Le";
          item := StructTuple [];
        };
        {
          name := "Ge";
          item := StructTuple [];
        };
        {
          name := "Abort";
          item := StructTuple [];
        };
        {
          name := "Nop";
          item := StructTuple [];
        };
        {
          name := "Shl";
          item := StructTuple [];
        };
        {
          name := "Shr";
          item := StructTuple [];
        };
        {
          name := "VecPack";
          item :=
            StructTuple
              [ Ty.path "move_binary_format::file_format::SignatureIndex"; Ty.path "u64" ];
        };
        {
          name := "VecLen";
          item := StructTuple [ Ty.path "move_binary_format::file_format::SignatureIndex" ];
        };
        {
          name := "VecImmBorrow";
          item := StructTuple [ Ty.path "move_binary_format::file_format::SignatureIndex" ];
        };
        {
          name := "VecMutBorrow";
          item := StructTuple [ Ty.path "move_binary_format::file_format::SignatureIndex" ];
        };
        {
          name := "VecPushBack";
          item := StructTuple [ Ty.path "move_binary_format::file_format::SignatureIndex" ];
        };
        {
          name := "VecPopBack";
          item := StructTuple [ Ty.path "move_binary_format::file_format::SignatureIndex" ];
        };
        {
          name := "VecUnpack";
          item :=
            StructTuple
              [ Ty.path "move_binary_format::file_format::SignatureIndex"; Ty.path "u64" ];
        };
        {
          name := "VecSwap";
          item := StructTuple [ Ty.path "move_binary_format::file_format::SignatureIndex" ];
        };
        {
          name := "LdU16";
          item := StructTuple [ Ty.path "u16" ];
        };
        {
          name := "LdU32";
          item := StructTuple [ Ty.path "u32" ];
        };
        {
          name := "LdU256";
          item :=
            StructTuple
              [
                Ty.apply
                  (Ty.path "alloc::boxed::Box")
                  []
                  [ Ty.path "move_core_types::u256::U256"; Ty.path "alloc::alloc::Global" ]
              ];
        };
        {
          name := "CastU16";
          item := StructTuple [];
        };
        {
          name := "CastU32";
          item := StructTuple [];
        };
        {
          name := "CastU256";
          item := StructTuple [];
        };
        {
          name := "ExistsDeprecated";
          item := StructTuple [ Ty.path "move_binary_format::file_format::StructDefinitionIndex" ];
        };
        {
          name := "ExistsGenericDeprecated";
          item :=
            StructTuple [ Ty.path "move_binary_format::file_format::StructDefInstantiationIndex" ];
        };
        {
          name := "MoveFromDeprecated";
          item := StructTuple [ Ty.path "move_binary_format::file_format::StructDefinitionIndex" ];
        };
        {
          name := "MoveFromGenericDeprecated";
          item :=
            StructTuple [ Ty.path "move_binary_format::file_format::StructDefInstantiationIndex" ];
        };
        {
          name := "MoveToDeprecated";
          item := StructTuple [ Ty.path "move_binary_format::file_format::StructDefinitionIndex" ];
        };
        {
          name := "MoveToGenericDeprecated";
          item :=
            StructTuple [ Ty.path "move_binary_format::file_format::StructDefInstantiationIndex" ];
        };
        {
          name := "MutBorrowGlobalDeprecated";
          item := StructTuple [ Ty.path "move_binary_format::file_format::StructDefinitionIndex" ];
        };
        {
          name := "MutBorrowGlobalGenericDeprecated";
          item :=
            StructTuple [ Ty.path "move_binary_format::file_format::StructDefInstantiationIndex" ];
        };
        {
          name := "ImmBorrowGlobalDeprecated";
          item := StructTuple [ Ty.path "move_binary_format::file_format::StructDefinitionIndex" ];
        };
        {
          name := "ImmBorrowGlobalGenericDeprecated";
          item :=
            StructTuple [ Ty.path "move_binary_format::file_format::StructDefInstantiationIndex" ];
        }
      ];
  }
  *)
  
  Axiom IsDiscriminant_Bytecode_Pop :
    M.IsDiscriminant "move_binary_format::file_format::Bytecode::Pop" 0.
  Axiom IsDiscriminant_Bytecode_Ret :
    M.IsDiscriminant "move_binary_format::file_format::Bytecode::Ret" 1.
  Axiom IsDiscriminant_Bytecode_BrTrue :
    M.IsDiscriminant "move_binary_format::file_format::Bytecode::BrTrue" 2.
  Axiom IsDiscriminant_Bytecode_BrFalse :
    M.IsDiscriminant "move_binary_format::file_format::Bytecode::BrFalse" 3.
  Axiom IsDiscriminant_Bytecode_Branch :
    M.IsDiscriminant "move_binary_format::file_format::Bytecode::Branch" 4.
  Axiom IsDiscriminant_Bytecode_LdU8 :
    M.IsDiscriminant "move_binary_format::file_format::Bytecode::LdU8" 5.
  Axiom IsDiscriminant_Bytecode_LdU64 :
    M.IsDiscriminant "move_binary_format::file_format::Bytecode::LdU64" 6.
  Axiom IsDiscriminant_Bytecode_LdU128 :
    M.IsDiscriminant "move_binary_format::file_format::Bytecode::LdU128" 7.
  Axiom IsDiscriminant_Bytecode_CastU8 :
    M.IsDiscriminant "move_binary_format::file_format::Bytecode::CastU8" 8.
  Axiom IsDiscriminant_Bytecode_CastU64 :
    M.IsDiscriminant "move_binary_format::file_format::Bytecode::CastU64" 9.
  Axiom IsDiscriminant_Bytecode_CastU128 :
    M.IsDiscriminant "move_binary_format::file_format::Bytecode::CastU128" 10.
  Axiom IsDiscriminant_Bytecode_LdConst :
    M.IsDiscriminant "move_binary_format::file_format::Bytecode::LdConst" 11.
  Axiom IsDiscriminant_Bytecode_LdTrue :
    M.IsDiscriminant "move_binary_format::file_format::Bytecode::LdTrue" 12.
  Axiom IsDiscriminant_Bytecode_LdFalse :
    M.IsDiscriminant "move_binary_format::file_format::Bytecode::LdFalse" 13.
  Axiom IsDiscriminant_Bytecode_CopyLoc :
    M.IsDiscriminant "move_binary_format::file_format::Bytecode::CopyLoc" 14.
  Axiom IsDiscriminant_Bytecode_MoveLoc :
    M.IsDiscriminant "move_binary_format::file_format::Bytecode::MoveLoc" 15.
  Axiom IsDiscriminant_Bytecode_StLoc :
    M.IsDiscriminant "move_binary_format::file_format::Bytecode::StLoc" 16.
  Axiom IsDiscriminant_Bytecode_Call :
    M.IsDiscriminant "move_binary_format::file_format::Bytecode::Call" 17.
  Axiom IsDiscriminant_Bytecode_CallGeneric :
    M.IsDiscriminant "move_binary_format::file_format::Bytecode::CallGeneric" 18.
  Axiom IsDiscriminant_Bytecode_Pack :
    M.IsDiscriminant "move_binary_format::file_format::Bytecode::Pack" 19.
  Axiom IsDiscriminant_Bytecode_PackGeneric :
    M.IsDiscriminant "move_binary_format::file_format::Bytecode::PackGeneric" 20.
  Axiom IsDiscriminant_Bytecode_Unpack :
    M.IsDiscriminant "move_binary_format::file_format::Bytecode::Unpack" 21.
  Axiom IsDiscriminant_Bytecode_UnpackGeneric :
    M.IsDiscriminant "move_binary_format::file_format::Bytecode::UnpackGeneric" 22.
  Axiom IsDiscriminant_Bytecode_ReadRef :
    M.IsDiscriminant "move_binary_format::file_format::Bytecode::ReadRef" 23.
  Axiom IsDiscriminant_Bytecode_WriteRef :
    M.IsDiscriminant "move_binary_format::file_format::Bytecode::WriteRef" 24.
  Axiom IsDiscriminant_Bytecode_FreezeRef :
    M.IsDiscriminant "move_binary_format::file_format::Bytecode::FreezeRef" 25.
  Axiom IsDiscriminant_Bytecode_MutBorrowLoc :
    M.IsDiscriminant "move_binary_format::file_format::Bytecode::MutBorrowLoc" 26.
  Axiom IsDiscriminant_Bytecode_ImmBorrowLoc :
    M.IsDiscriminant "move_binary_format::file_format::Bytecode::ImmBorrowLoc" 27.
  Axiom IsDiscriminant_Bytecode_MutBorrowField :
    M.IsDiscriminant "move_binary_format::file_format::Bytecode::MutBorrowField" 28.
  Axiom IsDiscriminant_Bytecode_MutBorrowFieldGeneric :
    M.IsDiscriminant "move_binary_format::file_format::Bytecode::MutBorrowFieldGeneric" 29.
  Axiom IsDiscriminant_Bytecode_ImmBorrowField :
    M.IsDiscriminant "move_binary_format::file_format::Bytecode::ImmBorrowField" 30.
  Axiom IsDiscriminant_Bytecode_ImmBorrowFieldGeneric :
    M.IsDiscriminant "move_binary_format::file_format::Bytecode::ImmBorrowFieldGeneric" 31.
  Axiom IsDiscriminant_Bytecode_Add :
    M.IsDiscriminant "move_binary_format::file_format::Bytecode::Add" 32.
  Axiom IsDiscriminant_Bytecode_Sub :
    M.IsDiscriminant "move_binary_format::file_format::Bytecode::Sub" 33.
  Axiom IsDiscriminant_Bytecode_Mul :
    M.IsDiscriminant "move_binary_format::file_format::Bytecode::Mul" 34.
  Axiom IsDiscriminant_Bytecode_Mod :
    M.IsDiscriminant "move_binary_format::file_format::Bytecode::Mod" 35.
  Axiom IsDiscriminant_Bytecode_Div :
    M.IsDiscriminant "move_binary_format::file_format::Bytecode::Div" 36.
  Axiom IsDiscriminant_Bytecode_BitOr :
    M.IsDiscriminant "move_binary_format::file_format::Bytecode::BitOr" 37.
  Axiom IsDiscriminant_Bytecode_BitAnd :
    M.IsDiscriminant "move_binary_format::file_format::Bytecode::BitAnd" 38.
  Axiom IsDiscriminant_Bytecode_Xor :
    M.IsDiscriminant "move_binary_format::file_format::Bytecode::Xor" 39.
  Axiom IsDiscriminant_Bytecode_Or :
    M.IsDiscriminant "move_binary_format::file_format::Bytecode::Or" 40.
  Axiom IsDiscriminant_Bytecode_And :
    M.IsDiscriminant "move_binary_format::file_format::Bytecode::And" 41.
  Axiom IsDiscriminant_Bytecode_Not :
    M.IsDiscriminant "move_binary_format::file_format::Bytecode::Not" 42.
  Axiom IsDiscriminant_Bytecode_Eq :
    M.IsDiscriminant "move_binary_format::file_format::Bytecode::Eq" 43.
  Axiom IsDiscriminant_Bytecode_Neq :
    M.IsDiscriminant "move_binary_format::file_format::Bytecode::Neq" 44.
  Axiom IsDiscriminant_Bytecode_Lt :
    M.IsDiscriminant "move_binary_format::file_format::Bytecode::Lt" 45.
  Axiom IsDiscriminant_Bytecode_Gt :
    M.IsDiscriminant "move_binary_format::file_format::Bytecode::Gt" 46.
  Axiom IsDiscriminant_Bytecode_Le :
    M.IsDiscriminant "move_binary_format::file_format::Bytecode::Le" 47.
  Axiom IsDiscriminant_Bytecode_Ge :
    M.IsDiscriminant "move_binary_format::file_format::Bytecode::Ge" 48.
  Axiom IsDiscriminant_Bytecode_Abort :
    M.IsDiscriminant "move_binary_format::file_format::Bytecode::Abort" 49.
  Axiom IsDiscriminant_Bytecode_Nop :
    M.IsDiscriminant "move_binary_format::file_format::Bytecode::Nop" 50.
  Axiom IsDiscriminant_Bytecode_Shl :
    M.IsDiscriminant "move_binary_format::file_format::Bytecode::Shl" 51.
  Axiom IsDiscriminant_Bytecode_Shr :
    M.IsDiscriminant "move_binary_format::file_format::Bytecode::Shr" 52.
  Axiom IsDiscriminant_Bytecode_VecPack :
    M.IsDiscriminant "move_binary_format::file_format::Bytecode::VecPack" 53.
  Axiom IsDiscriminant_Bytecode_VecLen :
    M.IsDiscriminant "move_binary_format::file_format::Bytecode::VecLen" 54.
  Axiom IsDiscriminant_Bytecode_VecImmBorrow :
    M.IsDiscriminant "move_binary_format::file_format::Bytecode::VecImmBorrow" 55.
  Axiom IsDiscriminant_Bytecode_VecMutBorrow :
    M.IsDiscriminant "move_binary_format::file_format::Bytecode::VecMutBorrow" 56.
  Axiom IsDiscriminant_Bytecode_VecPushBack :
    M.IsDiscriminant "move_binary_format::file_format::Bytecode::VecPushBack" 57.
  Axiom IsDiscriminant_Bytecode_VecPopBack :
    M.IsDiscriminant "move_binary_format::file_format::Bytecode::VecPopBack" 58.
  Axiom IsDiscriminant_Bytecode_VecUnpack :
    M.IsDiscriminant "move_binary_format::file_format::Bytecode::VecUnpack" 59.
  Axiom IsDiscriminant_Bytecode_VecSwap :
    M.IsDiscriminant "move_binary_format::file_format::Bytecode::VecSwap" 60.
  Axiom IsDiscriminant_Bytecode_LdU16 :
    M.IsDiscriminant "move_binary_format::file_format::Bytecode::LdU16" 61.
  Axiom IsDiscriminant_Bytecode_LdU32 :
    M.IsDiscriminant "move_binary_format::file_format::Bytecode::LdU32" 62.
  Axiom IsDiscriminant_Bytecode_LdU256 :
    M.IsDiscriminant "move_binary_format::file_format::Bytecode::LdU256" 63.
  Axiom IsDiscriminant_Bytecode_CastU16 :
    M.IsDiscriminant "move_binary_format::file_format::Bytecode::CastU16" 64.
  Axiom IsDiscriminant_Bytecode_CastU32 :
    M.IsDiscriminant "move_binary_format::file_format::Bytecode::CastU32" 65.
  Axiom IsDiscriminant_Bytecode_CastU256 :
    M.IsDiscriminant "move_binary_format::file_format::Bytecode::CastU256" 66.
  Axiom IsDiscriminant_Bytecode_ExistsDeprecated :
    M.IsDiscriminant "move_binary_format::file_format::Bytecode::ExistsDeprecated" 67.
  Axiom IsDiscriminant_Bytecode_ExistsGenericDeprecated :
    M.IsDiscriminant "move_binary_format::file_format::Bytecode::ExistsGenericDeprecated" 68.
  Axiom IsDiscriminant_Bytecode_MoveFromDeprecated :
    M.IsDiscriminant "move_binary_format::file_format::Bytecode::MoveFromDeprecated" 69.
  Axiom IsDiscriminant_Bytecode_MoveFromGenericDeprecated :
    M.IsDiscriminant "move_binary_format::file_format::Bytecode::MoveFromGenericDeprecated" 70.
  Axiom IsDiscriminant_Bytecode_MoveToDeprecated :
    M.IsDiscriminant "move_binary_format::file_format::Bytecode::MoveToDeprecated" 71.
  Axiom IsDiscriminant_Bytecode_MoveToGenericDeprecated :
    M.IsDiscriminant "move_binary_format::file_format::Bytecode::MoveToGenericDeprecated" 72.
  Axiom IsDiscriminant_Bytecode_MutBorrowGlobalDeprecated :
    M.IsDiscriminant "move_binary_format::file_format::Bytecode::MutBorrowGlobalDeprecated" 73.
  Axiom IsDiscriminant_Bytecode_MutBorrowGlobalGenericDeprecated :
    M.IsDiscriminant
      "move_binary_format::file_format::Bytecode::MutBorrowGlobalGenericDeprecated"
      74.
  Axiom IsDiscriminant_Bytecode_ImmBorrowGlobalDeprecated :
    M.IsDiscriminant "move_binary_format::file_format::Bytecode::ImmBorrowGlobalDeprecated" 75.
  Axiom IsDiscriminant_Bytecode_ImmBorrowGlobalGenericDeprecated :
    M.IsDiscriminant
      "move_binary_format::file_format::Bytecode::ImmBorrowGlobalGenericDeprecated"
      76.
  
  Module Impl_core_clone_Clone_for_move_binary_format_file_format_Bytecode.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::Bytecode".
    
    (* Clone *)
    Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.path "move_binary_format::file_format::Bytecode" ],
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (| γ, "move_binary_format::file_format::Bytecode::Pop" |) in
                    M.alloc (|
                      Value.StructTuple "move_binary_format::file_format::Bytecode::Pop" [] [] []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (| γ, "move_binary_format::file_format::Bytecode::Ret" |) in
                    M.alloc (|
                      Value.StructTuple "move_binary_format::file_format::Bytecode::Ret" [] [] []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::BrTrue",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_binary_format::file_format::Bytecode::BrTrue"
                        []
                        []
                        [
                          M.call_closure (|
                            Ty.path "u16",
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.path "u16",
                              [],
                              [],
                              "clone",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::BrFalse",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_binary_format::file_format::Bytecode::BrFalse"
                        []
                        []
                        [
                          M.call_closure (|
                            Ty.path "u16",
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.path "u16",
                              [],
                              [],
                              "clone",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::Branch",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_binary_format::file_format::Bytecode::Branch"
                        []
                        []
                        [
                          M.call_closure (|
                            Ty.path "u16",
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.path "u16",
                              [],
                              [],
                              "clone",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::LdU8",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_binary_format::file_format::Bytecode::LdU8"
                        []
                        []
                        [
                          M.call_closure (|
                            Ty.path "u8",
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.path "u8",
                              [],
                              [],
                              "clone",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::LdU64",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_binary_format::file_format::Bytecode::LdU64"
                        []
                        []
                        [
                          M.call_closure (|
                            Ty.path "u64",
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.path "u64",
                              [],
                              [],
                              "clone",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::LdU128",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_binary_format::file_format::Bytecode::LdU128"
                        []
                        []
                        [
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "alloc::boxed::Box")
                              []
                              [ Ty.path "u128"; Ty.path "alloc::alloc::Global" ],
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.apply
                                (Ty.path "alloc::boxed::Box")
                                []
                                [ Ty.path "u128"; Ty.path "alloc::alloc::Global" ],
                              [],
                              [],
                              "clone",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "move_binary_format::file_format::Bytecode::CastU8"
                      |) in
                    M.alloc (|
                      Value.StructTuple "move_binary_format::file_format::Bytecode::CastU8" [] [] []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "move_binary_format::file_format::Bytecode::CastU64"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_binary_format::file_format::Bytecode::CastU64"
                        []
                        []
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "move_binary_format::file_format::Bytecode::CastU128"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_binary_format::file_format::Bytecode::CastU128"
                        []
                        []
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::LdConst",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_binary_format::file_format::Bytecode::LdConst"
                        []
                        []
                        [
                          M.call_closure (|
                            Ty.path "move_binary_format::file_format::ConstantPoolIndex",
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.path "move_binary_format::file_format::ConstantPoolIndex",
                              [],
                              [],
                              "clone",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "move_binary_format::file_format::Bytecode::LdTrue"
                      |) in
                    M.alloc (|
                      Value.StructTuple "move_binary_format::file_format::Bytecode::LdTrue" [] [] []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "move_binary_format::file_format::Bytecode::LdFalse"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_binary_format::file_format::Bytecode::LdFalse"
                        []
                        []
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::CopyLoc",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_binary_format::file_format::Bytecode::CopyLoc"
                        []
                        []
                        [
                          M.call_closure (|
                            Ty.path "u8",
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.path "u8",
                              [],
                              [],
                              "clone",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::MoveLoc",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_binary_format::file_format::Bytecode::MoveLoc"
                        []
                        []
                        [
                          M.call_closure (|
                            Ty.path "u8",
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.path "u8",
                              [],
                              [],
                              "clone",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::StLoc",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_binary_format::file_format::Bytecode::StLoc"
                        []
                        []
                        [
                          M.call_closure (|
                            Ty.path "u8",
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.path "u8",
                              [],
                              [],
                              "clone",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::Call",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_binary_format::file_format::Bytecode::Call"
                        []
                        []
                        [
                          M.call_closure (|
                            Ty.path "move_binary_format::file_format::FunctionHandleIndex",
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.path "move_binary_format::file_format::FunctionHandleIndex",
                              [],
                              [],
                              "clone",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::CallGeneric",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_binary_format::file_format::Bytecode::CallGeneric"
                        []
                        []
                        [
                          M.call_closure (|
                            Ty.path "move_binary_format::file_format::FunctionInstantiationIndex",
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.path "move_binary_format::file_format::FunctionInstantiationIndex",
                              [],
                              [],
                              "clone",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::Pack",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_binary_format::file_format::Bytecode::Pack"
                        []
                        []
                        [
                          M.call_closure (|
                            Ty.path "move_binary_format::file_format::StructDefinitionIndex",
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.path "move_binary_format::file_format::StructDefinitionIndex",
                              [],
                              [],
                              "clone",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::PackGeneric",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_binary_format::file_format::Bytecode::PackGeneric"
                        []
                        []
                        [
                          M.call_closure (|
                            Ty.path "move_binary_format::file_format::StructDefInstantiationIndex",
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.path
                                "move_binary_format::file_format::StructDefInstantiationIndex",
                              [],
                              [],
                              "clone",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::Unpack",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_binary_format::file_format::Bytecode::Unpack"
                        []
                        []
                        [
                          M.call_closure (|
                            Ty.path "move_binary_format::file_format::StructDefinitionIndex",
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.path "move_binary_format::file_format::StructDefinitionIndex",
                              [],
                              [],
                              "clone",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::UnpackGeneric",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_binary_format::file_format::Bytecode::UnpackGeneric"
                        []
                        []
                        [
                          M.call_closure (|
                            Ty.path "move_binary_format::file_format::StructDefInstantiationIndex",
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.path
                                "move_binary_format::file_format::StructDefInstantiationIndex",
                              [],
                              [],
                              "clone",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "move_binary_format::file_format::Bytecode::ReadRef"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_binary_format::file_format::Bytecode::ReadRef"
                        []
                        []
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "move_binary_format::file_format::Bytecode::WriteRef"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_binary_format::file_format::Bytecode::WriteRef"
                        []
                        []
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "move_binary_format::file_format::Bytecode::FreezeRef"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_binary_format::file_format::Bytecode::FreezeRef"
                        []
                        []
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::MutBorrowLoc",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_binary_format::file_format::Bytecode::MutBorrowLoc"
                        []
                        []
                        [
                          M.call_closure (|
                            Ty.path "u8",
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.path "u8",
                              [],
                              [],
                              "clone",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::ImmBorrowLoc",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_binary_format::file_format::Bytecode::ImmBorrowLoc"
                        []
                        []
                        [
                          M.call_closure (|
                            Ty.path "u8",
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.path "u8",
                              [],
                              [],
                              "clone",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::MutBorrowField",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_binary_format::file_format::Bytecode::MutBorrowField"
                        []
                        []
                        [
                          M.call_closure (|
                            Ty.path "move_binary_format::file_format::FieldHandleIndex",
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.path "move_binary_format::file_format::FieldHandleIndex",
                              [],
                              [],
                              "clone",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::MutBorrowFieldGeneric",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_binary_format::file_format::Bytecode::MutBorrowFieldGeneric"
                        []
                        []
                        [
                          M.call_closure (|
                            Ty.path "move_binary_format::file_format::FieldInstantiationIndex",
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.path "move_binary_format::file_format::FieldInstantiationIndex",
                              [],
                              [],
                              "clone",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::ImmBorrowField",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_binary_format::file_format::Bytecode::ImmBorrowField"
                        []
                        []
                        [
                          M.call_closure (|
                            Ty.path "move_binary_format::file_format::FieldHandleIndex",
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.path "move_binary_format::file_format::FieldHandleIndex",
                              [],
                              [],
                              "clone",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::ImmBorrowFieldGeneric",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_binary_format::file_format::Bytecode::ImmBorrowFieldGeneric"
                        []
                        []
                        [
                          M.call_closure (|
                            Ty.path "move_binary_format::file_format::FieldInstantiationIndex",
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.path "move_binary_format::file_format::FieldInstantiationIndex",
                              [],
                              [],
                              "clone",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (| γ, "move_binary_format::file_format::Bytecode::Add" |) in
                    M.alloc (|
                      Value.StructTuple "move_binary_format::file_format::Bytecode::Add" [] [] []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (| γ, "move_binary_format::file_format::Bytecode::Sub" |) in
                    M.alloc (|
                      Value.StructTuple "move_binary_format::file_format::Bytecode::Sub" [] [] []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (| γ, "move_binary_format::file_format::Bytecode::Mul" |) in
                    M.alloc (|
                      Value.StructTuple "move_binary_format::file_format::Bytecode::Mul" [] [] []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (| γ, "move_binary_format::file_format::Bytecode::Mod" |) in
                    M.alloc (|
                      Value.StructTuple "move_binary_format::file_format::Bytecode::Mod" [] [] []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (| γ, "move_binary_format::file_format::Bytecode::Div" |) in
                    M.alloc (|
                      Value.StructTuple "move_binary_format::file_format::Bytecode::Div" [] [] []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "move_binary_format::file_format::Bytecode::BitOr"
                      |) in
                    M.alloc (|
                      Value.StructTuple "move_binary_format::file_format::Bytecode::BitOr" [] [] []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "move_binary_format::file_format::Bytecode::BitAnd"
                      |) in
                    M.alloc (|
                      Value.StructTuple "move_binary_format::file_format::Bytecode::BitAnd" [] [] []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (| γ, "move_binary_format::file_format::Bytecode::Xor" |) in
                    M.alloc (|
                      Value.StructTuple "move_binary_format::file_format::Bytecode::Xor" [] [] []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (| γ, "move_binary_format::file_format::Bytecode::Or" |) in
                    M.alloc (|
                      Value.StructTuple "move_binary_format::file_format::Bytecode::Or" [] [] []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (| γ, "move_binary_format::file_format::Bytecode::And" |) in
                    M.alloc (|
                      Value.StructTuple "move_binary_format::file_format::Bytecode::And" [] [] []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (| γ, "move_binary_format::file_format::Bytecode::Not" |) in
                    M.alloc (|
                      Value.StructTuple "move_binary_format::file_format::Bytecode::Not" [] [] []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (| γ, "move_binary_format::file_format::Bytecode::Eq" |) in
                    M.alloc (|
                      Value.StructTuple "move_binary_format::file_format::Bytecode::Eq" [] [] []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (| γ, "move_binary_format::file_format::Bytecode::Neq" |) in
                    M.alloc (|
                      Value.StructTuple "move_binary_format::file_format::Bytecode::Neq" [] [] []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (| γ, "move_binary_format::file_format::Bytecode::Lt" |) in
                    M.alloc (|
                      Value.StructTuple "move_binary_format::file_format::Bytecode::Lt" [] [] []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (| γ, "move_binary_format::file_format::Bytecode::Gt" |) in
                    M.alloc (|
                      Value.StructTuple "move_binary_format::file_format::Bytecode::Gt" [] [] []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (| γ, "move_binary_format::file_format::Bytecode::Le" |) in
                    M.alloc (|
                      Value.StructTuple "move_binary_format::file_format::Bytecode::Le" [] [] []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (| γ, "move_binary_format::file_format::Bytecode::Ge" |) in
                    M.alloc (|
                      Value.StructTuple "move_binary_format::file_format::Bytecode::Ge" [] [] []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "move_binary_format::file_format::Bytecode::Abort"
                      |) in
                    M.alloc (|
                      Value.StructTuple "move_binary_format::file_format::Bytecode::Abort" [] [] []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (| γ, "move_binary_format::file_format::Bytecode::Nop" |) in
                    M.alloc (|
                      Value.StructTuple "move_binary_format::file_format::Bytecode::Nop" [] [] []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (| γ, "move_binary_format::file_format::Bytecode::Shl" |) in
                    M.alloc (|
                      Value.StructTuple "move_binary_format::file_format::Bytecode::Shl" [] [] []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (| γ, "move_binary_format::file_format::Bytecode::Shr" |) in
                    M.alloc (|
                      Value.StructTuple "move_binary_format::file_format::Bytecode::Shr" [] [] []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::VecPack",
                        0
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::VecPack",
                        1
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    let __self_1 := M.alloc (| γ1_1 |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_binary_format::file_format::Bytecode::VecPack"
                        []
                        []
                        [
                          M.call_closure (|
                            Ty.path "move_binary_format::file_format::SignatureIndex",
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.path "move_binary_format::file_format::SignatureIndex",
                              [],
                              [],
                              "clone",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |) ]
                          |);
                          M.call_closure (|
                            Ty.path "u64",
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.path "u64",
                              [],
                              [],
                              "clone",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_1 |) |) |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::VecLen",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_binary_format::file_format::Bytecode::VecLen"
                        []
                        []
                        [
                          M.call_closure (|
                            Ty.path "move_binary_format::file_format::SignatureIndex",
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.path "move_binary_format::file_format::SignatureIndex",
                              [],
                              [],
                              "clone",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::VecImmBorrow",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_binary_format::file_format::Bytecode::VecImmBorrow"
                        []
                        []
                        [
                          M.call_closure (|
                            Ty.path "move_binary_format::file_format::SignatureIndex",
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.path "move_binary_format::file_format::SignatureIndex",
                              [],
                              [],
                              "clone",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::VecMutBorrow",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_binary_format::file_format::Bytecode::VecMutBorrow"
                        []
                        []
                        [
                          M.call_closure (|
                            Ty.path "move_binary_format::file_format::SignatureIndex",
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.path "move_binary_format::file_format::SignatureIndex",
                              [],
                              [],
                              "clone",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::VecPushBack",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_binary_format::file_format::Bytecode::VecPushBack"
                        []
                        []
                        [
                          M.call_closure (|
                            Ty.path "move_binary_format::file_format::SignatureIndex",
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.path "move_binary_format::file_format::SignatureIndex",
                              [],
                              [],
                              "clone",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::VecPopBack",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_binary_format::file_format::Bytecode::VecPopBack"
                        []
                        []
                        [
                          M.call_closure (|
                            Ty.path "move_binary_format::file_format::SignatureIndex",
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.path "move_binary_format::file_format::SignatureIndex",
                              [],
                              [],
                              "clone",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::VecUnpack",
                        0
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::VecUnpack",
                        1
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    let __self_1 := M.alloc (| γ1_1 |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_binary_format::file_format::Bytecode::VecUnpack"
                        []
                        []
                        [
                          M.call_closure (|
                            Ty.path "move_binary_format::file_format::SignatureIndex",
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.path "move_binary_format::file_format::SignatureIndex",
                              [],
                              [],
                              "clone",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |) ]
                          |);
                          M.call_closure (|
                            Ty.path "u64",
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.path "u64",
                              [],
                              [],
                              "clone",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_1 |) |) |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::VecSwap",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_binary_format::file_format::Bytecode::VecSwap"
                        []
                        []
                        [
                          M.call_closure (|
                            Ty.path "move_binary_format::file_format::SignatureIndex",
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.path "move_binary_format::file_format::SignatureIndex",
                              [],
                              [],
                              "clone",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::LdU16",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_binary_format::file_format::Bytecode::LdU16"
                        []
                        []
                        [
                          M.call_closure (|
                            Ty.path "u16",
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.path "u16",
                              [],
                              [],
                              "clone",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::LdU32",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_binary_format::file_format::Bytecode::LdU32"
                        []
                        []
                        [
                          M.call_closure (|
                            Ty.path "u32",
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.path "u32",
                              [],
                              [],
                              "clone",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::LdU256",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_binary_format::file_format::Bytecode::LdU256"
                        []
                        []
                        [
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "alloc::boxed::Box")
                              []
                              [
                                Ty.path "move_core_types::u256::U256";
                                Ty.path "alloc::alloc::Global"
                              ],
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.apply
                                (Ty.path "alloc::boxed::Box")
                                []
                                [
                                  Ty.path "move_core_types::u256::U256";
                                  Ty.path "alloc::alloc::Global"
                                ],
                              [],
                              [],
                              "clone",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "move_binary_format::file_format::Bytecode::CastU16"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_binary_format::file_format::Bytecode::CastU16"
                        []
                        []
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "move_binary_format::file_format::Bytecode::CastU32"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_binary_format::file_format::Bytecode::CastU32"
                        []
                        []
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "move_binary_format::file_format::Bytecode::CastU256"
                      |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_binary_format::file_format::Bytecode::CastU256"
                        []
                        []
                        []
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::ExistsDeprecated",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_binary_format::file_format::Bytecode::ExistsDeprecated"
                        []
                        []
                        [
                          M.call_closure (|
                            Ty.path "move_binary_format::file_format::StructDefinitionIndex",
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.path "move_binary_format::file_format::StructDefinitionIndex",
                              [],
                              [],
                              "clone",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::ExistsGenericDeprecated",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_binary_format::file_format::Bytecode::ExistsGenericDeprecated"
                        []
                        []
                        [
                          M.call_closure (|
                            Ty.path "move_binary_format::file_format::StructDefInstantiationIndex",
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.path
                                "move_binary_format::file_format::StructDefInstantiationIndex",
                              [],
                              [],
                              "clone",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::MoveFromDeprecated",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_binary_format::file_format::Bytecode::MoveFromDeprecated"
                        []
                        []
                        [
                          M.call_closure (|
                            Ty.path "move_binary_format::file_format::StructDefinitionIndex",
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.path "move_binary_format::file_format::StructDefinitionIndex",
                              [],
                              [],
                              "clone",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::MoveFromGenericDeprecated",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_binary_format::file_format::Bytecode::MoveFromGenericDeprecated"
                        []
                        []
                        [
                          M.call_closure (|
                            Ty.path "move_binary_format::file_format::StructDefInstantiationIndex",
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.path
                                "move_binary_format::file_format::StructDefInstantiationIndex",
                              [],
                              [],
                              "clone",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::MoveToDeprecated",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_binary_format::file_format::Bytecode::MoveToDeprecated"
                        []
                        []
                        [
                          M.call_closure (|
                            Ty.path "move_binary_format::file_format::StructDefinitionIndex",
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.path "move_binary_format::file_format::StructDefinitionIndex",
                              [],
                              [],
                              "clone",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::MoveToGenericDeprecated",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_binary_format::file_format::Bytecode::MoveToGenericDeprecated"
                        []
                        []
                        [
                          M.call_closure (|
                            Ty.path "move_binary_format::file_format::StructDefInstantiationIndex",
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.path
                                "move_binary_format::file_format::StructDefInstantiationIndex",
                              [],
                              [],
                              "clone",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::MutBorrowGlobalDeprecated",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_binary_format::file_format::Bytecode::MutBorrowGlobalDeprecated"
                        []
                        []
                        [
                          M.call_closure (|
                            Ty.path "move_binary_format::file_format::StructDefinitionIndex",
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.path "move_binary_format::file_format::StructDefinitionIndex",
                              [],
                              [],
                              "clone",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::MutBorrowGlobalGenericDeprecated",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_binary_format::file_format::Bytecode::MutBorrowGlobalGenericDeprecated"
                        []
                        []
                        [
                          M.call_closure (|
                            Ty.path "move_binary_format::file_format::StructDefInstantiationIndex",
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.path
                                "move_binary_format::file_format::StructDefInstantiationIndex",
                              [],
                              [],
                              "clone",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::ImmBorrowGlobalDeprecated",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_binary_format::file_format::Bytecode::ImmBorrowGlobalDeprecated"
                        []
                        []
                        [
                          M.call_closure (|
                            Ty.path "move_binary_format::file_format::StructDefinitionIndex",
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.path "move_binary_format::file_format::StructDefinitionIndex",
                              [],
                              [],
                              "clone",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |) ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::ImmBorrowGlobalGenericDeprecated",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_binary_format::file_format::Bytecode::ImmBorrowGlobalGenericDeprecated"
                        []
                        []
                        [
                          M.call_closure (|
                            Ty.path "move_binary_format::file_format::StructDefInstantiationIndex",
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.path
                                "move_binary_format::file_format::StructDefInstantiationIndex",
                              [],
                              [],
                              "clone",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |) ]
                          |)
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_move_binary_format_file_format_Bytecode.
  
  Module Impl_core_hash_Hash_for_move_binary_format_file_format_Bytecode.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::Bytecode".
    
    (* Hash *)
    Definition hash (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ __H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let state := M.alloc (| state |) in
          M.read (|
            let~ __self_discr : Ty.path "isize" :=
              M.call_closure (|
                Ty.path "isize",
                M.get_function (|
                  "core::intrinsics::discriminant_value",
                  [],
                  [ Ty.path "move_binary_format::file_format::Bytecode" ]
                |),
                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
              |) in
            let~ _ : Ty.tuple [] :=
              M.call_closure (|
                Ty.tuple [],
                M.get_trait_method (|
                  "core::hash::Hash",
                  Ty.path "isize",
                  [],
                  [],
                  "hash",
                  [],
                  [ __H ]
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (| M.borrow (| Pointer.Kind.Ref, __self_discr |) |)
                  |);
                  M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                ]
              |) in
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::BrTrue",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.path "u16",
                          [],
                          [],
                          "hash",
                          [],
                          [ __H ]
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |);
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::BrFalse",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.path "u16",
                          [],
                          [],
                          "hash",
                          [],
                          [ __H ]
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |);
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::Branch",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.path "u16",
                          [],
                          [],
                          "hash",
                          [],
                          [ __H ]
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |);
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::LdU8",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.path "u8",
                          [],
                          [],
                          "hash",
                          [],
                          [ __H ]
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |);
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::LdU64",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.path "u64",
                          [],
                          [],
                          "hash",
                          [],
                          [ __H ]
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |);
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::LdU128",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.apply
                            (Ty.path "alloc::boxed::Box")
                            []
                            [ Ty.path "u128"; Ty.path "alloc::alloc::Global" ],
                          [],
                          [],
                          "hash",
                          [],
                          [ __H ]
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |);
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::LdConst",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.path "move_binary_format::file_format::ConstantPoolIndex",
                          [],
                          [],
                          "hash",
                          [],
                          [ __H ]
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |);
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::CopyLoc",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.path "u8",
                          [],
                          [],
                          "hash",
                          [],
                          [ __H ]
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |);
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::MoveLoc",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.path "u8",
                          [],
                          [],
                          "hash",
                          [],
                          [ __H ]
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |);
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::StLoc",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.path "u8",
                          [],
                          [],
                          "hash",
                          [],
                          [ __H ]
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |);
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::Call",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.path "move_binary_format::file_format::FunctionHandleIndex",
                          [],
                          [],
                          "hash",
                          [],
                          [ __H ]
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |);
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::CallGeneric",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.path "move_binary_format::file_format::FunctionInstantiationIndex",
                          [],
                          [],
                          "hash",
                          [],
                          [ __H ]
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |);
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::Pack",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.path "move_binary_format::file_format::StructDefinitionIndex",
                          [],
                          [],
                          "hash",
                          [],
                          [ __H ]
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |);
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::PackGeneric",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.path "move_binary_format::file_format::StructDefInstantiationIndex",
                          [],
                          [],
                          "hash",
                          [],
                          [ __H ]
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |);
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::Unpack",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.path "move_binary_format::file_format::StructDefinitionIndex",
                          [],
                          [],
                          "hash",
                          [],
                          [ __H ]
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |);
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::UnpackGeneric",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.path "move_binary_format::file_format::StructDefInstantiationIndex",
                          [],
                          [],
                          "hash",
                          [],
                          [ __H ]
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |);
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::MutBorrowLoc",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.path "u8",
                          [],
                          [],
                          "hash",
                          [],
                          [ __H ]
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |);
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::ImmBorrowLoc",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.path "u8",
                          [],
                          [],
                          "hash",
                          [],
                          [ __H ]
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |);
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::MutBorrowField",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.path "move_binary_format::file_format::FieldHandleIndex",
                          [],
                          [],
                          "hash",
                          [],
                          [ __H ]
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |);
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::MutBorrowFieldGeneric",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.path "move_binary_format::file_format::FieldInstantiationIndex",
                          [],
                          [],
                          "hash",
                          [],
                          [ __H ]
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |);
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::ImmBorrowField",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.path "move_binary_format::file_format::FieldHandleIndex",
                          [],
                          [],
                          "hash",
                          [],
                          [ __H ]
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |);
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::ImmBorrowFieldGeneric",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.path "move_binary_format::file_format::FieldInstantiationIndex",
                          [],
                          [],
                          "hash",
                          [],
                          [ __H ]
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |);
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::VecPack",
                        0
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::VecPack",
                        1
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    let __self_1 := M.alloc (| γ1_1 |) in
                    let~ _ : Ty.tuple [] :=
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.path "move_binary_format::file_format::SignatureIndex",
                          [],
                          [],
                          "hash",
                          [],
                          [ __H ]
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |);
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                        ]
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.path "u64",
                          [],
                          [],
                          "hash",
                          [],
                          [ __H ]
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_1 |) |) |);
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::VecLen",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.path "move_binary_format::file_format::SignatureIndex",
                          [],
                          [],
                          "hash",
                          [],
                          [ __H ]
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |);
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::VecImmBorrow",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.path "move_binary_format::file_format::SignatureIndex",
                          [],
                          [],
                          "hash",
                          [],
                          [ __H ]
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |);
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::VecMutBorrow",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.path "move_binary_format::file_format::SignatureIndex",
                          [],
                          [],
                          "hash",
                          [],
                          [ __H ]
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |);
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::VecPushBack",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.path "move_binary_format::file_format::SignatureIndex",
                          [],
                          [],
                          "hash",
                          [],
                          [ __H ]
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |);
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::VecPopBack",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.path "move_binary_format::file_format::SignatureIndex",
                          [],
                          [],
                          "hash",
                          [],
                          [ __H ]
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |);
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::VecUnpack",
                        0
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::VecUnpack",
                        1
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    let __self_1 := M.alloc (| γ1_1 |) in
                    let~ _ : Ty.tuple [] :=
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.path "move_binary_format::file_format::SignatureIndex",
                          [],
                          [],
                          "hash",
                          [],
                          [ __H ]
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |);
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                        ]
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.path "u64",
                          [],
                          [],
                          "hash",
                          [],
                          [ __H ]
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_1 |) |) |);
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::VecSwap",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.path "move_binary_format::file_format::SignatureIndex",
                          [],
                          [],
                          "hash",
                          [],
                          [ __H ]
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |);
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::LdU16",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.path "u16",
                          [],
                          [],
                          "hash",
                          [],
                          [ __H ]
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |);
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::LdU32",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.path "u32",
                          [],
                          [],
                          "hash",
                          [],
                          [ __H ]
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |);
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::LdU256",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.apply
                            (Ty.path "alloc::boxed::Box")
                            []
                            [ Ty.path "move_core_types::u256::U256"; Ty.path "alloc::alloc::Global"
                            ],
                          [],
                          [],
                          "hash",
                          [],
                          [ __H ]
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |);
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::ExistsDeprecated",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.path "move_binary_format::file_format::StructDefinitionIndex",
                          [],
                          [],
                          "hash",
                          [],
                          [ __H ]
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |);
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::ExistsGenericDeprecated",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.path "move_binary_format::file_format::StructDefInstantiationIndex",
                          [],
                          [],
                          "hash",
                          [],
                          [ __H ]
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |);
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::MoveFromDeprecated",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.path "move_binary_format::file_format::StructDefinitionIndex",
                          [],
                          [],
                          "hash",
                          [],
                          [ __H ]
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |);
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::MoveFromGenericDeprecated",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.path "move_binary_format::file_format::StructDefInstantiationIndex",
                          [],
                          [],
                          "hash",
                          [],
                          [ __H ]
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |);
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::MoveToDeprecated",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.path "move_binary_format::file_format::StructDefinitionIndex",
                          [],
                          [],
                          "hash",
                          [],
                          [ __H ]
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |);
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::MoveToGenericDeprecated",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.path "move_binary_format::file_format::StructDefInstantiationIndex",
                          [],
                          [],
                          "hash",
                          [],
                          [ __H ]
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |);
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::MutBorrowGlobalDeprecated",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.path "move_binary_format::file_format::StructDefinitionIndex",
                          [],
                          [],
                          "hash",
                          [],
                          [ __H ]
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |);
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::MutBorrowGlobalGenericDeprecated",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.path "move_binary_format::file_format::StructDefInstantiationIndex",
                          [],
                          [],
                          "hash",
                          [],
                          [ __H ]
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |);
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::ImmBorrowGlobalDeprecated",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.path "move_binary_format::file_format::StructDefinitionIndex",
                          [],
                          [],
                          "hash",
                          [],
                          [ __H ]
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |);
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::ImmBorrowGlobalGenericDeprecated",
                        0
                      |) in
                    let __self_0 := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_trait_method (|
                          "core::hash::Hash",
                          Ty.path "move_binary_format::file_format::StructDefInstantiationIndex",
                          [],
                          [],
                          "hash",
                          [],
                          [ __H ]
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |);
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                        ]
                      |)
                    |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::hash::Hash"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("hash", InstanceField.Method hash) ].
  End Impl_core_hash_Hash_for_move_binary_format_file_format_Bytecode.
  
  Module Impl_core_cmp_Eq_for_move_binary_format_file_format_Bytecode.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::Bytecode".
    
    (* Eq *)
    Definition assert_receiver_is_total_eq
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              Value.DeclaredButUndefined,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                      Value.DeclaredButUndefined,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                              Value.DeclaredButUndefined,
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (M.match_operator (|
                                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                      Value.DeclaredButUndefined,
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (M.match_operator (|
                                              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                              Value.DeclaredButUndefined,
                                              [
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (M.match_operator (|
                                                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                                      Value.DeclaredButUndefined,
                                                      [
                                                        fun γ =>
                                                          ltac:(M.monadic
                                                            (M.match_operator (|
                                                              Ty.apply
                                                                (Ty.path "*")
                                                                []
                                                                [ Ty.tuple [] ],
                                                              Value.DeclaredButUndefined,
                                                              [
                                                                fun γ =>
                                                                  ltac:(M.monadic
                                                                    (M.match_operator (|
                                                                      Ty.apply
                                                                        (Ty.path "*")
                                                                        []
                                                                        [ Ty.tuple [] ],
                                                                      Value.DeclaredButUndefined,
                                                                      [
                                                                        fun γ =>
                                                                          ltac:(M.monadic
                                                                            (M.match_operator (|
                                                                              Ty.apply
                                                                                (Ty.path "*")
                                                                                []
                                                                                [ Ty.tuple [] ],
                                                                              Value.DeclaredButUndefined,
                                                                              [
                                                                                fun γ =>
                                                                                  ltac:(M.monadic
                                                                                    (M.match_operator (|
                                                                                      Ty.apply
                                                                                        (Ty.path
                                                                                          "*")
                                                                                        []
                                                                                        [
                                                                                          Ty.tuple
                                                                                            []
                                                                                        ],
                                                                                      Value.DeclaredButUndefined,
                                                                                      [
                                                                                        fun γ =>
                                                                                          ltac:(M.monadic
                                                                                            (M.match_operator (|
                                                                                              Ty.apply
                                                                                                (Ty.path
                                                                                                  "*")
                                                                                                []
                                                                                                [
                                                                                                  Ty.tuple
                                                                                                    []
                                                                                                ],
                                                                                              Value.DeclaredButUndefined,
                                                                                              [
                                                                                                fun
                                                                                                    γ =>
                                                                                                  ltac:(M.monadic
                                                                                                    (M.match_operator (|
                                                                                                      Ty.apply
                                                                                                        (Ty.path
                                                                                                          "*")
                                                                                                        []
                                                                                                        [
                                                                                                          Ty.tuple
                                                                                                            []
                                                                                                        ],
                                                                                                      Value.DeclaredButUndefined,
                                                                                                      [
                                                                                                        fun
                                                                                                            γ =>
                                                                                                          ltac:(M.monadic
                                                                                                            (M.match_operator (|
                                                                                                              Ty.apply
                                                                                                                (Ty.path
                                                                                                                  "*")
                                                                                                                []
                                                                                                                [
                                                                                                                  Ty.tuple
                                                                                                                    []
                                                                                                                ],
                                                                                                              Value.DeclaredButUndefined,
                                                                                                              [
                                                                                                                fun
                                                                                                                    γ =>
                                                                                                                  ltac:(M.monadic
                                                                                                                    (M.match_operator (|
                                                                                                                      Ty.apply
                                                                                                                        (Ty.path
                                                                                                                          "*")
                                                                                                                        []
                                                                                                                        [
                                                                                                                          Ty.tuple
                                                                                                                            []
                                                                                                                        ],
                                                                                                                      Value.DeclaredButUndefined,
                                                                                                                      [
                                                                                                                        fun
                                                                                                                            γ =>
                                                                                                                          ltac:(M.monadic
                                                                                                                            (M.match_operator (|
                                                                                                                              Ty.apply
                                                                                                                                (Ty.path
                                                                                                                                  "*")
                                                                                                                                []
                                                                                                                                [
                                                                                                                                  Ty.tuple
                                                                                                                                    []
                                                                                                                                ],
                                                                                                                              Value.DeclaredButUndefined,
                                                                                                                              [
                                                                                                                                fun
                                                                                                                                    γ =>
                                                                                                                                  ltac:(M.monadic
                                                                                                                                    (M.match_operator (|
                                                                                                                                      Ty.apply
                                                                                                                                        (Ty.path
                                                                                                                                          "*")
                                                                                                                                        []
                                                                                                                                        [
                                                                                                                                          Ty.tuple
                                                                                                                                            []
                                                                                                                                        ],
                                                                                                                                      Value.DeclaredButUndefined,
                                                                                                                                      [
                                                                                                                                        fun
                                                                                                                                            γ =>
                                                                                                                                          ltac:(M.monadic
                                                                                                                                            (M.alloc (|
                                                                                                                                              Value.Tuple
                                                                                                                                                []
                                                                                                                                            |)))
                                                                                                                                      ]
                                                                                                                                    |)))
                                                                                                                              ]
                                                                                                                            |)))
                                                                                                                      ]
                                                                                                                    |)))
                                                                                                              ]
                                                                                                            |)))
                                                                                                      ]
                                                                                                    |)))
                                                                                              ]
                                                                                            |)))
                                                                                      ]
                                                                                    |)))
                                                                              ]
                                                                            |)))
                                                                      ]
                                                                    |)))
                                                              ]
                                                            |)))
                                                      ]
                                                    |)))
                                              ]
                                            |)))
                                      ]
                                    |)))
                              ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_move_binary_format_file_format_Bytecode.
  
  Module Impl_move_binary_format_file_format_Bytecode.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::Bytecode".
    
    (* VariantCount *)
    (* Ty.path "usize" *)
    Definition value_VARIANT_COUNT (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.Usize 77 |))).
    
    Global Instance AssociatedConstant_value_VARIANT_COUNT :
      M.IsAssociatedFunction.C Self "VARIANT_COUNT" value_VARIANT_COUNT.
    Admitted.
    Global Typeclasses Opaque value_VARIANT_COUNT.
    (*
        pub fn is_unconditional_branch(&self) -> bool {
            matches!(self, Bytecode::Ret | Bytecode::Abort | Bytecode::Branch(_))
        }
    *)
    Definition is_unconditional_branch (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.path "bool" ],
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.find_or_pattern (Ty.tuple []) (|
                      γ,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.read (| γ |) in
                            let _ :=
                              M.is_struct_tuple (|
                                γ,
                                "move_binary_format::file_format::Bytecode::Ret"
                              |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.read (| γ |) in
                            let _ :=
                              M.is_struct_tuple (|
                                γ,
                                "move_binary_format::file_format::Bytecode::Abort"
                              |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.read (| γ |) in
                            let γ1_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "move_binary_format::file_format::Bytecode::Branch",
                                0
                              |) in
                            Value.Tuple []))
                      ],
                      fun γ =>
                        ltac:(M.monadic
                          match γ with
                          | [] => ltac:(M.monadic (M.alloc (| Value.Bool true |)))
                          | _ => M.impossible "wrong number of arguments"
                          end)
                    |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Bool false |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_is_unconditional_branch :
      M.IsAssociatedFunction.C Self "is_unconditional_branch" is_unconditional_branch.
    Admitted.
    Global Typeclasses Opaque is_unconditional_branch.
    
    (*
        pub fn is_conditional_branch(&self) -> bool {
            matches!(self, Bytecode::BrFalse(_) | Bytecode::BrTrue(_))
        }
    *)
    Definition is_conditional_branch (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.path "bool" ],
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.find_or_pattern (Ty.tuple []) (|
                      γ,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.read (| γ |) in
                            let γ1_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "move_binary_format::file_format::Bytecode::BrFalse",
                                0
                              |) in
                            Value.Tuple []));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.read (| γ |) in
                            let γ1_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "move_binary_format::file_format::Bytecode::BrTrue",
                                0
                              |) in
                            Value.Tuple []))
                      ],
                      fun γ =>
                        ltac:(M.monadic
                          match γ with
                          | [] => ltac:(M.monadic (M.alloc (| Value.Bool true |)))
                          | _ => M.impossible "wrong number of arguments"
                          end)
                    |)));
                fun γ => ltac:(M.monadic (M.alloc (| Value.Bool false |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_is_conditional_branch :
      M.IsAssociatedFunction.C Self "is_conditional_branch" is_conditional_branch.
    Admitted.
    Global Typeclasses Opaque is_conditional_branch.
    
    (*
        pub fn is_branch(&self) -> bool {
            self.is_conditional_branch() || self.is_unconditional_branch()
        }
    *)
    Definition is_branch (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          LogicalOp.or (|
            M.call_closure (|
              Ty.path "bool",
              M.get_associated_function (|
                Ty.path "move_binary_format::file_format::Bytecode",
                "is_conditional_branch",
                [],
                []
              |),
              [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
            |),
            ltac:(M.monadic
              (M.call_closure (|
                Ty.path "bool",
                M.get_associated_function (|
                  Ty.path "move_binary_format::file_format::Bytecode",
                  "is_unconditional_branch",
                  [],
                  []
                |),
                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_is_branch :
      M.IsAssociatedFunction.C Self "is_branch" is_branch.
    Admitted.
    Global Typeclasses Opaque is_branch.
    
    (*
        pub fn offset(&self) -> Option<&CodeOffset> {
            match self {
                Bytecode::BrFalse(offset) | Bytecode::BrTrue(offset) | Bytecode::Branch(offset) => {
                    Some(offset)
                }
                _ => None,
            }
        }
    *)
    Definition offset (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Ty.apply
                (Ty.path "*")
                []
                [
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [ Ty.apply (Ty.path "&") [] [ Ty.path "u16" ] ]
                ],
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.find_or_pattern (Ty.tuple [ Ty.apply (Ty.path "&") [] [ Ty.path "u16" ] ]) (|
                      γ,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.read (| γ |) in
                            let γ1_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "move_binary_format::file_format::Bytecode::BrFalse",
                                0
                              |) in
                            let offset := M.alloc (| γ1_0 |) in
                            Value.Tuple [ offset ]));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.read (| γ |) in
                            let γ1_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "move_binary_format::file_format::Bytecode::BrTrue",
                                0
                              |) in
                            let offset := M.alloc (| γ1_0 |) in
                            Value.Tuple [ offset ]));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.read (| γ |) in
                            let γ1_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "move_binary_format::file_format::Bytecode::Branch",
                                0
                              |) in
                            let offset := M.alloc (| γ1_0 |) in
                            Value.Tuple [ offset ]))
                      ],
                      fun γ =>
                        ltac:(M.monadic
                          match γ with
                          | [ offset ] =>
                            ltac:(M.monadic
                              (M.alloc (|
                                Value.StructTuple
                                  "core::option::Option::Some"
                                  []
                                  [ Ty.apply (Ty.path "&") [] [ Ty.path "u16" ] ]
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (| M.read (| offset |) |)
                                    |)
                                  ]
                              |)))
                          | _ => M.impossible "wrong number of arguments"
                          end)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.StructTuple
                        "core::option::Option::None"
                        []
                        [ Ty.apply (Ty.path "&") [] [ Ty.path "u16" ] ]
                        []
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_offset : M.IsAssociatedFunction.C Self "offset" offset.
    Admitted.
    Global Typeclasses Opaque offset.
    
    (*
        pub fn get_successors(pc: CodeOffset, code: &[Bytecode]) -> Vec<CodeOffset> {
            assert!(
                // The program counter must remain within the bounds of the code
                pc < u16::MAX && (pc as usize) < code.len(),
                "Program counter out of bounds"
            );
    
            let bytecode = &code[pc as usize];
            let mut v = vec![];
    
            if let Some(offset) = bytecode.offset() {
                v.push( *offset);
            }
    
            let next_pc = pc + 1;
            if next_pc >= code.len() as CodeOffset {
                return v;
            }
    
            if !bytecode.is_unconditional_branch() && !v.contains(&next_pc) {
                // avoid duplicates
                v.push(pc + 1);
            }
    
            // always give successors in ascending order
            if v.len() > 1 && v[0] > v[1] {
                v.swap(0, 1);
            }
    
            v
        }
    *)
    Definition get_successors (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ pc; code ] =>
        ltac:(M.monadic
          (let pc := M.alloc (| pc |) in
          let code := M.alloc (| code |) in
          M.catch_return
            (Ty.apply
              (Ty.path "alloc::vec::Vec")
              []
              [ Ty.path "u16"; Ty.path "alloc::alloc::Global" ]) (|
            ltac:(M.monadic
              (M.read (|
                let~ _ : Ty.tuple [] :=
                  M.read (|
                    M.match_operator (|
                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  UnOp.not (|
                                    LogicalOp.and (|
                                      M.call_closure (|
                                        Ty.path "bool",
                                        BinOp.lt,
                                        [
                                          M.read (| pc |);
                                          M.read (|
                                            get_associated_constant (|
                                              Ty.path "u16",
                                              "MAX",
                                              Ty.path "u16"
                                            |)
                                          |)
                                        ]
                                      |),
                                      ltac:(M.monadic
                                        (M.call_closure (|
                                          Ty.path "bool",
                                          BinOp.lt,
                                          [
                                            M.cast (Ty.path "usize") (M.read (| pc |));
                                            M.call_closure (|
                                              Ty.path "usize",
                                              M.get_associated_function (|
                                                Ty.apply
                                                  (Ty.path "slice")
                                                  []
                                                  [
                                                    Ty.path
                                                      "move_binary_format::file_format::Bytecode"
                                                  ],
                                                "len",
                                                [],
                                                []
                                              |),
                                              [
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (| M.read (| code |) |)
                                                |)
                                              ]
                                            |)
                                          ]
                                        |)))
                                    |)
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.call_closure (|
                                  Ty.path "never",
                                  M.get_function (| "core::panicking::panic_fmt", [], [] |),
                                  [
                                    M.call_closure (|
                                      Ty.path "core::fmt::Arguments",
                                      M.get_associated_function (|
                                        Ty.path "core::fmt::Arguments",
                                        "new_const",
                                        [ Value.Integer IntegerKind.Usize 1 ],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (|
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.alloc (|
                                                Value.Array
                                                  [ mk_str (| "Program counter out of bounds" |) ]
                                              |)
                                            |)
                                          |)
                                        |)
                                      ]
                                    |)
                                  ]
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |)
                  |) in
                let~ bytecode :
                    Ty.apply
                      (Ty.path "&")
                      []
                      [ Ty.path "move_binary_format::file_format::Bytecode" ] :=
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_array_field (|
                      M.deref (| M.read (| code |) |),
                      M.cast (Ty.path "usize") (M.read (| pc |))
                    |)
                  |) in
                let~ v :
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      []
                      [ Ty.path "u16"; Ty.path "alloc::alloc::Global" ] :=
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      []
                      [ Ty.path "u16"; Ty.path "alloc::alloc::Global" ],
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        []
                        [ Ty.path "u16"; Ty.path "alloc::alloc::Global" ],
                      "new",
                      [],
                      []
                    |),
                    []
                  |) in
                let~ _ : Ty.tuple [] :=
                  M.read (|
                    M.match_operator (|
                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.alloc (|
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "core::option::Option")
                                    []
                                    [ Ty.apply (Ty.path "&") [] [ Ty.path "u16" ] ],
                                  M.get_associated_function (|
                                    Ty.path "move_binary_format::file_format::Bytecode",
                                    "offset",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (| M.read (| bytecode |) |)
                                    |)
                                  ]
                                |)
                              |) in
                            let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::option::Option::Some",
                                0
                              |) in
                            let offset := M.copy (| γ0_0 |) in
                            let~ _ : Ty.tuple [] :=
                              M.call_closure (|
                                Ty.tuple [],
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "alloc::vec::Vec")
                                    []
                                    [ Ty.path "u16"; Ty.path "alloc::alloc::Global" ],
                                  "push",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (| Pointer.Kind.MutRef, v |);
                                  M.read (| M.deref (| M.read (| offset |) |) |)
                                ]
                              |) in
                            M.alloc (| Value.Tuple [] |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |)
                  |) in
                let~ next_pc : Ty.path "u16" :=
                  M.call_closure (|
                    Ty.path "u16",
                    BinOp.Wrap.add,
                    [ M.read (| pc |); Value.Integer IntegerKind.U16 1 ]
                  |) in
                let~ _ : Ty.tuple [] :=
                  M.read (|
                    M.match_operator (|
                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    Ty.path "bool",
                                    BinOp.ge,
                                    [
                                      M.read (| next_pc |);
                                      M.cast
                                        (Ty.path "u16")
                                        (M.call_closure (|
                                          Ty.path "usize",
                                          M.get_associated_function (|
                                            Ty.apply
                                              (Ty.path "slice")
                                              []
                                              [ Ty.path "move_binary_format::file_format::Bytecode"
                                              ],
                                            "len",
                                            [],
                                            []
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (| M.read (| code |) |)
                                            |)
                                          ]
                                        |))
                                    ]
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (| M.read (| M.return_ (| M.read (| v |) |) |) |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |)
                  |) in
                let~ _ : Ty.tuple [] :=
                  M.read (|
                    M.match_operator (|
                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  LogicalOp.and (|
                                    UnOp.not (|
                                      M.call_closure (|
                                        Ty.path "bool",
                                        M.get_associated_function (|
                                          Ty.path "move_binary_format::file_format::Bytecode",
                                          "is_unconditional_branch",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (| M.read (| bytecode |) |)
                                          |)
                                        ]
                                      |)
                                    |),
                                    ltac:(M.monadic
                                      (UnOp.not (|
                                        M.call_closure (|
                                          Ty.path "bool",
                                          M.get_associated_function (|
                                            Ty.apply (Ty.path "slice") [] [ Ty.path "u16" ],
                                            "contains",
                                            [],
                                            []
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.call_closure (|
                                                  Ty.apply
                                                    (Ty.path "&")
                                                    []
                                                    [
                                                      Ty.apply
                                                        (Ty.path "slice")
                                                        []
                                                        [ Ty.path "u16" ]
                                                    ],
                                                  M.get_trait_method (|
                                                    "core::ops::deref::Deref",
                                                    Ty.apply
                                                      (Ty.path "alloc::vec::Vec")
                                                      []
                                                      [
                                                        Ty.path "u16";
                                                        Ty.path "alloc::alloc::Global"
                                                      ],
                                                    [],
                                                    [],
                                                    "deref",
                                                    [],
                                                    []
                                                  |),
                                                  [ M.borrow (| Pointer.Kind.Ref, v |) ]
                                                |)
                                              |)
                                            |);
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (| M.borrow (| Pointer.Kind.Ref, next_pc |) |)
                                            |)
                                          ]
                                        |)
                                      |)))
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            let~ _ : Ty.tuple [] :=
                              M.call_closure (|
                                Ty.tuple [],
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "alloc::vec::Vec")
                                    []
                                    [ Ty.path "u16"; Ty.path "alloc::alloc::Global" ],
                                  "push",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (| Pointer.Kind.MutRef, v |);
                                  M.call_closure (|
                                    Ty.path "u16",
                                    BinOp.Wrap.add,
                                    [ M.read (| pc |); Value.Integer IntegerKind.U16 1 ]
                                  |)
                                ]
                              |) in
                            M.alloc (| Value.Tuple [] |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |)
                  |) in
                let~ _ : Ty.tuple [] :=
                  M.read (|
                    M.match_operator (|
                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  LogicalOp.and (|
                                    M.call_closure (|
                                      Ty.path "bool",
                                      BinOp.gt,
                                      [
                                        M.call_closure (|
                                          Ty.path "usize",
                                          M.get_associated_function (|
                                            Ty.apply
                                              (Ty.path "alloc::vec::Vec")
                                              []
                                              [ Ty.path "u16"; Ty.path "alloc::alloc::Global" ],
                                            "len",
                                            [],
                                            []
                                          |),
                                          [ M.borrow (| Pointer.Kind.Ref, v |) ]
                                        |);
                                        Value.Integer IntegerKind.Usize 1
                                      ]
                                    |),
                                    ltac:(M.monadic
                                      (M.call_closure (|
                                        Ty.path "bool",
                                        BinOp.gt,
                                        [
                                          M.read (|
                                            M.deref (|
                                              M.call_closure (|
                                                Ty.apply (Ty.path "&") [] [ Ty.path "u16" ],
                                                M.get_trait_method (|
                                                  "core::ops::index::Index",
                                                  Ty.apply
                                                    (Ty.path "alloc::vec::Vec")
                                                    []
                                                    [ Ty.path "u16"; Ty.path "alloc::alloc::Global"
                                                    ],
                                                  [],
                                                  [ Ty.path "usize" ],
                                                  "index",
                                                  [],
                                                  []
                                                |),
                                                [
                                                  M.borrow (| Pointer.Kind.Ref, v |);
                                                  Value.Integer IntegerKind.Usize 0
                                                ]
                                              |)
                                            |)
                                          |);
                                          M.read (|
                                            M.deref (|
                                              M.call_closure (|
                                                Ty.apply (Ty.path "&") [] [ Ty.path "u16" ],
                                                M.get_trait_method (|
                                                  "core::ops::index::Index",
                                                  Ty.apply
                                                    (Ty.path "alloc::vec::Vec")
                                                    []
                                                    [ Ty.path "u16"; Ty.path "alloc::alloc::Global"
                                                    ],
                                                  [],
                                                  [ Ty.path "usize" ],
                                                  "index",
                                                  [],
                                                  []
                                                |),
                                                [
                                                  M.borrow (| Pointer.Kind.Ref, v |);
                                                  Value.Integer IntegerKind.Usize 1
                                                ]
                                              |)
                                            |)
                                          |)
                                        ]
                                      |)))
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            let~ _ : Ty.tuple [] :=
                              M.call_closure (|
                                Ty.tuple [],
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "slice") [] [ Ty.path "u16" ],
                                  "swap",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.MutRef,
                                    M.deref (|
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "&mut")
                                          []
                                          [ Ty.apply (Ty.path "slice") [] [ Ty.path "u16" ] ],
                                        M.get_trait_method (|
                                          "core::ops::deref::DerefMut",
                                          Ty.apply
                                            (Ty.path "alloc::vec::Vec")
                                            []
                                            [ Ty.path "u16"; Ty.path "alloc::alloc::Global" ],
                                          [],
                                          [],
                                          "deref_mut",
                                          [],
                                          []
                                        |),
                                        [ M.borrow (| Pointer.Kind.MutRef, v |) ]
                                      |)
                                    |)
                                  |);
                                  Value.Integer IntegerKind.Usize 0;
                                  Value.Integer IntegerKind.Usize 1
                                ]
                              |) in
                            M.alloc (| Value.Tuple [] |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |)
                  |) in
                v
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_get_successors :
      M.IsAssociatedFunction.C Self "get_successors" get_successors.
    Admitted.
    Global Typeclasses Opaque get_successors.
  End Impl_move_binary_format_file_format_Bytecode.
  
  Module Impl_core_marker_StructuralPartialEq_for_move_binary_format_file_format_Bytecode.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::Bytecode".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_move_binary_format_file_format_Bytecode.
  
  Module Impl_core_cmp_PartialEq_move_binary_format_file_format_Bytecode_for_move_binary_format_file_format_Bytecode.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::Bytecode".
    
    (* PartialEq *)
    Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            let~ __self_discr : Ty.path "isize" :=
              M.call_closure (|
                Ty.path "isize",
                M.get_function (|
                  "core::intrinsics::discriminant_value",
                  [],
                  [ Ty.path "move_binary_format::file_format::Bytecode" ]
                |),
                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
              |) in
            let~ __arg1_discr : Ty.path "isize" :=
              M.call_closure (|
                Ty.path "isize",
                M.get_function (|
                  "core::intrinsics::discriminant_value",
                  [],
                  [ Ty.path "move_binary_format::file_format::Bytecode" ]
                |),
                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |) ]
              |) in
            M.alloc (|
              LogicalOp.and (|
                M.call_closure (|
                  Ty.path "bool",
                  BinOp.eq,
                  [ M.read (| __self_discr |); M.read (| __arg1_discr |) ]
                |),
                ltac:(M.monadic
                  (M.read (|
                    M.match_operator (|
                      Ty.apply (Ty.path "*") [] [ Ty.path "bool" ],
                      M.alloc (| Value.Tuple [ M.read (| self |); M.read (| other |) ] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_0,
                                "move_binary_format::file_format::Bytecode::BrTrue",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_1,
                                "move_binary_format::file_format::Bytecode::BrTrue",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.apply (Ty.path "&") [] [ Ty.path "u16" ],
                                  [],
                                  [ Ty.apply (Ty.path "&") [] [ Ty.path "u16" ] ],
                                  "eq",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (| Pointer.Kind.Ref, __self_0 |);
                                  M.borrow (| Pointer.Kind.Ref, __arg1_0 |)
                                ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_0,
                                "move_binary_format::file_format::Bytecode::BrFalse",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_1,
                                "move_binary_format::file_format::Bytecode::BrFalse",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.apply (Ty.path "&") [] [ Ty.path "u16" ],
                                  [],
                                  [ Ty.apply (Ty.path "&") [] [ Ty.path "u16" ] ],
                                  "eq",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (| Pointer.Kind.Ref, __self_0 |);
                                  M.borrow (| Pointer.Kind.Ref, __arg1_0 |)
                                ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_0,
                                "move_binary_format::file_format::Bytecode::Branch",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_1,
                                "move_binary_format::file_format::Bytecode::Branch",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.apply (Ty.path "&") [] [ Ty.path "u16" ],
                                  [],
                                  [ Ty.apply (Ty.path "&") [] [ Ty.path "u16" ] ],
                                  "eq",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (| Pointer.Kind.Ref, __self_0 |);
                                  M.borrow (| Pointer.Kind.Ref, __arg1_0 |)
                                ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_0,
                                "move_binary_format::file_format::Bytecode::LdU8",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_1,
                                "move_binary_format::file_format::Bytecode::LdU8",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.apply (Ty.path "&") [] [ Ty.path "u8" ],
                                  [],
                                  [ Ty.apply (Ty.path "&") [] [ Ty.path "u8" ] ],
                                  "eq",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (| Pointer.Kind.Ref, __self_0 |);
                                  M.borrow (| Pointer.Kind.Ref, __arg1_0 |)
                                ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_0,
                                "move_binary_format::file_format::Bytecode::LdU64",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_1,
                                "move_binary_format::file_format::Bytecode::LdU64",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.apply (Ty.path "&") [] [ Ty.path "u64" ],
                                  [],
                                  [ Ty.apply (Ty.path "&") [] [ Ty.path "u64" ] ],
                                  "eq",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (| Pointer.Kind.Ref, __self_0 |);
                                  M.borrow (| Pointer.Kind.Ref, __arg1_0 |)
                                ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_0,
                                "move_binary_format::file_format::Bytecode::LdU128",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_1,
                                "move_binary_format::file_format::Bytecode::LdU128",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.apply
                                    (Ty.path "&")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "alloc::boxed::Box")
                                        []
                                        [ Ty.path "u128"; Ty.path "alloc::alloc::Global" ]
                                    ],
                                  [],
                                  [
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "alloc::boxed::Box")
                                          []
                                          [ Ty.path "u128"; Ty.path "alloc::alloc::Global" ]
                                      ]
                                  ],
                                  "eq",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (| Pointer.Kind.Ref, __self_0 |);
                                  M.borrow (| Pointer.Kind.Ref, __arg1_0 |)
                                ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_0,
                                "move_binary_format::file_format::Bytecode::LdConst",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_1,
                                "move_binary_format::file_format::Bytecode::LdConst",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.apply
                                    (Ty.path "&")
                                    []
                                    [ Ty.path "move_binary_format::file_format::ConstantPoolIndex"
                                    ],
                                  [],
                                  [
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [ Ty.path "move_binary_format::file_format::ConstantPoolIndex"
                                      ]
                                  ],
                                  "eq",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (| Pointer.Kind.Ref, __self_0 |);
                                  M.borrow (| Pointer.Kind.Ref, __arg1_0 |)
                                ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_0,
                                "move_binary_format::file_format::Bytecode::CopyLoc",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_1,
                                "move_binary_format::file_format::Bytecode::CopyLoc",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.apply (Ty.path "&") [] [ Ty.path "u8" ],
                                  [],
                                  [ Ty.apply (Ty.path "&") [] [ Ty.path "u8" ] ],
                                  "eq",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (| Pointer.Kind.Ref, __self_0 |);
                                  M.borrow (| Pointer.Kind.Ref, __arg1_0 |)
                                ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_0,
                                "move_binary_format::file_format::Bytecode::MoveLoc",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_1,
                                "move_binary_format::file_format::Bytecode::MoveLoc",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.apply (Ty.path "&") [] [ Ty.path "u8" ],
                                  [],
                                  [ Ty.apply (Ty.path "&") [] [ Ty.path "u8" ] ],
                                  "eq",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (| Pointer.Kind.Ref, __self_0 |);
                                  M.borrow (| Pointer.Kind.Ref, __arg1_0 |)
                                ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_0,
                                "move_binary_format::file_format::Bytecode::StLoc",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_1,
                                "move_binary_format::file_format::Bytecode::StLoc",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.apply (Ty.path "&") [] [ Ty.path "u8" ],
                                  [],
                                  [ Ty.apply (Ty.path "&") [] [ Ty.path "u8" ] ],
                                  "eq",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (| Pointer.Kind.Ref, __self_0 |);
                                  M.borrow (| Pointer.Kind.Ref, __arg1_0 |)
                                ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_0,
                                "move_binary_format::file_format::Bytecode::Call",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_1,
                                "move_binary_format::file_format::Bytecode::Call",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.apply
                                    (Ty.path "&")
                                    []
                                    [ Ty.path "move_binary_format::file_format::FunctionHandleIndex"
                                    ],
                                  [],
                                  [
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [
                                        Ty.path
                                          "move_binary_format::file_format::FunctionHandleIndex"
                                      ]
                                  ],
                                  "eq",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (| Pointer.Kind.Ref, __self_0 |);
                                  M.borrow (| Pointer.Kind.Ref, __arg1_0 |)
                                ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_0,
                                "move_binary_format::file_format::Bytecode::CallGeneric",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_1,
                                "move_binary_format::file_format::Bytecode::CallGeneric",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.apply
                                    (Ty.path "&")
                                    []
                                    [
                                      Ty.path
                                        "move_binary_format::file_format::FunctionInstantiationIndex"
                                    ],
                                  [],
                                  [
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [
                                        Ty.path
                                          "move_binary_format::file_format::FunctionInstantiationIndex"
                                      ]
                                  ],
                                  "eq",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (| Pointer.Kind.Ref, __self_0 |);
                                  M.borrow (| Pointer.Kind.Ref, __arg1_0 |)
                                ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_0,
                                "move_binary_format::file_format::Bytecode::Pack",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_1,
                                "move_binary_format::file_format::Bytecode::Pack",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.apply
                                    (Ty.path "&")
                                    []
                                    [
                                      Ty.path
                                        "move_binary_format::file_format::StructDefinitionIndex"
                                    ],
                                  [],
                                  [
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [
                                        Ty.path
                                          "move_binary_format::file_format::StructDefinitionIndex"
                                      ]
                                  ],
                                  "eq",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (| Pointer.Kind.Ref, __self_0 |);
                                  M.borrow (| Pointer.Kind.Ref, __arg1_0 |)
                                ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_0,
                                "move_binary_format::file_format::Bytecode::PackGeneric",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_1,
                                "move_binary_format::file_format::Bytecode::PackGeneric",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.apply
                                    (Ty.path "&")
                                    []
                                    [
                                      Ty.path
                                        "move_binary_format::file_format::StructDefInstantiationIndex"
                                    ],
                                  [],
                                  [
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [
                                        Ty.path
                                          "move_binary_format::file_format::StructDefInstantiationIndex"
                                      ]
                                  ],
                                  "eq",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (| Pointer.Kind.Ref, __self_0 |);
                                  M.borrow (| Pointer.Kind.Ref, __arg1_0 |)
                                ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_0,
                                "move_binary_format::file_format::Bytecode::Unpack",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_1,
                                "move_binary_format::file_format::Bytecode::Unpack",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.apply
                                    (Ty.path "&")
                                    []
                                    [
                                      Ty.path
                                        "move_binary_format::file_format::StructDefinitionIndex"
                                    ],
                                  [],
                                  [
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [
                                        Ty.path
                                          "move_binary_format::file_format::StructDefinitionIndex"
                                      ]
                                  ],
                                  "eq",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (| Pointer.Kind.Ref, __self_0 |);
                                  M.borrow (| Pointer.Kind.Ref, __arg1_0 |)
                                ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_0,
                                "move_binary_format::file_format::Bytecode::UnpackGeneric",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_1,
                                "move_binary_format::file_format::Bytecode::UnpackGeneric",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.apply
                                    (Ty.path "&")
                                    []
                                    [
                                      Ty.path
                                        "move_binary_format::file_format::StructDefInstantiationIndex"
                                    ],
                                  [],
                                  [
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [
                                        Ty.path
                                          "move_binary_format::file_format::StructDefInstantiationIndex"
                                      ]
                                  ],
                                  "eq",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (| Pointer.Kind.Ref, __self_0 |);
                                  M.borrow (| Pointer.Kind.Ref, __arg1_0 |)
                                ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_0,
                                "move_binary_format::file_format::Bytecode::MutBorrowLoc",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_1,
                                "move_binary_format::file_format::Bytecode::MutBorrowLoc",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.apply (Ty.path "&") [] [ Ty.path "u8" ],
                                  [],
                                  [ Ty.apply (Ty.path "&") [] [ Ty.path "u8" ] ],
                                  "eq",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (| Pointer.Kind.Ref, __self_0 |);
                                  M.borrow (| Pointer.Kind.Ref, __arg1_0 |)
                                ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_0,
                                "move_binary_format::file_format::Bytecode::ImmBorrowLoc",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_1,
                                "move_binary_format::file_format::Bytecode::ImmBorrowLoc",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.apply (Ty.path "&") [] [ Ty.path "u8" ],
                                  [],
                                  [ Ty.apply (Ty.path "&") [] [ Ty.path "u8" ] ],
                                  "eq",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (| Pointer.Kind.Ref, __self_0 |);
                                  M.borrow (| Pointer.Kind.Ref, __arg1_0 |)
                                ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_0,
                                "move_binary_format::file_format::Bytecode::MutBorrowField",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_1,
                                "move_binary_format::file_format::Bytecode::MutBorrowField",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.apply
                                    (Ty.path "&")
                                    []
                                    [ Ty.path "move_binary_format::file_format::FieldHandleIndex" ],
                                  [],
                                  [
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [ Ty.path "move_binary_format::file_format::FieldHandleIndex"
                                      ]
                                  ],
                                  "eq",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (| Pointer.Kind.Ref, __self_0 |);
                                  M.borrow (| Pointer.Kind.Ref, __arg1_0 |)
                                ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_0,
                                "move_binary_format::file_format::Bytecode::MutBorrowFieldGeneric",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_1,
                                "move_binary_format::file_format::Bytecode::MutBorrowFieldGeneric",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.apply
                                    (Ty.path "&")
                                    []
                                    [
                                      Ty.path
                                        "move_binary_format::file_format::FieldInstantiationIndex"
                                    ],
                                  [],
                                  [
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [
                                        Ty.path
                                          "move_binary_format::file_format::FieldInstantiationIndex"
                                      ]
                                  ],
                                  "eq",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (| Pointer.Kind.Ref, __self_0 |);
                                  M.borrow (| Pointer.Kind.Ref, __arg1_0 |)
                                ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_0,
                                "move_binary_format::file_format::Bytecode::ImmBorrowField",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_1,
                                "move_binary_format::file_format::Bytecode::ImmBorrowField",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.apply
                                    (Ty.path "&")
                                    []
                                    [ Ty.path "move_binary_format::file_format::FieldHandleIndex" ],
                                  [],
                                  [
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [ Ty.path "move_binary_format::file_format::FieldHandleIndex"
                                      ]
                                  ],
                                  "eq",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (| Pointer.Kind.Ref, __self_0 |);
                                  M.borrow (| Pointer.Kind.Ref, __arg1_0 |)
                                ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_0,
                                "move_binary_format::file_format::Bytecode::ImmBorrowFieldGeneric",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_1,
                                "move_binary_format::file_format::Bytecode::ImmBorrowFieldGeneric",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.apply
                                    (Ty.path "&")
                                    []
                                    [
                                      Ty.path
                                        "move_binary_format::file_format::FieldInstantiationIndex"
                                    ],
                                  [],
                                  [
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [
                                        Ty.path
                                          "move_binary_format::file_format::FieldInstantiationIndex"
                                      ]
                                  ],
                                  "eq",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (| Pointer.Kind.Ref, __self_0 |);
                                  M.borrow (| Pointer.Kind.Ref, __arg1_0 |)
                                ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_0,
                                "move_binary_format::file_format::Bytecode::VecPack",
                                0
                              |) in
                            let γ2_1 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_0,
                                "move_binary_format::file_format::Bytecode::VecPack",
                                1
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let __self_1 := M.alloc (| γ2_1 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_1,
                                "move_binary_format::file_format::Bytecode::VecPack",
                                0
                              |) in
                            let γ2_1 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_1,
                                "move_binary_format::file_format::Bytecode::VecPack",
                                1
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            let __arg1_1 := M.alloc (| γ2_1 |) in
                            M.alloc (|
                              LogicalOp.and (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  M.get_trait_method (|
                                    "core::cmp::PartialEq",
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [ Ty.path "move_binary_format::file_format::SignatureIndex" ],
                                    [],
                                    [
                                      Ty.apply
                                        (Ty.path "&")
                                        []
                                        [ Ty.path "move_binary_format::file_format::SignatureIndex"
                                        ]
                                    ],
                                    "eq",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (| Pointer.Kind.Ref, __self_0 |);
                                    M.borrow (| Pointer.Kind.Ref, __arg1_0 |)
                                  ]
                                |),
                                ltac:(M.monadic
                                  (M.call_closure (|
                                    Ty.path "bool",
                                    M.get_trait_method (|
                                      "core::cmp::PartialEq",
                                      Ty.apply (Ty.path "&") [] [ Ty.path "u64" ],
                                      [],
                                      [ Ty.apply (Ty.path "&") [] [ Ty.path "u64" ] ],
                                      "eq",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (| Pointer.Kind.Ref, __self_1 |);
                                      M.borrow (| Pointer.Kind.Ref, __arg1_1 |)
                                    ]
                                  |)))
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_0,
                                "move_binary_format::file_format::Bytecode::VecLen",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_1,
                                "move_binary_format::file_format::Bytecode::VecLen",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.apply
                                    (Ty.path "&")
                                    []
                                    [ Ty.path "move_binary_format::file_format::SignatureIndex" ],
                                  [],
                                  [
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [ Ty.path "move_binary_format::file_format::SignatureIndex" ]
                                  ],
                                  "eq",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (| Pointer.Kind.Ref, __self_0 |);
                                  M.borrow (| Pointer.Kind.Ref, __arg1_0 |)
                                ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_0,
                                "move_binary_format::file_format::Bytecode::VecImmBorrow",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_1,
                                "move_binary_format::file_format::Bytecode::VecImmBorrow",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.apply
                                    (Ty.path "&")
                                    []
                                    [ Ty.path "move_binary_format::file_format::SignatureIndex" ],
                                  [],
                                  [
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [ Ty.path "move_binary_format::file_format::SignatureIndex" ]
                                  ],
                                  "eq",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (| Pointer.Kind.Ref, __self_0 |);
                                  M.borrow (| Pointer.Kind.Ref, __arg1_0 |)
                                ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_0,
                                "move_binary_format::file_format::Bytecode::VecMutBorrow",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_1,
                                "move_binary_format::file_format::Bytecode::VecMutBorrow",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.apply
                                    (Ty.path "&")
                                    []
                                    [ Ty.path "move_binary_format::file_format::SignatureIndex" ],
                                  [],
                                  [
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [ Ty.path "move_binary_format::file_format::SignatureIndex" ]
                                  ],
                                  "eq",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (| Pointer.Kind.Ref, __self_0 |);
                                  M.borrow (| Pointer.Kind.Ref, __arg1_0 |)
                                ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_0,
                                "move_binary_format::file_format::Bytecode::VecPushBack",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_1,
                                "move_binary_format::file_format::Bytecode::VecPushBack",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.apply
                                    (Ty.path "&")
                                    []
                                    [ Ty.path "move_binary_format::file_format::SignatureIndex" ],
                                  [],
                                  [
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [ Ty.path "move_binary_format::file_format::SignatureIndex" ]
                                  ],
                                  "eq",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (| Pointer.Kind.Ref, __self_0 |);
                                  M.borrow (| Pointer.Kind.Ref, __arg1_0 |)
                                ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_0,
                                "move_binary_format::file_format::Bytecode::VecPopBack",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_1,
                                "move_binary_format::file_format::Bytecode::VecPopBack",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.apply
                                    (Ty.path "&")
                                    []
                                    [ Ty.path "move_binary_format::file_format::SignatureIndex" ],
                                  [],
                                  [
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [ Ty.path "move_binary_format::file_format::SignatureIndex" ]
                                  ],
                                  "eq",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (| Pointer.Kind.Ref, __self_0 |);
                                  M.borrow (| Pointer.Kind.Ref, __arg1_0 |)
                                ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_0,
                                "move_binary_format::file_format::Bytecode::VecUnpack",
                                0
                              |) in
                            let γ2_1 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_0,
                                "move_binary_format::file_format::Bytecode::VecUnpack",
                                1
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let __self_1 := M.alloc (| γ2_1 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_1,
                                "move_binary_format::file_format::Bytecode::VecUnpack",
                                0
                              |) in
                            let γ2_1 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_1,
                                "move_binary_format::file_format::Bytecode::VecUnpack",
                                1
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            let __arg1_1 := M.alloc (| γ2_1 |) in
                            M.alloc (|
                              LogicalOp.and (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  M.get_trait_method (|
                                    "core::cmp::PartialEq",
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [ Ty.path "move_binary_format::file_format::SignatureIndex" ],
                                    [],
                                    [
                                      Ty.apply
                                        (Ty.path "&")
                                        []
                                        [ Ty.path "move_binary_format::file_format::SignatureIndex"
                                        ]
                                    ],
                                    "eq",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (| Pointer.Kind.Ref, __self_0 |);
                                    M.borrow (| Pointer.Kind.Ref, __arg1_0 |)
                                  ]
                                |),
                                ltac:(M.monadic
                                  (M.call_closure (|
                                    Ty.path "bool",
                                    M.get_trait_method (|
                                      "core::cmp::PartialEq",
                                      Ty.apply (Ty.path "&") [] [ Ty.path "u64" ],
                                      [],
                                      [ Ty.apply (Ty.path "&") [] [ Ty.path "u64" ] ],
                                      "eq",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (| Pointer.Kind.Ref, __self_1 |);
                                      M.borrow (| Pointer.Kind.Ref, __arg1_1 |)
                                    ]
                                  |)))
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_0,
                                "move_binary_format::file_format::Bytecode::VecSwap",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_1,
                                "move_binary_format::file_format::Bytecode::VecSwap",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.apply
                                    (Ty.path "&")
                                    []
                                    [ Ty.path "move_binary_format::file_format::SignatureIndex" ],
                                  [],
                                  [
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [ Ty.path "move_binary_format::file_format::SignatureIndex" ]
                                  ],
                                  "eq",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (| Pointer.Kind.Ref, __self_0 |);
                                  M.borrow (| Pointer.Kind.Ref, __arg1_0 |)
                                ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_0,
                                "move_binary_format::file_format::Bytecode::LdU16",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_1,
                                "move_binary_format::file_format::Bytecode::LdU16",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.apply (Ty.path "&") [] [ Ty.path "u16" ],
                                  [],
                                  [ Ty.apply (Ty.path "&") [] [ Ty.path "u16" ] ],
                                  "eq",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (| Pointer.Kind.Ref, __self_0 |);
                                  M.borrow (| Pointer.Kind.Ref, __arg1_0 |)
                                ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_0,
                                "move_binary_format::file_format::Bytecode::LdU32",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_1,
                                "move_binary_format::file_format::Bytecode::LdU32",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.apply (Ty.path "&") [] [ Ty.path "u32" ],
                                  [],
                                  [ Ty.apply (Ty.path "&") [] [ Ty.path "u32" ] ],
                                  "eq",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (| Pointer.Kind.Ref, __self_0 |);
                                  M.borrow (| Pointer.Kind.Ref, __arg1_0 |)
                                ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_0,
                                "move_binary_format::file_format::Bytecode::LdU256",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_1,
                                "move_binary_format::file_format::Bytecode::LdU256",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.apply
                                    (Ty.path "&")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "alloc::boxed::Box")
                                        []
                                        [
                                          Ty.path "move_core_types::u256::U256";
                                          Ty.path "alloc::alloc::Global"
                                        ]
                                    ],
                                  [],
                                  [
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "alloc::boxed::Box")
                                          []
                                          [
                                            Ty.path "move_core_types::u256::U256";
                                            Ty.path "alloc::alloc::Global"
                                          ]
                                      ]
                                  ],
                                  "eq",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (| Pointer.Kind.Ref, __self_0 |);
                                  M.borrow (| Pointer.Kind.Ref, __arg1_0 |)
                                ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_0,
                                "move_binary_format::file_format::Bytecode::ExistsDeprecated",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_1,
                                "move_binary_format::file_format::Bytecode::ExistsDeprecated",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.apply
                                    (Ty.path "&")
                                    []
                                    [
                                      Ty.path
                                        "move_binary_format::file_format::StructDefinitionIndex"
                                    ],
                                  [],
                                  [
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [
                                        Ty.path
                                          "move_binary_format::file_format::StructDefinitionIndex"
                                      ]
                                  ],
                                  "eq",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (| Pointer.Kind.Ref, __self_0 |);
                                  M.borrow (| Pointer.Kind.Ref, __arg1_0 |)
                                ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_0,
                                "move_binary_format::file_format::Bytecode::ExistsGenericDeprecated",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_1,
                                "move_binary_format::file_format::Bytecode::ExistsGenericDeprecated",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.apply
                                    (Ty.path "&")
                                    []
                                    [
                                      Ty.path
                                        "move_binary_format::file_format::StructDefInstantiationIndex"
                                    ],
                                  [],
                                  [
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [
                                        Ty.path
                                          "move_binary_format::file_format::StructDefInstantiationIndex"
                                      ]
                                  ],
                                  "eq",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (| Pointer.Kind.Ref, __self_0 |);
                                  M.borrow (| Pointer.Kind.Ref, __arg1_0 |)
                                ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_0,
                                "move_binary_format::file_format::Bytecode::MoveFromDeprecated",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_1,
                                "move_binary_format::file_format::Bytecode::MoveFromDeprecated",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.apply
                                    (Ty.path "&")
                                    []
                                    [
                                      Ty.path
                                        "move_binary_format::file_format::StructDefinitionIndex"
                                    ],
                                  [],
                                  [
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [
                                        Ty.path
                                          "move_binary_format::file_format::StructDefinitionIndex"
                                      ]
                                  ],
                                  "eq",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (| Pointer.Kind.Ref, __self_0 |);
                                  M.borrow (| Pointer.Kind.Ref, __arg1_0 |)
                                ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_0,
                                "move_binary_format::file_format::Bytecode::MoveFromGenericDeprecated",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_1,
                                "move_binary_format::file_format::Bytecode::MoveFromGenericDeprecated",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.apply
                                    (Ty.path "&")
                                    []
                                    [
                                      Ty.path
                                        "move_binary_format::file_format::StructDefInstantiationIndex"
                                    ],
                                  [],
                                  [
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [
                                        Ty.path
                                          "move_binary_format::file_format::StructDefInstantiationIndex"
                                      ]
                                  ],
                                  "eq",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (| Pointer.Kind.Ref, __self_0 |);
                                  M.borrow (| Pointer.Kind.Ref, __arg1_0 |)
                                ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_0,
                                "move_binary_format::file_format::Bytecode::MoveToDeprecated",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_1,
                                "move_binary_format::file_format::Bytecode::MoveToDeprecated",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.apply
                                    (Ty.path "&")
                                    []
                                    [
                                      Ty.path
                                        "move_binary_format::file_format::StructDefinitionIndex"
                                    ],
                                  [],
                                  [
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [
                                        Ty.path
                                          "move_binary_format::file_format::StructDefinitionIndex"
                                      ]
                                  ],
                                  "eq",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (| Pointer.Kind.Ref, __self_0 |);
                                  M.borrow (| Pointer.Kind.Ref, __arg1_0 |)
                                ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_0,
                                "move_binary_format::file_format::Bytecode::MoveToGenericDeprecated",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_1,
                                "move_binary_format::file_format::Bytecode::MoveToGenericDeprecated",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.apply
                                    (Ty.path "&")
                                    []
                                    [
                                      Ty.path
                                        "move_binary_format::file_format::StructDefInstantiationIndex"
                                    ],
                                  [],
                                  [
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [
                                        Ty.path
                                          "move_binary_format::file_format::StructDefInstantiationIndex"
                                      ]
                                  ],
                                  "eq",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (| Pointer.Kind.Ref, __self_0 |);
                                  M.borrow (| Pointer.Kind.Ref, __arg1_0 |)
                                ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_0,
                                "move_binary_format::file_format::Bytecode::MutBorrowGlobalDeprecated",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_1,
                                "move_binary_format::file_format::Bytecode::MutBorrowGlobalDeprecated",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.apply
                                    (Ty.path "&")
                                    []
                                    [
                                      Ty.path
                                        "move_binary_format::file_format::StructDefinitionIndex"
                                    ],
                                  [],
                                  [
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [
                                        Ty.path
                                          "move_binary_format::file_format::StructDefinitionIndex"
                                      ]
                                  ],
                                  "eq",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (| Pointer.Kind.Ref, __self_0 |);
                                  M.borrow (| Pointer.Kind.Ref, __arg1_0 |)
                                ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_0,
                                "move_binary_format::file_format::Bytecode::MutBorrowGlobalGenericDeprecated",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_1,
                                "move_binary_format::file_format::Bytecode::MutBorrowGlobalGenericDeprecated",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.apply
                                    (Ty.path "&")
                                    []
                                    [
                                      Ty.path
                                        "move_binary_format::file_format::StructDefInstantiationIndex"
                                    ],
                                  [],
                                  [
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [
                                        Ty.path
                                          "move_binary_format::file_format::StructDefInstantiationIndex"
                                      ]
                                  ],
                                  "eq",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (| Pointer.Kind.Ref, __self_0 |);
                                  M.borrow (| Pointer.Kind.Ref, __arg1_0 |)
                                ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_0,
                                "move_binary_format::file_format::Bytecode::ImmBorrowGlobalDeprecated",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_1,
                                "move_binary_format::file_format::Bytecode::ImmBorrowGlobalDeprecated",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.apply
                                    (Ty.path "&")
                                    []
                                    [
                                      Ty.path
                                        "move_binary_format::file_format::StructDefinitionIndex"
                                    ],
                                  [],
                                  [
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [
                                        Ty.path
                                          "move_binary_format::file_format::StructDefinitionIndex"
                                      ]
                                  ],
                                  "eq",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (| Pointer.Kind.Ref, __self_0 |);
                                  M.borrow (| Pointer.Kind.Ref, __arg1_0 |)
                                ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_0,
                                "move_binary_format::file_format::Bytecode::ImmBorrowGlobalGenericDeprecated",
                                0
                              |) in
                            let __self_0 := M.alloc (| γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_1,
                                "move_binary_format::file_format::Bytecode::ImmBorrowGlobalGenericDeprecated",
                                0
                              |) in
                            let __arg1_0 := M.alloc (| γ2_0 |) in
                            M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.apply
                                    (Ty.path "&")
                                    []
                                    [
                                      Ty.path
                                        "move_binary_format::file_format::StructDefInstantiationIndex"
                                    ],
                                  [],
                                  [
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [
                                        Ty.path
                                          "move_binary_format::file_format::StructDefInstantiationIndex"
                                      ]
                                  ],
                                  "eq",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (| Pointer.Kind.Ref, __self_0 |);
                                  M.borrow (| Pointer.Kind.Ref, __arg1_0 |)
                                ]
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Bool true |)))
                      ]
                    |)
                  |)))
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "move_binary_format::file_format::Bytecode" ]
        Self
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_move_binary_format_file_format_Bytecode_for_move_binary_format_file_format_Bytecode.
  
  Module Impl_core_fmt_Debug_for_move_binary_format_file_format_Bytecode.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::Bytecode".
    
    (*
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match self {
                Bytecode::Pop => write!(f, "Pop"),
                Bytecode::Ret => write!(f, "Ret"),
                Bytecode::BrTrue(a) => write!(f, "BrTrue({})", a),
                Bytecode::BrFalse(a) => write!(f, "BrFalse({})", a),
                Bytecode::Branch(a) => write!(f, "Branch({})", a),
                Bytecode::LdU8(a) => write!(f, "LdU8({})", a),
                Bytecode::LdU16(a) => write!(f, "LdU16({})", a),
                Bytecode::LdU32(a) => write!(f, "LdU32({})", a),
                Bytecode::LdU64(a) => write!(f, "LdU64({})", a),
                Bytecode::LdU128(a) => write!(f, "LdU128({})", a),
                Bytecode::LdU256(a) => write!(f, "LdU256({})", a),
                Bytecode::CastU8 => write!(f, "CastU8"),
                Bytecode::CastU16 => write!(f, "CastU16"),
                Bytecode::CastU32 => write!(f, "CastU32"),
                Bytecode::CastU64 => write!(f, "CastU64"),
                Bytecode::CastU128 => write!(f, "CastU128"),
                Bytecode::CastU256 => write!(f, "CastU256"),
                Bytecode::LdConst(a) => write!(f, "LdConst({})", a),
                Bytecode::LdTrue => write!(f, "LdTrue"),
                Bytecode::LdFalse => write!(f, "LdFalse"),
                Bytecode::CopyLoc(a) => write!(f, "CopyLoc({})", a),
                Bytecode::MoveLoc(a) => write!(f, "MoveLoc({})", a),
                Bytecode::StLoc(a) => write!(f, "StLoc({})", a),
                Bytecode::Call(a) => write!(f, "Call({})", a),
                Bytecode::CallGeneric(a) => write!(f, "CallGeneric({})", a),
                Bytecode::Pack(a) => write!(f, "Pack({})", a),
                Bytecode::PackGeneric(a) => write!(f, "PackGeneric({})", a),
                Bytecode::Unpack(a) => write!(f, "Unpack({})", a),
                Bytecode::UnpackGeneric(a) => write!(f, "UnpackGeneric({})", a),
                Bytecode::ReadRef => write!(f, "ReadRef"),
                Bytecode::WriteRef => write!(f, "WriteRef"),
                Bytecode::FreezeRef => write!(f, "FreezeRef"),
                Bytecode::MutBorrowLoc(a) => write!(f, "MutBorrowLoc({})", a),
                Bytecode::ImmBorrowLoc(a) => write!(f, "ImmBorrowLoc({})", a),
                Bytecode::MutBorrowField(a) => write!(f, "MutBorrowField({:?})", a),
                Bytecode::MutBorrowFieldGeneric(a) => write!(f, "MutBorrowFieldGeneric({:?})", a),
                Bytecode::ImmBorrowField(a) => write!(f, "ImmBorrowField({:?})", a),
                Bytecode::ImmBorrowFieldGeneric(a) => write!(f, "ImmBorrowFieldGeneric({:?})", a),
                Bytecode::MutBorrowGlobalDeprecated(a) => write!(f, "MutBorrowGlobal({:?})", a),
                Bytecode::MutBorrowGlobalGenericDeprecated(a) => {
                    write!(f, "MutBorrowGlobalGeneric({:?})", a)
                }
                Bytecode::ImmBorrowGlobalDeprecated(a) => write!(f, "ImmBorrowGlobal({:?})", a),
                Bytecode::ImmBorrowGlobalGenericDeprecated(a) => {
                    write!(f, "ImmBorrowGlobalGeneric({:?})", a)
                }
                Bytecode::Add => write!(f, "Add"),
                Bytecode::Sub => write!(f, "Sub"),
                Bytecode::Mul => write!(f, "Mul"),
                Bytecode::Mod => write!(f, "Mod"),
                Bytecode::Div => write!(f, "Div"),
                Bytecode::BitOr => write!(f, "BitOr"),
                Bytecode::BitAnd => write!(f, "BitAnd"),
                Bytecode::Xor => write!(f, "Xor"),
                Bytecode::Shl => write!(f, "Shl"),
                Bytecode::Shr => write!(f, "Shr"),
                Bytecode::Or => write!(f, "Or"),
                Bytecode::And => write!(f, "And"),
                Bytecode::Not => write!(f, "Not"),
                Bytecode::Eq => write!(f, "Eq"),
                Bytecode::Neq => write!(f, "Neq"),
                Bytecode::Lt => write!(f, "Lt"),
                Bytecode::Gt => write!(f, "Gt"),
                Bytecode::Le => write!(f, "Le"),
                Bytecode::Ge => write!(f, "Ge"),
                Bytecode::Abort => write!(f, "Abort"),
                Bytecode::Nop => write!(f, "Nop"),
                Bytecode::ExistsDeprecated(a) => write!(f, "Exists({:?})", a),
                Bytecode::ExistsGenericDeprecated(a) => write!(f, "ExistsGeneric({:?})", a),
                Bytecode::MoveFromDeprecated(a) => write!(f, "MoveFrom({:?})", a),
                Bytecode::MoveFromGenericDeprecated(a) => write!(f, "MoveFromGeneric({:?})", a),
                Bytecode::MoveToDeprecated(a) => write!(f, "MoveTo({:?})", a),
                Bytecode::MoveToGenericDeprecated(a) => write!(f, "MoveToGeneric({:?})", a),
                Bytecode::VecPack(a, n) => write!(f, "VecPack({}, {})", a, n),
                Bytecode::VecLen(a) => write!(f, "VecLen({})", a),
                Bytecode::VecImmBorrow(a) => write!(f, "VecImmBorrow({})", a),
                Bytecode::VecMutBorrow(a) => write!(f, "VecMutBorrow({})", a),
                Bytecode::VecPushBack(a) => write!(f, "VecPushBack({})", a),
                Bytecode::VecPopBack(a) => write!(f, "VecPopBack({})", a),
                Bytecode::VecUnpack(a, n) => write!(f, "VecUnpack({}, {})", a, n),
                Bytecode::VecSwap(a) => write!(f, "VecSwap({})", a),
            }
        }
    *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.read (|
            M.match_operator (|
              Ty.apply
                (Ty.path "*")
                []
                [
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [ Ty.tuple []; Ty.path "core::fmt::Error" ]
                ],
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (| γ, "move_binary_format::file_format::Bytecode::Pop" |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [ Value.Integer IntegerKind.Usize 1 ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (| Value.Array [ mk_str (| "Pop" |) ] |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (| γ, "move_binary_format::file_format::Bytecode::Ret" |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [ Value.Integer IntegerKind.Usize 1 ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (| Value.Array [ mk_str (| "Ret" |) ] |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::BrTrue",
                        0
                      |) in
                    let a := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_v1",
                              [ Value.Integer IntegerKind.Usize 2; Value.Integer IntegerKind.Usize 1
                              ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array [ mk_str (| "BrTrue(" |); mk_str (| ")" |) ]
                                    |)
                                  |)
                                |)
                              |);
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.call_closure (|
                                            Ty.path "core::fmt::rt::Argument",
                                            M.get_associated_function (|
                                              Ty.path "core::fmt::rt::Argument",
                                              "new_display",
                                              [],
                                              [ Ty.apply (Ty.path "&") [] [ Ty.path "u16" ] ]
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.borrow (| Pointer.Kind.Ref, a |) |)
                                              |)
                                            ]
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::BrFalse",
                        0
                      |) in
                    let a := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_v1",
                              [ Value.Integer IntegerKind.Usize 2; Value.Integer IntegerKind.Usize 1
                              ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array [ mk_str (| "BrFalse(" |); mk_str (| ")" |) ]
                                    |)
                                  |)
                                |)
                              |);
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.call_closure (|
                                            Ty.path "core::fmt::rt::Argument",
                                            M.get_associated_function (|
                                              Ty.path "core::fmt::rt::Argument",
                                              "new_display",
                                              [],
                                              [ Ty.apply (Ty.path "&") [] [ Ty.path "u16" ] ]
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.borrow (| Pointer.Kind.Ref, a |) |)
                                              |)
                                            ]
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::Branch",
                        0
                      |) in
                    let a := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_v1",
                              [ Value.Integer IntegerKind.Usize 2; Value.Integer IntegerKind.Usize 1
                              ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array [ mk_str (| "Branch(" |); mk_str (| ")" |) ]
                                    |)
                                  |)
                                |)
                              |);
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.call_closure (|
                                            Ty.path "core::fmt::rt::Argument",
                                            M.get_associated_function (|
                                              Ty.path "core::fmt::rt::Argument",
                                              "new_display",
                                              [],
                                              [ Ty.apply (Ty.path "&") [] [ Ty.path "u16" ] ]
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.borrow (| Pointer.Kind.Ref, a |) |)
                                              |)
                                            ]
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::LdU8",
                        0
                      |) in
                    let a := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_v1",
                              [ Value.Integer IntegerKind.Usize 2; Value.Integer IntegerKind.Usize 1
                              ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array [ mk_str (| "LdU8(" |); mk_str (| ")" |) ]
                                    |)
                                  |)
                                |)
                              |);
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.call_closure (|
                                            Ty.path "core::fmt::rt::Argument",
                                            M.get_associated_function (|
                                              Ty.path "core::fmt::rt::Argument",
                                              "new_display",
                                              [],
                                              [ Ty.apply (Ty.path "&") [] [ Ty.path "u8" ] ]
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.borrow (| Pointer.Kind.Ref, a |) |)
                                              |)
                                            ]
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::LdU16",
                        0
                      |) in
                    let a := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_v1",
                              [ Value.Integer IntegerKind.Usize 2; Value.Integer IntegerKind.Usize 1
                              ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array [ mk_str (| "LdU16(" |); mk_str (| ")" |) ]
                                    |)
                                  |)
                                |)
                              |);
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.call_closure (|
                                            Ty.path "core::fmt::rt::Argument",
                                            M.get_associated_function (|
                                              Ty.path "core::fmt::rt::Argument",
                                              "new_display",
                                              [],
                                              [ Ty.apply (Ty.path "&") [] [ Ty.path "u16" ] ]
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.borrow (| Pointer.Kind.Ref, a |) |)
                                              |)
                                            ]
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::LdU32",
                        0
                      |) in
                    let a := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_v1",
                              [ Value.Integer IntegerKind.Usize 2; Value.Integer IntegerKind.Usize 1
                              ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array [ mk_str (| "LdU32(" |); mk_str (| ")" |) ]
                                    |)
                                  |)
                                |)
                              |);
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.call_closure (|
                                            Ty.path "core::fmt::rt::Argument",
                                            M.get_associated_function (|
                                              Ty.path "core::fmt::rt::Argument",
                                              "new_display",
                                              [],
                                              [ Ty.apply (Ty.path "&") [] [ Ty.path "u32" ] ]
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.borrow (| Pointer.Kind.Ref, a |) |)
                                              |)
                                            ]
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::LdU64",
                        0
                      |) in
                    let a := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_v1",
                              [ Value.Integer IntegerKind.Usize 2; Value.Integer IntegerKind.Usize 1
                              ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array [ mk_str (| "LdU64(" |); mk_str (| ")" |) ]
                                    |)
                                  |)
                                |)
                              |);
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.call_closure (|
                                            Ty.path "core::fmt::rt::Argument",
                                            M.get_associated_function (|
                                              Ty.path "core::fmt::rt::Argument",
                                              "new_display",
                                              [],
                                              [ Ty.apply (Ty.path "&") [] [ Ty.path "u64" ] ]
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.borrow (| Pointer.Kind.Ref, a |) |)
                                              |)
                                            ]
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::LdU128",
                        0
                      |) in
                    let a := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_v1",
                              [ Value.Integer IntegerKind.Usize 2; Value.Integer IntegerKind.Usize 1
                              ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array [ mk_str (| "LdU128(" |); mk_str (| ")" |) ]
                                    |)
                                  |)
                                |)
                              |);
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.call_closure (|
                                            Ty.path "core::fmt::rt::Argument",
                                            M.get_associated_function (|
                                              Ty.path "core::fmt::rt::Argument",
                                              "new_display",
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "&")
                                                  []
                                                  [
                                                    Ty.apply
                                                      (Ty.path "alloc::boxed::Box")
                                                      []
                                                      [
                                                        Ty.path "u128";
                                                        Ty.path "alloc::alloc::Global"
                                                      ]
                                                  ]
                                              ]
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.borrow (| Pointer.Kind.Ref, a |) |)
                                              |)
                                            ]
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::LdU256",
                        0
                      |) in
                    let a := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_v1",
                              [ Value.Integer IntegerKind.Usize 2; Value.Integer IntegerKind.Usize 1
                              ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array [ mk_str (| "LdU256(" |); mk_str (| ")" |) ]
                                    |)
                                  |)
                                |)
                              |);
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.call_closure (|
                                            Ty.path "core::fmt::rt::Argument",
                                            M.get_associated_function (|
                                              Ty.path "core::fmt::rt::Argument",
                                              "new_display",
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "&")
                                                  []
                                                  [
                                                    Ty.apply
                                                      (Ty.path "alloc::boxed::Box")
                                                      []
                                                      [
                                                        Ty.path "move_core_types::u256::U256";
                                                        Ty.path "alloc::alloc::Global"
                                                      ]
                                                  ]
                                              ]
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.borrow (| Pointer.Kind.Ref, a |) |)
                                              |)
                                            ]
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "move_binary_format::file_format::Bytecode::CastU8"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [ Value.Integer IntegerKind.Usize 1 ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (| Value.Array [ mk_str (| "CastU8" |) ] |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "move_binary_format::file_format::Bytecode::CastU16"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [ Value.Integer IntegerKind.Usize 1 ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (| Value.Array [ mk_str (| "CastU16" |) ] |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "move_binary_format::file_format::Bytecode::CastU32"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [ Value.Integer IntegerKind.Usize 1 ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (| Value.Array [ mk_str (| "CastU32" |) ] |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "move_binary_format::file_format::Bytecode::CastU64"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [ Value.Integer IntegerKind.Usize 1 ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (| Value.Array [ mk_str (| "CastU64" |) ] |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "move_binary_format::file_format::Bytecode::CastU128"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [ Value.Integer IntegerKind.Usize 1 ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (| Value.Array [ mk_str (| "CastU128" |) ] |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "move_binary_format::file_format::Bytecode::CastU256"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [ Value.Integer IntegerKind.Usize 1 ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (| Value.Array [ mk_str (| "CastU256" |) ] |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::LdConst",
                        0
                      |) in
                    let a := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_v1",
                              [ Value.Integer IntegerKind.Usize 2; Value.Integer IntegerKind.Usize 1
                              ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array [ mk_str (| "LdConst(" |); mk_str (| ")" |) ]
                                    |)
                                  |)
                                |)
                              |);
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.call_closure (|
                                            Ty.path "core::fmt::rt::Argument",
                                            M.get_associated_function (|
                                              Ty.path "core::fmt::rt::Argument",
                                              "new_display",
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "&")
                                                  []
                                                  [
                                                    Ty.path
                                                      "move_binary_format::file_format::ConstantPoolIndex"
                                                  ]
                                              ]
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.borrow (| Pointer.Kind.Ref, a |) |)
                                              |)
                                            ]
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "move_binary_format::file_format::Bytecode::LdTrue"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [ Value.Integer IntegerKind.Usize 1 ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (| Value.Array [ mk_str (| "LdTrue" |) ] |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "move_binary_format::file_format::Bytecode::LdFalse"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [ Value.Integer IntegerKind.Usize 1 ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (| Value.Array [ mk_str (| "LdFalse" |) ] |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::CopyLoc",
                        0
                      |) in
                    let a := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_v1",
                              [ Value.Integer IntegerKind.Usize 2; Value.Integer IntegerKind.Usize 1
                              ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array [ mk_str (| "CopyLoc(" |); mk_str (| ")" |) ]
                                    |)
                                  |)
                                |)
                              |);
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.call_closure (|
                                            Ty.path "core::fmt::rt::Argument",
                                            M.get_associated_function (|
                                              Ty.path "core::fmt::rt::Argument",
                                              "new_display",
                                              [],
                                              [ Ty.apply (Ty.path "&") [] [ Ty.path "u8" ] ]
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.borrow (| Pointer.Kind.Ref, a |) |)
                                              |)
                                            ]
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::MoveLoc",
                        0
                      |) in
                    let a := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_v1",
                              [ Value.Integer IntegerKind.Usize 2; Value.Integer IntegerKind.Usize 1
                              ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array [ mk_str (| "MoveLoc(" |); mk_str (| ")" |) ]
                                    |)
                                  |)
                                |)
                              |);
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.call_closure (|
                                            Ty.path "core::fmt::rt::Argument",
                                            M.get_associated_function (|
                                              Ty.path "core::fmt::rt::Argument",
                                              "new_display",
                                              [],
                                              [ Ty.apply (Ty.path "&") [] [ Ty.path "u8" ] ]
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.borrow (| Pointer.Kind.Ref, a |) |)
                                              |)
                                            ]
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::StLoc",
                        0
                      |) in
                    let a := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_v1",
                              [ Value.Integer IntegerKind.Usize 2; Value.Integer IntegerKind.Usize 1
                              ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array [ mk_str (| "StLoc(" |); mk_str (| ")" |) ]
                                    |)
                                  |)
                                |)
                              |);
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.call_closure (|
                                            Ty.path "core::fmt::rt::Argument",
                                            M.get_associated_function (|
                                              Ty.path "core::fmt::rt::Argument",
                                              "new_display",
                                              [],
                                              [ Ty.apply (Ty.path "&") [] [ Ty.path "u8" ] ]
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.borrow (| Pointer.Kind.Ref, a |) |)
                                              |)
                                            ]
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::Call",
                        0
                      |) in
                    let a := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_v1",
                              [ Value.Integer IntegerKind.Usize 2; Value.Integer IntegerKind.Usize 1
                              ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array [ mk_str (| "Call(" |); mk_str (| ")" |) ]
                                    |)
                                  |)
                                |)
                              |);
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.call_closure (|
                                            Ty.path "core::fmt::rt::Argument",
                                            M.get_associated_function (|
                                              Ty.path "core::fmt::rt::Argument",
                                              "new_display",
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "&")
                                                  []
                                                  [
                                                    Ty.path
                                                      "move_binary_format::file_format::FunctionHandleIndex"
                                                  ]
                                              ]
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.borrow (| Pointer.Kind.Ref, a |) |)
                                              |)
                                            ]
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::CallGeneric",
                        0
                      |) in
                    let a := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_v1",
                              [ Value.Integer IntegerKind.Usize 2; Value.Integer IntegerKind.Usize 1
                              ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array [ mk_str (| "CallGeneric(" |); mk_str (| ")" |) ]
                                    |)
                                  |)
                                |)
                              |);
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.call_closure (|
                                            Ty.path "core::fmt::rt::Argument",
                                            M.get_associated_function (|
                                              Ty.path "core::fmt::rt::Argument",
                                              "new_display",
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "&")
                                                  []
                                                  [
                                                    Ty.path
                                                      "move_binary_format::file_format::FunctionInstantiationIndex"
                                                  ]
                                              ]
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.borrow (| Pointer.Kind.Ref, a |) |)
                                              |)
                                            ]
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::Pack",
                        0
                      |) in
                    let a := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_v1",
                              [ Value.Integer IntegerKind.Usize 2; Value.Integer IntegerKind.Usize 1
                              ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array [ mk_str (| "Pack(" |); mk_str (| ")" |) ]
                                    |)
                                  |)
                                |)
                              |);
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.call_closure (|
                                            Ty.path "core::fmt::rt::Argument",
                                            M.get_associated_function (|
                                              Ty.path "core::fmt::rt::Argument",
                                              "new_display",
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "&")
                                                  []
                                                  [
                                                    Ty.path
                                                      "move_binary_format::file_format::StructDefinitionIndex"
                                                  ]
                                              ]
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.borrow (| Pointer.Kind.Ref, a |) |)
                                              |)
                                            ]
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::PackGeneric",
                        0
                      |) in
                    let a := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_v1",
                              [ Value.Integer IntegerKind.Usize 2; Value.Integer IntegerKind.Usize 1
                              ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array [ mk_str (| "PackGeneric(" |); mk_str (| ")" |) ]
                                    |)
                                  |)
                                |)
                              |);
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.call_closure (|
                                            Ty.path "core::fmt::rt::Argument",
                                            M.get_associated_function (|
                                              Ty.path "core::fmt::rt::Argument",
                                              "new_display",
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "&")
                                                  []
                                                  [
                                                    Ty.path
                                                      "move_binary_format::file_format::StructDefInstantiationIndex"
                                                  ]
                                              ]
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.borrow (| Pointer.Kind.Ref, a |) |)
                                              |)
                                            ]
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::Unpack",
                        0
                      |) in
                    let a := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_v1",
                              [ Value.Integer IntegerKind.Usize 2; Value.Integer IntegerKind.Usize 1
                              ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array [ mk_str (| "Unpack(" |); mk_str (| ")" |) ]
                                    |)
                                  |)
                                |)
                              |);
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.call_closure (|
                                            Ty.path "core::fmt::rt::Argument",
                                            M.get_associated_function (|
                                              Ty.path "core::fmt::rt::Argument",
                                              "new_display",
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "&")
                                                  []
                                                  [
                                                    Ty.path
                                                      "move_binary_format::file_format::StructDefinitionIndex"
                                                  ]
                                              ]
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.borrow (| Pointer.Kind.Ref, a |) |)
                                              |)
                                            ]
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::UnpackGeneric",
                        0
                      |) in
                    let a := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_v1",
                              [ Value.Integer IntegerKind.Usize 2; Value.Integer IntegerKind.Usize 1
                              ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [ mk_str (| "UnpackGeneric(" |); mk_str (| ")" |) ]
                                    |)
                                  |)
                                |)
                              |);
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.call_closure (|
                                            Ty.path "core::fmt::rt::Argument",
                                            M.get_associated_function (|
                                              Ty.path "core::fmt::rt::Argument",
                                              "new_display",
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "&")
                                                  []
                                                  [
                                                    Ty.path
                                                      "move_binary_format::file_format::StructDefInstantiationIndex"
                                                  ]
                                              ]
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.borrow (| Pointer.Kind.Ref, a |) |)
                                              |)
                                            ]
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "move_binary_format::file_format::Bytecode::ReadRef"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [ Value.Integer IntegerKind.Usize 1 ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (| Value.Array [ mk_str (| "ReadRef" |) ] |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "move_binary_format::file_format::Bytecode::WriteRef"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [ Value.Integer IntegerKind.Usize 1 ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (| Value.Array [ mk_str (| "WriteRef" |) ] |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "move_binary_format::file_format::Bytecode::FreezeRef"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [ Value.Integer IntegerKind.Usize 1 ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (| Value.Array [ mk_str (| "FreezeRef" |) ] |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::MutBorrowLoc",
                        0
                      |) in
                    let a := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_v1",
                              [ Value.Integer IntegerKind.Usize 2; Value.Integer IntegerKind.Usize 1
                              ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array [ mk_str (| "MutBorrowLoc(" |); mk_str (| ")" |) ]
                                    |)
                                  |)
                                |)
                              |);
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.call_closure (|
                                            Ty.path "core::fmt::rt::Argument",
                                            M.get_associated_function (|
                                              Ty.path "core::fmt::rt::Argument",
                                              "new_display",
                                              [],
                                              [ Ty.apply (Ty.path "&") [] [ Ty.path "u8" ] ]
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.borrow (| Pointer.Kind.Ref, a |) |)
                                              |)
                                            ]
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::ImmBorrowLoc",
                        0
                      |) in
                    let a := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_v1",
                              [ Value.Integer IntegerKind.Usize 2; Value.Integer IntegerKind.Usize 1
                              ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array [ mk_str (| "ImmBorrowLoc(" |); mk_str (| ")" |) ]
                                    |)
                                  |)
                                |)
                              |);
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.call_closure (|
                                            Ty.path "core::fmt::rt::Argument",
                                            M.get_associated_function (|
                                              Ty.path "core::fmt::rt::Argument",
                                              "new_display",
                                              [],
                                              [ Ty.apply (Ty.path "&") [] [ Ty.path "u8" ] ]
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.borrow (| Pointer.Kind.Ref, a |) |)
                                              |)
                                            ]
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::MutBorrowField",
                        0
                      |) in
                    let a := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_v1",
                              [ Value.Integer IntegerKind.Usize 2; Value.Integer IntegerKind.Usize 1
                              ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [ mk_str (| "MutBorrowField(" |); mk_str (| ")" |) ]
                                    |)
                                  |)
                                |)
                              |);
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.call_closure (|
                                            Ty.path "core::fmt::rt::Argument",
                                            M.get_associated_function (|
                                              Ty.path "core::fmt::rt::Argument",
                                              "new_debug",
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "&")
                                                  []
                                                  [
                                                    Ty.path
                                                      "move_binary_format::file_format::FieldHandleIndex"
                                                  ]
                                              ]
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.borrow (| Pointer.Kind.Ref, a |) |)
                                              |)
                                            ]
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::MutBorrowFieldGeneric",
                        0
                      |) in
                    let a := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_v1",
                              [ Value.Integer IntegerKind.Usize 2; Value.Integer IntegerKind.Usize 1
                              ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [ mk_str (| "MutBorrowFieldGeneric(" |); mk_str (| ")" |) ]
                                    |)
                                  |)
                                |)
                              |);
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.call_closure (|
                                            Ty.path "core::fmt::rt::Argument",
                                            M.get_associated_function (|
                                              Ty.path "core::fmt::rt::Argument",
                                              "new_debug",
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "&")
                                                  []
                                                  [
                                                    Ty.path
                                                      "move_binary_format::file_format::FieldInstantiationIndex"
                                                  ]
                                              ]
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.borrow (| Pointer.Kind.Ref, a |) |)
                                              |)
                                            ]
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::ImmBorrowField",
                        0
                      |) in
                    let a := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_v1",
                              [ Value.Integer IntegerKind.Usize 2; Value.Integer IntegerKind.Usize 1
                              ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [ mk_str (| "ImmBorrowField(" |); mk_str (| ")" |) ]
                                    |)
                                  |)
                                |)
                              |);
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.call_closure (|
                                            Ty.path "core::fmt::rt::Argument",
                                            M.get_associated_function (|
                                              Ty.path "core::fmt::rt::Argument",
                                              "new_debug",
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "&")
                                                  []
                                                  [
                                                    Ty.path
                                                      "move_binary_format::file_format::FieldHandleIndex"
                                                  ]
                                              ]
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.borrow (| Pointer.Kind.Ref, a |) |)
                                              |)
                                            ]
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::ImmBorrowFieldGeneric",
                        0
                      |) in
                    let a := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_v1",
                              [ Value.Integer IntegerKind.Usize 2; Value.Integer IntegerKind.Usize 1
                              ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [ mk_str (| "ImmBorrowFieldGeneric(" |); mk_str (| ")" |) ]
                                    |)
                                  |)
                                |)
                              |);
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.call_closure (|
                                            Ty.path "core::fmt::rt::Argument",
                                            M.get_associated_function (|
                                              Ty.path "core::fmt::rt::Argument",
                                              "new_debug",
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "&")
                                                  []
                                                  [
                                                    Ty.path
                                                      "move_binary_format::file_format::FieldInstantiationIndex"
                                                  ]
                                              ]
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.borrow (| Pointer.Kind.Ref, a |) |)
                                              |)
                                            ]
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::MutBorrowGlobalDeprecated",
                        0
                      |) in
                    let a := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_v1",
                              [ Value.Integer IntegerKind.Usize 2; Value.Integer IntegerKind.Usize 1
                              ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [ mk_str (| "MutBorrowGlobal(" |); mk_str (| ")" |) ]
                                    |)
                                  |)
                                |)
                              |);
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.call_closure (|
                                            Ty.path "core::fmt::rt::Argument",
                                            M.get_associated_function (|
                                              Ty.path "core::fmt::rt::Argument",
                                              "new_debug",
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "&")
                                                  []
                                                  [
                                                    Ty.path
                                                      "move_binary_format::file_format::StructDefinitionIndex"
                                                  ]
                                              ]
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.borrow (| Pointer.Kind.Ref, a |) |)
                                              |)
                                            ]
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::MutBorrowGlobalGenericDeprecated",
                        0
                      |) in
                    let a := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_v1",
                              [ Value.Integer IntegerKind.Usize 2; Value.Integer IntegerKind.Usize 1
                              ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [ mk_str (| "MutBorrowGlobalGeneric(" |); mk_str (| ")" |) ]
                                    |)
                                  |)
                                |)
                              |);
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.call_closure (|
                                            Ty.path "core::fmt::rt::Argument",
                                            M.get_associated_function (|
                                              Ty.path "core::fmt::rt::Argument",
                                              "new_debug",
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "&")
                                                  []
                                                  [
                                                    Ty.path
                                                      "move_binary_format::file_format::StructDefInstantiationIndex"
                                                  ]
                                              ]
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.borrow (| Pointer.Kind.Ref, a |) |)
                                              |)
                                            ]
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::ImmBorrowGlobalDeprecated",
                        0
                      |) in
                    let a := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_v1",
                              [ Value.Integer IntegerKind.Usize 2; Value.Integer IntegerKind.Usize 1
                              ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [ mk_str (| "ImmBorrowGlobal(" |); mk_str (| ")" |) ]
                                    |)
                                  |)
                                |)
                              |);
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.call_closure (|
                                            Ty.path "core::fmt::rt::Argument",
                                            M.get_associated_function (|
                                              Ty.path "core::fmt::rt::Argument",
                                              "new_debug",
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "&")
                                                  []
                                                  [
                                                    Ty.path
                                                      "move_binary_format::file_format::StructDefinitionIndex"
                                                  ]
                                              ]
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.borrow (| Pointer.Kind.Ref, a |) |)
                                              |)
                                            ]
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::ImmBorrowGlobalGenericDeprecated",
                        0
                      |) in
                    let a := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_v1",
                              [ Value.Integer IntegerKind.Usize 2; Value.Integer IntegerKind.Usize 1
                              ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [ mk_str (| "ImmBorrowGlobalGeneric(" |); mk_str (| ")" |) ]
                                    |)
                                  |)
                                |)
                              |);
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.call_closure (|
                                            Ty.path "core::fmt::rt::Argument",
                                            M.get_associated_function (|
                                              Ty.path "core::fmt::rt::Argument",
                                              "new_debug",
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "&")
                                                  []
                                                  [
                                                    Ty.path
                                                      "move_binary_format::file_format::StructDefInstantiationIndex"
                                                  ]
                                              ]
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.borrow (| Pointer.Kind.Ref, a |) |)
                                              |)
                                            ]
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (| γ, "move_binary_format::file_format::Bytecode::Add" |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [ Value.Integer IntegerKind.Usize 1 ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (| Value.Array [ mk_str (| "Add" |) ] |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (| γ, "move_binary_format::file_format::Bytecode::Sub" |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [ Value.Integer IntegerKind.Usize 1 ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (| Value.Array [ mk_str (| "Sub" |) ] |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (| γ, "move_binary_format::file_format::Bytecode::Mul" |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [ Value.Integer IntegerKind.Usize 1 ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (| Value.Array [ mk_str (| "Mul" |) ] |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (| γ, "move_binary_format::file_format::Bytecode::Mod" |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [ Value.Integer IntegerKind.Usize 1 ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (| Value.Array [ mk_str (| "Mod" |) ] |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (| γ, "move_binary_format::file_format::Bytecode::Div" |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [ Value.Integer IntegerKind.Usize 1 ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (| Value.Array [ mk_str (| "Div" |) ] |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "move_binary_format::file_format::Bytecode::BitOr"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [ Value.Integer IntegerKind.Usize 1 ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (| Value.Array [ mk_str (| "BitOr" |) ] |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "move_binary_format::file_format::Bytecode::BitAnd"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [ Value.Integer IntegerKind.Usize 1 ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (| Value.Array [ mk_str (| "BitAnd" |) ] |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (| γ, "move_binary_format::file_format::Bytecode::Xor" |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [ Value.Integer IntegerKind.Usize 1 ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (| Value.Array [ mk_str (| "Xor" |) ] |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (| γ, "move_binary_format::file_format::Bytecode::Shl" |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [ Value.Integer IntegerKind.Usize 1 ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (| Value.Array [ mk_str (| "Shl" |) ] |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (| γ, "move_binary_format::file_format::Bytecode::Shr" |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [ Value.Integer IntegerKind.Usize 1 ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (| Value.Array [ mk_str (| "Shr" |) ] |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (| γ, "move_binary_format::file_format::Bytecode::Or" |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [ Value.Integer IntegerKind.Usize 1 ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (| Value.Array [ mk_str (| "Or" |) ] |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (| γ, "move_binary_format::file_format::Bytecode::And" |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [ Value.Integer IntegerKind.Usize 1 ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (| Value.Array [ mk_str (| "And" |) ] |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (| γ, "move_binary_format::file_format::Bytecode::Not" |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [ Value.Integer IntegerKind.Usize 1 ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (| Value.Array [ mk_str (| "Not" |) ] |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (| γ, "move_binary_format::file_format::Bytecode::Eq" |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [ Value.Integer IntegerKind.Usize 1 ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (| Value.Array [ mk_str (| "Eq" |) ] |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (| γ, "move_binary_format::file_format::Bytecode::Neq" |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [ Value.Integer IntegerKind.Usize 1 ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (| Value.Array [ mk_str (| "Neq" |) ] |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (| γ, "move_binary_format::file_format::Bytecode::Lt" |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [ Value.Integer IntegerKind.Usize 1 ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (| Value.Array [ mk_str (| "Lt" |) ] |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (| γ, "move_binary_format::file_format::Bytecode::Gt" |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [ Value.Integer IntegerKind.Usize 1 ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (| Value.Array [ mk_str (| "Gt" |) ] |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (| γ, "move_binary_format::file_format::Bytecode::Le" |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [ Value.Integer IntegerKind.Usize 1 ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (| Value.Array [ mk_str (| "Le" |) ] |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (| γ, "move_binary_format::file_format::Bytecode::Ge" |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [ Value.Integer IntegerKind.Usize 1 ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (| Value.Array [ mk_str (| "Ge" |) ] |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "move_binary_format::file_format::Bytecode::Abort"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [ Value.Integer IntegerKind.Usize 1 ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (| Value.Array [ mk_str (| "Abort" |) ] |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (| γ, "move_binary_format::file_format::Bytecode::Nop" |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_const",
                              [ Value.Integer IntegerKind.Usize 1 ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (| Value.Array [ mk_str (| "Nop" |) ] |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::ExistsDeprecated",
                        0
                      |) in
                    let a := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_v1",
                              [ Value.Integer IntegerKind.Usize 2; Value.Integer IntegerKind.Usize 1
                              ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array [ mk_str (| "Exists(" |); mk_str (| ")" |) ]
                                    |)
                                  |)
                                |)
                              |);
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.call_closure (|
                                            Ty.path "core::fmt::rt::Argument",
                                            M.get_associated_function (|
                                              Ty.path "core::fmt::rt::Argument",
                                              "new_debug",
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "&")
                                                  []
                                                  [
                                                    Ty.path
                                                      "move_binary_format::file_format::StructDefinitionIndex"
                                                  ]
                                              ]
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.borrow (| Pointer.Kind.Ref, a |) |)
                                              |)
                                            ]
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::ExistsGenericDeprecated",
                        0
                      |) in
                    let a := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_v1",
                              [ Value.Integer IntegerKind.Usize 2; Value.Integer IntegerKind.Usize 1
                              ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [ mk_str (| "ExistsGeneric(" |); mk_str (| ")" |) ]
                                    |)
                                  |)
                                |)
                              |);
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.call_closure (|
                                            Ty.path "core::fmt::rt::Argument",
                                            M.get_associated_function (|
                                              Ty.path "core::fmt::rt::Argument",
                                              "new_debug",
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "&")
                                                  []
                                                  [
                                                    Ty.path
                                                      "move_binary_format::file_format::StructDefInstantiationIndex"
                                                  ]
                                              ]
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.borrow (| Pointer.Kind.Ref, a |) |)
                                              |)
                                            ]
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::MoveFromDeprecated",
                        0
                      |) in
                    let a := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_v1",
                              [ Value.Integer IntegerKind.Usize 2; Value.Integer IntegerKind.Usize 1
                              ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array [ mk_str (| "MoveFrom(" |); mk_str (| ")" |) ]
                                    |)
                                  |)
                                |)
                              |);
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.call_closure (|
                                            Ty.path "core::fmt::rt::Argument",
                                            M.get_associated_function (|
                                              Ty.path "core::fmt::rt::Argument",
                                              "new_debug",
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "&")
                                                  []
                                                  [
                                                    Ty.path
                                                      "move_binary_format::file_format::StructDefinitionIndex"
                                                  ]
                                              ]
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.borrow (| Pointer.Kind.Ref, a |) |)
                                              |)
                                            ]
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::MoveFromGenericDeprecated",
                        0
                      |) in
                    let a := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_v1",
                              [ Value.Integer IntegerKind.Usize 2; Value.Integer IntegerKind.Usize 1
                              ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [ mk_str (| "MoveFromGeneric(" |); mk_str (| ")" |) ]
                                    |)
                                  |)
                                |)
                              |);
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.call_closure (|
                                            Ty.path "core::fmt::rt::Argument",
                                            M.get_associated_function (|
                                              Ty.path "core::fmt::rt::Argument",
                                              "new_debug",
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "&")
                                                  []
                                                  [
                                                    Ty.path
                                                      "move_binary_format::file_format::StructDefInstantiationIndex"
                                                  ]
                                              ]
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.borrow (| Pointer.Kind.Ref, a |) |)
                                              |)
                                            ]
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::MoveToDeprecated",
                        0
                      |) in
                    let a := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_v1",
                              [ Value.Integer IntegerKind.Usize 2; Value.Integer IntegerKind.Usize 1
                              ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array [ mk_str (| "MoveTo(" |); mk_str (| ")" |) ]
                                    |)
                                  |)
                                |)
                              |);
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.call_closure (|
                                            Ty.path "core::fmt::rt::Argument",
                                            M.get_associated_function (|
                                              Ty.path "core::fmt::rt::Argument",
                                              "new_debug",
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "&")
                                                  []
                                                  [
                                                    Ty.path
                                                      "move_binary_format::file_format::StructDefinitionIndex"
                                                  ]
                                              ]
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.borrow (| Pointer.Kind.Ref, a |) |)
                                              |)
                                            ]
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::MoveToGenericDeprecated",
                        0
                      |) in
                    let a := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_v1",
                              [ Value.Integer IntegerKind.Usize 2; Value.Integer IntegerKind.Usize 1
                              ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [ mk_str (| "MoveToGeneric(" |); mk_str (| ")" |) ]
                                    |)
                                  |)
                                |)
                              |);
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.call_closure (|
                                            Ty.path "core::fmt::rt::Argument",
                                            M.get_associated_function (|
                                              Ty.path "core::fmt::rt::Argument",
                                              "new_debug",
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "&")
                                                  []
                                                  [
                                                    Ty.path
                                                      "move_binary_format::file_format::StructDefInstantiationIndex"
                                                  ]
                                              ]
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.borrow (| Pointer.Kind.Ref, a |) |)
                                              |)
                                            ]
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::VecPack",
                        0
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::VecPack",
                        1
                      |) in
                    let a := M.alloc (| γ1_0 |) in
                    let n := M.alloc (| γ1_1 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_v1",
                              [ Value.Integer IntegerKind.Usize 3; Value.Integer IntegerKind.Usize 2
                              ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          mk_str (| "VecPack(" |);
                                          mk_str (| ", " |);
                                          mk_str (| ")" |)
                                        ]
                                    |)
                                  |)
                                |)
                              |);
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.call_closure (|
                                            Ty.path "core::fmt::rt::Argument",
                                            M.get_associated_function (|
                                              Ty.path "core::fmt::rt::Argument",
                                              "new_display",
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "&")
                                                  []
                                                  [
                                                    Ty.path
                                                      "move_binary_format::file_format::SignatureIndex"
                                                  ]
                                              ]
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.borrow (| Pointer.Kind.Ref, a |) |)
                                              |)
                                            ]
                                          |);
                                          M.call_closure (|
                                            Ty.path "core::fmt::rt::Argument",
                                            M.get_associated_function (|
                                              Ty.path "core::fmt::rt::Argument",
                                              "new_display",
                                              [],
                                              [ Ty.apply (Ty.path "&") [] [ Ty.path "u64" ] ]
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.borrow (| Pointer.Kind.Ref, n |) |)
                                              |)
                                            ]
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::VecLen",
                        0
                      |) in
                    let a := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_v1",
                              [ Value.Integer IntegerKind.Usize 2; Value.Integer IntegerKind.Usize 1
                              ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array [ mk_str (| "VecLen(" |); mk_str (| ")" |) ]
                                    |)
                                  |)
                                |)
                              |);
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.call_closure (|
                                            Ty.path "core::fmt::rt::Argument",
                                            M.get_associated_function (|
                                              Ty.path "core::fmt::rt::Argument",
                                              "new_display",
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "&")
                                                  []
                                                  [
                                                    Ty.path
                                                      "move_binary_format::file_format::SignatureIndex"
                                                  ]
                                              ]
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.borrow (| Pointer.Kind.Ref, a |) |)
                                              |)
                                            ]
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::VecImmBorrow",
                        0
                      |) in
                    let a := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_v1",
                              [ Value.Integer IntegerKind.Usize 2; Value.Integer IntegerKind.Usize 1
                              ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array [ mk_str (| "VecImmBorrow(" |); mk_str (| ")" |) ]
                                    |)
                                  |)
                                |)
                              |);
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.call_closure (|
                                            Ty.path "core::fmt::rt::Argument",
                                            M.get_associated_function (|
                                              Ty.path "core::fmt::rt::Argument",
                                              "new_display",
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "&")
                                                  []
                                                  [
                                                    Ty.path
                                                      "move_binary_format::file_format::SignatureIndex"
                                                  ]
                                              ]
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.borrow (| Pointer.Kind.Ref, a |) |)
                                              |)
                                            ]
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::VecMutBorrow",
                        0
                      |) in
                    let a := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_v1",
                              [ Value.Integer IntegerKind.Usize 2; Value.Integer IntegerKind.Usize 1
                              ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array [ mk_str (| "VecMutBorrow(" |); mk_str (| ")" |) ]
                                    |)
                                  |)
                                |)
                              |);
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.call_closure (|
                                            Ty.path "core::fmt::rt::Argument",
                                            M.get_associated_function (|
                                              Ty.path "core::fmt::rt::Argument",
                                              "new_display",
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "&")
                                                  []
                                                  [
                                                    Ty.path
                                                      "move_binary_format::file_format::SignatureIndex"
                                                  ]
                                              ]
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.borrow (| Pointer.Kind.Ref, a |) |)
                                              |)
                                            ]
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::VecPushBack",
                        0
                      |) in
                    let a := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_v1",
                              [ Value.Integer IntegerKind.Usize 2; Value.Integer IntegerKind.Usize 1
                              ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array [ mk_str (| "VecPushBack(" |); mk_str (| ")" |) ]
                                    |)
                                  |)
                                |)
                              |);
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.call_closure (|
                                            Ty.path "core::fmt::rt::Argument",
                                            M.get_associated_function (|
                                              Ty.path "core::fmt::rt::Argument",
                                              "new_display",
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "&")
                                                  []
                                                  [
                                                    Ty.path
                                                      "move_binary_format::file_format::SignatureIndex"
                                                  ]
                                              ]
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.borrow (| Pointer.Kind.Ref, a |) |)
                                              |)
                                            ]
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::VecPopBack",
                        0
                      |) in
                    let a := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_v1",
                              [ Value.Integer IntegerKind.Usize 2; Value.Integer IntegerKind.Usize 1
                              ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array [ mk_str (| "VecPopBack(" |); mk_str (| ")" |) ]
                                    |)
                                  |)
                                |)
                              |);
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.call_closure (|
                                            Ty.path "core::fmt::rt::Argument",
                                            M.get_associated_function (|
                                              Ty.path "core::fmt::rt::Argument",
                                              "new_display",
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "&")
                                                  []
                                                  [
                                                    Ty.path
                                                      "move_binary_format::file_format::SignatureIndex"
                                                  ]
                                              ]
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.borrow (| Pointer.Kind.Ref, a |) |)
                                              |)
                                            ]
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::VecUnpack",
                        0
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::VecUnpack",
                        1
                      |) in
                    let a := M.alloc (| γ1_0 |) in
                    let n := M.alloc (| γ1_1 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_v1",
                              [ Value.Integer IntegerKind.Usize 3; Value.Integer IntegerKind.Usize 2
                              ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          mk_str (| "VecUnpack(" |);
                                          mk_str (| ", " |);
                                          mk_str (| ")" |)
                                        ]
                                    |)
                                  |)
                                |)
                              |);
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.call_closure (|
                                            Ty.path "core::fmt::rt::Argument",
                                            M.get_associated_function (|
                                              Ty.path "core::fmt::rt::Argument",
                                              "new_display",
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "&")
                                                  []
                                                  [
                                                    Ty.path
                                                      "move_binary_format::file_format::SignatureIndex"
                                                  ]
                                              ]
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.borrow (| Pointer.Kind.Ref, a |) |)
                                              |)
                                            ]
                                          |);
                                          M.call_closure (|
                                            Ty.path "core::fmt::rt::Argument",
                                            M.get_associated_function (|
                                              Ty.path "core::fmt::rt::Argument",
                                              "new_display",
                                              [],
                                              [ Ty.apply (Ty.path "&") [] [ Ty.path "u64" ] ]
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.borrow (| Pointer.Kind.Ref, n |) |)
                                              |)
                                            ]
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_binary_format::file_format::Bytecode::VecSwap",
                        0
                      |) in
                    let a := M.alloc (| γ1_0 |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                        M.get_associated_function (|
                          Ty.path "core::fmt::Formatter",
                          "write_fmt",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                          M.call_closure (|
                            Ty.path "core::fmt::Arguments",
                            M.get_associated_function (|
                              Ty.path "core::fmt::Arguments",
                              "new_v1",
                              [ Value.Integer IntegerKind.Usize 2; Value.Integer IntegerKind.Usize 1
                              ],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array [ mk_str (| "VecSwap(" |); mk_str (| ")" |) ]
                                    |)
                                  |)
                                |)
                              |);
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Value.Array
                                        [
                                          M.call_closure (|
                                            Ty.path "core::fmt::rt::Argument",
                                            M.get_associated_function (|
                                              Ty.path "core::fmt::rt::Argument",
                                              "new_display",
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "&")
                                                  []
                                                  [
                                                    Ty.path
                                                      "move_binary_format::file_format::SignatureIndex"
                                                  ]
                                              ]
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.borrow (| Pointer.Kind.Ref, a |) |)
                                              |)
                                            ]
                                          |)
                                        ]
                                    |)
                                  |)
                                |)
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_move_binary_format_file_format_Bytecode.
  
  
  (* StructRecord
    {
      name := "CompiledModule";
      const_params := [];
      ty_params := [];
      fields :=
        [
          ("version", Ty.path "u32");
          ("self_module_handle_idx", Ty.path "move_binary_format::file_format::ModuleHandleIndex");
          ("module_handles",
            Ty.apply
              (Ty.path "alloc::vec::Vec")
              []
              [
                Ty.path "move_binary_format::file_format::ModuleHandle";
                Ty.path "alloc::alloc::Global"
              ]);
          ("struct_handles",
            Ty.apply
              (Ty.path "alloc::vec::Vec")
              []
              [
                Ty.path "move_binary_format::file_format::StructHandle";
                Ty.path "alloc::alloc::Global"
              ]);
          ("function_handles",
            Ty.apply
              (Ty.path "alloc::vec::Vec")
              []
              [
                Ty.path "move_binary_format::file_format::FunctionHandle";
                Ty.path "alloc::alloc::Global"
              ]);
          ("field_handles",
            Ty.apply
              (Ty.path "alloc::vec::Vec")
              []
              [
                Ty.path "move_binary_format::file_format::FieldHandle";
                Ty.path "alloc::alloc::Global"
              ]);
          ("friend_decls",
            Ty.apply
              (Ty.path "alloc::vec::Vec")
              []
              [
                Ty.path "move_binary_format::file_format::ModuleHandle";
                Ty.path "alloc::alloc::Global"
              ]);
          ("struct_def_instantiations",
            Ty.apply
              (Ty.path "alloc::vec::Vec")
              []
              [
                Ty.path "move_binary_format::file_format::StructDefInstantiation";
                Ty.path "alloc::alloc::Global"
              ]);
          ("function_instantiations",
            Ty.apply
              (Ty.path "alloc::vec::Vec")
              []
              [
                Ty.path "move_binary_format::file_format::FunctionInstantiation";
                Ty.path "alloc::alloc::Global"
              ]);
          ("field_instantiations",
            Ty.apply
              (Ty.path "alloc::vec::Vec")
              []
              [
                Ty.path "move_binary_format::file_format::FieldInstantiation";
                Ty.path "alloc::alloc::Global"
              ]);
          ("signatures",
            Ty.apply
              (Ty.path "alloc::vec::Vec")
              []
              [ Ty.path "move_binary_format::file_format::Signature"; Ty.path "alloc::alloc::Global"
              ]);
          ("identifiers",
            Ty.apply
              (Ty.path "alloc::vec::Vec")
              []
              [ Ty.path "move_core_types::identifier::Identifier"; Ty.path "alloc::alloc::Global"
              ]);
          ("address_identifiers",
            Ty.apply
              (Ty.path "alloc::vec::Vec")
              []
              [
                Ty.path "move_core_types::account_address::AccountAddress";
                Ty.path "alloc::alloc::Global"
              ]);
          ("constant_pool",
            Ty.apply
              (Ty.path "alloc::vec::Vec")
              []
              [ Ty.path "move_binary_format::file_format::Constant"; Ty.path "alloc::alloc::Global"
              ]);
          ("metadata",
            Ty.apply
              (Ty.path "alloc::vec::Vec")
              []
              [ Ty.path "move_core_types::metadata::Metadata"; Ty.path "alloc::alloc::Global" ]);
          ("struct_defs",
            Ty.apply
              (Ty.path "alloc::vec::Vec")
              []
              [
                Ty.path "move_binary_format::file_format::StructDefinition";
                Ty.path "alloc::alloc::Global"
              ]);
          ("function_defs",
            Ty.apply
              (Ty.path "alloc::vec::Vec")
              []
              [
                Ty.path "move_binary_format::file_format::FunctionDefinition";
                Ty.path "alloc::alloc::Global"
              ])
        ];
    } *)
  
  Module Impl_core_clone_Clone_for_move_binary_format_file_format_CompiledModule.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::CompiledModule".
    
    (* Clone *)
    Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.StructRecord
            "move_binary_format::file_format::CompiledModule"
            []
            []
            [
              ("version",
                M.call_closure (|
                  Ty.path "u32",
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.path "u32",
                    [],
                    [],
                    "clone",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "move_binary_format::file_format::CompiledModule",
                            "version"
                          |)
                        |)
                      |)
                    |)
                  ]
                |));
              ("self_module_handle_idx",
                M.call_closure (|
                  Ty.path "move_binary_format::file_format::ModuleHandleIndex",
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.path "move_binary_format::file_format::ModuleHandleIndex",
                    [],
                    [],
                    "clone",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "move_binary_format::file_format::CompiledModule",
                            "self_module_handle_idx"
                          |)
                        |)
                      |)
                    |)
                  ]
                |));
              ("module_handles",
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [
                      Ty.path "move_binary_format::file_format::ModuleHandle";
                      Ty.path "alloc::alloc::Global"
                    ],
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      []
                      [
                        Ty.path "move_binary_format::file_format::ModuleHandle";
                        Ty.path "alloc::alloc::Global"
                      ],
                    [],
                    [],
                    "clone",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "move_binary_format::file_format::CompiledModule",
                            "module_handles"
                          |)
                        |)
                      |)
                    |)
                  ]
                |));
              ("struct_handles",
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [
                      Ty.path "move_binary_format::file_format::StructHandle";
                      Ty.path "alloc::alloc::Global"
                    ],
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      []
                      [
                        Ty.path "move_binary_format::file_format::StructHandle";
                        Ty.path "alloc::alloc::Global"
                      ],
                    [],
                    [],
                    "clone",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "move_binary_format::file_format::CompiledModule",
                            "struct_handles"
                          |)
                        |)
                      |)
                    |)
                  ]
                |));
              ("function_handles",
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [
                      Ty.path "move_binary_format::file_format::FunctionHandle";
                      Ty.path "alloc::alloc::Global"
                    ],
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      []
                      [
                        Ty.path "move_binary_format::file_format::FunctionHandle";
                        Ty.path "alloc::alloc::Global"
                      ],
                    [],
                    [],
                    "clone",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "move_binary_format::file_format::CompiledModule",
                            "function_handles"
                          |)
                        |)
                      |)
                    |)
                  ]
                |));
              ("field_handles",
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [
                      Ty.path "move_binary_format::file_format::FieldHandle";
                      Ty.path "alloc::alloc::Global"
                    ],
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      []
                      [
                        Ty.path "move_binary_format::file_format::FieldHandle";
                        Ty.path "alloc::alloc::Global"
                      ],
                    [],
                    [],
                    "clone",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "move_binary_format::file_format::CompiledModule",
                            "field_handles"
                          |)
                        |)
                      |)
                    |)
                  ]
                |));
              ("friend_decls",
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [
                      Ty.path "move_binary_format::file_format::ModuleHandle";
                      Ty.path "alloc::alloc::Global"
                    ],
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      []
                      [
                        Ty.path "move_binary_format::file_format::ModuleHandle";
                        Ty.path "alloc::alloc::Global"
                      ],
                    [],
                    [],
                    "clone",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "move_binary_format::file_format::CompiledModule",
                            "friend_decls"
                          |)
                        |)
                      |)
                    |)
                  ]
                |));
              ("struct_def_instantiations",
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [
                      Ty.path "move_binary_format::file_format::StructDefInstantiation";
                      Ty.path "alloc::alloc::Global"
                    ],
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      []
                      [
                        Ty.path "move_binary_format::file_format::StructDefInstantiation";
                        Ty.path "alloc::alloc::Global"
                      ],
                    [],
                    [],
                    "clone",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "move_binary_format::file_format::CompiledModule",
                            "struct_def_instantiations"
                          |)
                        |)
                      |)
                    |)
                  ]
                |));
              ("function_instantiations",
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [
                      Ty.path "move_binary_format::file_format::FunctionInstantiation";
                      Ty.path "alloc::alloc::Global"
                    ],
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      []
                      [
                        Ty.path "move_binary_format::file_format::FunctionInstantiation";
                        Ty.path "alloc::alloc::Global"
                      ],
                    [],
                    [],
                    "clone",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "move_binary_format::file_format::CompiledModule",
                            "function_instantiations"
                          |)
                        |)
                      |)
                    |)
                  ]
                |));
              ("field_instantiations",
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [
                      Ty.path "move_binary_format::file_format::FieldInstantiation";
                      Ty.path "alloc::alloc::Global"
                    ],
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      []
                      [
                        Ty.path "move_binary_format::file_format::FieldInstantiation";
                        Ty.path "alloc::alloc::Global"
                      ],
                    [],
                    [],
                    "clone",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "move_binary_format::file_format::CompiledModule",
                            "field_instantiations"
                          |)
                        |)
                      |)
                    |)
                  ]
                |));
              ("signatures",
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [
                      Ty.path "move_binary_format::file_format::Signature";
                      Ty.path "alloc::alloc::Global"
                    ],
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      []
                      [
                        Ty.path "move_binary_format::file_format::Signature";
                        Ty.path "alloc::alloc::Global"
                      ],
                    [],
                    [],
                    "clone",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "move_binary_format::file_format::CompiledModule",
                            "signatures"
                          |)
                        |)
                      |)
                    |)
                  ]
                |));
              ("identifiers",
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [
                      Ty.path "move_core_types::identifier::Identifier";
                      Ty.path "alloc::alloc::Global"
                    ],
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      []
                      [
                        Ty.path "move_core_types::identifier::Identifier";
                        Ty.path "alloc::alloc::Global"
                      ],
                    [],
                    [],
                    "clone",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "move_binary_format::file_format::CompiledModule",
                            "identifiers"
                          |)
                        |)
                      |)
                    |)
                  ]
                |));
              ("address_identifiers",
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [
                      Ty.path "move_core_types::account_address::AccountAddress";
                      Ty.path "alloc::alloc::Global"
                    ],
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      []
                      [
                        Ty.path "move_core_types::account_address::AccountAddress";
                        Ty.path "alloc::alloc::Global"
                      ],
                    [],
                    [],
                    "clone",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "move_binary_format::file_format::CompiledModule",
                            "address_identifiers"
                          |)
                        |)
                      |)
                    |)
                  ]
                |));
              ("constant_pool",
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [
                      Ty.path "move_binary_format::file_format::Constant";
                      Ty.path "alloc::alloc::Global"
                    ],
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      []
                      [
                        Ty.path "move_binary_format::file_format::Constant";
                        Ty.path "alloc::alloc::Global"
                      ],
                    [],
                    [],
                    "clone",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "move_binary_format::file_format::CompiledModule",
                            "constant_pool"
                          |)
                        |)
                      |)
                    |)
                  ]
                |));
              ("metadata",
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [ Ty.path "move_core_types::metadata::Metadata"; Ty.path "alloc::alloc::Global"
                    ],
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      []
                      [
                        Ty.path "move_core_types::metadata::Metadata";
                        Ty.path "alloc::alloc::Global"
                      ],
                    [],
                    [],
                    "clone",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "move_binary_format::file_format::CompiledModule",
                            "metadata"
                          |)
                        |)
                      |)
                    |)
                  ]
                |));
              ("struct_defs",
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [
                      Ty.path "move_binary_format::file_format::StructDefinition";
                      Ty.path "alloc::alloc::Global"
                    ],
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      []
                      [
                        Ty.path "move_binary_format::file_format::StructDefinition";
                        Ty.path "alloc::alloc::Global"
                      ],
                    [],
                    [],
                    "clone",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "move_binary_format::file_format::CompiledModule",
                            "struct_defs"
                          |)
                        |)
                      |)
                    |)
                  ]
                |));
              ("function_defs",
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [
                      Ty.path "move_binary_format::file_format::FunctionDefinition";
                      Ty.path "alloc::alloc::Global"
                    ],
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      []
                      [
                        Ty.path "move_binary_format::file_format::FunctionDefinition";
                        Ty.path "alloc::alloc::Global"
                      ],
                    [],
                    [],
                    "clone",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "move_binary_format::file_format::CompiledModule",
                            "function_defs"
                          |)
                        |)
                      |)
                    |)
                  ]
                |))
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_move_binary_format_file_format_CompiledModule.
  
  Module Impl_core_fmt_Debug_for_move_binary_format_file_format_CompiledModule.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::CompiledModule".
    
    (* Debug *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.read (|
            let~ names :
                Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path "array")
                      [ Value.Integer IntegerKind.Usize 17 ]
                      [ Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ]
                  ] :=
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.alloc (|
                      Value.Array
                        [
                          mk_str (| "version" |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| mk_str (| "self_module_handle_idx" |) |)
                          |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| mk_str (| "module_handles" |) |)
                          |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| mk_str (| "struct_handles" |) |)
                          |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| mk_str (| "function_handles" |) |)
                          |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| mk_str (| "field_handles" |) |)
                          |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| mk_str (| "friend_decls" |) |)
                          |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| mk_str (| "struct_def_instantiations" |) |)
                          |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| mk_str (| "function_instantiations" |) |)
                          |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| mk_str (| "field_instantiations" |) |)
                          |);
                          M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "signatures" |) |) |);
                          M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "identifiers" |) |) |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| mk_str (| "address_identifiers" |) |)
                          |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| mk_str (| "constant_pool" |) |)
                          |);
                          M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "metadata" |) |) |);
                          M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "struct_defs" |) |) |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| mk_str (| "function_defs" |) |)
                          |)
                        ]
                    |)
                  |)
                |)
              |) in
            let~ values :
                Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path "slice")
                      []
                      [ Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ] ]
                  ] :=
              (* Unsize *)
              M.pointer_coercion
                (M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.alloc (|
                        Value.Array
                          [
                            (* Unsize *)
                            M.pointer_coercion
                              (M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "move_binary_format::file_format::CompiledModule",
                                      "version"
                                    |)
                                  |)
                                |)
                              |));
                            (* Unsize *)
                            M.pointer_coercion
                              (M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "move_binary_format::file_format::CompiledModule",
                                      "self_module_handle_idx"
                                    |)
                                  |)
                                |)
                              |));
                            (* Unsize *)
                            M.pointer_coercion
                              (M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "move_binary_format::file_format::CompiledModule",
                                      "module_handles"
                                    |)
                                  |)
                                |)
                              |));
                            (* Unsize *)
                            M.pointer_coercion
                              (M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "move_binary_format::file_format::CompiledModule",
                                      "struct_handles"
                                    |)
                                  |)
                                |)
                              |));
                            (* Unsize *)
                            M.pointer_coercion
                              (M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "move_binary_format::file_format::CompiledModule",
                                      "function_handles"
                                    |)
                                  |)
                                |)
                              |));
                            (* Unsize *)
                            M.pointer_coercion
                              (M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "move_binary_format::file_format::CompiledModule",
                                      "field_handles"
                                    |)
                                  |)
                                |)
                              |));
                            (* Unsize *)
                            M.pointer_coercion
                              (M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "move_binary_format::file_format::CompiledModule",
                                      "friend_decls"
                                    |)
                                  |)
                                |)
                              |));
                            (* Unsize *)
                            M.pointer_coercion
                              (M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "move_binary_format::file_format::CompiledModule",
                                      "struct_def_instantiations"
                                    |)
                                  |)
                                |)
                              |));
                            (* Unsize *)
                            M.pointer_coercion
                              (M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "move_binary_format::file_format::CompiledModule",
                                      "function_instantiations"
                                    |)
                                  |)
                                |)
                              |));
                            (* Unsize *)
                            M.pointer_coercion
                              (M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "move_binary_format::file_format::CompiledModule",
                                      "field_instantiations"
                                    |)
                                  |)
                                |)
                              |));
                            (* Unsize *)
                            M.pointer_coercion
                              (M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "move_binary_format::file_format::CompiledModule",
                                      "signatures"
                                    |)
                                  |)
                                |)
                              |));
                            (* Unsize *)
                            M.pointer_coercion
                              (M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "move_binary_format::file_format::CompiledModule",
                                      "identifiers"
                                    |)
                                  |)
                                |)
                              |));
                            (* Unsize *)
                            M.pointer_coercion
                              (M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "move_binary_format::file_format::CompiledModule",
                                      "address_identifiers"
                                    |)
                                  |)
                                |)
                              |));
                            (* Unsize *)
                            M.pointer_coercion
                              (M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "move_binary_format::file_format::CompiledModule",
                                      "constant_pool"
                                    |)
                                  |)
                                |)
                              |));
                            (* Unsize *)
                            M.pointer_coercion
                              (M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "move_binary_format::file_format::CompiledModule",
                                      "metadata"
                                    |)
                                  |)
                                |)
                              |));
                            (* Unsize *)
                            M.pointer_coercion
                              (M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "move_binary_format::file_format::CompiledModule",
                                      "struct_defs"
                                    |)
                                  |)
                                |)
                              |));
                            (* Unsize *)
                            M.pointer_coercion
                              (M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.SubPointer.get_struct_record_field (|
                                          M.deref (| M.read (| self |) |),
                                          "move_binary_format::file_format::CompiledModule",
                                          "function_defs"
                                        |)
                                      |)
                                    |)
                                  |)
                                |)
                              |))
                          ]
                      |)
                    |)
                  |)
                |)) in
            M.alloc (|
              M.call_closure (|
                Ty.apply
                  (Ty.path "core::result::Result")
                  []
                  [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                M.get_associated_function (|
                  Ty.path "core::fmt::Formatter",
                  "debug_struct_fields_finish",
                  [],
                  []
                |),
                [
                  M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                  M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "CompiledModule" |) |) |);
                  (* Unsize *)
                  M.pointer_coercion
                    (M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| names |) |) |));
                  M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| values |) |) |)
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_move_binary_format_file_format_CompiledModule.
  
  Module Impl_core_default_Default_for_move_binary_format_file_format_CompiledModule.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::CompiledModule".
    
    (* Default *)
    Definition default (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [] =>
        ltac:(M.monadic
          (Value.StructRecord
            "move_binary_format::file_format::CompiledModule"
            []
            []
            [
              ("version",
                M.call_closure (|
                  Ty.path "u32",
                  M.get_trait_method (|
                    "core::default::Default",
                    Ty.path "u32",
                    [],
                    [],
                    "default",
                    [],
                    []
                  |),
                  []
                |));
              ("self_module_handle_idx",
                M.call_closure (|
                  Ty.path "move_binary_format::file_format::ModuleHandleIndex",
                  M.get_trait_method (|
                    "core::default::Default",
                    Ty.path "move_binary_format::file_format::ModuleHandleIndex",
                    [],
                    [],
                    "default",
                    [],
                    []
                  |),
                  []
                |));
              ("module_handles",
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [
                      Ty.path "move_binary_format::file_format::ModuleHandle";
                      Ty.path "alloc::alloc::Global"
                    ],
                  M.get_trait_method (|
                    "core::default::Default",
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      []
                      [
                        Ty.path "move_binary_format::file_format::ModuleHandle";
                        Ty.path "alloc::alloc::Global"
                      ],
                    [],
                    [],
                    "default",
                    [],
                    []
                  |),
                  []
                |));
              ("struct_handles",
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [
                      Ty.path "move_binary_format::file_format::StructHandle";
                      Ty.path "alloc::alloc::Global"
                    ],
                  M.get_trait_method (|
                    "core::default::Default",
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      []
                      [
                        Ty.path "move_binary_format::file_format::StructHandle";
                        Ty.path "alloc::alloc::Global"
                      ],
                    [],
                    [],
                    "default",
                    [],
                    []
                  |),
                  []
                |));
              ("function_handles",
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [
                      Ty.path "move_binary_format::file_format::FunctionHandle";
                      Ty.path "alloc::alloc::Global"
                    ],
                  M.get_trait_method (|
                    "core::default::Default",
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      []
                      [
                        Ty.path "move_binary_format::file_format::FunctionHandle";
                        Ty.path "alloc::alloc::Global"
                      ],
                    [],
                    [],
                    "default",
                    [],
                    []
                  |),
                  []
                |));
              ("field_handles",
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [
                      Ty.path "move_binary_format::file_format::FieldHandle";
                      Ty.path "alloc::alloc::Global"
                    ],
                  M.get_trait_method (|
                    "core::default::Default",
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      []
                      [
                        Ty.path "move_binary_format::file_format::FieldHandle";
                        Ty.path "alloc::alloc::Global"
                      ],
                    [],
                    [],
                    "default",
                    [],
                    []
                  |),
                  []
                |));
              ("friend_decls",
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [
                      Ty.path "move_binary_format::file_format::ModuleHandle";
                      Ty.path "alloc::alloc::Global"
                    ],
                  M.get_trait_method (|
                    "core::default::Default",
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      []
                      [
                        Ty.path "move_binary_format::file_format::ModuleHandle";
                        Ty.path "alloc::alloc::Global"
                      ],
                    [],
                    [],
                    "default",
                    [],
                    []
                  |),
                  []
                |));
              ("struct_def_instantiations",
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [
                      Ty.path "move_binary_format::file_format::StructDefInstantiation";
                      Ty.path "alloc::alloc::Global"
                    ],
                  M.get_trait_method (|
                    "core::default::Default",
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      []
                      [
                        Ty.path "move_binary_format::file_format::StructDefInstantiation";
                        Ty.path "alloc::alloc::Global"
                      ],
                    [],
                    [],
                    "default",
                    [],
                    []
                  |),
                  []
                |));
              ("function_instantiations",
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [
                      Ty.path "move_binary_format::file_format::FunctionInstantiation";
                      Ty.path "alloc::alloc::Global"
                    ],
                  M.get_trait_method (|
                    "core::default::Default",
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      []
                      [
                        Ty.path "move_binary_format::file_format::FunctionInstantiation";
                        Ty.path "alloc::alloc::Global"
                      ],
                    [],
                    [],
                    "default",
                    [],
                    []
                  |),
                  []
                |));
              ("field_instantiations",
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [
                      Ty.path "move_binary_format::file_format::FieldInstantiation";
                      Ty.path "alloc::alloc::Global"
                    ],
                  M.get_trait_method (|
                    "core::default::Default",
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      []
                      [
                        Ty.path "move_binary_format::file_format::FieldInstantiation";
                        Ty.path "alloc::alloc::Global"
                      ],
                    [],
                    [],
                    "default",
                    [],
                    []
                  |),
                  []
                |));
              ("signatures",
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [
                      Ty.path "move_binary_format::file_format::Signature";
                      Ty.path "alloc::alloc::Global"
                    ],
                  M.get_trait_method (|
                    "core::default::Default",
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      []
                      [
                        Ty.path "move_binary_format::file_format::Signature";
                        Ty.path "alloc::alloc::Global"
                      ],
                    [],
                    [],
                    "default",
                    [],
                    []
                  |),
                  []
                |));
              ("identifiers",
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [
                      Ty.path "move_core_types::identifier::Identifier";
                      Ty.path "alloc::alloc::Global"
                    ],
                  M.get_trait_method (|
                    "core::default::Default",
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      []
                      [
                        Ty.path "move_core_types::identifier::Identifier";
                        Ty.path "alloc::alloc::Global"
                      ],
                    [],
                    [],
                    "default",
                    [],
                    []
                  |),
                  []
                |));
              ("address_identifiers",
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [
                      Ty.path "move_core_types::account_address::AccountAddress";
                      Ty.path "alloc::alloc::Global"
                    ],
                  M.get_trait_method (|
                    "core::default::Default",
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      []
                      [
                        Ty.path "move_core_types::account_address::AccountAddress";
                        Ty.path "alloc::alloc::Global"
                      ],
                    [],
                    [],
                    "default",
                    [],
                    []
                  |),
                  []
                |));
              ("constant_pool",
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [
                      Ty.path "move_binary_format::file_format::Constant";
                      Ty.path "alloc::alloc::Global"
                    ],
                  M.get_trait_method (|
                    "core::default::Default",
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      []
                      [
                        Ty.path "move_binary_format::file_format::Constant";
                        Ty.path "alloc::alloc::Global"
                      ],
                    [],
                    [],
                    "default",
                    [],
                    []
                  |),
                  []
                |));
              ("metadata",
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [ Ty.path "move_core_types::metadata::Metadata"; Ty.path "alloc::alloc::Global"
                    ],
                  M.get_trait_method (|
                    "core::default::Default",
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      []
                      [
                        Ty.path "move_core_types::metadata::Metadata";
                        Ty.path "alloc::alloc::Global"
                      ],
                    [],
                    [],
                    "default",
                    [],
                    []
                  |),
                  []
                |));
              ("struct_defs",
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [
                      Ty.path "move_binary_format::file_format::StructDefinition";
                      Ty.path "alloc::alloc::Global"
                    ],
                  M.get_trait_method (|
                    "core::default::Default",
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      []
                      [
                        Ty.path "move_binary_format::file_format::StructDefinition";
                        Ty.path "alloc::alloc::Global"
                      ],
                    [],
                    [],
                    "default",
                    [],
                    []
                  |),
                  []
                |));
              ("function_defs",
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [
                      Ty.path "move_binary_format::file_format::FunctionDefinition";
                      Ty.path "alloc::alloc::Global"
                    ],
                  M.get_trait_method (|
                    "core::default::Default",
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      []
                      [
                        Ty.path "move_binary_format::file_format::FunctionDefinition";
                        Ty.path "alloc::alloc::Global"
                      ],
                    [],
                    [],
                    "default",
                    [],
                    []
                  |),
                  []
                |))
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::default::Default"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("default", InstanceField.Method default) ].
  End Impl_core_default_Default_for_move_binary_format_file_format_CompiledModule.
  
  Module Impl_core_cmp_Eq_for_move_binary_format_file_format_CompiledModule.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::CompiledModule".
    
    (* Eq *)
    Definition assert_receiver_is_total_eq
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              Value.DeclaredButUndefined,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                      Value.DeclaredButUndefined,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                              Value.DeclaredButUndefined,
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (M.match_operator (|
                                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                      Value.DeclaredButUndefined,
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (M.match_operator (|
                                              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                              Value.DeclaredButUndefined,
                                              [
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (M.match_operator (|
                                                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                                      Value.DeclaredButUndefined,
                                                      [
                                                        fun γ =>
                                                          ltac:(M.monadic
                                                            (M.match_operator (|
                                                              Ty.apply
                                                                (Ty.path "*")
                                                                []
                                                                [ Ty.tuple [] ],
                                                              Value.DeclaredButUndefined,
                                                              [
                                                                fun γ =>
                                                                  ltac:(M.monadic
                                                                    (M.match_operator (|
                                                                      Ty.apply
                                                                        (Ty.path "*")
                                                                        []
                                                                        [ Ty.tuple [] ],
                                                                      Value.DeclaredButUndefined,
                                                                      [
                                                                        fun γ =>
                                                                          ltac:(M.monadic
                                                                            (M.match_operator (|
                                                                              Ty.apply
                                                                                (Ty.path "*")
                                                                                []
                                                                                [ Ty.tuple [] ],
                                                                              Value.DeclaredButUndefined,
                                                                              [
                                                                                fun γ =>
                                                                                  ltac:(M.monadic
                                                                                    (M.match_operator (|
                                                                                      Ty.apply
                                                                                        (Ty.path
                                                                                          "*")
                                                                                        []
                                                                                        [
                                                                                          Ty.tuple
                                                                                            []
                                                                                        ],
                                                                                      Value.DeclaredButUndefined,
                                                                                      [
                                                                                        fun γ =>
                                                                                          ltac:(M.monadic
                                                                                            (M.match_operator (|
                                                                                              Ty.apply
                                                                                                (Ty.path
                                                                                                  "*")
                                                                                                []
                                                                                                [
                                                                                                  Ty.tuple
                                                                                                    []
                                                                                                ],
                                                                                              Value.DeclaredButUndefined,
                                                                                              [
                                                                                                fun
                                                                                                    γ =>
                                                                                                  ltac:(M.monadic
                                                                                                    (M.match_operator (|
                                                                                                      Ty.apply
                                                                                                        (Ty.path
                                                                                                          "*")
                                                                                                        []
                                                                                                        [
                                                                                                          Ty.tuple
                                                                                                            []
                                                                                                        ],
                                                                                                      Value.DeclaredButUndefined,
                                                                                                      [
                                                                                                        fun
                                                                                                            γ =>
                                                                                                          ltac:(M.monadic
                                                                                                            (M.match_operator (|
                                                                                                              Ty.apply
                                                                                                                (Ty.path
                                                                                                                  "*")
                                                                                                                []
                                                                                                                [
                                                                                                                  Ty.tuple
                                                                                                                    []
                                                                                                                ],
                                                                                                              Value.DeclaredButUndefined,
                                                                                                              [
                                                                                                                fun
                                                                                                                    γ =>
                                                                                                                  ltac:(M.monadic
                                                                                                                    (M.match_operator (|
                                                                                                                      Ty.apply
                                                                                                                        (Ty.path
                                                                                                                          "*")
                                                                                                                        []
                                                                                                                        [
                                                                                                                          Ty.tuple
                                                                                                                            []
                                                                                                                        ],
                                                                                                                      Value.DeclaredButUndefined,
                                                                                                                      [
                                                                                                                        fun
                                                                                                                            γ =>
                                                                                                                          ltac:(M.monadic
                                                                                                                            (M.match_operator (|
                                                                                                                              Ty.apply
                                                                                                                                (Ty.path
                                                                                                                                  "*")
                                                                                                                                []
                                                                                                                                [
                                                                                                                                  Ty.tuple
                                                                                                                                    []
                                                                                                                                ],
                                                                                                                              Value.DeclaredButUndefined,
                                                                                                                              [
                                                                                                                                fun
                                                                                                                                    γ =>
                                                                                                                                  ltac:(M.monadic
                                                                                                                                    (M.match_operator (|
                                                                                                                                      Ty.apply
                                                                                                                                        (Ty.path
                                                                                                                                          "*")
                                                                                                                                        []
                                                                                                                                        [
                                                                                                                                          Ty.tuple
                                                                                                                                            []
                                                                                                                                        ],
                                                                                                                                      Value.DeclaredButUndefined,
                                                                                                                                      [
                                                                                                                                        fun
                                                                                                                                            γ =>
                                                                                                                                          ltac:(M.monadic
                                                                                                                                            (M.match_operator (|
                                                                                                                                              Ty.apply
                                                                                                                                                (Ty.path
                                                                                                                                                  "*")
                                                                                                                                                []
                                                                                                                                                [
                                                                                                                                                  Ty.tuple
                                                                                                                                                    []
                                                                                                                                                ],
                                                                                                                                              Value.DeclaredButUndefined,
                                                                                                                                              [
                                                                                                                                                fun
                                                                                                                                                    γ =>
                                                                                                                                                  ltac:(M.monadic
                                                                                                                                                    (M.alloc (|
                                                                                                                                                      Value.Tuple
                                                                                                                                                        []
                                                                                                                                                    |)))
                                                                                                                                              ]
                                                                                                                                            |)))
                                                                                                                                      ]
                                                                                                                                    |)))
                                                                                                                              ]
                                                                                                                            |)))
                                                                                                                      ]
                                                                                                                    |)))
                                                                                                              ]
                                                                                                            |)))
                                                                                                      ]
                                                                                                    |)))
                                                                                              ]
                                                                                            |)))
                                                                                      ]
                                                                                    |)))
                                                                              ]
                                                                            |)))
                                                                      ]
                                                                    |)))
                                                              ]
                                                            |)))
                                                      ]
                                                    |)))
                                              ]
                                            |)))
                                      ]
                                    |)))
                              ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_move_binary_format_file_format_CompiledModule.
  
  Module Impl_core_marker_StructuralPartialEq_for_move_binary_format_file_format_CompiledModule.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::CompiledModule".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_move_binary_format_file_format_CompiledModule.
  
  Module Impl_core_cmp_PartialEq_move_binary_format_file_format_CompiledModule_for_move_binary_format_file_format_CompiledModule.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::CompiledModule".
    
    (* PartialEq *)
    Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          LogicalOp.and (|
            LogicalOp.and (|
              LogicalOp.and (|
                LogicalOp.and (|
                  LogicalOp.and (|
                    LogicalOp.and (|
                      LogicalOp.and (|
                        LogicalOp.and (|
                          LogicalOp.and (|
                            LogicalOp.and (|
                              LogicalOp.and (|
                                LogicalOp.and (|
                                  LogicalOp.and (|
                                    LogicalOp.and (|
                                      LogicalOp.and (|
                                        LogicalOp.and (|
                                          M.call_closure (|
                                            Ty.path "bool",
                                            BinOp.eq,
                                            [
                                              M.read (|
                                                M.SubPointer.get_struct_record_field (|
                                                  M.deref (| M.read (| self |) |),
                                                  "move_binary_format::file_format::CompiledModule",
                                                  "version"
                                                |)
                                              |);
                                              M.read (|
                                                M.SubPointer.get_struct_record_field (|
                                                  M.deref (| M.read (| other |) |),
                                                  "move_binary_format::file_format::CompiledModule",
                                                  "version"
                                                |)
                                              |)
                                            ]
                                          |),
                                          ltac:(M.monadic
                                            (M.call_closure (|
                                              Ty.path "bool",
                                              M.get_trait_method (|
                                                "core::cmp::PartialEq",
                                                Ty.path
                                                  "move_binary_format::file_format::ModuleHandleIndex",
                                                [],
                                                [
                                                  Ty.path
                                                    "move_binary_format::file_format::ModuleHandleIndex"
                                                ],
                                                "eq",
                                                [],
                                                []
                                              |),
                                              [
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.SubPointer.get_struct_record_field (|
                                                    M.deref (| M.read (| self |) |),
                                                    "move_binary_format::file_format::CompiledModule",
                                                    "self_module_handle_idx"
                                                  |)
                                                |);
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.SubPointer.get_struct_record_field (|
                                                    M.deref (| M.read (| other |) |),
                                                    "move_binary_format::file_format::CompiledModule",
                                                    "self_module_handle_idx"
                                                  |)
                                                |)
                                              ]
                                            |)))
                                        |),
                                        ltac:(M.monadic
                                          (M.call_closure (|
                                            Ty.path "bool",
                                            M.get_trait_method (|
                                              "core::cmp::PartialEq",
                                              Ty.apply
                                                (Ty.path "alloc::vec::Vec")
                                                []
                                                [
                                                  Ty.path
                                                    "move_binary_format::file_format::ModuleHandle";
                                                  Ty.path "alloc::alloc::Global"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "alloc::vec::Vec")
                                                  []
                                                  [
                                                    Ty.path
                                                      "move_binary_format::file_format::ModuleHandle";
                                                    Ty.path "alloc::alloc::Global"
                                                  ]
                                              ],
                                              "eq",
                                              [],
                                              []
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.SubPointer.get_struct_record_field (|
                                                  M.deref (| M.read (| self |) |),
                                                  "move_binary_format::file_format::CompiledModule",
                                                  "module_handles"
                                                |)
                                              |);
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.SubPointer.get_struct_record_field (|
                                                  M.deref (| M.read (| other |) |),
                                                  "move_binary_format::file_format::CompiledModule",
                                                  "module_handles"
                                                |)
                                              |)
                                            ]
                                          |)))
                                      |),
                                      ltac:(M.monadic
                                        (M.call_closure (|
                                          Ty.path "bool",
                                          M.get_trait_method (|
                                            "core::cmp::PartialEq",
                                            Ty.apply
                                              (Ty.path "alloc::vec::Vec")
                                              []
                                              [
                                                Ty.path
                                                  "move_binary_format::file_format::StructHandle";
                                                Ty.path "alloc::alloc::Global"
                                              ],
                                            [],
                                            [
                                              Ty.apply
                                                (Ty.path "alloc::vec::Vec")
                                                []
                                                [
                                                  Ty.path
                                                    "move_binary_format::file_format::StructHandle";
                                                  Ty.path "alloc::alloc::Global"
                                                ]
                                            ],
                                            "eq",
                                            [],
                                            []
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.SubPointer.get_struct_record_field (|
                                                M.deref (| M.read (| self |) |),
                                                "move_binary_format::file_format::CompiledModule",
                                                "struct_handles"
                                              |)
                                            |);
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.SubPointer.get_struct_record_field (|
                                                M.deref (| M.read (| other |) |),
                                                "move_binary_format::file_format::CompiledModule",
                                                "struct_handles"
                                              |)
                                            |)
                                          ]
                                        |)))
                                    |),
                                    ltac:(M.monadic
                                      (M.call_closure (|
                                        Ty.path "bool",
                                        M.get_trait_method (|
                                          "core::cmp::PartialEq",
                                          Ty.apply
                                            (Ty.path "alloc::vec::Vec")
                                            []
                                            [
                                              Ty.path
                                                "move_binary_format::file_format::FunctionHandle";
                                              Ty.path "alloc::alloc::Global"
                                            ],
                                          [],
                                          [
                                            Ty.apply
                                              (Ty.path "alloc::vec::Vec")
                                              []
                                              [
                                                Ty.path
                                                  "move_binary_format::file_format::FunctionHandle";
                                                Ty.path "alloc::alloc::Global"
                                              ]
                                          ],
                                          "eq",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.SubPointer.get_struct_record_field (|
                                              M.deref (| M.read (| self |) |),
                                              "move_binary_format::file_format::CompiledModule",
                                              "function_handles"
                                            |)
                                          |);
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.SubPointer.get_struct_record_field (|
                                              M.deref (| M.read (| other |) |),
                                              "move_binary_format::file_format::CompiledModule",
                                              "function_handles"
                                            |)
                                          |)
                                        ]
                                      |)))
                                  |),
                                  ltac:(M.monadic
                                    (M.call_closure (|
                                      Ty.path "bool",
                                      M.get_trait_method (|
                                        "core::cmp::PartialEq",
                                        Ty.apply
                                          (Ty.path "alloc::vec::Vec")
                                          []
                                          [
                                            Ty.path "move_binary_format::file_format::FieldHandle";
                                            Ty.path "alloc::alloc::Global"
                                          ],
                                        [],
                                        [
                                          Ty.apply
                                            (Ty.path "alloc::vec::Vec")
                                            []
                                            [
                                              Ty.path
                                                "move_binary_format::file_format::FieldHandle";
                                              Ty.path "alloc::alloc::Global"
                                            ]
                                        ],
                                        "eq",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.SubPointer.get_struct_record_field (|
                                            M.deref (| M.read (| self |) |),
                                            "move_binary_format::file_format::CompiledModule",
                                            "field_handles"
                                          |)
                                        |);
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.SubPointer.get_struct_record_field (|
                                            M.deref (| M.read (| other |) |),
                                            "move_binary_format::file_format::CompiledModule",
                                            "field_handles"
                                          |)
                                        |)
                                      ]
                                    |)))
                                |),
                                ltac:(M.monadic
                                  (M.call_closure (|
                                    Ty.path "bool",
                                    M.get_trait_method (|
                                      "core::cmp::PartialEq",
                                      Ty.apply
                                        (Ty.path "alloc::vec::Vec")
                                        []
                                        [
                                          Ty.path "move_binary_format::file_format::ModuleHandle";
                                          Ty.path "alloc::alloc::Global"
                                        ],
                                      [],
                                      [
                                        Ty.apply
                                          (Ty.path "alloc::vec::Vec")
                                          []
                                          [
                                            Ty.path "move_binary_format::file_format::ModuleHandle";
                                            Ty.path "alloc::alloc::Global"
                                          ]
                                      ],
                                      "eq",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.SubPointer.get_struct_record_field (|
                                          M.deref (| M.read (| self |) |),
                                          "move_binary_format::file_format::CompiledModule",
                                          "friend_decls"
                                        |)
                                      |);
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.SubPointer.get_struct_record_field (|
                                          M.deref (| M.read (| other |) |),
                                          "move_binary_format::file_format::CompiledModule",
                                          "friend_decls"
                                        |)
                                      |)
                                    ]
                                  |)))
                              |),
                              ltac:(M.monadic
                                (M.call_closure (|
                                  Ty.path "bool",
                                  M.get_trait_method (|
                                    "core::cmp::PartialEq",
                                    Ty.apply
                                      (Ty.path "alloc::vec::Vec")
                                      []
                                      [
                                        Ty.path
                                          "move_binary_format::file_format::StructDefInstantiation";
                                        Ty.path "alloc::alloc::Global"
                                      ],
                                    [],
                                    [
                                      Ty.apply
                                        (Ty.path "alloc::vec::Vec")
                                        []
                                        [
                                          Ty.path
                                            "move_binary_format::file_format::StructDefInstantiation";
                                          Ty.path "alloc::alloc::Global"
                                        ]
                                    ],
                                    "eq",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.SubPointer.get_struct_record_field (|
                                        M.deref (| M.read (| self |) |),
                                        "move_binary_format::file_format::CompiledModule",
                                        "struct_def_instantiations"
                                      |)
                                    |);
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.SubPointer.get_struct_record_field (|
                                        M.deref (| M.read (| other |) |),
                                        "move_binary_format::file_format::CompiledModule",
                                        "struct_def_instantiations"
                                      |)
                                    |)
                                  ]
                                |)))
                            |),
                            ltac:(M.monadic
                              (M.call_closure (|
                                Ty.path "bool",
                                M.get_trait_method (|
                                  "core::cmp::PartialEq",
                                  Ty.apply
                                    (Ty.path "alloc::vec::Vec")
                                    []
                                    [
                                      Ty.path
                                        "move_binary_format::file_format::FunctionInstantiation";
                                      Ty.path "alloc::alloc::Global"
                                    ],
                                  [],
                                  [
                                    Ty.apply
                                      (Ty.path "alloc::vec::Vec")
                                      []
                                      [
                                        Ty.path
                                          "move_binary_format::file_format::FunctionInstantiation";
                                        Ty.path "alloc::alloc::Global"
                                      ]
                                  ],
                                  "eq",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "move_binary_format::file_format::CompiledModule",
                                      "function_instantiations"
                                    |)
                                  |);
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| other |) |),
                                      "move_binary_format::file_format::CompiledModule",
                                      "function_instantiations"
                                    |)
                                  |)
                                ]
                              |)))
                          |),
                          ltac:(M.monadic
                            (M.call_closure (|
                              Ty.path "bool",
                              M.get_trait_method (|
                                "core::cmp::PartialEq",
                                Ty.apply
                                  (Ty.path "alloc::vec::Vec")
                                  []
                                  [
                                    Ty.path "move_binary_format::file_format::FieldInstantiation";
                                    Ty.path "alloc::alloc::Global"
                                  ],
                                [],
                                [
                                  Ty.apply
                                    (Ty.path "alloc::vec::Vec")
                                    []
                                    [
                                      Ty.path "move_binary_format::file_format::FieldInstantiation";
                                      Ty.path "alloc::alloc::Global"
                                    ]
                                ],
                                "eq",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "move_binary_format::file_format::CompiledModule",
                                    "field_instantiations"
                                  |)
                                |);
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| other |) |),
                                    "move_binary_format::file_format::CompiledModule",
                                    "field_instantiations"
                                  |)
                                |)
                              ]
                            |)))
                        |),
                        ltac:(M.monadic
                          (M.call_closure (|
                            Ty.path "bool",
                            M.get_trait_method (|
                              "core::cmp::PartialEq",
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                []
                                [
                                  Ty.path "move_binary_format::file_format::Signature";
                                  Ty.path "alloc::alloc::Global"
                                ],
                              [],
                              [
                                Ty.apply
                                  (Ty.path "alloc::vec::Vec")
                                  []
                                  [
                                    Ty.path "move_binary_format::file_format::Signature";
                                    Ty.path "alloc::alloc::Global"
                                  ]
                              ],
                              "eq",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "move_binary_format::file_format::CompiledModule",
                                  "signatures"
                                |)
                              |);
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| other |) |),
                                  "move_binary_format::file_format::CompiledModule",
                                  "signatures"
                                |)
                              |)
                            ]
                          |)))
                      |),
                      ltac:(M.monadic
                        (M.call_closure (|
                          Ty.path "bool",
                          M.get_trait_method (|
                            "core::cmp::PartialEq",
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              []
                              [
                                Ty.path "move_core_types::identifier::Identifier";
                                Ty.path "alloc::alloc::Global"
                              ],
                            [],
                            [
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                []
                                [
                                  Ty.path "move_core_types::identifier::Identifier";
                                  Ty.path "alloc::alloc::Global"
                                ]
                            ],
                            "eq",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "move_binary_format::file_format::CompiledModule",
                                "identifiers"
                              |)
                            |);
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| other |) |),
                                "move_binary_format::file_format::CompiledModule",
                                "identifiers"
                              |)
                            |)
                          ]
                        |)))
                    |),
                    ltac:(M.monadic
                      (M.call_closure (|
                        Ty.path "bool",
                        M.get_trait_method (|
                          "core::cmp::PartialEq",
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            []
                            [
                              Ty.path "move_core_types::account_address::AccountAddress";
                              Ty.path "alloc::alloc::Global"
                            ],
                          [],
                          [
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              []
                              [
                                Ty.path "move_core_types::account_address::AccountAddress";
                                Ty.path "alloc::alloc::Global"
                              ]
                          ],
                          "eq",
                          [],
                          []
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "move_binary_format::file_format::CompiledModule",
                              "address_identifiers"
                            |)
                          |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| other |) |),
                              "move_binary_format::file_format::CompiledModule",
                              "address_identifiers"
                            |)
                          |)
                        ]
                      |)))
                  |),
                  ltac:(M.monadic
                    (M.call_closure (|
                      Ty.path "bool",
                      M.get_trait_method (|
                        "core::cmp::PartialEq",
                        Ty.apply
                          (Ty.path "alloc::vec::Vec")
                          []
                          [
                            Ty.path "move_binary_format::file_format::Constant";
                            Ty.path "alloc::alloc::Global"
                          ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            []
                            [
                              Ty.path "move_binary_format::file_format::Constant";
                              Ty.path "alloc::alloc::Global"
                            ]
                        ],
                        "eq",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "move_binary_format::file_format::CompiledModule",
                            "constant_pool"
                          |)
                        |);
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| other |) |),
                            "move_binary_format::file_format::CompiledModule",
                            "constant_pool"
                          |)
                        |)
                      ]
                    |)))
                |),
                ltac:(M.monadic
                  (M.call_closure (|
                    Ty.path "bool",
                    M.get_trait_method (|
                      "core::cmp::PartialEq",
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        []
                        [
                          Ty.path "move_core_types::metadata::Metadata";
                          Ty.path "alloc::alloc::Global"
                        ],
                      [],
                      [
                        Ty.apply
                          (Ty.path "alloc::vec::Vec")
                          []
                          [
                            Ty.path "move_core_types::metadata::Metadata";
                            Ty.path "alloc::alloc::Global"
                          ]
                      ],
                      "eq",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "move_binary_format::file_format::CompiledModule",
                          "metadata"
                        |)
                      |);
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| other |) |),
                          "move_binary_format::file_format::CompiledModule",
                          "metadata"
                        |)
                      |)
                    ]
                  |)))
              |),
              ltac:(M.monadic
                (M.call_closure (|
                  Ty.path "bool",
                  M.get_trait_method (|
                    "core::cmp::PartialEq",
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      []
                      [
                        Ty.path "move_binary_format::file_format::StructDefinition";
                        Ty.path "alloc::alloc::Global"
                      ],
                    [],
                    [
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        []
                        [
                          Ty.path "move_binary_format::file_format::StructDefinition";
                          Ty.path "alloc::alloc::Global"
                        ]
                    ],
                    "eq",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "move_binary_format::file_format::CompiledModule",
                        "struct_defs"
                      |)
                    |);
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| other |) |),
                        "move_binary_format::file_format::CompiledModule",
                        "struct_defs"
                      |)
                    |)
                  ]
                |)))
            |),
            ltac:(M.monadic
              (M.call_closure (|
                Ty.path "bool",
                M.get_trait_method (|
                  "core::cmp::PartialEq",
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [
                      Ty.path "move_binary_format::file_format::FunctionDefinition";
                      Ty.path "alloc::alloc::Global"
                    ],
                  [],
                  [
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      []
                      [
                        Ty.path "move_binary_format::file_format::FunctionDefinition";
                        Ty.path "alloc::alloc::Global"
                      ]
                  ],
                  "eq",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "move_binary_format::file_format::CompiledModule",
                      "function_defs"
                    |)
                  |);
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| other |) |),
                      "move_binary_format::file_format::CompiledModule",
                      "function_defs"
                    |)
                  |)
                ]
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "move_binary_format::file_format::CompiledModule" ]
        Self
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_move_binary_format_file_format_CompiledModule_for_move_binary_format_file_format_CompiledModule.
  
  Module Impl_move_binary_format_file_format_CompiledModule.
    Definition Self : Ty.t := Ty.path "move_binary_format::file_format::CompiledModule".
    
    (*
        pub fn kind_count(&self, kind: IndexKind) -> usize {
            debug_assert!(!matches!(
                kind,
                IndexKind::LocalPool
                    | IndexKind::CodeDefinition
                    | IndexKind::FieldDefinition
                    | IndexKind::TypeParameter
                    | IndexKind::MemberCount
            ));
            match kind {
                IndexKind::ModuleHandle => self.module_handles.len(),
                IndexKind::StructHandle => self.struct_handles.len(),
                IndexKind::FunctionHandle => self.function_handles.len(),
                IndexKind::FieldHandle => self.field_handles.len(),
                IndexKind::FriendDeclaration => self.friend_decls.len(),
                IndexKind::StructDefInstantiation => self.struct_def_instantiations.len(),
                IndexKind::FunctionInstantiation => self.function_instantiations.len(),
                IndexKind::FieldInstantiation => self.field_instantiations.len(),
                IndexKind::StructDefinition => self.struct_defs.len(),
                IndexKind::FunctionDefinition => self.function_defs.len(),
                IndexKind::Signature => self.signatures.len(),
                IndexKind::Identifier => self.identifiers.len(),
                IndexKind::AddressIdentifier => self.address_identifiers.len(),
                IndexKind::ConstantPool => self.constant_pool.len(),
                // XXX these two don't seem to belong here
                other @ IndexKind::LocalPool
                | other @ IndexKind::CodeDefinition
                | other @ IndexKind::FieldDefinition
                | other @ IndexKind::TypeParameter
                | other @ IndexKind::MemberCount => unreachable!("invalid kind for count: {:?}", other),
            }
        }
    *)
    Definition kind_count (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; kind ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let kind := M.alloc (| kind |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.read (|
                M.match_operator (|
                  Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.use (M.alloc (| Value.Bool true |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        let~ _ : Ty.tuple [] :=
                          M.read (|
                            M.match_operator (|
                              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                              M.alloc (| Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ :=
                                      M.use
                                        (M.alloc (|
                                          UnOp.not (|
                                            UnOp.not (|
                                              M.read (|
                                                M.match_operator (|
                                                  Ty.apply (Ty.path "*") [] [ Ty.path "bool" ],
                                                  kind,
                                                  [
                                                    fun γ =>
                                                      ltac:(M.monadic
                                                        (M.find_or_pattern (Ty.tuple []) (|
                                                          γ,
                                                          [
                                                            fun γ =>
                                                              ltac:(M.monadic
                                                                (let _ :=
                                                                  M.is_struct_tuple (|
                                                                    γ,
                                                                    "move_binary_format::IndexKind::LocalPool"
                                                                  |) in
                                                                Value.Tuple []));
                                                            fun γ =>
                                                              ltac:(M.monadic
                                                                (let _ :=
                                                                  M.is_struct_tuple (|
                                                                    γ,
                                                                    "move_binary_format::IndexKind::CodeDefinition"
                                                                  |) in
                                                                Value.Tuple []));
                                                            fun γ =>
                                                              ltac:(M.monadic
                                                                (let _ :=
                                                                  M.is_struct_tuple (|
                                                                    γ,
                                                                    "move_binary_format::IndexKind::FieldDefinition"
                                                                  |) in
                                                                Value.Tuple []));
                                                            fun γ =>
                                                              ltac:(M.monadic
                                                                (let _ :=
                                                                  M.is_struct_tuple (|
                                                                    γ,
                                                                    "move_binary_format::IndexKind::TypeParameter"
                                                                  |) in
                                                                Value.Tuple []));
                                                            fun γ =>
                                                              ltac:(M.monadic
                                                                (let _ :=
                                                                  M.is_struct_tuple (|
                                                                    γ,
                                                                    "move_binary_format::IndexKind::MemberCount"
                                                                  |) in
                                                                Value.Tuple []))
                                                          ],
                                                          fun γ =>
                                                            ltac:(M.monadic
                                                              match γ with
                                                              | [] =>
                                                                ltac:(M.monadic
                                                                  (M.alloc (| Value.Bool true |)))
                                                              | _ =>
                                                                M.impossible
                                                                  "wrong number of arguments"
                                                              end)
                                                        |)));
                                                    fun γ =>
                                                      ltac:(M.monadic
                                                        (M.alloc (| Value.Bool false |)))
                                                  ]
                                                |)
                                              |)
                                            |)
                                          |)
                                        |)) in
                                    let _ :=
                                      is_constant_or_break_match (|
                                        M.read (| γ |),
                                        Value.Bool true
                                      |) in
                                    M.alloc (|
                                      M.never_to_any (|
                                        M.call_closure (|
                                          Ty.path "never",
                                          M.get_function (| "core::panicking::panic", [], [] |),
                                          [
                                            mk_str (|
                                              "assertion failed: !matches!(kind, IndexKind::LocalPool | IndexKind::CodeDefinition |
        IndexKind::FieldDefinition | IndexKind::TypeParameter |
        IndexKind::MemberCount)"
                                            |)
                                          ]
                                        |)
                                      |)
                                    |)));
                                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                              ]
                            |)
                          |) in
                        M.alloc (| Value.Tuple [] |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |)
              |) in
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.path "usize" ],
              kind,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_struct_tuple (| γ, "move_binary_format::IndexKind::ModuleHandle" |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.path "usize",
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            []
                            [
                              Ty.path "move_binary_format::file_format::ModuleHandle";
                              Ty.path "alloc::alloc::Global"
                            ],
                          "len",
                          [],
                          []
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "move_binary_format::file_format::CompiledModule",
                              "module_handles"
                            |)
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_struct_tuple (| γ, "move_binary_format::IndexKind::StructHandle" |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.path "usize",
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            []
                            [
                              Ty.path "move_binary_format::file_format::StructHandle";
                              Ty.path "alloc::alloc::Global"
                            ],
                          "len",
                          [],
                          []
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "move_binary_format::file_format::CompiledModule",
                              "struct_handles"
                            |)
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_struct_tuple (| γ, "move_binary_format::IndexKind::FunctionHandle" |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.path "usize",
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            []
                            [
                              Ty.path "move_binary_format::file_format::FunctionHandle";
                              Ty.path "alloc::alloc::Global"
                            ],
                          "len",
                          [],
                          []
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "move_binary_format::file_format::CompiledModule",
                              "function_handles"
                            |)
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_struct_tuple (| γ, "move_binary_format::IndexKind::FieldHandle" |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.path "usize",
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            []
                            [
                              Ty.path "move_binary_format::file_format::FieldHandle";
                              Ty.path "alloc::alloc::Global"
                            ],
                          "len",
                          [],
                          []
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "move_binary_format::file_format::CompiledModule",
                              "field_handles"
                            |)
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "move_binary_format::IndexKind::FriendDeclaration"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.path "usize",
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            []
                            [
                              Ty.path "move_binary_format::file_format::ModuleHandle";
                              Ty.path "alloc::alloc::Global"
                            ],
                          "len",
                          [],
                          []
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "move_binary_format::file_format::CompiledModule",
                              "friend_decls"
                            |)
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "move_binary_format::IndexKind::StructDefInstantiation"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.path "usize",
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            []
                            [
                              Ty.path "move_binary_format::file_format::StructDefInstantiation";
                              Ty.path "alloc::alloc::Global"
                            ],
                          "len",
                          [],
                          []
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "move_binary_format::file_format::CompiledModule",
                              "struct_def_instantiations"
                            |)
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "move_binary_format::IndexKind::FunctionInstantiation"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.path "usize",
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            []
                            [
                              Ty.path "move_binary_format::file_format::FunctionInstantiation";
                              Ty.path "alloc::alloc::Global"
                            ],
                          "len",
                          [],
                          []
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "move_binary_format::file_format::CompiledModule",
                              "function_instantiations"
                            |)
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "move_binary_format::IndexKind::FieldInstantiation"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.path "usize",
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            []
                            [
                              Ty.path "move_binary_format::file_format::FieldInstantiation";
                              Ty.path "alloc::alloc::Global"
                            ],
                          "len",
                          [],
                          []
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "move_binary_format::file_format::CompiledModule",
                              "field_instantiations"
                            |)
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "move_binary_format::IndexKind::StructDefinition"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.path "usize",
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            []
                            [
                              Ty.path "move_binary_format::file_format::StructDefinition";
                              Ty.path "alloc::alloc::Global"
                            ],
                          "len",
                          [],
                          []
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "move_binary_format::file_format::CompiledModule",
                              "struct_defs"
                            |)
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "move_binary_format::IndexKind::FunctionDefinition"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.path "usize",
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            []
                            [
                              Ty.path "move_binary_format::file_format::FunctionDefinition";
                              Ty.path "alloc::alloc::Global"
                            ],
                          "len",
                          [],
                          []
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "move_binary_format::file_format::CompiledModule",
                              "function_defs"
                            |)
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_struct_tuple (| γ, "move_binary_format::IndexKind::Signature" |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.path "usize",
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            []
                            [
                              Ty.path "move_binary_format::file_format::Signature";
                              Ty.path "alloc::alloc::Global"
                            ],
                          "len",
                          [],
                          []
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "move_binary_format::file_format::CompiledModule",
                              "signatures"
                            |)
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_struct_tuple (| γ, "move_binary_format::IndexKind::Identifier" |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.path "usize",
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            []
                            [
                              Ty.path "move_core_types::identifier::Identifier";
                              Ty.path "alloc::alloc::Global"
                            ],
                          "len",
                          [],
                          []
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "move_binary_format::file_format::CompiledModule",
                              "identifiers"
                            |)
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "move_binary_format::IndexKind::AddressIdentifier"
                      |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.path "usize",
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            []
                            [
                              Ty.path "move_core_types::account_address::AccountAddress";
                              Ty.path "alloc::alloc::Global"
                            ],
                          "len",
                          [],
                          []
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "move_binary_format::file_format::CompiledModule",
                              "address_identifiers"
                            |)
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let _ :=
                      M.is_struct_tuple (| γ, "move_binary_format::IndexKind::ConstantPool" |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.path "usize",
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            []
                            [
                              Ty.path "move_binary_format::file_format::Constant";
                              Ty.path "alloc::alloc::Global"
                            ],
                          "len",
                          [],
                          []
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "move_binary_format::file_format::CompiledModule",
                              "constant_pool"
                            |)
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.find_or_pattern (Ty.tuple [ Ty.path "move_binary_format::IndexKind" ]) (|
                      γ,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let other := M.copy (| γ |) in
                            let _ :=
                              M.is_struct_tuple (|
                                γ,
                                "move_binary_format::IndexKind::LocalPool"
                              |) in
                            Value.Tuple [ other ]));
                        fun γ =>
                          ltac:(M.monadic
                            (let other := M.copy (| γ |) in
                            let _ :=
                              M.is_struct_tuple (|
                                γ,
                                "move_binary_format::IndexKind::CodeDefinition"
                              |) in
                            Value.Tuple [ other ]));
                        fun γ =>
                          ltac:(M.monadic
                            (let other := M.copy (| γ |) in
                            let _ :=
                              M.is_struct_tuple (|
                                γ,
                                "move_binary_format::IndexKind::FieldDefinition"
                              |) in
                            Value.Tuple [ other ]));
                        fun γ =>
                          ltac:(M.monadic
                            (let other := M.copy (| γ |) in
                            let _ :=
                              M.is_struct_tuple (|
                                γ,
                                "move_binary_format::IndexKind::TypeParameter"
                              |) in
                            Value.Tuple [ other ]));
                        fun γ =>
                          ltac:(M.monadic
                            (let other := M.copy (| γ |) in
                            let _ :=
                              M.is_struct_tuple (|
                                γ,
                                "move_binary_format::IndexKind::MemberCount"
                              |) in
                            Value.Tuple [ other ]))
                      ],
                      fun γ =>
                        ltac:(M.monadic
                          match γ with
                          | [ other ] =>
                            ltac:(M.monadic
                              (M.alloc (|
                                M.never_to_any (|
                                  M.call_closure (|
                                    Ty.path "never",
                                    M.get_function (| "core::panicking::panic_fmt", [], [] |),
                                    [
                                      M.call_closure (|
                                        Ty.path "core::fmt::Arguments",
                                        M.get_associated_function (|
                                          Ty.path "core::fmt::Arguments",
                                          "new_v1",
                                          [
                                            Value.Integer IntegerKind.Usize 1;
                                            Value.Integer IntegerKind.Usize 1
                                          ],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (|
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.alloc (|
                                                  Value.Array
                                                    [
                                                      mk_str (|
                                                        "internal error: entered unreachable code: invalid kind for count: "
                                                      |)
                                                    ]
                                                |)
                                              |)
                                            |)
                                          |);
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (|
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.alloc (|
                                                  Value.Array
                                                    [
                                                      M.call_closure (|
                                                        Ty.path "core::fmt::rt::Argument",
                                                        M.get_associated_function (|
                                                          Ty.path "core::fmt::rt::Argument",
                                                          "new_debug",
                                                          [],
                                                          [ Ty.path "move_binary_format::IndexKind"
                                                          ]
                                                        |),
                                                        [
                                                          M.borrow (|
                                                            Pointer.Kind.Ref,
                                                            M.deref (|
                                                              M.borrow (| Pointer.Kind.Ref, other |)
                                                            |)
                                                          |)
                                                        ]
                                                      |)
                                                    ]
                                                |)
                                              |)
                                            |)
                                          |)
                                        ]
                                      |)
                                    ]
                                  |)
                                |)
                              |)))
                          | _ => M.impossible "wrong number of arguments"
                          end)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_kind_count :
      M.IsAssociatedFunction.C Self "kind_count" kind_count.
    Admitted.
    Global Typeclasses Opaque kind_count.
    
    (*
        pub fn self_handle_idx(&self) -> ModuleHandleIndex {
            self.self_module_handle_idx
        }
    *)
    Definition self_handle_idx (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.SubPointer.get_struct_record_field (|
              M.deref (| M.read (| self |) |),
              "move_binary_format::file_format::CompiledModule",
              "self_module_handle_idx"
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_self_handle_idx :
      M.IsAssociatedFunction.C Self "self_handle_idx" self_handle_idx.
    Admitted.
    Global Typeclasses Opaque self_handle_idx.
    
    (*
        pub fn self_handle(&self) -> &ModuleHandle {
            let handle = self.module_handle_at(self.self_handle_idx());
            debug_assert!(handle.address.into_index() < self.address_identifiers.len()); // invariant
            debug_assert!(handle.name.into_index() < self.identifiers.len()); // invariant
            handle
        }
    *)
    Definition self_handle (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let~ handle :
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.path "move_binary_format::file_format::ModuleHandle" ] :=
              M.call_closure (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.path "move_binary_format::file_format::ModuleHandle" ],
                M.get_associated_function (|
                  Ty.path "move_binary_format::file_format::CompiledModule",
                  "module_handle_at",
                  [],
                  []
                |),
                [
                  M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                  M.call_closure (|
                    Ty.path "move_binary_format::file_format::ModuleHandleIndex",
                    M.get_associated_function (|
                      Ty.path "move_binary_format::file_format::CompiledModule",
                      "self_handle_idx",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                  |)
                ]
              |) in
            let~ _ : Ty.tuple [] :=
              M.read (|
                M.match_operator (|
                  Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.use (M.alloc (| Value.Bool true |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        let~ _ : Ty.tuple [] :=
                          M.read (|
                            M.match_operator (|
                              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                              M.alloc (| Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ :=
                                      M.use
                                        (M.alloc (|
                                          UnOp.not (|
                                            M.call_closure (|
                                              Ty.path "bool",
                                              BinOp.lt,
                                              [
                                                M.call_closure (|
                                                  Ty.path "usize",
                                                  M.get_trait_method (|
                                                    "move_binary_format::internals::ModuleIndex",
                                                    Ty.path
                                                      "move_binary_format::file_format::AddressIdentifierIndex",
                                                    [],
                                                    [],
                                                    "into_index",
                                                    [],
                                                    []
                                                  |),
                                                  [
                                                    M.read (|
                                                      M.SubPointer.get_struct_record_field (|
                                                        M.deref (| M.read (| handle |) |),
                                                        "move_binary_format::file_format::ModuleHandle",
                                                        "address"
                                                      |)
                                                    |)
                                                  ]
                                                |);
                                                M.call_closure (|
                                                  Ty.path "usize",
                                                  M.get_associated_function (|
                                                    Ty.apply
                                                      (Ty.path "alloc::vec::Vec")
                                                      []
                                                      [
                                                        Ty.path
                                                          "move_core_types::account_address::AccountAddress";
                                                        Ty.path "alloc::alloc::Global"
                                                      ],
                                                    "len",
                                                    [],
                                                    []
                                                  |),
                                                  [
                                                    M.borrow (|
                                                      Pointer.Kind.Ref,
                                                      M.SubPointer.get_struct_record_field (|
                                                        M.deref (| M.read (| self |) |),
                                                        "move_binary_format::file_format::CompiledModule",
                                                        "address_identifiers"
                                                      |)
                                                    |)
                                                  ]
                                                |)
                                              ]
                                            |)
                                          |)
                                        |)) in
                                    let _ :=
                                      is_constant_or_break_match (|
                                        M.read (| γ |),
                                        Value.Bool true
                                      |) in
                                    M.alloc (|
                                      M.never_to_any (|
                                        M.call_closure (|
                                          Ty.path "never",
                                          M.get_function (| "core::panicking::panic", [], [] |),
                                          [
                                            mk_str (|
                                              "assertion failed: handle.address.into_index() < self.address_identifiers.len()"
                                            |)
                                          ]
                                        |)
                                      |)
                                    |)));
                                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                              ]
                            |)
                          |) in
                        M.alloc (| Value.Tuple [] |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |)
              |) in
            let~ _ : Ty.tuple [] :=
              M.read (|
                M.match_operator (|
                  Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.use (M.alloc (| Value.Bool true |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        let~ _ : Ty.tuple [] :=
                          M.read (|
                            M.match_operator (|
                              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                              M.alloc (| Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ :=
                                      M.use
                                        (M.alloc (|
                                          UnOp.not (|
                                            M.call_closure (|
                                              Ty.path "bool",
                                              BinOp.lt,
                                              [
                                                M.call_closure (|
                                                  Ty.path "usize",
                                                  M.get_trait_method (|
                                                    "move_binary_format::internals::ModuleIndex",
                                                    Ty.path
                                                      "move_binary_format::file_format::IdentifierIndex",
                                                    [],
                                                    [],
                                                    "into_index",
                                                    [],
                                                    []
                                                  |),
                                                  [
                                                    M.read (|
                                                      M.SubPointer.get_struct_record_field (|
                                                        M.deref (| M.read (| handle |) |),
                                                        "move_binary_format::file_format::ModuleHandle",
                                                        "name"
                                                      |)
                                                    |)
                                                  ]
                                                |);
                                                M.call_closure (|
                                                  Ty.path "usize",
                                                  M.get_associated_function (|
                                                    Ty.apply
                                                      (Ty.path "alloc::vec::Vec")
                                                      []
                                                      [
                                                        Ty.path
                                                          "move_core_types::identifier::Identifier";
                                                        Ty.path "alloc::alloc::Global"
                                                      ],
                                                    "len",
                                                    [],
                                                    []
                                                  |),
                                                  [
                                                    M.borrow (|
                                                      Pointer.Kind.Ref,
                                                      M.SubPointer.get_struct_record_field (|
                                                        M.deref (| M.read (| self |) |),
                                                        "move_binary_format::file_format::CompiledModule",
                                                        "identifiers"
                                                      |)
                                                    |)
                                                  ]
                                                |)
                                              ]
                                            |)
                                          |)
                                        |)) in
                                    let _ :=
                                      is_constant_or_break_match (|
                                        M.read (| γ |),
                                        Value.Bool true
                                      |) in
                                    M.alloc (|
                                      M.never_to_any (|
                                        M.call_closure (|
                                          Ty.path "never",
                                          M.get_function (| "core::panicking::panic", [], [] |),
                                          [
                                            mk_str (|
                                              "assertion failed: handle.name.into_index() < self.identifiers.len()"
                                            |)
                                          ]
                                        |)
                                      |)
                                    |)));
                                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                              ]
                            |)
                          |) in
                        M.alloc (| Value.Tuple [] |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |)
              |) in
            M.alloc (| M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| handle |) |) |) |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_self_handle :
      M.IsAssociatedFunction.C Self "self_handle" self_handle.
    Admitted.
    Global Typeclasses Opaque self_handle.
    
    (*
        pub fn name(&self) -> &IdentStr {
            self.identifier_at(self.self_handle().name)
        }
    *)
    Definition name (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.borrow (|
            Pointer.Kind.Ref,
            M.deref (|
              M.call_closure (|
                Ty.apply (Ty.path "&") [] [ Ty.path "move_core_types::identifier::IdentStr" ],
                M.get_associated_function (|
                  Ty.path "move_binary_format::file_format::CompiledModule",
                  "identifier_at",
                  [],
                  []
                |),
                [
                  M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.path "move_binary_format::file_format::ModuleHandle" ],
                          M.get_associated_function (|
                            Ty.path "move_binary_format::file_format::CompiledModule",
                            "self_handle",
                            [],
                            []
                          |),
                          [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                        |)
                      |),
                      "move_binary_format::file_format::ModuleHandle",
                      "name"
                    |)
                  |)
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_name : M.IsAssociatedFunction.C Self "name" name.
    Admitted.
    Global Typeclasses Opaque name.
    
    (*
        pub fn address(&self) -> &AccountAddress {
            self.address_identifier_at(self.self_handle().address)
        }
    *)
    Definition address (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.borrow (|
            Pointer.Kind.Ref,
            M.deref (|
              M.call_closure (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.path "move_core_types::account_address::AccountAddress" ],
                M.get_associated_function (|
                  Ty.path "move_binary_format::file_format::CompiledModule",
                  "address_identifier_at",
                  [],
                  []
                |),
                [
                  M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.path "move_binary_format::file_format::ModuleHandle" ],
                          M.get_associated_function (|
                            Ty.path "move_binary_format::file_format::CompiledModule",
                            "self_handle",
                            [],
                            []
                          |),
                          [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                        |)
                      |),
                      "move_binary_format::file_format::ModuleHandle",
                      "address"
                    |)
                  |)
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_address : M.IsAssociatedFunction.C Self "address" address.
    Admitted.
    Global Typeclasses Opaque address.
    
    (*
        pub fn struct_name(&self, idx: StructDefinitionIndex) -> &IdentStr {
            let struct_def = self.struct_def_at(idx);
            let handle = self.struct_handle_at(struct_def.struct_handle);
            self.identifier_at(handle.name)
        }
    *)
    Definition struct_name (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; idx ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let idx := M.alloc (| idx |) in
          M.read (|
            let~ struct_def :
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.path "move_binary_format::file_format::StructDefinition" ] :=
              M.call_closure (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.path "move_binary_format::file_format::StructDefinition" ],
                M.get_associated_function (|
                  Ty.path "move_binary_format::file_format::CompiledModule",
                  "struct_def_at",
                  [],
                  []
                |),
                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |); M.read (| idx |)
                ]
              |) in
            let~ handle :
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.path "move_binary_format::file_format::StructHandle" ] :=
              M.call_closure (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.path "move_binary_format::file_format::StructHandle" ],
                M.get_associated_function (|
                  Ty.path "move_binary_format::file_format::CompiledModule",
                  "struct_handle_at",
                  [],
                  []
                |),
                [
                  M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| struct_def |) |),
                      "move_binary_format::file_format::StructDefinition",
                      "struct_handle"
                    |)
                  |)
                ]
              |) in
            M.alloc (|
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ Ty.path "move_core_types::identifier::IdentStr" ],
                    M.get_associated_function (|
                      Ty.path "move_binary_format::file_format::CompiledModule",
                      "identifier_at",
                      [],
                      []
                    |),
                    [
                      M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| handle |) |),
                          "move_binary_format::file_format::StructHandle",
                          "name"
                        |)
                      |)
                    ]
                  |)
                |)
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_struct_name :
      M.IsAssociatedFunction.C Self "struct_name" struct_name.
    Admitted.
    Global Typeclasses Opaque struct_name.
    
    (*
        pub fn module_handle_at(&self, idx: ModuleHandleIndex) -> &ModuleHandle {
            let handle = &self.module_handles[idx.into_index()];
            debug_assert!(handle.address.into_index() < self.address_identifiers.len()); // invariant
            debug_assert!(handle.name.into_index() < self.identifiers.len()); // invariant
            handle
        }
    *)
    Definition module_handle_at (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; idx ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let idx := M.alloc (| idx |) in
          M.read (|
            let~ handle :
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.path "move_binary_format::file_format::ModuleHandle" ] :=
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "&")
                      []
                      [ Ty.path "move_binary_format::file_format::ModuleHandle" ],
                    M.get_trait_method (|
                      "core::ops::index::Index",
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        []
                        [
                          Ty.path "move_binary_format::file_format::ModuleHandle";
                          Ty.path "alloc::alloc::Global"
                        ],
                      [],
                      [ Ty.path "usize" ],
                      "index",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "move_binary_format::file_format::CompiledModule",
                          "module_handles"
                        |)
                      |);
                      M.call_closure (|
                        Ty.path "usize",
                        M.get_trait_method (|
                          "move_binary_format::internals::ModuleIndex",
                          Ty.path "move_binary_format::file_format::ModuleHandleIndex",
                          [],
                          [],
                          "into_index",
                          [],
                          []
                        |),
                        [ M.read (| idx |) ]
                      |)
                    ]
                  |)
                |)
              |) in
            let~ _ : Ty.tuple [] :=
              M.read (|
                M.match_operator (|
                  Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.use (M.alloc (| Value.Bool true |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        let~ _ : Ty.tuple [] :=
                          M.read (|
                            M.match_operator (|
                              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                              M.alloc (| Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ :=
                                      M.use
                                        (M.alloc (|
                                          UnOp.not (|
                                            M.call_closure (|
                                              Ty.path "bool",
                                              BinOp.lt,
                                              [
                                                M.call_closure (|
                                                  Ty.path "usize",
                                                  M.get_trait_method (|
                                                    "move_binary_format::internals::ModuleIndex",
                                                    Ty.path
                                                      "move_binary_format::file_format::AddressIdentifierIndex",
                                                    [],
                                                    [],
                                                    "into_index",
                                                    [],
                                                    []
                                                  |),
                                                  [
                                                    M.read (|
                                                      M.SubPointer.get_struct_record_field (|
                                                        M.deref (| M.read (| handle |) |),
                                                        "move_binary_format::file_format::ModuleHandle",
                                                        "address"
                                                      |)
                                                    |)
                                                  ]
                                                |);
                                                M.call_closure (|
                                                  Ty.path "usize",
                                                  M.get_associated_function (|
                                                    Ty.apply
                                                      (Ty.path "alloc::vec::Vec")
                                                      []
                                                      [
                                                        Ty.path
                                                          "move_core_types::account_address::AccountAddress";
                                                        Ty.path "alloc::alloc::Global"
                                                      ],
                                                    "len",
                                                    [],
                                                    []
                                                  |),
                                                  [
                                                    M.borrow (|
                                                      Pointer.Kind.Ref,
                                                      M.SubPointer.get_struct_record_field (|
                                                        M.deref (| M.read (| self |) |),
                                                        "move_binary_format::file_format::CompiledModule",
                                                        "address_identifiers"
                                                      |)
                                                    |)
                                                  ]
                                                |)
                                              ]
                                            |)
                                          |)
                                        |)) in
                                    let _ :=
                                      is_constant_or_break_match (|
                                        M.read (| γ |),
                                        Value.Bool true
                                      |) in
                                    M.alloc (|
                                      M.never_to_any (|
                                        M.call_closure (|
                                          Ty.path "never",
                                          M.get_function (| "core::panicking::panic", [], [] |),
                                          [
                                            mk_str (|
                                              "assertion failed: handle.address.into_index() < self.address_identifiers.len()"
                                            |)
                                          ]
                                        |)
                                      |)
                                    |)));
                                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                              ]
                            |)
                          |) in
                        M.alloc (| Value.Tuple [] |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |)
              |) in
            let~ _ : Ty.tuple [] :=
              M.read (|
                M.match_operator (|
                  Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.use (M.alloc (| Value.Bool true |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        let~ _ : Ty.tuple [] :=
                          M.read (|
                            M.match_operator (|
                              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                              M.alloc (| Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ :=
                                      M.use
                                        (M.alloc (|
                                          UnOp.not (|
                                            M.call_closure (|
                                              Ty.path "bool",
                                              BinOp.lt,
                                              [
                                                M.call_closure (|
                                                  Ty.path "usize",
                                                  M.get_trait_method (|
                                                    "move_binary_format::internals::ModuleIndex",
                                                    Ty.path
                                                      "move_binary_format::file_format::IdentifierIndex",
                                                    [],
                                                    [],
                                                    "into_index",
                                                    [],
                                                    []
                                                  |),
                                                  [
                                                    M.read (|
                                                      M.SubPointer.get_struct_record_field (|
                                                        M.deref (| M.read (| handle |) |),
                                                        "move_binary_format::file_format::ModuleHandle",
                                                        "name"
                                                      |)
                                                    |)
                                                  ]
                                                |);
                                                M.call_closure (|
                                                  Ty.path "usize",
                                                  M.get_associated_function (|
                                                    Ty.apply
                                                      (Ty.path "alloc::vec::Vec")
                                                      []
                                                      [
                                                        Ty.path
                                                          "move_core_types::identifier::Identifier";
                                                        Ty.path "alloc::alloc::Global"
                                                      ],
                                                    "len",
                                                    [],
                                                    []
                                                  |),
                                                  [
                                                    M.borrow (|
                                                      Pointer.Kind.Ref,
                                                      M.SubPointer.get_struct_record_field (|
                                                        M.deref (| M.read (| self |) |),
                                                        "move_binary_format::file_format::CompiledModule",
                                                        "identifiers"
                                                      |)
                                                    |)
                                                  ]
                                                |)
                                              ]
                                            |)
                                          |)
                                        |)) in
                                    let _ :=
                                      is_constant_or_break_match (|
                                        M.read (| γ |),
                                        Value.Bool true
                                      |) in
                                    M.alloc (|
                                      M.never_to_any (|
                                        M.call_closure (|
                                          Ty.path "never",
                                          M.get_function (| "core::panicking::panic", [], [] |),
                                          [
                                            mk_str (|
                                              "assertion failed: handle.name.into_index() < self.identifiers.len()"
                                            |)
                                          ]
                                        |)
                                      |)
                                    |)));
                                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                              ]
                            |)
                          |) in
                        M.alloc (| Value.Tuple [] |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |)
              |) in
            M.alloc (| M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| handle |) |) |) |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_module_handle_at :
      M.IsAssociatedFunction.C Self "module_handle_at" module_handle_at.
    Admitted.
    Global Typeclasses Opaque module_handle_at.
    
    (*
        pub fn struct_handle_at(&self, idx: StructHandleIndex) -> &StructHandle {
            let handle = &self.struct_handles[idx.into_index()];
            debug_assert!(handle.module.into_index() < self.module_handles.len()); // invariant
            handle
        }
    *)
    Definition struct_handle_at (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; idx ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let idx := M.alloc (| idx |) in
          M.read (|
            let~ handle :
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.path "move_binary_format::file_format::StructHandle" ] :=
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "&")
                      []
                      [ Ty.path "move_binary_format::file_format::StructHandle" ],
                    M.get_trait_method (|
                      "core::ops::index::Index",
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        []
                        [
                          Ty.path "move_binary_format::file_format::StructHandle";
                          Ty.path "alloc::alloc::Global"
                        ],
                      [],
                      [ Ty.path "usize" ],
                      "index",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "move_binary_format::file_format::CompiledModule",
                          "struct_handles"
                        |)
                      |);
                      M.call_closure (|
                        Ty.path "usize",
                        M.get_trait_method (|
                          "move_binary_format::internals::ModuleIndex",
                          Ty.path "move_binary_format::file_format::StructHandleIndex",
                          [],
                          [],
                          "into_index",
                          [],
                          []
                        |),
                        [ M.read (| idx |) ]
                      |)
                    ]
                  |)
                |)
              |) in
            let~ _ : Ty.tuple [] :=
              M.read (|
                M.match_operator (|
                  Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.use (M.alloc (| Value.Bool true |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        let~ _ : Ty.tuple [] :=
                          M.read (|
                            M.match_operator (|
                              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                              M.alloc (| Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ :=
                                      M.use
                                        (M.alloc (|
                                          UnOp.not (|
                                            M.call_closure (|
                                              Ty.path "bool",
                                              BinOp.lt,
                                              [
                                                M.call_closure (|
                                                  Ty.path "usize",
                                                  M.get_trait_method (|
                                                    "move_binary_format::internals::ModuleIndex",
                                                    Ty.path
                                                      "move_binary_format::file_format::ModuleHandleIndex",
                                                    [],
                                                    [],
                                                    "into_index",
                                                    [],
                                                    []
                                                  |),
                                                  [
                                                    M.read (|
                                                      M.SubPointer.get_struct_record_field (|
                                                        M.deref (| M.read (| handle |) |),
                                                        "move_binary_format::file_format::StructHandle",
                                                        "module"
                                                      |)
                                                    |)
                                                  ]
                                                |);
                                                M.call_closure (|
                                                  Ty.path "usize",
                                                  M.get_associated_function (|
                                                    Ty.apply
                                                      (Ty.path "alloc::vec::Vec")
                                                      []
                                                      [
                                                        Ty.path
                                                          "move_binary_format::file_format::ModuleHandle";
                                                        Ty.path "alloc::alloc::Global"
                                                      ],
                                                    "len",
                                                    [],
                                                    []
                                                  |),
                                                  [
                                                    M.borrow (|
                                                      Pointer.Kind.Ref,
                                                      M.SubPointer.get_struct_record_field (|
                                                        M.deref (| M.read (| self |) |),
                                                        "move_binary_format::file_format::CompiledModule",
                                                        "module_handles"
                                                      |)
                                                    |)
                                                  ]
                                                |)
                                              ]
                                            |)
                                          |)
                                        |)) in
                                    let _ :=
                                      is_constant_or_break_match (|
                                        M.read (| γ |),
                                        Value.Bool true
                                      |) in
                                    M.alloc (|
                                      M.never_to_any (|
                                        M.call_closure (|
                                          Ty.path "never",
                                          M.get_function (| "core::panicking::panic", [], [] |),
                                          [
                                            mk_str (|
                                              "assertion failed: handle.module.into_index() < self.module_handles.len()"
                                            |)
                                          ]
                                        |)
                                      |)
                                    |)));
                                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                              ]
                            |)
                          |) in
                        M.alloc (| Value.Tuple [] |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |)
              |) in
            M.alloc (| M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| handle |) |) |) |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_struct_handle_at :
      M.IsAssociatedFunction.C Self "struct_handle_at" struct_handle_at.
    Admitted.
    Global Typeclasses Opaque struct_handle_at.
    
    (*
        pub fn function_handle_at(&self, idx: FunctionHandleIndex) -> &FunctionHandle {
            let handle = &self.function_handles[idx.into_index()];
            debug_assert!(handle.parameters.into_index() < self.signatures.len()); // invariant
            debug_assert!(handle.return_.into_index() < self.signatures.len()); // invariant
            handle
        }
    *)
    Definition function_handle_at (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; idx ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let idx := M.alloc (| idx |) in
          M.read (|
            let~ handle :
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.path "move_binary_format::file_format::FunctionHandle" ] :=
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "&")
                      []
                      [ Ty.path "move_binary_format::file_format::FunctionHandle" ],
                    M.get_trait_method (|
                      "core::ops::index::Index",
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        []
                        [
                          Ty.path "move_binary_format::file_format::FunctionHandle";
                          Ty.path "alloc::alloc::Global"
                        ],
                      [],
                      [ Ty.path "usize" ],
                      "index",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "move_binary_format::file_format::CompiledModule",
                          "function_handles"
                        |)
                      |);
                      M.call_closure (|
                        Ty.path "usize",
                        M.get_trait_method (|
                          "move_binary_format::internals::ModuleIndex",
                          Ty.path "move_binary_format::file_format::FunctionHandleIndex",
                          [],
                          [],
                          "into_index",
                          [],
                          []
                        |),
                        [ M.read (| idx |) ]
                      |)
                    ]
                  |)
                |)
              |) in
            let~ _ : Ty.tuple [] :=
              M.read (|
                M.match_operator (|
                  Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.use (M.alloc (| Value.Bool true |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        let~ _ : Ty.tuple [] :=
                          M.read (|
                            M.match_operator (|
                              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                              M.alloc (| Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ :=
                                      M.use
                                        (M.alloc (|
                                          UnOp.not (|
                                            M.call_closure (|
                                              Ty.path "bool",
                                              BinOp.lt,
                                              [
                                                M.call_closure (|
                                                  Ty.path "usize",
                                                  M.get_trait_method (|
                                                    "move_binary_format::internals::ModuleIndex",
                                                    Ty.path
                                                      "move_binary_format::file_format::SignatureIndex",
                                                    [],
                                                    [],
                                                    "into_index",
                                                    [],
                                                    []
                                                  |),
                                                  [
                                                    M.read (|
                                                      M.SubPointer.get_struct_record_field (|
                                                        M.deref (| M.read (| handle |) |),
                                                        "move_binary_format::file_format::FunctionHandle",
                                                        "parameters"
                                                      |)
                                                    |)
                                                  ]
                                                |);
                                                M.call_closure (|
                                                  Ty.path "usize",
                                                  M.get_associated_function (|
                                                    Ty.apply
                                                      (Ty.path "alloc::vec::Vec")
                                                      []
                                                      [
                                                        Ty.path
                                                          "move_binary_format::file_format::Signature";
                                                        Ty.path "alloc::alloc::Global"
                                                      ],
                                                    "len",
                                                    [],
                                                    []
                                                  |),
                                                  [
                                                    M.borrow (|
                                                      Pointer.Kind.Ref,
                                                      M.SubPointer.get_struct_record_field (|
                                                        M.deref (| M.read (| self |) |),
                                                        "move_binary_format::file_format::CompiledModule",
                                                        "signatures"
                                                      |)
                                                    |)
                                                  ]
                                                |)
                                              ]
                                            |)
                                          |)
                                        |)) in
                                    let _ :=
                                      is_constant_or_break_match (|
                                        M.read (| γ |),
                                        Value.Bool true
                                      |) in
                                    M.alloc (|
                                      M.never_to_any (|
                                        M.call_closure (|
                                          Ty.path "never",
                                          M.get_function (| "core::panicking::panic", [], [] |),
                                          [
                                            mk_str (|
                                              "assertion failed: handle.parameters.into_index() < self.signatures.len()"
                                            |)
                                          ]
                                        |)
                                      |)
                                    |)));
                                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                              ]
                            |)
                          |) in
                        M.alloc (| Value.Tuple [] |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |)
              |) in
            let~ _ : Ty.tuple [] :=
              M.read (|
                M.match_operator (|
                  Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.use (M.alloc (| Value.Bool true |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        let~ _ : Ty.tuple [] :=
                          M.read (|
                            M.match_operator (|
                              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                              M.alloc (| Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ :=
                                      M.use
                                        (M.alloc (|
                                          UnOp.not (|
                                            M.call_closure (|
                                              Ty.path "bool",
                                              BinOp.lt,
                                              [
                                                M.call_closure (|
                                                  Ty.path "usize",
                                                  M.get_trait_method (|
                                                    "move_binary_format::internals::ModuleIndex",
                                                    Ty.path
                                                      "move_binary_format::file_format::SignatureIndex",
                                                    [],
                                                    [],
                                                    "into_index",
                                                    [],
                                                    []
                                                  |),
                                                  [
                                                    M.read (|
                                                      M.SubPointer.get_struct_record_field (|
                                                        M.deref (| M.read (| handle |) |),
                                                        "move_binary_format::file_format::FunctionHandle",
                                                        "return_"
                                                      |)
                                                    |)
                                                  ]
                                                |);
                                                M.call_closure (|
                                                  Ty.path "usize",
                                                  M.get_associated_function (|
                                                    Ty.apply
                                                      (Ty.path "alloc::vec::Vec")
                                                      []
                                                      [
                                                        Ty.path
                                                          "move_binary_format::file_format::Signature";
                                                        Ty.path "alloc::alloc::Global"
                                                      ],
                                                    "len",
                                                    [],
                                                    []
                                                  |),
                                                  [
                                                    M.borrow (|
                                                      Pointer.Kind.Ref,
                                                      M.SubPointer.get_struct_record_field (|
                                                        M.deref (| M.read (| self |) |),
                                                        "move_binary_format::file_format::CompiledModule",
                                                        "signatures"
                                                      |)
                                                    |)
                                                  ]
                                                |)
                                              ]
                                            |)
                                          |)
                                        |)) in
                                    let _ :=
                                      is_constant_or_break_match (|
                                        M.read (| γ |),
                                        Value.Bool true
                                      |) in
                                    M.alloc (|
                                      M.never_to_any (|
                                        M.call_closure (|
                                          Ty.path "never",
                                          M.get_function (| "core::panicking::panic", [], [] |),
                                          [
                                            mk_str (|
                                              "assertion failed: handle.return_.into_index() < self.signatures.len()"
                                            |)
                                          ]
                                        |)
                                      |)
                                    |)));
                                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                              ]
                            |)
                          |) in
                        M.alloc (| Value.Tuple [] |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |)
              |) in
            M.alloc (| M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| handle |) |) |) |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_function_handle_at :
      M.IsAssociatedFunction.C Self "function_handle_at" function_handle_at.
    Admitted.
    Global Typeclasses Opaque function_handle_at.
    
    (*
        pub fn field_handle_at(&self, idx: FieldHandleIndex) -> &FieldHandle {
            let handle = &self.field_handles[idx.into_index()];
            debug_assert!(handle.owner.into_index() < self.struct_defs.len()); // invariant
            handle
        }
    *)
    Definition field_handle_at (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; idx ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let idx := M.alloc (| idx |) in
          M.read (|
            let~ handle :
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.path "move_binary_format::file_format::FieldHandle" ] :=
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "&")
                      []
                      [ Ty.path "move_binary_format::file_format::FieldHandle" ],
                    M.get_trait_method (|
                      "core::ops::index::Index",
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        []
                        [
                          Ty.path "move_binary_format::file_format::FieldHandle";
                          Ty.path "alloc::alloc::Global"
                        ],
                      [],
                      [ Ty.path "usize" ],
                      "index",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "move_binary_format::file_format::CompiledModule",
                          "field_handles"
                        |)
                      |);
                      M.call_closure (|
                        Ty.path "usize",
                        M.get_trait_method (|
                          "move_binary_format::internals::ModuleIndex",
                          Ty.path "move_binary_format::file_format::FieldHandleIndex",
                          [],
                          [],
                          "into_index",
                          [],
                          []
                        |),
                        [ M.read (| idx |) ]
                      |)
                    ]
                  |)
                |)
              |) in
            let~ _ : Ty.tuple [] :=
              M.read (|
                M.match_operator (|
                  Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.use (M.alloc (| Value.Bool true |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        let~ _ : Ty.tuple [] :=
                          M.read (|
                            M.match_operator (|
                              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                              M.alloc (| Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ :=
                                      M.use
                                        (M.alloc (|
                                          UnOp.not (|
                                            M.call_closure (|
                                              Ty.path "bool",
                                              BinOp.lt,
                                              [
                                                M.call_closure (|
                                                  Ty.path "usize",
                                                  M.get_trait_method (|
                                                    "move_binary_format::internals::ModuleIndex",
                                                    Ty.path
                                                      "move_binary_format::file_format::StructDefinitionIndex",
                                                    [],
                                                    [],
                                                    "into_index",
                                                    [],
                                                    []
                                                  |),
                                                  [
                                                    M.read (|
                                                      M.SubPointer.get_struct_record_field (|
                                                        M.deref (| M.read (| handle |) |),
                                                        "move_binary_format::file_format::FieldHandle",
                                                        "owner"
                                                      |)
                                                    |)
                                                  ]
                                                |);
                                                M.call_closure (|
                                                  Ty.path "usize",
                                                  M.get_associated_function (|
                                                    Ty.apply
                                                      (Ty.path "alloc::vec::Vec")
                                                      []
                                                      [
                                                        Ty.path
                                                          "move_binary_format::file_format::StructDefinition";
                                                        Ty.path "alloc::alloc::Global"
                                                      ],
                                                    "len",
                                                    [],
                                                    []
                                                  |),
                                                  [
                                                    M.borrow (|
                                                      Pointer.Kind.Ref,
                                                      M.SubPointer.get_struct_record_field (|
                                                        M.deref (| M.read (| self |) |),
                                                        "move_binary_format::file_format::CompiledModule",
                                                        "struct_defs"
                                                      |)
                                                    |)
                                                  ]
                                                |)
                                              ]
                                            |)
                                          |)
                                        |)) in
                                    let _ :=
                                      is_constant_or_break_match (|
                                        M.read (| γ |),
                                        Value.Bool true
                                      |) in
                                    M.alloc (|
                                      M.never_to_any (|
                                        M.call_closure (|
                                          Ty.path "never",
                                          M.get_function (| "core::panicking::panic", [], [] |),
                                          [
                                            mk_str (|
                                              "assertion failed: handle.owner.into_index() < self.struct_defs.len()"
                                            |)
                                          ]
                                        |)
                                      |)
                                    |)));
                                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                              ]
                            |)
                          |) in
                        M.alloc (| Value.Tuple [] |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |)
              |) in
            M.alloc (| M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| handle |) |) |) |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_field_handle_at :
      M.IsAssociatedFunction.C Self "field_handle_at" field_handle_at.
    Admitted.
    Global Typeclasses Opaque field_handle_at.
    
    (*
        pub fn struct_instantiation_at(
            &self,
            idx: StructDefInstantiationIndex,
        ) -> &StructDefInstantiation {
            &self.struct_def_instantiations[idx.into_index()]
        }
    *)
    Definition struct_instantiation_at (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; idx ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let idx := M.alloc (| idx |) in
          M.borrow (|
            Pointer.Kind.Ref,
            M.deref (|
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "&")
                      []
                      [ Ty.path "move_binary_format::file_format::StructDefInstantiation" ],
                    M.get_trait_method (|
                      "core::ops::index::Index",
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        []
                        [
                          Ty.path "move_binary_format::file_format::StructDefInstantiation";
                          Ty.path "alloc::alloc::Global"
                        ],
                      [],
                      [ Ty.path "usize" ],
                      "index",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "move_binary_format::file_format::CompiledModule",
                          "struct_def_instantiations"
                        |)
                      |);
                      M.call_closure (|
                        Ty.path "usize",
                        M.get_trait_method (|
                          "move_binary_format::internals::ModuleIndex",
                          Ty.path "move_binary_format::file_format::StructDefInstantiationIndex",
                          [],
                          [],
                          "into_index",
                          [],
                          []
                        |),
                        [ M.read (| idx |) ]
                      |)
                    ]
                  |)
                |)
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_struct_instantiation_at :
      M.IsAssociatedFunction.C Self "struct_instantiation_at" struct_instantiation_at.
    Admitted.
    Global Typeclasses Opaque struct_instantiation_at.
    
    (*
        pub fn function_instantiation_at(
            &self,
            idx: FunctionInstantiationIndex,
        ) -> &FunctionInstantiation {
            &self.function_instantiations[idx.into_index()]
        }
    *)
    Definition function_instantiation_at
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self; idx ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let idx := M.alloc (| idx |) in
          M.borrow (|
            Pointer.Kind.Ref,
            M.deref (|
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "&")
                      []
                      [ Ty.path "move_binary_format::file_format::FunctionInstantiation" ],
                    M.get_trait_method (|
                      "core::ops::index::Index",
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        []
                        [
                          Ty.path "move_binary_format::file_format::FunctionInstantiation";
                          Ty.path "alloc::alloc::Global"
                        ],
                      [],
                      [ Ty.path "usize" ],
                      "index",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "move_binary_format::file_format::CompiledModule",
                          "function_instantiations"
                        |)
                      |);
                      M.call_closure (|
                        Ty.path "usize",
                        M.get_trait_method (|
                          "move_binary_format::internals::ModuleIndex",
                          Ty.path "move_binary_format::file_format::FunctionInstantiationIndex",
                          [],
                          [],
                          "into_index",
                          [],
                          []
                        |),
                        [ M.read (| idx |) ]
                      |)
                    ]
                  |)
                |)
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_function_instantiation_at :
      M.IsAssociatedFunction.C Self "function_instantiation_at" function_instantiation_at.
    Admitted.
    Global Typeclasses Opaque function_instantiation_at.
    
    (*
        pub fn field_instantiation_at(&self, idx: FieldInstantiationIndex) -> &FieldInstantiation {
            &self.field_instantiations[idx.into_index()]
        }
    *)
    Definition field_instantiation_at (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; idx ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let idx := M.alloc (| idx |) in
          M.borrow (|
            Pointer.Kind.Ref,
            M.deref (|
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "&")
                      []
                      [ Ty.path "move_binary_format::file_format::FieldInstantiation" ],
                    M.get_trait_method (|
                      "core::ops::index::Index",
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        []
                        [
                          Ty.path "move_binary_format::file_format::FieldInstantiation";
                          Ty.path "alloc::alloc::Global"
                        ],
                      [],
                      [ Ty.path "usize" ],
                      "index",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "move_binary_format::file_format::CompiledModule",
                          "field_instantiations"
                        |)
                      |);
                      M.call_closure (|
                        Ty.path "usize",
                        M.get_trait_method (|
                          "move_binary_format::internals::ModuleIndex",
                          Ty.path "move_binary_format::file_format::FieldInstantiationIndex",
                          [],
                          [],
                          "into_index",
                          [],
                          []
                        |),
                        [ M.read (| idx |) ]
                      |)
                    ]
                  |)
                |)
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_field_instantiation_at :
      M.IsAssociatedFunction.C Self "field_instantiation_at" field_instantiation_at.
    Admitted.
    Global Typeclasses Opaque field_instantiation_at.
    
    (*
        pub fn signature_at(&self, idx: SignatureIndex) -> &Signature {
            &self.signatures[idx.into_index()]
        }
    *)
    Definition signature_at (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; idx ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let idx := M.alloc (| idx |) in
          M.borrow (|
            Pointer.Kind.Ref,
            M.deref (|
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "&")
                      []
                      [ Ty.path "move_binary_format::file_format::Signature" ],
                    M.get_trait_method (|
                      "core::ops::index::Index",
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        []
                        [
                          Ty.path "move_binary_format::file_format::Signature";
                          Ty.path "alloc::alloc::Global"
                        ],
                      [],
                      [ Ty.path "usize" ],
                      "index",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "move_binary_format::file_format::CompiledModule",
                          "signatures"
                        |)
                      |);
                      M.call_closure (|
                        Ty.path "usize",
                        M.get_trait_method (|
                          "move_binary_format::internals::ModuleIndex",
                          Ty.path "move_binary_format::file_format::SignatureIndex",
                          [],
                          [],
                          "into_index",
                          [],
                          []
                        |),
                        [ M.read (| idx |) ]
                      |)
                    ]
                  |)
                |)
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_signature_at :
      M.IsAssociatedFunction.C Self "signature_at" signature_at.
    Admitted.
    Global Typeclasses Opaque signature_at.
    
    (*
        pub fn identifier_at(&self, idx: IdentifierIndex) -> &IdentStr {
            &self.identifiers[idx.into_index()]
        }
    *)
    Definition identifier_at (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; idx ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let idx := M.alloc (| idx |) in
          M.borrow (|
            Pointer.Kind.Ref,
            M.deref (|
              M.call_closure (|
                Ty.apply (Ty.path "&") [] [ Ty.path "move_core_types::identifier::IdentStr" ],
                M.get_trait_method (|
                  "core::ops::deref::Deref",
                  Ty.path "move_core_types::identifier::Identifier",
                  [],
                  [],
                  "deref",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.path "move_core_types::identifier::Identifier" ],
                            M.get_trait_method (|
                              "core::ops::index::Index",
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                []
                                [
                                  Ty.path "move_core_types::identifier::Identifier";
                                  Ty.path "alloc::alloc::Global"
                                ],
                              [],
                              [ Ty.path "usize" ],
                              "index",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "move_binary_format::file_format::CompiledModule",
                                  "identifiers"
                                |)
                              |);
                              M.call_closure (|
                                Ty.path "usize",
                                M.get_trait_method (|
                                  "move_binary_format::internals::ModuleIndex",
                                  Ty.path "move_binary_format::file_format::IdentifierIndex",
                                  [],
                                  [],
                                  "into_index",
                                  [],
                                  []
                                |),
                                [ M.read (| idx |) ]
                              |)
                            ]
                          |)
                        |)
                      |)
                    |)
                  |)
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_identifier_at :
      M.IsAssociatedFunction.C Self "identifier_at" identifier_at.
    Admitted.
    Global Typeclasses Opaque identifier_at.
    
    (*
        pub fn address_identifier_at(&self, idx: AddressIdentifierIndex) -> &AccountAddress {
            &self.address_identifiers[idx.into_index()]
        }
    *)
    Definition address_identifier_at (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; idx ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let idx := M.alloc (| idx |) in
          M.borrow (|
            Pointer.Kind.Ref,
            M.deref (|
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "&")
                      []
                      [ Ty.path "move_core_types::account_address::AccountAddress" ],
                    M.get_trait_method (|
                      "core::ops::index::Index",
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        []
                        [
                          Ty.path "move_core_types::account_address::AccountAddress";
                          Ty.path "alloc::alloc::Global"
                        ],
                      [],
                      [ Ty.path "usize" ],
                      "index",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "move_binary_format::file_format::CompiledModule",
                          "address_identifiers"
                        |)
                      |);
                      M.call_closure (|
                        Ty.path "usize",
                        M.get_trait_method (|
                          "move_binary_format::internals::ModuleIndex",
                          Ty.path "move_binary_format::file_format::AddressIdentifierIndex",
                          [],
                          [],
                          "into_index",
                          [],
                          []
                        |),
                        [ M.read (| idx |) ]
                      |)
                    ]
                  |)
                |)
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_address_identifier_at :
      M.IsAssociatedFunction.C Self "address_identifier_at" address_identifier_at.
    Admitted.
    Global Typeclasses Opaque address_identifier_at.
    
    (*
        pub fn constant_at(&self, idx: ConstantPoolIndex) -> &Constant {
            &self.constant_pool[idx.into_index()]
        }
    *)
    Definition constant_at (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; idx ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let idx := M.alloc (| idx |) in
          M.borrow (|
            Pointer.Kind.Ref,
            M.deref (|
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "&")
                      []
                      [ Ty.path "move_binary_format::file_format::Constant" ],
                    M.get_trait_method (|
                      "core::ops::index::Index",
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        []
                        [
                          Ty.path "move_binary_format::file_format::Constant";
                          Ty.path "alloc::alloc::Global"
                        ],
                      [],
                      [ Ty.path "usize" ],
                      "index",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "move_binary_format::file_format::CompiledModule",
                          "constant_pool"
                        |)
                      |);
                      M.call_closure (|
                        Ty.path "usize",
                        M.get_trait_method (|
                          "move_binary_format::internals::ModuleIndex",
                          Ty.path "move_binary_format::file_format::ConstantPoolIndex",
                          [],
                          [],
                          "into_index",
                          [],
                          []
                        |),
                        [ M.read (| idx |) ]
                      |)
                    ]
                  |)
                |)
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_constant_at :
      M.IsAssociatedFunction.C Self "constant_at" constant_at.
    Admitted.
    Global Typeclasses Opaque constant_at.
    
    (*
        pub fn struct_def_at(&self, idx: StructDefinitionIndex) -> &StructDefinition {
            &self.struct_defs[idx.into_index()]
        }
    *)
    Definition struct_def_at (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; idx ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let idx := M.alloc (| idx |) in
          M.borrow (|
            Pointer.Kind.Ref,
            M.deref (|
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "&")
                      []
                      [ Ty.path "move_binary_format::file_format::StructDefinition" ],
                    M.get_trait_method (|
                      "core::ops::index::Index",
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        []
                        [
                          Ty.path "move_binary_format::file_format::StructDefinition";
                          Ty.path "alloc::alloc::Global"
                        ],
                      [],
                      [ Ty.path "usize" ],
                      "index",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "move_binary_format::file_format::CompiledModule",
                          "struct_defs"
                        |)
                      |);
                      M.call_closure (|
                        Ty.path "usize",
                        M.get_trait_method (|
                          "move_binary_format::internals::ModuleIndex",
                          Ty.path "move_binary_format::file_format::StructDefinitionIndex",
                          [],
                          [],
                          "into_index",
                          [],
                          []
                        |),
                        [ M.read (| idx |) ]
                      |)
                    ]
                  |)
                |)
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_struct_def_at :
      M.IsAssociatedFunction.C Self "struct_def_at" struct_def_at.
    Admitted.
    Global Typeclasses Opaque struct_def_at.
    
    (*
        pub fn function_def_at(&self, idx: FunctionDefinitionIndex) -> &FunctionDefinition {
            let result = &self.function_defs[idx.into_index()];
            debug_assert!(result.function.into_index() < self.function_handles().len()); // invariant
            debug_assert!(match &result.code {
                Some(code) => code.locals.into_index() < self.signatures().len(),
                None => true,
            }); // invariant
            result
        }
    *)
    Definition function_def_at (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; idx ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let idx := M.alloc (| idx |) in
          M.read (|
            let~ result :
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.path "move_binary_format::file_format::FunctionDefinition" ] :=
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "&")
                      []
                      [ Ty.path "move_binary_format::file_format::FunctionDefinition" ],
                    M.get_trait_method (|
                      "core::ops::index::Index",
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        []
                        [
                          Ty.path "move_binary_format::file_format::FunctionDefinition";
                          Ty.path "alloc::alloc::Global"
                        ],
                      [],
                      [ Ty.path "usize" ],
                      "index",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "move_binary_format::file_format::CompiledModule",
                          "function_defs"
                        |)
                      |);
                      M.call_closure (|
                        Ty.path "usize",
                        M.get_trait_method (|
                          "move_binary_format::internals::ModuleIndex",
                          Ty.path "move_binary_format::file_format::FunctionDefinitionIndex",
                          [],
                          [],
                          "into_index",
                          [],
                          []
                        |),
                        [ M.read (| idx |) ]
                      |)
                    ]
                  |)
                |)
              |) in
            let~ _ : Ty.tuple [] :=
              M.read (|
                M.match_operator (|
                  Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.use (M.alloc (| Value.Bool true |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        let~ _ : Ty.tuple [] :=
                          M.read (|
                            M.match_operator (|
                              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                              M.alloc (| Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ :=
                                      M.use
                                        (M.alloc (|
                                          UnOp.not (|
                                            M.call_closure (|
                                              Ty.path "bool",
                                              BinOp.lt,
                                              [
                                                M.call_closure (|
                                                  Ty.path "usize",
                                                  M.get_trait_method (|
                                                    "move_binary_format::internals::ModuleIndex",
                                                    Ty.path
                                                      "move_binary_format::file_format::FunctionHandleIndex",
                                                    [],
                                                    [],
                                                    "into_index",
                                                    [],
                                                    []
                                                  |),
                                                  [
                                                    M.read (|
                                                      M.SubPointer.get_struct_record_field (|
                                                        M.deref (| M.read (| result |) |),
                                                        "move_binary_format::file_format::FunctionDefinition",
                                                        "function"
                                                      |)
                                                    |)
                                                  ]
                                                |);
                                                M.call_closure (|
                                                  Ty.path "usize",
                                                  M.get_associated_function (|
                                                    Ty.apply
                                                      (Ty.path "slice")
                                                      []
                                                      [
                                                        Ty.path
                                                          "move_binary_format::file_format::FunctionHandle"
                                                      ],
                                                    "len",
                                                    [],
                                                    []
                                                  |),
                                                  [
                                                    M.borrow (|
                                                      Pointer.Kind.Ref,
                                                      M.deref (|
                                                        M.call_closure (|
                                                          Ty.apply
                                                            (Ty.path "&")
                                                            []
                                                            [
                                                              Ty.apply
                                                                (Ty.path "slice")
                                                                []
                                                                [
                                                                  Ty.path
                                                                    "move_binary_format::file_format::FunctionHandle"
                                                                ]
                                                            ],
                                                          M.get_associated_function (|
                                                            Ty.path
                                                              "move_binary_format::file_format::CompiledModule",
                                                            "function_handles",
                                                            [],
                                                            []
                                                          |),
                                                          [
                                                            M.borrow (|
                                                              Pointer.Kind.Ref,
                                                              M.deref (| M.read (| self |) |)
                                                            |)
                                                          ]
                                                        |)
                                                      |)
                                                    |)
                                                  ]
                                                |)
                                              ]
                                            |)
                                          |)
                                        |)) in
                                    let _ :=
                                      is_constant_or_break_match (|
                                        M.read (| γ |),
                                        Value.Bool true
                                      |) in
                                    M.alloc (|
                                      M.never_to_any (|
                                        M.call_closure (|
                                          Ty.path "never",
                                          M.get_function (| "core::panicking::panic", [], [] |),
                                          [
                                            mk_str (|
                                              "assertion failed: result.function.into_index() < self.function_handles().len()"
                                            |)
                                          ]
                                        |)
                                      |)
                                    |)));
                                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                              ]
                            |)
                          |) in
                        M.alloc (| Value.Tuple [] |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |)
              |) in
            let~ _ : Ty.tuple [] :=
              M.read (|
                M.match_operator (|
                  Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.use (M.alloc (| Value.Bool true |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        let~ _ : Ty.tuple [] :=
                          M.read (|
                            M.match_operator (|
                              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                              M.alloc (| Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ :=
                                      M.use
                                        (M.alloc (|
                                          UnOp.not (|
                                            M.read (|
                                              M.match_operator (|
                                                Ty.apply (Ty.path "*") [] [ Ty.path "bool" ],
                                                M.alloc (|
                                                  M.borrow (|
                                                    Pointer.Kind.Ref,
                                                    M.SubPointer.get_struct_record_field (|
                                                      M.deref (| M.read (| result |) |),
                                                      "move_binary_format::file_format::FunctionDefinition",
                                                      "code"
                                                    |)
                                                  |)
                                                |),
                                                [
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (let γ := M.read (| γ |) in
                                                      let γ1_0 :=
                                                        M.SubPointer.get_struct_tuple_field (|
                                                          γ,
                                                          "core::option::Option::Some",
                                                          0
                                                        |) in
                                                      let code := M.alloc (| γ1_0 |) in
                                                      M.alloc (|
                                                        M.call_closure (|
                                                          Ty.path "bool",
                                                          BinOp.lt,
                                                          [
                                                            M.call_closure (|
                                                              Ty.path "usize",
                                                              M.get_trait_method (|
                                                                "move_binary_format::internals::ModuleIndex",
                                                                Ty.path
                                                                  "move_binary_format::file_format::SignatureIndex",
                                                                [],
                                                                [],
                                                                "into_index",
                                                                [],
                                                                []
                                                              |),
                                                              [
                                                                M.read (|
                                                                  M.SubPointer.get_struct_record_field (|
                                                                    M.deref (| M.read (| code |) |),
                                                                    "move_binary_format::file_format::CodeUnit",
                                                                    "locals"
                                                                  |)
                                                                |)
                                                              ]
                                                            |);
                                                            M.call_closure (|
                                                              Ty.path "usize",
                                                              M.get_associated_function (|
                                                                Ty.apply
                                                                  (Ty.path "slice")
                                                                  []
                                                                  [
                                                                    Ty.path
                                                                      "move_binary_format::file_format::Signature"
                                                                  ],
                                                                "len",
                                                                [],
                                                                []
                                                              |),
                                                              [
                                                                M.borrow (|
                                                                  Pointer.Kind.Ref,
                                                                  M.deref (|
                                                                    M.call_closure (|
                                                                      Ty.apply
                                                                        (Ty.path "&")
                                                                        []
                                                                        [
                                                                          Ty.apply
                                                                            (Ty.path "slice")
                                                                            []
                                                                            [
                                                                              Ty.path
                                                                                "move_binary_format::file_format::Signature"
                                                                            ]
                                                                        ],
                                                                      M.get_associated_function (|
                                                                        Ty.path
                                                                          "move_binary_format::file_format::CompiledModule",
                                                                        "signatures",
                                                                        [],
                                                                        []
                                                                      |),
                                                                      [
                                                                        M.borrow (|
                                                                          Pointer.Kind.Ref,
                                                                          M.deref (|
                                                                            M.read (| self |)
                                                                          |)
                                                                        |)
                                                                      ]
                                                                    |)
                                                                  |)
                                                                |)
                                                              ]
                                                            |)
                                                          ]
                                                        |)
                                                      |)));
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (let γ := M.read (| γ |) in
                                                      let _ :=
                                                        M.is_struct_tuple (|
                                                          γ,
                                                          "core::option::Option::None"
                                                        |) in
                                                      M.alloc (| Value.Bool true |)))
                                                ]
                                              |)
                                            |)
                                          |)
                                        |)) in
                                    let _ :=
                                      is_constant_or_break_match (|
                                        M.read (| γ |),
                                        Value.Bool true
                                      |) in
                                    M.alloc (|
                                      M.never_to_any (|
                                        M.call_closure (|
                                          Ty.path "never",
                                          M.get_function (| "core::panicking::panic", [], [] |),
                                          [
                                            mk_str (|
                                              "assertion failed: match &result.code {
    Some(code) => code.locals.into_index() < self.signatures().len(),
    None => true,
}"
                                            |)
                                          ]
                                        |)
                                      |)
                                    |)));
                                fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                              ]
                            |)
                          |) in
                        M.alloc (| Value.Tuple [] |)));
                    fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                  ]
                |)
              |) in
            M.alloc (| M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| result |) |) |) |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_function_def_at :
      M.IsAssociatedFunction.C Self "function_def_at" function_def_at.
    Admitted.
    Global Typeclasses Opaque function_def_at.
    
    (*
        pub fn module_handles(&self) -> &[ModuleHandle] {
            &self.module_handles
        }
    *)
    Definition module_handles (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.borrow (|
            Pointer.Kind.Ref,
            M.deref (|
              M.call_closure (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path "slice")
                      []
                      [ Ty.path "move_binary_format::file_format::ModuleHandle" ]
                  ],
                M.get_trait_method (|
                  "core::ops::deref::Deref",
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [
                      Ty.path "move_binary_format::file_format::ModuleHandle";
                      Ty.path "alloc::alloc::Global"
                    ],
                  [],
                  [],
                  "deref",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "move_binary_format::file_format::CompiledModule",
                          "module_handles"
                        |)
                      |)
                    |)
                  |)
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_module_handles :
      M.IsAssociatedFunction.C Self "module_handles" module_handles.
    Admitted.
    Global Typeclasses Opaque module_handles.
    
    (*
        pub fn struct_handles(&self) -> &[StructHandle] {
            &self.struct_handles
        }
    *)
    Definition struct_handles (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.borrow (|
            Pointer.Kind.Ref,
            M.deref (|
              M.call_closure (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path "slice")
                      []
                      [ Ty.path "move_binary_format::file_format::StructHandle" ]
                  ],
                M.get_trait_method (|
                  "core::ops::deref::Deref",
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [
                      Ty.path "move_binary_format::file_format::StructHandle";
                      Ty.path "alloc::alloc::Global"
                    ],
                  [],
                  [],
                  "deref",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "move_binary_format::file_format::CompiledModule",
                          "struct_handles"
                        |)
                      |)
                    |)
                  |)
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_struct_handles :
      M.IsAssociatedFunction.C Self "struct_handles" struct_handles.
    Admitted.
    Global Typeclasses Opaque struct_handles.
    
    (*
        pub fn function_handles(&self) -> &[FunctionHandle] {
            &self.function_handles
        }
    *)
    Definition function_handles (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.borrow (|
            Pointer.Kind.Ref,
            M.deref (|
              M.call_closure (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path "slice")
                      []
                      [ Ty.path "move_binary_format::file_format::FunctionHandle" ]
                  ],
                M.get_trait_method (|
                  "core::ops::deref::Deref",
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [
                      Ty.path "move_binary_format::file_format::FunctionHandle";
                      Ty.path "alloc::alloc::Global"
                    ],
                  [],
                  [],
                  "deref",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "move_binary_format::file_format::CompiledModule",
                          "function_handles"
                        |)
                      |)
                    |)
                  |)
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_function_handles :
      M.IsAssociatedFunction.C Self "function_handles" function_handles.
    Admitted.
    Global Typeclasses Opaque function_handles.
    
    (*
        pub fn field_handles(&self) -> &[FieldHandle] {
            &self.field_handles
        }
    *)
    Definition field_handles (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.borrow (|
            Pointer.Kind.Ref,
            M.deref (|
              M.call_closure (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path "slice")
                      []
                      [ Ty.path "move_binary_format::file_format::FieldHandle" ]
                  ],
                M.get_trait_method (|
                  "core::ops::deref::Deref",
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [
                      Ty.path "move_binary_format::file_format::FieldHandle";
                      Ty.path "alloc::alloc::Global"
                    ],
                  [],
                  [],
                  "deref",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "move_binary_format::file_format::CompiledModule",
                          "field_handles"
                        |)
                      |)
                    |)
                  |)
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_field_handles :
      M.IsAssociatedFunction.C Self "field_handles" field_handles.
    Admitted.
    Global Typeclasses Opaque field_handles.
    
    (*
        pub fn struct_instantiations(&self) -> &[StructDefInstantiation] {
            &self.struct_def_instantiations
        }
    *)
    Definition struct_instantiations (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.borrow (|
            Pointer.Kind.Ref,
            M.deref (|
              M.call_closure (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path "slice")
                      []
                      [ Ty.path "move_binary_format::file_format::StructDefInstantiation" ]
                  ],
                M.get_trait_method (|
                  "core::ops::deref::Deref",
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [
                      Ty.path "move_binary_format::file_format::StructDefInstantiation";
                      Ty.path "alloc::alloc::Global"
                    ],
                  [],
                  [],
                  "deref",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "move_binary_format::file_format::CompiledModule",
                          "struct_def_instantiations"
                        |)
                      |)
                    |)
                  |)
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_struct_instantiations :
      M.IsAssociatedFunction.C Self "struct_instantiations" struct_instantiations.
    Admitted.
    Global Typeclasses Opaque struct_instantiations.
    
    (*
        pub fn function_instantiations(&self) -> &[FunctionInstantiation] {
            &self.function_instantiations
        }
    *)
    Definition function_instantiations (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.borrow (|
            Pointer.Kind.Ref,
            M.deref (|
              M.call_closure (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path "slice")
                      []
                      [ Ty.path "move_binary_format::file_format::FunctionInstantiation" ]
                  ],
                M.get_trait_method (|
                  "core::ops::deref::Deref",
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [
                      Ty.path "move_binary_format::file_format::FunctionInstantiation";
                      Ty.path "alloc::alloc::Global"
                    ],
                  [],
                  [],
                  "deref",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "move_binary_format::file_format::CompiledModule",
                          "function_instantiations"
                        |)
                      |)
                    |)
                  |)
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_function_instantiations :
      M.IsAssociatedFunction.C Self "function_instantiations" function_instantiations.
    Admitted.
    Global Typeclasses Opaque function_instantiations.
    
    (*
        pub fn field_instantiations(&self) -> &[FieldInstantiation] {
            &self.field_instantiations
        }
    *)
    Definition field_instantiations (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.borrow (|
            Pointer.Kind.Ref,
            M.deref (|
              M.call_closure (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path "slice")
                      []
                      [ Ty.path "move_binary_format::file_format::FieldInstantiation" ]
                  ],
                M.get_trait_method (|
                  "core::ops::deref::Deref",
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [
                      Ty.path "move_binary_format::file_format::FieldInstantiation";
                      Ty.path "alloc::alloc::Global"
                    ],
                  [],
                  [],
                  "deref",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "move_binary_format::file_format::CompiledModule",
                          "field_instantiations"
                        |)
                      |)
                    |)
                  |)
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_field_instantiations :
      M.IsAssociatedFunction.C Self "field_instantiations" field_instantiations.
    Admitted.
    Global Typeclasses Opaque field_instantiations.
    
    (*
        pub fn signatures(&self) -> &[Signature] {
            &self.signatures
        }
    *)
    Definition signatures (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.borrow (|
            Pointer.Kind.Ref,
            M.deref (|
              M.call_closure (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path "slice")
                      []
                      [ Ty.path "move_binary_format::file_format::Signature" ]
                  ],
                M.get_trait_method (|
                  "core::ops::deref::Deref",
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [
                      Ty.path "move_binary_format::file_format::Signature";
                      Ty.path "alloc::alloc::Global"
                    ],
                  [],
                  [],
                  "deref",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "move_binary_format::file_format::CompiledModule",
                          "signatures"
                        |)
                      |)
                    |)
                  |)
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_signatures :
      M.IsAssociatedFunction.C Self "signatures" signatures.
    Admitted.
    Global Typeclasses Opaque signatures.
    
    (*
        pub fn constant_pool(&self) -> &[Constant] {
            &self.constant_pool
        }
    *)
    Definition constant_pool (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.borrow (|
            Pointer.Kind.Ref,
            M.deref (|
              M.call_closure (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path "slice")
                      []
                      [ Ty.path "move_binary_format::file_format::Constant" ]
                  ],
                M.get_trait_method (|
                  "core::ops::deref::Deref",
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [
                      Ty.path "move_binary_format::file_format::Constant";
                      Ty.path "alloc::alloc::Global"
                    ],
                  [],
                  [],
                  "deref",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "move_binary_format::file_format::CompiledModule",
                          "constant_pool"
                        |)
                      |)
                    |)
                  |)
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_constant_pool :
      M.IsAssociatedFunction.C Self "constant_pool" constant_pool.
    Admitted.
    Global Typeclasses Opaque constant_pool.
    
    (*
        pub fn identifiers(&self) -> &[Identifier] {
            &self.identifiers
        }
    *)
    Definition identifiers (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.borrow (|
            Pointer.Kind.Ref,
            M.deref (|
              M.call_closure (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path "slice")
                      []
                      [ Ty.path "move_core_types::identifier::Identifier" ]
                  ],
                M.get_trait_method (|
                  "core::ops::deref::Deref",
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [
                      Ty.path "move_core_types::identifier::Identifier";
                      Ty.path "alloc::alloc::Global"
                    ],
                  [],
                  [],
                  "deref",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "move_binary_format::file_format::CompiledModule",
                          "identifiers"
                        |)
                      |)
                    |)
                  |)
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_identifiers :
      M.IsAssociatedFunction.C Self "identifiers" identifiers.
    Admitted.
    Global Typeclasses Opaque identifiers.
    
    (*
        pub fn address_identifiers(&self) -> &[AccountAddress] {
            &self.address_identifiers
        }
    *)
    Definition address_identifiers (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.borrow (|
            Pointer.Kind.Ref,
            M.deref (|
              M.call_closure (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path "slice")
                      []
                      [ Ty.path "move_core_types::account_address::AccountAddress" ]
                  ],
                M.get_trait_method (|
                  "core::ops::deref::Deref",
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [
                      Ty.path "move_core_types::account_address::AccountAddress";
                      Ty.path "alloc::alloc::Global"
                    ],
                  [],
                  [],
                  "deref",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "move_binary_format::file_format::CompiledModule",
                          "address_identifiers"
                        |)
                      |)
                    |)
                  |)
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_address_identifiers :
      M.IsAssociatedFunction.C Self "address_identifiers" address_identifiers.
    Admitted.
    Global Typeclasses Opaque address_identifiers.
    
    (*
        pub fn struct_defs(&self) -> &[StructDefinition] {
            &self.struct_defs
        }
    *)
    Definition struct_defs (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.borrow (|
            Pointer.Kind.Ref,
            M.deref (|
              M.call_closure (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path "slice")
                      []
                      [ Ty.path "move_binary_format::file_format::StructDefinition" ]
                  ],
                M.get_trait_method (|
                  "core::ops::deref::Deref",
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [
                      Ty.path "move_binary_format::file_format::StructDefinition";
                      Ty.path "alloc::alloc::Global"
                    ],
                  [],
                  [],
                  "deref",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "move_binary_format::file_format::CompiledModule",
                          "struct_defs"
                        |)
                      |)
                    |)
                  |)
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_struct_defs :
      M.IsAssociatedFunction.C Self "struct_defs" struct_defs.
    Admitted.
    Global Typeclasses Opaque struct_defs.
    
    (*
        pub fn function_defs(&self) -> &[FunctionDefinition] {
            &self.function_defs
        }
    *)
    Definition function_defs (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.borrow (|
            Pointer.Kind.Ref,
            M.deref (|
              M.call_closure (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path "slice")
                      []
                      [ Ty.path "move_binary_format::file_format::FunctionDefinition" ]
                  ],
                M.get_trait_method (|
                  "core::ops::deref::Deref",
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [
                      Ty.path "move_binary_format::file_format::FunctionDefinition";
                      Ty.path "alloc::alloc::Global"
                    ],
                  [],
                  [],
                  "deref",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "move_binary_format::file_format::CompiledModule",
                          "function_defs"
                        |)
                      |)
                    |)
                  |)
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_function_defs :
      M.IsAssociatedFunction.C Self "function_defs" function_defs.
    Admitted.
    Global Typeclasses Opaque function_defs.
    
    (*
        pub fn friend_decls(&self) -> &[ModuleHandle] {
            &self.friend_decls
        }
    *)
    Definition friend_decls (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.borrow (|
            Pointer.Kind.Ref,
            M.deref (|
              M.call_closure (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path "slice")
                      []
                      [ Ty.path "move_binary_format::file_format::ModuleHandle" ]
                  ],
                M.get_trait_method (|
                  "core::ops::deref::Deref",
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [
                      Ty.path "move_binary_format::file_format::ModuleHandle";
                      Ty.path "alloc::alloc::Global"
                    ],
                  [],
                  [],
                  "deref",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "move_binary_format::file_format::CompiledModule",
                          "friend_decls"
                        |)
                      |)
                    |)
                  |)
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_friend_decls :
      M.IsAssociatedFunction.C Self "friend_decls" friend_decls.
    Admitted.
    Global Typeclasses Opaque friend_decls.
    
    (*
        pub fn version(&self) -> u32 {
            self.version
        }
    *)
    Definition version (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.SubPointer.get_struct_record_field (|
              M.deref (| M.read (| self |) |),
              "move_binary_format::file_format::CompiledModule",
              "version"
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_version : M.IsAssociatedFunction.C Self "version" version.
    Admitted.
    Global Typeclasses Opaque version.
    
    (*
        pub fn immediate_dependencies(&self) -> Vec<ModuleId> {
            let self_handle = self.self_handle();
            self.module_handles()
                .iter()
                .filter(|&handle| handle != self_handle)
                .map(|handle| self.module_id_for_handle(handle))
                .collect()
        }
    *)
    Definition immediate_dependencies (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let~ self_handle :
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.path "move_binary_format::file_format::ModuleHandle" ] :=
              M.call_closure (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.path "move_binary_format::file_format::ModuleHandle" ],
                M.get_associated_function (|
                  Ty.path "move_binary_format::file_format::CompiledModule",
                  "self_handle",
                  [],
                  []
                |),
                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
              |) in
            M.alloc (|
              M.call_closure (|
                Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  []
                  [
                    Ty.path "move_core_types::language_storage::ModuleId";
                    Ty.path "alloc::alloc::Global"
                  ],
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  Ty.apply
                    (Ty.path "core::iter::adapters::map::Map")
                    []
                    [
                      Ty.apply
                        (Ty.path "core::iter::adapters::filter::Filter")
                        []
                        [
                          Ty.apply
                            (Ty.path "core::slice::iter::Iter")
                            []
                            [ Ty.path "move_binary_format::file_format::ModuleHandle" ];
                          Ty.function
                            [
                              Ty.tuple
                                [
                                  Ty.apply
                                    (Ty.path "&")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "&")
                                        []
                                        [ Ty.path "move_binary_format::file_format::ModuleHandle" ]
                                    ]
                                ]
                            ]
                            (Ty.path "bool")
                        ];
                      Ty.function
                        [
                          Ty.tuple
                            [
                              Ty.apply
                                (Ty.path "&")
                                []
                                [ Ty.path "move_binary_format::file_format::ModuleHandle" ]
                            ]
                        ]
                        (Ty.path "move_core_types::language_storage::ModuleId")
                    ],
                  [],
                  [],
                  "collect",
                  [],
                  [
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      []
                      [
                        Ty.path "move_core_types::language_storage::ModuleId";
                        Ty.path "alloc::alloc::Global"
                      ]
                  ]
                |),
                [
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::iter::adapters::map::Map")
                      []
                      [
                        Ty.apply
                          (Ty.path "core::iter::adapters::filter::Filter")
                          []
                          [
                            Ty.apply
                              (Ty.path "core::slice::iter::Iter")
                              []
                              [ Ty.path "move_binary_format::file_format::ModuleHandle" ];
                            Ty.function
                              [
                                Ty.tuple
                                  [
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "&")
                                          []
                                          [ Ty.path "move_binary_format::file_format::ModuleHandle"
                                          ]
                                      ]
                                  ]
                              ]
                              (Ty.path "bool")
                          ];
                        Ty.function
                          [
                            Ty.tuple
                              [
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [ Ty.path "move_binary_format::file_format::ModuleHandle" ]
                              ]
                          ]
                          (Ty.path "move_core_types::language_storage::ModuleId")
                      ],
                    M.get_trait_method (|
                      "core::iter::traits::iterator::Iterator",
                      Ty.apply
                        (Ty.path "core::iter::adapters::filter::Filter")
                        []
                        [
                          Ty.apply
                            (Ty.path "core::slice::iter::Iter")
                            []
                            [ Ty.path "move_binary_format::file_format::ModuleHandle" ];
                          Ty.function
                            [
                              Ty.tuple
                                [
                                  Ty.apply
                                    (Ty.path "&")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "&")
                                        []
                                        [ Ty.path "move_binary_format::file_format::ModuleHandle" ]
                                    ]
                                ]
                            ]
                            (Ty.path "bool")
                        ],
                      [],
                      [],
                      "map",
                      [],
                      [
                        Ty.path "move_core_types::language_storage::ModuleId";
                        Ty.function
                          [
                            Ty.tuple
                              [
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [ Ty.path "move_binary_format::file_format::ModuleHandle" ]
                              ]
                          ]
                          (Ty.path "move_core_types::language_storage::ModuleId")
                      ]
                    |),
                    [
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::iter::adapters::filter::Filter")
                          []
                          [
                            Ty.apply
                              (Ty.path "core::slice::iter::Iter")
                              []
                              [ Ty.path "move_binary_format::file_format::ModuleHandle" ];
                            Ty.function
                              [
                                Ty.tuple
                                  [
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "&")
                                          []
                                          [ Ty.path "move_binary_format::file_format::ModuleHandle"
                                          ]
                                      ]
                                  ]
                              ]
                              (Ty.path "bool")
                          ],
                        M.get_trait_method (|
                          "core::iter::traits::iterator::Iterator",
                          Ty.apply
                            (Ty.path "core::slice::iter::Iter")
                            []
                            [ Ty.path "move_binary_format::file_format::ModuleHandle" ],
                          [],
                          [],
                          "filter",
                          [],
                          [
                            Ty.function
                              [
                                Ty.tuple
                                  [
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "&")
                                          []
                                          [ Ty.path "move_binary_format::file_format::ModuleHandle"
                                          ]
                                      ]
                                  ]
                              ]
                              (Ty.path "bool")
                          ]
                        |),
                        [
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "core::slice::iter::Iter")
                              []
                              [ Ty.path "move_binary_format::file_format::ModuleHandle" ],
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "slice")
                                []
                                [ Ty.path "move_binary_format::file_format::ModuleHandle" ],
                              "iter",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "slice")
                                          []
                                          [ Ty.path "move_binary_format::file_format::ModuleHandle"
                                          ]
                                      ],
                                    M.get_associated_function (|
                                      Ty.path "move_binary_format::file_format::CompiledModule",
                                      "module_handles",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (| M.read (| self |) |)
                                      |)
                                    ]
                                  |)
                                |)
                              |)
                            ]
                          |);
                          M.closure
                            (fun γ =>
                              ltac:(M.monadic
                                match γ with
                                | [ α0 ] =>
                                  ltac:(M.monadic
                                    (M.match_operator (|
                                      Ty.apply
                                        (Ty.path "*")
                                        []
                                        [
                                          Ty.function
                                            [
                                              Ty.tuple
                                                [
                                                  Ty.apply
                                                    (Ty.path "&")
                                                    []
                                                    [
                                                      Ty.apply
                                                        (Ty.path "&")
                                                        []
                                                        [
                                                          Ty.path
                                                            "move_binary_format::file_format::ModuleHandle"
                                                        ]
                                                    ]
                                                ]
                                            ]
                                            (Ty.path "bool")
                                        ],
                                      M.alloc (| α0 |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ := M.read (| γ |) in
                                            let handle := M.copy (| γ |) in
                                            M.call_closure (|
                                              Ty.path "bool",
                                              M.get_trait_method (|
                                                "core::cmp::PartialEq",
                                                Ty.apply
                                                  (Ty.path "&")
                                                  []
                                                  [
                                                    Ty.path
                                                      "move_binary_format::file_format::ModuleHandle"
                                                  ],
                                                [],
                                                [
                                                  Ty.apply
                                                    (Ty.path "&")
                                                    []
                                                    [
                                                      Ty.path
                                                        "move_binary_format::file_format::ModuleHandle"
                                                    ]
                                                ],
                                                "ne",
                                                [],
                                                []
                                              |),
                                              [
                                                M.borrow (| Pointer.Kind.Ref, handle |);
                                                M.borrow (| Pointer.Kind.Ref, self_handle |)
                                              ]
                                            |)))
                                      ]
                                    |)))
                                | _ => M.impossible "wrong number of arguments"
                                end))
                        ]
                      |);
                      M.closure
                        (fun γ =>
                          ltac:(M.monadic
                            match γ with
                            | [ α0 ] =>
                              ltac:(M.monadic
                                (M.match_operator (|
                                  Ty.apply
                                    (Ty.path "*")
                                    []
                                    [
                                      Ty.function
                                        [
                                          Ty.tuple
                                            [
                                              Ty.apply
                                                (Ty.path "&")
                                                []
                                                [
                                                  Ty.path
                                                    "move_binary_format::file_format::ModuleHandle"
                                                ]
                                            ]
                                        ]
                                        (Ty.path "move_core_types::language_storage::ModuleId")
                                    ],
                                  M.alloc (| α0 |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let handle := M.copy (| γ |) in
                                        M.call_closure (|
                                          Ty.path "move_core_types::language_storage::ModuleId",
                                          M.get_associated_function (|
                                            Ty.path
                                              "move_binary_format::file_format::CompiledModule",
                                            "module_id_for_handle",
                                            [],
                                            []
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (| M.read (| self |) |)
                                            |);
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (| M.read (| handle |) |)
                                            |)
                                          ]
                                        |)))
                                  ]
                                |)))
                            | _ => M.impossible "wrong number of arguments"
                            end))
                    ]
                  |)
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_immediate_dependencies :
      M.IsAssociatedFunction.C Self "immediate_dependencies" immediate_dependencies.
    Admitted.
    Global Typeclasses Opaque immediate_dependencies.
    
    (*
        pub fn immediate_friends(&self) -> Vec<ModuleId> {
            self.friend_decls()
                .iter()
                .map(|handle| self.module_id_for_handle(handle))
                .collect()
        }
    *)
    Definition immediate_friends (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "alloc::vec::Vec")
              []
              [
                Ty.path "move_core_types::language_storage::ModuleId";
                Ty.path "alloc::alloc::Global"
              ],
            M.get_trait_method (|
              "core::iter::traits::iterator::Iterator",
              Ty.apply
                (Ty.path "core::iter::adapters::map::Map")
                []
                [
                  Ty.apply
                    (Ty.path "core::slice::iter::Iter")
                    []
                    [ Ty.path "move_binary_format::file_format::ModuleHandle" ];
                  Ty.function
                    [
                      Ty.tuple
                        [
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.path "move_binary_format::file_format::ModuleHandle" ]
                        ]
                    ]
                    (Ty.path "move_core_types::language_storage::ModuleId")
                ],
              [],
              [],
              "collect",
              [],
              [
                Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  []
                  [
                    Ty.path "move_core_types::language_storage::ModuleId";
                    Ty.path "alloc::alloc::Global"
                  ]
              ]
            |),
            [
              M.call_closure (|
                Ty.apply
                  (Ty.path "core::iter::adapters::map::Map")
                  []
                  [
                    Ty.apply
                      (Ty.path "core::slice::iter::Iter")
                      []
                      [ Ty.path "move_binary_format::file_format::ModuleHandle" ];
                    Ty.function
                      [
                        Ty.tuple
                          [
                            Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.path "move_binary_format::file_format::ModuleHandle" ]
                          ]
                      ]
                      (Ty.path "move_core_types::language_storage::ModuleId")
                  ],
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  Ty.apply
                    (Ty.path "core::slice::iter::Iter")
                    []
                    [ Ty.path "move_binary_format::file_format::ModuleHandle" ],
                  [],
                  [],
                  "map",
                  [],
                  [
                    Ty.path "move_core_types::language_storage::ModuleId";
                    Ty.function
                      [
                        Ty.tuple
                          [
                            Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.path "move_binary_format::file_format::ModuleHandle" ]
                          ]
                      ]
                      (Ty.path "move_core_types::language_storage::ModuleId")
                  ]
                |),
                [
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::slice::iter::Iter")
                      []
                      [ Ty.path "move_binary_format::file_format::ModuleHandle" ],
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "slice")
                        []
                        [ Ty.path "move_binary_format::file_format::ModuleHandle" ],
                      "iter",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "&")
                              []
                              [
                                Ty.apply
                                  (Ty.path "slice")
                                  []
                                  [ Ty.path "move_binary_format::file_format::ModuleHandle" ]
                              ],
                            M.get_associated_function (|
                              Ty.path "move_binary_format::file_format::CompiledModule",
                              "friend_decls",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                          |)
                        |)
                      |)
                    ]
                  |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              Ty.apply
                                (Ty.path "*")
                                []
                                [
                                  Ty.function
                                    [
                                      Ty.tuple
                                        [
                                          Ty.apply
                                            (Ty.path "&")
                                            []
                                            [
                                              Ty.path
                                                "move_binary_format::file_format::ModuleHandle"
                                            ]
                                        ]
                                    ]
                                    (Ty.path "move_core_types::language_storage::ModuleId")
                                ],
                              M.alloc (| α0 |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let handle := M.copy (| γ |) in
                                    M.call_closure (|
                                      Ty.path "move_core_types::language_storage::ModuleId",
                                      M.get_associated_function (|
                                        Ty.path "move_binary_format::file_format::CompiledModule",
                                        "module_id_for_handle",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| self |) |)
                                        |);
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| handle |) |)
                                        |)
                                      ]
                                    |)))
                              ]
                            |)))
                        | _ => M.impossible "wrong number of arguments"
                        end))
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_immediate_friends :
      M.IsAssociatedFunction.C Self "immediate_friends" immediate_friends.
    Admitted.
    Global Typeclasses Opaque immediate_friends.
    
    (*
        pub fn find_struct_def(&self, idx: StructHandleIndex) -> Option<&StructDefinition> {
            self.struct_defs().iter().find(|d| d.struct_handle == idx)
        }
    *)
    Definition find_struct_def (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; idx ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let idx := M.alloc (| idx |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::option::Option")
              []
              [
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.path "move_binary_format::file_format::StructDefinition" ]
              ],
            M.get_trait_method (|
              "core::iter::traits::iterator::Iterator",
              Ty.apply
                (Ty.path "core::slice::iter::Iter")
                []
                [ Ty.path "move_binary_format::file_format::StructDefinition" ],
              [],
              [],
              "find",
              [],
              [
                Ty.function
                  [
                    Ty.tuple
                      [
                        Ty.apply
                          (Ty.path "&")
                          []
                          [
                            Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.path "move_binary_format::file_format::StructDefinition" ]
                          ]
                      ]
                  ]
                  (Ty.path "bool")
              ]
            |),
            [
              M.borrow (|
                Pointer.Kind.MutRef,
                M.alloc (|
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::slice::iter::Iter")
                      []
                      [ Ty.path "move_binary_format::file_format::StructDefinition" ],
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "slice")
                        []
                        [ Ty.path "move_binary_format::file_format::StructDefinition" ],
                      "iter",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "&")
                              []
                              [
                                Ty.apply
                                  (Ty.path "slice")
                                  []
                                  [ Ty.path "move_binary_format::file_format::StructDefinition" ]
                              ],
                            M.get_associated_function (|
                              Ty.path "move_binary_format::file_format::CompiledModule",
                              "struct_defs",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                          |)
                        |)
                      |)
                    ]
                  |)
                |)
              |);
              M.closure
                (fun γ =>
                  ltac:(M.monadic
                    match γ with
                    | [ α0 ] =>
                      ltac:(M.monadic
                        (M.match_operator (|
                          Ty.apply
                            (Ty.path "*")
                            []
                            [
                              Ty.function
                                [
                                  Ty.tuple
                                    [
                                      Ty.apply
                                        (Ty.path "&")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "&")
                                            []
                                            [
                                              Ty.path
                                                "move_binary_format::file_format::StructDefinition"
                                            ]
                                        ]
                                    ]
                                ]
                                (Ty.path "bool")
                            ],
                          M.alloc (| α0 |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let d := M.copy (| γ |) in
                                M.call_closure (|
                                  Ty.path "bool",
                                  M.get_trait_method (|
                                    "core::cmp::PartialEq",
                                    Ty.path "move_binary_format::file_format::StructHandleIndex",
                                    [],
                                    [ Ty.path "move_binary_format::file_format::StructHandleIndex"
                                    ],
                                    "eq",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.SubPointer.get_struct_record_field (|
                                        M.deref (| M.read (| M.deref (| M.read (| d |) |) |) |),
                                        "move_binary_format::file_format::StructDefinition",
                                        "struct_handle"
                                      |)
                                    |);
                                    M.borrow (| Pointer.Kind.Ref, idx |)
                                  ]
                                |)))
                          ]
                        |)))
                    | _ => M.impossible "wrong number of arguments"
                    end))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_find_struct_def :
      M.IsAssociatedFunction.C Self "find_struct_def" find_struct_def.
    Admitted.
    Global Typeclasses Opaque find_struct_def.
    
    (*
        pub fn find_struct_def_by_name(&self, name: &IdentStr) -> Option<&StructDefinition> {
            self.struct_defs().iter().find(|def| {
                let handle = self.struct_handle_at(def.struct_handle);
                name == self.identifier_at(handle.name)
            })
        }
    *)
    Definition find_struct_def_by_name (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; name ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let name := M.alloc (| name |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::option::Option")
              []
              [
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.path "move_binary_format::file_format::StructDefinition" ]
              ],
            M.get_trait_method (|
              "core::iter::traits::iterator::Iterator",
              Ty.apply
                (Ty.path "core::slice::iter::Iter")
                []
                [ Ty.path "move_binary_format::file_format::StructDefinition" ],
              [],
              [],
              "find",
              [],
              [
                Ty.function
                  [
                    Ty.tuple
                      [
                        Ty.apply
                          (Ty.path "&")
                          []
                          [
                            Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.path "move_binary_format::file_format::StructDefinition" ]
                          ]
                      ]
                  ]
                  (Ty.path "bool")
              ]
            |),
            [
              M.borrow (|
                Pointer.Kind.MutRef,
                M.alloc (|
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::slice::iter::Iter")
                      []
                      [ Ty.path "move_binary_format::file_format::StructDefinition" ],
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "slice")
                        []
                        [ Ty.path "move_binary_format::file_format::StructDefinition" ],
                      "iter",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "&")
                              []
                              [
                                Ty.apply
                                  (Ty.path "slice")
                                  []
                                  [ Ty.path "move_binary_format::file_format::StructDefinition" ]
                              ],
                            M.get_associated_function (|
                              Ty.path "move_binary_format::file_format::CompiledModule",
                              "struct_defs",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                          |)
                        |)
                      |)
                    ]
                  |)
                |)
              |);
              M.closure
                (fun γ =>
                  ltac:(M.monadic
                    match γ with
                    | [ α0 ] =>
                      ltac:(M.monadic
                        (M.match_operator (|
                          Ty.apply
                            (Ty.path "*")
                            []
                            [
                              Ty.function
                                [
                                  Ty.tuple
                                    [
                                      Ty.apply
                                        (Ty.path "&")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "&")
                                            []
                                            [
                                              Ty.path
                                                "move_binary_format::file_format::StructDefinition"
                                            ]
                                        ]
                                    ]
                                ]
                                (Ty.path "bool")
                            ],
                          M.alloc (| α0 |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let def := M.copy (| γ |) in
                                M.read (|
                                  let~ handle :
                                      Ty.apply
                                        (Ty.path "&")
                                        []
                                        [ Ty.path "move_binary_format::file_format::StructHandle"
                                        ] :=
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "&")
                                        []
                                        [ Ty.path "move_binary_format::file_format::StructHandle" ],
                                      M.get_associated_function (|
                                        Ty.path "move_binary_format::file_format::CompiledModule",
                                        "struct_handle_at",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| self |) |)
                                        |);
                                        M.read (|
                                          M.SubPointer.get_struct_record_field (|
                                            M.deref (|
                                              M.read (| M.deref (| M.read (| def |) |) |)
                                            |),
                                            "move_binary_format::file_format::StructDefinition",
                                            "struct_handle"
                                          |)
                                        |)
                                      ]
                                    |) in
                                  M.alloc (|
                                    M.call_closure (|
                                      Ty.path "bool",
                                      M.get_trait_method (|
                                        "core::cmp::PartialEq",
                                        Ty.apply
                                          (Ty.path "&")
                                          []
                                          [ Ty.path "move_core_types::identifier::IdentStr" ],
                                        [],
                                        [
                                          Ty.apply
                                            (Ty.path "&")
                                            []
                                            [ Ty.path "move_core_types::identifier::IdentStr" ]
                                        ],
                                        "eq",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (| Pointer.Kind.Ref, name |);
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.alloc (|
                                            M.call_closure (|
                                              Ty.apply
                                                (Ty.path "&")
                                                []
                                                [ Ty.path "move_core_types::identifier::IdentStr" ],
                                              M.get_associated_function (|
                                                Ty.path
                                                  "move_binary_format::file_format::CompiledModule",
                                                "identifier_at",
                                                [],
                                                []
                                              |),
                                              [
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (| M.read (| self |) |)
                                                |);
                                                M.read (|
                                                  M.SubPointer.get_struct_record_field (|
                                                    M.deref (| M.read (| handle |) |),
                                                    "move_binary_format::file_format::StructHandle",
                                                    "name"
                                                  |)
                                                |)
                                              ]
                                            |)
                                          |)
                                        |)
                                      ]
                                    |)
                                  |)
                                |)))
                          ]
                        |)))
                    | _ => M.impossible "wrong number of arguments"
                    end))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_find_struct_def_by_name :
      M.IsAssociatedFunction.C Self "find_struct_def_by_name" find_struct_def_by_name.
    Admitted.
    Global Typeclasses Opaque find_struct_def_by_name.
    
    (*
        pub fn abilities(
            &self,
            ty: &SignatureToken,
            constraints: &[AbilitySet],
        ) -> PartialVMResult<AbilitySet> {
            use SignatureToken::*;
    
            match ty {
                Bool | U8 | U16 | U32 | U64 | U128 | U256 | Address => Ok(AbilitySet::PRIMITIVES),
    
                Reference(_) | MutableReference(_) => Ok(AbilitySet::REFERENCES),
                Signer => Ok(AbilitySet::SIGNER),
                TypeParameter(idx) => Ok(constraints[*idx as usize]),
                Vector(ty) => AbilitySet::polymorphic_abilities(
                    AbilitySet::VECTOR,
                    vec![false],
                    vec![self.abilities(ty, constraints)?],
                ),
                Struct(idx) => {
                    let sh = self.struct_handle_at( *idx);
                    Ok(sh.abilities)
                }
                StructInstantiation(struct_inst) => {
                    let (idx, type_args) = &**struct_inst;
                    let sh = self.struct_handle_at( *idx);
                    let declared_abilities = sh.abilities;
                    let type_arguments = type_args
                        .iter()
                        .map(|arg| self.abilities(arg, constraints))
                        .collect::<PartialVMResult<Vec<_>>>()?;
                    AbilitySet::polymorphic_abilities(
                        declared_abilities,
                        sh.type_parameters.iter().map(|param| param.is_phantom),
                        type_arguments,
                    )
                }
            }
        }
    *)
    Definition abilities (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; ty; constraints ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let ty := M.alloc (| ty |) in
          let constraints := M.alloc (| constraints |) in
          M.catch_return
            (Ty.apply
              (Ty.path "core::result::Result")
              []
              [
                Ty.path "move_binary_format::file_format::AbilitySet";
                Ty.path "move_binary_format::errors::PartialVMError"
              ]) (|
            ltac:(M.monadic
              (M.read (|
                M.match_operator (|
                  Ty.apply
                    (Ty.path "*")
                    []
                    [
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [
                          Ty.path "move_binary_format::file_format::AbilitySet";
                          Ty.path "move_binary_format::errors::PartialVMError"
                        ]
                    ],
                  ty,
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (M.find_or_pattern (Ty.tuple []) (|
                          γ,
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ := M.read (| γ |) in
                                let _ :=
                                  M.is_struct_tuple (|
                                    γ,
                                    "move_binary_format::file_format::SignatureToken::Bool"
                                  |) in
                                Value.Tuple []));
                            fun γ =>
                              ltac:(M.monadic
                                (let γ := M.read (| γ |) in
                                let _ :=
                                  M.is_struct_tuple (|
                                    γ,
                                    "move_binary_format::file_format::SignatureToken::U8"
                                  |) in
                                Value.Tuple []));
                            fun γ =>
                              ltac:(M.monadic
                                (let γ := M.read (| γ |) in
                                let _ :=
                                  M.is_struct_tuple (|
                                    γ,
                                    "move_binary_format::file_format::SignatureToken::U16"
                                  |) in
                                Value.Tuple []));
                            fun γ =>
                              ltac:(M.monadic
                                (let γ := M.read (| γ |) in
                                let _ :=
                                  M.is_struct_tuple (|
                                    γ,
                                    "move_binary_format::file_format::SignatureToken::U32"
                                  |) in
                                Value.Tuple []));
                            fun γ =>
                              ltac:(M.monadic
                                (let γ := M.read (| γ |) in
                                let _ :=
                                  M.is_struct_tuple (|
                                    γ,
                                    "move_binary_format::file_format::SignatureToken::U64"
                                  |) in
                                Value.Tuple []));
                            fun γ =>
                              ltac:(M.monadic
                                (let γ := M.read (| γ |) in
                                let _ :=
                                  M.is_struct_tuple (|
                                    γ,
                                    "move_binary_format::file_format::SignatureToken::U128"
                                  |) in
                                Value.Tuple []));
                            fun γ =>
                              ltac:(M.monadic
                                (let γ := M.read (| γ |) in
                                let _ :=
                                  M.is_struct_tuple (|
                                    γ,
                                    "move_binary_format::file_format::SignatureToken::U256"
                                  |) in
                                Value.Tuple []));
                            fun γ =>
                              ltac:(M.monadic
                                (let γ := M.read (| γ |) in
                                let _ :=
                                  M.is_struct_tuple (|
                                    γ,
                                    "move_binary_format::file_format::SignatureToken::Address"
                                  |) in
                                Value.Tuple []))
                          ],
                          fun γ =>
                            ltac:(M.monadic
                              match γ with
                              | [] =>
                                ltac:(M.monadic
                                  (M.alloc (|
                                    Value.StructTuple
                                      "core::result::Result::Ok"
                                      []
                                      [
                                        Ty.path "move_binary_format::file_format::AbilitySet";
                                        Ty.path "move_binary_format::errors::PartialVMError"
                                      ]
                                      [
                                        M.read (|
                                          get_associated_constant (|
                                            Ty.path "move_binary_format::file_format::AbilitySet",
                                            "PRIMITIVES",
                                            Ty.path "move_binary_format::file_format::AbilitySet"
                                          |)
                                        |)
                                      ]
                                  |)))
                              | _ => M.impossible "wrong number of arguments"
                              end)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (M.find_or_pattern (Ty.tuple []) (|
                          γ,
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ := M.read (| γ |) in
                                let γ1_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "move_binary_format::file_format::SignatureToken::Reference",
                                    0
                                  |) in
                                Value.Tuple []));
                            fun γ =>
                              ltac:(M.monadic
                                (let γ := M.read (| γ |) in
                                let γ1_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "move_binary_format::file_format::SignatureToken::MutableReference",
                                    0
                                  |) in
                                Value.Tuple []))
                          ],
                          fun γ =>
                            ltac:(M.monadic
                              match γ with
                              | [] =>
                                ltac:(M.monadic
                                  (M.alloc (|
                                    Value.StructTuple
                                      "core::result::Result::Ok"
                                      []
                                      [
                                        Ty.path "move_binary_format::file_format::AbilitySet";
                                        Ty.path "move_binary_format::errors::PartialVMError"
                                      ]
                                      [
                                        M.read (|
                                          get_associated_constant (|
                                            Ty.path "move_binary_format::file_format::AbilitySet",
                                            "REFERENCES",
                                            Ty.path "move_binary_format::file_format::AbilitySet"
                                          |)
                                        |)
                                      ]
                                  |)))
                              | _ => M.impossible "wrong number of arguments"
                              end)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "move_binary_format::file_format::SignatureToken::Signer"
                          |) in
                        M.alloc (|
                          Value.StructTuple
                            "core::result::Result::Ok"
                            []
                            [
                              Ty.path "move_binary_format::file_format::AbilitySet";
                              Ty.path "move_binary_format::errors::PartialVMError"
                            ]
                            [
                              M.read (|
                                get_associated_constant (|
                                  Ty.path "move_binary_format::file_format::AbilitySet",
                                  "SIGNER",
                                  Ty.path "move_binary_format::file_format::AbilitySet"
                                |)
                              |)
                            ]
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let γ1_0 :=
                          M.SubPointer.get_struct_tuple_field (|
                            γ,
                            "move_binary_format::file_format::SignatureToken::TypeParameter",
                            0
                          |) in
                        let idx := M.alloc (| γ1_0 |) in
                        M.alloc (|
                          Value.StructTuple
                            "core::result::Result::Ok"
                            []
                            [
                              Ty.path "move_binary_format::file_format::AbilitySet";
                              Ty.path "move_binary_format::errors::PartialVMError"
                            ]
                            [
                              M.read (|
                                M.SubPointer.get_array_field (|
                                  M.deref (| M.read (| constraints |) |),
                                  M.cast
                                    (Ty.path "usize")
                                    (M.read (| M.deref (| M.read (| idx |) |) |))
                                |)
                              |)
                            ]
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let γ1_0 :=
                          M.SubPointer.get_struct_tuple_field (|
                            γ,
                            "move_binary_format::file_format::SignatureToken::Vector",
                            0
                          |) in
                        let ty := M.alloc (| γ1_0 |) in
                        M.alloc (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "core::result::Result")
                              []
                              [
                                Ty.path "move_binary_format::file_format::AbilitySet";
                                Ty.path "move_binary_format::errors::PartialVMError"
                              ],
                            M.get_associated_function (|
                              Ty.path "move_binary_format::file_format::AbilitySet",
                              "polymorphic_abilities",
                              [],
                              [
                                Ty.apply
                                  (Ty.path "alloc::vec::Vec")
                                  []
                                  [ Ty.path "bool"; Ty.path "alloc::alloc::Global" ];
                                Ty.apply
                                  (Ty.path "alloc::vec::Vec")
                                  []
                                  [
                                    Ty.path "move_binary_format::file_format::AbilitySet";
                                    Ty.path "alloc::alloc::Global"
                                  ]
                              ]
                            |),
                            [
                              M.read (|
                                get_associated_constant (|
                                  Ty.path "move_binary_format::file_format::AbilitySet",
                                  "VECTOR",
                                  Ty.path "move_binary_format::file_format::AbilitySet"
                                |)
                              |);
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "alloc::vec::Vec")
                                  []
                                  [ Ty.path "bool"; Ty.path "alloc::alloc::Global" ],
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "slice") [] [ Ty.path "bool" ],
                                  "into_vec",
                                  [],
                                  [ Ty.path "alloc::alloc::Global" ]
                                |),
                                [
                                  (* Unsize *)
                                  M.pointer_coercion
                                    (M.read (|
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "alloc::boxed::Box")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "array")
                                              [ Value.Integer IntegerKind.Usize 1 ]
                                              [ Ty.path "bool" ];
                                            Ty.path "alloc::alloc::Global"
                                          ],
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "alloc::boxed::Box")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "array")
                                                [ Value.Integer IntegerKind.Usize 1 ]
                                                [ Ty.path "bool" ];
                                              Ty.path "alloc::alloc::Global"
                                            ],
                                          "new",
                                          [],
                                          []
                                        |),
                                        [ M.alloc (| Value.Array [ Value.Bool false ] |) ]
                                      |)
                                    |))
                                ]
                              |);
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "alloc::vec::Vec")
                                  []
                                  [
                                    Ty.path "move_binary_format::file_format::AbilitySet";
                                    Ty.path "alloc::alloc::Global"
                                  ],
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "slice")
                                    []
                                    [ Ty.path "move_binary_format::file_format::AbilitySet" ],
                                  "into_vec",
                                  [],
                                  [ Ty.path "alloc::alloc::Global" ]
                                |),
                                [
                                  (* Unsize *)
                                  M.pointer_coercion
                                    (M.read (|
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "alloc::boxed::Box")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "array")
                                              [ Value.Integer IntegerKind.Usize 1 ]
                                              [
                                                Ty.path
                                                  "move_binary_format::file_format::AbilitySet"
                                              ];
                                            Ty.path "alloc::alloc::Global"
                                          ],
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "alloc::boxed::Box")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "array")
                                                [ Value.Integer IntegerKind.Usize 1 ]
                                                [
                                                  Ty.path
                                                    "move_binary_format::file_format::AbilitySet"
                                                ];
                                              Ty.path "alloc::alloc::Global"
                                            ],
                                          "new",
                                          [],
                                          []
                                        |),
                                        [
                                          M.alloc (|
                                            Value.Array
                                              [
                                                M.read (|
                                                  M.match_operator (|
                                                    Ty.apply
                                                      (Ty.path "*")
                                                      []
                                                      [
                                                        Ty.path
                                                          "move_binary_format::file_format::AbilitySet"
                                                      ],
                                                    M.alloc (|
                                                      M.call_closure (|
                                                        Ty.apply
                                                          (Ty.path
                                                            "core::ops::control_flow::ControlFlow")
                                                          []
                                                          [
                                                            Ty.apply
                                                              (Ty.path "core::result::Result")
                                                              []
                                                              [
                                                                Ty.path "core::convert::Infallible";
                                                                Ty.path
                                                                  "move_binary_format::errors::PartialVMError"
                                                              ];
                                                            Ty.path
                                                              "move_binary_format::file_format::AbilitySet"
                                                          ],
                                                        M.get_trait_method (|
                                                          "core::ops::try_trait::Try",
                                                          Ty.apply
                                                            (Ty.path "core::result::Result")
                                                            []
                                                            [
                                                              Ty.path
                                                                "move_binary_format::file_format::AbilitySet";
                                                              Ty.path
                                                                "move_binary_format::errors::PartialVMError"
                                                            ],
                                                          [],
                                                          [],
                                                          "branch",
                                                          [],
                                                          []
                                                        |),
                                                        [
                                                          M.call_closure (|
                                                            Ty.apply
                                                              (Ty.path "core::result::Result")
                                                              []
                                                              [
                                                                Ty.path
                                                                  "move_binary_format::file_format::AbilitySet";
                                                                Ty.path
                                                                  "move_binary_format::errors::PartialVMError"
                                                              ],
                                                            M.get_associated_function (|
                                                              Ty.path
                                                                "move_binary_format::file_format::CompiledModule",
                                                              "abilities",
                                                              [],
                                                              []
                                                            |),
                                                            [
                                                              M.borrow (|
                                                                Pointer.Kind.Ref,
                                                                M.deref (| M.read (| self |) |)
                                                              |);
                                                              M.borrow (|
                                                                Pointer.Kind.Ref,
                                                                M.deref (|
                                                                  M.read (|
                                                                    M.deref (| M.read (| ty |) |)
                                                                  |)
                                                                |)
                                                              |);
                                                              M.borrow (|
                                                                Pointer.Kind.Ref,
                                                                M.deref (|
                                                                  M.read (| constraints |)
                                                                |)
                                                              |)
                                                            ]
                                                          |)
                                                        ]
                                                      |)
                                                    |),
                                                    [
                                                      fun γ =>
                                                        ltac:(M.monadic
                                                          (let γ0_0 :=
                                                            M.SubPointer.get_struct_tuple_field (|
                                                              γ,
                                                              "core::ops::control_flow::ControlFlow::Break",
                                                              0
                                                            |) in
                                                          let residual := M.copy (| γ0_0 |) in
                                                          M.alloc (|
                                                            M.never_to_any (|
                                                              M.read (|
                                                                M.return_ (|
                                                                  M.call_closure (|
                                                                    Ty.apply
                                                                      (Ty.path
                                                                        "core::result::Result")
                                                                      []
                                                                      [
                                                                        Ty.path
                                                                          "move_binary_format::file_format::AbilitySet";
                                                                        Ty.path
                                                                          "move_binary_format::errors::PartialVMError"
                                                                      ],
                                                                    M.get_trait_method (|
                                                                      "core::ops::try_trait::FromResidual",
                                                                      Ty.apply
                                                                        (Ty.path
                                                                          "core::result::Result")
                                                                        []
                                                                        [
                                                                          Ty.path
                                                                            "move_binary_format::file_format::AbilitySet";
                                                                          Ty.path
                                                                            "move_binary_format::errors::PartialVMError"
                                                                        ],
                                                                      [],
                                                                      [
                                                                        Ty.apply
                                                                          (Ty.path
                                                                            "core::result::Result")
                                                                          []
                                                                          [
                                                                            Ty.path
                                                                              "core::convert::Infallible";
                                                                            Ty.path
                                                                              "move_binary_format::errors::PartialVMError"
                                                                          ]
                                                                      ],
                                                                      "from_residual",
                                                                      [],
                                                                      []
                                                                    |),
                                                                    [ M.read (| residual |) ]
                                                                  |)
                                                                |)
                                                              |)
                                                            |)
                                                          |)));
                                                      fun γ =>
                                                        ltac:(M.monadic
                                                          (let γ0_0 :=
                                                            M.SubPointer.get_struct_tuple_field (|
                                                              γ,
                                                              "core::ops::control_flow::ControlFlow::Continue",
                                                              0
                                                            |) in
                                                          let val := M.copy (| γ0_0 |) in
                                                          val))
                                                    ]
                                                  |)
                                                |)
                                              ]
                                          |)
                                        ]
                                      |)
                                    |))
                                ]
                              |)
                            ]
                          |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let γ1_0 :=
                          M.SubPointer.get_struct_tuple_field (|
                            γ,
                            "move_binary_format::file_format::SignatureToken::Struct",
                            0
                          |) in
                        let idx := M.alloc (| γ1_0 |) in
                        let~ sh :
                            Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.path "move_binary_format::file_format::StructHandle" ] :=
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.path "move_binary_format::file_format::StructHandle" ],
                            M.get_associated_function (|
                              Ty.path "move_binary_format::file_format::CompiledModule",
                              "struct_handle_at",
                              [],
                              []
                            |),
                            [
                              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                              M.read (| M.deref (| M.read (| idx |) |) |)
                            ]
                          |) in
                        M.alloc (|
                          Value.StructTuple
                            "core::result::Result::Ok"
                            []
                            [
                              Ty.path "move_binary_format::file_format::AbilitySet";
                              Ty.path "move_binary_format::errors::PartialVMError"
                            ]
                            [
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| sh |) |),
                                  "move_binary_format::file_format::StructHandle",
                                  "abilities"
                                |)
                              |)
                            ]
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let γ1_0 :=
                          M.SubPointer.get_struct_tuple_field (|
                            γ,
                            "move_binary_format::file_format::SignatureToken::StructInstantiation",
                            0
                          |) in
                        let struct_inst := M.alloc (| γ1_0 |) in
                        M.match_operator (|
                          Ty.apply
                            (Ty.path "*")
                            []
                            [
                              Ty.apply
                                (Ty.path "core::result::Result")
                                []
                                [
                                  Ty.path "move_binary_format::file_format::AbilitySet";
                                  Ty.path "move_binary_format::errors::PartialVMError"
                                ]
                            ],
                          M.alloc (|
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (| M.read (| M.deref (| M.read (| struct_inst |) |) |) |)
                            |)
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ := M.read (| γ |) in
                                let γ1_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                let γ1_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                let idx := M.alloc (| γ1_0 |) in
                                let type_args := M.alloc (| γ1_1 |) in
                                let~ sh :
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [ Ty.path "move_binary_format::file_format::StructHandle" ] :=
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [ Ty.path "move_binary_format::file_format::StructHandle" ],
                                    M.get_associated_function (|
                                      Ty.path "move_binary_format::file_format::CompiledModule",
                                      "struct_handle_at",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (| M.read (| self |) |)
                                      |);
                                      M.read (| M.deref (| M.read (| idx |) |) |)
                                    ]
                                  |) in
                                let~ declared_abilities :
                                    Ty.path "move_binary_format::file_format::AbilitySet" :=
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| sh |) |),
                                      "move_binary_format::file_format::StructHandle",
                                      "abilities"
                                    |)
                                  |) in
                                let~ type_arguments :
                                    Ty.apply
                                      (Ty.path "alloc::vec::Vec")
                                      []
                                      [
                                        Ty.path "move_binary_format::file_format::AbilitySet";
                                        Ty.path "alloc::alloc::Global"
                                      ] :=
                                  M.read (|
                                    M.match_operator (|
                                      Ty.apply
                                        (Ty.path "*")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "alloc::vec::Vec")
                                            []
                                            [
                                              Ty.path "move_binary_format::file_format::AbilitySet";
                                              Ty.path "alloc::alloc::Global"
                                            ]
                                        ],
                                      M.alloc (|
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "core::ops::control_flow::ControlFlow")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.path "core::convert::Infallible";
                                                  Ty.path
                                                    "move_binary_format::errors::PartialVMError"
                                                ];
                                              Ty.apply
                                                (Ty.path "alloc::vec::Vec")
                                                []
                                                [
                                                  Ty.path
                                                    "move_binary_format::file_format::AbilitySet";
                                                  Ty.path "alloc::alloc::Global"
                                                ]
                                            ],
                                          M.get_trait_method (|
                                            "core::ops::try_trait::Try",
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "alloc::vec::Vec")
                                                  []
                                                  [
                                                    Ty.path
                                                      "move_binary_format::file_format::AbilitySet";
                                                    Ty.path "alloc::alloc::Global"
                                                  ];
                                                Ty.path "move_binary_format::errors::PartialVMError"
                                              ],
                                            [],
                                            [],
                                            "branch",
                                            [],
                                            []
                                          |),
                                          [
                                            M.call_closure (|
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "alloc::vec::Vec")
                                                    []
                                                    [
                                                      Ty.path
                                                        "move_binary_format::file_format::AbilitySet";
                                                      Ty.path "alloc::alloc::Global"
                                                    ];
                                                  Ty.path
                                                    "move_binary_format::errors::PartialVMError"
                                                ],
                                              M.get_trait_method (|
                                                "core::iter::traits::iterator::Iterator",
                                                Ty.apply
                                                  (Ty.path "core::iter::adapters::map::Map")
                                                  []
                                                  [
                                                    Ty.apply
                                                      (Ty.path "core::slice::iter::Iter")
                                                      []
                                                      [
                                                        Ty.path
                                                          "move_binary_format::file_format::SignatureToken"
                                                      ];
                                                    Ty.function
                                                      [
                                                        Ty.tuple
                                                          [
                                                            Ty.apply
                                                              (Ty.path "&")
                                                              []
                                                              [
                                                                Ty.path
                                                                  "move_binary_format::file_format::SignatureToken"
                                                              ]
                                                          ]
                                                      ]
                                                      (Ty.apply
                                                        (Ty.path "core::result::Result")
                                                        []
                                                        [
                                                          Ty.path
                                                            "move_binary_format::file_format::AbilitySet";
                                                          Ty.path
                                                            "move_binary_format::errors::PartialVMError"
                                                        ])
                                                  ],
                                                [],
                                                [],
                                                "collect",
                                                [],
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::result::Result")
                                                    []
                                                    [
                                                      Ty.apply
                                                        (Ty.path "alloc::vec::Vec")
                                                        []
                                                        [
                                                          Ty.path
                                                            "move_binary_format::file_format::AbilitySet";
                                                          Ty.path "alloc::alloc::Global"
                                                        ];
                                                      Ty.path
                                                        "move_binary_format::errors::PartialVMError"
                                                    ]
                                                ]
                                              |),
                                              [
                                                M.call_closure (|
                                                  Ty.apply
                                                    (Ty.path "core::iter::adapters::map::Map")
                                                    []
                                                    [
                                                      Ty.apply
                                                        (Ty.path "core::slice::iter::Iter")
                                                        []
                                                        [
                                                          Ty.path
                                                            "move_binary_format::file_format::SignatureToken"
                                                        ];
                                                      Ty.function
                                                        [
                                                          Ty.tuple
                                                            [
                                                              Ty.apply
                                                                (Ty.path "&")
                                                                []
                                                                [
                                                                  Ty.path
                                                                    "move_binary_format::file_format::SignatureToken"
                                                                ]
                                                            ]
                                                        ]
                                                        (Ty.apply
                                                          (Ty.path "core::result::Result")
                                                          []
                                                          [
                                                            Ty.path
                                                              "move_binary_format::file_format::AbilitySet";
                                                            Ty.path
                                                              "move_binary_format::errors::PartialVMError"
                                                          ])
                                                    ],
                                                  M.get_trait_method (|
                                                    "core::iter::traits::iterator::Iterator",
                                                    Ty.apply
                                                      (Ty.path "core::slice::iter::Iter")
                                                      []
                                                      [
                                                        Ty.path
                                                          "move_binary_format::file_format::SignatureToken"
                                                      ],
                                                    [],
                                                    [],
                                                    "map",
                                                    [],
                                                    [
                                                      Ty.apply
                                                        (Ty.path "core::result::Result")
                                                        []
                                                        [
                                                          Ty.path
                                                            "move_binary_format::file_format::AbilitySet";
                                                          Ty.path
                                                            "move_binary_format::errors::PartialVMError"
                                                        ];
                                                      Ty.function
                                                        [
                                                          Ty.tuple
                                                            [
                                                              Ty.apply
                                                                (Ty.path "&")
                                                                []
                                                                [
                                                                  Ty.path
                                                                    "move_binary_format::file_format::SignatureToken"
                                                                ]
                                                            ]
                                                        ]
                                                        (Ty.apply
                                                          (Ty.path "core::result::Result")
                                                          []
                                                          [
                                                            Ty.path
                                                              "move_binary_format::file_format::AbilitySet";
                                                            Ty.path
                                                              "move_binary_format::errors::PartialVMError"
                                                          ])
                                                    ]
                                                  |),
                                                  [
                                                    M.call_closure (|
                                                      Ty.apply
                                                        (Ty.path "core::slice::iter::Iter")
                                                        []
                                                        [
                                                          Ty.path
                                                            "move_binary_format::file_format::SignatureToken"
                                                        ],
                                                      M.get_associated_function (|
                                                        Ty.apply
                                                          (Ty.path "slice")
                                                          []
                                                          [
                                                            Ty.path
                                                              "move_binary_format::file_format::SignatureToken"
                                                          ],
                                                        "iter",
                                                        [],
                                                        []
                                                      |),
                                                      [
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.deref (|
                                                            M.call_closure (|
                                                              Ty.apply
                                                                (Ty.path "&")
                                                                []
                                                                [
                                                                  Ty.apply
                                                                    (Ty.path "slice")
                                                                    []
                                                                    [
                                                                      Ty.path
                                                                        "move_binary_format::file_format::SignatureToken"
                                                                    ]
                                                                ],
                                                              M.get_trait_method (|
                                                                "core::ops::deref::Deref",
                                                                Ty.apply
                                                                  (Ty.path "alloc::vec::Vec")
                                                                  []
                                                                  [
                                                                    Ty.path
                                                                      "move_binary_format::file_format::SignatureToken";
                                                                    Ty.path "alloc::alloc::Global"
                                                                  ],
                                                                [],
                                                                [],
                                                                "deref",
                                                                [],
                                                                []
                                                              |),
                                                              [
                                                                M.borrow (|
                                                                  Pointer.Kind.Ref,
                                                                  M.deref (|
                                                                    M.read (| type_args |)
                                                                  |)
                                                                |)
                                                              ]
                                                            |)
                                                          |)
                                                        |)
                                                      ]
                                                    |);
                                                    M.closure
                                                      (fun γ =>
                                                        ltac:(M.monadic
                                                          match γ with
                                                          | [ α0 ] =>
                                                            ltac:(M.monadic
                                                              (M.match_operator (|
                                                                Ty.apply
                                                                  (Ty.path "*")
                                                                  []
                                                                  [
                                                                    Ty.function
                                                                      [
                                                                        Ty.tuple
                                                                          [
                                                                            Ty.apply
                                                                              (Ty.path "&")
                                                                              []
                                                                              [
                                                                                Ty.path
                                                                                  "move_binary_format::file_format::SignatureToken"
                                                                              ]
                                                                          ]
                                                                      ]
                                                                      (Ty.apply
                                                                        (Ty.path
                                                                          "core::result::Result")
                                                                        []
                                                                        [
                                                                          Ty.path
                                                                            "move_binary_format::file_format::AbilitySet";
                                                                          Ty.path
                                                                            "move_binary_format::errors::PartialVMError"
                                                                        ])
                                                                  ],
                                                                M.alloc (| α0 |),
                                                                [
                                                                  fun γ =>
                                                                    ltac:(M.monadic
                                                                      (let arg := M.copy (| γ |) in
                                                                      M.call_closure (|
                                                                        Ty.apply
                                                                          (Ty.path
                                                                            "core::result::Result")
                                                                          []
                                                                          [
                                                                            Ty.path
                                                                              "move_binary_format::file_format::AbilitySet";
                                                                            Ty.path
                                                                              "move_binary_format::errors::PartialVMError"
                                                                          ],
                                                                        M.get_associated_function (|
                                                                          Ty.path
                                                                            "move_binary_format::file_format::CompiledModule",
                                                                          "abilities",
                                                                          [],
                                                                          []
                                                                        |),
                                                                        [
                                                                          M.borrow (|
                                                                            Pointer.Kind.Ref,
                                                                            M.deref (|
                                                                              M.read (| self |)
                                                                            |)
                                                                          |);
                                                                          M.borrow (|
                                                                            Pointer.Kind.Ref,
                                                                            M.deref (|
                                                                              M.read (| arg |)
                                                                            |)
                                                                          |);
                                                                          M.borrow (|
                                                                            Pointer.Kind.Ref,
                                                                            M.deref (|
                                                                              M.read (|
                                                                                constraints
                                                                              |)
                                                                            |)
                                                                          |)
                                                                        ]
                                                                      |)))
                                                                ]
                                                              |)))
                                                          | _ =>
                                                            M.impossible "wrong number of arguments"
                                                          end))
                                                  ]
                                                |)
                                              ]
                                            |)
                                          ]
                                        |)
                                      |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ,
                                                "core::ops::control_flow::ControlFlow::Break",
                                                0
                                              |) in
                                            let residual := M.copy (| γ0_0 |) in
                                            M.alloc (|
                                              M.never_to_any (|
                                                M.read (|
                                                  M.return_ (|
                                                    M.call_closure (|
                                                      Ty.apply
                                                        (Ty.path "core::result::Result")
                                                        []
                                                        [
                                                          Ty.path
                                                            "move_binary_format::file_format::AbilitySet";
                                                          Ty.path
                                                            "move_binary_format::errors::PartialVMError"
                                                        ],
                                                      M.get_trait_method (|
                                                        "core::ops::try_trait::FromResidual",
                                                        Ty.apply
                                                          (Ty.path "core::result::Result")
                                                          []
                                                          [
                                                            Ty.path
                                                              "move_binary_format::file_format::AbilitySet";
                                                            Ty.path
                                                              "move_binary_format::errors::PartialVMError"
                                                          ],
                                                        [],
                                                        [
                                                          Ty.apply
                                                            (Ty.path "core::result::Result")
                                                            []
                                                            [
                                                              Ty.path "core::convert::Infallible";
                                                              Ty.path
                                                                "move_binary_format::errors::PartialVMError"
                                                            ]
                                                        ],
                                                        "from_residual",
                                                        [],
                                                        []
                                                      |),
                                                      [ M.read (| residual |) ]
                                                    |)
                                                  |)
                                                |)
                                              |)
                                            |)));
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ,
                                                "core::ops::control_flow::ControlFlow::Continue",
                                                0
                                              |) in
                                            let val := M.copy (| γ0_0 |) in
                                            val))
                                      ]
                                    |)
                                  |) in
                                M.alloc (|
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "move_binary_format::file_format::AbilitySet";
                                        Ty.path "move_binary_format::errors::PartialVMError"
                                      ],
                                    M.get_associated_function (|
                                      Ty.path "move_binary_format::file_format::AbilitySet",
                                      "polymorphic_abilities",
                                      [],
                                      [
                                        Ty.apply
                                          (Ty.path "core::iter::adapters::map::Map")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "core::slice::iter::Iter")
                                              []
                                              [
                                                Ty.path
                                                  "move_binary_format::file_format::StructTypeParameter"
                                              ];
                                            Ty.function
                                              [
                                                Ty.tuple
                                                  [
                                                    Ty.apply
                                                      (Ty.path "&")
                                                      []
                                                      [
                                                        Ty.path
                                                          "move_binary_format::file_format::StructTypeParameter"
                                                      ]
                                                  ]
                                              ]
                                              (Ty.path "bool")
                                          ];
                                        Ty.apply
                                          (Ty.path "alloc::vec::Vec")
                                          []
                                          [
                                            Ty.path "move_binary_format::file_format::AbilitySet";
                                            Ty.path "alloc::alloc::Global"
                                          ]
                                      ]
                                    |),
                                    [
                                      M.read (| declared_abilities |);
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "core::iter::adapters::map::Map")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "core::slice::iter::Iter")
                                              []
                                              [
                                                Ty.path
                                                  "move_binary_format::file_format::StructTypeParameter"
                                              ];
                                            Ty.function
                                              [
                                                Ty.tuple
                                                  [
                                                    Ty.apply
                                                      (Ty.path "&")
                                                      []
                                                      [
                                                        Ty.path
                                                          "move_binary_format::file_format::StructTypeParameter"
                                                      ]
                                                  ]
                                              ]
                                              (Ty.path "bool")
                                          ],
                                        M.get_trait_method (|
                                          "core::iter::traits::iterator::Iterator",
                                          Ty.apply
                                            (Ty.path "core::slice::iter::Iter")
                                            []
                                            [
                                              Ty.path
                                                "move_binary_format::file_format::StructTypeParameter"
                                            ],
                                          [],
                                          [],
                                          "map",
                                          [],
                                          [
                                            Ty.path "bool";
                                            Ty.function
                                              [
                                                Ty.tuple
                                                  [
                                                    Ty.apply
                                                      (Ty.path "&")
                                                      []
                                                      [
                                                        Ty.path
                                                          "move_binary_format::file_format::StructTypeParameter"
                                                      ]
                                                  ]
                                              ]
                                              (Ty.path "bool")
                                          ]
                                        |),
                                        [
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::slice::iter::Iter")
                                              []
                                              [
                                                Ty.path
                                                  "move_binary_format::file_format::StructTypeParameter"
                                              ],
                                            M.get_associated_function (|
                                              Ty.apply
                                                (Ty.path "slice")
                                                []
                                                [
                                                  Ty.path
                                                    "move_binary_format::file_format::StructTypeParameter"
                                                ],
                                              "iter",
                                              [],
                                              []
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (|
                                                  M.call_closure (|
                                                    Ty.apply
                                                      (Ty.path "&")
                                                      []
                                                      [
                                                        Ty.apply
                                                          (Ty.path "slice")
                                                          []
                                                          [
                                                            Ty.path
                                                              "move_binary_format::file_format::StructTypeParameter"
                                                          ]
                                                      ],
                                                    M.get_trait_method (|
                                                      "core::ops::deref::Deref",
                                                      Ty.apply
                                                        (Ty.path "alloc::vec::Vec")
                                                        []
                                                        [
                                                          Ty.path
                                                            "move_binary_format::file_format::StructTypeParameter";
                                                          Ty.path "alloc::alloc::Global"
                                                        ],
                                                      [],
                                                      [],
                                                      "deref",
                                                      [],
                                                      []
                                                    |),
                                                    [
                                                      M.borrow (|
                                                        Pointer.Kind.Ref,
                                                        M.SubPointer.get_struct_record_field (|
                                                          M.deref (| M.read (| sh |) |),
                                                          "move_binary_format::file_format::StructHandle",
                                                          "type_parameters"
                                                        |)
                                                      |)
                                                    ]
                                                  |)
                                                |)
                                              |)
                                            ]
                                          |);
                                          M.closure
                                            (fun γ =>
                                              ltac:(M.monadic
                                                match γ with
                                                | [ α0 ] =>
                                                  ltac:(M.monadic
                                                    (M.match_operator (|
                                                      Ty.apply
                                                        (Ty.path "*")
                                                        []
                                                        [
                                                          Ty.function
                                                            [
                                                              Ty.tuple
                                                                [
                                                                  Ty.apply
                                                                    (Ty.path "&")
                                                                    []
                                                                    [
                                                                      Ty.path
                                                                        "move_binary_format::file_format::StructTypeParameter"
                                                                    ]
                                                                ]
                                                            ]
                                                            (Ty.path "bool")
                                                        ],
                                                      M.alloc (| α0 |),
                                                      [
                                                        fun γ =>
                                                          ltac:(M.monadic
                                                            (let param := M.copy (| γ |) in
                                                            M.read (|
                                                              M.SubPointer.get_struct_record_field (|
                                                                M.deref (| M.read (| param |) |),
                                                                "move_binary_format::file_format::StructTypeParameter",
                                                                "is_phantom"
                                                              |)
                                                            |)))
                                                      ]
                                                    |)))
                                                | _ => M.impossible "wrong number of arguments"
                                                end))
                                        ]
                                      |);
                                      M.read (| type_arguments |)
                                    ]
                                  |)
                                |)))
                          ]
                        |)))
                  ]
                |)
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_abilities :
      M.IsAssociatedFunction.C Self "abilities" abilities.
    Admitted.
    Global Typeclasses Opaque abilities.
    
    (*
        pub fn module_id_for_handle(&self, module_handle: &ModuleHandle) -> ModuleId {
            ModuleId::new(
                *self.address_identifier_at(module_handle.address),
                self.identifier_at(module_handle.name).to_owned(),
            )
        }
    *)
    Definition module_id_for_handle (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; module_handle ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let module_handle := M.alloc (| module_handle |) in
          M.call_closure (|
            Ty.path "move_core_types::language_storage::ModuleId",
            M.get_associated_function (|
              Ty.path "move_core_types::language_storage::ModuleId",
              "new",
              [],
              []
            |),
            [
              M.read (|
                M.deref (|
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "&")
                      []
                      [ Ty.path "move_core_types::account_address::AccountAddress" ],
                    M.get_associated_function (|
                      Ty.path "move_binary_format::file_format::CompiledModule",
                      "address_identifier_at",
                      [],
                      []
                    |),
                    [
                      M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| module_handle |) |),
                          "move_binary_format::file_format::ModuleHandle",
                          "address"
                        |)
                      |)
                    ]
                  |)
                |)
              |);
              M.call_closure (|
                Ty.path "move_core_types::identifier::Identifier",
                M.get_trait_method (|
                  "alloc::borrow::ToOwned",
                  Ty.path "move_core_types::identifier::IdentStr",
                  [],
                  [],
                  "to_owned",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "&")
                          []
                          [ Ty.path "move_core_types::identifier::IdentStr" ],
                        M.get_associated_function (|
                          Ty.path "move_binary_format::file_format::CompiledModule",
                          "identifier_at",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                          M.read (|
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| module_handle |) |),
                              "move_binary_format::file_format::ModuleHandle",
                              "name"
                            |)
                          |)
                        ]
                      |)
                    |)
                  |)
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_module_id_for_handle :
      M.IsAssociatedFunction.C Self "module_id_for_handle" module_id_for_handle.
    Admitted.
    Global Typeclasses Opaque module_id_for_handle.
    
    (*
        pub fn self_id(&self) -> ModuleId {
            self.module_id_for_handle(self.self_handle())
        }
    *)
    Definition self_id (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            Ty.path "move_core_types::language_storage::ModuleId",
            M.get_associated_function (|
              Ty.path "move_binary_format::file_format::CompiledModule",
              "module_id_for_handle",
              [],
              []
            |),
            [
              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "&")
                      []
                      [ Ty.path "move_binary_format::file_format::ModuleHandle" ],
                    M.get_associated_function (|
                      Ty.path "move_binary_format::file_format::CompiledModule",
                      "self_handle",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_self_id : M.IsAssociatedFunction.C Self "self_id" self_id.
    Admitted.
    Global Typeclasses Opaque self_id.
  End Impl_move_binary_format_file_format_CompiledModule.
  
  (*
  pub fn empty_module() -> CompiledModule {
      CompiledModule {
          version: file_format_common::VERSION_MAX,
          module_handles: vec![ModuleHandle {
              address: AddressIdentifierIndex(0),
              name: IdentifierIndex(0),
          }],
          self_module_handle_idx: ModuleHandleIndex(0),
          identifiers: vec![self_module_name().to_owned()],
          address_identifiers: vec![AccountAddress::ZERO],
          constant_pool: vec![],
          metadata: vec![],
          function_defs: vec![],
          struct_defs: vec![],
          struct_handles: vec![],
          function_handles: vec![],
          field_handles: vec![],
          friend_decls: vec![],
          struct_def_instantiations: vec![],
          function_instantiations: vec![],
          field_instantiations: vec![],
          signatures: vec![Signature(vec![])],
      }
  }
  *)
  Definition empty_module (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [] =>
      ltac:(M.monadic
        (Value.StructRecord
          "move_binary_format::file_format::CompiledModule"
          []
          []
          [
            ("version",
              M.read (|
                get_constant (|
                  "move_binary_format::file_format_common::VERSION_MAX",
                  Ty.path "u32"
                |)
              |));
            ("module_handles",
              M.call_closure (|
                Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  []
                  [
                    Ty.path "move_binary_format::file_format::ModuleHandle";
                    Ty.path "alloc::alloc::Global"
                  ],
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "slice")
                    []
                    [ Ty.path "move_binary_format::file_format::ModuleHandle" ],
                  "into_vec",
                  [],
                  [ Ty.path "alloc::alloc::Global" ]
                |),
                [
                  (* Unsize *)
                  M.pointer_coercion
                    (M.read (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "alloc::boxed::Box")
                          []
                          [
                            Ty.apply
                              (Ty.path "array")
                              [ Value.Integer IntegerKind.Usize 1 ]
                              [ Ty.path "move_binary_format::file_format::ModuleHandle" ];
                            Ty.path "alloc::alloc::Global"
                          ],
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::boxed::Box")
                            []
                            [
                              Ty.apply
                                (Ty.path "array")
                                [ Value.Integer IntegerKind.Usize 1 ]
                                [ Ty.path "move_binary_format::file_format::ModuleHandle" ];
                              Ty.path "alloc::alloc::Global"
                            ],
                          "new",
                          [],
                          []
                        |),
                        [
                          M.alloc (|
                            Value.Array
                              [
                                Value.StructRecord
                                  "move_binary_format::file_format::ModuleHandle"
                                  []
                                  []
                                  [
                                    ("address",
                                      Value.StructTuple
                                        "move_binary_format::file_format::AddressIdentifierIndex"
                                        []
                                        []
                                        [ Value.Integer IntegerKind.U16 0 ]);
                                    ("name",
                                      Value.StructTuple
                                        "move_binary_format::file_format::IdentifierIndex"
                                        []
                                        []
                                        [ Value.Integer IntegerKind.U16 0 ])
                                  ]
                              ]
                          |)
                        ]
                      |)
                    |))
                ]
              |));
            ("self_module_handle_idx",
              Value.StructTuple
                "move_binary_format::file_format::ModuleHandleIndex"
                []
                []
                [ Value.Integer IntegerKind.U16 0 ]);
            ("identifiers",
              M.call_closure (|
                Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  []
                  [
                    Ty.path "move_core_types::identifier::Identifier";
                    Ty.path "alloc::alloc::Global"
                  ],
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "slice")
                    []
                    [ Ty.path "move_core_types::identifier::Identifier" ],
                  "into_vec",
                  [],
                  [ Ty.path "alloc::alloc::Global" ]
                |),
                [
                  (* Unsize *)
                  M.pointer_coercion
                    (M.read (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "alloc::boxed::Box")
                          []
                          [
                            Ty.apply
                              (Ty.path "array")
                              [ Value.Integer IntegerKind.Usize 1 ]
                              [ Ty.path "move_core_types::identifier::Identifier" ];
                            Ty.path "alloc::alloc::Global"
                          ],
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::boxed::Box")
                            []
                            [
                              Ty.apply
                                (Ty.path "array")
                                [ Value.Integer IntegerKind.Usize 1 ]
                                [ Ty.path "move_core_types::identifier::Identifier" ];
                              Ty.path "alloc::alloc::Global"
                            ],
                          "new",
                          [],
                          []
                        |),
                        [
                          M.alloc (|
                            Value.Array
                              [
                                M.call_closure (|
                                  Ty.path "move_core_types::identifier::Identifier",
                                  M.get_trait_method (|
                                    "alloc::borrow::ToOwned",
                                    Ty.path "move_core_types::identifier::IdentStr",
                                    [],
                                    [],
                                    "to_owned",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (|
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "&")
                                            []
                                            [ Ty.path "move_core_types::identifier::IdentStr" ],
                                          M.get_function (|
                                            "move_binary_format::file_format::self_module_name",
                                            [],
                                            []
                                          |),
                                          []
                                        |)
                                      |)
                                    |)
                                  ]
                                |)
                              ]
                          |)
                        ]
                      |)
                    |))
                ]
              |));
            ("address_identifiers",
              M.call_closure (|
                Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  []
                  [
                    Ty.path "move_core_types::account_address::AccountAddress";
                    Ty.path "alloc::alloc::Global"
                  ],
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "slice")
                    []
                    [ Ty.path "move_core_types::account_address::AccountAddress" ],
                  "into_vec",
                  [],
                  [ Ty.path "alloc::alloc::Global" ]
                |),
                [
                  (* Unsize *)
                  M.pointer_coercion
                    (M.read (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "alloc::boxed::Box")
                          []
                          [
                            Ty.apply
                              (Ty.path "array")
                              [ Value.Integer IntegerKind.Usize 1 ]
                              [ Ty.path "move_core_types::account_address::AccountAddress" ];
                            Ty.path "alloc::alloc::Global"
                          ],
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::boxed::Box")
                            []
                            [
                              Ty.apply
                                (Ty.path "array")
                                [ Value.Integer IntegerKind.Usize 1 ]
                                [ Ty.path "move_core_types::account_address::AccountAddress" ];
                              Ty.path "alloc::alloc::Global"
                            ],
                          "new",
                          [],
                          []
                        |),
                        [
                          M.alloc (|
                            Value.Array
                              [
                                M.read (|
                                  get_associated_constant (|
                                    Ty.path "move_core_types::account_address::AccountAddress",
                                    "ZERO",
                                    Ty.path "move_core_types::account_address::AccountAddress"
                                  |)
                                |)
                              ]
                          |)
                        ]
                      |)
                    |))
                ]
              |));
            ("constant_pool",
              M.call_closure (|
                Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  []
                  [
                    Ty.path "move_binary_format::file_format::Constant";
                    Ty.path "alloc::alloc::Global"
                  ],
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [
                      Ty.path "move_binary_format::file_format::Constant";
                      Ty.path "alloc::alloc::Global"
                    ],
                  "new",
                  [],
                  []
                |),
                []
              |));
            ("metadata",
              M.call_closure (|
                Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  []
                  [ Ty.path "move_core_types::metadata::Metadata"; Ty.path "alloc::alloc::Global" ],
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [ Ty.path "move_core_types::metadata::Metadata"; Ty.path "alloc::alloc::Global"
                    ],
                  "new",
                  [],
                  []
                |),
                []
              |));
            ("function_defs",
              M.call_closure (|
                Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  []
                  [
                    Ty.path "move_binary_format::file_format::FunctionDefinition";
                    Ty.path "alloc::alloc::Global"
                  ],
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [
                      Ty.path "move_binary_format::file_format::FunctionDefinition";
                      Ty.path "alloc::alloc::Global"
                    ],
                  "new",
                  [],
                  []
                |),
                []
              |));
            ("struct_defs",
              M.call_closure (|
                Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  []
                  [
                    Ty.path "move_binary_format::file_format::StructDefinition";
                    Ty.path "alloc::alloc::Global"
                  ],
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [
                      Ty.path "move_binary_format::file_format::StructDefinition";
                      Ty.path "alloc::alloc::Global"
                    ],
                  "new",
                  [],
                  []
                |),
                []
              |));
            ("struct_handles",
              M.call_closure (|
                Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  []
                  [
                    Ty.path "move_binary_format::file_format::StructHandle";
                    Ty.path "alloc::alloc::Global"
                  ],
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [
                      Ty.path "move_binary_format::file_format::StructHandle";
                      Ty.path "alloc::alloc::Global"
                    ],
                  "new",
                  [],
                  []
                |),
                []
              |));
            ("function_handles",
              M.call_closure (|
                Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  []
                  [
                    Ty.path "move_binary_format::file_format::FunctionHandle";
                    Ty.path "alloc::alloc::Global"
                  ],
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [
                      Ty.path "move_binary_format::file_format::FunctionHandle";
                      Ty.path "alloc::alloc::Global"
                    ],
                  "new",
                  [],
                  []
                |),
                []
              |));
            ("field_handles",
              M.call_closure (|
                Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  []
                  [
                    Ty.path "move_binary_format::file_format::FieldHandle";
                    Ty.path "alloc::alloc::Global"
                  ],
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [
                      Ty.path "move_binary_format::file_format::FieldHandle";
                      Ty.path "alloc::alloc::Global"
                    ],
                  "new",
                  [],
                  []
                |),
                []
              |));
            ("friend_decls",
              M.call_closure (|
                Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  []
                  [
                    Ty.path "move_binary_format::file_format::ModuleHandle";
                    Ty.path "alloc::alloc::Global"
                  ],
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [
                      Ty.path "move_binary_format::file_format::ModuleHandle";
                      Ty.path "alloc::alloc::Global"
                    ],
                  "new",
                  [],
                  []
                |),
                []
              |));
            ("struct_def_instantiations",
              M.call_closure (|
                Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  []
                  [
                    Ty.path "move_binary_format::file_format::StructDefInstantiation";
                    Ty.path "alloc::alloc::Global"
                  ],
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [
                      Ty.path "move_binary_format::file_format::StructDefInstantiation";
                      Ty.path "alloc::alloc::Global"
                    ],
                  "new",
                  [],
                  []
                |),
                []
              |));
            ("function_instantiations",
              M.call_closure (|
                Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  []
                  [
                    Ty.path "move_binary_format::file_format::FunctionInstantiation";
                    Ty.path "alloc::alloc::Global"
                  ],
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [
                      Ty.path "move_binary_format::file_format::FunctionInstantiation";
                      Ty.path "alloc::alloc::Global"
                    ],
                  "new",
                  [],
                  []
                |),
                []
              |));
            ("field_instantiations",
              M.call_closure (|
                Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  []
                  [
                    Ty.path "move_binary_format::file_format::FieldInstantiation";
                    Ty.path "alloc::alloc::Global"
                  ],
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [
                      Ty.path "move_binary_format::file_format::FieldInstantiation";
                      Ty.path "alloc::alloc::Global"
                    ],
                  "new",
                  [],
                  []
                |),
                []
              |));
            ("signatures",
              M.call_closure (|
                Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  []
                  [
                    Ty.path "move_binary_format::file_format::Signature";
                    Ty.path "alloc::alloc::Global"
                  ],
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "slice")
                    []
                    [ Ty.path "move_binary_format::file_format::Signature" ],
                  "into_vec",
                  [],
                  [ Ty.path "alloc::alloc::Global" ]
                |),
                [
                  (* Unsize *)
                  M.pointer_coercion
                    (M.read (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "alloc::boxed::Box")
                          []
                          [
                            Ty.apply
                              (Ty.path "array")
                              [ Value.Integer IntegerKind.Usize 1 ]
                              [ Ty.path "move_binary_format::file_format::Signature" ];
                            Ty.path "alloc::alloc::Global"
                          ],
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::boxed::Box")
                            []
                            [
                              Ty.apply
                                (Ty.path "array")
                                [ Value.Integer IntegerKind.Usize 1 ]
                                [ Ty.path "move_binary_format::file_format::Signature" ];
                              Ty.path "alloc::alloc::Global"
                            ],
                          "new",
                          [],
                          []
                        |),
                        [
                          M.alloc (|
                            Value.Array
                              [
                                Value.StructTuple
                                  "move_binary_format::file_format::Signature"
                                  []
                                  []
                                  [
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "alloc::vec::Vec")
                                        []
                                        [
                                          Ty.path "move_binary_format::file_format::SignatureToken";
                                          Ty.path "alloc::alloc::Global"
                                        ],
                                      M.get_associated_function (|
                                        Ty.apply
                                          (Ty.path "alloc::vec::Vec")
                                          []
                                          [
                                            Ty.path
                                              "move_binary_format::file_format::SignatureToken";
                                            Ty.path "alloc::alloc::Global"
                                          ],
                                        "new",
                                        [],
                                        []
                                      |),
                                      []
                                    |)
                                  ]
                              ]
                          |)
                        ]
                      |)
                    |))
                ]
              |))
          ]))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_empty_module :
    M.IsFunction.C "move_binary_format::file_format::empty_module" empty_module.
  Admitted.
  Global Typeclasses Opaque empty_module.
  
  (*
  pub fn basic_test_module() -> CompiledModule {
      let mut m = empty_module();
  
      m.function_handles.push(FunctionHandle {
          module: ModuleHandleIndex(0),
          name: IdentifierIndex(m.identifiers.len() as u16),
          parameters: SignatureIndex(0),
          return_: SignatureIndex(0),
          type_parameters: vec![],
      });
      m.identifiers
          .push(Identifier::new("foo".to_string()).unwrap());
  
      m.function_defs.push(FunctionDefinition {
          function: FunctionHandleIndex(0),
          visibility: Visibility::Private,
          is_entry: false,
          acquires_global_resources: vec![],
          code: Some(CodeUnit {
              locals: SignatureIndex(0),
              code: vec![Bytecode::Ret],
          }),
      });
  
      m.struct_handles.push(StructHandle {
          module: ModuleHandleIndex(0),
          name: IdentifierIndex(m.identifiers.len() as u16),
          abilities: AbilitySet::EMPTY,
          type_parameters: vec![],
      });
      m.identifiers
          .push(Identifier::new("Bar".to_string()).unwrap());
  
      m.struct_defs.push(StructDefinition {
          struct_handle: StructHandleIndex(0),
          field_information: StructFieldInformation::Declared(vec![FieldDefinition {
              name: IdentifierIndex(m.identifiers.len() as u16),
              signature: TypeSignature(SignatureToken::U64),
          }]),
      });
      m.identifiers
          .push(Identifier::new("x".to_string()).unwrap());
  
      m
  }
  *)
  Definition basic_test_module (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [] =>
      ltac:(M.monadic
        (M.read (|
          let~ m : Ty.path "move_binary_format::file_format::CompiledModule" :=
            M.call_closure (|
              Ty.path "move_binary_format::file_format::CompiledModule",
              M.get_function (| "move_binary_format::file_format::empty_module", [], [] |),
              []
            |) in
          let~ _ : Ty.tuple [] :=
            M.call_closure (|
              Ty.tuple [],
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  []
                  [
                    Ty.path "move_binary_format::file_format::FunctionHandle";
                    Ty.path "alloc::alloc::Global"
                  ],
                "push",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.SubPointer.get_struct_record_field (|
                    m,
                    "move_binary_format::file_format::CompiledModule",
                    "function_handles"
                  |)
                |);
                Value.StructRecord
                  "move_binary_format::file_format::FunctionHandle"
                  []
                  []
                  [
                    ("module",
                      Value.StructTuple
                        "move_binary_format::file_format::ModuleHandleIndex"
                        []
                        []
                        [ Value.Integer IntegerKind.U16 0 ]);
                    ("name",
                      Value.StructTuple
                        "move_binary_format::file_format::IdentifierIndex"
                        []
                        []
                        [
                          M.cast
                            (Ty.path "u16")
                            (M.call_closure (|
                              Ty.path "usize",
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "alloc::vec::Vec")
                                  []
                                  [
                                    Ty.path "move_core_types::identifier::Identifier";
                                    Ty.path "alloc::alloc::Global"
                                  ],
                                "len",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.SubPointer.get_struct_record_field (|
                                    m,
                                    "move_binary_format::file_format::CompiledModule",
                                    "identifiers"
                                  |)
                                |)
                              ]
                            |))
                        ]);
                    ("parameters",
                      Value.StructTuple
                        "move_binary_format::file_format::SignatureIndex"
                        []
                        []
                        [ Value.Integer IntegerKind.U16 0 ]);
                    ("return_",
                      Value.StructTuple
                        "move_binary_format::file_format::SignatureIndex"
                        []
                        []
                        [ Value.Integer IntegerKind.U16 0 ]);
                    ("type_parameters",
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "alloc::vec::Vec")
                          []
                          [
                            Ty.path "move_binary_format::file_format::AbilitySet";
                            Ty.path "alloc::alloc::Global"
                          ],
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            []
                            [
                              Ty.path "move_binary_format::file_format::AbilitySet";
                              Ty.path "alloc::alloc::Global"
                            ],
                          "new",
                          [],
                          []
                        |),
                        []
                      |))
                  ]
              ]
            |) in
          let~ _ : Ty.tuple [] :=
            M.call_closure (|
              Ty.tuple [],
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  []
                  [
                    Ty.path "move_core_types::identifier::Identifier";
                    Ty.path "alloc::alloc::Global"
                  ],
                "push",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.SubPointer.get_struct_record_field (|
                    m,
                    "move_binary_format::file_format::CompiledModule",
                    "identifiers"
                  |)
                |);
                M.call_closure (|
                  Ty.path "move_core_types::identifier::Identifier",
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.path "move_core_types::identifier::Identifier"; Ty.path "anyhow::Error"
                      ],
                    "unwrap",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [ Ty.path "move_core_types::identifier::Identifier"; Ty.path "anyhow::Error"
                        ],
                      M.get_associated_function (|
                        Ty.path "move_core_types::identifier::Identifier",
                        "new",
                        [],
                        [ Ty.path "alloc::string::String" ]
                      |),
                      [
                        M.call_closure (|
                          Ty.path "alloc::string::String",
                          M.get_trait_method (|
                            "alloc::string::ToString",
                            Ty.path "str",
                            [],
                            [],
                            "to_string",
                            [],
                            []
                          |),
                          [ M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "foo" |) |) |) ]
                        |)
                      ]
                    |)
                  ]
                |)
              ]
            |) in
          let~ _ : Ty.tuple [] :=
            M.call_closure (|
              Ty.tuple [],
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  []
                  [
                    Ty.path "move_binary_format::file_format::FunctionDefinition";
                    Ty.path "alloc::alloc::Global"
                  ],
                "push",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.SubPointer.get_struct_record_field (|
                    m,
                    "move_binary_format::file_format::CompiledModule",
                    "function_defs"
                  |)
                |);
                Value.StructRecord
                  "move_binary_format::file_format::FunctionDefinition"
                  []
                  []
                  [
                    ("function",
                      Value.StructTuple
                        "move_binary_format::file_format::FunctionHandleIndex"
                        []
                        []
                        [ Value.Integer IntegerKind.U16 0 ]);
                    ("visibility",
                      Value.StructTuple
                        "move_binary_format::file_format::Visibility::Private"
                        []
                        []
                        []);
                    ("is_entry", Value.Bool false);
                    ("acquires_global_resources",
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "alloc::vec::Vec")
                          []
                          [
                            Ty.path "move_binary_format::file_format::StructDefinitionIndex";
                            Ty.path "alloc::alloc::Global"
                          ],
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            []
                            [
                              Ty.path "move_binary_format::file_format::StructDefinitionIndex";
                              Ty.path "alloc::alloc::Global"
                            ],
                          "new",
                          [],
                          []
                        |),
                        []
                      |));
                    ("code",
                      Value.StructTuple
                        "core::option::Option::Some"
                        []
                        [ Ty.path "move_binary_format::file_format::CodeUnit" ]
                        [
                          Value.StructRecord
                            "move_binary_format::file_format::CodeUnit"
                            []
                            []
                            [
                              ("locals",
                                Value.StructTuple
                                  "move_binary_format::file_format::SignatureIndex"
                                  []
                                  []
                                  [ Value.Integer IntegerKind.U16 0 ]);
                              ("code",
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "alloc::vec::Vec")
                                    []
                                    [
                                      Ty.path "move_binary_format::file_format::Bytecode";
                                      Ty.path "alloc::alloc::Global"
                                    ],
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "slice")
                                      []
                                      [ Ty.path "move_binary_format::file_format::Bytecode" ],
                                    "into_vec",
                                    [],
                                    [ Ty.path "alloc::alloc::Global" ]
                                  |),
                                  [
                                    (* Unsize *)
                                    M.pointer_coercion
                                      (M.read (|
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "alloc::boxed::Box")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "array")
                                                [ Value.Integer IntegerKind.Usize 1 ]
                                                [
                                                  Ty.path
                                                    "move_binary_format::file_format::Bytecode"
                                                ];
                                              Ty.path "alloc::alloc::Global"
                                            ],
                                          M.get_associated_function (|
                                            Ty.apply
                                              (Ty.path "alloc::boxed::Box")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "array")
                                                  [ Value.Integer IntegerKind.Usize 1 ]
                                                  [
                                                    Ty.path
                                                      "move_binary_format::file_format::Bytecode"
                                                  ];
                                                Ty.path "alloc::alloc::Global"
                                              ],
                                            "new",
                                            [],
                                            []
                                          |),
                                          [
                                            M.alloc (|
                                              Value.Array
                                                [
                                                  Value.StructTuple
                                                    "move_binary_format::file_format::Bytecode::Ret"
                                                    []
                                                    []
                                                    []
                                                ]
                                            |)
                                          ]
                                        |)
                                      |))
                                  ]
                                |))
                            ]
                        ])
                  ]
              ]
            |) in
          let~ _ : Ty.tuple [] :=
            M.call_closure (|
              Ty.tuple [],
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  []
                  [
                    Ty.path "move_binary_format::file_format::StructHandle";
                    Ty.path "alloc::alloc::Global"
                  ],
                "push",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.SubPointer.get_struct_record_field (|
                    m,
                    "move_binary_format::file_format::CompiledModule",
                    "struct_handles"
                  |)
                |);
                Value.StructRecord
                  "move_binary_format::file_format::StructHandle"
                  []
                  []
                  [
                    ("module",
                      Value.StructTuple
                        "move_binary_format::file_format::ModuleHandleIndex"
                        []
                        []
                        [ Value.Integer IntegerKind.U16 0 ]);
                    ("name",
                      Value.StructTuple
                        "move_binary_format::file_format::IdentifierIndex"
                        []
                        []
                        [
                          M.cast
                            (Ty.path "u16")
                            (M.call_closure (|
                              Ty.path "usize",
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "alloc::vec::Vec")
                                  []
                                  [
                                    Ty.path "move_core_types::identifier::Identifier";
                                    Ty.path "alloc::alloc::Global"
                                  ],
                                "len",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.SubPointer.get_struct_record_field (|
                                    m,
                                    "move_binary_format::file_format::CompiledModule",
                                    "identifiers"
                                  |)
                                |)
                              ]
                            |))
                        ]);
                    ("abilities",
                      M.read (|
                        get_associated_constant (|
                          Ty.path "move_binary_format::file_format::AbilitySet",
                          "EMPTY",
                          Ty.path "move_binary_format::file_format::AbilitySet"
                        |)
                      |));
                    ("type_parameters",
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "alloc::vec::Vec")
                          []
                          [
                            Ty.path "move_binary_format::file_format::StructTypeParameter";
                            Ty.path "alloc::alloc::Global"
                          ],
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            []
                            [
                              Ty.path "move_binary_format::file_format::StructTypeParameter";
                              Ty.path "alloc::alloc::Global"
                            ],
                          "new",
                          [],
                          []
                        |),
                        []
                      |))
                  ]
              ]
            |) in
          let~ _ : Ty.tuple [] :=
            M.call_closure (|
              Ty.tuple [],
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  []
                  [
                    Ty.path "move_core_types::identifier::Identifier";
                    Ty.path "alloc::alloc::Global"
                  ],
                "push",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.SubPointer.get_struct_record_field (|
                    m,
                    "move_binary_format::file_format::CompiledModule",
                    "identifiers"
                  |)
                |);
                M.call_closure (|
                  Ty.path "move_core_types::identifier::Identifier",
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.path "move_core_types::identifier::Identifier"; Ty.path "anyhow::Error"
                      ],
                    "unwrap",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [ Ty.path "move_core_types::identifier::Identifier"; Ty.path "anyhow::Error"
                        ],
                      M.get_associated_function (|
                        Ty.path "move_core_types::identifier::Identifier",
                        "new",
                        [],
                        [ Ty.path "alloc::string::String" ]
                      |),
                      [
                        M.call_closure (|
                          Ty.path "alloc::string::String",
                          M.get_trait_method (|
                            "alloc::string::ToString",
                            Ty.path "str",
                            [],
                            [],
                            "to_string",
                            [],
                            []
                          |),
                          [ M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "Bar" |) |) |) ]
                        |)
                      ]
                    |)
                  ]
                |)
              ]
            |) in
          let~ _ : Ty.tuple [] :=
            M.call_closure (|
              Ty.tuple [],
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  []
                  [
                    Ty.path "move_binary_format::file_format::StructDefinition";
                    Ty.path "alloc::alloc::Global"
                  ],
                "push",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.SubPointer.get_struct_record_field (|
                    m,
                    "move_binary_format::file_format::CompiledModule",
                    "struct_defs"
                  |)
                |);
                Value.StructRecord
                  "move_binary_format::file_format::StructDefinition"
                  []
                  []
                  [
                    ("struct_handle",
                      Value.StructTuple
                        "move_binary_format::file_format::StructHandleIndex"
                        []
                        []
                        [ Value.Integer IntegerKind.U16 0 ]);
                    ("field_information",
                      Value.StructTuple
                        "move_binary_format::file_format::StructFieldInformation::Declared"
                        []
                        []
                        [
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              []
                              [
                                Ty.path "move_binary_format::file_format::FieldDefinition";
                                Ty.path "alloc::alloc::Global"
                              ],
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "slice")
                                []
                                [ Ty.path "move_binary_format::file_format::FieldDefinition" ],
                              "into_vec",
                              [],
                              [ Ty.path "alloc::alloc::Global" ]
                            |),
                            [
                              (* Unsize *)
                              M.pointer_coercion
                                (M.read (|
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "alloc::boxed::Box")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "array")
                                          [ Value.Integer IntegerKind.Usize 1 ]
                                          [
                                            Ty.path
                                              "move_binary_format::file_format::FieldDefinition"
                                          ];
                                        Ty.path "alloc::alloc::Global"
                                      ],
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "alloc::boxed::Box")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "array")
                                            [ Value.Integer IntegerKind.Usize 1 ]
                                            [
                                              Ty.path
                                                "move_binary_format::file_format::FieldDefinition"
                                            ];
                                          Ty.path "alloc::alloc::Global"
                                        ],
                                      "new",
                                      [],
                                      []
                                    |),
                                    [
                                      M.alloc (|
                                        Value.Array
                                          [
                                            Value.StructRecord
                                              "move_binary_format::file_format::FieldDefinition"
                                              []
                                              []
                                              [
                                                ("name",
                                                  Value.StructTuple
                                                    "move_binary_format::file_format::IdentifierIndex"
                                                    []
                                                    []
                                                    [
                                                      M.cast
                                                        (Ty.path "u16")
                                                        (M.call_closure (|
                                                          Ty.path "usize",
                                                          M.get_associated_function (|
                                                            Ty.apply
                                                              (Ty.path "alloc::vec::Vec")
                                                              []
                                                              [
                                                                Ty.path
                                                                  "move_core_types::identifier::Identifier";
                                                                Ty.path "alloc::alloc::Global"
                                                              ],
                                                            "len",
                                                            [],
                                                            []
                                                          |),
                                                          [
                                                            M.borrow (|
                                                              Pointer.Kind.Ref,
                                                              M.SubPointer.get_struct_record_field (|
                                                                m,
                                                                "move_binary_format::file_format::CompiledModule",
                                                                "identifiers"
                                                              |)
                                                            |)
                                                          ]
                                                        |))
                                                    ]);
                                                ("signature",
                                                  Value.StructTuple
                                                    "move_binary_format::file_format::TypeSignature"
                                                    []
                                                    []
                                                    [
                                                      Value.StructTuple
                                                        "move_binary_format::file_format::SignatureToken::U64"
                                                        []
                                                        []
                                                        []
                                                    ])
                                              ]
                                          ]
                                      |)
                                    ]
                                  |)
                                |))
                            ]
                          |)
                        ])
                  ]
              ]
            |) in
          let~ _ : Ty.tuple [] :=
            M.call_closure (|
              Ty.tuple [],
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  []
                  [
                    Ty.path "move_core_types::identifier::Identifier";
                    Ty.path "alloc::alloc::Global"
                  ],
                "push",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.SubPointer.get_struct_record_field (|
                    m,
                    "move_binary_format::file_format::CompiledModule",
                    "identifiers"
                  |)
                |);
                M.call_closure (|
                  Ty.path "move_core_types::identifier::Identifier",
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.path "move_core_types::identifier::Identifier"; Ty.path "anyhow::Error"
                      ],
                    "unwrap",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [ Ty.path "move_core_types::identifier::Identifier"; Ty.path "anyhow::Error"
                        ],
                      M.get_associated_function (|
                        Ty.path "move_core_types::identifier::Identifier",
                        "new",
                        [],
                        [ Ty.path "alloc::string::String" ]
                      |),
                      [
                        M.call_closure (|
                          Ty.path "alloc::string::String",
                          M.get_trait_method (|
                            "alloc::string::ToString",
                            Ty.path "str",
                            [],
                            [],
                            "to_string",
                            [],
                            []
                          |),
                          [ M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "x" |) |) |) ]
                        |)
                      ]
                    |)
                  ]
                |)
              ]
            |) in
          m
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_basic_test_module :
    M.IsFunction.C "move_binary_format::file_format::basic_test_module" basic_test_module.
  Admitted.
  Global Typeclasses Opaque basic_test_module.
End file_format.
