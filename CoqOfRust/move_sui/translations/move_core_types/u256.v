(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module u256.
  Definition value_NUM_BITS_PER_BYTE (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.Usize 8 |))).
  
  Global Instance Instance_IsConstant_value_NUM_BITS_PER_BYTE :
    M.IsFunction.C "move_core_types::u256::NUM_BITS_PER_BYTE" value_NUM_BITS_PER_BYTE.
  Admitted.
  Global Typeclasses Opaque value_NUM_BITS_PER_BYTE.
  
  Definition value_U256_NUM_BITS (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    ltac:(M.monadic (M.alloc (| Value.Integer IntegerKind.Usize 256 |))).
  
  Global Instance Instance_IsConstant_value_U256_NUM_BITS :
    M.IsFunction.C "move_core_types::u256::U256_NUM_BITS" value_U256_NUM_BITS.
  Admitted.
  Global Typeclasses Opaque value_U256_NUM_BITS.
  
  Definition value_U256_NUM_BYTES (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    ltac:(M.monadic
      (M.alloc (|
        M.call_closure (|
          Ty.path "usize",
          BinOp.Wrap.div,
          [
            M.read (| get_constant (| "move_core_types::u256::U256_NUM_BITS", Ty.path "usize" |) |);
            M.read (|
              get_constant (| "move_core_types::u256::NUM_BITS_PER_BYTE", Ty.path "usize" |)
            |)
          ]
        |)
      |))).
  
  Global Instance Instance_IsConstant_value_U256_NUM_BYTES :
    M.IsFunction.C "move_core_types::u256::U256_NUM_BYTES" value_U256_NUM_BYTES.
  Admitted.
  Global Typeclasses Opaque value_U256_NUM_BYTES.
  
  (* StructTuple
    {
      name := "U256FromStrError";
      const_params := [];
      ty_params := [];
      fields := [ Ty.path "uint::uint::FromStrRadixErr" ];
    } *)
  
  Module Impl_core_fmt_Debug_for_move_core_types_u256_U256FromStrError.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::U256FromStrError".
    
    (* Debug *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_associated_function (|
              Ty.path "core::fmt::Formatter",
              "debug_tuple_field1_finish",
              [],
              []
            |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "U256FromStrError" |) |) |);
              (* Unsize *)
              M.pointer_coercion
                (M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.alloc (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_tuple_field (|
                            M.deref (| M.read (| self |) |),
                            "move_core_types::u256::U256FromStrError",
                            0
                          |)
                        |)
                      |)
                    |)
                  |)
                |))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_move_core_types_u256_U256FromStrError.
  
  (*
  Enum U256CastErrorKind
  {
    const_params := [];
    ty_params := [];
    variants :=
      [
        {
          name := "TooLargeForU8";
          item := StructTuple [];
        };
        {
          name := "TooLargeForU16";
          item := StructTuple [];
        };
        {
          name := "TooLargeForU32";
          item := StructTuple [];
        };
        {
          name := "TooLargeForU64";
          item := StructTuple [];
        };
        {
          name := "TooLargeForU128";
          item := StructTuple [];
        }
      ];
  }
  *)
  
  Axiom IsDiscriminant_U256CastErrorKind_TooLargeForU8 :
    M.IsDiscriminant "move_core_types::u256::U256CastErrorKind::TooLargeForU8" 0.
  Axiom IsDiscriminant_U256CastErrorKind_TooLargeForU16 :
    M.IsDiscriminant "move_core_types::u256::U256CastErrorKind::TooLargeForU16" 1.
  Axiom IsDiscriminant_U256CastErrorKind_TooLargeForU32 :
    M.IsDiscriminant "move_core_types::u256::U256CastErrorKind::TooLargeForU32" 2.
  Axiom IsDiscriminant_U256CastErrorKind_TooLargeForU64 :
    M.IsDiscriminant "move_core_types::u256::U256CastErrorKind::TooLargeForU64" 3.
  Axiom IsDiscriminant_U256CastErrorKind_TooLargeForU128 :
    M.IsDiscriminant "move_core_types::u256::U256CastErrorKind::TooLargeForU128" 4.
  
  Module Impl_core_fmt_Debug_for_move_core_types_u256_U256CastErrorKind.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::U256CastErrorKind".
    
    (* Debug *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_str", [], [] |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
              M.read (|
                M.match_operator (|
                  Ty.apply (Ty.path "*") [] [ Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ],
                  self,
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "move_core_types::u256::U256CastErrorKind::TooLargeForU8"
                          |) in
                        M.alloc (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| mk_str (| "TooLargeForU8" |) |)
                          |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "move_core_types::u256::U256CastErrorKind::TooLargeForU16"
                          |) in
                        M.alloc (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| mk_str (| "TooLargeForU16" |) |)
                          |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "move_core_types::u256::U256CastErrorKind::TooLargeForU32"
                          |) in
                        M.alloc (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| mk_str (| "TooLargeForU32" |) |)
                          |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "move_core_types::u256::U256CastErrorKind::TooLargeForU64"
                          |) in
                        M.alloc (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| mk_str (| "TooLargeForU64" |) |)
                          |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "move_core_types::u256::U256CastErrorKind::TooLargeForU128"
                          |) in
                        M.alloc (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| mk_str (| "TooLargeForU128" |) |)
                          |)
                        |)))
                  ]
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_move_core_types_u256_U256CastErrorKind.
  
  Module Impl_core_marker_StructuralPartialEq_for_move_core_types_u256_U256CastErrorKind.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::U256CastErrorKind".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_move_core_types_u256_U256CastErrorKind.
  
  Module Impl_core_cmp_PartialEq_move_core_types_u256_U256CastErrorKind_for_move_core_types_u256_U256CastErrorKind.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::U256CastErrorKind".
    
    (* PartialEq *)
    Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.read (|
            let~ __self_discr : Ty.apply (Ty.path "*") [] [ Ty.path "isize" ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "isize",
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [],
                    [ Ty.path "move_core_types::u256::U256CastErrorKind" ]
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                |)
              |) in
            let~ __arg1_discr : Ty.apply (Ty.path "*") [] [ Ty.path "isize" ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "isize",
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [],
                    [ Ty.path "move_core_types::u256::U256CastErrorKind" ]
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |) ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                Ty.path "bool",
                BinOp.eq,
                [ M.read (| __self_discr |); M.read (| __arg1_discr |) ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "move_core_types::u256::U256CastErrorKind" ]
        Self
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_move_core_types_u256_U256CastErrorKind_for_move_core_types_u256_U256CastErrorKind.
  
  Module Impl_core_cmp_Eq_for_move_core_types_u256_U256CastErrorKind.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::U256CastErrorKind".
    
    (* Eq *)
    Definition assert_receiver_is_total_eq
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.Tuple []))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_move_core_types_u256_U256CastErrorKind.
  
  Module Impl_core_clone_Clone_for_move_core_types_u256_U256CastErrorKind.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::U256CastErrorKind".
    
    (* Clone *)
    Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (| M.deref (| M.read (| self |) |) |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_move_core_types_u256_U256CastErrorKind.
  
  Module Impl_core_marker_Copy_for_move_core_types_u256_U256CastErrorKind.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::U256CastErrorKind".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::Copy"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_Copy_for_move_core_types_u256_U256CastErrorKind.
  
  Module Impl_core_hash_Hash_for_move_core_types_u256_U256CastErrorKind.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::U256CastErrorKind".
    
    (* Hash *)
    Definition hash (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ __H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let state := M.alloc (| state |) in
          M.read (|
            let~ __self_discr : Ty.apply (Ty.path "*") [] [ Ty.path "isize" ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "isize",
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [],
                    [ Ty.path "move_core_types::u256::U256CastErrorKind" ]
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                Ty.tuple [],
                M.get_trait_method (|
                  "core::hash::Hash",
                  Ty.path "isize",
                  [],
                  [],
                  "hash",
                  [],
                  [ __H ]
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (| M.borrow (| Pointer.Kind.Ref, __self_discr |) |)
                  |);
                  M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::hash::Hash"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("hash", InstanceField.Method hash) ].
  End Impl_core_hash_Hash_for_move_core_types_u256_U256CastErrorKind.
  
  (* StructRecord
    {
      name := "U256CastError";
      const_params := [];
      ty_params := [];
      fields :=
        [
          ("kind", Ty.path "move_core_types::u256::U256CastErrorKind");
          ("val", Ty.path "move_core_types::u256::U256")
        ];
    } *)
  
  Module Impl_core_fmt_Debug_for_move_core_types_u256_U256CastError.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::U256CastError".
    
    (* Debug *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_associated_function (|
              Ty.path "core::fmt::Formatter",
              "debug_struct_field2_finish",
              [],
              []
            |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "U256CastError" |) |) |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "kind" |) |) |);
              (* Unsize *)
              M.pointer_coercion
                (M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "move_core_types::u256::U256CastError",
                        "kind"
                      |)
                    |)
                  |)
                |));
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "val" |) |) |);
              (* Unsize *)
              M.pointer_coercion
                (M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.alloc (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "move_core_types::u256::U256CastError",
                            "val"
                          |)
                        |)
                      |)
                    |)
                  |)
                |))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_move_core_types_u256_U256CastError.
  
  Module Impl_move_core_types_u256_U256CastError.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::U256CastError".
    
    (*
        pub fn new<T: std::convert::Into<U256>>(val: T, kind: U256CastErrorKind) -> Self {
            Self {
                kind,
                val: val.into(),
            }
        }
    *)
    Definition new (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ T ], [ val; kind ] =>
        ltac:(M.monadic
          (let val := M.alloc (| val |) in
          let kind := M.alloc (| kind |) in
          Value.StructRecord
            "move_core_types::u256::U256CastError"
            [
              ("kind", M.read (| kind |));
              ("val",
                M.call_closure (|
                  Ty.path "move_core_types::u256::U256",
                  M.get_trait_method (|
                    "core::convert::Into",
                    T,
                    [],
                    [ Ty.path "move_core_types::u256::U256" ],
                    "into",
                    [],
                    []
                  |),
                  [ M.read (| val |) ]
                |))
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_new : M.IsAssociatedFunction.C Self "new" new.
    Admitted.
    Global Typeclasses Opaque new.
  End Impl_move_core_types_u256_U256CastError.
  
  Module Impl_core_error_Error_for_move_core_types_u256_U256CastError.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::U256CastError".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::error::Error"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_error_Error_for_move_core_types_u256_U256CastError.
  
  Module Impl_core_fmt_Display_for_move_core_types_u256_U256CastError.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::U256CastError".
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            let type_str = match self.kind {
                U256CastErrorKind::TooLargeForU8 => "u8",
                U256CastErrorKind::TooLargeForU16 => "u16",
                U256CastErrorKind::TooLargeForU32 => "u32",
                U256CastErrorKind::TooLargeForU64 => "u64",
                U256CastErrorKind::TooLargeForU128 => "u128",
            };
            let err_str = format!("Cast failed. {} too large for {}.", self.val, type_str);
            write!(f, "{err_str}")
        }
    *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.read (|
            let~ type_str :
                Ty.apply (Ty.path "*") [] [ Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ] :=
              M.copy (|
                M.match_operator (|
                  Ty.apply (Ty.path "*") [] [ Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ],
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "move_core_types::u256::U256CastError",
                    "kind"
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "move_core_types::u256::U256CastErrorKind::TooLargeForU8"
                          |) in
                        M.alloc (| mk_str (| "u8" |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "move_core_types::u256::U256CastErrorKind::TooLargeForU16"
                          |) in
                        M.alloc (|
                          M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "u16" |) |) |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "move_core_types::u256::U256CastErrorKind::TooLargeForU32"
                          |) in
                        M.alloc (|
                          M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "u32" |) |) |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "move_core_types::u256::U256CastErrorKind::TooLargeForU64"
                          |) in
                        M.alloc (|
                          M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "u64" |) |) |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "move_core_types::u256::U256CastErrorKind::TooLargeForU128"
                          |) in
                        M.alloc (|
                          M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "u128" |) |) |)
                        |)))
                  ]
                |)
              |) in
            let~ err_str : Ty.apply (Ty.path "*") [] [ Ty.path "alloc::string::String" ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "alloc::string::String",
                  M.get_function (|
                    "core::hint::must_use",
                    [],
                    [ Ty.path "alloc::string::String" ]
                  |),
                  [
                    M.read (|
                      let~ res : Ty.apply (Ty.path "*") [] [ Ty.path "alloc::string::String" ] :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.path "alloc::string::String",
                            M.get_function (| "alloc::fmt::format", [], [] |),
                            [
                              M.call_closure (|
                                Ty.path "core::fmt::Arguments",
                                M.get_associated_function (|
                                  Ty.path "core::fmt::Arguments",
                                  "new_v1",
                                  [
                                    Value.Integer IntegerKind.Usize 3;
                                    Value.Integer IntegerKind.Usize 2
                                  ],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.alloc (|
                                          Value.Array
                                            [
                                              mk_str (| "Cast failed. " |);
                                              mk_str (| " too large for " |);
                                              mk_str (| "." |)
                                            ]
                                        |)
                                      |)
                                    |)
                                  |);
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.alloc (|
                                          Value.Array
                                            [
                                              M.call_closure (|
                                                Ty.path "core::fmt::rt::Argument",
                                                M.get_associated_function (|
                                                  Ty.path "core::fmt::rt::Argument",
                                                  "new_display",
                                                  [],
                                                  [ Ty.path "move_core_types::u256::U256" ]
                                                |),
                                                [
                                                  M.borrow (|
                                                    Pointer.Kind.Ref,
                                                    M.deref (|
                                                      M.borrow (|
                                                        Pointer.Kind.Ref,
                                                        M.SubPointer.get_struct_record_field (|
                                                          M.deref (| M.read (| self |) |),
                                                          "move_core_types::u256::U256CastError",
                                                          "val"
                                                        |)
                                                      |)
                                                    |)
                                                  |)
                                                ]
                                              |);
                                              M.call_closure (|
                                                Ty.path "core::fmt::rt::Argument",
                                                M.get_associated_function (|
                                                  Ty.path "core::fmt::rt::Argument",
                                                  "new_display",
                                                  [],
                                                  [ Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ]
                                                |),
                                                [
                                                  M.borrow (|
                                                    Pointer.Kind.Ref,
                                                    M.deref (|
                                                      M.borrow (| Pointer.Kind.Ref, type_str |)
                                                    |)
                                                  |)
                                                ]
                                              |)
                                            ]
                                        |)
                                      |)
                                    |)
                                  |)
                                ]
                              |)
                            ]
                          |)
                        |) in
                      res
                    |)
                  ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                Ty.apply
                  (Ty.path "core::result::Result")
                  []
                  [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_fmt", [], [] |),
                [
                  M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                  M.call_closure (|
                    Ty.path "core::fmt::Arguments",
                    M.get_associated_function (|
                      Ty.path "core::fmt::Arguments",
                      "new_v1",
                      [ Value.Integer IntegerKind.Usize 1; Value.Integer IntegerKind.Usize 1 ],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.alloc (| Value.Array [ mk_str (| "" |) ] |)
                          |)
                        |)
                      |);
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.alloc (|
                              Value.Array
                                [
                                  M.call_closure (|
                                    Ty.path "core::fmt::rt::Argument",
                                    M.get_associated_function (|
                                      Ty.path "core::fmt::rt::Argument",
                                      "new_display",
                                      [],
                                      [ Ty.path "alloc::string::String" ]
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (| M.borrow (| Pointer.Kind.Ref, err_str |) |)
                                      |)
                                    ]
                                  |)
                                ]
                            |)
                          |)
                        |)
                      |)
                    ]
                  |)
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Display"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Display_for_move_core_types_u256_U256CastError.
  
  Module Impl_core_error_Error_for_move_core_types_u256_U256FromStrError.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::U256FromStrError".
    
    (*
        fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
            self.0.source()
        }
    *)
    Definition source (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::option::Option")
              []
              [ Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::error::Error::Trait", []) ] ] ],
            M.get_trait_method (|
              "core::error::Error",
              Ty.path "uint::uint::FromStrRadixErr",
              [],
              [],
              "source",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.SubPointer.get_struct_tuple_field (|
                  M.deref (| M.read (| self |) |),
                  "move_core_types::u256::U256FromStrError",
                  0
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::error::Error"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("source", InstanceField.Method source) ].
  End Impl_core_error_Error_for_move_core_types_u256_U256FromStrError.
  
  Module Impl_core_fmt_Display_for_move_core_types_u256_U256FromStrError.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::U256FromStrError".
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            write!(f, "{}", self.0)
        }
    *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_fmt", [], [] |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
              M.call_closure (|
                Ty.path "core::fmt::Arguments",
                M.get_associated_function (|
                  Ty.path "core::fmt::Arguments",
                  "new_v1",
                  [ Value.Integer IntegerKind.Usize 1; Value.Integer IntegerKind.Usize 1 ],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (| Pointer.Kind.Ref, M.alloc (| Value.Array [ mk_str (| "" |) ] |) |)
                    |)
                  |);
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          Value.Array
                            [
                              M.call_closure (|
                                Ty.path "core::fmt::rt::Argument",
                                M.get_associated_function (|
                                  Ty.path "core::fmt::rt::Argument",
                                  "new_display",
                                  [],
                                  [ Ty.path "uint::uint::FromStrRadixErr" ]
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.SubPointer.get_struct_tuple_field (|
                                          M.deref (| M.read (| self |) |),
                                          "move_core_types::u256::U256FromStrError",
                                          0
                                        |)
                                      |)
                                    |)
                                  |)
                                ]
                              |)
                            ]
                        |)
                      |)
                    |)
                  |)
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Display"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Display_for_move_core_types_u256_U256FromStrError.
  
  (* StructTuple
    {
      name := "U256";
      const_params := [];
      ty_params := [];
      fields := [ Ty.path "primitive_types::U256" ];
    } *)
  
  Module Impl_core_clone_Clone_for_move_core_types_u256_U256.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::U256".
    
    (* Clone *)
    Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.path "move_core_types::u256::U256" ],
              Value.DeclaredButUndefined,
              [ fun γ => ltac:(M.monadic (M.deref (| M.read (| self |) |))) ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_move_core_types_u256_U256.
  
  Module Impl_core_fmt_Debug_for_move_core_types_u256_U256.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::U256".
    
    (* Debug *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_associated_function (|
              Ty.path "core::fmt::Formatter",
              "debug_tuple_field1_finish",
              [],
              []
            |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "U256" |) |) |);
              (* Unsize *)
              M.pointer_coercion
                (M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.alloc (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_tuple_field (|
                            M.deref (| M.read (| self |) |),
                            "move_core_types::u256::U256",
                            0
                          |)
                        |)
                      |)
                    |)
                  |)
                |))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_move_core_types_u256_U256.
  
  Module Impl_core_marker_StructuralPartialEq_for_move_core_types_u256_U256.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::U256".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_move_core_types_u256_U256.
  
  Module Impl_core_cmp_PartialEq_move_core_types_u256_U256_for_move_core_types_u256_U256.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::U256".
    
    (* PartialEq *)
    Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.path "bool",
            M.get_trait_method (|
              "core::cmp::PartialEq",
              Ty.path "primitive_types::U256",
              [],
              [ Ty.path "primitive_types::U256" ],
              "eq",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.SubPointer.get_struct_tuple_field (|
                  M.deref (| M.read (| self |) |),
                  "move_core_types::u256::U256",
                  0
                |)
              |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.SubPointer.get_struct_tuple_field (|
                  M.deref (| M.read (| other |) |),
                  "move_core_types::u256::U256",
                  0
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "move_core_types::u256::U256" ]
        Self
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_move_core_types_u256_U256_for_move_core_types_u256_U256.
  
  Module Impl_core_cmp_Eq_for_move_core_types_u256_U256.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::U256".
    
    (* Eq *)
    Definition assert_receiver_is_total_eq
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              Value.DeclaredButUndefined,
              [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_move_core_types_u256_U256.
  
  Module Impl_core_hash_Hash_for_move_core_types_u256_U256.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::U256".
    
    (* Hash *)
    Definition hash (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ __H ], [ self; state ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let state := M.alloc (| state |) in
          M.call_closure (|
            Ty.tuple [],
            M.get_trait_method (|
              "core::hash::Hash",
              Ty.path "primitive_types::U256",
              [],
              [],
              "hash",
              [],
              [ __H ]
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| self |) |),
                      "move_core_types::u256::U256",
                      0
                    |)
                  |)
                |)
              |);
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| state |) |) |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::hash::Hash"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("hash", InstanceField.Method hash) ].
  End Impl_core_hash_Hash_for_move_core_types_u256_U256.
  
  Module Impl_core_marker_Copy_for_move_core_types_u256_U256.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::U256".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::Copy"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_Copy_for_move_core_types_u256_U256.
  
  Module Impl_core_cmp_PartialOrd_move_core_types_u256_U256_for_move_core_types_u256_U256.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::U256".
    
    (* PartialOrd *)
    Definition partial_cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "core::cmp::Ordering" ],
            M.get_trait_method (|
              "core::cmp::PartialOrd",
              Ty.path "primitive_types::U256",
              [],
              [ Ty.path "primitive_types::U256" ],
              "partial_cmp",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| self |) |),
                      "move_core_types::u256::U256",
                      0
                    |)
                  |)
                |)
              |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| other |) |),
                      "move_core_types::u256::U256",
                      0
                    |)
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialOrd"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "move_core_types::u256::U256" ]
        Self
        (* Instance *) [ ("partial_cmp", InstanceField.Method partial_cmp) ].
  End Impl_core_cmp_PartialOrd_move_core_types_u256_U256_for_move_core_types_u256_U256.
  
  Module Impl_core_cmp_Ord_for_move_core_types_u256_U256.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::U256".
    
    (* Ord *)
    Definition cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          M.call_closure (|
            Ty.path "core::cmp::Ordering",
            M.get_trait_method (|
              "core::cmp::Ord",
              Ty.path "primitive_types::U256",
              [],
              [],
              "cmp",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| self |) |),
                      "move_core_types::u256::U256",
                      0
                    |)
                  |)
                |)
              |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| other |) |),
                      "move_core_types::u256::U256",
                      0
                    |)
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Ord"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("cmp", InstanceField.Method cmp) ].
  End Impl_core_cmp_Ord_for_move_core_types_u256_U256.
  
  Module Impl_core_default_Default_for_move_core_types_u256_U256.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::U256".
    
    (* Default *)
    Definition default (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [] =>
        ltac:(M.monadic
          (Value.StructTuple
            "move_core_types::u256::U256"
            [
              M.call_closure (|
                Ty.path "primitive_types::U256",
                M.get_trait_method (|
                  "core::default::Default",
                  Ty.path "primitive_types::U256",
                  [],
                  [],
                  "default",
                  [],
                  []
                |),
                []
              |)
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::default::Default"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("default", InstanceField.Method default) ].
  End Impl_core_default_Default_for_move_core_types_u256_U256.
  
  Module Impl_core_fmt_Display_for_move_core_types_u256_U256.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::U256".
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter) -> std::fmt::Result {
            self.0.fmt(f)
        }
    *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_trait_method (|
              "core::fmt::Display",
              Ty.path "primitive_types::U256",
              [],
              [],
              "fmt",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.SubPointer.get_struct_tuple_field (|
                  M.deref (| M.read (| self |) |),
                  "move_core_types::u256::U256",
                  0
                |)
              |);
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Display"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Display_for_move_core_types_u256_U256.
  
  Module Impl_core_fmt_UpperHex_for_move_core_types_u256_U256.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::U256".
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            fmt::UpperHex::fmt(&self.0, f)
        }
    *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_trait_method (|
              "core::fmt::UpperHex",
              Ty.path "primitive_types::U256",
              [],
              [],
              "fmt",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| self |) |),
                      "move_core_types::u256::U256",
                      0
                    |)
                  |)
                |)
              |);
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::UpperHex"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_UpperHex_for_move_core_types_u256_U256.
  
  Module Impl_core_fmt_LowerHex_for_move_core_types_u256_U256.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::U256".
    
    (*
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            fmt::LowerHex::fmt(&self.0, f)
        }
    *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_trait_method (|
              "core::fmt::LowerHex",
              Ty.path "primitive_types::U256",
              [],
              [],
              "fmt",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_tuple_field (|
                      M.deref (| M.read (| self |) |),
                      "move_core_types::u256::U256",
                      0
                    |)
                  |)
                |)
              |);
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::LowerHex"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_LowerHex_for_move_core_types_u256_U256.
  
  Module Impl_core_str_traits_FromStr_for_move_core_types_u256_U256.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::U256".
    
    (*     type Err = U256FromStrError; *)
    Definition _Err : Ty.t := Ty.path "move_core_types::u256::U256FromStrError".
    
    (*
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            Self::from_str_radix(s, 10)
        }
    *)
    Definition from_str (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ s ] =>
        ltac:(M.monadic
          (let s := M.alloc (| s |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [
                Ty.path "move_core_types::u256::U256";
                Ty.path "move_core_types::u256::U256FromStrError"
              ],
            M.get_associated_function (|
              Ty.path "move_core_types::u256::U256",
              "from_str_radix",
              [],
              []
            |),
            [
              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| s |) |) |);
              Value.Integer IntegerKind.U32 10
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::str::traits::FromStr"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *)
        [ ("Err", InstanceField.Ty _Err); ("from_str", InstanceField.Method from_str) ].
  End Impl_core_str_traits_FromStr_for_move_core_types_u256_U256.
  
  Module Impl_serde_de_Deserialize_for_move_core_types_u256_U256.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::U256".
    
    (*
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: Deserializer<'de>,
        {
            Ok(U256::from_le_bytes(
                &(<[u8; U256_NUM_BYTES]>::deserialize(deserializer)?),
            ))
        }
    *)
    Definition deserialize (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ D ], [ deserializer ] =>
        ltac:(M.monadic
          (let deserializer := M.alloc (| deserializer |) in
          M.catch_return
            (Ty.apply
              (Ty.path "core::result::Result")
              []
              [
                Ty.path "move_core_types::u256::U256";
                Ty.associated_in_trait "serde::de::Deserializer" [] [] D "Error"
              ]) (|
            ltac:(M.monadic
              (Value.StructTuple
                "core::result::Result::Ok"
                [
                  M.call_closure (|
                    Ty.path "move_core_types::u256::U256",
                    M.get_associated_function (|
                      Ty.path "move_core_types::u256::U256",
                      "from_le_bytes",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.match_operator (|
                              Ty.apply
                                (Ty.path "*")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "array")
                                    [ Value.Integer IntegerKind.Usize 32 ]
                                    [ Ty.path "u8" ]
                                ],
                              M.alloc (|
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "core::ops::control_flow::ControlFlow")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        []
                                        [
                                          Ty.path "core::convert::Infallible";
                                          Ty.associated_in_trait
                                            "serde::de::Deserializer"
                                            []
                                            []
                                            D
                                            "Error"
                                        ];
                                      Ty.apply
                                        (Ty.path "array")
                                        [ Value.Integer IntegerKind.Usize 32 ]
                                        [ Ty.path "u8" ]
                                    ],
                                  M.get_trait_method (|
                                    "core::ops::try_trait::Try",
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "array")
                                          [ Value.Integer IntegerKind.Usize 32 ]
                                          [ Ty.path "u8" ];
                                        Ty.associated_in_trait
                                          "serde::de::Deserializer"
                                          []
                                          []
                                          D
                                          "Error"
                                      ],
                                    [],
                                    [],
                                    "branch",
                                    [],
                                    []
                                  |),
                                  [
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "array")
                                            [ Value.Integer IntegerKind.Usize 32 ]
                                            [ Ty.path "u8" ];
                                          Ty.associated_in_trait
                                            "serde::de::Deserializer"
                                            []
                                            []
                                            D
                                            "Error"
                                        ],
                                      M.get_trait_method (|
                                        "serde::de::Deserialize",
                                        Ty.apply
                                          (Ty.path "array")
                                          [ Value.Integer IntegerKind.Usize 32 ]
                                          [ Ty.path "u8" ],
                                        [],
                                        [],
                                        "deserialize",
                                        [],
                                        [ D ]
                                      |),
                                      [ M.read (| deserializer |) ]
                                    |)
                                  ]
                                |)
                              |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ0_0 :=
                                      M.SubPointer.get_struct_tuple_field (|
                                        γ,
                                        "core::ops::control_flow::ControlFlow::Break",
                                        0
                                      |) in
                                    let residual := M.copy (| γ0_0 |) in
                                    M.alloc (|
                                      M.never_to_any (|
                                        M.read (|
                                          M.return_ (|
                                            M.call_closure (|
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.path "move_core_types::u256::U256";
                                                  Ty.associated_in_trait
                                                    "serde::de::Deserializer"
                                                    []
                                                    []
                                                    D
                                                    "Error"
                                                ],
                                              M.get_trait_method (|
                                                "core::ops::try_trait::FromResidual",
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "move_core_types::u256::U256";
                                                    Ty.associated_in_trait
                                                      "serde::de::Deserializer"
                                                      []
                                                      []
                                                      D
                                                      "Error"
                                                  ],
                                                [],
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::result::Result")
                                                    []
                                                    [
                                                      Ty.path "core::convert::Infallible";
                                                      Ty.associated_in_trait
                                                        "serde::de::Deserializer"
                                                        []
                                                        []
                                                        D
                                                        "Error"
                                                    ]
                                                ],
                                                "from_residual",
                                                [],
                                                []
                                              |),
                                              [ M.read (| residual |) ]
                                            |)
                                          |)
                                        |)
                                      |)
                                    |)));
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ0_0 :=
                                      M.SubPointer.get_struct_tuple_field (|
                                        γ,
                                        "core::ops::control_flow::ControlFlow::Continue",
                                        0
                                      |) in
                                    let val := M.copy (| γ0_0 |) in
                                    val))
                              ]
                            |)
                          |)
                        |)
                      |)
                    ]
                  |)
                ]))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "serde::de::Deserialize"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("deserialize", InstanceField.Method deserialize) ].
  End Impl_serde_de_Deserialize_for_move_core_types_u256_U256.
  
  Module Impl_serde_ser_Serialize_for_move_core_types_u256_U256.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::U256".
    
    (*
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: Serializer,
        {
            self.to_le_bytes().serialize(serializer)
        }
    *)
    Definition serialize (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ _ as S ], [ self; serializer ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let serializer := M.alloc (| serializer |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [
                Ty.associated_in_trait "serde::ser::Serializer" [] [] S "Ok";
                Ty.associated_in_trait "serde::ser::Serializer" [] [] S "Error"
              ],
            M.get_trait_method (|
              "serde::ser::Serialize",
              Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 32 ] [ Ty.path "u8" ],
              [],
              [],
              "serialize",
              [],
              [ S ]
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.alloc (|
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "array")
                      [ Value.Integer IntegerKind.Usize 32 ]
                      [ Ty.path "u8" ],
                    M.get_associated_function (|
                      Ty.path "move_core_types::u256::U256",
                      "to_le_bytes",
                      [],
                      []
                    |),
                    [ M.read (| M.deref (| M.read (| self |) |) |) ]
                  |)
                |)
              |);
              M.read (| serializer |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "serde::ser::Serialize"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("serialize", InstanceField.Method serialize) ].
  End Impl_serde_ser_Serialize_for_move_core_types_u256_U256.
  
  Module Impl_core_ops_bit_Shl_u32_for_move_core_types_u256_U256.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::U256".
    
    (*     type Output = Self; *)
    Definition _Output : Ty.t := Ty.path "move_core_types::u256::U256".
    
    (*
        fn shl(self, rhs: u32) -> Self::Output {
            let Self(lhs) = self;
            Self(lhs << rhs)
        }
    *)
    Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.path "move_core_types::u256::U256" ],
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_core_types::u256::U256",
                        0
                      |) in
                    let lhs := M.copy (| γ0_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_core_types::u256::U256"
                        [
                          M.call_closure (|
                            Ty.path "primitive_types::U256",
                            M.get_trait_method (|
                              "core::ops::bit::Shl",
                              Ty.path "primitive_types::U256",
                              [],
                              [ Ty.path "u32" ],
                              "shl",
                              [],
                              []
                            |),
                            [ M.read (| lhs |); M.read (| rhs |) ]
                          |)
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::ops::bit::Shl"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "u32" ]
        Self
        (* Instance *) [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
  End Impl_core_ops_bit_Shl_u32_for_move_core_types_u256_U256.
  
  Module Impl_core_ops_bit_Shl_u8_for_move_core_types_u256_U256.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::U256".
    
    (*     type Output = Self; *)
    Definition _Output : Ty.t := Ty.path "move_core_types::u256::U256".
    
    (*
        fn shl(self, rhs: u8) -> Self::Output {
            let Self(lhs) = self;
            Self(lhs << rhs)
        }
    *)
    Definition shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.path "move_core_types::u256::U256" ],
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_core_types::u256::U256",
                        0
                      |) in
                    let lhs := M.copy (| γ0_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_core_types::u256::U256"
                        [
                          M.call_closure (|
                            Ty.path "primitive_types::U256",
                            M.get_trait_method (|
                              "core::ops::bit::Shl",
                              Ty.path "primitive_types::U256",
                              [],
                              [ Ty.path "u8" ],
                              "shl",
                              [],
                              []
                            |),
                            [ M.read (| lhs |); M.read (| rhs |) ]
                          |)
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::ops::bit::Shl"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "u8" ]
        Self
        (* Instance *) [ ("Output", InstanceField.Ty _Output); ("shl", InstanceField.Method shl) ].
  End Impl_core_ops_bit_Shl_u8_for_move_core_types_u256_U256.
  
  Module Impl_core_ops_bit_Shr_u8_for_move_core_types_u256_U256.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::U256".
    
    (*     type Output = Self; *)
    Definition _Output : Ty.t := Ty.path "move_core_types::u256::U256".
    
    (*
        fn shr(self, rhs: u8) -> Self::Output {
            let Self(lhs) = self;
            Self(lhs >> rhs)
        }
    *)
    Definition shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.path "move_core_types::u256::U256" ],
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_core_types::u256::U256",
                        0
                      |) in
                    let lhs := M.copy (| γ0_0 |) in
                    M.alloc (|
                      Value.StructTuple
                        "move_core_types::u256::U256"
                        [
                          M.call_closure (|
                            Ty.path "primitive_types::U256",
                            M.get_trait_method (|
                              "core::ops::bit::Shr",
                              Ty.path "primitive_types::U256",
                              [],
                              [ Ty.path "u8" ],
                              "shr",
                              [],
                              []
                            |),
                            [ M.read (| lhs |); M.read (| rhs |) ]
                          |)
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::ops::bit::Shr"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "u8" ]
        Self
        (* Instance *) [ ("Output", InstanceField.Ty _Output); ("shr", InstanceField.Method shr) ].
  End Impl_core_ops_bit_Shr_u8_for_move_core_types_u256_U256.
  
  Module Impl_core_ops_bit_BitOr_move_core_types_u256_U256_for_move_core_types_u256_U256.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::U256".
    
    (*     type Output = Self; *)
    Definition _Output : Ty.t := Ty.path "move_core_types::u256::U256".
    
    (*
        fn bitor(self, rhs: U256) -> Self::Output {
            let Self(lhs) = self;
            let Self(rhs) = rhs;
            Self(lhs | rhs)
        }
    *)
    Definition bitor (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.path "move_core_types::u256::U256" ],
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_core_types::u256::U256",
                        0
                      |) in
                    let lhs := M.copy (| γ0_0 |) in
                    M.match_operator (|
                      Ty.apply (Ty.path "*") [] [ Ty.path "move_core_types::u256::U256" ],
                      rhs,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "move_core_types::u256::U256",
                                0
                              |) in
                            let rhs := M.copy (| γ0_0 |) in
                            M.alloc (|
                              Value.StructTuple
                                "move_core_types::u256::U256"
                                [
                                  M.call_closure (|
                                    Ty.path "primitive_types::U256",
                                    M.get_trait_method (|
                                      "core::ops::bit::BitOr",
                                      Ty.path "primitive_types::U256",
                                      [],
                                      [ Ty.path "primitive_types::U256" ],
                                      "bitor",
                                      [],
                                      []
                                    |),
                                    [ M.read (| lhs |); M.read (| rhs |) ]
                                  |)
                                ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::ops::bit::BitOr"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "move_core_types::u256::U256" ]
        Self
        (* Instance *)
        [ ("Output", InstanceField.Ty _Output); ("bitor", InstanceField.Method bitor) ].
  End Impl_core_ops_bit_BitOr_move_core_types_u256_U256_for_move_core_types_u256_U256.
  
  Module Impl_core_ops_bit_BitAnd_move_core_types_u256_U256_for_move_core_types_u256_U256.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::U256".
    
    (*     type Output = Self; *)
    Definition _Output : Ty.t := Ty.path "move_core_types::u256::U256".
    
    (*
        fn bitand(self, rhs: U256) -> Self::Output {
            let Self(lhs) = self;
            let Self(rhs) = rhs;
            Self(lhs & rhs)
        }
    *)
    Definition bitand (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.path "move_core_types::u256::U256" ],
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_core_types::u256::U256",
                        0
                      |) in
                    let lhs := M.copy (| γ0_0 |) in
                    M.match_operator (|
                      Ty.apply (Ty.path "*") [] [ Ty.path "move_core_types::u256::U256" ],
                      rhs,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "move_core_types::u256::U256",
                                0
                              |) in
                            let rhs := M.copy (| γ0_0 |) in
                            M.alloc (|
                              Value.StructTuple
                                "move_core_types::u256::U256"
                                [
                                  M.call_closure (|
                                    Ty.path "primitive_types::U256",
                                    M.get_trait_method (|
                                      "core::ops::bit::BitAnd",
                                      Ty.path "primitive_types::U256",
                                      [],
                                      [ Ty.path "primitive_types::U256" ],
                                      "bitand",
                                      [],
                                      []
                                    |),
                                    [ M.read (| lhs |); M.read (| rhs |) ]
                                  |)
                                ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::ops::bit::BitAnd"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "move_core_types::u256::U256" ]
        Self
        (* Instance *)
        [ ("Output", InstanceField.Ty _Output); ("bitand", InstanceField.Method bitand) ].
  End Impl_core_ops_bit_BitAnd_move_core_types_u256_U256_for_move_core_types_u256_U256.
  
  Module Impl_core_ops_bit_BitXor_move_core_types_u256_U256_for_move_core_types_u256_U256.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::U256".
    
    (*     type Output = Self; *)
    Definition _Output : Ty.t := Ty.path "move_core_types::u256::U256".
    
    (*
        fn bitxor(self, rhs: U256) -> Self::Output {
            let Self(lhs) = self;
            let Self(rhs) = rhs;
            Self(lhs ^ rhs)
        }
    *)
    Definition bitxor (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.path "move_core_types::u256::U256" ],
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "move_core_types::u256::U256",
                        0
                      |) in
                    let lhs := M.copy (| γ0_0 |) in
                    M.match_operator (|
                      Ty.apply (Ty.path "*") [] [ Ty.path "move_core_types::u256::U256" ],
                      rhs,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "move_core_types::u256::U256",
                                0
                              |) in
                            let rhs := M.copy (| γ0_0 |) in
                            M.alloc (|
                              Value.StructTuple
                                "move_core_types::u256::U256"
                                [
                                  M.call_closure (|
                                    Ty.path "primitive_types::U256",
                                    M.get_trait_method (|
                                      "core::ops::bit::BitXor",
                                      Ty.path "primitive_types::U256",
                                      [],
                                      [ Ty.path "primitive_types::U256" ],
                                      "bitxor",
                                      [],
                                      []
                                    |),
                                    [ M.read (| lhs |); M.read (| rhs |) ]
                                  |)
                                ]
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::ops::bit::BitXor"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "move_core_types::u256::U256" ]
        Self
        (* Instance *)
        [ ("Output", InstanceField.Ty _Output); ("bitxor", InstanceField.Method bitxor) ].
  End Impl_core_ops_bit_BitXor_move_core_types_u256_U256_for_move_core_types_u256_U256.
  
  Module Impl_core_ops_bit_BitAndAssign_move_core_types_u256_U256_for_move_core_types_u256_U256.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::U256".
    
    (*
        fn bitand_assign(&mut self, rhs: U256) {
            *self = *self & rhs;
        }
    *)
    Definition bitand_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.alloc (|
                M.write (|
                  M.deref (| M.read (| self |) |),
                  M.call_closure (|
                    Ty.path "move_core_types::u256::U256",
                    M.get_trait_method (|
                      "core::ops::bit::BitAnd",
                      Ty.path "move_core_types::u256::U256",
                      [],
                      [ Ty.path "move_core_types::u256::U256" ],
                      "bitand",
                      [],
                      []
                    |),
                    [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| rhs |) ]
                  |)
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::ops::bit::BitAndAssign"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "move_core_types::u256::U256" ]
        Self
        (* Instance *) [ ("bitand_assign", InstanceField.Method bitand_assign) ].
  End Impl_core_ops_bit_BitAndAssign_move_core_types_u256_U256_for_move_core_types_u256_U256.
  
  Module Impl_core_ops_arith_Add_move_core_types_u256_U256_for_move_core_types_u256_U256.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::U256".
    
    (*     type Output = Self; *)
    Definition _Output : Ty.t := Ty.path "move_core_types::u256::U256".
    
    (*
        fn add(self, rhs: U256) -> Self::Output {
            self.wrapping_add(rhs)
        }
    *)
    Definition add (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            Ty.path "move_core_types::u256::U256",
            M.get_associated_function (|
              Ty.path "move_core_types::u256::U256",
              "wrapping_add",
              [],
              []
            |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::ops::arith::Add"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "move_core_types::u256::U256" ]
        Self
        (* Instance *) [ ("Output", InstanceField.Ty _Output); ("add", InstanceField.Method add) ].
  End Impl_core_ops_arith_Add_move_core_types_u256_U256_for_move_core_types_u256_U256.
  
  Module Impl_core_ops_arith_AddAssign_move_core_types_u256_U256_for_move_core_types_u256_U256.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::U256".
    
    (*
        fn add_assign(&mut self, rhs: U256) {
            *self = *self + rhs;
        }
    *)
    Definition add_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.alloc (|
                M.write (|
                  M.deref (| M.read (| self |) |),
                  M.call_closure (|
                    Ty.path "move_core_types::u256::U256",
                    M.get_trait_method (|
                      "core::ops::arith::Add",
                      Ty.path "move_core_types::u256::U256",
                      [],
                      [ Ty.path "move_core_types::u256::U256" ],
                      "add",
                      [],
                      []
                    |),
                    [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| rhs |) ]
                  |)
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::ops::arith::AddAssign"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "move_core_types::u256::U256" ]
        Self
        (* Instance *) [ ("add_assign", InstanceField.Method add_assign) ].
  End Impl_core_ops_arith_AddAssign_move_core_types_u256_U256_for_move_core_types_u256_U256.
  
  Module Impl_core_ops_arith_Sub_move_core_types_u256_U256_for_move_core_types_u256_U256.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::U256".
    
    (*     type Output = Self; *)
    Definition _Output : Ty.t := Ty.path "move_core_types::u256::U256".
    
    (*
        fn sub(self, rhs: U256) -> Self::Output {
            self.wrapping_sub(rhs)
        }
    *)
    Definition sub (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            Ty.path "move_core_types::u256::U256",
            M.get_associated_function (|
              Ty.path "move_core_types::u256::U256",
              "wrapping_sub",
              [],
              []
            |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::ops::arith::Sub"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "move_core_types::u256::U256" ]
        Self
        (* Instance *) [ ("Output", InstanceField.Ty _Output); ("sub", InstanceField.Method sub) ].
  End Impl_core_ops_arith_Sub_move_core_types_u256_U256_for_move_core_types_u256_U256.
  
  Module Impl_core_ops_arith_SubAssign_move_core_types_u256_U256_for_move_core_types_u256_U256.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::U256".
    
    (*
        fn sub_assign(&mut self, rhs: U256) {
            *self = *self - rhs;
        }
    *)
    Definition sub_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.alloc (|
                M.write (|
                  M.deref (| M.read (| self |) |),
                  M.call_closure (|
                    Ty.path "move_core_types::u256::U256",
                    M.get_trait_method (|
                      "core::ops::arith::Sub",
                      Ty.path "move_core_types::u256::U256",
                      [],
                      [ Ty.path "move_core_types::u256::U256" ],
                      "sub",
                      [],
                      []
                    |),
                    [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| rhs |) ]
                  |)
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::ops::arith::SubAssign"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "move_core_types::u256::U256" ]
        Self
        (* Instance *) [ ("sub_assign", InstanceField.Method sub_assign) ].
  End Impl_core_ops_arith_SubAssign_move_core_types_u256_U256_for_move_core_types_u256_U256.
  
  Module Impl_core_ops_arith_Mul_move_core_types_u256_U256_for_move_core_types_u256_U256.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::U256".
    
    (*     type Output = Self; *)
    Definition _Output : Ty.t := Ty.path "move_core_types::u256::U256".
    
    (*
        fn mul(self, rhs: U256) -> Self::Output {
            self.wrapping_mul(rhs)
        }
    *)
    Definition mul (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            Ty.path "move_core_types::u256::U256",
            M.get_associated_function (|
              Ty.path "move_core_types::u256::U256",
              "wrapping_mul",
              [],
              []
            |),
            [ M.read (| self |); M.read (| rhs |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::ops::arith::Mul"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "move_core_types::u256::U256" ]
        Self
        (* Instance *) [ ("Output", InstanceField.Ty _Output); ("mul", InstanceField.Method mul) ].
  End Impl_core_ops_arith_Mul_move_core_types_u256_U256_for_move_core_types_u256_U256.
  
  Module Impl_core_ops_arith_MulAssign_move_core_types_u256_U256_for_move_core_types_u256_U256.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::U256".
    
    (*
        fn mul_assign(&mut self, rhs: U256) {
            *self = *self * rhs;
        }
    *)
    Definition mul_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.alloc (|
                M.write (|
                  M.deref (| M.read (| self |) |),
                  M.call_closure (|
                    Ty.path "move_core_types::u256::U256",
                    M.get_trait_method (|
                      "core::ops::arith::Mul",
                      Ty.path "move_core_types::u256::U256",
                      [],
                      [ Ty.path "move_core_types::u256::U256" ],
                      "mul",
                      [],
                      []
                    |),
                    [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| rhs |) ]
                  |)
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::ops::arith::MulAssign"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "move_core_types::u256::U256" ]
        Self
        (* Instance *) [ ("mul_assign", InstanceField.Method mul_assign) ].
  End Impl_core_ops_arith_MulAssign_move_core_types_u256_U256_for_move_core_types_u256_U256.
  
  Module Impl_core_ops_arith_Div_move_core_types_u256_U256_for_move_core_types_u256_U256.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::U256".
    
    (*     type Output = Self; *)
    Definition _Output : Ty.t := Ty.path "move_core_types::u256::U256".
    
    (*
        fn div(self, rhs: U256) -> Self::Output {
            Self(self.0 / rhs.0)
        }
    *)
    Definition div (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          Value.StructTuple
            "move_core_types::u256::U256"
            [
              M.call_closure (|
                Ty.path "primitive_types::U256",
                M.get_trait_method (|
                  "core::ops::arith::Div",
                  Ty.path "primitive_types::U256",
                  [],
                  [ Ty.path "primitive_types::U256" ],
                  "div",
                  [],
                  []
                |),
                [
                  M.read (|
                    M.SubPointer.get_struct_tuple_field (| self, "move_core_types::u256::U256", 0 |)
                  |);
                  M.read (|
                    M.SubPointer.get_struct_tuple_field (| rhs, "move_core_types::u256::U256", 0 |)
                  |)
                ]
              |)
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::ops::arith::Div"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "move_core_types::u256::U256" ]
        Self
        (* Instance *) [ ("Output", InstanceField.Ty _Output); ("div", InstanceField.Method div) ].
  End Impl_core_ops_arith_Div_move_core_types_u256_U256_for_move_core_types_u256_U256.
  
  Module Impl_core_ops_arith_DivAssign_move_core_types_u256_U256_for_move_core_types_u256_U256.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::U256".
    
    (*
        fn div_assign(&mut self, rhs: U256) {
            *self = *self / rhs;
        }
    *)
    Definition div_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.alloc (|
                M.write (|
                  M.deref (| M.read (| self |) |),
                  M.call_closure (|
                    Ty.path "move_core_types::u256::U256",
                    M.get_trait_method (|
                      "core::ops::arith::Div",
                      Ty.path "move_core_types::u256::U256",
                      [],
                      [ Ty.path "move_core_types::u256::U256" ],
                      "div",
                      [],
                      []
                    |),
                    [ M.read (| M.deref (| M.read (| self |) |) |); M.read (| rhs |) ]
                  |)
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::ops::arith::DivAssign"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "move_core_types::u256::U256" ]
        Self
        (* Instance *) [ ("div_assign", InstanceField.Method div_assign) ].
  End Impl_core_ops_arith_DivAssign_move_core_types_u256_U256_for_move_core_types_u256_U256.
  
  Module Impl_core_ops_arith_Rem_move_core_types_u256_U256_for_move_core_types_u256_U256.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::U256".
    
    (*     type Output = Self; *)
    Definition _Output : Ty.t := Ty.path "move_core_types::u256::U256".
    
    (*
        fn rem(self, rhs: U256) -> Self::Output {
            Self(self.0 % rhs.0)
        }
    *)
    Definition rem (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          Value.StructTuple
            "move_core_types::u256::U256"
            [
              M.call_closure (|
                Ty.path "primitive_types::U256",
                M.get_trait_method (|
                  "core::ops::arith::Rem",
                  Ty.path "primitive_types::U256",
                  [],
                  [ Ty.path "primitive_types::U256" ],
                  "rem",
                  [],
                  []
                |),
                [
                  M.read (|
                    M.SubPointer.get_struct_tuple_field (| self, "move_core_types::u256::U256", 0 |)
                  |);
                  M.read (|
                    M.SubPointer.get_struct_tuple_field (| rhs, "move_core_types::u256::U256", 0 |)
                  |)
                ]
              |)
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::ops::arith::Rem"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "move_core_types::u256::U256" ]
        Self
        (* Instance *) [ ("Output", InstanceField.Ty _Output); ("rem", InstanceField.Method rem) ].
  End Impl_core_ops_arith_Rem_move_core_types_u256_U256_for_move_core_types_u256_U256.
  
  Module Impl_core_ops_arith_RemAssign_move_core_types_u256_U256_for_move_core_types_u256_U256.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::U256".
    
    (*
        fn rem_assign(&mut self, rhs: U256) {
            *self = Self(self.0 % rhs.0);
        }
    *)
    Definition rem_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.read (|
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.alloc (|
                M.write (|
                  M.deref (| M.read (| self |) |),
                  Value.StructTuple
                    "move_core_types::u256::U256"
                    [
                      M.call_closure (|
                        Ty.path "primitive_types::U256",
                        M.get_trait_method (|
                          "core::ops::arith::Rem",
                          Ty.path "primitive_types::U256",
                          [],
                          [ Ty.path "primitive_types::U256" ],
                          "rem",
                          [],
                          []
                        |),
                        [
                          M.read (|
                            M.SubPointer.get_struct_tuple_field (|
                              M.deref (| M.read (| self |) |),
                              "move_core_types::u256::U256",
                              0
                            |)
                          |);
                          M.read (|
                            M.SubPointer.get_struct_tuple_field (|
                              rhs,
                              "move_core_types::u256::U256",
                              0
                            |)
                          |)
                        ]
                      |)
                    ]
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::ops::arith::RemAssign"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "move_core_types::u256::U256" ]
        Self
        (* Instance *) [ ("rem_assign", InstanceField.Method rem_assign) ].
  End Impl_core_ops_arith_RemAssign_move_core_types_u256_U256_for_move_core_types_u256_U256.
  
  Module Impl_move_core_types_u256_U256.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::U256".
    
    (*
        pub const fn zero() -> Self {
            Self(PrimitiveU256::zero())
        }
    *)
    Definition zero (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [] =>
        ltac:(M.monadic
          (Value.StructTuple
            "move_core_types::u256::U256"
            [
              M.call_closure (|
                Ty.path "primitive_types::U256",
                M.get_associated_function (| Ty.path "primitive_types::U256", "zero", [], [] |),
                []
              |)
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_zero : M.IsAssociatedFunction.C Self "zero" zero.
    Admitted.
    Global Typeclasses Opaque zero.
    
    (*
        pub const fn one() -> Self {
            Self(PrimitiveU256::one())
        }
    *)
    Definition one (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [] =>
        ltac:(M.monadic
          (Value.StructTuple
            "move_core_types::u256::U256"
            [
              M.call_closure (|
                Ty.path "primitive_types::U256",
                M.get_associated_function (| Ty.path "primitive_types::U256", "one", [], [] |),
                []
              |)
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_one : M.IsAssociatedFunction.C Self "one" one.
    Admitted.
    Global Typeclasses Opaque one.
    
    (*
        pub const fn max_value() -> Self {
            Self(PrimitiveU256::max_value())
        }
    *)
    Definition max_value (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [] =>
        ltac:(M.monadic
          (Value.StructTuple
            "move_core_types::u256::U256"
            [
              M.call_closure (|
                Ty.path "primitive_types::U256",
                M.get_associated_function (|
                  Ty.path "primitive_types::U256",
                  "max_value",
                  [],
                  []
                |),
                []
              |)
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_max_value :
      M.IsAssociatedFunction.C Self "max_value" max_value.
    Admitted.
    Global Typeclasses Opaque max_value.
    
    (*
        pub fn from_str_radix(src: &str, radix: u32) -> Result<Self, U256FromStrError> {
            PrimitiveU256::from_str_radix(src.trim_start_matches('0'), radix)
                .map(Self)
                .map_err(U256FromStrError)
        }
    *)
    Definition from_str_radix (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ src; radix ] =>
        ltac:(M.monadic
          (let src := M.alloc (| src |) in
          let radix := M.alloc (| radix |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [
                Ty.path "move_core_types::u256::U256";
                Ty.path "move_core_types::u256::U256FromStrError"
              ],
            M.get_associated_function (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [ Ty.path "move_core_types::u256::U256"; Ty.path "uint::uint::FromStrRadixErr" ],
              "map_err",
              [],
              [
                Ty.path "move_core_types::u256::U256FromStrError";
                Ty.function
                  [ Ty.path "uint::uint::FromStrRadixErr" ]
                  (Ty.path "move_core_types::u256::U256FromStrError")
              ]
            |),
            [
              M.call_closure (|
                Ty.apply
                  (Ty.path "core::result::Result")
                  []
                  [ Ty.path "move_core_types::u256::U256"; Ty.path "uint::uint::FromStrRadixErr" ],
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [ Ty.path "primitive_types::U256"; Ty.path "uint::uint::FromStrRadixErr" ],
                  "map",
                  [],
                  [
                    Ty.path "move_core_types::u256::U256";
                    Ty.function
                      [ Ty.path "primitive_types::U256" ]
                      (Ty.path "move_core_types::u256::U256")
                  ]
                |),
                [
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.path "primitive_types::U256"; Ty.path "uint::uint::FromStrRadixErr" ],
                    M.get_associated_function (|
                      Ty.path "primitive_types::U256",
                      "from_str_radix",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.call_closure (|
                            Ty.apply (Ty.path "&") [] [ Ty.path "str" ],
                            M.get_associated_function (|
                              Ty.path "str",
                              "trim_start_matches",
                              [],
                              [ Ty.path "char" ]
                            |),
                            [
                              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| src |) |) |);
                              Value.UnicodeChar 48
                            ]
                          |)
                        |)
                      |);
                      M.read (| radix |)
                    ]
                  |);
                  M.constructor_as_closure "move_core_types::u256::U256"
                ]
              |);
              M.constructor_as_closure "move_core_types::u256::U256FromStrError"
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_from_str_radix :
      M.IsAssociatedFunction.C Self "from_str_radix" from_str_radix.
    Admitted.
    Global Typeclasses Opaque from_str_radix.
    
    (*
        pub fn from_le_bytes(slice: &[u8; U256_NUM_BYTES]) -> Self {
            Self(PrimitiveU256::from_little_endian(slice))
        }
    *)
    Definition from_le_bytes (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ slice ] =>
        ltac:(M.monadic
          (let slice := M.alloc (| slice |) in
          Value.StructTuple
            "move_core_types::u256::U256"
            [
              M.call_closure (|
                Ty.path "primitive_types::U256",
                M.get_associated_function (|
                  Ty.path "primitive_types::U256",
                  "from_little_endian",
                  [],
                  []
                |),
                [
                  (* Unsize *)
                  M.pointer_coercion
                    (M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| slice |) |) |))
                ]
              |)
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_from_le_bytes :
      M.IsAssociatedFunction.C Self "from_le_bytes" from_le_bytes.
    Admitted.
    Global Typeclasses Opaque from_le_bytes.
    
    (*
        pub fn to_le_bytes(self) -> [u8; U256_NUM_BYTES] {
            let mut bytes = [0u8; U256_NUM_BYTES];
            self.0.to_little_endian(&mut bytes);
            bytes
        }
    *)
    Definition to_le_bytes (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let~ bytes :
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "array")
                      [ Value.Integer IntegerKind.Usize 32 ]
                      [ Ty.path "u8" ]
                  ] :=
              M.alloc (|
                repeat (| Value.Integer IntegerKind.U8 0, Value.Integer IntegerKind.Usize 32 |)
              |) in
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_associated_function (|
                    Ty.path "primitive_types::U256",
                    "to_little_endian",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_tuple_field (|
                        self,
                        "move_core_types::u256::U256",
                        0
                      |)
                    |);
                    (* Unsize *)
                    M.pointer_coercion
                      (M.borrow (|
                        Pointer.Kind.MutRef,
                        M.deref (| M.borrow (| Pointer.Kind.MutRef, bytes |) |)
                      |))
                  ]
                |)
              |) in
            bytes
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_to_le_bytes :
      M.IsAssociatedFunction.C Self "to_le_bytes" to_le_bytes.
    Admitted.
    Global Typeclasses Opaque to_le_bytes.
    
    (*
        pub fn leading_zeros(&self) -> u32 {
            self.0.leading_zeros()
        }
    *)
    Definition leading_zeros (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            Ty.path "u32",
            M.get_associated_function (|
              Ty.path "primitive_types::U256",
              "leading_zeros",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.SubPointer.get_struct_tuple_field (|
                  M.deref (| M.read (| self |) |),
                  "move_core_types::u256::U256",
                  0
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_leading_zeros :
      M.IsAssociatedFunction.C Self "leading_zeros" leading_zeros.
    Admitted.
    Global Typeclasses Opaque leading_zeros.
    
    (*
        pub fn unchecked_as_u8(&self) -> u8 {
            self.0.low_u128() as u8
        }
    *)
    Definition unchecked_as_u8 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.cast
            (Ty.path "u8")
            (M.call_closure (|
              Ty.path "u128",
              M.get_associated_function (| Ty.path "primitive_types::U256", "low_u128", [], [] |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_tuple_field (|
                    M.deref (| M.read (| self |) |),
                    "move_core_types::u256::U256",
                    0
                  |)
                |)
              ]
            |))))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_unchecked_as_u8 :
      M.IsAssociatedFunction.C Self "unchecked_as_u8" unchecked_as_u8.
    Admitted.
    Global Typeclasses Opaque unchecked_as_u8.
    
    (*
        pub fn unchecked_as_u16(&self) -> u16 {
            self.0.low_u128() as u16
        }
    *)
    Definition unchecked_as_u16 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.cast
            (Ty.path "u16")
            (M.call_closure (|
              Ty.path "u128",
              M.get_associated_function (| Ty.path "primitive_types::U256", "low_u128", [], [] |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_tuple_field (|
                    M.deref (| M.read (| self |) |),
                    "move_core_types::u256::U256",
                    0
                  |)
                |)
              ]
            |))))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_unchecked_as_u16 :
      M.IsAssociatedFunction.C Self "unchecked_as_u16" unchecked_as_u16.
    Admitted.
    Global Typeclasses Opaque unchecked_as_u16.
    
    (*
        pub fn unchecked_as_u32(&self) -> u32 {
            self.0.low_u128() as u32
        }
    *)
    Definition unchecked_as_u32 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.cast
            (Ty.path "u32")
            (M.call_closure (|
              Ty.path "u128",
              M.get_associated_function (| Ty.path "primitive_types::U256", "low_u128", [], [] |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_tuple_field (|
                    M.deref (| M.read (| self |) |),
                    "move_core_types::u256::U256",
                    0
                  |)
                |)
              ]
            |))))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_unchecked_as_u32 :
      M.IsAssociatedFunction.C Self "unchecked_as_u32" unchecked_as_u32.
    Admitted.
    Global Typeclasses Opaque unchecked_as_u32.
    
    (*
        pub fn unchecked_as_u64(&self) -> u64 {
            self.0.low_u128() as u64
        }
    *)
    Definition unchecked_as_u64 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.cast
            (Ty.path "u64")
            (M.call_closure (|
              Ty.path "u128",
              M.get_associated_function (| Ty.path "primitive_types::U256", "low_u128", [], [] |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_tuple_field (|
                    M.deref (| M.read (| self |) |),
                    "move_core_types::u256::U256",
                    0
                  |)
                |)
              ]
            |))))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_unchecked_as_u64 :
      M.IsAssociatedFunction.C Self "unchecked_as_u64" unchecked_as_u64.
    Admitted.
    Global Typeclasses Opaque unchecked_as_u64.
    
    (*
        pub fn unchecked_as_u128(&self) -> u128 {
            self.0.low_u128()
        }
    *)
    Definition unchecked_as_u128 (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            Ty.path "u128",
            M.get_associated_function (| Ty.path "primitive_types::U256", "low_u128", [], [] |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.SubPointer.get_struct_tuple_field (|
                  M.deref (| M.read (| self |) |),
                  "move_core_types::u256::U256",
                  0
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_unchecked_as_u128 :
      M.IsAssociatedFunction.C Self "unchecked_as_u128" unchecked_as_u128.
    Admitted.
    Global Typeclasses Opaque unchecked_as_u128.
    
    (*
        pub fn checked_add(self, rhs: Self) -> Option<Self> {
            self.0.checked_add(rhs.0).map(Self)
        }
    *)
    Definition checked_add (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "move_core_types::u256::U256" ],
            M.get_associated_function (|
              Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "primitive_types::U256" ],
              "map",
              [],
              [
                Ty.path "move_core_types::u256::U256";
                Ty.function
                  [ Ty.path "primitive_types::U256" ]
                  (Ty.path "move_core_types::u256::U256")
              ]
            |),
            [
              M.call_closure (|
                Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "primitive_types::U256" ],
                M.get_associated_function (|
                  Ty.path "primitive_types::U256",
                  "checked_add",
                  [],
                  []
                |),
                [
                  M.read (|
                    M.SubPointer.get_struct_tuple_field (| self, "move_core_types::u256::U256", 0 |)
                  |);
                  M.read (|
                    M.SubPointer.get_struct_tuple_field (| rhs, "move_core_types::u256::U256", 0 |)
                  |)
                ]
              |);
              M.constructor_as_closure "move_core_types::u256::U256"
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_checked_add :
      M.IsAssociatedFunction.C Self "checked_add" checked_add.
    Admitted.
    Global Typeclasses Opaque checked_add.
    
    (*
        pub fn checked_sub(self, rhs: Self) -> Option<Self> {
            self.0.checked_sub(rhs.0).map(Self)
        }
    *)
    Definition checked_sub (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "move_core_types::u256::U256" ],
            M.get_associated_function (|
              Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "primitive_types::U256" ],
              "map",
              [],
              [
                Ty.path "move_core_types::u256::U256";
                Ty.function
                  [ Ty.path "primitive_types::U256" ]
                  (Ty.path "move_core_types::u256::U256")
              ]
            |),
            [
              M.call_closure (|
                Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "primitive_types::U256" ],
                M.get_associated_function (|
                  Ty.path "primitive_types::U256",
                  "checked_sub",
                  [],
                  []
                |),
                [
                  M.read (|
                    M.SubPointer.get_struct_tuple_field (| self, "move_core_types::u256::U256", 0 |)
                  |);
                  M.read (|
                    M.SubPointer.get_struct_tuple_field (| rhs, "move_core_types::u256::U256", 0 |)
                  |)
                ]
              |);
              M.constructor_as_closure "move_core_types::u256::U256"
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_checked_sub :
      M.IsAssociatedFunction.C Self "checked_sub" checked_sub.
    Admitted.
    Global Typeclasses Opaque checked_sub.
    
    (*
        pub fn checked_mul(self, rhs: Self) -> Option<Self> {
            self.0.checked_mul(rhs.0).map(Self)
        }
    *)
    Definition checked_mul (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "move_core_types::u256::U256" ],
            M.get_associated_function (|
              Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "primitive_types::U256" ],
              "map",
              [],
              [
                Ty.path "move_core_types::u256::U256";
                Ty.function
                  [ Ty.path "primitive_types::U256" ]
                  (Ty.path "move_core_types::u256::U256")
              ]
            |),
            [
              M.call_closure (|
                Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "primitive_types::U256" ],
                M.get_associated_function (|
                  Ty.path "primitive_types::U256",
                  "checked_mul",
                  [],
                  []
                |),
                [
                  M.read (|
                    M.SubPointer.get_struct_tuple_field (| self, "move_core_types::u256::U256", 0 |)
                  |);
                  M.read (|
                    M.SubPointer.get_struct_tuple_field (| rhs, "move_core_types::u256::U256", 0 |)
                  |)
                ]
              |);
              M.constructor_as_closure "move_core_types::u256::U256"
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_checked_mul :
      M.IsAssociatedFunction.C Self "checked_mul" checked_mul.
    Admitted.
    Global Typeclasses Opaque checked_mul.
    
    (*
        pub fn checked_div(self, rhs: Self) -> Option<Self> {
            self.0.checked_div(rhs.0).map(Self)
        }
    *)
    Definition checked_div (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "move_core_types::u256::U256" ],
            M.get_associated_function (|
              Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "primitive_types::U256" ],
              "map",
              [],
              [
                Ty.path "move_core_types::u256::U256";
                Ty.function
                  [ Ty.path "primitive_types::U256" ]
                  (Ty.path "move_core_types::u256::U256")
              ]
            |),
            [
              M.call_closure (|
                Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "primitive_types::U256" ],
                M.get_associated_function (|
                  Ty.path "primitive_types::U256",
                  "checked_div",
                  [],
                  []
                |),
                [
                  M.read (|
                    M.SubPointer.get_struct_tuple_field (| self, "move_core_types::u256::U256", 0 |)
                  |);
                  M.read (|
                    M.SubPointer.get_struct_tuple_field (| rhs, "move_core_types::u256::U256", 0 |)
                  |)
                ]
              |);
              M.constructor_as_closure "move_core_types::u256::U256"
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_checked_div :
      M.IsAssociatedFunction.C Self "checked_div" checked_div.
    Admitted.
    Global Typeclasses Opaque checked_div.
    
    (*
        pub fn checked_rem(self, rhs: Self) -> Option<Self> {
            self.0.checked_rem(rhs.0).map(Self)
        }
    *)
    Definition checked_rem (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.call_closure (|
            Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "move_core_types::u256::U256" ],
            M.get_associated_function (|
              Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "primitive_types::U256" ],
              "map",
              [],
              [
                Ty.path "move_core_types::u256::U256";
                Ty.function
                  [ Ty.path "primitive_types::U256" ]
                  (Ty.path "move_core_types::u256::U256")
              ]
            |),
            [
              M.call_closure (|
                Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "primitive_types::U256" ],
                M.get_associated_function (|
                  Ty.path "primitive_types::U256",
                  "checked_rem",
                  [],
                  []
                |),
                [
                  M.read (|
                    M.SubPointer.get_struct_tuple_field (| self, "move_core_types::u256::U256", 0 |)
                  |);
                  M.read (|
                    M.SubPointer.get_struct_tuple_field (| rhs, "move_core_types::u256::U256", 0 |)
                  |)
                ]
              |);
              M.constructor_as_closure "move_core_types::u256::U256"
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_checked_rem :
      M.IsAssociatedFunction.C Self "checked_rem" checked_rem.
    Admitted.
    Global Typeclasses Opaque checked_rem.
    
    (*
        pub fn checked_shl(self, rhs: u32) -> Option<Self> {
            if rhs >= U256_NUM_BITS as u32 {
                return None;
            }
            Some(Self(self.0.shl(rhs)))
        }
    *)
    Definition checked_shl (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.catch_return
            (Ty.apply
              (Ty.path "core::option::Option")
              []
              [ Ty.path "move_core_types::u256::U256" ]) (|
            ltac:(M.monadic
              (M.read (|
                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                  M.match_operator (|
                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.ge,
                                  [
                                    M.read (| rhs |);
                                    M.cast
                                      (Ty.path "u32")
                                      (M.read (|
                                        get_constant (|
                                          "move_core_types::u256::U256_NUM_BITS",
                                          Ty.path "usize"
                                        |)
                                      |))
                                  ]
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (| Value.StructTuple "core::option::Option::None" [] |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                M.alloc (|
                  Value.StructTuple
                    "core::option::Option::Some"
                    [
                      Value.StructTuple
                        "move_core_types::u256::U256"
                        [
                          M.call_closure (|
                            Ty.path "primitive_types::U256",
                            M.get_trait_method (|
                              "core::ops::bit::Shl",
                              Ty.path "primitive_types::U256",
                              [],
                              [ Ty.path "u32" ],
                              "shl",
                              [],
                              []
                            |),
                            [
                              M.read (|
                                M.SubPointer.get_struct_tuple_field (|
                                  self,
                                  "move_core_types::u256::U256",
                                  0
                                |)
                              |);
                              M.read (| rhs |)
                            ]
                          |)
                        ]
                    ]
                |)
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_checked_shl :
      M.IsAssociatedFunction.C Self "checked_shl" checked_shl.
    Admitted.
    Global Typeclasses Opaque checked_shl.
    
    (*
        pub fn checked_shr(self, rhs: u32) -> Option<Self> {
            if rhs >= U256_NUM_BITS as u32 {
                return None;
            }
            Some(Self(self.0.shr(rhs)))
        }
    *)
    Definition checked_shr (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          M.catch_return
            (Ty.apply
              (Ty.path "core::option::Option")
              []
              [ Ty.path "move_core_types::u256::U256" ]) (|
            ltac:(M.monadic
              (M.read (|
                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                  M.match_operator (|
                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  BinOp.ge,
                                  [
                                    M.read (| rhs |);
                                    M.cast
                                      (Ty.path "u32")
                                      (M.read (|
                                        get_constant (|
                                          "move_core_types::u256::U256_NUM_BITS",
                                          Ty.path "usize"
                                        |)
                                      |))
                                  ]
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (| Value.StructTuple "core::option::Option::None" [] |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                M.alloc (|
                  Value.StructTuple
                    "core::option::Option::Some"
                    [
                      Value.StructTuple
                        "move_core_types::u256::U256"
                        [
                          M.call_closure (|
                            Ty.path "primitive_types::U256",
                            M.get_trait_method (|
                              "core::ops::bit::Shr",
                              Ty.path "primitive_types::U256",
                              [],
                              [ Ty.path "u32" ],
                              "shr",
                              [],
                              []
                            |),
                            [
                              M.read (|
                                M.SubPointer.get_struct_tuple_field (|
                                  self,
                                  "move_core_types::u256::U256",
                                  0
                                |)
                              |);
                              M.read (| rhs |)
                            ]
                          |)
                        ]
                    ]
                |)
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_checked_shr :
      M.IsAssociatedFunction.C Self "checked_shr" checked_shr.
    Admitted.
    Global Typeclasses Opaque checked_shr.
    
    (*
        pub fn down_cast_lossy<T: std::convert::TryFrom<u128>>(self) -> T {
            // Size of this type
            let type_size = size_of::<T>();
            // Maximum value for this type
            let max_val: u128 = if type_size < 16 {
                (1u128 << (NUM_BITS_PER_BYTE * type_size)) - 1u128
            } else {
                u128::MAX
            };
            // This should never fail
            match T::try_from(self.0.low_u128() & max_val) {
                Ok(w) => w,
                Err(_) => panic!("Fatal! Downcast failed"),
            }
        }
    *)
    Definition down_cast_lossy (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ T ], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let~ type_size : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "usize",
                  M.get_function (| "core::mem::size_of", [], [ T ] |),
                  []
                |)
              |) in
            let~ max_val : Ty.apply (Ty.path "*") [] [ Ty.path "u128" ] :=
              M.copy (|
                M.match_operator (|
                  Ty.apply (Ty.path "*") [] [ Ty.path "u128" ],
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                BinOp.lt,
                                [ M.read (| type_size |); Value.Integer IntegerKind.Usize 16 ]
                              |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.alloc (|
                          M.call_closure (|
                            Ty.path "u128",
                            BinOp.Wrap.sub,
                            [
                              M.call_closure (|
                                Ty.path "u128",
                                BinOp.Wrap.shl,
                                [
                                  Value.Integer IntegerKind.U128 1;
                                  M.call_closure (|
                                    Ty.path "usize",
                                    BinOp.Wrap.mul,
                                    [
                                      M.read (|
                                        get_constant (|
                                          "move_core_types::u256::NUM_BITS_PER_BYTE",
                                          Ty.path "usize"
                                        |)
                                      |);
                                      M.read (| type_size |)
                                    ]
                                  |)
                                ]
                              |);
                              Value.Integer IntegerKind.U128 1
                            ]
                          |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (get_associated_constant (| Ty.path "u128", "MAX", Ty.path "u128" |)))
                  ]
                |)
              |) in
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ T ],
              M.alloc (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [
                      T;
                      Ty.associated_in_trait
                        "core::convert::TryFrom"
                        []
                        [ Ty.path "u128" ]
                        T
                        "Error"
                    ],
                  M.get_trait_method (|
                    "core::convert::TryFrom",
                    T,
                    [],
                    [ Ty.path "u128" ],
                    "try_from",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.path "u128",
                      BinOp.Wrap.bit_and,
                      [
                        M.call_closure (|
                          Ty.path "u128",
                          M.get_associated_function (|
                            Ty.path "primitive_types::U256",
                            "low_u128",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.SubPointer.get_struct_tuple_field (|
                                self,
                                "move_core_types::u256::U256",
                                0
                              |)
                            |)
                          ]
                        |);
                        M.read (| max_val |)
                      ]
                    |)
                  ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (| γ, "core::result::Result::Ok", 0 |) in
                    let w := M.copy (| γ0_0 |) in
                    w));
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_tuple_field (| γ, "core::result::Result::Err", 0 |) in
                    M.alloc (|
                      M.never_to_any (|
                        M.call_closure (|
                          Ty.path "never",
                          M.get_function (| "core::panicking::panic_fmt", [], [] |),
                          [
                            M.call_closure (|
                              Ty.path "core::fmt::Arguments",
                              M.get_associated_function (|
                                Ty.path "core::fmt::Arguments",
                                "new_const",
                                [ Value.Integer IntegerKind.Usize 1 ],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.alloc (|
                                        Value.Array [ mk_str (| "Fatal! Downcast failed" |) ]
                                      |)
                                    |)
                                  |)
                                |)
                              ]
                            |)
                          ]
                        |)
                      |)
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_down_cast_lossy :
      M.IsAssociatedFunction.C Self "down_cast_lossy" down_cast_lossy.
    Admitted.
    Global Typeclasses Opaque down_cast_lossy.
    
    (*
        pub fn wrapping_add(self, rhs: Self) -> Self {
            Self(self.0.overflowing_add(rhs.0).0)
        }
    *)
    Definition wrapping_add (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          Value.StructTuple
            "move_core_types::u256::U256"
            [
              M.read (|
                M.SubPointer.get_tuple_field (|
                  M.alloc (|
                    M.call_closure (|
                      Ty.tuple [ Ty.path "primitive_types::U256"; Ty.path "bool" ],
                      M.get_associated_function (|
                        Ty.path "primitive_types::U256",
                        "overflowing_add",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.SubPointer.get_struct_tuple_field (|
                            self,
                            "move_core_types::u256::U256",
                            0
                          |)
                        |);
                        M.read (|
                          M.SubPointer.get_struct_tuple_field (|
                            rhs,
                            "move_core_types::u256::U256",
                            0
                          |)
                        |)
                      ]
                    |)
                  |),
                  0
                |)
              |)
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_wrapping_add :
      M.IsAssociatedFunction.C Self "wrapping_add" wrapping_add.
    Admitted.
    Global Typeclasses Opaque wrapping_add.
    
    (*
        pub fn wrapping_sub(self, rhs: Self) -> Self {
            Self(self.0.overflowing_sub(rhs.0).0)
        }
    *)
    Definition wrapping_sub (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          Value.StructTuple
            "move_core_types::u256::U256"
            [
              M.read (|
                M.SubPointer.get_tuple_field (|
                  M.alloc (|
                    M.call_closure (|
                      Ty.tuple [ Ty.path "primitive_types::U256"; Ty.path "bool" ],
                      M.get_associated_function (|
                        Ty.path "primitive_types::U256",
                        "overflowing_sub",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.SubPointer.get_struct_tuple_field (|
                            self,
                            "move_core_types::u256::U256",
                            0
                          |)
                        |);
                        M.read (|
                          M.SubPointer.get_struct_tuple_field (|
                            rhs,
                            "move_core_types::u256::U256",
                            0
                          |)
                        |)
                      ]
                    |)
                  |),
                  0
                |)
              |)
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_wrapping_sub :
      M.IsAssociatedFunction.C Self "wrapping_sub" wrapping_sub.
    Admitted.
    Global Typeclasses Opaque wrapping_sub.
    
    (*
        pub fn wrapping_mul(self, rhs: Self) -> Self {
            Self(self.0.overflowing_mul(rhs.0).0)
        }
    *)
    Definition wrapping_mul (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; rhs ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rhs := M.alloc (| rhs |) in
          Value.StructTuple
            "move_core_types::u256::U256"
            [
              M.read (|
                M.SubPointer.get_tuple_field (|
                  M.alloc (|
                    M.call_closure (|
                      Ty.tuple [ Ty.path "primitive_types::U256"; Ty.path "bool" ],
                      M.get_associated_function (|
                        Ty.path "primitive_types::U256",
                        "overflowing_mul",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.SubPointer.get_struct_tuple_field (|
                            self,
                            "move_core_types::u256::U256",
                            0
                          |)
                        |);
                        M.read (|
                          M.SubPointer.get_struct_tuple_field (|
                            rhs,
                            "move_core_types::u256::U256",
                            0
                          |)
                        |)
                      ]
                    |)
                  |),
                  0
                |)
              |)
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_wrapping_mul :
      M.IsAssociatedFunction.C Self "wrapping_mul" wrapping_mul.
    Admitted.
    Global Typeclasses Opaque wrapping_mul.
    
    (*
        fn wmul(self, b: Self) -> (Self, Self) {
            let half = 128;
            #[allow(non_snake_case)]
            let LOWER_MASK: U256 = Self::max_value() >> half;
    
            let mut low = (self & LOWER_MASK).wrapping_mul(b & LOWER_MASK);
            let mut t = low >> half;
            low &= LOWER_MASK;
            t += (self >> half).wrapping_mul(b & LOWER_MASK);
            low += (t & LOWER_MASK) << half;
            let mut high = t >> half;
            t = low >> half;
            low &= LOWER_MASK;
            t += (b >> half).wrapping_mul(self & LOWER_MASK);
            low += (t & LOWER_MASK) << half;
            high += t >> half;
            high += (self >> half).wrapping_mul(b >> half);
    
            (high, low)
        }
    *)
    Definition wmul (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; b ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let b := M.alloc (| b |) in
          M.read (|
            let~ half : Ty.apply (Ty.path "*") [] [ Ty.path "u8" ] :=
              M.alloc (| Value.Integer IntegerKind.U8 128 |) in
            let~ value_LOWER_MASK :
                Ty.apply (Ty.path "*") [] [ Ty.path "move_core_types::u256::U256" ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "move_core_types::u256::U256",
                  M.get_trait_method (|
                    "core::ops::bit::Shr",
                    Ty.path "move_core_types::u256::U256",
                    [],
                    [ Ty.path "u8" ],
                    "shr",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.path "move_core_types::u256::U256",
                      M.get_associated_function (|
                        Ty.path "move_core_types::u256::U256",
                        "max_value",
                        [],
                        []
                      |),
                      []
                    |);
                    M.read (| half |)
                  ]
                |)
              |) in
            let~ low : Ty.apply (Ty.path "*") [] [ Ty.path "move_core_types::u256::U256" ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "move_core_types::u256::U256",
                  M.get_associated_function (|
                    Ty.path "move_core_types::u256::U256",
                    "wrapping_mul",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.path "move_core_types::u256::U256",
                      M.get_trait_method (|
                        "core::ops::bit::BitAnd",
                        Ty.path "move_core_types::u256::U256",
                        [],
                        [ Ty.path "move_core_types::u256::U256" ],
                        "bitand",
                        [],
                        []
                      |),
                      [ M.read (| self |); M.read (| value_LOWER_MASK |) ]
                    |);
                    M.call_closure (|
                      Ty.path "move_core_types::u256::U256",
                      M.get_trait_method (|
                        "core::ops::bit::BitAnd",
                        Ty.path "move_core_types::u256::U256",
                        [],
                        [ Ty.path "move_core_types::u256::U256" ],
                        "bitand",
                        [],
                        []
                      |),
                      [ M.read (| b |); M.read (| value_LOWER_MASK |) ]
                    |)
                  ]
                |)
              |) in
            let~ t : Ty.apply (Ty.path "*") [] [ Ty.path "move_core_types::u256::U256" ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "move_core_types::u256::U256",
                  M.get_trait_method (|
                    "core::ops::bit::Shr",
                    Ty.path "move_core_types::u256::U256",
                    [],
                    [ Ty.path "u8" ],
                    "shr",
                    [],
                    []
                  |),
                  [ M.read (| low |); M.read (| half |) ]
                |)
              |) in
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "core::ops::bit::BitAndAssign",
                    Ty.path "move_core_types::u256::U256",
                    [],
                    [ Ty.path "move_core_types::u256::U256" ],
                    "bitand_assign",
                    [],
                    []
                  |),
                  [ M.borrow (| Pointer.Kind.MutRef, low |); M.read (| value_LOWER_MASK |) ]
                |)
              |) in
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "core::ops::arith::AddAssign",
                    Ty.path "move_core_types::u256::U256",
                    [],
                    [ Ty.path "move_core_types::u256::U256" ],
                    "add_assign",
                    [],
                    []
                  |),
                  [
                    M.borrow (| Pointer.Kind.MutRef, t |);
                    M.call_closure (|
                      Ty.path "move_core_types::u256::U256",
                      M.get_associated_function (|
                        Ty.path "move_core_types::u256::U256",
                        "wrapping_mul",
                        [],
                        []
                      |),
                      [
                        M.call_closure (|
                          Ty.path "move_core_types::u256::U256",
                          M.get_trait_method (|
                            "core::ops::bit::Shr",
                            Ty.path "move_core_types::u256::U256",
                            [],
                            [ Ty.path "u8" ],
                            "shr",
                            [],
                            []
                          |),
                          [ M.read (| self |); M.read (| half |) ]
                        |);
                        M.call_closure (|
                          Ty.path "move_core_types::u256::U256",
                          M.get_trait_method (|
                            "core::ops::bit::BitAnd",
                            Ty.path "move_core_types::u256::U256",
                            [],
                            [ Ty.path "move_core_types::u256::U256" ],
                            "bitand",
                            [],
                            []
                          |),
                          [ M.read (| b |); M.read (| value_LOWER_MASK |) ]
                        |)
                      ]
                    |)
                  ]
                |)
              |) in
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "core::ops::arith::AddAssign",
                    Ty.path "move_core_types::u256::U256",
                    [],
                    [ Ty.path "move_core_types::u256::U256" ],
                    "add_assign",
                    [],
                    []
                  |),
                  [
                    M.borrow (| Pointer.Kind.MutRef, low |);
                    M.call_closure (|
                      Ty.path "move_core_types::u256::U256",
                      M.get_trait_method (|
                        "core::ops::bit::Shl",
                        Ty.path "move_core_types::u256::U256",
                        [],
                        [ Ty.path "u8" ],
                        "shl",
                        [],
                        []
                      |),
                      [
                        M.call_closure (|
                          Ty.path "move_core_types::u256::U256",
                          M.get_trait_method (|
                            "core::ops::bit::BitAnd",
                            Ty.path "move_core_types::u256::U256",
                            [],
                            [ Ty.path "move_core_types::u256::U256" ],
                            "bitand",
                            [],
                            []
                          |),
                          [ M.read (| t |); M.read (| value_LOWER_MASK |) ]
                        |);
                        M.read (| half |)
                      ]
                    |)
                  ]
                |)
              |) in
            let~ high : Ty.apply (Ty.path "*") [] [ Ty.path "move_core_types::u256::U256" ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "move_core_types::u256::U256",
                  M.get_trait_method (|
                    "core::ops::bit::Shr",
                    Ty.path "move_core_types::u256::U256",
                    [],
                    [ Ty.path "u8" ],
                    "shr",
                    [],
                    []
                  |),
                  [ M.read (| t |); M.read (| half |) ]
                |)
              |) in
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.alloc (|
                M.write (|
                  t,
                  M.call_closure (|
                    Ty.path "move_core_types::u256::U256",
                    M.get_trait_method (|
                      "core::ops::bit::Shr",
                      Ty.path "move_core_types::u256::U256",
                      [],
                      [ Ty.path "u8" ],
                      "shr",
                      [],
                      []
                    |),
                    [ M.read (| low |); M.read (| half |) ]
                  |)
                |)
              |) in
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "core::ops::bit::BitAndAssign",
                    Ty.path "move_core_types::u256::U256",
                    [],
                    [ Ty.path "move_core_types::u256::U256" ],
                    "bitand_assign",
                    [],
                    []
                  |),
                  [ M.borrow (| Pointer.Kind.MutRef, low |); M.read (| value_LOWER_MASK |) ]
                |)
              |) in
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "core::ops::arith::AddAssign",
                    Ty.path "move_core_types::u256::U256",
                    [],
                    [ Ty.path "move_core_types::u256::U256" ],
                    "add_assign",
                    [],
                    []
                  |),
                  [
                    M.borrow (| Pointer.Kind.MutRef, t |);
                    M.call_closure (|
                      Ty.path "move_core_types::u256::U256",
                      M.get_associated_function (|
                        Ty.path "move_core_types::u256::U256",
                        "wrapping_mul",
                        [],
                        []
                      |),
                      [
                        M.call_closure (|
                          Ty.path "move_core_types::u256::U256",
                          M.get_trait_method (|
                            "core::ops::bit::Shr",
                            Ty.path "move_core_types::u256::U256",
                            [],
                            [ Ty.path "u8" ],
                            "shr",
                            [],
                            []
                          |),
                          [ M.read (| b |); M.read (| half |) ]
                        |);
                        M.call_closure (|
                          Ty.path "move_core_types::u256::U256",
                          M.get_trait_method (|
                            "core::ops::bit::BitAnd",
                            Ty.path "move_core_types::u256::U256",
                            [],
                            [ Ty.path "move_core_types::u256::U256" ],
                            "bitand",
                            [],
                            []
                          |),
                          [ M.read (| self |); M.read (| value_LOWER_MASK |) ]
                        |)
                      ]
                    |)
                  ]
                |)
              |) in
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "core::ops::arith::AddAssign",
                    Ty.path "move_core_types::u256::U256",
                    [],
                    [ Ty.path "move_core_types::u256::U256" ],
                    "add_assign",
                    [],
                    []
                  |),
                  [
                    M.borrow (| Pointer.Kind.MutRef, low |);
                    M.call_closure (|
                      Ty.path "move_core_types::u256::U256",
                      M.get_trait_method (|
                        "core::ops::bit::Shl",
                        Ty.path "move_core_types::u256::U256",
                        [],
                        [ Ty.path "u8" ],
                        "shl",
                        [],
                        []
                      |),
                      [
                        M.call_closure (|
                          Ty.path "move_core_types::u256::U256",
                          M.get_trait_method (|
                            "core::ops::bit::BitAnd",
                            Ty.path "move_core_types::u256::U256",
                            [],
                            [ Ty.path "move_core_types::u256::U256" ],
                            "bitand",
                            [],
                            []
                          |),
                          [ M.read (| t |); M.read (| value_LOWER_MASK |) ]
                        |);
                        M.read (| half |)
                      ]
                    |)
                  ]
                |)
              |) in
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "core::ops::arith::AddAssign",
                    Ty.path "move_core_types::u256::U256",
                    [],
                    [ Ty.path "move_core_types::u256::U256" ],
                    "add_assign",
                    [],
                    []
                  |),
                  [
                    M.borrow (| Pointer.Kind.MutRef, high |);
                    M.call_closure (|
                      Ty.path "move_core_types::u256::U256",
                      M.get_trait_method (|
                        "core::ops::bit::Shr",
                        Ty.path "move_core_types::u256::U256",
                        [],
                        [ Ty.path "u8" ],
                        "shr",
                        [],
                        []
                      |),
                      [ M.read (| t |); M.read (| half |) ]
                    |)
                  ]
                |)
              |) in
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "core::ops::arith::AddAssign",
                    Ty.path "move_core_types::u256::U256",
                    [],
                    [ Ty.path "move_core_types::u256::U256" ],
                    "add_assign",
                    [],
                    []
                  |),
                  [
                    M.borrow (| Pointer.Kind.MutRef, high |);
                    M.call_closure (|
                      Ty.path "move_core_types::u256::U256",
                      M.get_associated_function (|
                        Ty.path "move_core_types::u256::U256",
                        "wrapping_mul",
                        [],
                        []
                      |),
                      [
                        M.call_closure (|
                          Ty.path "move_core_types::u256::U256",
                          M.get_trait_method (|
                            "core::ops::bit::Shr",
                            Ty.path "move_core_types::u256::U256",
                            [],
                            [ Ty.path "u8" ],
                            "shr",
                            [],
                            []
                          |),
                          [ M.read (| self |); M.read (| half |) ]
                        |);
                        M.call_closure (|
                          Ty.path "move_core_types::u256::U256",
                          M.get_trait_method (|
                            "core::ops::bit::Shr",
                            Ty.path "move_core_types::u256::U256",
                            [],
                            [ Ty.path "u8" ],
                            "shr",
                            [],
                            []
                          |),
                          [ M.read (| b |); M.read (| half |) ]
                        |)
                      ]
                    |)
                  ]
                |)
              |) in
            M.alloc (| Value.Tuple [ M.read (| high |); M.read (| low |) ] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_wmul : M.IsAssociatedFunction.C Self "wmul" wmul.
    Admitted.
    Global Typeclasses Opaque wmul.
  End Impl_move_core_types_u256_U256.
  
  Module Impl_core_convert_From_u8_for_move_core_types_u256_U256.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::U256".
    
    (*
        fn from(n: u8) -> Self {
            U256(PrimitiveU256::from(n))
        }
    *)
    Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ n ] =>
        ltac:(M.monadic
          (let n := M.alloc (| n |) in
          Value.StructTuple
            "move_core_types::u256::U256"
            [
              M.call_closure (|
                Ty.path "primitive_types::U256",
                M.get_trait_method (|
                  "core::convert::From",
                  Ty.path "primitive_types::U256",
                  [],
                  [ Ty.path "u8" ],
                  "from",
                  [],
                  []
                |),
                [ M.read (| n |) ]
              |)
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::convert::From"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "u8" ]
        Self
        (* Instance *) [ ("from", InstanceField.Method from) ].
  End Impl_core_convert_From_u8_for_move_core_types_u256_U256.
  
  Module Impl_core_convert_From_u16_for_move_core_types_u256_U256.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::U256".
    
    (*
        fn from(n: u16) -> Self {
            U256(PrimitiveU256::from(n))
        }
    *)
    Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ n ] =>
        ltac:(M.monadic
          (let n := M.alloc (| n |) in
          Value.StructTuple
            "move_core_types::u256::U256"
            [
              M.call_closure (|
                Ty.path "primitive_types::U256",
                M.get_trait_method (|
                  "core::convert::From",
                  Ty.path "primitive_types::U256",
                  [],
                  [ Ty.path "u16" ],
                  "from",
                  [],
                  []
                |),
                [ M.read (| n |) ]
              |)
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::convert::From"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "u16" ]
        Self
        (* Instance *) [ ("from", InstanceField.Method from) ].
  End Impl_core_convert_From_u16_for_move_core_types_u256_U256.
  
  Module Impl_core_convert_From_u32_for_move_core_types_u256_U256.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::U256".
    
    (*
        fn from(n: u32) -> Self {
            U256(PrimitiveU256::from(n))
        }
    *)
    Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ n ] =>
        ltac:(M.monadic
          (let n := M.alloc (| n |) in
          Value.StructTuple
            "move_core_types::u256::U256"
            [
              M.call_closure (|
                Ty.path "primitive_types::U256",
                M.get_trait_method (|
                  "core::convert::From",
                  Ty.path "primitive_types::U256",
                  [],
                  [ Ty.path "u32" ],
                  "from",
                  [],
                  []
                |),
                [ M.read (| n |) ]
              |)
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::convert::From"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "u32" ]
        Self
        (* Instance *) [ ("from", InstanceField.Method from) ].
  End Impl_core_convert_From_u32_for_move_core_types_u256_U256.
  
  Module Impl_core_convert_From_u64_for_move_core_types_u256_U256.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::U256".
    
    (*
        fn from(n: u64) -> Self {
            U256(PrimitiveU256::from(n))
        }
    *)
    Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ n ] =>
        ltac:(M.monadic
          (let n := M.alloc (| n |) in
          Value.StructTuple
            "move_core_types::u256::U256"
            [
              M.call_closure (|
                Ty.path "primitive_types::U256",
                M.get_trait_method (|
                  "core::convert::From",
                  Ty.path "primitive_types::U256",
                  [],
                  [ Ty.path "u64" ],
                  "from",
                  [],
                  []
                |),
                [ M.read (| n |) ]
              |)
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::convert::From"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "u64" ]
        Self
        (* Instance *) [ ("from", InstanceField.Method from) ].
  End Impl_core_convert_From_u64_for_move_core_types_u256_U256.
  
  Module Impl_core_convert_From_u128_for_move_core_types_u256_U256.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::U256".
    
    (*
        fn from(n: u128) -> Self {
            U256(PrimitiveU256::from(n))
        }
    *)
    Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ n ] =>
        ltac:(M.monadic
          (let n := M.alloc (| n |) in
          Value.StructTuple
            "move_core_types::u256::U256"
            [
              M.call_closure (|
                Ty.path "primitive_types::U256",
                M.get_trait_method (|
                  "core::convert::From",
                  Ty.path "primitive_types::U256",
                  [],
                  [ Ty.path "u128" ],
                  "from",
                  [],
                  []
                |),
                [ M.read (| n |) ]
              |)
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::convert::From"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "u128" ]
        Self
        (* Instance *) [ ("from", InstanceField.Method from) ].
  End Impl_core_convert_From_u128_for_move_core_types_u256_U256.
  
  Module Impl_core_convert_From_ref__move_core_types_u256_U256_for_num_bigint_bigint_BigInt.
    Definition Self : Ty.t := Ty.path "num_bigint::bigint::BigInt".
    
    (*
        fn from(n: &U256) -> Self {
            BigInt::from_bytes_le(Sign::Plus, &n.to_le_bytes())
        }
    *)
    Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ n ] =>
        ltac:(M.monadic
          (let n := M.alloc (| n |) in
          M.call_closure (|
            Ty.path "num_bigint::bigint::BigInt",
            M.get_associated_function (|
              Ty.path "num_bigint::bigint::BigInt",
              "from_bytes_le",
              [],
              []
            |),
            [
              Value.StructTuple "num_bigint::bigint::Sign::Plus" [];
              (* Unsize *)
              M.pointer_coercion
                (M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "array")
                            [ Value.Integer IntegerKind.Usize 32 ]
                            [ Ty.path "u8" ],
                          M.get_associated_function (|
                            Ty.path "move_core_types::u256::U256",
                            "to_le_bytes",
                            [],
                            []
                          |),
                          [ M.read (| M.deref (| M.read (| n |) |) |) ]
                        |)
                      |)
                    |)
                  |)
                |))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::convert::From"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.apply (Ty.path "&") [] [ Ty.path "move_core_types::u256::U256" ] ]
        Self
        (* Instance *) [ ("from", InstanceField.Method from) ].
  End Impl_core_convert_From_ref__move_core_types_u256_U256_for_num_bigint_bigint_BigInt.
  
  Module Impl_core_convert_From_ref__move_core_types_u256_U256_for_ethnum_uint_U256.
    Definition Self : Ty.t := Ty.path "ethnum::uint::U256".
    
    (*
        fn from(n: &U256) -> EthnumU256 {
            // TODO (ade): use better solution for conversion
            // Currently using str because EthnumU256 can be little or big endian
            let num_str = format!("{:X}", n.0);
            // TODO (ade): remove expect()
            EthnumU256::from_str_radix(&num_str, 16).expect("Cannot convert to U256")
        }
    *)
    Definition from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ n ] =>
        ltac:(M.monadic
          (let n := M.alloc (| n |) in
          M.read (|
            let~ num_str : Ty.apply (Ty.path "*") [] [ Ty.path "alloc::string::String" ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "alloc::string::String",
                  M.get_function (|
                    "core::hint::must_use",
                    [],
                    [ Ty.path "alloc::string::String" ]
                  |),
                  [
                    M.read (|
                      let~ res : Ty.apply (Ty.path "*") [] [ Ty.path "alloc::string::String" ] :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.path "alloc::string::String",
                            M.get_function (| "alloc::fmt::format", [], [] |),
                            [
                              M.call_closure (|
                                Ty.path "core::fmt::Arguments",
                                M.get_associated_function (|
                                  Ty.path "core::fmt::Arguments",
                                  "new_v1",
                                  [
                                    Value.Integer IntegerKind.Usize 1;
                                    Value.Integer IntegerKind.Usize 1
                                  ],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.alloc (| Value.Array [ mk_str (| "" |) ] |)
                                      |)
                                    |)
                                  |);
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.alloc (|
                                          Value.Array
                                            [
                                              M.call_closure (|
                                                Ty.path "core::fmt::rt::Argument",
                                                M.get_associated_function (|
                                                  Ty.path "core::fmt::rt::Argument",
                                                  "new_upper_hex",
                                                  [],
                                                  [ Ty.path "primitive_types::U256" ]
                                                |),
                                                [
                                                  M.borrow (|
                                                    Pointer.Kind.Ref,
                                                    M.deref (|
                                                      M.borrow (|
                                                        Pointer.Kind.Ref,
                                                        M.SubPointer.get_struct_tuple_field (|
                                                          M.deref (| M.read (| n |) |),
                                                          "move_core_types::u256::U256",
                                                          0
                                                        |)
                                                      |)
                                                    |)
                                                  |)
                                                ]
                                              |)
                                            ]
                                        |)
                                      |)
                                    |)
                                  |)
                                ]
                              |)
                            ]
                          |)
                        |) in
                      res
                    |)
                  ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                Ty.path "ethnum::uint::U256",
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [ Ty.path "ethnum::uint::U256"; Ty.path "core::num::error::ParseIntError" ],
                  "expect",
                  [],
                  []
                |),
                [
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.path "ethnum::uint::U256"; Ty.path "core::num::error::ParseIntError" ],
                    M.get_associated_function (|
                      Ty.path "ethnum::uint::U256",
                      "from_str_radix",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.call_closure (|
                            Ty.apply (Ty.path "&") [] [ Ty.path "str" ],
                            M.get_trait_method (|
                              "core::ops::deref::Deref",
                              Ty.path "alloc::string::String",
                              [],
                              [],
                              "deref",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (| M.borrow (| Pointer.Kind.Ref, num_str |) |)
                              |)
                            ]
                          |)
                        |)
                      |);
                      Value.Integer IntegerKind.U32 16
                    ]
                  |);
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (| mk_str (| "Cannot convert to U256" |) |)
                  |)
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::convert::From"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.apply (Ty.path "&") [] [ Ty.path "move_core_types::u256::U256" ] ]
        Self
        (* Instance *) [ ("from", InstanceField.Method from) ].
  End Impl_core_convert_From_ref__move_core_types_u256_U256_for_ethnum_uint_U256.
  
  Module Impl_core_convert_TryFrom_move_core_types_u256_U256_for_u8.
    Definition Self : Ty.t := Ty.path "u8".
    
    (*     type Error = U256CastError; *)
    Definition _Error : Ty.t := Ty.path "move_core_types::u256::U256CastError".
    
    (*
        fn try_from(n: U256) -> Result<Self, Self::Error> {
            let n = n.0.low_u64();
            if n > u8::MAX as u64 {
                Err(U256CastError::new(n, U256CastErrorKind::TooLargeForU8))
            } else {
                Ok(n as u8)
            }
        }
    *)
    Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ n ] =>
        ltac:(M.monadic
          (let n := M.alloc (| n |) in
          M.read (|
            let~ n : Ty.apply (Ty.path "*") [] [ Ty.path "u64" ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "u64",
                  M.get_associated_function (|
                    Ty.path "primitive_types::U256",
                    "low_u64",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_tuple_field (| n, "move_core_types::u256::U256", 0 |)
                    |)
                  ]
                |)
              |) in
            M.match_operator (|
              Ty.apply
                (Ty.path "*")
                []
                [
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [ Ty.path "u8"; Ty.path "move_core_types::u256::U256CastError" ]
                ],
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            Ty.path "bool",
                            BinOp.gt,
                            [
                              M.read (| n |);
                              M.cast
                                (Ty.path "u64")
                                (M.read (|
                                  get_associated_constant (| Ty.path "u8", "MAX", Ty.path "u8" |)
                                |))
                            ]
                          |)
                        |)) in
                    let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Err"
                        [
                          M.call_closure (|
                            Ty.path "move_core_types::u256::U256CastError",
                            M.get_associated_function (|
                              Ty.path "move_core_types::u256::U256CastError",
                              "new",
                              [],
                              [ Ty.path "u64" ]
                            |),
                            [
                              M.read (| n |);
                              Value.StructTuple
                                "move_core_types::u256::U256CastErrorKind::TooLargeForU8"
                                []
                            ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [ M.cast (Ty.path "u8") (M.read (| n |)) ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::convert::TryFrom"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "move_core_types::u256::U256" ]
        Self
        (* Instance *)
        [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
  End Impl_core_convert_TryFrom_move_core_types_u256_U256_for_u8.
  
  Module Impl_core_convert_TryFrom_move_core_types_u256_U256_for_u16.
    Definition Self : Ty.t := Ty.path "u16".
    
    (*     type Error = U256CastError; *)
    Definition _Error : Ty.t := Ty.path "move_core_types::u256::U256CastError".
    
    (*
        fn try_from(n: U256) -> Result<Self, Self::Error> {
            let n = n.0.low_u64();
            if n > u16::MAX as u64 {
                Err(U256CastError::new(n, U256CastErrorKind::TooLargeForU16))
            } else {
                Ok(n as u16)
            }
        }
    *)
    Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ n ] =>
        ltac:(M.monadic
          (let n := M.alloc (| n |) in
          M.read (|
            let~ n : Ty.apply (Ty.path "*") [] [ Ty.path "u64" ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "u64",
                  M.get_associated_function (|
                    Ty.path "primitive_types::U256",
                    "low_u64",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_tuple_field (| n, "move_core_types::u256::U256", 0 |)
                    |)
                  ]
                |)
              |) in
            M.match_operator (|
              Ty.apply
                (Ty.path "*")
                []
                [
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [ Ty.path "u16"; Ty.path "move_core_types::u256::U256CastError" ]
                ],
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            Ty.path "bool",
                            BinOp.gt,
                            [
                              M.read (| n |);
                              M.cast
                                (Ty.path "u64")
                                (M.read (|
                                  get_associated_constant (| Ty.path "u16", "MAX", Ty.path "u16" |)
                                |))
                            ]
                          |)
                        |)) in
                    let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Err"
                        [
                          M.call_closure (|
                            Ty.path "move_core_types::u256::U256CastError",
                            M.get_associated_function (|
                              Ty.path "move_core_types::u256::U256CastError",
                              "new",
                              [],
                              [ Ty.path "u64" ]
                            |),
                            [
                              M.read (| n |);
                              Value.StructTuple
                                "move_core_types::u256::U256CastErrorKind::TooLargeForU16"
                                []
                            ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [ M.cast (Ty.path "u16") (M.read (| n |)) ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::convert::TryFrom"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "move_core_types::u256::U256" ]
        Self
        (* Instance *)
        [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
  End Impl_core_convert_TryFrom_move_core_types_u256_U256_for_u16.
  
  Module Impl_core_convert_TryFrom_move_core_types_u256_U256_for_u32.
    Definition Self : Ty.t := Ty.path "u32".
    
    (*     type Error = U256CastError; *)
    Definition _Error : Ty.t := Ty.path "move_core_types::u256::U256CastError".
    
    (*
        fn try_from(n: U256) -> Result<Self, Self::Error> {
            let n = n.0.low_u64();
            if n > u32::MAX as u64 {
                Err(U256CastError::new(n, U256CastErrorKind::TooLargeForU32))
            } else {
                Ok(n as u32)
            }
        }
    *)
    Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ n ] =>
        ltac:(M.monadic
          (let n := M.alloc (| n |) in
          M.read (|
            let~ n : Ty.apply (Ty.path "*") [] [ Ty.path "u64" ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "u64",
                  M.get_associated_function (|
                    Ty.path "primitive_types::U256",
                    "low_u64",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_tuple_field (| n, "move_core_types::u256::U256", 0 |)
                    |)
                  ]
                |)
              |) in
            M.match_operator (|
              Ty.apply
                (Ty.path "*")
                []
                [
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [ Ty.path "u32"; Ty.path "move_core_types::u256::U256CastError" ]
                ],
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            Ty.path "bool",
                            BinOp.gt,
                            [
                              M.read (| n |);
                              M.cast
                                (Ty.path "u64")
                                (M.read (|
                                  get_associated_constant (| Ty.path "u32", "MAX", Ty.path "u32" |)
                                |))
                            ]
                          |)
                        |)) in
                    let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Err"
                        [
                          M.call_closure (|
                            Ty.path "move_core_types::u256::U256CastError",
                            M.get_associated_function (|
                              Ty.path "move_core_types::u256::U256CastError",
                              "new",
                              [],
                              [ Ty.path "u64" ]
                            |),
                            [
                              M.read (| n |);
                              Value.StructTuple
                                "move_core_types::u256::U256CastErrorKind::TooLargeForU32"
                                []
                            ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [ M.cast (Ty.path "u32") (M.read (| n |)) ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::convert::TryFrom"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "move_core_types::u256::U256" ]
        Self
        (* Instance *)
        [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
  End Impl_core_convert_TryFrom_move_core_types_u256_U256_for_u32.
  
  Module Impl_core_convert_TryFrom_move_core_types_u256_U256_for_u64.
    Definition Self : Ty.t := Ty.path "u64".
    
    (*     type Error = U256CastError; *)
    Definition _Error : Ty.t := Ty.path "move_core_types::u256::U256CastError".
    
    (*
        fn try_from(n: U256) -> Result<Self, Self::Error> {
            let n = n.0.low_u128();
            if n > u64::MAX as u128 {
                Err(U256CastError::new(n, U256CastErrorKind::TooLargeForU64))
            } else {
                Ok(n as u64)
            }
        }
    *)
    Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ n ] =>
        ltac:(M.monadic
          (let n := M.alloc (| n |) in
          M.read (|
            let~ n : Ty.apply (Ty.path "*") [] [ Ty.path "u128" ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "u128",
                  M.get_associated_function (|
                    Ty.path "primitive_types::U256",
                    "low_u128",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_tuple_field (| n, "move_core_types::u256::U256", 0 |)
                    |)
                  ]
                |)
              |) in
            M.match_operator (|
              Ty.apply
                (Ty.path "*")
                []
                [
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [ Ty.path "u64"; Ty.path "move_core_types::u256::U256CastError" ]
                ],
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            Ty.path "bool",
                            BinOp.gt,
                            [
                              M.read (| n |);
                              M.cast
                                (Ty.path "u128")
                                (M.read (|
                                  get_associated_constant (| Ty.path "u64", "MAX", Ty.path "u64" |)
                                |))
                            ]
                          |)
                        |)) in
                    let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Err"
                        [
                          M.call_closure (|
                            Ty.path "move_core_types::u256::U256CastError",
                            M.get_associated_function (|
                              Ty.path "move_core_types::u256::U256CastError",
                              "new",
                              [],
                              [ Ty.path "u128" ]
                            |),
                            [
                              M.read (| n |);
                              Value.StructTuple
                                "move_core_types::u256::U256CastErrorKind::TooLargeForU64"
                                []
                            ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [ M.cast (Ty.path "u64") (M.read (| n |)) ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::convert::TryFrom"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "move_core_types::u256::U256" ]
        Self
        (* Instance *)
        [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
  End Impl_core_convert_TryFrom_move_core_types_u256_U256_for_u64.
  
  Module Impl_core_convert_TryFrom_move_core_types_u256_U256_for_u128.
    Definition Self : Ty.t := Ty.path "u128".
    
    (*     type Error = U256CastError; *)
    Definition _Error : Ty.t := Ty.path "move_core_types::u256::U256CastError".
    
    (*
        fn try_from(n: U256) -> Result<Self, Self::Error> {
            if n > U256::from(u128::MAX) {
                Err(U256CastError::new(n, U256CastErrorKind::TooLargeForU128))
            } else {
                Ok(n.0.low_u128())
            }
        }
    *)
    Definition try_from (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ n ] =>
        ltac:(M.monadic
          (let n := M.alloc (| n |) in
          M.read (|
            M.match_operator (|
              Ty.apply
                (Ty.path "*")
                []
                [
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [ Ty.path "u128"; Ty.path "move_core_types::u256::U256CastError" ]
                ],
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            Ty.path "bool",
                            M.get_trait_method (|
                              "core::cmp::PartialOrd",
                              Ty.path "move_core_types::u256::U256",
                              [],
                              [ Ty.path "move_core_types::u256::U256" ],
                              "gt",
                              [],
                              []
                            |),
                            [
                              M.borrow (| Pointer.Kind.Ref, n |);
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.alloc (|
                                  M.call_closure (|
                                    Ty.path "move_core_types::u256::U256",
                                    M.get_trait_method (|
                                      "core::convert::From",
                                      Ty.path "move_core_types::u256::U256",
                                      [],
                                      [ Ty.path "u128" ],
                                      "from",
                                      [],
                                      []
                                    |),
                                    [
                                      M.read (|
                                        get_associated_constant (|
                                          Ty.path "u128",
                                          "MAX",
                                          Ty.path "u128"
                                        |)
                                      |)
                                    ]
                                  |)
                                |)
                              |)
                            ]
                          |)
                        |)) in
                    let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Err"
                        [
                          M.call_closure (|
                            Ty.path "move_core_types::u256::U256CastError",
                            M.get_associated_function (|
                              Ty.path "move_core_types::u256::U256CastError",
                              "new",
                              [],
                              [ Ty.path "move_core_types::u256::U256" ]
                            |),
                            [
                              M.read (| n |);
                              Value.StructTuple
                                "move_core_types::u256::U256CastErrorKind::TooLargeForU128"
                                []
                            ]
                          |)
                        ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (M.alloc (|
                      Value.StructTuple
                        "core::result::Result::Ok"
                        [
                          M.call_closure (|
                            Ty.path "u128",
                            M.get_associated_function (|
                              Ty.path "primitive_types::U256",
                              "low_u128",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.SubPointer.get_struct_tuple_field (|
                                  n,
                                  "move_core_types::u256::U256",
                                  0
                                |)
                              |)
                            ]
                          |)
                        ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::convert::TryFrom"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "move_core_types::u256::U256" ]
        Self
        (* Instance *)
        [ ("Error", InstanceField.Ty _Error); ("try_from", InstanceField.Method try_from) ].
  End Impl_core_convert_TryFrom_move_core_types_u256_U256_for_u128.
  
  Module Impl_rand_distributions_distribution_Distribution_move_core_types_u256_U256_for_rand_distributions_Standard.
    Definition Self : Ty.t := Ty.path "rand::distributions::Standard".
    
    (*
        fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> U256 {
            let mut dest = [0; U256_NUM_BYTES];
            rng.fill_bytes(&mut dest);
            U256::from_le_bytes(&dest)
        }
    *)
    Definition sample (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ R ], [ self; rng ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rng := M.alloc (| rng |) in
          M.read (|
            let~ dest :
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "array")
                      [ Value.Integer IntegerKind.Usize 32 ]
                      [ Ty.path "u8" ]
                  ] :=
              M.alloc (|
                repeat (| Value.Integer IntegerKind.U8 0, Value.Integer IntegerKind.Usize 32 |)
              |) in
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (| "rand_core::RngCore", R, [], [], "fill_bytes", [], [] |),
                  [
                    M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| rng |) |) |);
                    (* Unsize *)
                    M.pointer_coercion
                      (M.borrow (|
                        Pointer.Kind.MutRef,
                        M.deref (| M.borrow (| Pointer.Kind.MutRef, dest |) |)
                      |))
                  ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                Ty.path "move_core_types::u256::U256",
                M.get_associated_function (|
                  Ty.path "move_core_types::u256::U256",
                  "from_le_bytes",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (| M.borrow (| Pointer.Kind.Ref, dest |) |)
                  |)
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "rand::distributions::distribution::Distribution"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "move_core_types::u256::U256" ]
        Self
        (* Instance *) [ ("sample", InstanceField.Method sample) ].
  End Impl_rand_distributions_distribution_Distribution_move_core_types_u256_U256_for_rand_distributions_Standard.
  
  (* StructRecord
    {
      name := "UniformU256";
      const_params := [];
      ty_params := [];
      fields :=
        [
          ("low", Ty.path "move_core_types::u256::U256");
          ("range", Ty.path "move_core_types::u256::U256");
          ("z", Ty.path "move_core_types::u256::U256")
        ];
    } *)
  
  Module Impl_core_clone_Clone_for_move_core_types_u256_UniformU256.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::UniformU256".
    
    (* Clone *)
    Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.path "move_core_types::u256::UniformU256" ],
              Value.DeclaredButUndefined,
              [ fun γ => ltac:(M.monadic (M.deref (| M.read (| self |) |))) ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::clone::Clone"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("clone", InstanceField.Method clone) ].
  End Impl_core_clone_Clone_for_move_core_types_u256_UniformU256.
  
  Module Impl_core_marker_Copy_for_move_core_types_u256_UniformU256.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::UniformU256".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::Copy"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_Copy_for_move_core_types_u256_UniformU256.
  
  Module Impl_core_fmt_Debug_for_move_core_types_u256_UniformU256.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::UniformU256".
    
    (* Debug *)
    Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_associated_function (|
              Ty.path "core::fmt::Formatter",
              "debug_struct_field3_finish",
              [],
              []
            |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "UniformU256" |) |) |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "low" |) |) |);
              (* Unsize *)
              M.pointer_coercion
                (M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "move_core_types::u256::UniformU256",
                        "low"
                      |)
                    |)
                  |)
                |));
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "range" |) |) |);
              (* Unsize *)
              M.pointer_coercion
                (M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "move_core_types::u256::UniformU256",
                        "range"
                      |)
                    |)
                  |)
                |));
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "z" |) |) |);
              (* Unsize *)
              M.pointer_coercion
                (M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.alloc (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "move_core_types::u256::UniformU256",
                            "z"
                          |)
                        |)
                      |)
                    |)
                  |)
                |))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
  End Impl_core_fmt_Debug_for_move_core_types_u256_UniformU256.
  
  Module Impl_core_marker_StructuralPartialEq_for_move_core_types_u256_UniformU256.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::UniformU256".
    
    Axiom Implements :
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_move_core_types_u256_UniformU256.
  
  Module Impl_core_cmp_PartialEq_move_core_types_u256_UniformU256_for_move_core_types_u256_UniformU256.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::UniformU256".
    
    (* PartialEq *)
    Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          LogicalOp.and (|
            LogicalOp.and (|
              M.call_closure (|
                Ty.path "bool",
                M.get_trait_method (|
                  "core::cmp::PartialEq",
                  Ty.path "move_core_types::u256::U256",
                  [],
                  [ Ty.path "move_core_types::u256::U256" ],
                  "eq",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "move_core_types::u256::UniformU256",
                      "low"
                    |)
                  |);
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| other |) |),
                      "move_core_types::u256::UniformU256",
                      "low"
                    |)
                  |)
                ]
              |),
              ltac:(M.monadic
                (M.call_closure (|
                  Ty.path "bool",
                  M.get_trait_method (|
                    "core::cmp::PartialEq",
                    Ty.path "move_core_types::u256::U256",
                    [],
                    [ Ty.path "move_core_types::u256::U256" ],
                    "eq",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "move_core_types::u256::UniformU256",
                        "range"
                      |)
                    |);
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| other |) |),
                        "move_core_types::u256::UniformU256",
                        "range"
                      |)
                    |)
                  ]
                |)))
            |),
            ltac:(M.monadic
              (M.call_closure (|
                Ty.path "bool",
                M.get_trait_method (|
                  "core::cmp::PartialEq",
                  Ty.path "move_core_types::u256::U256",
                  [],
                  [ Ty.path "move_core_types::u256::U256" ],
                  "eq",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "move_core_types::u256::UniformU256",
                      "z"
                    |)
                  |);
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| other |) |),
                      "move_core_types::u256::UniformU256",
                      "z"
                    |)
                  |)
                ]
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.path "move_core_types::u256::UniformU256" ]
        Self
        (* Instance *) [ ("eq", InstanceField.Method eq) ].
  End Impl_core_cmp_PartialEq_move_core_types_u256_UniformU256_for_move_core_types_u256_UniformU256.
  
  Module Impl_core_cmp_Eq_for_move_core_types_u256_UniformU256.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::UniformU256".
    
    (* Eq *)
    Definition assert_receiver_is_total_eq
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              Value.DeclaredButUndefined,
              [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::cmp::Eq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
  End Impl_core_cmp_Eq_for_move_core_types_u256_UniformU256.
  
  Module Impl_rand_distributions_uniform_SampleUniform_for_move_core_types_u256_U256.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::U256".
    
    (*     type Sampler = UniformU256; *)
    Definition _Sampler : Ty.t := Ty.path "move_core_types::u256::UniformU256".
    
    Axiom Implements :
      M.IsTraitInstance
        "rand::distributions::uniform::SampleUniform"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *) [ ("Sampler", InstanceField.Ty _Sampler) ].
  End Impl_rand_distributions_uniform_SampleUniform_for_move_core_types_u256_U256.
  
  Module Impl_rand_distributions_uniform_UniformSampler_for_move_core_types_u256_UniformU256.
    Definition Self : Ty.t := Ty.path "move_core_types::u256::UniformU256".
    
    (*     type X = U256; *)
    Definition _X : Ty.t := Ty.path "move_core_types::u256::U256".
    
    (*
        fn new<B1, B2>(low: B1, high: B2) -> Self
        where
            B1: rand::distributions::uniform::SampleBorrow<Self::X> + Sized,
            B2: rand::distributions::uniform::SampleBorrow<Self::X> + Sized,
        {
            let low = *low.borrow();
            let high = *high.borrow();
            assert!(low < high, "Uniform::new called with `low >= high`");
            UniformSampler::new_inclusive(low, high - U256::one())
        }
    *)
    Definition new (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ B1; B2 ], [ low; high ] =>
        ltac:(M.monadic
          (let low := M.alloc (| low |) in
          let high := M.alloc (| high |) in
          M.read (|
            let~ low : Ty.apply (Ty.path "*") [] [ Ty.path "move_core_types::u256::U256" ] :=
              M.copy (|
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ Ty.path "move_core_types::u256::U256" ],
                    M.get_trait_method (|
                      "rand::distributions::uniform::SampleBorrow",
                      B1,
                      [],
                      [ Ty.path "move_core_types::u256::U256" ],
                      "borrow",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, low |) ]
                  |)
                |)
              |) in
            let~ high : Ty.apply (Ty.path "*") [] [ Ty.path "move_core_types::u256::U256" ] :=
              M.copy (|
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ Ty.path "move_core_types::u256::U256" ],
                    M.get_trait_method (|
                      "rand::distributions::uniform::SampleBorrow",
                      B2,
                      [],
                      [ Ty.path "move_core_types::u256::U256" ],
                      "borrow",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, high |) ]
                  |)
                |)
              |) in
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.match_operator (|
                Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            UnOp.not (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_trait_method (|
                                  "core::cmp::PartialOrd",
                                  Ty.path "move_core_types::u256::U256",
                                  [],
                                  [ Ty.path "move_core_types::u256::U256" ],
                                  "lt",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (| Pointer.Kind.Ref, low |);
                                  M.borrow (| Pointer.Kind.Ref, high |)
                                ]
                              |)
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        M.never_to_any (|
                          M.call_closure (|
                            Ty.path "never",
                            M.get_function (| "core::panicking::panic_fmt", [], [] |),
                            [
                              M.call_closure (|
                                Ty.path "core::fmt::Arguments",
                                M.get_associated_function (|
                                  Ty.path "core::fmt::Arguments",
                                  "new_const",
                                  [ Value.Integer IntegerKind.Usize 1 ],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.alloc (|
                                          Value.Array
                                            [ mk_str (| "Uniform::new called with `low >= high`" |)
                                            ]
                                        |)
                                      |)
                                    |)
                                  |)
                                ]
                              |)
                            ]
                          |)
                        |)
                      |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            M.alloc (|
              M.call_closure (|
                Ty.path "move_core_types::u256::UniformU256",
                M.get_trait_method (|
                  "rand::distributions::uniform::UniformSampler",
                  Ty.path "move_core_types::u256::UniformU256",
                  [],
                  [],
                  "new_inclusive",
                  [],
                  [ Ty.path "move_core_types::u256::U256"; Ty.path "move_core_types::u256::U256" ]
                |),
                [
                  M.read (| low |);
                  M.call_closure (|
                    Ty.path "move_core_types::u256::U256",
                    M.get_trait_method (|
                      "core::ops::arith::Sub",
                      Ty.path "move_core_types::u256::U256",
                      [],
                      [ Ty.path "move_core_types::u256::U256" ],
                      "sub",
                      [],
                      []
                    |),
                    [
                      M.read (| high |);
                      M.call_closure (|
                        Ty.path "move_core_types::u256::U256",
                        M.get_associated_function (|
                          Ty.path "move_core_types::u256::U256",
                          "one",
                          [],
                          []
                        |),
                        []
                      |)
                    ]
                  |)
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn new_inclusive<B1, B2>(low: B1, high: B2) -> Self
        where
            B1: rand::distributions::uniform::SampleBorrow<Self::X> + Sized,
            B2: rand::distributions::uniform::SampleBorrow<Self::X> + Sized,
        {
            let low = *low.borrow();
            let high = *high.borrow();
            assert!(
                low <= high,
                "Uniform::new_inclusive called with `low > high`"
            );
            let unsigned_max = U256::max_value();
    
            let range = high.wrapping_sub(low).wrapping_add(U256::one());
    
            let ints_to_reject = if range > U256::zero() {
                (unsigned_max - range) + U256::one() % range
            } else {
                U256::zero()
            };
    
            UniformU256 {
                low,
                range,
                z: ints_to_reject,
            }
        }
    *)
    Definition new_inclusive (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ B1; B2 ], [ low; high ] =>
        ltac:(M.monadic
          (let low := M.alloc (| low |) in
          let high := M.alloc (| high |) in
          M.read (|
            let~ low : Ty.apply (Ty.path "*") [] [ Ty.path "move_core_types::u256::U256" ] :=
              M.copy (|
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ Ty.path "move_core_types::u256::U256" ],
                    M.get_trait_method (|
                      "rand::distributions::uniform::SampleBorrow",
                      B1,
                      [],
                      [ Ty.path "move_core_types::u256::U256" ],
                      "borrow",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, low |) ]
                  |)
                |)
              |) in
            let~ high : Ty.apply (Ty.path "*") [] [ Ty.path "move_core_types::u256::U256" ] :=
              M.copy (|
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ Ty.path "move_core_types::u256::U256" ],
                    M.get_trait_method (|
                      "rand::distributions::uniform::SampleBorrow",
                      B2,
                      [],
                      [ Ty.path "move_core_types::u256::U256" ],
                      "borrow",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, high |) ]
                  |)
                |)
              |) in
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.match_operator (|
                Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            UnOp.not (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_trait_method (|
                                  "core::cmp::PartialOrd",
                                  Ty.path "move_core_types::u256::U256",
                                  [],
                                  [ Ty.path "move_core_types::u256::U256" ],
                                  "le",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (| Pointer.Kind.Ref, low |);
                                  M.borrow (| Pointer.Kind.Ref, high |)
                                ]
                              |)
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        M.never_to_any (|
                          M.call_closure (|
                            Ty.path "never",
                            M.get_function (| "core::panicking::panic_fmt", [], [] |),
                            [
                              M.call_closure (|
                                Ty.path "core::fmt::Arguments",
                                M.get_associated_function (|
                                  Ty.path "core::fmt::Arguments",
                                  "new_const",
                                  [ Value.Integer IntegerKind.Usize 1 ],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.alloc (|
                                          Value.Array
                                            [
                                              mk_str (|
                                                "Uniform::new_inclusive called with `low > high`"
                                              |)
                                            ]
                                        |)
                                      |)
                                    |)
                                  |)
                                ]
                              |)
                            ]
                          |)
                        |)
                      |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            let~ unsigned_max :
                Ty.apply (Ty.path "*") [] [ Ty.path "move_core_types::u256::U256" ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "move_core_types::u256::U256",
                  M.get_associated_function (|
                    Ty.path "move_core_types::u256::U256",
                    "max_value",
                    [],
                    []
                  |),
                  []
                |)
              |) in
            let~ range : Ty.apply (Ty.path "*") [] [ Ty.path "move_core_types::u256::U256" ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "move_core_types::u256::U256",
                  M.get_associated_function (|
                    Ty.path "move_core_types::u256::U256",
                    "wrapping_add",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.path "move_core_types::u256::U256",
                      M.get_associated_function (|
                        Ty.path "move_core_types::u256::U256",
                        "wrapping_sub",
                        [],
                        []
                      |),
                      [ M.read (| high |); M.read (| low |) ]
                    |);
                    M.call_closure (|
                      Ty.path "move_core_types::u256::U256",
                      M.get_associated_function (|
                        Ty.path "move_core_types::u256::U256",
                        "one",
                        [],
                        []
                      |),
                      []
                    |)
                  ]
                |)
              |) in
            let~ ints_to_reject :
                Ty.apply (Ty.path "*") [] [ Ty.path "move_core_types::u256::U256" ] :=
              M.copy (|
                M.match_operator (|
                  Ty.apply (Ty.path "*") [] [ Ty.path "move_core_types::u256::U256" ],
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_trait_method (|
                                  "core::cmp::PartialOrd",
                                  Ty.path "move_core_types::u256::U256",
                                  [],
                                  [ Ty.path "move_core_types::u256::U256" ],
                                  "gt",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (| Pointer.Kind.Ref, range |);
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.path "move_core_types::u256::U256",
                                        M.get_associated_function (|
                                          Ty.path "move_core_types::u256::U256",
                                          "zero",
                                          [],
                                          []
                                        |),
                                        []
                                      |)
                                    |)
                                  |)
                                ]
                              |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.alloc (|
                          M.call_closure (|
                            Ty.path "move_core_types::u256::U256",
                            M.get_trait_method (|
                              "core::ops::arith::Add",
                              Ty.path "move_core_types::u256::U256",
                              [],
                              [ Ty.path "move_core_types::u256::U256" ],
                              "add",
                              [],
                              []
                            |),
                            [
                              M.call_closure (|
                                Ty.path "move_core_types::u256::U256",
                                M.get_trait_method (|
                                  "core::ops::arith::Sub",
                                  Ty.path "move_core_types::u256::U256",
                                  [],
                                  [ Ty.path "move_core_types::u256::U256" ],
                                  "sub",
                                  [],
                                  []
                                |),
                                [ M.read (| unsigned_max |); M.read (| range |) ]
                              |);
                              M.call_closure (|
                                Ty.path "move_core_types::u256::U256",
                                M.get_trait_method (|
                                  "core::ops::arith::Rem",
                                  Ty.path "move_core_types::u256::U256",
                                  [],
                                  [ Ty.path "move_core_types::u256::U256" ],
                                  "rem",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.path "move_core_types::u256::U256",
                                    M.get_associated_function (|
                                      Ty.path "move_core_types::u256::U256",
                                      "one",
                                      [],
                                      []
                                    |),
                                    []
                                  |);
                                  M.read (| range |)
                                ]
                              |)
                            ]
                          |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (M.alloc (|
                          M.call_closure (|
                            Ty.path "move_core_types::u256::U256",
                            M.get_associated_function (|
                              Ty.path "move_core_types::u256::U256",
                              "zero",
                              [],
                              []
                            |),
                            []
                          |)
                        |)))
                  ]
                |)
              |) in
            M.alloc (|
              Value.StructRecord
                "move_core_types::u256::UniformU256"
                [
                  ("low", M.read (| low |));
                  ("range", M.read (| range |));
                  ("z", M.read (| ints_to_reject |))
                ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn sample<R: rand::Rng + ?Sized>(&self, rng: &mut R) -> Self::X {
            let range = self.range;
            if range > U256::zero() {
                let unsigned_max = U256::max_value();
                let zone = unsigned_max - self.z;
                loop {
                    let v: U256 = rng.gen();
                    let (hi, lo) = v.wmul(range);
                    if lo <= zone {
                        return self.low.wrapping_add(hi);
                    }
                }
            } else {
                // Sample from the entire integer range.
                rng.gen()
            }
        }
    *)
    Definition sample (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ R ], [ self; rng ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let rng := M.alloc (| rng |) in
          M.catch_return
            (Ty.associated_in_trait
              "rand::distributions::uniform::UniformSampler"
              []
              []
              (Ty.path "move_core_types::u256::UniformU256")
              "X") (|
            ltac:(M.monadic
              (M.read (|
                let~ range : Ty.apply (Ty.path "*") [] [ Ty.path "move_core_types::u256::U256" ] :=
                  M.copy (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "move_core_types::u256::UniformU256",
                      "range"
                    |)
                  |) in
                M.match_operator (|
                  Ty.apply (Ty.path "*") [] [ Ty.path "move_core_types::u256::U256" ],
                  M.alloc (| Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_trait_method (|
                                  "core::cmp::PartialOrd",
                                  Ty.path "move_core_types::u256::U256",
                                  [],
                                  [ Ty.path "move_core_types::u256::U256" ],
                                  "gt",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (| Pointer.Kind.Ref, range |);
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.path "move_core_types::u256::U256",
                                        M.get_associated_function (|
                                          Ty.path "move_core_types::u256::U256",
                                          "zero",
                                          [],
                                          []
                                        |),
                                        []
                                      |)
                                    |)
                                  |)
                                ]
                              |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        let~ unsigned_max :
                            Ty.apply (Ty.path "*") [] [ Ty.path "move_core_types::u256::U256" ] :=
                          M.alloc (|
                            M.call_closure (|
                              Ty.path "move_core_types::u256::U256",
                              M.get_associated_function (|
                                Ty.path "move_core_types::u256::U256",
                                "max_value",
                                [],
                                []
                              |),
                              []
                            |)
                          |) in
                        let~ zone :
                            Ty.apply (Ty.path "*") [] [ Ty.path "move_core_types::u256::U256" ] :=
                          M.alloc (|
                            M.call_closure (|
                              Ty.path "move_core_types::u256::U256",
                              M.get_trait_method (|
                                "core::ops::arith::Sub",
                                Ty.path "move_core_types::u256::U256",
                                [],
                                [ Ty.path "move_core_types::u256::U256" ],
                                "sub",
                                [],
                                []
                              |),
                              [
                                M.read (| unsigned_max |);
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "move_core_types::u256::UniformU256",
                                    "z"
                                  |)
                                |)
                              ]
                            |)
                          |) in
                        M.alloc (|
                          M.never_to_any (|
                            M.read (|
                              M.loop (|
                                Ty.apply (Ty.path "*") [] [ Ty.path "never" ],
                                ltac:(M.monadic
                                  (let~ v :
                                      Ty.apply
                                        (Ty.path "*")
                                        []
                                        [ Ty.path "move_core_types::u256::U256" ] :=
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.path "move_core_types::u256::U256",
                                        M.get_trait_method (|
                                          "rand::rng::Rng",
                                          R,
                                          [],
                                          [],
                                          "gen",
                                          [],
                                          [ Ty.path "move_core_types::u256::U256" ]
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.MutRef,
                                            M.deref (| M.read (| rng |) |)
                                          |)
                                        ]
                                      |)
                                    |) in
                                  M.match_operator (|
                                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.tuple
                                          [
                                            Ty.path "move_core_types::u256::U256";
                                            Ty.path "move_core_types::u256::U256"
                                          ],
                                        M.get_associated_function (|
                                          Ty.path "move_core_types::u256::U256",
                                          "wmul",
                                          [],
                                          []
                                        |),
                                        [ M.read (| v |); M.read (| range |) ]
                                      |)
                                    |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                          let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                          let hi := M.copy (| γ0_0 |) in
                                          let lo := M.copy (| γ0_1 |) in
                                          M.match_operator (|
                                            Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                            M.alloc (| Value.Tuple [] |),
                                            [
                                              fun γ =>
                                                ltac:(M.monadic
                                                  (let γ :=
                                                    M.use
                                                      (M.alloc (|
                                                        M.call_closure (|
                                                          Ty.path "bool",
                                                          M.get_trait_method (|
                                                            "core::cmp::PartialOrd",
                                                            Ty.path "move_core_types::u256::U256",
                                                            [],
                                                            [ Ty.path "move_core_types::u256::U256"
                                                            ],
                                                            "le",
                                                            [],
                                                            []
                                                          |),
                                                          [
                                                            M.borrow (| Pointer.Kind.Ref, lo |);
                                                            M.borrow (| Pointer.Kind.Ref, zone |)
                                                          ]
                                                        |)
                                                      |)) in
                                                  let _ :=
                                                    is_constant_or_break_match (|
                                                      M.read (| γ |),
                                                      Value.Bool true
                                                    |) in
                                                  M.alloc (|
                                                    M.never_to_any (|
                                                      M.read (|
                                                        M.return_ (|
                                                          M.call_closure (|
                                                            Ty.path "move_core_types::u256::U256",
                                                            M.get_associated_function (|
                                                              Ty.path "move_core_types::u256::U256",
                                                              "wrapping_add",
                                                              [],
                                                              []
                                                            |),
                                                            [
                                                              M.read (|
                                                                M.SubPointer.get_struct_record_field (|
                                                                  M.deref (| M.read (| self |) |),
                                                                  "move_core_types::u256::UniformU256",
                                                                  "low"
                                                                |)
                                                              |);
                                                              M.read (| hi |)
                                                            ]
                                                          |)
                                                        |)
                                                      |)
                                                    |)
                                                  |)));
                                              fun γ =>
                                                ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                            ]
                                          |)))
                                    ]
                                  |)))
                              |)
                            |)
                          |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (M.alloc (|
                          M.call_closure (|
                            Ty.path "move_core_types::u256::U256",
                            M.get_trait_method (|
                              "rand::rng::Rng",
                              R,
                              [],
                              [],
                              "gen",
                              [],
                              [ Ty.path "move_core_types::u256::U256" ]
                            |),
                            [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| rng |) |) |) ]
                          |)
                        |)))
                  ]
                |)
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn sample_single<R: rand::Rng + ?Sized, B1, B2>(low: B1, high: B2, rng: &mut R) -> Self::X
        where
            B1: rand::distributions::uniform::SampleBorrow<Self::X> + Sized,
            B2: rand::distributions::uniform::SampleBorrow<Self::X> + Sized,
        {
            let low = *low.borrow();
            let high = *high.borrow();
            assert!(low < high, "UniformSampler::sample_single: low >= high");
            Self::sample_single_inclusive(low, high - U256::one(), rng)
        }
    *)
    Definition sample_single (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ R; B1; B2 ], [ low; high; rng ] =>
        ltac:(M.monadic
          (let low := M.alloc (| low |) in
          let high := M.alloc (| high |) in
          let rng := M.alloc (| rng |) in
          M.read (|
            let~ low : Ty.apply (Ty.path "*") [] [ Ty.path "move_core_types::u256::U256" ] :=
              M.copy (|
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ Ty.path "move_core_types::u256::U256" ],
                    M.get_trait_method (|
                      "rand::distributions::uniform::SampleBorrow",
                      B1,
                      [],
                      [ Ty.path "move_core_types::u256::U256" ],
                      "borrow",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, low |) ]
                  |)
                |)
              |) in
            let~ high : Ty.apply (Ty.path "*") [] [ Ty.path "move_core_types::u256::U256" ] :=
              M.copy (|
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ Ty.path "move_core_types::u256::U256" ],
                    M.get_trait_method (|
                      "rand::distributions::uniform::SampleBorrow",
                      B2,
                      [],
                      [ Ty.path "move_core_types::u256::U256" ],
                      "borrow",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, high |) ]
                  |)
                |)
              |) in
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.match_operator (|
                Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            UnOp.not (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_trait_method (|
                                  "core::cmp::PartialOrd",
                                  Ty.path "move_core_types::u256::U256",
                                  [],
                                  [ Ty.path "move_core_types::u256::U256" ],
                                  "lt",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (| Pointer.Kind.Ref, low |);
                                  M.borrow (| Pointer.Kind.Ref, high |)
                                ]
                              |)
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        M.never_to_any (|
                          M.call_closure (|
                            Ty.path "never",
                            M.get_function (| "core::panicking::panic_fmt", [], [] |),
                            [
                              M.call_closure (|
                                Ty.path "core::fmt::Arguments",
                                M.get_associated_function (|
                                  Ty.path "core::fmt::Arguments",
                                  "new_const",
                                  [ Value.Integer IntegerKind.Usize 1 ],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.alloc (|
                                          Value.Array
                                            [
                                              mk_str (|
                                                "UniformSampler::sample_single: low >= high"
                                              |)
                                            ]
                                        |)
                                      |)
                                    |)
                                  |)
                                ]
                              |)
                            ]
                          |)
                        |)
                      |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            M.alloc (|
              M.call_closure (|
                Ty.path "move_core_types::u256::U256",
                M.get_trait_method (|
                  "rand::distributions::uniform::UniformSampler",
                  Ty.path "move_core_types::u256::UniformU256",
                  [],
                  [],
                  "sample_single_inclusive",
                  [],
                  [ R; Ty.path "move_core_types::u256::U256"; Ty.path "move_core_types::u256::U256"
                  ]
                |),
                [
                  M.read (| low |);
                  M.call_closure (|
                    Ty.path "move_core_types::u256::U256",
                    M.get_trait_method (|
                      "core::ops::arith::Sub",
                      Ty.path "move_core_types::u256::U256",
                      [],
                      [ Ty.path "move_core_types::u256::U256" ],
                      "sub",
                      [],
                      []
                    |),
                    [
                      M.read (| high |);
                      M.call_closure (|
                        Ty.path "move_core_types::u256::U256",
                        M.get_associated_function (|
                          Ty.path "move_core_types::u256::U256",
                          "one",
                          [],
                          []
                        |),
                        []
                      |)
                    ]
                  |);
                  M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| rng |) |) |)
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn sample_single_inclusive<R: rand::Rng + ?Sized, B1, B2>(
            low: B1,
            high: B2,
            rng: &mut R,
        ) -> Self::X
        where
            B1: rand::distributions::uniform::SampleBorrow<Self::X> + Sized,
            B2: rand::distributions::uniform::SampleBorrow<Self::X> + Sized,
        {
            let low = *low.borrow();
            let high = *high.borrow();
            assert!(
                low <= high,
                "UniformSampler::sample_single_inclusive: low > high"
            );
            let range = high.wrapping_sub(low).wrapping_add(U256::one());
            // If the above resulted in wrap-around to 0, the range is U256::MIN..=U256::MAX,
            // and any integer will do.
            if range == U256::zero() {
                return rng.gen();
            }
            // conservative but fast approximation. `- 1` is necessary to allow the
            // same comparison without bias.
            let zone = (range << range.leading_zeros()).wrapping_sub(U256::one());
    
            loop {
                let v: U256 = rng.gen();
                let (hi, lo) = v.wmul(range);
                if lo <= zone {
                    return low.wrapping_add(hi);
                }
            }
        }
    *)
    Definition sample_single_inclusive (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ R; B1; B2 ], [ low; high; rng ] =>
        ltac:(M.monadic
          (let low := M.alloc (| low |) in
          let high := M.alloc (| high |) in
          let rng := M.alloc (| rng |) in
          M.catch_return
            (Ty.associated_in_trait
              "rand::distributions::uniform::UniformSampler"
              []
              []
              (Ty.path "move_core_types::u256::UniformU256")
              "X") (|
            ltac:(M.monadic
              (M.read (|
                let~ low : Ty.apply (Ty.path "*") [] [ Ty.path "move_core_types::u256::U256" ] :=
                  M.copy (|
                    M.deref (|
                      M.call_closure (|
                        Ty.apply (Ty.path "&") [] [ Ty.path "move_core_types::u256::U256" ],
                        M.get_trait_method (|
                          "rand::distributions::uniform::SampleBorrow",
                          B1,
                          [],
                          [ Ty.path "move_core_types::u256::U256" ],
                          "borrow",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.Ref, low |) ]
                      |)
                    |)
                  |) in
                let~ high : Ty.apply (Ty.path "*") [] [ Ty.path "move_core_types::u256::U256" ] :=
                  M.copy (|
                    M.deref (|
                      M.call_closure (|
                        Ty.apply (Ty.path "&") [] [ Ty.path "move_core_types::u256::U256" ],
                        M.get_trait_method (|
                          "rand::distributions::uniform::SampleBorrow",
                          B2,
                          [],
                          [ Ty.path "move_core_types::u256::U256" ],
                          "borrow",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.Ref, high |) ]
                      |)
                    |)
                  |) in
                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                  M.match_operator (|
                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                UnOp.not (|
                                  M.call_closure (|
                                    Ty.path "bool",
                                    M.get_trait_method (|
                                      "core::cmp::PartialOrd",
                                      Ty.path "move_core_types::u256::U256",
                                      [],
                                      [ Ty.path "move_core_types::u256::U256" ],
                                      "le",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (| Pointer.Kind.Ref, low |);
                                      M.borrow (| Pointer.Kind.Ref, high |)
                                    ]
                                  |)
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.call_closure (|
                                Ty.path "never",
                                M.get_function (| "core::panicking::panic_fmt", [], [] |),
                                [
                                  M.call_closure (|
                                    Ty.path "core::fmt::Arguments",
                                    M.get_associated_function (|
                                      Ty.path "core::fmt::Arguments",
                                      "new_const",
                                      [ Value.Integer IntegerKind.Usize 1 ],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (|
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.alloc (|
                                              Value.Array
                                                [
                                                  mk_str (|
                                                    "UniformSampler::sample_single_inclusive: low > high"
                                                  |)
                                                ]
                                            |)
                                          |)
                                        |)
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ range : Ty.apply (Ty.path "*") [] [ Ty.path "move_core_types::u256::U256" ] :=
                  M.alloc (|
                    M.call_closure (|
                      Ty.path "move_core_types::u256::U256",
                      M.get_associated_function (|
                        Ty.path "move_core_types::u256::U256",
                        "wrapping_add",
                        [],
                        []
                      |),
                      [
                        M.call_closure (|
                          Ty.path "move_core_types::u256::U256",
                          M.get_associated_function (|
                            Ty.path "move_core_types::u256::U256",
                            "wrapping_sub",
                            [],
                            []
                          |),
                          [ M.read (| high |); M.read (| low |) ]
                        |);
                        M.call_closure (|
                          Ty.path "move_core_types::u256::U256",
                          M.get_associated_function (|
                            Ty.path "move_core_types::u256::U256",
                            "one",
                            [],
                            []
                          |),
                          []
                        |)
                      ]
                    |)
                  |) in
                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                  M.match_operator (|
                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  M.get_trait_method (|
                                    "core::cmp::PartialEq",
                                    Ty.path "move_core_types::u256::U256",
                                    [],
                                    [ Ty.path "move_core_types::u256::U256" ],
                                    "eq",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (| Pointer.Kind.Ref, range |);
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.alloc (|
                                        M.call_closure (|
                                          Ty.path "move_core_types::u256::U256",
                                          M.get_associated_function (|
                                            Ty.path "move_core_types::u256::U256",
                                            "zero",
                                            [],
                                            []
                                          |),
                                          []
                                        |)
                                      |)
                                    |)
                                  ]
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  M.call_closure (|
                                    Ty.path "move_core_types::u256::U256",
                                    M.get_trait_method (|
                                      "rand::rng::Rng",
                                      R,
                                      [],
                                      [],
                                      "gen",
                                      [],
                                      [ Ty.path "move_core_types::u256::U256" ]
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.MutRef,
                                        M.deref (| M.read (| rng |) |)
                                      |)
                                    ]
                                  |)
                                |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ zone : Ty.apply (Ty.path "*") [] [ Ty.path "move_core_types::u256::U256" ] :=
                  M.alloc (|
                    M.call_closure (|
                      Ty.path "move_core_types::u256::U256",
                      M.get_associated_function (|
                        Ty.path "move_core_types::u256::U256",
                        "wrapping_sub",
                        [],
                        []
                      |),
                      [
                        M.call_closure (|
                          Ty.path "move_core_types::u256::U256",
                          M.get_trait_method (|
                            "core::ops::bit::Shl",
                            Ty.path "move_core_types::u256::U256",
                            [],
                            [ Ty.path "u32" ],
                            "shl",
                            [],
                            []
                          |),
                          [
                            M.read (| range |);
                            M.call_closure (|
                              Ty.path "u32",
                              M.get_associated_function (|
                                Ty.path "move_core_types::u256::U256",
                                "leading_zeros",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.Ref, range |) ]
                            |)
                          ]
                        |);
                        M.call_closure (|
                          Ty.path "move_core_types::u256::U256",
                          M.get_associated_function (|
                            Ty.path "move_core_types::u256::U256",
                            "one",
                            [],
                            []
                          |),
                          []
                        |)
                      ]
                    |)
                  |) in
                M.alloc (|
                  M.never_to_any (|
                    M.read (|
                      M.loop (|
                        Ty.apply (Ty.path "*") [] [ Ty.path "never" ],
                        ltac:(M.monadic
                          (let~ v :
                              Ty.apply (Ty.path "*") [] [ Ty.path "move_core_types::u256::U256" ] :=
                            M.alloc (|
                              M.call_closure (|
                                Ty.path "move_core_types::u256::U256",
                                M.get_trait_method (|
                                  "rand::rng::Rng",
                                  R,
                                  [],
                                  [],
                                  "gen",
                                  [],
                                  [ Ty.path "move_core_types::u256::U256" ]
                                |),
                                [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| rng |) |) |)
                                ]
                              |)
                            |) in
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.tuple
                                  [
                                    Ty.path "move_core_types::u256::U256";
                                    Ty.path "move_core_types::u256::U256"
                                  ],
                                M.get_associated_function (|
                                  Ty.path "move_core_types::u256::U256",
                                  "wmul",
                                  [],
                                  []
                                |),
                                [ M.read (| v |); M.read (| range |) ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                  let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                  let hi := M.copy (| γ0_0 |) in
                                  let lo := M.copy (| γ0_1 |) in
                                  M.match_operator (|
                                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                    M.alloc (| Value.Tuple [] |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let γ :=
                                            M.use
                                              (M.alloc (|
                                                M.call_closure (|
                                                  Ty.path "bool",
                                                  M.get_trait_method (|
                                                    "core::cmp::PartialOrd",
                                                    Ty.path "move_core_types::u256::U256",
                                                    [],
                                                    [ Ty.path "move_core_types::u256::U256" ],
                                                    "le",
                                                    [],
                                                    []
                                                  |),
                                                  [
                                                    M.borrow (| Pointer.Kind.Ref, lo |);
                                                    M.borrow (| Pointer.Kind.Ref, zone |)
                                                  ]
                                                |)
                                              |)) in
                                          let _ :=
                                            is_constant_or_break_match (|
                                              M.read (| γ |),
                                              Value.Bool true
                                            |) in
                                          M.alloc (|
                                            M.never_to_any (|
                                              M.read (|
                                                M.return_ (|
                                                  M.call_closure (|
                                                    Ty.path "move_core_types::u256::U256",
                                                    M.get_associated_function (|
                                                      Ty.path "move_core_types::u256::U256",
                                                      "wrapping_add",
                                                      [],
                                                      []
                                                    |),
                                                    [ M.read (| low |); M.read (| hi |) ]
                                                  |)
                                                |)
                                              |)
                                            |)
                                          |)));
                                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                    ]
                                  |)))
                            ]
                          |)))
                      |)
                    |)
                  |)
                |)
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "rand::distributions::uniform::UniformSampler"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *)
        [
          ("X", InstanceField.Ty _X);
          ("new", InstanceField.Method new);
          ("new_inclusive", InstanceField.Method new_inclusive);
          ("sample", InstanceField.Method sample);
          ("sample_single", InstanceField.Method sample_single);
          ("sample_single_inclusive", InstanceField.Method sample_single_inclusive)
        ].
  End Impl_rand_distributions_uniform_UniformSampler_for_move_core_types_u256_UniformU256.
End u256.
