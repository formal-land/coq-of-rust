(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module bounds.
  Module Bounded.
    Class Trait (Self : Set) : Set := {
      min_value `{H : State.Trait} : (M (H := H) Self);
      max_value `{H : State.Trait} : (M (H := H) Self);
    }.
    
    Global Instance Method_min_value `{H : State.Trait} `(Trait)
      : Notation.Dot "min_value" := {
      Notation.dot := @min_value;
    }.
    Global Instance Method_max_value `{H : State.Trait} `(Trait)
      : Notation.Dot "max_value" := {
      Notation.dot := @max_value;
    }.
  End Bounded.
  
  Module LowerBounded.
    Class Trait (Self : Set) : Set := {
      min_value `{H : State.Trait} : (M (H := H) Self);
    }.
    
    Global Instance Method_min_value `{H : State.Trait} `(Trait)
      : Notation.Dot "min_value" := {
      Notation.dot := @min_value;
    }.
  End LowerBounded.
  
  Module UpperBounded.
    Class Trait (Self : Set) : Set := {
      max_value `{H : State.Trait} : (M (H := H) Self);
    }.
    
    Global Instance Method_max_value `{H : State.Trait} `(Trait)
      : Notation.Dot "max_value" := {
      Notation.dot := @max_value;
    }.
  End UpperBounded.
End bounds.

(*
Module Bounded.
  Class Trait (Self : Set) : Set := {
    min_value `{H : State.Trait} : (M (H := H) Self);
    max_value `{H : State.Trait} : (M (H := H) Self);
  }.
  
  Global Instance Method_min_value `{H : State.Trait} `(Trait)
    : Notation.Dot "min_value" := {
    Notation.dot := @min_value;
  }.
  Global Instance Method_max_value `{H : State.Trait} `(Trait)
    : Notation.Dot "max_value" := {
    Notation.dot := @max_value;
  }.
End Bounded.

Module LowerBounded.
  Class Trait (Self : Set) : Set := {
    min_value `{H : State.Trait} : (M (H := H) Self);
  }.
  
  Global Instance Method_min_value `{H : State.Trait} `(Trait)
    : Notation.Dot "min_value" := {
    Notation.dot := @min_value;
  }.
End LowerBounded.

Module UpperBounded.
  Class Trait (Self : Set) : Set := {
    max_value `{H : State.Trait} : (M (H := H) Self);
  }.
  
  Global Instance Method_max_value `{H : State.Trait} `(Trait)
    : Notation.Dot "max_value" := {
    Notation.dot := @max_value;
  }.
End UpperBounded.

Module cast.
  Module ToPrimitive.
    Class Trait (Self : Set) : Set := {
      to_i64
        `{H : State.Trait}
        :
        (ref Self) -> (M (H := H) (core.option.Option i64));
      to_u64
        `{H : State.Trait}
        :
        (ref Self) -> (M (H := H) (core.option.Option u64));
    }.
    
    Global Instance Method_to_isize `{H : State.Trait} `(Trait)
      : Notation.Dot "to_isize" := {
      Notation.dot (self : ref Self) :=
        (axiom : M (H := H) (core.option.Option isize));
    }.
    Global Instance Method_to_i8 `{H : State.Trait} `(Trait)
      : Notation.Dot "to_i8" := {
      Notation.dot (self : ref Self) :=
        (axiom : M (H := H) (core.option.Option i8));
    }.
    Global Instance Method_to_i16 `{H : State.Trait} `(Trait)
      : Notation.Dot "to_i16" := {
      Notation.dot (self : ref Self) :=
        (axiom : M (H := H) (core.option.Option i16));
    }.
    Global Instance Method_to_i32 `{H : State.Trait} `(Trait)
      : Notation.Dot "to_i32" := {
      Notation.dot (self : ref Self) :=
        (axiom : M (H := H) (core.option.Option i32));
    }.
    Global Instance Method_to_i64 `{H : State.Trait} `(Trait)
      : Notation.Dot "to_i64" := {
      Notation.dot := @to_i64;
    }.
    Global Instance Method_to_i128 `{H : State.Trait} `(Trait)
      : Notation.Dot "to_i128" := {
      Notation.dot (self : ref Self) :=
        (axiom : M (H := H) (core.option.Option i128));
    }.
    Global Instance Method_to_usize `{H : State.Trait} `(Trait)
      : Notation.Dot "to_usize" := {
      Notation.dot (self : ref Self) :=
        (axiom : M (H := H) (core.option.Option usize));
    }.
    Global Instance Method_to_u8 `{H : State.Trait} `(Trait)
      : Notation.Dot "to_u8" := {
      Notation.dot (self : ref Self) :=
        (axiom : M (H := H) (core.option.Option u8));
    }.
    Global Instance Method_to_u16 `{H : State.Trait} `(Trait)
      : Notation.Dot "to_u16" := {
      Notation.dot (self : ref Self) :=
        (axiom : M (H := H) (core.option.Option u16));
    }.
    Global Instance Method_to_u32 `{H : State.Trait} `(Trait)
      : Notation.Dot "to_u32" := {
      Notation.dot (self : ref Self) :=
        (axiom : M (H := H) (core.option.Option u32));
    }.
    Global Instance Method_to_u64 `{H : State.Trait} `(Trait)
      : Notation.Dot "to_u64" := {
      Notation.dot := @to_u64;
    }.
    Global Instance Method_to_u128 `{H : State.Trait} `(Trait)
      : Notation.Dot "to_u128" := {
      Notation.dot (self : ref Self) :=
        (axiom : M (H := H) (core.option.Option u128));
    }.
    Global Instance Method_to_f32 `{H : State.Trait} `(Trait)
      : Notation.Dot "to_f32" := {
      Notation.dot (self : ref Self) :=
        (axiom : M (H := H) (core.option.Option f32));
    }.
    Global Instance Method_to_f64 `{H : State.Trait} `(Trait)
      : Notation.Dot "to_f64" := {
      Notation.dot (self : ref Self) :=
        (axiom : M (H := H) (core.option.Option f64));
    }.
  End ToPrimitive.
  
  Module FromPrimitive.
    Class Trait (Self : Set) `{core.marker.Sized.Trait Self} : Set := {
      from_i64
        `{H : State.Trait}
        :
        i64 -> (M (H := H) (core.option.Option Self));
      from_u64
        `{H : State.Trait}
        :
        u64 -> (M (H := H) (core.option.Option Self));
    }.
    
    Global Instance Method_from_isize `{H : State.Trait} `(Trait)
      : Notation.Dot "from_isize" := {
      Notation.dot (n : isize) :=
        (axiom : M (H := H) (core.option.Option Self));
    }.
    Global Instance Method_from_i8 `{H : State.Trait} `(Trait)
      : Notation.Dot "from_i8" := {
      Notation.dot (n : i8) := (axiom : M (H := H) (core.option.Option Self));
    }.
    Global Instance Method_from_i16 `{H : State.Trait} `(Trait)
      : Notation.Dot "from_i16" := {
      Notation.dot (n : i16) := (axiom : M (H := H) (core.option.Option Self));
    }.
    Global Instance Method_from_i32 `{H : State.Trait} `(Trait)
      : Notation.Dot "from_i32" := {
      Notation.dot (n : i32) := (axiom : M (H := H) (core.option.Option Self));
    }.
    Global Instance Method_from_i64 `{H : State.Trait} `(Trait)
      : Notation.Dot "from_i64" := {
      Notation.dot := @from_i64;
    }.
    Global Instance Method_from_i128 `{H : State.Trait} `(Trait)
      : Notation.Dot "from_i128" := {
      Notation.dot (n : i128) := (axiom : M (H := H) (core.option.Option Self));
    }.
    Global Instance Method_from_usize `{H : State.Trait} `(Trait)
      : Notation.Dot "from_usize" := {
      Notation.dot (n : usize) :=
        (axiom : M (H := H) (core.option.Option Self));
    }.
    Global Instance Method_from_u8 `{H : State.Trait} `(Trait)
      : Notation.Dot "from_u8" := {
      Notation.dot (n : u8) := (axiom : M (H := H) (core.option.Option Self));
    }.
    Global Instance Method_from_u16 `{H : State.Trait} `(Trait)
      : Notation.Dot "from_u16" := {
      Notation.dot (n : u16) := (axiom : M (H := H) (core.option.Option Self));
    }.
    Global Instance Method_from_u32 `{H : State.Trait} `(Trait)
      : Notation.Dot "from_u32" := {
      Notation.dot (n : u32) := (axiom : M (H := H) (core.option.Option Self));
    }.
    Global Instance Method_from_u64 `{H : State.Trait} `(Trait)
      : Notation.Dot "from_u64" := {
      Notation.dot := @from_u64;
    }.
    Global Instance Method_from_u128 `{H : State.Trait} `(Trait)
      : Notation.Dot "from_u128" := {
      Notation.dot (n : u128) := (axiom : M (H := H) (core.option.Option Self));
    }.
    Global Instance Method_from_f32 `{H : State.Trait} `(Trait)
      : Notation.Dot "from_f32" := {
      Notation.dot (n : f32) := (axiom : M (H := H) (core.option.Option Self));
    }.
    Global Instance Method_from_f64 `{H : State.Trait} `(Trait)
      : Notation.Dot "from_f64" := {
      Notation.dot (n : f64) := (axiom : M (H := H) (core.option.Option Self));
    }.
  End FromPrimitive.
  
  Parameter cast : forall `{H : State.Trait},
      forall
      {T : Set} {U : Set},
      forall `{num_traits.cast.NumCast.Trait T}, forall
        `{num_traits.cast.NumCast.Trait U},
        T ->
      M (H := H) (core.option.Option U).
  
  Module NumCast.
    Class Trait
        (Self : Set)
          `{core.marker.Sized.Trait Self}
          `{num_traits.cast.ToPrimitive.Trait Self} :
        Set := {
      from
        `{H : State.Trait}
        {T: Set}
        `{num_traits.cast.ToPrimitive.Trait T}
        :
        T -> (M (H := H) (core.option.Option Self));
    }.
    
    Global Instance Method_from `{H : State.Trait} `(Trait)
      : Notation.Dot "from" := {
      Notation.dot := @from;
    }.
  End NumCast.
  
  Module AsPrimitive.
    Class Trait
        (Self : Set)
          `{core.marker.Copy.Trait Self}
          {T : Set}
          `{core.marker.Copy.Trait T} :
        Set := {
      as_ `{H : State.Trait} : Self -> (M (H := H) T);
    }.
    
    Global Instance Method_as_ `{H : State.Trait} `(Trait)
      : Notation.Dot "as_" := {
      Notation.dot := @as_;
    }.
  End AsPrimitive.
End cast.

Module ToPrimitive.
  Class Trait (Self : Set) : Set := {
    to_i64
      `{H : State.Trait}
      :
      (ref Self) -> (M (H := H) (core.option.Option i64));
    to_u64
      `{H : State.Trait}
      :
      (ref Self) -> (M (H := H) (core.option.Option u64));
  }.
  
  Global Instance Method_to_isize `{H : State.Trait} `(Trait)
    : Notation.Dot "to_isize" := {
    Notation.dot (self : ref Self) :=
      (axiom : M (H := H) (core.option.Option isize));
  }.
  Global Instance Method_to_i8 `{H : State.Trait} `(Trait)
    : Notation.Dot "to_i8" := {
    Notation.dot (self : ref Self) :=
      (axiom : M (H := H) (core.option.Option i8));
  }.
  Global Instance Method_to_i16 `{H : State.Trait} `(Trait)
    : Notation.Dot "to_i16" := {
    Notation.dot (self : ref Self) :=
      (axiom : M (H := H) (core.option.Option i16));
  }.
  Global Instance Method_to_i32 `{H : State.Trait} `(Trait)
    : Notation.Dot "to_i32" := {
    Notation.dot (self : ref Self) :=
      (axiom : M (H := H) (core.option.Option i32));
  }.
  Global Instance Method_to_i64 `{H : State.Trait} `(Trait)
    : Notation.Dot "to_i64" := {
    Notation.dot := @to_i64;
  }.
  Global Instance Method_to_i128 `{H : State.Trait} `(Trait)
    : Notation.Dot "to_i128" := {
    Notation.dot (self : ref Self) :=
      (axiom : M (H := H) (core.option.Option i128));
  }.
  Global Instance Method_to_usize `{H : State.Trait} `(Trait)
    : Notation.Dot "to_usize" := {
    Notation.dot (self : ref Self) :=
      (axiom : M (H := H) (core.option.Option usize));
  }.
  Global Instance Method_to_u8 `{H : State.Trait} `(Trait)
    : Notation.Dot "to_u8" := {
    Notation.dot (self : ref Self) :=
      (axiom : M (H := H) (core.option.Option u8));
  }.
  Global Instance Method_to_u16 `{H : State.Trait} `(Trait)
    : Notation.Dot "to_u16" := {
    Notation.dot (self : ref Self) :=
      (axiom : M (H := H) (core.option.Option u16));
  }.
  Global Instance Method_to_u32 `{H : State.Trait} `(Trait)
    : Notation.Dot "to_u32" := {
    Notation.dot (self : ref Self) :=
      (axiom : M (H := H) (core.option.Option u32));
  }.
  Global Instance Method_to_u64 `{H : State.Trait} `(Trait)
    : Notation.Dot "to_u64" := {
    Notation.dot := @to_u64;
  }.
  Global Instance Method_to_u128 `{H : State.Trait} `(Trait)
    : Notation.Dot "to_u128" := {
    Notation.dot (self : ref Self) :=
      (axiom : M (H := H) (core.option.Option u128));
  }.
  Global Instance Method_to_f32 `{H : State.Trait} `(Trait)
    : Notation.Dot "to_f32" := {
    Notation.dot (self : ref Self) :=
      (axiom : M (H := H) (core.option.Option f32));
  }.
  Global Instance Method_to_f64 `{H : State.Trait} `(Trait)
    : Notation.Dot "to_f64" := {
    Notation.dot (self : ref Self) :=
      (axiom : M (H := H) (core.option.Option f64));
  }.
End ToPrimitive.

Module FromPrimitive.
  Class Trait (Self : Set) `{core.marker.Sized.Trait Self} : Set := {
    from_i64 `{H : State.Trait} : i64 -> (M (H := H) (core.option.Option Self));
    from_u64 `{H : State.Trait} : u64 -> (M (H := H) (core.option.Option Self));
  }.
  
  Global Instance Method_from_isize `{H : State.Trait} `(Trait)
    : Notation.Dot "from_isize" := {
    Notation.dot (n : isize) := (axiom : M (H := H) (core.option.Option Self));
  }.
  Global Instance Method_from_i8 `{H : State.Trait} `(Trait)
    : Notation.Dot "from_i8" := {
    Notation.dot (n : i8) := (axiom : M (H := H) (core.option.Option Self));
  }.
  Global Instance Method_from_i16 `{H : State.Trait} `(Trait)
    : Notation.Dot "from_i16" := {
    Notation.dot (n : i16) := (axiom : M (H := H) (core.option.Option Self));
  }.
  Global Instance Method_from_i32 `{H : State.Trait} `(Trait)
    : Notation.Dot "from_i32" := {
    Notation.dot (n : i32) := (axiom : M (H := H) (core.option.Option Self));
  }.
  Global Instance Method_from_i64 `{H : State.Trait} `(Trait)
    : Notation.Dot "from_i64" := {
    Notation.dot := @from_i64;
  }.
  Global Instance Method_from_i128 `{H : State.Trait} `(Trait)
    : Notation.Dot "from_i128" := {
    Notation.dot (n : i128) := (axiom : M (H := H) (core.option.Option Self));
  }.
  Global Instance Method_from_usize `{H : State.Trait} `(Trait)
    : Notation.Dot "from_usize" := {
    Notation.dot (n : usize) := (axiom : M (H := H) (core.option.Option Self));
  }.
  Global Instance Method_from_u8 `{H : State.Trait} `(Trait)
    : Notation.Dot "from_u8" := {
    Notation.dot (n : u8) := (axiom : M (H := H) (core.option.Option Self));
  }.
  Global Instance Method_from_u16 `{H : State.Trait} `(Trait)
    : Notation.Dot "from_u16" := {
    Notation.dot (n : u16) := (axiom : M (H := H) (core.option.Option Self));
  }.
  Global Instance Method_from_u32 `{H : State.Trait} `(Trait)
    : Notation.Dot "from_u32" := {
    Notation.dot (n : u32) := (axiom : M (H := H) (core.option.Option Self));
  }.
  Global Instance Method_from_u64 `{H : State.Trait} `(Trait)
    : Notation.Dot "from_u64" := {
    Notation.dot := @from_u64;
  }.
  Global Instance Method_from_u128 `{H : State.Trait} `(Trait)
    : Notation.Dot "from_u128" := {
    Notation.dot (n : u128) := (axiom : M (H := H) (core.option.Option Self));
  }.
  Global Instance Method_from_f32 `{H : State.Trait} `(Trait)
    : Notation.Dot "from_f32" := {
    Notation.dot (n : f32) := (axiom : M (H := H) (core.option.Option Self));
  }.
  Global Instance Method_from_f64 `{H : State.Trait} `(Trait)
    : Notation.Dot "from_f64" := {
    Notation.dot (n : f64) := (axiom : M (H := H) (core.option.Option Self));
  }.
End FromPrimitive.

Parameter cast : forall `{H : State.Trait},
    forall
    {T : Set} {U : Set},
    forall `{num_traits.cast.NumCast.Trait T}, forall
      `{num_traits.cast.NumCast.Trait U},
      T ->
    M (H := H) (core.option.Option U).

Module NumCast.
  Class Trait
      (Self : Set)
        `{core.marker.Sized.Trait Self}
        `{num_traits.cast.ToPrimitive.Trait Self} :
      Set := {
    from
      `{H : State.Trait}
      {T: Set}
      `{num_traits.cast.ToPrimitive.Trait T}
      :
      T -> (M (H := H) (core.option.Option Self));
  }.
  
  Global Instance Method_from `{H : State.Trait} `(Trait)
    : Notation.Dot "from" := {
    Notation.dot := @from;
  }.
End NumCast.

Module AsPrimitive.
  Class Trait
      (Self : Set)
        `{core.marker.Copy.Trait Self}
        {T : Set}
        `{core.marker.Copy.Trait T} :
      Set := {
    as_ `{H : State.Trait} : Self -> (M (H := H) T);
  }.
  
  Global Instance Method_as_ `{H : State.Trait} `(Trait)
    : Notation.Dot "as_" := {
    Notation.dot := @as_;
  }.
End AsPrimitive.

Module float.
  Module FloatCore.
    Class Trait
        (Self : Set)
          `{num_traits.Num.Trait Self}
          `{num_traits.cast.NumCast.Trait Self}
          `{core.ops.arith.Neg.Trait Self}
          `{core.cmp.PartialOrd.Trait Self (Rhs := None)}
          `{core.marker.Copy.Trait Self} :
        Set := {
      infinity `{H : State.Trait} : (M (H := H) Self);
      neg_infinity `{H : State.Trait} : (M (H := H) Self);
      nan `{H : State.Trait} : (M (H := H) Self);
      neg_zero `{H : State.Trait} : (M (H := H) Self);
      min_value `{H : State.Trait} : (M (H := H) Self);
      min_positive_value `{H : State.Trait} : (M (H := H) Self);
      epsilon `{H : State.Trait} : (M (H := H) Self);
      max_value `{H : State.Trait} : (M (H := H) Self);
      classify `{H : State.Trait} : Self -> (M (H := H) core.num.FpCategory);
      to_degrees `{H : State.Trait} : Self -> (M (H := H) Self);
      to_radians `{H : State.Trait} : Self -> (M (H := H) Self);
      integer_decode `{H : State.Trait} : Self -> (M (H := H) (u64 * i16 * i8));
    }.
    
    Global Instance Method_infinity `{H : State.Trait} `(Trait)
      : Notation.Dot "infinity" := {
      Notation.dot := @infinity;
    }.
    Global Instance Method_neg_infinity `{H : State.Trait} `(Trait)
      : Notation.Dot "neg_infinity" := {
      Notation.dot := @neg_infinity;
    }.
    Global Instance Method_nan `{H : State.Trait} `(Trait)
      : Notation.Dot "nan" := {
      Notation.dot := @nan;
    }.
    Global Instance Method_neg_zero `{H : State.Trait} `(Trait)
      : Notation.Dot "neg_zero" := {
      Notation.dot := @neg_zero;
    }.
    Global Instance Method_min_value `{H : State.Trait} `(Trait)
      : Notation.Dot "min_value" := {
      Notation.dot := @min_value;
    }.
    Global Instance Method_min_positive_value `{H : State.Trait} `(Trait)
      : Notation.Dot "min_positive_value" := {
      Notation.dot := @min_positive_value;
    }.
    Global Instance Method_epsilon `{H : State.Trait} `(Trait)
      : Notation.Dot "epsilon" := {
      Notation.dot := @epsilon;
    }.
    Global Instance Method_max_value `{H : State.Trait} `(Trait)
      : Notation.Dot "max_value" := {
      Notation.dot := @max_value;
    }.
    Global Instance Method_is_nan `{H : State.Trait} `(Trait)
      : Notation.Dot "is_nan" := {
      Notation.dot (self : Self) := (axiom : M (H := H) bool);
    }.
    Global Instance Method_is_infinite `{H : State.Trait} `(Trait)
      : Notation.Dot "is_infinite" := {
      Notation.dot (self : Self) := (axiom : M (H := H) bool);
    }.
    Global Instance Method_is_finite `{H : State.Trait} `(Trait)
      : Notation.Dot "is_finite" := {
      Notation.dot (self : Self) := (axiom : M (H := H) bool);
    }.
    Global Instance Method_is_normal `{H : State.Trait} `(Trait)
      : Notation.Dot "is_normal" := {
      Notation.dot (self : Self) := (axiom : M (H := H) bool);
    }.
    Global Instance Method_is_subnormal `{H : State.Trait} `(Trait)
      : Notation.Dot "is_subnormal" := {
      Notation.dot (self : Self) := (axiom : M (H := H) bool);
    }.
    Global Instance Method_classify `{H : State.Trait} `(Trait)
      : Notation.Dot "classify" := {
      Notation.dot := @classify;
    }.
    Global Instance Method_floor `{H : State.Trait} `(Trait)
      : Notation.Dot "floor" := {
      Notation.dot (self : Self) := (axiom : M (H := H) Self);
    }.
    Global Instance Method_ceil `{H : State.Trait} `(Trait)
      : Notation.Dot "ceil" := {
      Notation.dot (self : Self) := (axiom : M (H := H) Self);
    }.
    Global Instance Method_round `{H : State.Trait} `(Trait)
      : Notation.Dot "round" := {
      Notation.dot (self : Self) := (axiom : M (H := H) Self);
    }.
    Global Instance Method_trunc `{H : State.Trait} `(Trait)
      : Notation.Dot "trunc" := {
      Notation.dot (self : Self) := (axiom : M (H := H) Self);
    }.
    Global Instance Method_fract `{H : State.Trait} `(Trait)
      : Notation.Dot "fract" := {
      Notation.dot (self : Self) := (axiom : M (H := H) Self);
    }.
    Global Instance Method_abs `{H : State.Trait} `(Trait)
      : Notation.Dot "abs" := {
      Notation.dot (self : Self) := (axiom : M (H := H) Self);
    }.
    Global Instance Method_signum `{H : State.Trait} `(Trait)
      : Notation.Dot "signum" := {
      Notation.dot (self : Self) := (axiom : M (H := H) Self);
    }.
    Global Instance Method_is_sign_positive `{H : State.Trait} `(Trait)
      : Notation.Dot "is_sign_positive" := {
      Notation.dot (self : Self) := (axiom : M (H := H) bool);
    }.
    Global Instance Method_is_sign_negative `{H : State.Trait} `(Trait)
      : Notation.Dot "is_sign_negative" := {
      Notation.dot (self : Self) := (axiom : M (H := H) bool);
    }.
    Global Instance Method_min `{H : State.Trait} `(Trait)
      : Notation.Dot "min" := {
      Notation.dot (self : Self) (other : Self) := (axiom : M (H := H) Self);
    }.
    Global Instance Method_max `{H : State.Trait} `(Trait)
      : Notation.Dot "max" := {
      Notation.dot (self : Self) (other : Self) := (axiom : M (H := H) Self);
    }.
    Global Instance Method_recip `{H : State.Trait} `(Trait)
      : Notation.Dot "recip" := {
      Notation.dot (self : Self) := (axiom : M (H := H) Self);
    }.
    Global Instance Method_powi `{H : State.Trait} `(Trait)
      : Notation.Dot "powi" := {
      Notation.dot (self : Self) (exp : i32) := (axiom : M (H := H) Self);
    }.
    Global Instance Method_to_degrees `{H : State.Trait} `(Trait)
      : Notation.Dot "to_degrees" := {
      Notation.dot := @to_degrees;
    }.
    Global Instance Method_to_radians `{H : State.Trait} `(Trait)
      : Notation.Dot "to_radians" := {
      Notation.dot := @to_radians;
    }.
    Global Instance Method_integer_decode `{H : State.Trait} `(Trait)
      : Notation.Dot "integer_decode" := {
      Notation.dot := @integer_decode;
    }.
  End FloatCore.
  
  Module Float.
    Class Trait
        (Self : Set)
          `{num_traits.Num.Trait Self}
          `{core.marker.Copy.Trait Self}
          `{num_traits.cast.NumCast.Trait Self}
          `{core.cmp.PartialOrd.Trait Self (Rhs := None)}
          `{core.ops.arith.Neg.Trait Self} :
        Set := {
      nan `{H : State.Trait} : (M (H := H) Self);
      infinity `{H : State.Trait} : (M (H := H) Self);
      neg_infinity `{H : State.Trait} : (M (H := H) Self);
      neg_zero `{H : State.Trait} : (M (H := H) Self);
      min_value `{H : State.Trait} : (M (H := H) Self);
      min_positive_value `{H : State.Trait} : (M (H := H) Self);
      max_value `{H : State.Trait} : (M (H := H) Self);
      is_nan `{H : State.Trait} : Self -> (M (H := H) bool);
      is_infinite `{H : State.Trait} : Self -> (M (H := H) bool);
      is_finite `{H : State.Trait} : Self -> (M (H := H) bool);
      is_normal `{H : State.Trait} : Self -> (M (H := H) bool);
      classify `{H : State.Trait} : Self -> (M (H := H) core.num.FpCategory);
      floor `{H : State.Trait} : Self -> (M (H := H) Self);
      ceil `{H : State.Trait} : Self -> (M (H := H) Self);
      round `{H : State.Trait} : Self -> (M (H := H) Self);
      trunc `{H : State.Trait} : Self -> (M (H := H) Self);
      fract `{H : State.Trait} : Self -> (M (H := H) Self);
      abs `{H : State.Trait} : Self -> (M (H := H) Self);
      signum `{H : State.Trait} : Self -> (M (H := H) Self);
      is_sign_positive `{H : State.Trait} : Self -> (M (H := H) bool);
      is_sign_negative `{H : State.Trait} : Self -> (M (H := H) bool);
      mul_add `{H : State.Trait} : Self -> Self -> Self -> (M (H := H) Self);
      recip `{H : State.Trait} : Self -> (M (H := H) Self);
      powi `{H : State.Trait} : Self -> i32 -> (M (H := H) Self);
      powf `{H : State.Trait} : Self -> Self -> (M (H := H) Self);
      sqrt `{H : State.Trait} : Self -> (M (H := H) Self);
      exp `{H : State.Trait} : Self -> (M (H := H) Self);
      exp2 `{H : State.Trait} : Self -> (M (H := H) Self);
      ln `{H : State.Trait} : Self -> (M (H := H) Self);
      log `{H : State.Trait} : Self -> Self -> (M (H := H) Self);
      log2 `{H : State.Trait} : Self -> (M (H := H) Self);
      log10 `{H : State.Trait} : Self -> (M (H := H) Self);
      max `{H : State.Trait} : Self -> Self -> (M (H := H) Self);
      min `{H : State.Trait} : Self -> Self -> (M (H := H) Self);
      abs_sub `{H : State.Trait} : Self -> Self -> (M (H := H) Self);
      cbrt `{H : State.Trait} : Self -> (M (H := H) Self);
      hypot `{H : State.Trait} : Self -> Self -> (M (H := H) Self);
      sin `{H : State.Trait} : Self -> (M (H := H) Self);
      cos `{H : State.Trait} : Self -> (M (H := H) Self);
      tan `{H : State.Trait} : Self -> (M (H := H) Self);
      asin `{H : State.Trait} : Self -> (M (H := H) Self);
      acos `{H : State.Trait} : Self -> (M (H := H) Self);
      atan `{H : State.Trait} : Self -> (M (H := H) Self);
      atan2 `{H : State.Trait} : Self -> Self -> (M (H := H) Self);
      sin_cos `{H : State.Trait} : Self -> (M (H := H) (Self * Self));
      exp_m1 `{H : State.Trait} : Self -> (M (H := H) Self);
      ln_1p `{H : State.Trait} : Self -> (M (H := H) Self);
      sinh `{H : State.Trait} : Self -> (M (H := H) Self);
      cosh `{H : State.Trait} : Self -> (M (H := H) Self);
      tanh `{H : State.Trait} : Self -> (M (H := H) Self);
      asinh `{H : State.Trait} : Self -> (M (H := H) Self);
      acosh `{H : State.Trait} : Self -> (M (H := H) Self);
      atanh `{H : State.Trait} : Self -> (M (H := H) Self);
      integer_decode `{H : State.Trait} : Self -> (M (H := H) (u64 * i16 * i8));
    }.
    
    Global Instance Method_nan `{H : State.Trait} `(Trait)
      : Notation.Dot "nan" := {
      Notation.dot := @nan;
    }.
    Global Instance Method_infinity `{H : State.Trait} `(Trait)
      : Notation.Dot "infinity" := {
      Notation.dot := @infinity;
    }.
    Global Instance Method_neg_infinity `{H : State.Trait} `(Trait)
      : Notation.Dot "neg_infinity" := {
      Notation.dot := @neg_infinity;
    }.
    Global Instance Method_neg_zero `{H : State.Trait} `(Trait)
      : Notation.Dot "neg_zero" := {
      Notation.dot := @neg_zero;
    }.
    Global Instance Method_min_value `{H : State.Trait} `(Trait)
      : Notation.Dot "min_value" := {
      Notation.dot := @min_value;
    }.
    Global Instance Method_min_positive_value `{H : State.Trait} `(Trait)
      : Notation.Dot "min_positive_value" := {
      Notation.dot := @min_positive_value;
    }.
    Global Instance Method_epsilon `{H : State.Trait} `(Trait)
      : Notation.Dot "epsilon" := {
      Notation.dot := (axiom : M (H := H) Self);
    }.
    Global Instance Method_max_value `{H : State.Trait} `(Trait)
      : Notation.Dot "max_value" := {
      Notation.dot := @max_value;
    }.
    Global Instance Method_is_nan `{H : State.Trait} `(Trait)
      : Notation.Dot "is_nan" := {
      Notation.dot := @is_nan;
    }.
    Global Instance Method_is_infinite `{H : State.Trait} `(Trait)
      : Notation.Dot "is_infinite" := {
      Notation.dot := @is_infinite;
    }.
    Global Instance Method_is_finite `{H : State.Trait} `(Trait)
      : Notation.Dot "is_finite" := {
      Notation.dot := @is_finite;
    }.
    Global Instance Method_is_normal `{H : State.Trait} `(Trait)
      : Notation.Dot "is_normal" := {
      Notation.dot := @is_normal;
    }.
    Global Instance Method_is_subnormal `{H : State.Trait} `(Trait)
      : Notation.Dot "is_subnormal" := {
      Notation.dot (self : Self) := (axiom : M (H := H) bool);
    }.
    Global Instance Method_classify `{H : State.Trait} `(Trait)
      : Notation.Dot "classify" := {
      Notation.dot := @classify;
    }.
    Global Instance Method_floor `{H : State.Trait} `(Trait)
      : Notation.Dot "floor" := {
      Notation.dot := @floor;
    }.
    Global Instance Method_ceil `{H : State.Trait} `(Trait)
      : Notation.Dot "ceil" := {
      Notation.dot := @ceil;
    }.
    Global Instance Method_round `{H : State.Trait} `(Trait)
      : Notation.Dot "round" := {
      Notation.dot := @round;
    }.
    Global Instance Method_trunc `{H : State.Trait} `(Trait)
      : Notation.Dot "trunc" := {
      Notation.dot := @trunc;
    }.
    Global Instance Method_fract `{H : State.Trait} `(Trait)
      : Notation.Dot "fract" := {
      Notation.dot := @fract;
    }.
    Global Instance Method_abs `{H : State.Trait} `(Trait)
      : Notation.Dot "abs" := {
      Notation.dot := @abs;
    }.
    Global Instance Method_signum `{H : State.Trait} `(Trait)
      : Notation.Dot "signum" := {
      Notation.dot := @signum;
    }.
    Global Instance Method_is_sign_positive `{H : State.Trait} `(Trait)
      : Notation.Dot "is_sign_positive" := {
      Notation.dot := @is_sign_positive;
    }.
    Global Instance Method_is_sign_negative `{H : State.Trait} `(Trait)
      : Notation.Dot "is_sign_negative" := {
      Notation.dot := @is_sign_negative;
    }.
    Global Instance Method_mul_add `{H : State.Trait} `(Trait)
      : Notation.Dot "mul_add" := {
      Notation.dot := @mul_add;
    }.
    Global Instance Method_recip `{H : State.Trait} `(Trait)
      : Notation.Dot "recip" := {
      Notation.dot := @recip;
    }.
    Global Instance Method_powi `{H : State.Trait} `(Trait)
      : Notation.Dot "powi" := {
      Notation.dot := @powi;
    }.
    Global Instance Method_powf `{H : State.Trait} `(Trait)
      : Notation.Dot "powf" := {
      Notation.dot := @powf;
    }.
    Global Instance Method_sqrt `{H : State.Trait} `(Trait)
      : Notation.Dot "sqrt" := {
      Notation.dot := @sqrt;
    }.
    Global Instance Method_exp `{H : State.Trait} `(Trait)
      : Notation.Dot "exp" := {
      Notation.dot := @exp;
    }.
    Global Instance Method_exp2 `{H : State.Trait} `(Trait)
      : Notation.Dot "exp2" := {
      Notation.dot := @exp2;
    }.
    Global Instance Method_ln `{H : State.Trait} `(Trait)
      : Notation.Dot "ln" := {
      Notation.dot := @ln;
    }.
    Global Instance Method_log `{H : State.Trait} `(Trait)
      : Notation.Dot "log" := {
      Notation.dot := @log;
    }.
    Global Instance Method_log2 `{H : State.Trait} `(Trait)
      : Notation.Dot "log2" := {
      Notation.dot := @log2;
    }.
    Global Instance Method_log10 `{H : State.Trait} `(Trait)
      : Notation.Dot "log10" := {
      Notation.dot := @log10;
    }.
    Global Instance Method_to_degrees `{H : State.Trait} `(Trait)
      : Notation.Dot "to_degrees" := {
      Notation.dot (self : Self) := (axiom : M (H := H) Self);
    }.
    Global Instance Method_to_radians `{H : State.Trait} `(Trait)
      : Notation.Dot "to_radians" := {
      Notation.dot (self : Self) := (axiom : M (H := H) Self);
    }.
    Global Instance Method_max `{H : State.Trait} `(Trait)
      : Notation.Dot "max" := {
      Notation.dot := @max;
    }.
    Global Instance Method_min `{H : State.Trait} `(Trait)
      : Notation.Dot "min" := {
      Notation.dot := @min;
    }.
    Global Instance Method_abs_sub `{H : State.Trait} `(Trait)
      : Notation.Dot "abs_sub" := {
      Notation.dot := @abs_sub;
    }.
    Global Instance Method_cbrt `{H : State.Trait} `(Trait)
      : Notation.Dot "cbrt" := {
      Notation.dot := @cbrt;
    }.
    Global Instance Method_hypot `{H : State.Trait} `(Trait)
      : Notation.Dot "hypot" := {
      Notation.dot := @hypot;
    }.
    Global Instance Method_sin `{H : State.Trait} `(Trait)
      : Notation.Dot "sin" := {
      Notation.dot := @sin;
    }.
    Global Instance Method_cos `{H : State.Trait} `(Trait)
      : Notation.Dot "cos" := {
      Notation.dot := @cos;
    }.
    Global Instance Method_tan `{H : State.Trait} `(Trait)
      : Notation.Dot "tan" := {
      Notation.dot := @tan;
    }.
    Global Instance Method_asin `{H : State.Trait} `(Trait)
      : Notation.Dot "asin" := {
      Notation.dot := @asin;
    }.
    Global Instance Method_acos `{H : State.Trait} `(Trait)
      : Notation.Dot "acos" := {
      Notation.dot := @acos;
    }.
    Global Instance Method_atan `{H : State.Trait} `(Trait)
      : Notation.Dot "atan" := {
      Notation.dot := @atan;
    }.
    Global Instance Method_atan2 `{H : State.Trait} `(Trait)
      : Notation.Dot "atan2" := {
      Notation.dot := @atan2;
    }.
    Global Instance Method_sin_cos `{H : State.Trait} `(Trait)
      : Notation.Dot "sin_cos" := {
      Notation.dot := @sin_cos;
    }.
    Global Instance Method_exp_m1 `{H : State.Trait} `(Trait)
      : Notation.Dot "exp_m1" := {
      Notation.dot := @exp_m1;
    }.
    Global Instance Method_ln_1p `{H : State.Trait} `(Trait)
      : Notation.Dot "ln_1p" := {
      Notation.dot := @ln_1p;
    }.
    Global Instance Method_sinh `{H : State.Trait} `(Trait)
      : Notation.Dot "sinh" := {
      Notation.dot := @sinh;
    }.
    Global Instance Method_cosh `{H : State.Trait} `(Trait)
      : Notation.Dot "cosh" := {
      Notation.dot := @cosh;
    }.
    Global Instance Method_tanh `{H : State.Trait} `(Trait)
      : Notation.Dot "tanh" := {
      Notation.dot := @tanh;
    }.
    Global Instance Method_asinh `{H : State.Trait} `(Trait)
      : Notation.Dot "asinh" := {
      Notation.dot := @asinh;
    }.
    Global Instance Method_acosh `{H : State.Trait} `(Trait)
      : Notation.Dot "acosh" := {
      Notation.dot := @acosh;
    }.
    Global Instance Method_atanh `{H : State.Trait} `(Trait)
      : Notation.Dot "atanh" := {
      Notation.dot := @atanh;
    }.
    Global Instance Method_integer_decode `{H : State.Trait} `(Trait)
      : Notation.Dot "integer_decode" := {
      Notation.dot := @integer_decode;
    }.
    Global Instance Method_copysign `{H : State.Trait} `(Trait)
      : Notation.Dot "copysign" := {
      Notation.dot (self : Self) (sign : Self) := (axiom : M (H := H) Self);
    }.
  End Float.
  
  Module FloatConst.
    Class Trait (Self : Set) : Set := {
      E `{H : State.Trait} : (M (H := H) Self);
      FRAC_1_PI `{H : State.Trait} : (M (H := H) Self);
      FRAC_1_SQRT_2 `{H : State.Trait} : (M (H := H) Self);
      FRAC_2_PI `{H : State.Trait} : (M (H := H) Self);
      FRAC_2_SQRT_PI `{H : State.Trait} : (M (H := H) Self);
      FRAC_PI_2 `{H : State.Trait} : (M (H := H) Self);
      FRAC_PI_3 `{H : State.Trait} : (M (H := H) Self);
      FRAC_PI_4 `{H : State.Trait} : (M (H := H) Self);
      FRAC_PI_6 `{H : State.Trait} : (M (H := H) Self);
      FRAC_PI_8 `{H : State.Trait} : (M (H := H) Self);
      LN_10 `{H : State.Trait} : (M (H := H) Self);
      LN_2 `{H : State.Trait} : (M (H := H) Self);
      LOG10_E `{H : State.Trait} : (M (H := H) Self);
      LOG2_E `{H : State.Trait} : (M (H := H) Self);
      PI `{H : State.Trait} : (M (H := H) Self);
      SQRT_2 `{H : State.Trait} : (M (H := H) Self);
    }.
    
    Global Instance Method_E `{H : State.Trait} `(Trait) : Notation.Dot "E" := {
      Notation.dot := @E;
    }.
    Global Instance Method_FRAC_1_PI `{H : State.Trait} `(Trait)
      : Notation.Dot "FRAC_1_PI" := {
      Notation.dot := @FRAC_1_PI;
    }.
    Global Instance Method_FRAC_1_SQRT_2 `{H : State.Trait} `(Trait)
      : Notation.Dot "FRAC_1_SQRT_2" := {
      Notation.dot := @FRAC_1_SQRT_2;
    }.
    Global Instance Method_FRAC_2_PI `{H : State.Trait} `(Trait)
      : Notation.Dot "FRAC_2_PI" := {
      Notation.dot := @FRAC_2_PI;
    }.
    Global Instance Method_FRAC_2_SQRT_PI `{H : State.Trait} `(Trait)
      : Notation.Dot "FRAC_2_SQRT_PI" := {
      Notation.dot := @FRAC_2_SQRT_PI;
    }.
    Global Instance Method_FRAC_PI_2 `{H : State.Trait} `(Trait)
      : Notation.Dot "FRAC_PI_2" := {
      Notation.dot := @FRAC_PI_2;
    }.
    Global Instance Method_FRAC_PI_3 `{H : State.Trait} `(Trait)
      : Notation.Dot "FRAC_PI_3" := {
      Notation.dot := @FRAC_PI_3;
    }.
    Global Instance Method_FRAC_PI_4 `{H : State.Trait} `(Trait)
      : Notation.Dot "FRAC_PI_4" := {
      Notation.dot := @FRAC_PI_4;
    }.
    Global Instance Method_FRAC_PI_6 `{H : State.Trait} `(Trait)
      : Notation.Dot "FRAC_PI_6" := {
      Notation.dot := @FRAC_PI_6;
    }.
    Global Instance Method_FRAC_PI_8 `{H : State.Trait} `(Trait)
      : Notation.Dot "FRAC_PI_8" := {
      Notation.dot := @FRAC_PI_8;
    }.
    Global Instance Method_LN_10 `{H : State.Trait} `(Trait)
      : Notation.Dot "LN_10" := {
      Notation.dot := @LN_10;
    }.
    Global Instance Method_LN_2 `{H : State.Trait} `(Trait)
      : Notation.Dot "LN_2" := {
      Notation.dot := @LN_2;
    }.
    Global Instance Method_LOG10_E `{H : State.Trait} `(Trait)
      : Notation.Dot "LOG10_E" := {
      Notation.dot := @LOG10_E;
    }.
    Global Instance Method_LOG2_E `{H : State.Trait} `(Trait)
      : Notation.Dot "LOG2_E" := {
      Notation.dot := @LOG2_E;
    }.
    Global Instance Method_PI `{H : State.Trait} `(Trait)
      : Notation.Dot "PI" := {
      Notation.dot := @PI;
    }.
    Global Instance Method_SQRT_2 `{H : State.Trait} `(Trait)
      : Notation.Dot "SQRT_2" := {
      Notation.dot := @SQRT_2;
    }.
    Global Instance Method_TAU `{H : State.Trait} `(Trait)
      : Notation.Dot "TAU" := {
      Notation.dot`{core.marker.Sized.Trait Self}
          `{core.ops.arith.Add.Trait Self (Rhs := (Some Self))}
           :=
        (axiom : M (H := H) Self);
    }.
    Global Instance Method_LOG10_2 `{H : State.Trait} `(Trait)
      : Notation.Dot "LOG10_2" := {
      Notation.dot`{core.marker.Sized.Trait Self}
          `{core.ops.arith.Div.Trait Self (Rhs := (Some Self))}
           :=
        (axiom : M (H := H) Self);
    }.
    Global Instance Method_LOG2_10 `{H : State.Trait} `(Trait)
      : Notation.Dot "LOG2_10" := {
      Notation.dot`{core.marker.Sized.Trait Self}
          `{core.ops.arith.Div.Trait Self (Rhs := (Some Self))}
           :=
        (axiom : M (H := H) Self);
    }.
  End FloatConst.
End float.

Module FloatCore.
  Class Trait
      (Self : Set)
        `{num_traits.Num.Trait Self}
        `{num_traits.cast.NumCast.Trait Self}
        `{core.ops.arith.Neg.Trait Self}
        `{core.cmp.PartialOrd.Trait Self (Rhs := None)}
        `{core.marker.Copy.Trait Self} :
      Set := {
    infinity `{H : State.Trait} : (M (H := H) Self);
    neg_infinity `{H : State.Trait} : (M (H := H) Self);
    nan `{H : State.Trait} : (M (H := H) Self);
    neg_zero `{H : State.Trait} : (M (H := H) Self);
    min_value `{H : State.Trait} : (M (H := H) Self);
    min_positive_value `{H : State.Trait} : (M (H := H) Self);
    epsilon `{H : State.Trait} : (M (H := H) Self);
    max_value `{H : State.Trait} : (M (H := H) Self);
    classify `{H : State.Trait} : Self -> (M (H := H) core.num.FpCategory);
    to_degrees `{H : State.Trait} : Self -> (M (H := H) Self);
    to_radians `{H : State.Trait} : Self -> (M (H := H) Self);
    integer_decode `{H : State.Trait} : Self -> (M (H := H) (u64 * i16 * i8));
  }.
  
  Global Instance Method_infinity `{H : State.Trait} `(Trait)
    : Notation.Dot "infinity" := {
    Notation.dot := @infinity;
  }.
  Global Instance Method_neg_infinity `{H : State.Trait} `(Trait)
    : Notation.Dot "neg_infinity" := {
    Notation.dot := @neg_infinity;
  }.
  Global Instance Method_nan `{H : State.Trait} `(Trait)
    : Notation.Dot "nan" := {
    Notation.dot := @nan;
  }.
  Global Instance Method_neg_zero `{H : State.Trait} `(Trait)
    : Notation.Dot "neg_zero" := {
    Notation.dot := @neg_zero;
  }.
  Global Instance Method_min_value `{H : State.Trait} `(Trait)
    : Notation.Dot "min_value" := {
    Notation.dot := @min_value;
  }.
  Global Instance Method_min_positive_value `{H : State.Trait} `(Trait)
    : Notation.Dot "min_positive_value" := {
    Notation.dot := @min_positive_value;
  }.
  Global Instance Method_epsilon `{H : State.Trait} `(Trait)
    : Notation.Dot "epsilon" := {
    Notation.dot := @epsilon;
  }.
  Global Instance Method_max_value `{H : State.Trait} `(Trait)
    : Notation.Dot "max_value" := {
    Notation.dot := @max_value;
  }.
  Global Instance Method_is_nan `{H : State.Trait} `(Trait)
    : Notation.Dot "is_nan" := {
    Notation.dot (self : Self) := (axiom : M (H := H) bool);
  }.
  Global Instance Method_is_infinite `{H : State.Trait} `(Trait)
    : Notation.Dot "is_infinite" := {
    Notation.dot (self : Self) := (axiom : M (H := H) bool);
  }.
  Global Instance Method_is_finite `{H : State.Trait} `(Trait)
    : Notation.Dot "is_finite" := {
    Notation.dot (self : Self) := (axiom : M (H := H) bool);
  }.
  Global Instance Method_is_normal `{H : State.Trait} `(Trait)
    : Notation.Dot "is_normal" := {
    Notation.dot (self : Self) := (axiom : M (H := H) bool);
  }.
  Global Instance Method_is_subnormal `{H : State.Trait} `(Trait)
    : Notation.Dot "is_subnormal" := {
    Notation.dot (self : Self) := (axiom : M (H := H) bool);
  }.
  Global Instance Method_classify `{H : State.Trait} `(Trait)
    : Notation.Dot "classify" := {
    Notation.dot := @classify;
  }.
  Global Instance Method_floor `{H : State.Trait} `(Trait)
    : Notation.Dot "floor" := {
    Notation.dot (self : Self) := (axiom : M (H := H) Self);
  }.
  Global Instance Method_ceil `{H : State.Trait} `(Trait)
    : Notation.Dot "ceil" := {
    Notation.dot (self : Self) := (axiom : M (H := H) Self);
  }.
  Global Instance Method_round `{H : State.Trait} `(Trait)
    : Notation.Dot "round" := {
    Notation.dot (self : Self) := (axiom : M (H := H) Self);
  }.
  Global Instance Method_trunc `{H : State.Trait} `(Trait)
    : Notation.Dot "trunc" := {
    Notation.dot (self : Self) := (axiom : M (H := H) Self);
  }.
  Global Instance Method_fract `{H : State.Trait} `(Trait)
    : Notation.Dot "fract" := {
    Notation.dot (self : Self) := (axiom : M (H := H) Self);
  }.
  Global Instance Method_abs `{H : State.Trait} `(Trait)
    : Notation.Dot "abs" := {
    Notation.dot (self : Self) := (axiom : M (H := H) Self);
  }.
  Global Instance Method_signum `{H : State.Trait} `(Trait)
    : Notation.Dot "signum" := {
    Notation.dot (self : Self) := (axiom : M (H := H) Self);
  }.
  Global Instance Method_is_sign_positive `{H : State.Trait} `(Trait)
    : Notation.Dot "is_sign_positive" := {
    Notation.dot (self : Self) := (axiom : M (H := H) bool);
  }.
  Global Instance Method_is_sign_negative `{H : State.Trait} `(Trait)
    : Notation.Dot "is_sign_negative" := {
    Notation.dot (self : Self) := (axiom : M (H := H) bool);
  }.
  Global Instance Method_min `{H : State.Trait} `(Trait)
    : Notation.Dot "min" := {
    Notation.dot (self : Self) (other : Self) := (axiom : M (H := H) Self);
  }.
  Global Instance Method_max `{H : State.Trait} `(Trait)
    : Notation.Dot "max" := {
    Notation.dot (self : Self) (other : Self) := (axiom : M (H := H) Self);
  }.
  Global Instance Method_recip `{H : State.Trait} `(Trait)
    : Notation.Dot "recip" := {
    Notation.dot (self : Self) := (axiom : M (H := H) Self);
  }.
  Global Instance Method_powi `{H : State.Trait} `(Trait)
    : Notation.Dot "powi" := {
    Notation.dot (self : Self) (exp : i32) := (axiom : M (H := H) Self);
  }.
  Global Instance Method_to_degrees `{H : State.Trait} `(Trait)
    : Notation.Dot "to_degrees" := {
    Notation.dot := @to_degrees;
  }.
  Global Instance Method_to_radians `{H : State.Trait} `(Trait)
    : Notation.Dot "to_radians" := {
    Notation.dot := @to_radians;
  }.
  Global Instance Method_integer_decode `{H : State.Trait} `(Trait)
    : Notation.Dot "integer_decode" := {
    Notation.dot := @integer_decode;
  }.
End FloatCore.

Module Float.
  Class Trait
      (Self : Set)
        `{num_traits.Num.Trait Self}
        `{core.marker.Copy.Trait Self}
        `{num_traits.cast.NumCast.Trait Self}
        `{core.cmp.PartialOrd.Trait Self (Rhs := None)}
        `{core.ops.arith.Neg.Trait Self} :
      Set := {
    nan `{H : State.Trait} : (M (H := H) Self);
    infinity `{H : State.Trait} : (M (H := H) Self);
    neg_infinity `{H : State.Trait} : (M (H := H) Self);
    neg_zero `{H : State.Trait} : (M (H := H) Self);
    min_value `{H : State.Trait} : (M (H := H) Self);
    min_positive_value `{H : State.Trait} : (M (H := H) Self);
    max_value `{H : State.Trait} : (M (H := H) Self);
    is_nan `{H : State.Trait} : Self -> (M (H := H) bool);
    is_infinite `{H : State.Trait} : Self -> (M (H := H) bool);
    is_finite `{H : State.Trait} : Self -> (M (H := H) bool);
    is_normal `{H : State.Trait} : Self -> (M (H := H) bool);
    classify `{H : State.Trait} : Self -> (M (H := H) core.num.FpCategory);
    floor `{H : State.Trait} : Self -> (M (H := H) Self);
    ceil `{H : State.Trait} : Self -> (M (H := H) Self);
    round `{H : State.Trait} : Self -> (M (H := H) Self);
    trunc `{H : State.Trait} : Self -> (M (H := H) Self);
    fract `{H : State.Trait} : Self -> (M (H := H) Self);
    abs `{H : State.Trait} : Self -> (M (H := H) Self);
    signum `{H : State.Trait} : Self -> (M (H := H) Self);
    is_sign_positive `{H : State.Trait} : Self -> (M (H := H) bool);
    is_sign_negative `{H : State.Trait} : Self -> (M (H := H) bool);
    mul_add `{H : State.Trait} : Self -> Self -> Self -> (M (H := H) Self);
    recip `{H : State.Trait} : Self -> (M (H := H) Self);
    powi `{H : State.Trait} : Self -> i32 -> (M (H := H) Self);
    powf `{H : State.Trait} : Self -> Self -> (M (H := H) Self);
    sqrt `{H : State.Trait} : Self -> (M (H := H) Self);
    exp `{H : State.Trait} : Self -> (M (H := H) Self);
    exp2 `{H : State.Trait} : Self -> (M (H := H) Self);
    ln `{H : State.Trait} : Self -> (M (H := H) Self);
    log `{H : State.Trait} : Self -> Self -> (M (H := H) Self);
    log2 `{H : State.Trait} : Self -> (M (H := H) Self);
    log10 `{H : State.Trait} : Self -> (M (H := H) Self);
    max `{H : State.Trait} : Self -> Self -> (M (H := H) Self);
    min `{H : State.Trait} : Self -> Self -> (M (H := H) Self);
    abs_sub `{H : State.Trait} : Self -> Self -> (M (H := H) Self);
    cbrt `{H : State.Trait} : Self -> (M (H := H) Self);
    hypot `{H : State.Trait} : Self -> Self -> (M (H := H) Self);
    sin `{H : State.Trait} : Self -> (M (H := H) Self);
    cos `{H : State.Trait} : Self -> (M (H := H) Self);
    tan `{H : State.Trait} : Self -> (M (H := H) Self);
    asin `{H : State.Trait} : Self -> (M (H := H) Self);
    acos `{H : State.Trait} : Self -> (M (H := H) Self);
    atan `{H : State.Trait} : Self -> (M (H := H) Self);
    atan2 `{H : State.Trait} : Self -> Self -> (M (H := H) Self);
    sin_cos `{H : State.Trait} : Self -> (M (H := H) (Self * Self));
    exp_m1 `{H : State.Trait} : Self -> (M (H := H) Self);
    ln_1p `{H : State.Trait} : Self -> (M (H := H) Self);
    sinh `{H : State.Trait} : Self -> (M (H := H) Self);
    cosh `{H : State.Trait} : Self -> (M (H := H) Self);
    tanh `{H : State.Trait} : Self -> (M (H := H) Self);
    asinh `{H : State.Trait} : Self -> (M (H := H) Self);
    acosh `{H : State.Trait} : Self -> (M (H := H) Self);
    atanh `{H : State.Trait} : Self -> (M (H := H) Self);
    integer_decode `{H : State.Trait} : Self -> (M (H := H) (u64 * i16 * i8));
  }.
  
  Global Instance Method_nan `{H : State.Trait} `(Trait)
    : Notation.Dot "nan" := {
    Notation.dot := @nan;
  }.
  Global Instance Method_infinity `{H : State.Trait} `(Trait)
    : Notation.Dot "infinity" := {
    Notation.dot := @infinity;
  }.
  Global Instance Method_neg_infinity `{H : State.Trait} `(Trait)
    : Notation.Dot "neg_infinity" := {
    Notation.dot := @neg_infinity;
  }.
  Global Instance Method_neg_zero `{H : State.Trait} `(Trait)
    : Notation.Dot "neg_zero" := {
    Notation.dot := @neg_zero;
  }.
  Global Instance Method_min_value `{H : State.Trait} `(Trait)
    : Notation.Dot "min_value" := {
    Notation.dot := @min_value;
  }.
  Global Instance Method_min_positive_value `{H : State.Trait} `(Trait)
    : Notation.Dot "min_positive_value" := {
    Notation.dot := @min_positive_value;
  }.
  Global Instance Method_epsilon `{H : State.Trait} `(Trait)
    : Notation.Dot "epsilon" := {
    Notation.dot := (axiom : M (H := H) Self);
  }.
  Global Instance Method_max_value `{H : State.Trait} `(Trait)
    : Notation.Dot "max_value" := {
    Notation.dot := @max_value;
  }.
  Global Instance Method_is_nan `{H : State.Trait} `(Trait)
    : Notation.Dot "is_nan" := {
    Notation.dot := @is_nan;
  }.
  Global Instance Method_is_infinite `{H : State.Trait} `(Trait)
    : Notation.Dot "is_infinite" := {
    Notation.dot := @is_infinite;
  }.
  Global Instance Method_is_finite `{H : State.Trait} `(Trait)
    : Notation.Dot "is_finite" := {
    Notation.dot := @is_finite;
  }.
  Global Instance Method_is_normal `{H : State.Trait} `(Trait)
    : Notation.Dot "is_normal" := {
    Notation.dot := @is_normal;
  }.
  Global Instance Method_is_subnormal `{H : State.Trait} `(Trait)
    : Notation.Dot "is_subnormal" := {
    Notation.dot (self : Self) := (axiom : M (H := H) bool);
  }.
  Global Instance Method_classify `{H : State.Trait} `(Trait)
    : Notation.Dot "classify" := {
    Notation.dot := @classify;
  }.
  Global Instance Method_floor `{H : State.Trait} `(Trait)
    : Notation.Dot "floor" := {
    Notation.dot := @floor;
  }.
  Global Instance Method_ceil `{H : State.Trait} `(Trait)
    : Notation.Dot "ceil" := {
    Notation.dot := @ceil;
  }.
  Global Instance Method_round `{H : State.Trait} `(Trait)
    : Notation.Dot "round" := {
    Notation.dot := @round;
  }.
  Global Instance Method_trunc `{H : State.Trait} `(Trait)
    : Notation.Dot "trunc" := {
    Notation.dot := @trunc;
  }.
  Global Instance Method_fract `{H : State.Trait} `(Trait)
    : Notation.Dot "fract" := {
    Notation.dot := @fract;
  }.
  Global Instance Method_abs `{H : State.Trait} `(Trait)
    : Notation.Dot "abs" := {
    Notation.dot := @abs;
  }.
  Global Instance Method_signum `{H : State.Trait} `(Trait)
    : Notation.Dot "signum" := {
    Notation.dot := @signum;
  }.
  Global Instance Method_is_sign_positive `{H : State.Trait} `(Trait)
    : Notation.Dot "is_sign_positive" := {
    Notation.dot := @is_sign_positive;
  }.
  Global Instance Method_is_sign_negative `{H : State.Trait} `(Trait)
    : Notation.Dot "is_sign_negative" := {
    Notation.dot := @is_sign_negative;
  }.
  Global Instance Method_mul_add `{H : State.Trait} `(Trait)
    : Notation.Dot "mul_add" := {
    Notation.dot := @mul_add;
  }.
  Global Instance Method_recip `{H : State.Trait} `(Trait)
    : Notation.Dot "recip" := {
    Notation.dot := @recip;
  }.
  Global Instance Method_powi `{H : State.Trait} `(Trait)
    : Notation.Dot "powi" := {
    Notation.dot := @powi;
  }.
  Global Instance Method_powf `{H : State.Trait} `(Trait)
    : Notation.Dot "powf" := {
    Notation.dot := @powf;
  }.
  Global Instance Method_sqrt `{H : State.Trait} `(Trait)
    : Notation.Dot "sqrt" := {
    Notation.dot := @sqrt;
  }.
  Global Instance Method_exp `{H : State.Trait} `(Trait)
    : Notation.Dot "exp" := {
    Notation.dot := @exp;
  }.
  Global Instance Method_exp2 `{H : State.Trait} `(Trait)
    : Notation.Dot "exp2" := {
    Notation.dot := @exp2;
  }.
  Global Instance Method_ln `{H : State.Trait} `(Trait) : Notation.Dot "ln" := {
    Notation.dot := @ln;
  }.
  Global Instance Method_log `{H : State.Trait} `(Trait)
    : Notation.Dot "log" := {
    Notation.dot := @log;
  }.
  Global Instance Method_log2 `{H : State.Trait} `(Trait)
    : Notation.Dot "log2" := {
    Notation.dot := @log2;
  }.
  Global Instance Method_log10 `{H : State.Trait} `(Trait)
    : Notation.Dot "log10" := {
    Notation.dot := @log10;
  }.
  Global Instance Method_to_degrees `{H : State.Trait} `(Trait)
    : Notation.Dot "to_degrees" := {
    Notation.dot (self : Self) := (axiom : M (H := H) Self);
  }.
  Global Instance Method_to_radians `{H : State.Trait} `(Trait)
    : Notation.Dot "to_radians" := {
    Notation.dot (self : Self) := (axiom : M (H := H) Self);
  }.
  Global Instance Method_max `{H : State.Trait} `(Trait)
    : Notation.Dot "max" := {
    Notation.dot := @max;
  }.
  Global Instance Method_min `{H : State.Trait} `(Trait)
    : Notation.Dot "min" := {
    Notation.dot := @min;
  }.
  Global Instance Method_abs_sub `{H : State.Trait} `(Trait)
    : Notation.Dot "abs_sub" := {
    Notation.dot := @abs_sub;
  }.
  Global Instance Method_cbrt `{H : State.Trait} `(Trait)
    : Notation.Dot "cbrt" := {
    Notation.dot := @cbrt;
  }.
  Global Instance Method_hypot `{H : State.Trait} `(Trait)
    : Notation.Dot "hypot" := {
    Notation.dot := @hypot;
  }.
  Global Instance Method_sin `{H : State.Trait} `(Trait)
    : Notation.Dot "sin" := {
    Notation.dot := @sin;
  }.
  Global Instance Method_cos `{H : State.Trait} `(Trait)
    : Notation.Dot "cos" := {
    Notation.dot := @cos;
  }.
  Global Instance Method_tan `{H : State.Trait} `(Trait)
    : Notation.Dot "tan" := {
    Notation.dot := @tan;
  }.
  Global Instance Method_asin `{H : State.Trait} `(Trait)
    : Notation.Dot "asin" := {
    Notation.dot := @asin;
  }.
  Global Instance Method_acos `{H : State.Trait} `(Trait)
    : Notation.Dot "acos" := {
    Notation.dot := @acos;
  }.
  Global Instance Method_atan `{H : State.Trait} `(Trait)
    : Notation.Dot "atan" := {
    Notation.dot := @atan;
  }.
  Global Instance Method_atan2 `{H : State.Trait} `(Trait)
    : Notation.Dot "atan2" := {
    Notation.dot := @atan2;
  }.
  Global Instance Method_sin_cos `{H : State.Trait} `(Trait)
    : Notation.Dot "sin_cos" := {
    Notation.dot := @sin_cos;
  }.
  Global Instance Method_exp_m1 `{H : State.Trait} `(Trait)
    : Notation.Dot "exp_m1" := {
    Notation.dot := @exp_m1;
  }.
  Global Instance Method_ln_1p `{H : State.Trait} `(Trait)
    : Notation.Dot "ln_1p" := {
    Notation.dot := @ln_1p;
  }.
  Global Instance Method_sinh `{H : State.Trait} `(Trait)
    : Notation.Dot "sinh" := {
    Notation.dot := @sinh;
  }.
  Global Instance Method_cosh `{H : State.Trait} `(Trait)
    : Notation.Dot "cosh" := {
    Notation.dot := @cosh;
  }.
  Global Instance Method_tanh `{H : State.Trait} `(Trait)
    : Notation.Dot "tanh" := {
    Notation.dot := @tanh;
  }.
  Global Instance Method_asinh `{H : State.Trait} `(Trait)
    : Notation.Dot "asinh" := {
    Notation.dot := @asinh;
  }.
  Global Instance Method_acosh `{H : State.Trait} `(Trait)
    : Notation.Dot "acosh" := {
    Notation.dot := @acosh;
  }.
  Global Instance Method_atanh `{H : State.Trait} `(Trait)
    : Notation.Dot "atanh" := {
    Notation.dot := @atanh;
  }.
  Global Instance Method_integer_decode `{H : State.Trait} `(Trait)
    : Notation.Dot "integer_decode" := {
    Notation.dot := @integer_decode;
  }.
  Global Instance Method_copysign `{H : State.Trait} `(Trait)
    : Notation.Dot "copysign" := {
    Notation.dot (self : Self) (sign : Self) := (axiom : M (H := H) Self);
  }.
End Float.

Module FloatConst.
  Class Trait (Self : Set) : Set := {
    E `{H : State.Trait} : (M (H := H) Self);
    FRAC_1_PI `{H : State.Trait} : (M (H := H) Self);
    FRAC_1_SQRT_2 `{H : State.Trait} : (M (H := H) Self);
    FRAC_2_PI `{H : State.Trait} : (M (H := H) Self);
    FRAC_2_SQRT_PI `{H : State.Trait} : (M (H := H) Self);
    FRAC_PI_2 `{H : State.Trait} : (M (H := H) Self);
    FRAC_PI_3 `{H : State.Trait} : (M (H := H) Self);
    FRAC_PI_4 `{H : State.Trait} : (M (H := H) Self);
    FRAC_PI_6 `{H : State.Trait} : (M (H := H) Self);
    FRAC_PI_8 `{H : State.Trait} : (M (H := H) Self);
    LN_10 `{H : State.Trait} : (M (H := H) Self);
    LN_2 `{H : State.Trait} : (M (H := H) Self);
    LOG10_E `{H : State.Trait} : (M (H := H) Self);
    LOG2_E `{H : State.Trait} : (M (H := H) Self);
    PI `{H : State.Trait} : (M (H := H) Self);
    SQRT_2 `{H : State.Trait} : (M (H := H) Self);
  }.
  
  Global Instance Method_E `{H : State.Trait} `(Trait) : Notation.Dot "E" := {
    Notation.dot := @E;
  }.
  Global Instance Method_FRAC_1_PI `{H : State.Trait} `(Trait)
    : Notation.Dot "FRAC_1_PI" := {
    Notation.dot := @FRAC_1_PI;
  }.
  Global Instance Method_FRAC_1_SQRT_2 `{H : State.Trait} `(Trait)
    : Notation.Dot "FRAC_1_SQRT_2" := {
    Notation.dot := @FRAC_1_SQRT_2;
  }.
  Global Instance Method_FRAC_2_PI `{H : State.Trait} `(Trait)
    : Notation.Dot "FRAC_2_PI" := {
    Notation.dot := @FRAC_2_PI;
  }.
  Global Instance Method_FRAC_2_SQRT_PI `{H : State.Trait} `(Trait)
    : Notation.Dot "FRAC_2_SQRT_PI" := {
    Notation.dot := @FRAC_2_SQRT_PI;
  }.
  Global Instance Method_FRAC_PI_2 `{H : State.Trait} `(Trait)
    : Notation.Dot "FRAC_PI_2" := {
    Notation.dot := @FRAC_PI_2;
  }.
  Global Instance Method_FRAC_PI_3 `{H : State.Trait} `(Trait)
    : Notation.Dot "FRAC_PI_3" := {
    Notation.dot := @FRAC_PI_3;
  }.
  Global Instance Method_FRAC_PI_4 `{H : State.Trait} `(Trait)
    : Notation.Dot "FRAC_PI_4" := {
    Notation.dot := @FRAC_PI_4;
  }.
  Global Instance Method_FRAC_PI_6 `{H : State.Trait} `(Trait)
    : Notation.Dot "FRAC_PI_6" := {
    Notation.dot := @FRAC_PI_6;
  }.
  Global Instance Method_FRAC_PI_8 `{H : State.Trait} `(Trait)
    : Notation.Dot "FRAC_PI_8" := {
    Notation.dot := @FRAC_PI_8;
  }.
  Global Instance Method_LN_10 `{H : State.Trait} `(Trait)
    : Notation.Dot "LN_10" := {
    Notation.dot := @LN_10;
  }.
  Global Instance Method_LN_2 `{H : State.Trait} `(Trait)
    : Notation.Dot "LN_2" := {
    Notation.dot := @LN_2;
  }.
  Global Instance Method_LOG10_E `{H : State.Trait} `(Trait)
    : Notation.Dot "LOG10_E" := {
    Notation.dot := @LOG10_E;
  }.
  Global Instance Method_LOG2_E `{H : State.Trait} `(Trait)
    : Notation.Dot "LOG2_E" := {
    Notation.dot := @LOG2_E;
  }.
  Global Instance Method_PI `{H : State.Trait} `(Trait) : Notation.Dot "PI" := {
    Notation.dot := @PI;
  }.
  Global Instance Method_SQRT_2 `{H : State.Trait} `(Trait)
    : Notation.Dot "SQRT_2" := {
    Notation.dot := @SQRT_2;
  }.
  Global Instance Method_TAU `{H : State.Trait} `(Trait)
    : Notation.Dot "TAU" := {
    Notation.dot`{core.marker.Sized.Trait Self}
        `{core.ops.arith.Add.Trait Self (Rhs := (Some Self))}
         :=
      (axiom : M (H := H) Self);
  }.
  Global Instance Method_LOG10_2 `{H : State.Trait} `(Trait)
    : Notation.Dot "LOG10_2" := {
    Notation.dot`{core.marker.Sized.Trait Self}
        `{core.ops.arith.Div.Trait Self (Rhs := (Some Self))}
         :=
      (axiom : M (H := H) Self);
  }.
  Global Instance Method_LOG2_10 `{H : State.Trait} `(Trait)
    : Notation.Dot "LOG2_10" := {
    Notation.dot`{core.marker.Sized.Trait Self}
        `{core.ops.arith.Div.Trait Self (Rhs := (Some Self))}
         :=
      (axiom : M (H := H) Self);
  }.
End FloatConst.
*)
Module identities.
  Module Zero.
    Class Trait
        (Self : Set)
          `{core.marker.Sized.Trait Self}
          `{core.ops.arith.Add.Trait Self (Rhs := (Some Self))} :
        Set := {
      zero `{H : State.Trait} : (M (H := H) Self);
      is_zero `{H : State.Trait} : (ref Self) -> (M (H := H) bool);
    }.
    
    Global Instance Method_zero `{H : State.Trait} `(Trait)
      : Notation.Dot "zero" := {
      Notation.dot := @zero;
    }.
    Global Instance Method_set_zero `{H : State.Trait} `(Trait)
      : Notation.Dot "set_zero" := {
      Notation.dot (self : mut_ref Self) := (axiom : M (H := H) unit);
    }.
    Global Instance Method_is_zero `{H : State.Trait} `(Trait)
      : Notation.Dot "is_zero" := {
      Notation.dot := @is_zero;
    }.
  End Zero.
  
  Module One.
    Class Trait
        (Self : Set)
          `{core.marker.Sized.Trait Self}
          `{core.ops.arith.Mul.Trait Self (Rhs := (Some Self))} :
        Set := {
      one `{H : State.Trait} : (M (H := H) Self);
    }.
    
    Global Instance Method_one `{H : State.Trait} `(Trait)
      : Notation.Dot "one" := {
      Notation.dot := @one;
    }.
    Global Instance Method_set_one `{H : State.Trait} `(Trait)
      : Notation.Dot "set_one" := {
      Notation.dot (self : mut_ref Self) := (axiom : M (H := H) unit);
    }.
    Global Instance Method_is_one `{H : State.Trait} `(Trait)
      : Notation.Dot "is_one" := {
      Notation.dot`{core.cmp.PartialEq.Trait Self (Rhs := None)} 
          (self : ref Self) :=
        (axiom : M (H := H) bool);
    }.
  End One.
  
  Parameter zero : forall `{H : State.Trait},
      forall
      {T : Set},
      forall `{num_traits.identities.Zero.Trait T}, M (H := H) T.
  
  Parameter one : forall `{H : State.Trait},
      forall
      {T : Set},
      forall `{num_traits.identities.One.Trait T}, M (H := H) T.
End identities.
(*
Module Zero.
  Class Trait
      (Self : Set)
        `{core.marker.Sized.Trait Self}
        `{core.ops.arith.Add.Trait Self (Rhs := (Some Self))} :
      Set := {
    zero `{H : State.Trait} : (M (H := H) Self);
    is_zero `{H : State.Trait} : (ref Self) -> (M (H := H) bool);
  }.
  
  Global Instance Method_zero `{H : State.Trait} `(Trait)
    : Notation.Dot "zero" := {
    Notation.dot := @zero;
  }.
  Global Instance Method_set_zero `{H : State.Trait} `(Trait)
    : Notation.Dot "set_zero" := {
    Notation.dot (self : mut_ref Self) := (axiom : M (H := H) unit);
  }.
  Global Instance Method_is_zero `{H : State.Trait} `(Trait)
    : Notation.Dot "is_zero" := {
    Notation.dot := @is_zero;
  }.
End Zero.

Module One.
  Class Trait
      (Self : Set)
        `{core.marker.Sized.Trait Self}
        `{core.ops.arith.Mul.Trait Self (Rhs := (Some Self))} :
      Set := {
    one `{H : State.Trait} : (M (H := H) Self);
  }.
  
  Global Instance Method_one `{H : State.Trait} `(Trait)
    : Notation.Dot "one" := {
    Notation.dot := @one;
  }.
  Global Instance Method_set_one `{H : State.Trait} `(Trait)
    : Notation.Dot "set_one" := {
    Notation.dot (self : mut_ref Self) := (axiom : M (H := H) unit);
  }.
  Global Instance Method_is_one `{H : State.Trait} `(Trait)
    : Notation.Dot "is_one" := {
    Notation.dot`{core.cmp.PartialEq.Trait Self (Rhs := None)} 
        (self : ref Self) :=
      (axiom : M (H := H) bool);
  }.
End One.

Parameter zero : forall `{H : State.Trait},
    forall
    {T : Set},
    forall `{num_traits.identities.Zero.Trait T}, M (H := H) T.

Parameter one : forall `{H : State.Trait},
    forall
    {T : Set},
    forall `{num_traits.identities.One.Trait T}, M (H := H) T.

Module int.
  Module PrimInt.
    Class Trait
        (Self : Set)
          `{core.marker.Sized.Trait Self}
          `{core.marker.Copy.Trait Self}
          `{num_traits.Num.Trait Self}
          `{num_traits.cast.NumCast.Trait Self}
          `{num_traits.bounds.Bounded.Trait Self}
          `{core.cmp.PartialOrd.Trait Self (Rhs := None)}
          `{core.cmp.Ord.Trait Self}
          `{core.cmp.Eq.Trait Self}
          `{core.ops.bit.Not.Trait Self}
          `{core.ops.bit.BitAnd.Trait Self (Rhs := None)}
          `{core.ops.bit.BitOr.Trait Self (Rhs := None)}
          `{core.ops.bit.BitXor.Trait Self (Rhs := None)}
          `{core.ops.bit.Shl.Trait Self (Rhs := (Some usize))}
          `{core.ops.bit.Shr.Trait Self (Rhs := (Some usize))}
          `{num_traits.ops.checked.CheckedAdd.Trait Self}
          `{num_traits.ops.checked.CheckedSub.Trait Self}
          `{num_traits.ops.checked.CheckedMul.Trait Self}
          `{num_traits.ops.checked.CheckedDiv.Trait Self}
          `{num_traits.ops.saturating.Saturating.Trait Self} :
        Set := {
      count_ones `{H : State.Trait} : Self -> (M (H := H) u32);
      count_zeros `{H : State.Trait} : Self -> (M (H := H) u32);
      leading_zeros `{H : State.Trait} : Self -> (M (H := H) u32);
      trailing_zeros `{H : State.Trait} : Self -> (M (H := H) u32);
      rotate_left `{H : State.Trait} : Self -> u32 -> (M (H := H) Self);
      rotate_right `{H : State.Trait} : Self -> u32 -> (M (H := H) Self);
      signed_shl `{H : State.Trait} : Self -> u32 -> (M (H := H) Self);
      signed_shr `{H : State.Trait} : Self -> u32 -> (M (H := H) Self);
      unsigned_shl `{H : State.Trait} : Self -> u32 -> (M (H := H) Self);
      unsigned_shr `{H : State.Trait} : Self -> u32 -> (M (H := H) Self);
      swap_bytes `{H : State.Trait} : Self -> (M (H := H) Self);
      from_be `{H : State.Trait} : Self -> (M (H := H) Self);
      from_le `{H : State.Trait} : Self -> (M (H := H) Self);
      to_be `{H : State.Trait} : Self -> (M (H := H) Self);
      to_le `{H : State.Trait} : Self -> (M (H := H) Self);
      pow `{H : State.Trait} : Self -> u32 -> (M (H := H) Self);
    }.
    
    Global Instance Method_count_ones `{H : State.Trait} `(Trait)
      : Notation.Dot "count_ones" := {
      Notation.dot := @count_ones;
    }.
    Global Instance Method_count_zeros `{H : State.Trait} `(Trait)
      : Notation.Dot "count_zeros" := {
      Notation.dot := @count_zeros;
    }.
    Global Instance Method_leading_ones `{H : State.Trait} `(Trait)
      : Notation.Dot "leading_ones" := {
      Notation.dot (self : Self) := (axiom : M (H := H) u32);
    }.
    Global Instance Method_leading_zeros `{H : State.Trait} `(Trait)
      : Notation.Dot "leading_zeros" := {
      Notation.dot := @leading_zeros;
    }.
    Global Instance Method_trailing_ones `{H : State.Trait} `(Trait)
      : Notation.Dot "trailing_ones" := {
      Notation.dot (self : Self) := (axiom : M (H := H) u32);
    }.
    Global Instance Method_trailing_zeros `{H : State.Trait} `(Trait)
      : Notation.Dot "trailing_zeros" := {
      Notation.dot := @trailing_zeros;
    }.
    Global Instance Method_rotate_left `{H : State.Trait} `(Trait)
      : Notation.Dot "rotate_left" := {
      Notation.dot := @rotate_left;
    }.
    Global Instance Method_rotate_right `{H : State.Trait} `(Trait)
      : Notation.Dot "rotate_right" := {
      Notation.dot := @rotate_right;
    }.
    Global Instance Method_signed_shl `{H : State.Trait} `(Trait)
      : Notation.Dot "signed_shl" := {
      Notation.dot := @signed_shl;
    }.
    Global Instance Method_signed_shr `{H : State.Trait} `(Trait)
      : Notation.Dot "signed_shr" := {
      Notation.dot := @signed_shr;
    }.
    Global Instance Method_unsigned_shl `{H : State.Trait} `(Trait)
      : Notation.Dot "unsigned_shl" := {
      Notation.dot := @unsigned_shl;
    }.
    Global Instance Method_unsigned_shr `{H : State.Trait} `(Trait)
      : Notation.Dot "unsigned_shr" := {
      Notation.dot := @unsigned_shr;
    }.
    Global Instance Method_swap_bytes `{H : State.Trait} `(Trait)
      : Notation.Dot "swap_bytes" := {
      Notation.dot := @swap_bytes;
    }.
    Global Instance Method_reverse_bits `{H : State.Trait} `(Trait)
      : Notation.Dot "reverse_bits" := {
      Notation.dot (self : Self) := (axiom : M (H := H) Self);
    }.
    Global Instance Method_from_be `{H : State.Trait} `(Trait)
      : Notation.Dot "from_be" := {
      Notation.dot := @from_be;
    }.
    Global Instance Method_from_le `{H : State.Trait} `(Trait)
      : Notation.Dot "from_le" := {
      Notation.dot := @from_le;
    }.
    Global Instance Method_to_be `{H : State.Trait} `(Trait)
      : Notation.Dot "to_be" := {
      Notation.dot := @to_be;
    }.
    Global Instance Method_to_le `{H : State.Trait} `(Trait)
      : Notation.Dot "to_le" := {
      Notation.dot := @to_le;
    }.
    Global Instance Method_pow `{H : State.Trait} `(Trait)
      : Notation.Dot "pow" := {
      Notation.dot := @pow;
    }.
  End PrimInt.
End int.

Module PrimInt.
  Class Trait
      (Self : Set)
        `{core.marker.Sized.Trait Self}
        `{core.marker.Copy.Trait Self}
        `{num_traits.Num.Trait Self}
        `{num_traits.cast.NumCast.Trait Self}
        `{num_traits.bounds.Bounded.Trait Self}
        `{core.cmp.PartialOrd.Trait Self (Rhs := None)}
        `{core.cmp.Ord.Trait Self}
        `{core.cmp.Eq.Trait Self}
        `{core.ops.bit.Not.Trait Self}
        `{core.ops.bit.BitAnd.Trait Self (Rhs := None)}
        `{core.ops.bit.BitOr.Trait Self (Rhs := None)}
        `{core.ops.bit.BitXor.Trait Self (Rhs := None)}
        `{core.ops.bit.Shl.Trait Self (Rhs := (Some usize))}
        `{core.ops.bit.Shr.Trait Self (Rhs := (Some usize))}
        `{num_traits.ops.checked.CheckedAdd.Trait Self}
        `{num_traits.ops.checked.CheckedSub.Trait Self}
        `{num_traits.ops.checked.CheckedMul.Trait Self}
        `{num_traits.ops.checked.CheckedDiv.Trait Self}
        `{num_traits.ops.saturating.Saturating.Trait Self} :
      Set := {
    count_ones `{H : State.Trait} : Self -> (M (H := H) u32);
    count_zeros `{H : State.Trait} : Self -> (M (H := H) u32);
    leading_zeros `{H : State.Trait} : Self -> (M (H := H) u32);
    trailing_zeros `{H : State.Trait} : Self -> (M (H := H) u32);
    rotate_left `{H : State.Trait} : Self -> u32 -> (M (H := H) Self);
    rotate_right `{H : State.Trait} : Self -> u32 -> (M (H := H) Self);
    signed_shl `{H : State.Trait} : Self -> u32 -> (M (H := H) Self);
    signed_shr `{H : State.Trait} : Self -> u32 -> (M (H := H) Self);
    unsigned_shl `{H : State.Trait} : Self -> u32 -> (M (H := H) Self);
    unsigned_shr `{H : State.Trait} : Self -> u32 -> (M (H := H) Self);
    swap_bytes `{H : State.Trait} : Self -> (M (H := H) Self);
    from_be `{H : State.Trait} : Self -> (M (H := H) Self);
    from_le `{H : State.Trait} : Self -> (M (H := H) Self);
    to_be `{H : State.Trait} : Self -> (M (H := H) Self);
    to_le `{H : State.Trait} : Self -> (M (H := H) Self);
    pow `{H : State.Trait} : Self -> u32 -> (M (H := H) Self);
  }.
  
  Global Instance Method_count_ones `{H : State.Trait} `(Trait)
    : Notation.Dot "count_ones" := {
    Notation.dot := @count_ones;
  }.
  Global Instance Method_count_zeros `{H : State.Trait} `(Trait)
    : Notation.Dot "count_zeros" := {
    Notation.dot := @count_zeros;
  }.
  Global Instance Method_leading_ones `{H : State.Trait} `(Trait)
    : Notation.Dot "leading_ones" := {
    Notation.dot (self : Self) := (axiom : M (H := H) u32);
  }.
  Global Instance Method_leading_zeros `{H : State.Trait} `(Trait)
    : Notation.Dot "leading_zeros" := {
    Notation.dot := @leading_zeros;
  }.
  Global Instance Method_trailing_ones `{H : State.Trait} `(Trait)
    : Notation.Dot "trailing_ones" := {
    Notation.dot (self : Self) := (axiom : M (H := H) u32);
  }.
  Global Instance Method_trailing_zeros `{H : State.Trait} `(Trait)
    : Notation.Dot "trailing_zeros" := {
    Notation.dot := @trailing_zeros;
  }.
  Global Instance Method_rotate_left `{H : State.Trait} `(Trait)
    : Notation.Dot "rotate_left" := {
    Notation.dot := @rotate_left;
  }.
  Global Instance Method_rotate_right `{H : State.Trait} `(Trait)
    : Notation.Dot "rotate_right" := {
    Notation.dot := @rotate_right;
  }.
  Global Instance Method_signed_shl `{H : State.Trait} `(Trait)
    : Notation.Dot "signed_shl" := {
    Notation.dot := @signed_shl;
  }.
  Global Instance Method_signed_shr `{H : State.Trait} `(Trait)
    : Notation.Dot "signed_shr" := {
    Notation.dot := @signed_shr;
  }.
  Global Instance Method_unsigned_shl `{H : State.Trait} `(Trait)
    : Notation.Dot "unsigned_shl" := {
    Notation.dot := @unsigned_shl;
  }.
  Global Instance Method_unsigned_shr `{H : State.Trait} `(Trait)
    : Notation.Dot "unsigned_shr" := {
    Notation.dot := @unsigned_shr;
  }.
  Global Instance Method_swap_bytes `{H : State.Trait} `(Trait)
    : Notation.Dot "swap_bytes" := {
    Notation.dot := @swap_bytes;
  }.
  Global Instance Method_reverse_bits `{H : State.Trait} `(Trait)
    : Notation.Dot "reverse_bits" := {
    Notation.dot (self : Self) := (axiom : M (H := H) Self);
  }.
  Global Instance Method_from_be `{H : State.Trait} `(Trait)
    : Notation.Dot "from_be" := {
    Notation.dot := @from_be;
  }.
  Global Instance Method_from_le `{H : State.Trait} `(Trait)
    : Notation.Dot "from_le" := {
    Notation.dot := @from_le;
  }.
  Global Instance Method_to_be `{H : State.Trait} `(Trait)
    : Notation.Dot "to_be" := {
    Notation.dot := @to_be;
  }.
  Global Instance Method_to_le `{H : State.Trait} `(Trait)
    : Notation.Dot "to_le" := {
    Notation.dot := @to_le;
  }.
  Global Instance Method_pow `{H : State.Trait} `(Trait)
    : Notation.Dot "pow" := {
    Notation.dot := @pow;
  }.
End PrimInt.
*)
Module ops.
  (*
  Module bytes.
    Module NumBytes.
      Unset Primitive Projections.
      Class Trait
          (Self : Set)
            `{core.fmt.Debug.Trait Self}
            `{core.convert.AsRef.Trait Self (T := Slice u8)}
            `{core.convert.AsMut.Trait Self (T := Slice u8)}
            `{core.cmp.PartialEq.Trait Self (Rhs := None)}
            `{core.cmp.Eq.Trait Self}
            `{core.cmp.PartialOrd.Trait Self (Rhs := None)}
            `{core.cmp.Ord.Trait Self}
            `{core.hash.Hash.Trait Self}
            `{core.borrow.Borrow.Trait Self (Borrowed := Slice u8)}
            `{core.borrow.BorrowMut.Trait Self (Borrowed := Slice u8)} :
          Set := {
      }.
      Global Set Primitive Projections.
    End NumBytes.
    
    Module ToBytes.
      Class Trait
          (Self : Set)
          {Bytes : Set}
          `{num_traits.ops.bytes.NumBytes.Trait Bytes} :
          Set := {
        Bytes := Bytes;
        to_be_bytes `{H : State.Trait} : (ref Self) -> (M (H := H) Bytes);
        to_le_bytes `{H : State.Trait} : (ref Self) -> (M (H := H) Bytes);
      }.
      
      Global Instance
          Method_Bytes
          `{H : State.Trait}
          {Bytes}
          `(Trait
          (Bytes := Bytes))
        : Notation.DoubleColonType Self "Bytes" := {
        Notation.double_colon_type := Bytes;
      }.
      Global Instance Method_to_be_bytes `{H : State.Trait} `(Trait)
        : Notation.Dot "to_be_bytes" := {
        Notation.dot := @to_be_bytes;
      }.
      Global Instance Method_to_le_bytes `{H : State.Trait} `(Trait)
        : Notation.Dot "to_le_bytes" := {
        Notation.dot := @to_le_bytes;
      }.
      Global Instance Method_to_ne_bytes `{H : State.Trait} `(Trait)
        : Notation.Dot "to_ne_bytes" := {
        Notation.dot (self : ref Self) := (axiom : M (H := H) Bytes);
      }.
    End ToBytes.
    
    Module FromBytes.
      Class Trait
          (Self : Set) `{core.marker.Sized.Trait Self}
          {Bytes : Set}
          `{num_traits.ops.bytes.NumBytes.Trait Bytes}
          `{core.marker.Sized.Trait Bytes} :
          Set := {
        Bytes := Bytes;
        from_be_bytes `{H : State.Trait} : (ref Bytes) -> (M (H := H) Self);
        from_le_bytes `{H : State.Trait} : (ref Bytes) -> (M (H := H) Self);
      }.
      
      Global Instance
          Method_Bytes
          `{H : State.Trait}
          {Bytes}
          `(Trait
          (Bytes := Bytes))
        : Notation.DoubleColonType Self "Bytes" := {
        Notation.double_colon_type := Bytes;
      }.
      Global Instance Method_from_be_bytes `{H : State.Trait} `(Trait)
        : Notation.Dot "from_be_bytes" := {
        Notation.dot := @from_be_bytes;
      }.
      Global Instance Method_from_le_bytes `{H : State.Trait} `(Trait)
        : Notation.Dot "from_le_bytes" := {
        Notation.dot := @from_le_bytes;
      }.
      Global Instance Method_from_ne_bytes `{H : State.Trait} `(Trait)
        : Notation.Dot "from_ne_bytes" := {
        Notation.dot (bytes : ref Bytes) := (axiom : M (H := H) Self);
      }.
    End FromBytes.
  End bytes.
  *)
  Module checked.
    Module CheckedAdd.
      Class Trait
          (Self : Set)
            `{core.marker.Sized.Trait Self}
            `{core.ops.arith.Add.Trait Self (Rhs := (Some Self))} :
          Set := {
        checked_add
          `{H : State.Trait}
          :
          (ref Self) -> (ref Self) -> (M (H := H) (core.option.Option Self));
      }.
      
      Global Instance Method_checked_add `{H : State.Trait} `(Trait)
        : Notation.Dot "checked_add" := {
        Notation.dot := @checked_add;
      }.
    End CheckedAdd.
    
    Module CheckedSub.
      Class Trait
          (Self : Set)
            `{core.marker.Sized.Trait Self}
            `{core.ops.arith.Sub.Trait Self (Rhs := (Some Self))} :
          Set := {
        checked_sub
          `{H : State.Trait}
          :
          (ref Self) -> (ref Self) -> (M (H := H) (core.option.Option Self));
      }.
      
      Global Instance Method_checked_sub `{H : State.Trait} `(Trait)
        : Notation.Dot "checked_sub" := {
        Notation.dot := @checked_sub;
      }.
    End CheckedSub.
    
    Module CheckedMul.
      Class Trait
          (Self : Set)
            `{core.marker.Sized.Trait Self}
            `{core.ops.arith.Mul.Trait Self (Rhs := (Some Self))} :
          Set := {
        checked_mul
          `{H : State.Trait}
          :
          (ref Self) -> (ref Self) -> (M (H := H) (core.option.Option Self));
      }.
      
      Global Instance Method_checked_mul `{H : State.Trait} `(Trait)
        : Notation.Dot "checked_mul" := {
        Notation.dot := @checked_mul;
      }.
    End CheckedMul.
    
    Module CheckedDiv.
      Class Trait
          (Self : Set)
            `{core.marker.Sized.Trait Self}
            `{core.ops.arith.Div.Trait Self (Rhs := (Some Self))} :
          Set := {
        checked_div
          `{H : State.Trait}
          :
          (ref Self) -> (ref Self) -> (M (H := H) (core.option.Option Self));
      }.
      
      Global Instance Method_checked_div `{H : State.Trait} `(Trait)
        : Notation.Dot "checked_div" := {
        Notation.dot := @checked_div;
      }.
    End CheckedDiv.
    
    Module CheckedRem.
      Class Trait
          (Self : Set)
            `{core.marker.Sized.Trait Self}
            `{core.ops.arith.Rem.Trait Self (Rhs := (Some Self))} :
          Set := {
        checked_rem
          `{H : State.Trait}
          :
          (ref Self) -> (ref Self) -> (M (H := H) (core.option.Option Self));
      }.
      
      Global Instance Method_checked_rem `{H : State.Trait} `(Trait)
        : Notation.Dot "checked_rem" := {
        Notation.dot := @checked_rem;
      }.
    End CheckedRem.
    
    Module CheckedNeg.
      Class Trait (Self : Set) `{core.marker.Sized.Trait Self} : Set := {
        checked_neg
          `{H : State.Trait}
          :
          (ref Self) -> (M (H := H) (core.option.Option Self));
      }.
      
      Global Instance Method_checked_neg `{H : State.Trait} `(Trait)
        : Notation.Dot "checked_neg" := {
        Notation.dot := @checked_neg;
      }.
    End CheckedNeg.
    (*
    Module CheckedShl.
      Class Trait
          (Self : Set)
            `{core.marker.Sized.Trait Self}
            `{core.ops.bit.Shl.Trait Self (Rhs := (Some u32))} :
          Set := {
        checked_shl
          `{H : State.Trait}
          :
          (ref Self) -> u32 -> (M (H := H) (core.option.Option Self));
      }.
      
      Global Instance Method_checked_shl `{H : State.Trait} `(Trait)
        : Notation.Dot "checked_shl" := {
        Notation.dot := @checked_shl;
      }.
    End CheckedShl.
    
    Module CheckedShr.
      Class Trait
          (Self : Set)
            `{core.marker.Sized.Trait Self}
            `{core.ops.bit.Shr.Trait Self (Rhs := (Some u32))} :
          Set := {
        checked_shr
          `{H : State.Trait}
          :
          (ref Self) -> u32 -> (M (H := H) (core.option.Option Self));
      }.
      
      Global Instance Method_checked_shr `{H : State.Trait} `(Trait)
        : Notation.Dot "checked_shr" := {
        Notation.dot := @checked_shr;
      }.
    End CheckedShr.
    *)
  End checked.
  (*
  Module euclid.
    Module Euclid.
      Class Trait
          (Self : Set)
            `{core.marker.Sized.Trait Self}
            `{core.ops.arith.Div.Trait Self (Rhs := (Some Self))}
            `{core.ops.arith.Rem.Trait Self (Rhs := (Some Self))} :
          Set := {
        div_euclid
          `{H : State.Trait}
          :
          (ref Self) -> (ref Self) -> (M (H := H) Self);
        rem_euclid
          `{H : State.Trait}
          :
          (ref Self) -> (ref Self) -> (M (H := H) Self);
      }.
      
      Global Instance Method_div_euclid `{H : State.Trait} `(Trait)
        : Notation.Dot "div_euclid" := {
        Notation.dot := @div_euclid;
      }.
      Global Instance Method_rem_euclid `{H : State.Trait} `(Trait)
        : Notation.Dot "rem_euclid" := {
        Notation.dot := @rem_euclid;
      }.
    End Euclid.
    
    Module CheckedEuclid.
      Class Trait
          (Self : Set) `{num_traits.ops.euclid.Euclid.Trait Self} :
          Set := {
        checked_div_euclid
          `{H : State.Trait}
          :
          (ref Self) -> (ref Self) -> (M (H := H) (core.option.Option Self));
        checked_rem_euclid
          `{H : State.Trait}
          :
          (ref Self) -> (ref Self) -> (M (H := H) (core.option.Option Self));
      }.
      
      Global Instance Method_checked_div_euclid `{H : State.Trait} `(Trait)
        : Notation.Dot "checked_div_euclid" := {
        Notation.dot := @checked_div_euclid;
      }.
      Global Instance Method_checked_rem_euclid `{H : State.Trait} `(Trait)
        : Notation.Dot "checked_rem_euclid" := {
        Notation.dot := @checked_rem_euclid;
      }.
    End CheckedEuclid.
  End euclid.
  
  Module inv.
    Module Inv.
      Class Trait (Self : Set) {Output : Set} : Set := {
        Output := Output;
        inv `{H : State.Trait} : Self -> (M (H := H) Output);
      }.
      
      Global Instance
          Method_Output
          `{H : State.Trait}
          {Output}
          `(Trait
          (Output := Output))
        : Notation.DoubleColonType Self "Output" := {
        Notation.double_colon_type := Output;
      }.
      Global Instance Method_inv `{H : State.Trait} `(Trait)
        : Notation.Dot "inv" := {
        Notation.dot := @inv;
      }.
    End Inv.
  End inv.
  
  Module mul_add.
    Module MulAdd.
      Class Trait
          (Self : Set) {(* TODO *) A (* TODO *) B : Set}
          {Output : Set} :
          Set := {
        Output := Output;
        mul_add `{H : State.Trait} : Self -> A -> B -> (M (H := H) Output);
      }.
      
      Global Instance
          Method_Output
          `{H : State.Trait}
          {Output}
          `(Trait
          (Output := Output))
        : Notation.DoubleColonType Self "Output" := {
        Notation.double_colon_type := Output;
      }.
      Global Instance Method_mul_add `{H : State.Trait} `(Trait)
        : Notation.Dot "mul_add" := {
        Notation.dot := @mul_add;
      }.
    End MulAdd.
    
    Module MulAddAssign.
      Class Trait (Self : Set) {(* TODO *) A (* TODO *) B : Set} : Set := {
        mul_add_assign
          `{H : State.Trait}
          :
          (mut_ref Self) -> A -> B -> (M (H := H) unit);
      }.
      
      Global Instance Method_mul_add_assign `{H : State.Trait} `(Trait)
        : Notation.Dot "mul_add_assign" := {
        Notation.dot := @mul_add_assign;
      }.
    End MulAddAssign.
  End mul_add.
  
  Module overflowing.
    Module OverflowingAdd.
      Class Trait
          (Self : Set)
            `{core.marker.Sized.Trait Self}
            `{core.ops.arith.Add.Trait Self (Rhs := (Some Self))} :
          Set := {
        overflowing_add
          `{H : State.Trait}
          :
          (ref Self) -> (ref Self) -> (M (H := H) (Self * bool));
      }.
      
      Global Instance Method_overflowing_add `{H : State.Trait} `(Trait)
        : Notation.Dot "overflowing_add" := {
        Notation.dot := @overflowing_add;
      }.
    End OverflowingAdd.
    
    Module OverflowingSub.
      Class Trait
          (Self : Set)
            `{core.marker.Sized.Trait Self}
            `{core.ops.arith.Sub.Trait Self (Rhs := (Some Self))} :
          Set := {
        overflowing_sub
          `{H : State.Trait}
          :
          (ref Self) -> (ref Self) -> (M (H := H) (Self * bool));
      }.
      
      Global Instance Method_overflowing_sub `{H : State.Trait} `(Trait)
        : Notation.Dot "overflowing_sub" := {
        Notation.dot := @overflowing_sub;
      }.
    End OverflowingSub.
    
    Module OverflowingMul.
      Class Trait
          (Self : Set)
            `{core.marker.Sized.Trait Self}
            `{core.ops.arith.Mul.Trait Self (Rhs := (Some Self))} :
          Set := {
        overflowing_mul
          `{H : State.Trait}
          :
          (ref Self) -> (ref Self) -> (M (H := H) (Self * bool));
      }.
      
      Global Instance Method_overflowing_mul `{H : State.Trait} `(Trait)
        : Notation.Dot "overflowing_mul" := {
        Notation.dot := @overflowing_mul;
      }.
    End OverflowingMul.
  End overflowing.
  
  Module saturating.
    Module Saturating.
      Class Trait (Self : Set) : Set := {
        saturating_add `{H : State.Trait} : Self -> Self -> (M (H := H) Self);
        saturating_sub `{H : State.Trait} : Self -> Self -> (M (H := H) Self);
      }.
      
      Global Instance Method_saturating_add `{H : State.Trait} `(Trait)
        : Notation.Dot "saturating_add" := {
        Notation.dot := @saturating_add;
      }.
      Global Instance Method_saturating_sub `{H : State.Trait} `(Trait)
        : Notation.Dot "saturating_sub" := {
        Notation.dot := @saturating_sub;
      }.
    End Saturating.
    
    Module SaturatingAdd.
      Class Trait
          (Self : Set)
            `{core.marker.Sized.Trait Self}
            `{core.ops.arith.Add.Trait Self (Rhs := (Some Self))} :
          Set := {
        saturating_add
          `{H : State.Trait}
          :
          (ref Self) -> (ref Self) -> (M (H := H) Self);
      }.
      
      Global Instance Method_saturating_add `{H : State.Trait} `(Trait)
        : Notation.Dot "saturating_add" := {
        Notation.dot := @saturating_add;
      }.
    End SaturatingAdd.
    
    Module SaturatingSub.
      Class Trait
          (Self : Set)
            `{core.marker.Sized.Trait Self}
            `{core.ops.arith.Sub.Trait Self (Rhs := (Some Self))} :
          Set := {
        saturating_sub
          `{H : State.Trait}
          :
          (ref Self) -> (ref Self) -> (M (H := H) Self);
      }.
      
      Global Instance Method_saturating_sub `{H : State.Trait} `(Trait)
        : Notation.Dot "saturating_sub" := {
        Notation.dot := @saturating_sub;
      }.
    End SaturatingSub.
    
    Module SaturatingMul.
      Class Trait
          (Self : Set)
            `{core.marker.Sized.Trait Self}
            `{core.ops.arith.Mul.Trait Self (Rhs := (Some Self))} :
          Set := {
        saturating_mul
          `{H : State.Trait}
          :
          (ref Self) -> (ref Self) -> (M (H := H) Self);
      }.
      
      Global Instance Method_saturating_mul `{H : State.Trait} `(Trait)
        : Notation.Dot "saturating_mul" := {
        Notation.dot := @saturating_mul;
      }.
    End SaturatingMul.
  End saturating.
  
  Module wrapping.
    Module WrappingAdd.
      Class Trait
          (Self : Set)
            `{core.marker.Sized.Trait Self}
            `{core.ops.arith.Add.Trait Self (Rhs := (Some Self))} :
          Set := {
        wrapping_add
          `{H : State.Trait}
          :
          (ref Self) -> (ref Self) -> (M (H := H) Self);
      }.
      
      Global Instance Method_wrapping_add `{H : State.Trait} `(Trait)
        : Notation.Dot "wrapping_add" := {
        Notation.dot := @wrapping_add;
      }.
    End WrappingAdd.
    
    Module WrappingSub.
      Class Trait
          (Self : Set)
            `{core.marker.Sized.Trait Self}
            `{core.ops.arith.Sub.Trait Self (Rhs := (Some Self))} :
          Set := {
        wrapping_sub
          `{H : State.Trait}
          :
          (ref Self) -> (ref Self) -> (M (H := H) Self);
      }.
      
      Global Instance Method_wrapping_sub `{H : State.Trait} `(Trait)
        : Notation.Dot "wrapping_sub" := {
        Notation.dot := @wrapping_sub;
      }.
    End WrappingSub.
    
    Module WrappingMul.
      Class Trait
          (Self : Set)
            `{core.marker.Sized.Trait Self}
            `{core.ops.arith.Mul.Trait Self (Rhs := (Some Self))} :
          Set := {
        wrapping_mul
          `{H : State.Trait}
          :
          (ref Self) -> (ref Self) -> (M (H := H) Self);
      }.
      
      Global Instance Method_wrapping_mul `{H : State.Trait} `(Trait)
        : Notation.Dot "wrapping_mul" := {
        Notation.dot := @wrapping_mul;
      }.
    End WrappingMul.
    
    Module WrappingNeg.
      Class Trait (Self : Set) `{core.marker.Sized.Trait Self} : Set := {
        wrapping_neg `{H : State.Trait} : (ref Self) -> (M (H := H) Self);
      }.
      
      Global Instance Method_wrapping_neg `{H : State.Trait} `(Trait)
        : Notation.Dot "wrapping_neg" := {
        Notation.dot := @wrapping_neg;
      }.
    End WrappingNeg.
    
    Module WrappingShl.
      Class Trait
          (Self : Set)
            `{core.marker.Sized.Trait Self}
            `{core.ops.bit.Shl.Trait Self (Rhs := (Some usize))} :
          Set := {
        wrapping_shl
          `{H : State.Trait}
          :
          (ref Self) -> u32 -> (M (H := H) Self);
      }.
      
      Global Instance Method_wrapping_shl `{H : State.Trait} `(Trait)
        : Notation.Dot "wrapping_shl" := {
        Notation.dot := @wrapping_shl;
      }.
    End WrappingShl.
    
    Module WrappingShr.
      Class Trait
          (Self : Set)
            `{core.marker.Sized.Trait Self}
            `{core.ops.bit.Shr.Trait Self (Rhs := (Some usize))} :
          Set := {
        wrapping_shr
          `{H : State.Trait}
          :
          (ref Self) -> u32 -> (M (H := H) Self);
      }.
      
      Global Instance Method_wrapping_shr `{H : State.Trait} `(Trait)
        : Notation.Dot "wrapping_shr" := {
        Notation.dot := @wrapping_shr;
      }.
    End WrappingShr.
  End wrapping.
  *)
End ops.
(*
Module bytes.
  Module NumBytes.
    Unset Primitive Projections.
    Class Trait
        (Self : Set)
          `{core.fmt.Debug.Trait Self}
          `{core.convert.AsRef.Trait Self (T := Slice u8)}
          `{core.convert.AsMut.Trait Self (T := Slice u8)}
          `{core.cmp.PartialEq.Trait Self (Rhs := None)}
          `{core.cmp.Eq.Trait Self}
          `{core.cmp.PartialOrd.Trait Self (Rhs := None)}
          `{core.cmp.Ord.Trait Self}
          `{core.hash.Hash.Trait Self}
          `{core.borrow.Borrow.Trait Self (Borrowed := Slice u8)}
          `{core.borrow.BorrowMut.Trait Self (Borrowed := Slice u8)} :
        Set := {
    }.
    Global Set Primitive Projections.
  End NumBytes.
  
  Module ToBytes.
    Class Trait
        (Self : Set)
        {Bytes : Set}
        `{num_traits.ops.bytes.NumBytes.Trait Bytes} :
        Set := {
      Bytes := Bytes;
      to_be_bytes `{H : State.Trait} : (ref Self) -> (M (H := H) Bytes);
      to_le_bytes `{H : State.Trait} : (ref Self) -> (M (H := H) Bytes);
    }.
    
    Global Instance
        Method_Bytes
        `{H : State.Trait}
        {Bytes}
        `(Trait
        (Bytes := Bytes))
      : Notation.DoubleColonType Self "Bytes" := {
      Notation.double_colon_type := Bytes;
    }.
    Global Instance Method_to_be_bytes `{H : State.Trait} `(Trait)
      : Notation.Dot "to_be_bytes" := {
      Notation.dot := @to_be_bytes;
    }.
    Global Instance Method_to_le_bytes `{H : State.Trait} `(Trait)
      : Notation.Dot "to_le_bytes" := {
      Notation.dot := @to_le_bytes;
    }.
    Global Instance Method_to_ne_bytes `{H : State.Trait} `(Trait)
      : Notation.Dot "to_ne_bytes" := {
      Notation.dot (self : ref Self) := (axiom : M (H := H) Bytes);
    }.
  End ToBytes.
  
  Module FromBytes.
    Class Trait
        (Self : Set) `{core.marker.Sized.Trait Self}
        {Bytes : Set}
        `{num_traits.ops.bytes.NumBytes.Trait Bytes}
        `{core.marker.Sized.Trait Bytes} :
        Set := {
      Bytes := Bytes;
      from_be_bytes `{H : State.Trait} : (ref Bytes) -> (M (H := H) Self);
      from_le_bytes `{H : State.Trait} : (ref Bytes) -> (M (H := H) Self);
    }.
    
    Global Instance
        Method_Bytes
        `{H : State.Trait}
        {Bytes}
        `(Trait
        (Bytes := Bytes))
      : Notation.DoubleColonType Self "Bytes" := {
      Notation.double_colon_type := Bytes;
    }.
    Global Instance Method_from_be_bytes `{H : State.Trait} `(Trait)
      : Notation.Dot "from_be_bytes" := {
      Notation.dot := @from_be_bytes;
    }.
    Global Instance Method_from_le_bytes `{H : State.Trait} `(Trait)
      : Notation.Dot "from_le_bytes" := {
      Notation.dot := @from_le_bytes;
    }.
    Global Instance Method_from_ne_bytes `{H : State.Trait} `(Trait)
      : Notation.Dot "from_ne_bytes" := {
      Notation.dot (bytes : ref Bytes) := (axiom : M (H := H) Self);
    }.
  End FromBytes.
End bytes.

Module NumBytes.
  Unset Primitive Projections.
  Class Trait
      (Self : Set)
        `{core.fmt.Debug.Trait Self}
        `{core.convert.AsRef.Trait Self (T := Slice u8)}
        `{core.convert.AsMut.Trait Self (T := Slice u8)}
        `{core.cmp.PartialEq.Trait Self (Rhs := None)}
        `{core.cmp.Eq.Trait Self}
        `{core.cmp.PartialOrd.Trait Self (Rhs := None)}
        `{core.cmp.Ord.Trait Self}
        `{core.hash.Hash.Trait Self}
        `{core.borrow.Borrow.Trait Self (Borrowed := Slice u8)}
        `{core.borrow.BorrowMut.Trait Self (Borrowed := Slice u8)} :
      Set := {
  }.
  Global Set Primitive Projections.
End NumBytes.

Module ToBytes.
  Class Trait
      (Self : Set)
      {Bytes : Set}
      `{num_traits.ops.bytes.NumBytes.Trait Bytes} :
      Set := {
    Bytes := Bytes;
    to_be_bytes `{H : State.Trait} : (ref Self) -> (M (H := H) Bytes);
    to_le_bytes `{H : State.Trait} : (ref Self) -> (M (H := H) Bytes);
  }.
  
  Global Instance
      Method_Bytes
      `{H : State.Trait}
      {Bytes}
      `(Trait
      (Bytes := Bytes))
    : Notation.DoubleColonType Self "Bytes" := {
    Notation.double_colon_type := Bytes;
  }.
  Global Instance Method_to_be_bytes `{H : State.Trait} `(Trait)
    : Notation.Dot "to_be_bytes" := {
    Notation.dot := @to_be_bytes;
  }.
  Global Instance Method_to_le_bytes `{H : State.Trait} `(Trait)
    : Notation.Dot "to_le_bytes" := {
    Notation.dot := @to_le_bytes;
  }.
  Global Instance Method_to_ne_bytes `{H : State.Trait} `(Trait)
    : Notation.Dot "to_ne_bytes" := {
    Notation.dot (self : ref Self) := (axiom : M (H := H) Bytes);
  }.
End ToBytes.

Module FromBytes.
  Class Trait
      (Self : Set) `{core.marker.Sized.Trait Self}
      {Bytes : Set}
      `{num_traits.ops.bytes.NumBytes.Trait Bytes}
      `{core.marker.Sized.Trait Bytes} :
      Set := {
    Bytes := Bytes;
    from_be_bytes `{H : State.Trait} : (ref Bytes) -> (M (H := H) Self);
    from_le_bytes `{H : State.Trait} : (ref Bytes) -> (M (H := H) Self);
  }.
  
  Global Instance
      Method_Bytes
      `{H : State.Trait}
      {Bytes}
      `(Trait
      (Bytes := Bytes))
    : Notation.DoubleColonType Self "Bytes" := {
    Notation.double_colon_type := Bytes;
  }.
  Global Instance Method_from_be_bytes `{H : State.Trait} `(Trait)
    : Notation.Dot "from_be_bytes" := {
    Notation.dot := @from_be_bytes;
  }.
  Global Instance Method_from_le_bytes `{H : State.Trait} `(Trait)
    : Notation.Dot "from_le_bytes" := {
    Notation.dot := @from_le_bytes;
  }.
  Global Instance Method_from_ne_bytes `{H : State.Trait} `(Trait)
    : Notation.Dot "from_ne_bytes" := {
    Notation.dot (bytes : ref Bytes) := (axiom : M (H := H) Self);
  }.
End FromBytes.

Module checked.
  Module CheckedAdd.
    Class Trait
        (Self : Set)
          `{core.marker.Sized.Trait Self}
          `{core.ops.arith.Add.Trait Self (Rhs := (Some Self))} :
        Set := {
      checked_add
        `{H : State.Trait}
        :
        (ref Self) -> (ref Self) -> (M (H := H) (core.option.Option Self));
    }.
    
    Global Instance Method_checked_add `{H : State.Trait} `(Trait)
      : Notation.Dot "checked_add" := {
      Notation.dot := @checked_add;
    }.
  End CheckedAdd.
  
  Module CheckedSub.
    Class Trait
        (Self : Set)
          `{core.marker.Sized.Trait Self}
          `{core.ops.arith.Sub.Trait Self (Rhs := (Some Self))} :
        Set := {
      checked_sub
        `{H : State.Trait}
        :
        (ref Self) -> (ref Self) -> (M (H := H) (core.option.Option Self));
    }.
    
    Global Instance Method_checked_sub `{H : State.Trait} `(Trait)
      : Notation.Dot "checked_sub" := {
      Notation.dot := @checked_sub;
    }.
  End CheckedSub.
  
  Module CheckedMul.
    Class Trait
        (Self : Set)
          `{core.marker.Sized.Trait Self}
          `{core.ops.arith.Mul.Trait Self (Rhs := (Some Self))} :
        Set := {
      checked_mul
        `{H : State.Trait}
        :
        (ref Self) -> (ref Self) -> (M (H := H) (core.option.Option Self));
    }.
    
    Global Instance Method_checked_mul `{H : State.Trait} `(Trait)
      : Notation.Dot "checked_mul" := {
      Notation.dot := @checked_mul;
    }.
  End CheckedMul.
  
  Module CheckedDiv.
    Class Trait
        (Self : Set)
          `{core.marker.Sized.Trait Self}
          `{core.ops.arith.Div.Trait Self (Rhs := (Some Self))} :
        Set := {
      checked_div
        `{H : State.Trait}
        :
        (ref Self) -> (ref Self) -> (M (H := H) (core.option.Option Self));
    }.
    
    Global Instance Method_checked_div `{H : State.Trait} `(Trait)
      : Notation.Dot "checked_div" := {
      Notation.dot := @checked_div;
    }.
  End CheckedDiv.
  
  Module CheckedRem.
    Class Trait
        (Self : Set)
          `{core.marker.Sized.Trait Self}
          `{core.ops.arith.Rem.Trait Self (Rhs := (Some Self))} :
        Set := {
      checked_rem
        `{H : State.Trait}
        :
        (ref Self) -> (ref Self) -> (M (H := H) (core.option.Option Self));
    }.
    
    Global Instance Method_checked_rem `{H : State.Trait} `(Trait)
      : Notation.Dot "checked_rem" := {
      Notation.dot := @checked_rem;
    }.
  End CheckedRem.
  
  Module CheckedNeg.
    Class Trait (Self : Set) `{core.marker.Sized.Trait Self} : Set := {
      checked_neg
        `{H : State.Trait}
        :
        (ref Self) -> (M (H := H) (core.option.Option Self));
    }.
    
    Global Instance Method_checked_neg `{H : State.Trait} `(Trait)
      : Notation.Dot "checked_neg" := {
      Notation.dot := @checked_neg;
    }.
  End CheckedNeg.
  
  Module CheckedShl.
    Class Trait
        (Self : Set)
          `{core.marker.Sized.Trait Self}
          `{core.ops.bit.Shl.Trait Self (Rhs := (Some u32))} :
        Set := {
      checked_shl
        `{H : State.Trait}
        :
        (ref Self) -> u32 -> (M (H := H) (core.option.Option Self));
    }.
    
    Global Instance Method_checked_shl `{H : State.Trait} `(Trait)
      : Notation.Dot "checked_shl" := {
      Notation.dot := @checked_shl;
    }.
  End CheckedShl.
  
  Module CheckedShr.
    Class Trait
        (Self : Set)
          `{core.marker.Sized.Trait Self}
          `{core.ops.bit.Shr.Trait Self (Rhs := (Some u32))} :
        Set := {
      checked_shr
        `{H : State.Trait}
        :
        (ref Self) -> u32 -> (M (H := H) (core.option.Option Self));
    }.
    
    Global Instance Method_checked_shr `{H : State.Trait} `(Trait)
      : Notation.Dot "checked_shr" := {
      Notation.dot := @checked_shr;
    }.
  End CheckedShr.
End checked.

Module CheckedAdd.
  Class Trait
      (Self : Set)
        `{core.marker.Sized.Trait Self}
        `{core.ops.arith.Add.Trait Self (Rhs := (Some Self))} :
      Set := {
    checked_add
      `{H : State.Trait}
      :
      (ref Self) -> (ref Self) -> (M (H := H) (core.option.Option Self));
  }.
  
  Global Instance Method_checked_add `{H : State.Trait} `(Trait)
    : Notation.Dot "checked_add" := {
    Notation.dot := @checked_add;
  }.
End CheckedAdd.

Module CheckedSub.
  Class Trait
      (Self : Set)
        `{core.marker.Sized.Trait Self}
        `{core.ops.arith.Sub.Trait Self (Rhs := (Some Self))} :
      Set := {
    checked_sub
      `{H : State.Trait}
      :
      (ref Self) -> (ref Self) -> (M (H := H) (core.option.Option Self));
  }.
  
  Global Instance Method_checked_sub `{H : State.Trait} `(Trait)
    : Notation.Dot "checked_sub" := {
    Notation.dot := @checked_sub;
  }.
End CheckedSub.

Module CheckedMul.
  Class Trait
      (Self : Set)
        `{core.marker.Sized.Trait Self}
        `{core.ops.arith.Mul.Trait Self (Rhs := (Some Self))} :
      Set := {
    checked_mul
      `{H : State.Trait}
      :
      (ref Self) -> (ref Self) -> (M (H := H) (core.option.Option Self));
  }.
  
  Global Instance Method_checked_mul `{H : State.Trait} `(Trait)
    : Notation.Dot "checked_mul" := {
    Notation.dot := @checked_mul;
  }.
End CheckedMul.

Module CheckedDiv.
  Class Trait
      (Self : Set)
        `{core.marker.Sized.Trait Self}
        `{core.ops.arith.Div.Trait Self (Rhs := (Some Self))} :
      Set := {
    checked_div
      `{H : State.Trait}
      :
      (ref Self) -> (ref Self) -> (M (H := H) (core.option.Option Self));
  }.
  
  Global Instance Method_checked_div `{H : State.Trait} `(Trait)
    : Notation.Dot "checked_div" := {
    Notation.dot := @checked_div;
  }.
End CheckedDiv.

Module CheckedRem.
  Class Trait
      (Self : Set)
        `{core.marker.Sized.Trait Self}
        `{core.ops.arith.Rem.Trait Self (Rhs := (Some Self))} :
      Set := {
    checked_rem
      `{H : State.Trait}
      :
      (ref Self) -> (ref Self) -> (M (H := H) (core.option.Option Self));
  }.
  
  Global Instance Method_checked_rem `{H : State.Trait} `(Trait)
    : Notation.Dot "checked_rem" := {
    Notation.dot := @checked_rem;
  }.
End CheckedRem.

Module CheckedNeg.
  Class Trait (Self : Set) `{core.marker.Sized.Trait Self} : Set := {
    checked_neg
      `{H : State.Trait}
      :
      (ref Self) -> (M (H := H) (core.option.Option Self));
  }.
  
  Global Instance Method_checked_neg `{H : State.Trait} `(Trait)
    : Notation.Dot "checked_neg" := {
    Notation.dot := @checked_neg;
  }.
End CheckedNeg.

Module CheckedShl.
  Class Trait
      (Self : Set)
        `{core.marker.Sized.Trait Self}
        `{core.ops.bit.Shl.Trait Self (Rhs := (Some u32))} :
      Set := {
    checked_shl
      `{H : State.Trait}
      :
      (ref Self) -> u32 -> (M (H := H) (core.option.Option Self));
  }.
  
  Global Instance Method_checked_shl `{H : State.Trait} `(Trait)
    : Notation.Dot "checked_shl" := {
    Notation.dot := @checked_shl;
  }.
End CheckedShl.

Module CheckedShr.
  Class Trait
      (Self : Set)
        `{core.marker.Sized.Trait Self}
        `{core.ops.bit.Shr.Trait Self (Rhs := (Some u32))} :
      Set := {
    checked_shr
      `{H : State.Trait}
      :
      (ref Self) -> u32 -> (M (H := H) (core.option.Option Self));
  }.
  
  Global Instance Method_checked_shr `{H : State.Trait} `(Trait)
    : Notation.Dot "checked_shr" := {
    Notation.dot := @checked_shr;
  }.
End CheckedShr.

Module euclid.
  Module Euclid.
    Class Trait
        (Self : Set)
          `{core.marker.Sized.Trait Self}
          `{core.ops.arith.Div.Trait Self (Rhs := (Some Self))}
          `{core.ops.arith.Rem.Trait Self (Rhs := (Some Self))} :
        Set := {
      div_euclid
        `{H : State.Trait}
        :
        (ref Self) -> (ref Self) -> (M (H := H) Self);
      rem_euclid
        `{H : State.Trait}
        :
        (ref Self) -> (ref Self) -> (M (H := H) Self);
    }.
    
    Global Instance Method_div_euclid `{H : State.Trait} `(Trait)
      : Notation.Dot "div_euclid" := {
      Notation.dot := @div_euclid;
    }.
    Global Instance Method_rem_euclid `{H : State.Trait} `(Trait)
      : Notation.Dot "rem_euclid" := {
      Notation.dot := @rem_euclid;
    }.
  End Euclid.
  
  Module CheckedEuclid.
    Class Trait
        (Self : Set) `{num_traits.ops.euclid.Euclid.Trait Self} :
        Set := {
      checked_div_euclid
        `{H : State.Trait}
        :
        (ref Self) -> (ref Self) -> (M (H := H) (core.option.Option Self));
      checked_rem_euclid
        `{H : State.Trait}
        :
        (ref Self) -> (ref Self) -> (M (H := H) (core.option.Option Self));
    }.
    
    Global Instance Method_checked_div_euclid `{H : State.Trait} `(Trait)
      : Notation.Dot "checked_div_euclid" := {
      Notation.dot := @checked_div_euclid;
    }.
    Global Instance Method_checked_rem_euclid `{H : State.Trait} `(Trait)
      : Notation.Dot "checked_rem_euclid" := {
      Notation.dot := @checked_rem_euclid;
    }.
  End CheckedEuclid.
End euclid.

Module Euclid.
  Class Trait
      (Self : Set)
        `{core.marker.Sized.Trait Self}
        `{core.ops.arith.Div.Trait Self (Rhs := (Some Self))}
        `{core.ops.arith.Rem.Trait Self (Rhs := (Some Self))} :
      Set := {
    div_euclid
      `{H : State.Trait}
      :
      (ref Self) -> (ref Self) -> (M (H := H) Self);
    rem_euclid
      `{H : State.Trait}
      :
      (ref Self) -> (ref Self) -> (M (H := H) Self);
  }.
  
  Global Instance Method_div_euclid `{H : State.Trait} `(Trait)
    : Notation.Dot "div_euclid" := {
    Notation.dot := @div_euclid;
  }.
  Global Instance Method_rem_euclid `{H : State.Trait} `(Trait)
    : Notation.Dot "rem_euclid" := {
    Notation.dot := @rem_euclid;
  }.
End Euclid.

Module CheckedEuclid.
  Class Trait (Self : Set) `{num_traits.ops.euclid.Euclid.Trait Self} : Set := {
    checked_div_euclid
      `{H : State.Trait}
      :
      (ref Self) -> (ref Self) -> (M (H := H) (core.option.Option Self));
    checked_rem_euclid
      `{H : State.Trait}
      :
      (ref Self) -> (ref Self) -> (M (H := H) (core.option.Option Self));
  }.
  
  Global Instance Method_checked_div_euclid `{H : State.Trait} `(Trait)
    : Notation.Dot "checked_div_euclid" := {
    Notation.dot := @checked_div_euclid;
  }.
  Global Instance Method_checked_rem_euclid `{H : State.Trait} `(Trait)
    : Notation.Dot "checked_rem_euclid" := {
    Notation.dot := @checked_rem_euclid;
  }.
End CheckedEuclid.

Module inv.
  Module Inv.
    Class Trait (Self : Set) {Output : Set} : Set := {
      Output := Output;
      inv `{H : State.Trait} : Self -> (M (H := H) Output);
    }.
    
    Global Instance
        Method_Output
        `{H : State.Trait}
        {Output}
        `(Trait
        (Output := Output))
      : Notation.DoubleColonType Self "Output" := {
      Notation.double_colon_type := Output;
    }.
    Global Instance Method_inv `{H : State.Trait} `(Trait)
      : Notation.Dot "inv" := {
      Notation.dot := @inv;
    }.
  End Inv.
End inv.

Module Inv.
  Class Trait (Self : Set) {Output : Set} : Set := {
    Output := Output;
    inv `{H : State.Trait} : Self -> (M (H := H) Output);
  }.
  
  Global Instance
      Method_Output
      `{H : State.Trait}
      {Output}
      `(Trait
      (Output := Output))
    : Notation.DoubleColonType Self "Output" := {
    Notation.double_colon_type := Output;
  }.
  Global Instance Method_inv `{H : State.Trait} `(Trait)
    : Notation.Dot "inv" := {
    Notation.dot := @inv;
  }.
End Inv.

Module mul_add.
  Module MulAdd.
    Class Trait
        (Self : Set) {(* TODO *) A (* TODO *) B : Set}
        {Output : Set} :
        Set := {
      Output := Output;
      mul_add `{H : State.Trait} : Self -> A -> B -> (M (H := H) Output);
    }.
    
    Global Instance
        Method_Output
        `{H : State.Trait}
        {Output}
        `(Trait
        (Output := Output))
      : Notation.DoubleColonType Self "Output" := {
      Notation.double_colon_type := Output;
    }.
    Global Instance Method_mul_add `{H : State.Trait} `(Trait)
      : Notation.Dot "mul_add" := {
      Notation.dot := @mul_add;
    }.
  End MulAdd.
  
  Module MulAddAssign.
    Class Trait (Self : Set) {(* TODO *) A (* TODO *) B : Set} : Set := {
      mul_add_assign
        `{H : State.Trait}
        :
        (mut_ref Self) -> A -> B -> (M (H := H) unit);
    }.
    
    Global Instance Method_mul_add_assign `{H : State.Trait} `(Trait)
      : Notation.Dot "mul_add_assign" := {
      Notation.dot := @mul_add_assign;
    }.
  End MulAddAssign.
End mul_add.

Module MulAdd.
  Class Trait
      (Self : Set) {(* TODO *) A (* TODO *) B : Set}
      {Output : Set} :
      Set := {
    Output := Output;
    mul_add `{H : State.Trait} : Self -> A -> B -> (M (H := H) Output);
  }.
  
  Global Instance
      Method_Output
      `{H : State.Trait}
      {Output}
      `(Trait
      (Output := Output))
    : Notation.DoubleColonType Self "Output" := {
    Notation.double_colon_type := Output;
  }.
  Global Instance Method_mul_add `{H : State.Trait} `(Trait)
    : Notation.Dot "mul_add" := {
    Notation.dot := @mul_add;
  }.
End MulAdd.

Module MulAddAssign.
  Class Trait (Self : Set) {(* TODO *) A (* TODO *) B : Set} : Set := {
    mul_add_assign
      `{H : State.Trait}
      :
      (mut_ref Self) -> A -> B -> (M (H := H) unit);
  }.
  
  Global Instance Method_mul_add_assign `{H : State.Trait} `(Trait)
    : Notation.Dot "mul_add_assign" := {
    Notation.dot := @mul_add_assign;
  }.
End MulAddAssign.

Module overflowing.
  Module OverflowingAdd.
    Class Trait
        (Self : Set)
          `{core.marker.Sized.Trait Self}
          `{core.ops.arith.Add.Trait Self (Rhs := (Some Self))} :
        Set := {
      overflowing_add
        `{H : State.Trait}
        :
        (ref Self) -> (ref Self) -> (M (H := H) (Self * bool));
    }.
    
    Global Instance Method_overflowing_add `{H : State.Trait} `(Trait)
      : Notation.Dot "overflowing_add" := {
      Notation.dot := @overflowing_add;
    }.
  End OverflowingAdd.
  
  Module OverflowingSub.
    Class Trait
        (Self : Set)
          `{core.marker.Sized.Trait Self}
          `{core.ops.arith.Sub.Trait Self (Rhs := (Some Self))} :
        Set := {
      overflowing_sub
        `{H : State.Trait}
        :
        (ref Self) -> (ref Self) -> (M (H := H) (Self * bool));
    }.
    
    Global Instance Method_overflowing_sub `{H : State.Trait} `(Trait)
      : Notation.Dot "overflowing_sub" := {
      Notation.dot := @overflowing_sub;
    }.
  End OverflowingSub.
  
  Module OverflowingMul.
    Class Trait
        (Self : Set)
          `{core.marker.Sized.Trait Self}
          `{core.ops.arith.Mul.Trait Self (Rhs := (Some Self))} :
        Set := {
      overflowing_mul
        `{H : State.Trait}
        :
        (ref Self) -> (ref Self) -> (M (H := H) (Self * bool));
    }.
    
    Global Instance Method_overflowing_mul `{H : State.Trait} `(Trait)
      : Notation.Dot "overflowing_mul" := {
      Notation.dot := @overflowing_mul;
    }.
  End OverflowingMul.
End overflowing.

Module OverflowingAdd.
  Class Trait
      (Self : Set)
        `{core.marker.Sized.Trait Self}
        `{core.ops.arith.Add.Trait Self (Rhs := (Some Self))} :
      Set := {
    overflowing_add
      `{H : State.Trait}
      :
      (ref Self) -> (ref Self) -> (M (H := H) (Self * bool));
  }.
  
  Global Instance Method_overflowing_add `{H : State.Trait} `(Trait)
    : Notation.Dot "overflowing_add" := {
    Notation.dot := @overflowing_add;
  }.
End OverflowingAdd.

Module OverflowingSub.
  Class Trait
      (Self : Set)
        `{core.marker.Sized.Trait Self}
        `{core.ops.arith.Sub.Trait Self (Rhs := (Some Self))} :
      Set := {
    overflowing_sub
      `{H : State.Trait}
      :
      (ref Self) -> (ref Self) -> (M (H := H) (Self * bool));
  }.
  
  Global Instance Method_overflowing_sub `{H : State.Trait} `(Trait)
    : Notation.Dot "overflowing_sub" := {
    Notation.dot := @overflowing_sub;
  }.
End OverflowingSub.

Module OverflowingMul.
  Class Trait
      (Self : Set)
        `{core.marker.Sized.Trait Self}
        `{core.ops.arith.Mul.Trait Self (Rhs := (Some Self))} :
      Set := {
    overflowing_mul
      `{H : State.Trait}
      :
      (ref Self) -> (ref Self) -> (M (H := H) (Self * bool));
  }.
  
  Global Instance Method_overflowing_mul `{H : State.Trait} `(Trait)
    : Notation.Dot "overflowing_mul" := {
    Notation.dot := @overflowing_mul;
  }.
End OverflowingMul.

Module saturating.
  Module Saturating.
    Class Trait (Self : Set) : Set := {
      saturating_add `{H : State.Trait} : Self -> Self -> (M (H := H) Self);
      saturating_sub `{H : State.Trait} : Self -> Self -> (M (H := H) Self);
    }.
    
    Global Instance Method_saturating_add `{H : State.Trait} `(Trait)
      : Notation.Dot "saturating_add" := {
      Notation.dot := @saturating_add;
    }.
    Global Instance Method_saturating_sub `{H : State.Trait} `(Trait)
      : Notation.Dot "saturating_sub" := {
      Notation.dot := @saturating_sub;
    }.
  End Saturating.
  
  Module SaturatingAdd.
    Class Trait
        (Self : Set)
          `{core.marker.Sized.Trait Self}
          `{core.ops.arith.Add.Trait Self (Rhs := (Some Self))} :
        Set := {
      saturating_add
        `{H : State.Trait}
        :
        (ref Self) -> (ref Self) -> (M (H := H) Self);
    }.
    
    Global Instance Method_saturating_add `{H : State.Trait} `(Trait)
      : Notation.Dot "saturating_add" := {
      Notation.dot := @saturating_add;
    }.
  End SaturatingAdd.
  
  Module SaturatingSub.
    Class Trait
        (Self : Set)
          `{core.marker.Sized.Trait Self}
          `{core.ops.arith.Sub.Trait Self (Rhs := (Some Self))} :
        Set := {
      saturating_sub
        `{H : State.Trait}
        :
        (ref Self) -> (ref Self) -> (M (H := H) Self);
    }.
    
    Global Instance Method_saturating_sub `{H : State.Trait} `(Trait)
      : Notation.Dot "saturating_sub" := {
      Notation.dot := @saturating_sub;
    }.
  End SaturatingSub.
  
  Module SaturatingMul.
    Class Trait
        (Self : Set)
          `{core.marker.Sized.Trait Self}
          `{core.ops.arith.Mul.Trait Self (Rhs := (Some Self))} :
        Set := {
      saturating_mul
        `{H : State.Trait}
        :
        (ref Self) -> (ref Self) -> (M (H := H) Self);
    }.
    
    Global Instance Method_saturating_mul `{H : State.Trait} `(Trait)
      : Notation.Dot "saturating_mul" := {
      Notation.dot := @saturating_mul;
    }.
  End SaturatingMul.
End saturating.

Module Saturating.
  Class Trait (Self : Set) : Set := {
    saturating_add `{H : State.Trait} : Self -> Self -> (M (H := H) Self);
    saturating_sub `{H : State.Trait} : Self -> Self -> (M (H := H) Self);
  }.
  
  Global Instance Method_saturating_add `{H : State.Trait} `(Trait)
    : Notation.Dot "saturating_add" := {
    Notation.dot := @saturating_add;
  }.
  Global Instance Method_saturating_sub `{H : State.Trait} `(Trait)
    : Notation.Dot "saturating_sub" := {
    Notation.dot := @saturating_sub;
  }.
End Saturating.

Module SaturatingAdd.
  Class Trait
      (Self : Set)
        `{core.marker.Sized.Trait Self}
        `{core.ops.arith.Add.Trait Self (Rhs := (Some Self))} :
      Set := {
    saturating_add
      `{H : State.Trait}
      :
      (ref Self) -> (ref Self) -> (M (H := H) Self);
  }.
  
  Global Instance Method_saturating_add `{H : State.Trait} `(Trait)
    : Notation.Dot "saturating_add" := {
    Notation.dot := @saturating_add;
  }.
End SaturatingAdd.

Module SaturatingSub.
  Class Trait
      (Self : Set)
        `{core.marker.Sized.Trait Self}
        `{core.ops.arith.Sub.Trait Self (Rhs := (Some Self))} :
      Set := {
    saturating_sub
      `{H : State.Trait}
      :
      (ref Self) -> (ref Self) -> (M (H := H) Self);
  }.
  
  Global Instance Method_saturating_sub `{H : State.Trait} `(Trait)
    : Notation.Dot "saturating_sub" := {
    Notation.dot := @saturating_sub;
  }.
End SaturatingSub.

Module SaturatingMul.
  Class Trait
      (Self : Set)
        `{core.marker.Sized.Trait Self}
        `{core.ops.arith.Mul.Trait Self (Rhs := (Some Self))} :
      Set := {
    saturating_mul
      `{H : State.Trait}
      :
      (ref Self) -> (ref Self) -> (M (H := H) Self);
  }.
  
  Global Instance Method_saturating_mul `{H : State.Trait} `(Trait)
    : Notation.Dot "saturating_mul" := {
    Notation.dot := @saturating_mul;
  }.
End SaturatingMul.

Module wrapping.
  Module WrappingAdd.
    Class Trait
        (Self : Set)
          `{core.marker.Sized.Trait Self}
          `{core.ops.arith.Add.Trait Self (Rhs := (Some Self))} :
        Set := {
      wrapping_add
        `{H : State.Trait}
        :
        (ref Self) -> (ref Self) -> (M (H := H) Self);
    }.
    
    Global Instance Method_wrapping_add `{H : State.Trait} `(Trait)
      : Notation.Dot "wrapping_add" := {
      Notation.dot := @wrapping_add;
    }.
  End WrappingAdd.
  
  Module WrappingSub.
    Class Trait
        (Self : Set)
          `{core.marker.Sized.Trait Self}
          `{core.ops.arith.Sub.Trait Self (Rhs := (Some Self))} :
        Set := {
      wrapping_sub
        `{H : State.Trait}
        :
        (ref Self) -> (ref Self) -> (M (H := H) Self);
    }.
    
    Global Instance Method_wrapping_sub `{H : State.Trait} `(Trait)
      : Notation.Dot "wrapping_sub" := {
      Notation.dot := @wrapping_sub;
    }.
  End WrappingSub.
  
  Module WrappingMul.
    Class Trait
        (Self : Set)
          `{core.marker.Sized.Trait Self}
          `{core.ops.arith.Mul.Trait Self (Rhs := (Some Self))} :
        Set := {
      wrapping_mul
        `{H : State.Trait}
        :
        (ref Self) -> (ref Self) -> (M (H := H) Self);
    }.
    
    Global Instance Method_wrapping_mul `{H : State.Trait} `(Trait)
      : Notation.Dot "wrapping_mul" := {
      Notation.dot := @wrapping_mul;
    }.
  End WrappingMul.
  
  Module WrappingNeg.
    Class Trait (Self : Set) `{core.marker.Sized.Trait Self} : Set := {
      wrapping_neg `{H : State.Trait} : (ref Self) -> (M (H := H) Self);
    }.
    
    Global Instance Method_wrapping_neg `{H : State.Trait} `(Trait)
      : Notation.Dot "wrapping_neg" := {
      Notation.dot := @wrapping_neg;
    }.
  End WrappingNeg.
  
  Module WrappingShl.
    Class Trait
        (Self : Set)
          `{core.marker.Sized.Trait Self}
          `{core.ops.bit.Shl.Trait Self (Rhs := (Some usize))} :
        Set := {
      wrapping_shl `{H : State.Trait} : (ref Self) -> u32 -> (M (H := H) Self);
    }.
    
    Global Instance Method_wrapping_shl `{H : State.Trait} `(Trait)
      : Notation.Dot "wrapping_shl" := {
      Notation.dot := @wrapping_shl;
    }.
  End WrappingShl.
  
  Module WrappingShr.
    Class Trait
        (Self : Set)
          `{core.marker.Sized.Trait Self}
          `{core.ops.bit.Shr.Trait Self (Rhs := (Some usize))} :
        Set := {
      wrapping_shr `{H : State.Trait} : (ref Self) -> u32 -> (M (H := H) Self);
    }.
    
    Global Instance Method_wrapping_shr `{H : State.Trait} `(Trait)
      : Notation.Dot "wrapping_shr" := {
      Notation.dot := @wrapping_shr;
    }.
  End WrappingShr.
End wrapping.

Module WrappingAdd.
  Class Trait
      (Self : Set)
        `{core.marker.Sized.Trait Self}
        `{core.ops.arith.Add.Trait Self (Rhs := (Some Self))} :
      Set := {
    wrapping_add
      `{H : State.Trait}
      :
      (ref Self) -> (ref Self) -> (M (H := H) Self);
  }.
  
  Global Instance Method_wrapping_add `{H : State.Trait} `(Trait)
    : Notation.Dot "wrapping_add" := {
    Notation.dot := @wrapping_add;
  }.
End WrappingAdd.

Module WrappingSub.
  Class Trait
      (Self : Set)
        `{core.marker.Sized.Trait Self}
        `{core.ops.arith.Sub.Trait Self (Rhs := (Some Self))} :
      Set := {
    wrapping_sub
      `{H : State.Trait}
      :
      (ref Self) -> (ref Self) -> (M (H := H) Self);
  }.
  
  Global Instance Method_wrapping_sub `{H : State.Trait} `(Trait)
    : Notation.Dot "wrapping_sub" := {
    Notation.dot := @wrapping_sub;
  }.
End WrappingSub.

Module WrappingMul.
  Class Trait
      (Self : Set)
        `{core.marker.Sized.Trait Self}
        `{core.ops.arith.Mul.Trait Self (Rhs := (Some Self))} :
      Set := {
    wrapping_mul
      `{H : State.Trait}
      :
      (ref Self) -> (ref Self) -> (M (H := H) Self);
  }.
  
  Global Instance Method_wrapping_mul `{H : State.Trait} `(Trait)
    : Notation.Dot "wrapping_mul" := {
    Notation.dot := @wrapping_mul;
  }.
End WrappingMul.

Module WrappingNeg.
  Class Trait (Self : Set) `{core.marker.Sized.Trait Self} : Set := {
    wrapping_neg `{H : State.Trait} : (ref Self) -> (M (H := H) Self);
  }.
  
  Global Instance Method_wrapping_neg `{H : State.Trait} `(Trait)
    : Notation.Dot "wrapping_neg" := {
    Notation.dot := @wrapping_neg;
  }.
End WrappingNeg.

Module WrappingShl.
  Class Trait
      (Self : Set)
        `{core.marker.Sized.Trait Self}
        `{core.ops.bit.Shl.Trait Self (Rhs := (Some usize))} :
      Set := {
    wrapping_shl `{H : State.Trait} : (ref Self) -> u32 -> (M (H := H) Self);
  }.
  
  Global Instance Method_wrapping_shl `{H : State.Trait} `(Trait)
    : Notation.Dot "wrapping_shl" := {
    Notation.dot := @wrapping_shl;
  }.
End WrappingShl.

Module WrappingShr.
  Class Trait
      (Self : Set)
        `{core.marker.Sized.Trait Self}
        `{core.ops.bit.Shr.Trait Self (Rhs := (Some usize))} :
      Set := {
    wrapping_shr `{H : State.Trait} : (ref Self) -> u32 -> (M (H := H) Self);
  }.
  
  Global Instance Method_wrapping_shr `{H : State.Trait} `(Trait)
    : Notation.Dot "wrapping_shr" := {
    Notation.dot := @wrapping_shr;
  }.
End WrappingShr.

Module pow.
  Module Pow.
    Class Trait (Self : Set) {RHS : Set} {Output : Set} : Set := {
      Output := Output;
      pow `{H : State.Trait} : Self -> RHS -> (M (H := H) Output);
    }.
    
    Global Instance
        Method_Output
        `{H : State.Trait}
        {Output}
        `(Trait
        (Output := Output))
      : Notation.DoubleColonType Self "Output" := {
      Notation.double_colon_type := Output;
    }.
    Global Instance Method_pow `{H : State.Trait} `(Trait)
      : Notation.Dot "pow" := {
      Notation.dot := @pow;
    }.
  End Pow.
  
  Parameter pow : forall `{H : State.Trait},
      forall
      {T : Set},
      forall `{core.clone.Clone.Trait T}, forall
        `{num_traits.identities.One.Trait T},
        forall `{core.ops.arith.Mul.Trait T (Rhs := (Some T))}, T ->
      usize ->
      M (H := H) T.
  
  Parameter checked_pow : forall `{H : State.Trait},
      forall
      {T : Set},
      forall `{core.clone.Clone.Trait T}, forall
        `{num_traits.identities.One.Trait T},
        forall `{num_traits.ops.checked.CheckedMul.Trait T}, T ->
      usize ->
      M (H := H) (core.option.Option T).
End pow.

Module Pow.
  Class Trait (Self : Set) {RHS : Set} {Output : Set} : Set := {
    Output := Output;
    pow `{H : State.Trait} : Self -> RHS -> (M (H := H) Output);
  }.
  
  Global Instance
      Method_Output
      `{H : State.Trait}
      {Output}
      `(Trait
      (Output := Output))
    : Notation.DoubleColonType Self "Output" := {
    Notation.double_colon_type := Output;
  }.
  Global Instance Method_pow `{H : State.Trait} `(Trait)
    : Notation.Dot "pow" := {
    Notation.dot := @pow;
  }.
End Pow.

Parameter pow : forall `{H : State.Trait},
    forall
    {T : Set},
    forall `{core.clone.Clone.Trait T}, forall
      `{num_traits.identities.One.Trait T},
      forall `{core.ops.arith.Mul.Trait T (Rhs := (Some T))}, T ->
    usize ->
    M (H := H) T.

Parameter checked_pow : forall `{H : State.Trait},
    forall
    {T : Set},
    forall `{core.clone.Clone.Trait T}, forall
      `{num_traits.identities.One.Trait T},
      forall `{num_traits.ops.checked.CheckedMul.Trait T}, T ->
    usize ->
    M (H := H) (core.option.Option T).

Module real.
  Module Real.
    Class Trait
        (Self : Set)
          `{num_traits.Num.Trait Self}
          `{core.marker.Copy.Trait Self}
          `{num_traits.cast.NumCast.Trait Self}
          `{core.cmp.PartialOrd.Trait Self (Rhs := None)}
          `{core.ops.arith.Neg.Trait Self} :
        Set := {
      min_value `{H : State.Trait} : (M (H := H) Self);
      min_positive_value `{H : State.Trait} : (M (H := H) Self);
      epsilon `{H : State.Trait} : (M (H := H) Self);
      max_value `{H : State.Trait} : (M (H := H) Self);
      floor `{H : State.Trait} : Self -> (M (H := H) Self);
      ceil `{H : State.Trait} : Self -> (M (H := H) Self);
      round `{H : State.Trait} : Self -> (M (H := H) Self);
      trunc `{H : State.Trait} : Self -> (M (H := H) Self);
      fract `{H : State.Trait} : Self -> (M (H := H) Self);
      abs `{H : State.Trait} : Self -> (M (H := H) Self);
      signum `{H : State.Trait} : Self -> (M (H := H) Self);
      is_sign_positive `{H : State.Trait} : Self -> (M (H := H) bool);
      is_sign_negative `{H : State.Trait} : Self -> (M (H := H) bool);
      mul_add `{H : State.Trait} : Self -> Self -> Self -> (M (H := H) Self);
      recip `{H : State.Trait} : Self -> (M (H := H) Self);
      powi `{H : State.Trait} : Self -> i32 -> (M (H := H) Self);
      powf `{H : State.Trait} : Self -> Self -> (M (H := H) Self);
      sqrt `{H : State.Trait} : Self -> (M (H := H) Self);
      exp `{H : State.Trait} : Self -> (M (H := H) Self);
      exp2 `{H : State.Trait} : Self -> (M (H := H) Self);
      ln `{H : State.Trait} : Self -> (M (H := H) Self);
      log `{H : State.Trait} : Self -> Self -> (M (H := H) Self);
      log2 `{H : State.Trait} : Self -> (M (H := H) Self);
      log10 `{H : State.Trait} : Self -> (M (H := H) Self);
      to_degrees `{H : State.Trait} : Self -> (M (H := H) Self);
      to_radians `{H : State.Trait} : Self -> (M (H := H) Self);
      max `{H : State.Trait} : Self -> Self -> (M (H := H) Self);
      min `{H : State.Trait} : Self -> Self -> (M (H := H) Self);
      abs_sub `{H : State.Trait} : Self -> Self -> (M (H := H) Self);
      cbrt `{H : State.Trait} : Self -> (M (H := H) Self);
      hypot `{H : State.Trait} : Self -> Self -> (M (H := H) Self);
      sin `{H : State.Trait} : Self -> (M (H := H) Self);
      cos `{H : State.Trait} : Self -> (M (H := H) Self);
      tan `{H : State.Trait} : Self -> (M (H := H) Self);
      asin `{H : State.Trait} : Self -> (M (H := H) Self);
      acos `{H : State.Trait} : Self -> (M (H := H) Self);
      atan `{H : State.Trait} : Self -> (M (H := H) Self);
      atan2 `{H : State.Trait} : Self -> Self -> (M (H := H) Self);
      sin_cos `{H : State.Trait} : Self -> (M (H := H) (Self * Self));
      exp_m1 `{H : State.Trait} : Self -> (M (H := H) Self);
      ln_1p `{H : State.Trait} : Self -> (M (H := H) Self);
      sinh `{H : State.Trait} : Self -> (M (H := H) Self);
      cosh `{H : State.Trait} : Self -> (M (H := H) Self);
      tanh `{H : State.Trait} : Self -> (M (H := H) Self);
      asinh `{H : State.Trait} : Self -> (M (H := H) Self);
      acosh `{H : State.Trait} : Self -> (M (H := H) Self);
      atanh `{H : State.Trait} : Self -> (M (H := H) Self);
    }.
    
    Global Instance Method_min_value `{H : State.Trait} `(Trait)
      : Notation.Dot "min_value" := {
      Notation.dot := @min_value;
    }.
    Global Instance Method_min_positive_value `{H : State.Trait} `(Trait)
      : Notation.Dot "min_positive_value" := {
      Notation.dot := @min_positive_value;
    }.
    Global Instance Method_epsilon `{H : State.Trait} `(Trait)
      : Notation.Dot "epsilon" := {
      Notation.dot := @epsilon;
    }.
    Global Instance Method_max_value `{H : State.Trait} `(Trait)
      : Notation.Dot "max_value" := {
      Notation.dot := @max_value;
    }.
    Global Instance Method_floor `{H : State.Trait} `(Trait)
      : Notation.Dot "floor" := {
      Notation.dot := @floor;
    }.
    Global Instance Method_ceil `{H : State.Trait} `(Trait)
      : Notation.Dot "ceil" := {
      Notation.dot := @ceil;
    }.
    Global Instance Method_round `{H : State.Trait} `(Trait)
      : Notation.Dot "round" := {
      Notation.dot := @round;
    }.
    Global Instance Method_trunc `{H : State.Trait} `(Trait)
      : Notation.Dot "trunc" := {
      Notation.dot := @trunc;
    }.
    Global Instance Method_fract `{H : State.Trait} `(Trait)
      : Notation.Dot "fract" := {
      Notation.dot := @fract;
    }.
    Global Instance Method_abs `{H : State.Trait} `(Trait)
      : Notation.Dot "abs" := {
      Notation.dot := @abs;
    }.
    Global Instance Method_signum `{H : State.Trait} `(Trait)
      : Notation.Dot "signum" := {
      Notation.dot := @signum;
    }.
    Global Instance Method_is_sign_positive `{H : State.Trait} `(Trait)
      : Notation.Dot "is_sign_positive" := {
      Notation.dot := @is_sign_positive;
    }.
    Global Instance Method_is_sign_negative `{H : State.Trait} `(Trait)
      : Notation.Dot "is_sign_negative" := {
      Notation.dot := @is_sign_negative;
    }.
    Global Instance Method_mul_add `{H : State.Trait} `(Trait)
      : Notation.Dot "mul_add" := {
      Notation.dot := @mul_add;
    }.
    Global Instance Method_recip `{H : State.Trait} `(Trait)
      : Notation.Dot "recip" := {
      Notation.dot := @recip;
    }.
    Global Instance Method_powi `{H : State.Trait} `(Trait)
      : Notation.Dot "powi" := {
      Notation.dot := @powi;
    }.
    Global Instance Method_powf `{H : State.Trait} `(Trait)
      : Notation.Dot "powf" := {
      Notation.dot := @powf;
    }.
    Global Instance Method_sqrt `{H : State.Trait} `(Trait)
      : Notation.Dot "sqrt" := {
      Notation.dot := @sqrt;
    }.
    Global Instance Method_exp `{H : State.Trait} `(Trait)
      : Notation.Dot "exp" := {
      Notation.dot := @exp;
    }.
    Global Instance Method_exp2 `{H : State.Trait} `(Trait)
      : Notation.Dot "exp2" := {
      Notation.dot := @exp2;
    }.
    Global Instance Method_ln `{H : State.Trait} `(Trait)
      : Notation.Dot "ln" := {
      Notation.dot := @ln;
    }.
    Global Instance Method_log `{H : State.Trait} `(Trait)
      : Notation.Dot "log" := {
      Notation.dot := @log;
    }.
    Global Instance Method_log2 `{H : State.Trait} `(Trait)
      : Notation.Dot "log2" := {
      Notation.dot := @log2;
    }.
    Global Instance Method_log10 `{H : State.Trait} `(Trait)
      : Notation.Dot "log10" := {
      Notation.dot := @log10;
    }.
    Global Instance Method_to_degrees `{H : State.Trait} `(Trait)
      : Notation.Dot "to_degrees" := {
      Notation.dot := @to_degrees;
    }.
    Global Instance Method_to_radians `{H : State.Trait} `(Trait)
      : Notation.Dot "to_radians" := {
      Notation.dot := @to_radians;
    }.
    Global Instance Method_max `{H : State.Trait} `(Trait)
      : Notation.Dot "max" := {
      Notation.dot := @max;
    }.
    Global Instance Method_min `{H : State.Trait} `(Trait)
      : Notation.Dot "min" := {
      Notation.dot := @min;
    }.
    Global Instance Method_abs_sub `{H : State.Trait} `(Trait)
      : Notation.Dot "abs_sub" := {
      Notation.dot := @abs_sub;
    }.
    Global Instance Method_cbrt `{H : State.Trait} `(Trait)
      : Notation.Dot "cbrt" := {
      Notation.dot := @cbrt;
    }.
    Global Instance Method_hypot `{H : State.Trait} `(Trait)
      : Notation.Dot "hypot" := {
      Notation.dot := @hypot;
    }.
    Global Instance Method_sin `{H : State.Trait} `(Trait)
      : Notation.Dot "sin" := {
      Notation.dot := @sin;
    }.
    Global Instance Method_cos `{H : State.Trait} `(Trait)
      : Notation.Dot "cos" := {
      Notation.dot := @cos;
    }.
    Global Instance Method_tan `{H : State.Trait} `(Trait)
      : Notation.Dot "tan" := {
      Notation.dot := @tan;
    }.
    Global Instance Method_asin `{H : State.Trait} `(Trait)
      : Notation.Dot "asin" := {
      Notation.dot := @asin;
    }.
    Global Instance Method_acos `{H : State.Trait} `(Trait)
      : Notation.Dot "acos" := {
      Notation.dot := @acos;
    }.
    Global Instance Method_atan `{H : State.Trait} `(Trait)
      : Notation.Dot "atan" := {
      Notation.dot := @atan;
    }.
    Global Instance Method_atan2 `{H : State.Trait} `(Trait)
      : Notation.Dot "atan2" := {
      Notation.dot := @atan2;
    }.
    Global Instance Method_sin_cos `{H : State.Trait} `(Trait)
      : Notation.Dot "sin_cos" := {
      Notation.dot := @sin_cos;
    }.
    Global Instance Method_exp_m1 `{H : State.Trait} `(Trait)
      : Notation.Dot "exp_m1" := {
      Notation.dot := @exp_m1;
    }.
    Global Instance Method_ln_1p `{H : State.Trait} `(Trait)
      : Notation.Dot "ln_1p" := {
      Notation.dot := @ln_1p;
    }.
    Global Instance Method_sinh `{H : State.Trait} `(Trait)
      : Notation.Dot "sinh" := {
      Notation.dot := @sinh;
    }.
    Global Instance Method_cosh `{H : State.Trait} `(Trait)
      : Notation.Dot "cosh" := {
      Notation.dot := @cosh;
    }.
    Global Instance Method_tanh `{H : State.Trait} `(Trait)
      : Notation.Dot "tanh" := {
      Notation.dot := @tanh;
    }.
    Global Instance Method_asinh `{H : State.Trait} `(Trait)
      : Notation.Dot "asinh" := {
      Notation.dot := @asinh;
    }.
    Global Instance Method_acosh `{H : State.Trait} `(Trait)
      : Notation.Dot "acosh" := {
      Notation.dot := @acosh;
    }.
    Global Instance Method_atanh `{H : State.Trait} `(Trait)
      : Notation.Dot "atanh" := {
      Notation.dot := @atanh;
    }.
  End Real.
End real.

Module Real.
  Class Trait
      (Self : Set)
        `{num_traits.Num.Trait Self}
        `{core.marker.Copy.Trait Self}
        `{num_traits.cast.NumCast.Trait Self}
        `{core.cmp.PartialOrd.Trait Self (Rhs := None)}
        `{core.ops.arith.Neg.Trait Self} :
      Set := {
    min_value `{H : State.Trait} : (M (H := H) Self);
    min_positive_value `{H : State.Trait} : (M (H := H) Self);
    epsilon `{H : State.Trait} : (M (H := H) Self);
    max_value `{H : State.Trait} : (M (H := H) Self);
    floor `{H : State.Trait} : Self -> (M (H := H) Self);
    ceil `{H : State.Trait} : Self -> (M (H := H) Self);
    round `{H : State.Trait} : Self -> (M (H := H) Self);
    trunc `{H : State.Trait} : Self -> (M (H := H) Self);
    fract `{H : State.Trait} : Self -> (M (H := H) Self);
    abs `{H : State.Trait} : Self -> (M (H := H) Self);
    signum `{H : State.Trait} : Self -> (M (H := H) Self);
    is_sign_positive `{H : State.Trait} : Self -> (M (H := H) bool);
    is_sign_negative `{H : State.Trait} : Self -> (M (H := H) bool);
    mul_add `{H : State.Trait} : Self -> Self -> Self -> (M (H := H) Self);
    recip `{H : State.Trait} : Self -> (M (H := H) Self);
    powi `{H : State.Trait} : Self -> i32 -> (M (H := H) Self);
    powf `{H : State.Trait} : Self -> Self -> (M (H := H) Self);
    sqrt `{H : State.Trait} : Self -> (M (H := H) Self);
    exp `{H : State.Trait} : Self -> (M (H := H) Self);
    exp2 `{H : State.Trait} : Self -> (M (H := H) Self);
    ln `{H : State.Trait} : Self -> (M (H := H) Self);
    log `{H : State.Trait} : Self -> Self -> (M (H := H) Self);
    log2 `{H : State.Trait} : Self -> (M (H := H) Self);
    log10 `{H : State.Trait} : Self -> (M (H := H) Self);
    to_degrees `{H : State.Trait} : Self -> (M (H := H) Self);
    to_radians `{H : State.Trait} : Self -> (M (H := H) Self);
    max `{H : State.Trait} : Self -> Self -> (M (H := H) Self);
    min `{H : State.Trait} : Self -> Self -> (M (H := H) Self);
    abs_sub `{H : State.Trait} : Self -> Self -> (M (H := H) Self);
    cbrt `{H : State.Trait} : Self -> (M (H := H) Self);
    hypot `{H : State.Trait} : Self -> Self -> (M (H := H) Self);
    sin `{H : State.Trait} : Self -> (M (H := H) Self);
    cos `{H : State.Trait} : Self -> (M (H := H) Self);
    tan `{H : State.Trait} : Self -> (M (H := H) Self);
    asin `{H : State.Trait} : Self -> (M (H := H) Self);
    acos `{H : State.Trait} : Self -> (M (H := H) Self);
    atan `{H : State.Trait} : Self -> (M (H := H) Self);
    atan2 `{H : State.Trait} : Self -> Self -> (M (H := H) Self);
    sin_cos `{H : State.Trait} : Self -> (M (H := H) (Self * Self));
    exp_m1 `{H : State.Trait} : Self -> (M (H := H) Self);
    ln_1p `{H : State.Trait} : Self -> (M (H := H) Self);
    sinh `{H : State.Trait} : Self -> (M (H := H) Self);
    cosh `{H : State.Trait} : Self -> (M (H := H) Self);
    tanh `{H : State.Trait} : Self -> (M (H := H) Self);
    asinh `{H : State.Trait} : Self -> (M (H := H) Self);
    acosh `{H : State.Trait} : Self -> (M (H := H) Self);
    atanh `{H : State.Trait} : Self -> (M (H := H) Self);
  }.
  
  Global Instance Method_min_value `{H : State.Trait} `(Trait)
    : Notation.Dot "min_value" := {
    Notation.dot := @min_value;
  }.
  Global Instance Method_min_positive_value `{H : State.Trait} `(Trait)
    : Notation.Dot "min_positive_value" := {
    Notation.dot := @min_positive_value;
  }.
  Global Instance Method_epsilon `{H : State.Trait} `(Trait)
    : Notation.Dot "epsilon" := {
    Notation.dot := @epsilon;
  }.
  Global Instance Method_max_value `{H : State.Trait} `(Trait)
    : Notation.Dot "max_value" := {
    Notation.dot := @max_value;
  }.
  Global Instance Method_floor `{H : State.Trait} `(Trait)
    : Notation.Dot "floor" := {
    Notation.dot := @floor;
  }.
  Global Instance Method_ceil `{H : State.Trait} `(Trait)
    : Notation.Dot "ceil" := {
    Notation.dot := @ceil;
  }.
  Global Instance Method_round `{H : State.Trait} `(Trait)
    : Notation.Dot "round" := {
    Notation.dot := @round;
  }.
  Global Instance Method_trunc `{H : State.Trait} `(Trait)
    : Notation.Dot "trunc" := {
    Notation.dot := @trunc;
  }.
  Global Instance Method_fract `{H : State.Trait} `(Trait)
    : Notation.Dot "fract" := {
    Notation.dot := @fract;
  }.
  Global Instance Method_abs `{H : State.Trait} `(Trait)
    : Notation.Dot "abs" := {
    Notation.dot := @abs;
  }.
  Global Instance Method_signum `{H : State.Trait} `(Trait)
    : Notation.Dot "signum" := {
    Notation.dot := @signum;
  }.
  Global Instance Method_is_sign_positive `{H : State.Trait} `(Trait)
    : Notation.Dot "is_sign_positive" := {
    Notation.dot := @is_sign_positive;
  }.
  Global Instance Method_is_sign_negative `{H : State.Trait} `(Trait)
    : Notation.Dot "is_sign_negative" := {
    Notation.dot := @is_sign_negative;
  }.
  Global Instance Method_mul_add `{H : State.Trait} `(Trait)
    : Notation.Dot "mul_add" := {
    Notation.dot := @mul_add;
  }.
  Global Instance Method_recip `{H : State.Trait} `(Trait)
    : Notation.Dot "recip" := {
    Notation.dot := @recip;
  }.
  Global Instance Method_powi `{H : State.Trait} `(Trait)
    : Notation.Dot "powi" := {
    Notation.dot := @powi;
  }.
  Global Instance Method_powf `{H : State.Trait} `(Trait)
    : Notation.Dot "powf" := {
    Notation.dot := @powf;
  }.
  Global Instance Method_sqrt `{H : State.Trait} `(Trait)
    : Notation.Dot "sqrt" := {
    Notation.dot := @sqrt;
  }.
  Global Instance Method_exp `{H : State.Trait} `(Trait)
    : Notation.Dot "exp" := {
    Notation.dot := @exp;
  }.
  Global Instance Method_exp2 `{H : State.Trait} `(Trait)
    : Notation.Dot "exp2" := {
    Notation.dot := @exp2;
  }.
  Global Instance Method_ln `{H : State.Trait} `(Trait) : Notation.Dot "ln" := {
    Notation.dot := @ln;
  }.
  Global Instance Method_log `{H : State.Trait} `(Trait)
    : Notation.Dot "log" := {
    Notation.dot := @log;
  }.
  Global Instance Method_log2 `{H : State.Trait} `(Trait)
    : Notation.Dot "log2" := {
    Notation.dot := @log2;
  }.
  Global Instance Method_log10 `{H : State.Trait} `(Trait)
    : Notation.Dot "log10" := {
    Notation.dot := @log10;
  }.
  Global Instance Method_to_degrees `{H : State.Trait} `(Trait)
    : Notation.Dot "to_degrees" := {
    Notation.dot := @to_degrees;
  }.
  Global Instance Method_to_radians `{H : State.Trait} `(Trait)
    : Notation.Dot "to_radians" := {
    Notation.dot := @to_radians;
  }.
  Global Instance Method_max `{H : State.Trait} `(Trait)
    : Notation.Dot "max" := {
    Notation.dot := @max;
  }.
  Global Instance Method_min `{H : State.Trait} `(Trait)
    : Notation.Dot "min" := {
    Notation.dot := @min;
  }.
  Global Instance Method_abs_sub `{H : State.Trait} `(Trait)
    : Notation.Dot "abs_sub" := {
    Notation.dot := @abs_sub;
  }.
  Global Instance Method_cbrt `{H : State.Trait} `(Trait)
    : Notation.Dot "cbrt" := {
    Notation.dot := @cbrt;
  }.
  Global Instance Method_hypot `{H : State.Trait} `(Trait)
    : Notation.Dot "hypot" := {
    Notation.dot := @hypot;
  }.
  Global Instance Method_sin `{H : State.Trait} `(Trait)
    : Notation.Dot "sin" := {
    Notation.dot := @sin;
  }.
  Global Instance Method_cos `{H : State.Trait} `(Trait)
    : Notation.Dot "cos" := {
    Notation.dot := @cos;
  }.
  Global Instance Method_tan `{H : State.Trait} `(Trait)
    : Notation.Dot "tan" := {
    Notation.dot := @tan;
  }.
  Global Instance Method_asin `{H : State.Trait} `(Trait)
    : Notation.Dot "asin" := {
    Notation.dot := @asin;
  }.
  Global Instance Method_acos `{H : State.Trait} `(Trait)
    : Notation.Dot "acos" := {
    Notation.dot := @acos;
  }.
  Global Instance Method_atan `{H : State.Trait} `(Trait)
    : Notation.Dot "atan" := {
    Notation.dot := @atan;
  }.
  Global Instance Method_atan2 `{H : State.Trait} `(Trait)
    : Notation.Dot "atan2" := {
    Notation.dot := @atan2;
  }.
  Global Instance Method_sin_cos `{H : State.Trait} `(Trait)
    : Notation.Dot "sin_cos" := {
    Notation.dot := @sin_cos;
  }.
  Global Instance Method_exp_m1 `{H : State.Trait} `(Trait)
    : Notation.Dot "exp_m1" := {
    Notation.dot := @exp_m1;
  }.
  Global Instance Method_ln_1p `{H : State.Trait} `(Trait)
    : Notation.Dot "ln_1p" := {
    Notation.dot := @ln_1p;
  }.
  Global Instance Method_sinh `{H : State.Trait} `(Trait)
    : Notation.Dot "sinh" := {
    Notation.dot := @sinh;
  }.
  Global Instance Method_cosh `{H : State.Trait} `(Trait)
    : Notation.Dot "cosh" := {
    Notation.dot := @cosh;
  }.
  Global Instance Method_tanh `{H : State.Trait} `(Trait)
    : Notation.Dot "tanh" := {
    Notation.dot := @tanh;
  }.
  Global Instance Method_asinh `{H : State.Trait} `(Trait)
    : Notation.Dot "asinh" := {
    Notation.dot := @asinh;
  }.
  Global Instance Method_acosh `{H : State.Trait} `(Trait)
    : Notation.Dot "acosh" := {
    Notation.dot := @acosh;
  }.
  Global Instance Method_atanh `{H : State.Trait} `(Trait)
    : Notation.Dot "atanh" := {
    Notation.dot := @atanh;
  }.
End Real.
*)
(* moved *)
Module NumOps.
  Unset Primitive Projections.
  Class Trait
      (Self : Set) {(* TODO *) Rhs (* TODO *) Output : option Set}
        `{core.ops.arith.Add.Trait Self (Rhs := (Rhs (* @TODO *)))}
        `{core.ops.arith.Sub.Trait Self (Rhs := (Rhs (* @TODO *)))}
        `{core.ops.arith.Mul.Trait Self (Rhs := (Rhs (* @TODO *)))}
        `{core.ops.arith.Div.Trait Self (Rhs := (Rhs (* @TODO *)))}
        `{core.ops.arith.Rem.Trait Self (Rhs := (Rhs (* @TODO *)))} :
      Set := {
  }.
  Global Set Primitive Projections.
End NumOps.

(* moved *)
Module Num.
  Class Trait
      (Self : Set)
        `{core.cmp.PartialEq.Trait Self (Rhs := None)}
        `{num_traits.identities.Zero.Trait Self}
        `{num_traits.identities.One.Trait Self}
        `{num_traits.NumOps.Trait Self (Rhs := None) (Output := None)}
      {FromStrRadixErr : Set} :
      Set := {
    FromStrRadixErr := FromStrRadixErr;
    from_str_radix
      `{H : State.Trait}
      :
      (ref str) ->
      u32 ->
      (M (H := H) (core.result.Result Self FromStrRadixErr));
  }.
  
  Global Instance
      Method_FromStrRadixErr
      `{H : State.Trait}
      {FromStrRadixErr}
      `(Trait
      (FromStrRadixErr := FromStrRadixErr))
    : Notation.DoubleColonType Self "FromStrRadixErr" := {
    Notation.double_colon_type := FromStrRadixErr;
  }.
  Global Instance Method_from_str_radix `{H : State.Trait} `(Trait)
    : Notation.Dot "from_str_radix" := {
    Notation.dot := @from_str_radix;
  }.
End Num.

Module sign.
  (*
  Module Signed.
    Class Trait
        (Self : Set)
          `{core.marker.Sized.Trait Self}
          `{num_traits.Num.Trait Self}
          `{core.ops.arith.Neg.Trait Self} :
        Set := {
      abs `{H : State.Trait} : (ref Self) -> (M (H := H) Self);
      abs_sub
        `{H : State.Trait}
        :
        (ref Self) -> (ref Self) -> (M (H := H) Self);
      signum `{H : State.Trait} : (ref Self) -> (M (H := H) Self);
      is_positive `{H : State.Trait} : (ref Self) -> (M (H := H) bool);
      is_negative `{H : State.Trait} : (ref Self) -> (M (H := H) bool);
    }.
    
    Global Instance Method_abs `{H : State.Trait} `(Trait)
      : Notation.Dot "abs" := {
      Notation.dot := @abs;
    }.
    Global Instance Method_abs_sub `{H : State.Trait} `(Trait)
      : Notation.Dot "abs_sub" := {
      Notation.dot := @abs_sub;
    }.
    Global Instance Method_signum `{H : State.Trait} `(Trait)
      : Notation.Dot "signum" := {
      Notation.dot := @signum;
    }.
    Global Instance Method_is_positive `{H : State.Trait} `(Trait)
      : Notation.Dot "is_positive" := {
      Notation.dot := @is_positive;
    }.
    Global Instance Method_is_negative `{H : State.Trait} `(Trait)
      : Notation.Dot "is_negative" := {
      Notation.dot := @is_negative;
    }.
  End Signed.
  
  Parameter abs : forall `{H : State.Trait},
      forall
      {T : Set},
      forall `{num_traits.sign.Signed.Trait T}, T ->
      M (H := H) T.
  
  Parameter abs_sub : forall `{H : State.Trait},
      forall
      {T : Set},
      forall `{num_traits.sign.Signed.Trait T}, T ->
      T ->
      M (H := H) T.
  
  Parameter signum : forall `{H : State.Trait},
      forall
      {T : Set},
      forall `{num_traits.sign.Signed.Trait T}, T ->
      M (H := H) T.
  *)
  Module Unsigned.
    Unset Primitive Projections.
    Class Trait (Self : Set) `{num_traits.Num.Trait Self} : Set := {
    }.
    Global Set Primitive Projections.
  End Unsigned.
End sign.
(*
Module Signed.
  Class Trait
      (Self : Set)
        `{core.marker.Sized.Trait Self}
        `{num_traits.Num.Trait Self}
        `{core.ops.arith.Neg.Trait Self} :
      Set := {
    abs `{H : State.Trait} : (ref Self) -> (M (H := H) Self);
    abs_sub `{H : State.Trait} : (ref Self) -> (ref Self) -> (M (H := H) Self);
    signum `{H : State.Trait} : (ref Self) -> (M (H := H) Self);
    is_positive `{H : State.Trait} : (ref Self) -> (M (H := H) bool);
    is_negative `{H : State.Trait} : (ref Self) -> (M (H := H) bool);
  }.
  
  Global Instance Method_abs `{H : State.Trait} `(Trait)
    : Notation.Dot "abs" := {
    Notation.dot := @abs;
  }.
  Global Instance Method_abs_sub `{H : State.Trait} `(Trait)
    : Notation.Dot "abs_sub" := {
    Notation.dot := @abs_sub;
  }.
  Global Instance Method_signum `{H : State.Trait} `(Trait)
    : Notation.Dot "signum" := {
    Notation.dot := @signum;
  }.
  Global Instance Method_is_positive `{H : State.Trait} `(Trait)
    : Notation.Dot "is_positive" := {
    Notation.dot := @is_positive;
  }.
  Global Instance Method_is_negative `{H : State.Trait} `(Trait)
    : Notation.Dot "is_negative" := {
    Notation.dot := @is_negative;
  }.
End Signed.

Parameter abs : forall `{H : State.Trait},
    forall
    {T : Set},
    forall `{num_traits.sign.Signed.Trait T}, T ->
    M (H := H) T.

Parameter abs_sub : forall `{H : State.Trait},
    forall
    {T : Set},
    forall `{num_traits.sign.Signed.Trait T}, T ->
    T ->
    M (H := H) T.

Parameter signum : forall `{H : State.Trait},
    forall
    {T : Set},
    forall `{num_traits.sign.Signed.Trait T}, T ->
    M (H := H) T.

Module Unsigned.
  Unset Primitive Projections.
  Class Trait (Self : Set) `{num_traits.Num.Trait Self} : Set := {
  }.
  Global Set Primitive Projections.
End Unsigned.
*)
(* moved the Num module *)
(* moved the NumOps module *)
(*
Module NumRef.
  Unset Primitive Projections.
  Class Trait
      (Self : Set)
        `{num_traits.Num.Trait Self}
        `{num_traits.NumOps.Trait
          Self
          (Rhs := (Some ref Self))
          (Output := None)} :
      Set := {
  }.
  Global Set Primitive Projections.
End NumRef.

Module RefNum.
  Unset Primitive Projections.
  Class Trait
      (Self : Set)
        `{num_traits.NumOps.Trait
          Self
          (Rhs := (Some Base))
          (Output := (Some Base))}
        `{num_traits.NumOps.Trait
          Self
          (Rhs := (Some ref Base))
          (Output := (Some Base))}
        {Base : Set} :
      Set := {
  }.
  Global Set Primitive Projections.
End RefNum.

Module NumAssignOps.
  Unset Primitive Projections.
  Class Trait
      (Self : Set)
        `{core.ops.arith.AddAssign.Trait Self (Rhs := (Some Rhs))}
        `{core.ops.arith.SubAssign.Trait Self (Rhs := (Some Rhs))}
        `{core.ops.arith.MulAssign.Trait Self (Rhs := (Some Rhs))}
        `{core.ops.arith.DivAssign.Trait Self (Rhs := (Some Rhs))}
        `{core.ops.arith.RemAssign.Trait Self (Rhs := (Some Rhs))}
        {(* TODO *) Rhs : Set} :
      Set := {
  }.
  Global Set Primitive Projections.
End NumAssignOps.

Module NumAssign.
  Unset Primitive Projections.
  Class Trait
      (Self : Set)
        `{num_traits.Num.Trait Self}
        `{num_traits.NumAssignOps.Trait Self (Rhs := None)} :
      Set := {
  }.
  Global Set Primitive Projections.
End NumAssign.

Module NumAssignRef.
  Unset Primitive Projections.
  Class Trait
      (Self : Set)
        `{num_traits.NumAssign.Trait Self}
        `{num_traits.NumAssignOps.Trait Self (Rhs := (Some ref Self))} :
      Set := {
  }.
  Global Set Primitive Projections.
End NumAssignRef.

Module FloatErrorKind.
  Inductive t : Set :=
  | Empty
  | Invalid.
End FloatErrorKind.
Definition FloatErrorKind := FloatErrorKind.t.

Module ParseFloatError.
  Unset Primitive Projections.
  Record t : Set := {
    kind : num_traits.FloatErrorKind;
  }.
  Global Set Primitive Projections.
  
  Global Instance Get_kind : Notation.Dot "kind" := {
    Notation.dot '(Build_t x0) := x0;
  }.
End ParseFloatError.
Definition ParseFloatError : Set := @ParseFloatError.t.

Parameter clamp : forall `{H : State.Trait},
    forall
    {T : Set},
    forall `{core.cmp.PartialOrd.Trait T (Rhs := None)}, T ->
    T ->
    T ->
    M (H := H) T.

Parameter clamp_min : forall `{H : State.Trait},
    forall
    {T : Set},
    forall `{core.cmp.PartialOrd.Trait T (Rhs := None)}, T ->
    T ->
    M (H := H) T.

Parameter clamp_max : forall `{H : State.Trait},
    forall
    {T : Set},
    forall `{core.cmp.PartialOrd.Trait T (Rhs := None)}, T ->
    T ->
    M (H := H) T.
*)
