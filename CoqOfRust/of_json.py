"""
Utility functions to generate Coq files from the JSON generated by `coq-of-rust`.
"""


from typing import Any, Tuple


def find_top_level_items(prefix: list[str], top_level, condition) -> list[Tuple[list[str], Any]]:
    results = []
    for entry in top_level:
        item = entry["item"]
        if condition(item):
            results += [(prefix, item)]
        if "Module" in item:
            module = item["Module"]
            results += find_top_level_items(prefix + [module["name"]], module["body"], condition)
    return results


def find_top_level_item_by_name(crate: str, top_level, name: str) -> Tuple[list[str], Any]:
    def item_has_name(item):
        if isinstance(item, dict):
            item = next(iter(item.values()))
            return "name" in item and item["name"] == name
        return False

    results = find_top_level_items(
        [crate],
        top_level,
        item_has_name,
    )
    if len(results) == 1:
        return results[0]
    if len(results) > 1:
        raise Exception("Multiple items found: " + name)
    raise Exception("Item not found: " + name)


def find_top_level_items_by_kind_in(
    crate: str,
    top_level,
    kinds: list[str],
) -> list[Tuple[list[str], Any]]:
    return find_top_level_items(
        [crate],
        top_level,
        lambda item: any(kind in item for kind in kinds),
    )


def get_header(imports: list[str]) -> str:
    return """(* Generated file. Do not edit. *)
Require Import CoqOfRust.CoqOfRust.
Require Import links.M.
""" + "".join("Require " + import_ + ".\n" for import_ in imports)


def indent(s: str) -> str:
    return "\n".join(
        # We do not indent empty lines
        "  " + line if len(line) > 0 else ""
        for line in s.split("\n")
    )


def paren(with_paren: bool, s: str) -> str:
    if with_paren:
        return "(" + s + ")"
    return s


def pp_path(path) -> str:
    if path == ["i8"]:
        return "I8"
    if path == ["i16"]:
        return "I16"
    if path == ["i32"]:
        return "I32"
    if path == ["i64"]:
        return "I64"
    if path == ["i128"]:
        return "I128"
    if path == ["isize"]:
        return "Isize"
    if path == ["u8"]:
        return "U8"
    if path == ["u16"]:
        return "U16"
    if path == ["u32"]:
        return "U32"
    if path == ["u64"]:
        return "U64"
    if path == ["u128"]:
        return "U128"
    if path == ["usize"]:
        return "Usize"

    # We limit the size of the path for readability, and count on the user to make the
    # right file imports in case of name collisions
    return ".".join(path[-2:])

def pp_const(const) -> str:
    if "Literal" in const:
        const = const["Literal"]
        if "Integer" in const:
            integer = const["Integer"]
            return str(integer["value"])
        return "Unknown literal " + str(const)
    return "Unknown const " + str(const)



def pp_type(with_paren: bool, item) -> str:
    if "Var" in item:
        item = item["Var"]
        return item["name"]
    if "Path" in item:
        item = item["Path"]
        path = item["path"]
        if path == ["&"]:
            return "Ref.t Pointer.Kind.Ref"
        if path == ["&mut"]:
            return "Ref.t Pointer.Kind.MutRef"
        if path == ["*const"]:
            return "Ref.t Pointer.Kind.ConstPointer"
        if path == ["*mut"]:
            return "Ref.t Pointer.Kind.MutPointer"
        if path == ["bool"]:
            return "bool"
        return pp_path(path) + ".t"
    if "Application" in item:
        item = item["Application"]
        return paren(
            with_paren and len(item["consts"]) + len(item["tys"]) > 0,
            " ".join(
                [pp_type(True, item["func"])] +
                [pp_const(const) for const in item["consts"]] +
                [pp_type(True, ty) for ty in item["tys"]]
            )
        )
    if "Tuple" in item:
        item = item["Tuple"]
        return paren(
            with_paren,
            " * ".join(pp_type(True, ty) for ty in item["tys"])
        )
    if "Function" in item:
        item = item["Function"]
        return paren(
            with_paren,
            " ".join(
                ["Function" + str(len(item["args"])) + ".t"] +
                [pp_type(True, arg) for arg in item["args"]] +
                [pp_type(True, item["ret"])]
            )
        )
    return "Unknown type " + str(item)


def pp_type_struct_struct(prefix: list[str], item) -> str:
    def get_ty_params(is_implicit: bool) -> str:
        if len(item["ty_params"]) != 0:
            return \
                ("{" if is_implicit else "(") + \
                " ".join(item["ty_params"]) + \
                ": Set" + \
                ("}" if is_implicit else ")") + \
                " "
        else:
            return ""

    def get_applied_ty() -> str:
        if len(item["ty_params"]) != 0:
            return "t" + "".join(" " + ty_param for ty_param in item["ty_params"])
        else:
            return "t"

    ty_params_links = "".join("`{Link " + ty_param + "} " for ty_param in item["ty_params"])
    full_name = "::".join(prefix + [item["name"]])
    return pp_module(item["name"],
        "Record t " + get_ty_params(True) + ": Set := {\n" +
        indent("".join(
            field[0] + ": " + pp_type(False, field[1]) + ";\n"
            for field in item["fields"]
        )) +
        "}.\n" +
        ("Arguments Build_t {" + " ".join(["_"] * len(item["ty_params"])) + "}.\n" +
        "Arguments t : clear implicits.\n"
        if len(item["ty_params"]) > 0
        else ""
        ) +
        "\n" +
        "Global Instance IsLink " + get_ty_params(True) + ty_params_links + ": Link " +
        paren(len(item["ty_params"]) > 0, " ".join(["t"] + item["ty_params"])) +
        " := {\n" +
        indent(
            "Φ := Ty.path \"" + full_name + "\";\n" +
            "φ '(Build_t" + "".join(" " + field[0] for field in item["fields"]) + ") :=\n" +
            indent(
                f"Value.StructRecord \"{full_name}\" [\n" +
                indent(";\n".join(
                    "(\"" + field[0] + "\", φ " + field[0] + ")"
                    for field in item["fields"]
                )) + "\n" +
                "]\n"
            )
        ) +
        "}."
    )


def pp_type_struct_tuple(prefix: list[str], item) -> str:
    if len(item["ty_params"]) != 0:
        ty_params = "(" + " ".join(item["ty_params"]) + ": Set) "
    else:
        ty_params = ""
    ty_params_links = "".join("`{Link " + ty_param + "} " for ty_param in item["ty_params"])
    return pp_module(item["name"],
        "Inductive t " + ty_params + ": Set :=\n" +
        "| Make :" +
        "".join(
            " " + pp_type(False, field) + " ->"
            for field in item["fields"]
        ) +
        " t" + "".join(" " + ty_param for ty_param in item["ty_params"]) + ".\n" +
        ("Arguments Make {" + " ".join(["_"] * len(item["ty_params"])) + "}.\n"
        if len(item["ty_params"]) > 0
        else ""
        ) +
        "\n" +
        "Global Instance IsLink " + ty_params + ty_params_links + ": Link " +
        paren(len(item["ty_params"]) > 0, " ".join(["t"] + item["ty_params"])) +
        " := {\n" +
        indent(
            "to_ty := Ty.path \"" + "::".join(prefix + [item["name"]]) + "\";\n" +
            "to_value '(Make" + "".join(" x" + str(index) for index in range(len(item["fields"]))) + ") :=\n" +
            indent(
                "Value.StructTuple \"" + "::".join(prefix + [item["name"]]) + "\" [" +
                "; ".join("to_value x" + str(index) for index in range(len(item["fields"]))) + "];\n"
            )
        ) +
        "}."
    )


def pp_type_enum(prefix: list[str], item) -> str:
    name = item["name"]
    variants = item["variants"]

    if len(item["ty_params"]) != 0:
        ty_params = "(" + " ".join(item["ty_params"]) + ": Set) "
        ty_params_args = "".join(" " + ty_param for ty_param in item["ty_params"])
    else:
        ty_params = ""
        ty_params_args = ""

    # Generate the inductive type definition
    inductive_def = f"Inductive t {ty_params}: Set :=\n"
    for variant in variants:
        variant_name = variant["name"]
        if "Tuple" in variant["item"]:
            tys = variant["item"]["Tuple"]["tys"]
            inductive_def += f"| {variant_name}"
            for ty in tys:
                inductive_def += "\n"
                inductive_def += indent(f"(_ : {pp_type(False, ty)})")
            inductive_def += "\n"
        else:
            fields = variant["item"]["Struct"]["fields"]
            inductive_def += f"| {variant_name}\n"
            inductive_def += indent('\n'.join(f"({field[0]} : {pp_type(False, field[1])})" for field in fields))
            inductive_def += "\n"
    inductive_def += ".\n"

    # Generate the Arguments line if there are type parameters
    arguments_line = (f"Arguments {' '.join(variant['name'] for variant in variants)} " +
                      "{" + " ".join(["_"] * len(item["ty_params"])) + "}.\n"
                     ) if len(item["ty_params"]) > 0 else ""

    is_link = f"Global Instance IsLink {ty_params}: Link t{ty_params_args} := {{\n"
    is_link += indent(f"Φ := Ty.path \"{'::'.join(prefix + [name])}\";\n")
    is_link += indent("φ x :=\n")
    is_link += indent(indent("match x with\n"))
    for variant in variants:
        variant_name = variant["name"]
        if "Tuple" in variant["item"]:
            is_link += indent(indent(
                f'| {variant_name}{"".join(f" γ{index}" for index, _ in enumerate(variant["item"]["Tuple"]["tys"]))} =>\n'
            ))
        else:
            is_link += indent(indent(
                f'| {variant_name}{"".join(f" {field[0]}" for field in variant["item"]["Struct"]["fields"])} =>\n'
            ))
        if "Tuple" in variant["item"]:
            is_link += indent(indent(indent(
                f"Value.StructTuple \"{'::'.join(prefix + [name, variant_name])}\" [" +
                (
                    ""
                    if len(variant['item']['Tuple']['tys']) == 0
                    else
                        "\n" +
                        indent(
                            ";\n".join(f'φ γ{index}'
                            for index, _ in enumerate(variant['item']['Tuple']['tys']))
                        ) + "\n"
                ) +
                "]\n"
            )))
        else:
            is_link += indent(indent(indent(
                f"Value.StructRecord \"{'::'.join(prefix + [name, variant_name])}\" [" +
                (
                    ""
                    if len(variant['item']['Struct']['fields']) == 0
                    else
                        "\n" +
                        indent(
                            ';\n'.join(f'("{field[0]}", φ {field[0]})'
                            for field in variant['item']['Struct']['fields'])
                        ) + "\n"
                ) +
                "]\n"
            )))
    is_link += indent(indent("end\n"))
    is_link += "}."

    of_ty = f'Definition of_ty : OfTy.t (Ty.path "{"::".join(prefix + [name])}").\n'
    of_ty += """Proof. eapply OfTy.Make with (A := t); reflexivity. Defined.
Smpl Add simple apply of_ty : of_ty."""

    of_value_with = ""
    for variant in variants:
        variant_name = variant["name"]
        of_value_with += f"\n\nLemma of_value_with_{variant_name}"
        if "Tuple" in variant["item"]:
            variant = variant["item"]["Tuple"]
            for index, ty in enumerate(variant["tys"]):
                of_value_with += "\n"
                of_value_with += indent(f"(γ{index} : {pp_type(False, ty)}) (γ{index}' : Value.t)")
            of_value_with += " :\n"
            for index, ty in enumerate(variant["tys"]):
                of_value_with += indent(f"γ{index}' = φ γ{index} ->\n")
            of_value_with += indent(
                f"Value.StructTuple \"{'::'.join(prefix + [name, variant_name])}\" [" +
                (
                    ""
                    if len(variant['tys']) == 0
                    else
                        "\n" +
                        indent(
                            ";\n".join(f'γ{index}'
                            for index, _ in enumerate(variant['tys']))
                        ) + "\n"
                ) +
                "] =\n" +
                "φ " + paren(len(variant['tys']) > 0,
                    f"{variant_name}{''.join(f' γ{index}' for index, _ in enumerate(variant['tys']))}"
                ) + ".\n"
            )
        else:
            variant = variant["item"]["Struct"]
            for field in variant["fields"]:
                of_value_with += "\n"
                of_value_with += indent(f"({field[0]} : {pp_type(False, field[1])}) ({field[0]}' : Value.t)")
            of_value_with += " :\n"
            for field in variant["fields"]:
                of_value_with += indent(f"{field[0]}' = φ {field[0]} ->\n")
            of_value_with += indent(
                f"Value.StructRecord \"{'::'.join(prefix + [name, variant_name])}\" [\n" +
                indent(
                    ';\n'.join(f'("{field[0]}", {field[0]}\')'
                    for field in variant['fields'])
                ) + "\n"
                "] =\n" +
                f"φ ({variant_name}{''.join(f' {field[0]}' for field in variant['fields'])}).\n"
            )
        of_value_with += f"""Proof. now intros; subst. Qed.
Smpl Add simple apply of_value_with_{variant_name} : of_value."""

    of_value = ""
    for variant in variants:
        variant_name = variant["name"]
        of_value += f"\n\nDefinition of_value_{variant_name}"
        if "Tuple" in variant["item"]:
            variant = variant["item"]["Tuple"]
            for index, ty in enumerate(variant["tys"]):
                of_value += "\n"
                of_value += indent(f"(γ{index} : {pp_type(False, ty)}) (γ{index}' : Value.t)")
            of_value += " :\n"
            for index, ty in enumerate(variant["tys"]):
                of_value += indent(f"γ{index}' = φ γ{index} ->\n")
            of_value += indent(
                "OfValue.t (\n" + indent(
                    f"Value.StructTuple \"{'::'.join(prefix + [name, variant_name])}\" [" +
                    (
                        ""
                        if len(variant['tys']) == 0
                        else
                            "\n" +
                            indent(
                                ";\n".join(f'γ{index}'
                                for index, _ in enumerate(variant['tys']))
                            ) + "\n"
                    ) +
                    "]"
                ) + "\n" +
                ").\n"
            )
        else:
            variant = variant["item"]["Struct"]
            for field in variant["fields"]:
                of_value += "\n"
                of_value += indent(f"({field[0]} : {pp_type(False, field[1])}) ({field[0]}' : Value.t)")
            of_value += " :\n"
            for field in variant["fields"]:
                of_value += indent(f"{field[0]}' = φ {field[0]} ->\n")
            of_value += indent(
                "OfValue.t (\n" + indent(
                    f"Value.StructRecord \"{'::'.join(prefix + [name, variant_name])}\" [\n" +
                    indent(
                        ';\n'.join(f'("{field[0]}", {field[0]}\')'
                        for field in variant['fields'])
                    ) + "\n"
                    "]"
                ) + "\n" +
                ").\n"
            )
        of_value += f"""Proof. econstructor; apply of_value_with_{variant_name}; eassumption. Defined.
Smpl Add simple apply of_value_{variant_name} : of_value."""

    sub_pointers = []
    for variant in variants:
        variant_name = variant["name"]
        fields = \
            [*enumerate(variant["item"]["Tuple"]["tys"])] \
            if "Tuple" in variant["item"] \
            else variant["item"]["Struct"]["fields"]
        for index, ty in fields:
            sub_pointer = f"Definition get_{variant_name}_{index} : SubPointer.Runner.t t\n"
            if "Tuple" in variant["item"]:
                sub_pointer += indent(f'(Pointer.Index.StructTuple "{"::".join(prefix + [name, variant_name])}" {index}) :=\n')
            else:
                sub_pointer += indent(f'(Pointer.Index.StructRecord "{"::".join(prefix + [name, variant_name])}" "{index}") :=\n')
            sub_pointer += "{|\n"
            sub_pointer += indent("SubPointer.Runner.projection (γ : t) :=\n")
            sub_pointer += indent(indent("match γ with\n"))
            pattern = " ".join(
                [variant_name] +
                [
                    (
                        f"γ_{current_index}"
                        if current_index == index
                        else "_"
                    )
                    for current_index, _ in fields
                ]
            )
            sub_pointer += indent(indent(f"| {pattern} => Some γ_{index}\n"))
            if len(variants) >= 2:
                sub_pointer += indent(indent("| _ => None\n"))
            sub_pointer += indent(indent("end;\n"))
            sub_pointer += indent(f"SubPointer.Runner.injection (γ : t) (γ_{index} : {pp_type(False, ty)}) :=\n")
            sub_pointer += indent(indent("match γ with\n"))
            pattern = " ".join(
                [variant_name] +
                [
                    (
                        f"γ_{current_index}"
                        if current_index != index
                        else "_"
                    )
                    for current_index, _ in fields
                ]
            )
            new_expression = " ".join(
                [variant_name] +
                [
                    f"γ_{current_index}"
                    for current_index, _ in fields
                ]
            )
            sub_pointer += indent(indent(f"| {pattern} => Some ({new_expression})\n"))
            if len(variants) >= 2:
                sub_pointer += indent(indent("| _ => None\n"))
            sub_pointer += indent(indent("end;\n"))
            sub_pointer += "|}.\n\n"
            sub_pointer += f"Lemma get_{variant_name}_{index}_is_valid : SubPointer.Runner.Valid.t get_{variant_name}_{index}.\n"
            sub_pointer += "Proof. sauto lq: on. Qed.\n"
            sub_pointer += f"Smpl Add apply get_{variant_name}_{index}_is_valid : run_sub_pointer."
            sub_pointers += [sub_pointer]

    return pp_module(name,
        inductive_def +
        arguments_line +
        "\n" +
        is_link +
        "\n\n" +
        of_ty +
        of_value_with +
        of_value +
        "\n\n" +
        pp_module("SubPointer", "\n\n".join(sub_pointers))
    )


def pp_top_level_item(prefix: list[str], item) -> str:
    if "TypeStructStruct" in item:
        item = item["TypeStructStruct"]
        return pp_type_struct_struct(prefix, item)
    if "TypeStructTuple" in item:
        item = item["TypeStructTuple"]
        return pp_type_struct_tuple(prefix, item)
    if "TypeEnum" in item:
        item = item["TypeEnum"]
        return pp_type_enum(prefix, item)
    return "Unknown item type " + str(item)


def pp_module(name: str, content: str) -> str:
    return \
        "Module " + name + ".\n" + \
        indent(content) + "\n" + \
        "End " + name + "."
