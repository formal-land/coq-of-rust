(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module arch.
  Module execution.
    Axiom Result :
      forall (T : Ty.t),
      (Ty.apply (Ty.path "openvm_circuit::arch::execution::Result") [] [ T ]) =
        (Ty.apply
          (Ty.path "core::result::Result")
          []
          [ T; Ty.path "openvm_circuit::arch::execution::ExecutionError" ]).
    
    (*
    Enum ExecutionError
    {
      const_params := [];
      ty_params := [];
      variants :=
        [
          {
            name := "Fail";
            item := StructRecord [ ("pc", Ty.path "u32") ];
          };
          {
            name := "PcNotFound";
            item :=
              StructRecord
                [
                  ("pc", Ty.path "u32");
                  ("step", Ty.path "u32");
                  ("pc_base", Ty.path "u32");
                  ("program_len", Ty.path "usize")
                ];
          };
          {
            name := "PcOutOfBounds";
            item :=
              StructRecord
                [
                  ("pc", Ty.path "u32");
                  ("step", Ty.path "u32");
                  ("pc_base", Ty.path "u32");
                  ("program_len", Ty.path "usize")
                ];
          };
          {
            name := "DisabledOperation";
            item :=
              StructRecord
                [ ("pc", Ty.path "u32"); ("opcode", Ty.path "openvm_instructions::VmOpcode") ];
          };
          {
            name := "HintOutOfBounds";
            item := StructRecord [ ("pc", Ty.path "u32") ];
          };
          {
            name := "PublicValueIndexOutOfBounds";
            item :=
              StructRecord
                [
                  ("pc", Ty.path "u32");
                  ("num_public_values", Ty.path "usize");
                  ("public_value_index", Ty.path "usize")
                ];
          };
          {
            name := "PublicValueNotEqual";
            item :=
              StructRecord
                [
                  ("pc", Ty.path "u32");
                  ("public_value_index", Ty.path "usize");
                  ("existing_value", Ty.path "usize");
                  ("new_value", Ty.path "usize")
                ];
          };
          {
            name := "PhantomNotFound";
            item :=
              StructRecord
                [
                  ("pc", Ty.path "u32");
                  ("discriminant", Ty.path "openvm_instructions::phantom::PhantomDiscriminant")
                ];
          };
          {
            name := "Phantom";
            item :=
              StructRecord
                [
                  ("pc", Ty.path "u32");
                  ("discriminant", Ty.path "openvm_instructions::phantom::PhantomDiscriminant");
                  ("inner", Ty.path "eyre::Report")
                ];
          };
          {
            name := "DidNotTerminate";
            item := StructTuple [];
          };
          {
            name := "FailedWithExitCode";
            item := StructTuple [ Ty.path "u32" ];
          }
        ];
    }
    *)
    
    Axiom IsDiscriminant_ExecutionError_Fail :
      M.IsDiscriminant "openvm_circuit::arch::execution::ExecutionError::Fail" 0.
    Axiom IsDiscriminant_ExecutionError_PcNotFound :
      M.IsDiscriminant "openvm_circuit::arch::execution::ExecutionError::PcNotFound" 1.
    Axiom IsDiscriminant_ExecutionError_PcOutOfBounds :
      M.IsDiscriminant "openvm_circuit::arch::execution::ExecutionError::PcOutOfBounds" 2.
    Axiom IsDiscriminant_ExecutionError_DisabledOperation :
      M.IsDiscriminant "openvm_circuit::arch::execution::ExecutionError::DisabledOperation" 3.
    Axiom IsDiscriminant_ExecutionError_HintOutOfBounds :
      M.IsDiscriminant "openvm_circuit::arch::execution::ExecutionError::HintOutOfBounds" 4.
    Axiom IsDiscriminant_ExecutionError_PublicValueIndexOutOfBounds :
      M.IsDiscriminant
        "openvm_circuit::arch::execution::ExecutionError::PublicValueIndexOutOfBounds"
        5.
    Axiom IsDiscriminant_ExecutionError_PublicValueNotEqual :
      M.IsDiscriminant "openvm_circuit::arch::execution::ExecutionError::PublicValueNotEqual" 6.
    Axiom IsDiscriminant_ExecutionError_PhantomNotFound :
      M.IsDiscriminant "openvm_circuit::arch::execution::ExecutionError::PhantomNotFound" 7.
    Axiom IsDiscriminant_ExecutionError_Phantom :
      M.IsDiscriminant "openvm_circuit::arch::execution::ExecutionError::Phantom" 8.
    Axiom IsDiscriminant_ExecutionError_DidNotTerminate :
      M.IsDiscriminant "openvm_circuit::arch::execution::ExecutionError::DidNotTerminate" 9.
    Axiom IsDiscriminant_ExecutionError_FailedWithExitCode :
      M.IsDiscriminant "openvm_circuit::arch::execution::ExecutionError::FailedWithExitCode" 10.
    
    Module Impl_core_error_Error_for_openvm_circuit_arch_execution_ExecutionError.
      Definition Self : Ty.t := Ty.path "openvm_circuit::arch::execution::ExecutionError".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::error::Error"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [].
    End Impl_core_error_Error_for_openvm_circuit_arch_execution_ExecutionError.
    
    Module Impl_core_fmt_Display_for_openvm_circuit_arch_execution_ExecutionError.
      Definition Self : Ty.t := Ty.path "openvm_circuit::arch::execution::ExecutionError".
      
      (* Error *)
      Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; __formatter ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.path "openvm_circuit::arch::execution::ExecutionError" ],
                self
              |) in
            let __formatter :=
              M.alloc (|
                Ty.apply (Ty.path "&mut") [] [ Ty.path "core::fmt::Formatter" ],
                __formatter
              |) in
            M.match_operator (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.deref (| M.read (| γ |) |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "openvm_circuit::arch::execution::ExecutionError::Fail",
                        "pc"
                      |) in
                    let pc := M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "u32" ], γ1_0 |) in
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                      M.get_associated_function (|
                        Ty.path "core::fmt::Formatter",
                        "write_fmt",
                        [],
                        []
                      |),
                      [
                        M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| __formatter |) |) |);
                        M.call_closure (|
                          Ty.path "core::fmt::Arguments",
                          M.get_associated_function (|
                            Ty.path "core::fmt::Arguments",
                            "new_v1",
                            [ Value.Integer IntegerKind.Usize 1; Value.Integer IntegerKind.Usize 1
                            ],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.alloc (|
                                    Ty.apply
                                      (Ty.path "array")
                                      [ Value.Integer IntegerKind.Usize 1 ]
                                      [ Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ],
                                    Value.Array [ mk_str (| "execution failed at pc " |) ]
                                  |)
                                |)
                              |)
                            |);
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.alloc (|
                                    Ty.apply
                                      (Ty.path "array")
                                      [ Value.Integer IntegerKind.Usize 1 ]
                                      [ Ty.path "core::fmt::rt::Argument" ],
                                    Value.Array
                                      [
                                        M.call_closure (|
                                          Ty.path "core::fmt::rt::Argument",
                                          M.get_associated_function (|
                                            Ty.path "core::fmt::rt::Argument",
                                            "new_display",
                                            [],
                                            [ Ty.apply (Ty.path "&") [] [ Ty.path "u32" ] ]
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.alloc (|
                                                    Ty.apply (Ty.path "&") [] [ Ty.path "u32" ],
                                                    M.call_closure (|
                                                      Ty.apply (Ty.path "&") [] [ Ty.path "u32" ],
                                                      M.get_trait_method (|
                                                        "thiserror::display::AsDisplay",
                                                        Ty.apply (Ty.path "&") [] [ Ty.path "u32" ],
                                                        [],
                                                        [],
                                                        "as_display",
                                                        [],
                                                        []
                                                      |),
                                                      [ M.borrow (| Pointer.Kind.Ref, pc |) ]
                                                    |)
                                                  |)
                                                |)
                                              |)
                                            |)
                                          ]
                                        |)
                                      ]
                                  |)
                                |)
                              |)
                            |)
                          ]
                        |)
                      ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.deref (| M.read (| γ |) |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "openvm_circuit::arch::execution::ExecutionError::PcNotFound",
                        "pc"
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "openvm_circuit::arch::execution::ExecutionError::PcNotFound",
                        "step"
                      |) in
                    let γ1_2 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "openvm_circuit::arch::execution::ExecutionError::PcNotFound",
                        "pc_base"
                      |) in
                    let γ1_3 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "openvm_circuit::arch::execution::ExecutionError::PcNotFound",
                        "program_len"
                      |) in
                    let pc := M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "u32" ], γ1_0 |) in
                    let step := M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "u32" ], γ1_1 |) in
                    let pc_base :=
                      M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "u32" ], γ1_2 |) in
                    let program_len :=
                      M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "usize" ], γ1_3 |) in
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                      M.get_associated_function (|
                        Ty.path "core::fmt::Formatter",
                        "write_fmt",
                        [],
                        []
                      |),
                      [
                        M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| __formatter |) |) |);
                        M.call_closure (|
                          Ty.path "core::fmt::Arguments",
                          M.get_associated_function (|
                            Ty.path "core::fmt::Arguments",
                            "new_v1",
                            [ Value.Integer IntegerKind.Usize 4; Value.Integer IntegerKind.Usize 4
                            ],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.alloc (|
                                    Ty.apply
                                      (Ty.path "array")
                                      [ Value.Integer IntegerKind.Usize 4 ]
                                      [ Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ],
                                    Value.Array
                                      [
                                        mk_str (| "pc " |);
                                        mk_str (| " not found for program of length " |);
                                        mk_str (| ", with pc_base " |);
                                        mk_str (| " and step = " |)
                                      ]
                                  |)
                                |)
                              |)
                            |);
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.alloc (|
                                    Ty.apply
                                      (Ty.path "array")
                                      [ Value.Integer IntegerKind.Usize 4 ]
                                      [ Ty.path "core::fmt::rt::Argument" ],
                                    Value.Array
                                      [
                                        M.call_closure (|
                                          Ty.path "core::fmt::rt::Argument",
                                          M.get_associated_function (|
                                            Ty.path "core::fmt::rt::Argument",
                                            "new_display",
                                            [],
                                            [ Ty.apply (Ty.path "&") [] [ Ty.path "u32" ] ]
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.alloc (|
                                                    Ty.apply (Ty.path "&") [] [ Ty.path "u32" ],
                                                    M.call_closure (|
                                                      Ty.apply (Ty.path "&") [] [ Ty.path "u32" ],
                                                      M.get_trait_method (|
                                                        "thiserror::display::AsDisplay",
                                                        Ty.apply (Ty.path "&") [] [ Ty.path "u32" ],
                                                        [],
                                                        [],
                                                        "as_display",
                                                        [],
                                                        []
                                                      |),
                                                      [ M.borrow (| Pointer.Kind.Ref, pc |) ]
                                                    |)
                                                  |)
                                                |)
                                              |)
                                            |)
                                          ]
                                        |);
                                        M.call_closure (|
                                          Ty.path "core::fmt::rt::Argument",
                                          M.get_associated_function (|
                                            Ty.path "core::fmt::rt::Argument",
                                            "new_display",
                                            [],
                                            [ Ty.apply (Ty.path "&") [] [ Ty.path "usize" ] ]
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.alloc (|
                                                    Ty.apply (Ty.path "&") [] [ Ty.path "usize" ],
                                                    M.call_closure (|
                                                      Ty.apply (Ty.path "&") [] [ Ty.path "usize" ],
                                                      M.get_trait_method (|
                                                        "thiserror::display::AsDisplay",
                                                        Ty.apply
                                                          (Ty.path "&")
                                                          []
                                                          [ Ty.path "usize" ],
                                                        [],
                                                        [],
                                                        "as_display",
                                                        [],
                                                        []
                                                      |),
                                                      [ M.borrow (| Pointer.Kind.Ref, program_len |)
                                                      ]
                                                    |)
                                                  |)
                                                |)
                                              |)
                                            |)
                                          ]
                                        |);
                                        M.call_closure (|
                                          Ty.path "core::fmt::rt::Argument",
                                          M.get_associated_function (|
                                            Ty.path "core::fmt::rt::Argument",
                                            "new_display",
                                            [],
                                            [ Ty.apply (Ty.path "&") [] [ Ty.path "u32" ] ]
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.alloc (|
                                                    Ty.apply (Ty.path "&") [] [ Ty.path "u32" ],
                                                    M.call_closure (|
                                                      Ty.apply (Ty.path "&") [] [ Ty.path "u32" ],
                                                      M.get_trait_method (|
                                                        "thiserror::display::AsDisplay",
                                                        Ty.apply (Ty.path "&") [] [ Ty.path "u32" ],
                                                        [],
                                                        [],
                                                        "as_display",
                                                        [],
                                                        []
                                                      |),
                                                      [ M.borrow (| Pointer.Kind.Ref, pc_base |) ]
                                                    |)
                                                  |)
                                                |)
                                              |)
                                            |)
                                          ]
                                        |);
                                        M.call_closure (|
                                          Ty.path "core::fmt::rt::Argument",
                                          M.get_associated_function (|
                                            Ty.path "core::fmt::rt::Argument",
                                            "new_display",
                                            [],
                                            [ Ty.apply (Ty.path "&") [] [ Ty.path "u32" ] ]
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.alloc (|
                                                    Ty.apply (Ty.path "&") [] [ Ty.path "u32" ],
                                                    M.call_closure (|
                                                      Ty.apply (Ty.path "&") [] [ Ty.path "u32" ],
                                                      M.get_trait_method (|
                                                        "thiserror::display::AsDisplay",
                                                        Ty.apply (Ty.path "&") [] [ Ty.path "u32" ],
                                                        [],
                                                        [],
                                                        "as_display",
                                                        [],
                                                        []
                                                      |),
                                                      [ M.borrow (| Pointer.Kind.Ref, step |) ]
                                                    |)
                                                  |)
                                                |)
                                              |)
                                            |)
                                          ]
                                        |)
                                      ]
                                  |)
                                |)
                              |)
                            |)
                          ]
                        |)
                      ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.deref (| M.read (| γ |) |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "openvm_circuit::arch::execution::ExecutionError::PcOutOfBounds",
                        "pc"
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "openvm_circuit::arch::execution::ExecutionError::PcOutOfBounds",
                        "step"
                      |) in
                    let γ1_2 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "openvm_circuit::arch::execution::ExecutionError::PcOutOfBounds",
                        "pc_base"
                      |) in
                    let γ1_3 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "openvm_circuit::arch::execution::ExecutionError::PcOutOfBounds",
                        "program_len"
                      |) in
                    let pc := M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "u32" ], γ1_0 |) in
                    let step := M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "u32" ], γ1_1 |) in
                    let pc_base :=
                      M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "u32" ], γ1_2 |) in
                    let program_len :=
                      M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "usize" ], γ1_3 |) in
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                      M.get_associated_function (|
                        Ty.path "core::fmt::Formatter",
                        "write_fmt",
                        [],
                        []
                      |),
                      [
                        M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| __formatter |) |) |);
                        M.call_closure (|
                          Ty.path "core::fmt::Arguments",
                          M.get_associated_function (|
                            Ty.path "core::fmt::Arguments",
                            "new_v1",
                            [ Value.Integer IntegerKind.Usize 4; Value.Integer IntegerKind.Usize 4
                            ],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.alloc (|
                                    Ty.apply
                                      (Ty.path "array")
                                      [ Value.Integer IntegerKind.Usize 4 ]
                                      [ Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ],
                                    Value.Array
                                      [
                                        mk_str (| "pc " |);
                                        mk_str (| " out of bounds for program of length " |);
                                        mk_str (| ", with pc_base " |);
                                        mk_str (| " and step = " |)
                                      ]
                                  |)
                                |)
                              |)
                            |);
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.alloc (|
                                    Ty.apply
                                      (Ty.path "array")
                                      [ Value.Integer IntegerKind.Usize 4 ]
                                      [ Ty.path "core::fmt::rt::Argument" ],
                                    Value.Array
                                      [
                                        M.call_closure (|
                                          Ty.path "core::fmt::rt::Argument",
                                          M.get_associated_function (|
                                            Ty.path "core::fmt::rt::Argument",
                                            "new_display",
                                            [],
                                            [ Ty.apply (Ty.path "&") [] [ Ty.path "u32" ] ]
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.alloc (|
                                                    Ty.apply (Ty.path "&") [] [ Ty.path "u32" ],
                                                    M.call_closure (|
                                                      Ty.apply (Ty.path "&") [] [ Ty.path "u32" ],
                                                      M.get_trait_method (|
                                                        "thiserror::display::AsDisplay",
                                                        Ty.apply (Ty.path "&") [] [ Ty.path "u32" ],
                                                        [],
                                                        [],
                                                        "as_display",
                                                        [],
                                                        []
                                                      |),
                                                      [ M.borrow (| Pointer.Kind.Ref, pc |) ]
                                                    |)
                                                  |)
                                                |)
                                              |)
                                            |)
                                          ]
                                        |);
                                        M.call_closure (|
                                          Ty.path "core::fmt::rt::Argument",
                                          M.get_associated_function (|
                                            Ty.path "core::fmt::rt::Argument",
                                            "new_display",
                                            [],
                                            [ Ty.apply (Ty.path "&") [] [ Ty.path "usize" ] ]
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.alloc (|
                                                    Ty.apply (Ty.path "&") [] [ Ty.path "usize" ],
                                                    M.call_closure (|
                                                      Ty.apply (Ty.path "&") [] [ Ty.path "usize" ],
                                                      M.get_trait_method (|
                                                        "thiserror::display::AsDisplay",
                                                        Ty.apply
                                                          (Ty.path "&")
                                                          []
                                                          [ Ty.path "usize" ],
                                                        [],
                                                        [],
                                                        "as_display",
                                                        [],
                                                        []
                                                      |),
                                                      [ M.borrow (| Pointer.Kind.Ref, program_len |)
                                                      ]
                                                    |)
                                                  |)
                                                |)
                                              |)
                                            |)
                                          ]
                                        |);
                                        M.call_closure (|
                                          Ty.path "core::fmt::rt::Argument",
                                          M.get_associated_function (|
                                            Ty.path "core::fmt::rt::Argument",
                                            "new_display",
                                            [],
                                            [ Ty.apply (Ty.path "&") [] [ Ty.path "u32" ] ]
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.alloc (|
                                                    Ty.apply (Ty.path "&") [] [ Ty.path "u32" ],
                                                    M.call_closure (|
                                                      Ty.apply (Ty.path "&") [] [ Ty.path "u32" ],
                                                      M.get_trait_method (|
                                                        "thiserror::display::AsDisplay",
                                                        Ty.apply (Ty.path "&") [] [ Ty.path "u32" ],
                                                        [],
                                                        [],
                                                        "as_display",
                                                        [],
                                                        []
                                                      |),
                                                      [ M.borrow (| Pointer.Kind.Ref, pc_base |) ]
                                                    |)
                                                  |)
                                                |)
                                              |)
                                            |)
                                          ]
                                        |);
                                        M.call_closure (|
                                          Ty.path "core::fmt::rt::Argument",
                                          M.get_associated_function (|
                                            Ty.path "core::fmt::rt::Argument",
                                            "new_display",
                                            [],
                                            [ Ty.apply (Ty.path "&") [] [ Ty.path "u32" ] ]
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.alloc (|
                                                    Ty.apply (Ty.path "&") [] [ Ty.path "u32" ],
                                                    M.call_closure (|
                                                      Ty.apply (Ty.path "&") [] [ Ty.path "u32" ],
                                                      M.get_trait_method (|
                                                        "thiserror::display::AsDisplay",
                                                        Ty.apply (Ty.path "&") [] [ Ty.path "u32" ],
                                                        [],
                                                        [],
                                                        "as_display",
                                                        [],
                                                        []
                                                      |),
                                                      [ M.borrow (| Pointer.Kind.Ref, step |) ]
                                                    |)
                                                  |)
                                                |)
                                              |)
                                            |)
                                          ]
                                        |)
                                      ]
                                  |)
                                |)
                              |)
                            |)
                          ]
                        |)
                      ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.deref (| M.read (| γ |) |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "openvm_circuit::arch::execution::ExecutionError::DisabledOperation",
                        "pc"
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "openvm_circuit::arch::execution::ExecutionError::DisabledOperation",
                        "opcode"
                      |) in
                    let pc := M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "u32" ], γ1_0 |) in
                    let opcode :=
                      M.alloc (|
                        Ty.apply (Ty.path "&") [] [ Ty.path "openvm_instructions::VmOpcode" ],
                        γ1_1
                      |) in
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                      M.get_associated_function (|
                        Ty.path "core::fmt::Formatter",
                        "write_fmt",
                        [],
                        []
                      |),
                      [
                        M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| __formatter |) |) |);
                        M.call_closure (|
                          Ty.path "core::fmt::Arguments",
                          M.get_associated_function (|
                            Ty.path "core::fmt::Arguments",
                            "new_v1",
                            [ Value.Integer IntegerKind.Usize 3; Value.Integer IntegerKind.Usize 2
                            ],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.alloc (|
                                    Ty.apply
                                      (Ty.path "array")
                                      [ Value.Integer IntegerKind.Usize 3 ]
                                      [ Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ],
                                    Value.Array
                                      [
                                        mk_str (| "at pc " |);
                                        mk_str (| ", opcode " |);
                                        mk_str (| " was not enabled" |)
                                      ]
                                  |)
                                |)
                              |)
                            |);
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.alloc (|
                                    Ty.apply
                                      (Ty.path "array")
                                      [ Value.Integer IntegerKind.Usize 2 ]
                                      [ Ty.path "core::fmt::rt::Argument" ],
                                    Value.Array
                                      [
                                        M.call_closure (|
                                          Ty.path "core::fmt::rt::Argument",
                                          M.get_associated_function (|
                                            Ty.path "core::fmt::rt::Argument",
                                            "new_display",
                                            [],
                                            [ Ty.apply (Ty.path "&") [] [ Ty.path "u32" ] ]
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.alloc (|
                                                    Ty.apply (Ty.path "&") [] [ Ty.path "u32" ],
                                                    M.call_closure (|
                                                      Ty.apply (Ty.path "&") [] [ Ty.path "u32" ],
                                                      M.get_trait_method (|
                                                        "thiserror::display::AsDisplay",
                                                        Ty.apply (Ty.path "&") [] [ Ty.path "u32" ],
                                                        [],
                                                        [],
                                                        "as_display",
                                                        [],
                                                        []
                                                      |),
                                                      [ M.borrow (| Pointer.Kind.Ref, pc |) ]
                                                    |)
                                                  |)
                                                |)
                                              |)
                                            |)
                                          ]
                                        |);
                                        M.call_closure (|
                                          Ty.path "core::fmt::rt::Argument",
                                          M.get_associated_function (|
                                            Ty.path "core::fmt::rt::Argument",
                                            "new_display",
                                            [],
                                            [
                                              Ty.apply
                                                (Ty.path "&")
                                                []
                                                [ Ty.path "openvm_instructions::VmOpcode" ]
                                            ]
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.alloc (|
                                                    Ty.apply
                                                      (Ty.path "&")
                                                      []
                                                      [ Ty.path "openvm_instructions::VmOpcode" ],
                                                    M.call_closure (|
                                                      Ty.apply
                                                        (Ty.path "&")
                                                        []
                                                        [ Ty.path "openvm_instructions::VmOpcode" ],
                                                      M.get_trait_method (|
                                                        "thiserror::display::AsDisplay",
                                                        Ty.apply
                                                          (Ty.path "&")
                                                          []
                                                          [ Ty.path "openvm_instructions::VmOpcode"
                                                          ],
                                                        [],
                                                        [],
                                                        "as_display",
                                                        [],
                                                        []
                                                      |),
                                                      [ M.borrow (| Pointer.Kind.Ref, opcode |) ]
                                                    |)
                                                  |)
                                                |)
                                              |)
                                            |)
                                          ]
                                        |)
                                      ]
                                  |)
                                |)
                              |)
                            |)
                          ]
                        |)
                      ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.deref (| M.read (| γ |) |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "openvm_circuit::arch::execution::ExecutionError::HintOutOfBounds",
                        "pc"
                      |) in
                    let pc := M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "u32" ], γ1_0 |) in
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                      M.get_associated_function (|
                        Ty.path "core::fmt::Formatter",
                        "write_fmt",
                        [],
                        []
                      |),
                      [
                        M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| __formatter |) |) |);
                        M.call_closure (|
                          Ty.path "core::fmt::Arguments",
                          M.get_associated_function (|
                            Ty.path "core::fmt::Arguments",
                            "new_v1",
                            [ Value.Integer IntegerKind.Usize 1; Value.Integer IntegerKind.Usize 1
                            ],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.alloc (|
                                    Ty.apply
                                      (Ty.path "array")
                                      [ Value.Integer IntegerKind.Usize 1 ]
                                      [ Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ],
                                    Value.Array [ mk_str (| "at pc = " |) ]
                                  |)
                                |)
                              |)
                            |);
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.alloc (|
                                    Ty.apply
                                      (Ty.path "array")
                                      [ Value.Integer IntegerKind.Usize 1 ]
                                      [ Ty.path "core::fmt::rt::Argument" ],
                                    Value.Array
                                      [
                                        M.call_closure (|
                                          Ty.path "core::fmt::rt::Argument",
                                          M.get_associated_function (|
                                            Ty.path "core::fmt::rt::Argument",
                                            "new_display",
                                            [],
                                            [ Ty.apply (Ty.path "&") [] [ Ty.path "u32" ] ]
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.alloc (|
                                                    Ty.apply (Ty.path "&") [] [ Ty.path "u32" ],
                                                    M.call_closure (|
                                                      Ty.apply (Ty.path "&") [] [ Ty.path "u32" ],
                                                      M.get_trait_method (|
                                                        "thiserror::display::AsDisplay",
                                                        Ty.apply (Ty.path "&") [] [ Ty.path "u32" ],
                                                        [],
                                                        [],
                                                        "as_display",
                                                        [],
                                                        []
                                                      |),
                                                      [ M.borrow (| Pointer.Kind.Ref, pc |) ]
                                                    |)
                                                  |)
                                                |)
                                              |)
                                            |)
                                          ]
                                        |)
                                      ]
                                  |)
                                |)
                              |)
                            |)
                          ]
                        |)
                      ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.deref (| M.read (| γ |) |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "openvm_circuit::arch::execution::ExecutionError::PublicValueIndexOutOfBounds",
                        "pc"
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "openvm_circuit::arch::execution::ExecutionError::PublicValueIndexOutOfBounds",
                        "num_public_values"
                      |) in
                    let γ1_2 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "openvm_circuit::arch::execution::ExecutionError::PublicValueIndexOutOfBounds",
                        "public_value_index"
                      |) in
                    let pc := M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "u32" ], γ1_0 |) in
                    let num_public_values :=
                      M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "usize" ], γ1_1 |) in
                    let public_value_index :=
                      M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "usize" ], γ1_2 |) in
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                      M.get_associated_function (|
                        Ty.path "core::fmt::Formatter",
                        "write_fmt",
                        [],
                        []
                      |),
                      [
                        M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| __formatter |) |) |);
                        M.call_closure (|
                          Ty.path "core::fmt::Arguments",
                          M.get_associated_function (|
                            Ty.path "core::fmt::Arguments",
                            "new_v1",
                            [ Value.Integer IntegerKind.Usize 3; Value.Integer IntegerKind.Usize 3
                            ],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.alloc (|
                                    Ty.apply
                                      (Ty.path "array")
                                      [ Value.Integer IntegerKind.Usize 3 ]
                                      [ Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ],
                                    Value.Array
                                      [
                                        mk_str (| "at pc " |);
                                        mk_str (| ", tried to publish into index " |);
                                        mk_str (| " when num_public_values = " |)
                                      ]
                                  |)
                                |)
                              |)
                            |);
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.alloc (|
                                    Ty.apply
                                      (Ty.path "array")
                                      [ Value.Integer IntegerKind.Usize 3 ]
                                      [ Ty.path "core::fmt::rt::Argument" ],
                                    Value.Array
                                      [
                                        M.call_closure (|
                                          Ty.path "core::fmt::rt::Argument",
                                          M.get_associated_function (|
                                            Ty.path "core::fmt::rt::Argument",
                                            "new_display",
                                            [],
                                            [ Ty.apply (Ty.path "&") [] [ Ty.path "u32" ] ]
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.alloc (|
                                                    Ty.apply (Ty.path "&") [] [ Ty.path "u32" ],
                                                    M.call_closure (|
                                                      Ty.apply (Ty.path "&") [] [ Ty.path "u32" ],
                                                      M.get_trait_method (|
                                                        "thiserror::display::AsDisplay",
                                                        Ty.apply (Ty.path "&") [] [ Ty.path "u32" ],
                                                        [],
                                                        [],
                                                        "as_display",
                                                        [],
                                                        []
                                                      |),
                                                      [ M.borrow (| Pointer.Kind.Ref, pc |) ]
                                                    |)
                                                  |)
                                                |)
                                              |)
                                            |)
                                          ]
                                        |);
                                        M.call_closure (|
                                          Ty.path "core::fmt::rt::Argument",
                                          M.get_associated_function (|
                                            Ty.path "core::fmt::rt::Argument",
                                            "new_display",
                                            [],
                                            [ Ty.apply (Ty.path "&") [] [ Ty.path "usize" ] ]
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.alloc (|
                                                    Ty.apply (Ty.path "&") [] [ Ty.path "usize" ],
                                                    M.call_closure (|
                                                      Ty.apply (Ty.path "&") [] [ Ty.path "usize" ],
                                                      M.get_trait_method (|
                                                        "thiserror::display::AsDisplay",
                                                        Ty.apply
                                                          (Ty.path "&")
                                                          []
                                                          [ Ty.path "usize" ],
                                                        [],
                                                        [],
                                                        "as_display",
                                                        [],
                                                        []
                                                      |),
                                                      [
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          public_value_index
                                                        |)
                                                      ]
                                                    |)
                                                  |)
                                                |)
                                              |)
                                            |)
                                          ]
                                        |);
                                        M.call_closure (|
                                          Ty.path "core::fmt::rt::Argument",
                                          M.get_associated_function (|
                                            Ty.path "core::fmt::rt::Argument",
                                            "new_display",
                                            [],
                                            [ Ty.apply (Ty.path "&") [] [ Ty.path "usize" ] ]
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.alloc (|
                                                    Ty.apply (Ty.path "&") [] [ Ty.path "usize" ],
                                                    M.call_closure (|
                                                      Ty.apply (Ty.path "&") [] [ Ty.path "usize" ],
                                                      M.get_trait_method (|
                                                        "thiserror::display::AsDisplay",
                                                        Ty.apply
                                                          (Ty.path "&")
                                                          []
                                                          [ Ty.path "usize" ],
                                                        [],
                                                        [],
                                                        "as_display",
                                                        [],
                                                        []
                                                      |),
                                                      [
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          num_public_values
                                                        |)
                                                      ]
                                                    |)
                                                  |)
                                                |)
                                              |)
                                            |)
                                          ]
                                        |)
                                      ]
                                  |)
                                |)
                              |)
                            |)
                          ]
                        |)
                      ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.deref (| M.read (| γ |) |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "openvm_circuit::arch::execution::ExecutionError::PublicValueNotEqual",
                        "pc"
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "openvm_circuit::arch::execution::ExecutionError::PublicValueNotEqual",
                        "public_value_index"
                      |) in
                    let γ1_2 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "openvm_circuit::arch::execution::ExecutionError::PublicValueNotEqual",
                        "existing_value"
                      |) in
                    let γ1_3 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "openvm_circuit::arch::execution::ExecutionError::PublicValueNotEqual",
                        "new_value"
                      |) in
                    let pc := M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "u32" ], γ1_0 |) in
                    let public_value_index :=
                      M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "usize" ], γ1_1 |) in
                    let existing_value :=
                      M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "usize" ], γ1_2 |) in
                    let new_value :=
                      M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "usize" ], γ1_3 |) in
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                      M.get_associated_function (|
                        Ty.path "core::fmt::Formatter",
                        "write_fmt",
                        [],
                        []
                      |),
                      [
                        M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| __formatter |) |) |);
                        M.call_closure (|
                          Ty.path "core::fmt::Arguments",
                          M.get_associated_function (|
                            Ty.path "core::fmt::Arguments",
                            "new_v1",
                            [ Value.Integer IntegerKind.Usize 4; Value.Integer IntegerKind.Usize 4
                            ],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.alloc (|
                                    Ty.apply
                                      (Ty.path "array")
                                      [ Value.Integer IntegerKind.Usize 4 ]
                                      [ Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ],
                                    Value.Array
                                      [
                                        mk_str (| "at pc " |);
                                        mk_str (| ", tried to publish " |);
                                        mk_str (| " into index " |);
                                        mk_str (| " but already had " |)
                                      ]
                                  |)
                                |)
                              |)
                            |);
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.alloc (|
                                    Ty.apply
                                      (Ty.path "array")
                                      [ Value.Integer IntegerKind.Usize 4 ]
                                      [ Ty.path "core::fmt::rt::Argument" ],
                                    Value.Array
                                      [
                                        M.call_closure (|
                                          Ty.path "core::fmt::rt::Argument",
                                          M.get_associated_function (|
                                            Ty.path "core::fmt::rt::Argument",
                                            "new_display",
                                            [],
                                            [ Ty.apply (Ty.path "&") [] [ Ty.path "u32" ] ]
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.alloc (|
                                                    Ty.apply (Ty.path "&") [] [ Ty.path "u32" ],
                                                    M.call_closure (|
                                                      Ty.apply (Ty.path "&") [] [ Ty.path "u32" ],
                                                      M.get_trait_method (|
                                                        "thiserror::display::AsDisplay",
                                                        Ty.apply (Ty.path "&") [] [ Ty.path "u32" ],
                                                        [],
                                                        [],
                                                        "as_display",
                                                        [],
                                                        []
                                                      |),
                                                      [ M.borrow (| Pointer.Kind.Ref, pc |) ]
                                                    |)
                                                  |)
                                                |)
                                              |)
                                            |)
                                          ]
                                        |);
                                        M.call_closure (|
                                          Ty.path "core::fmt::rt::Argument",
                                          M.get_associated_function (|
                                            Ty.path "core::fmt::rt::Argument",
                                            "new_display",
                                            [],
                                            [ Ty.apply (Ty.path "&") [] [ Ty.path "usize" ] ]
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.alloc (|
                                                    Ty.apply (Ty.path "&") [] [ Ty.path "usize" ],
                                                    M.call_closure (|
                                                      Ty.apply (Ty.path "&") [] [ Ty.path "usize" ],
                                                      M.get_trait_method (|
                                                        "thiserror::display::AsDisplay",
                                                        Ty.apply
                                                          (Ty.path "&")
                                                          []
                                                          [ Ty.path "usize" ],
                                                        [],
                                                        [],
                                                        "as_display",
                                                        [],
                                                        []
                                                      |),
                                                      [ M.borrow (| Pointer.Kind.Ref, new_value |) ]
                                                    |)
                                                  |)
                                                |)
                                              |)
                                            |)
                                          ]
                                        |);
                                        M.call_closure (|
                                          Ty.path "core::fmt::rt::Argument",
                                          M.get_associated_function (|
                                            Ty.path "core::fmt::rt::Argument",
                                            "new_display",
                                            [],
                                            [ Ty.apply (Ty.path "&") [] [ Ty.path "usize" ] ]
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.alloc (|
                                                    Ty.apply (Ty.path "&") [] [ Ty.path "usize" ],
                                                    M.call_closure (|
                                                      Ty.apply (Ty.path "&") [] [ Ty.path "usize" ],
                                                      M.get_trait_method (|
                                                        "thiserror::display::AsDisplay",
                                                        Ty.apply
                                                          (Ty.path "&")
                                                          []
                                                          [ Ty.path "usize" ],
                                                        [],
                                                        [],
                                                        "as_display",
                                                        [],
                                                        []
                                                      |),
                                                      [
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          public_value_index
                                                        |)
                                                      ]
                                                    |)
                                                  |)
                                                |)
                                              |)
                                            |)
                                          ]
                                        |);
                                        M.call_closure (|
                                          Ty.path "core::fmt::rt::Argument",
                                          M.get_associated_function (|
                                            Ty.path "core::fmt::rt::Argument",
                                            "new_display",
                                            [],
                                            [ Ty.apply (Ty.path "&") [] [ Ty.path "usize" ] ]
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.alloc (|
                                                    Ty.apply (Ty.path "&") [] [ Ty.path "usize" ],
                                                    M.call_closure (|
                                                      Ty.apply (Ty.path "&") [] [ Ty.path "usize" ],
                                                      M.get_trait_method (|
                                                        "thiserror::display::AsDisplay",
                                                        Ty.apply
                                                          (Ty.path "&")
                                                          []
                                                          [ Ty.path "usize" ],
                                                        [],
                                                        [],
                                                        "as_display",
                                                        [],
                                                        []
                                                      |),
                                                      [
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          existing_value
                                                        |)
                                                      ]
                                                    |)
                                                  |)
                                                |)
                                              |)
                                            |)
                                          ]
                                        |)
                                      ]
                                  |)
                                |)
                              |)
                            |)
                          ]
                        |)
                      ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.deref (| M.read (| γ |) |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "openvm_circuit::arch::execution::ExecutionError::PhantomNotFound",
                        "pc"
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "openvm_circuit::arch::execution::ExecutionError::PhantomNotFound",
                        "discriminant"
                      |) in
                    let pc := M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "u32" ], γ1_0 |) in
                    let discriminant :=
                      M.alloc (|
                        Ty.apply
                          (Ty.path "&")
                          []
                          [ Ty.path "openvm_instructions::phantom::PhantomDiscriminant" ],
                        γ1_1
                      |) in
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                      M.get_associated_function (|
                        Ty.path "core::fmt::Formatter",
                        "write_fmt",
                        [],
                        []
                      |),
                      [
                        M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| __formatter |) |) |);
                        M.call_closure (|
                          Ty.path "core::fmt::Arguments",
                          M.get_associated_function (|
                            Ty.path "core::fmt::Arguments",
                            "new_v1",
                            [ Value.Integer IntegerKind.Usize 2; Value.Integer IntegerKind.Usize 2
                            ],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.alloc (|
                                    Ty.apply
                                      (Ty.path "array")
                                      [ Value.Integer IntegerKind.Usize 2 ]
                                      [ Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ],
                                    Value.Array
                                      [
                                        mk_str (| "at pc " |);
                                        mk_str (|
                                          ", phantom sub-instruction not found for discriminant "
                                        |)
                                      ]
                                  |)
                                |)
                              |)
                            |);
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.alloc (|
                                    Ty.apply
                                      (Ty.path "array")
                                      [ Value.Integer IntegerKind.Usize 2 ]
                                      [ Ty.path "core::fmt::rt::Argument" ],
                                    M.match_operator (|
                                      Ty.apply
                                        (Ty.path "array")
                                        [ Value.Integer IntegerKind.Usize 2 ]
                                        [ Ty.path "core::fmt::rt::Argument" ],
                                      M.alloc (|
                                        Ty.tuple
                                          [
                                            Ty.apply (Ty.path "&") [] [ Ty.path "u16" ];
                                            Ty.apply
                                              (Ty.path "&")
                                              []
                                              [ Ty.apply (Ty.path "&") [] [ Ty.path "u32" ] ]
                                          ],
                                        Value.Tuple
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.SubPointer.get_struct_tuple_field (|
                                                M.deref (| M.read (| discriminant |) |),
                                                "openvm_instructions::phantom::PhantomDiscriminant",
                                                0
                                              |)
                                            |);
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.alloc (|
                                                Ty.apply (Ty.path "&") [] [ Ty.path "u32" ],
                                                M.call_closure (|
                                                  Ty.apply (Ty.path "&") [] [ Ty.path "u32" ],
                                                  M.get_trait_method (|
                                                    "thiserror::display::AsDisplay",
                                                    Ty.apply (Ty.path "&") [] [ Ty.path "u32" ],
                                                    [],
                                                    [],
                                                    "as_display",
                                                    [],
                                                    []
                                                  |),
                                                  [ M.borrow (| Pointer.Kind.Ref, pc |) ]
                                                |)
                                              |)
                                            |)
                                          ]
                                      |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let args :=
                                              M.copy (|
                                                Ty.tuple
                                                  [
                                                    Ty.apply (Ty.path "&") [] [ Ty.path "u16" ];
                                                    Ty.apply
                                                      (Ty.path "&")
                                                      []
                                                      [ Ty.apply (Ty.path "&") [] [ Ty.path "u32" ]
                                                      ]
                                                  ],
                                                γ
                                              |) in
                                            Value.Array
                                              [
                                                M.call_closure (|
                                                  Ty.path "core::fmt::rt::Argument",
                                                  M.get_associated_function (|
                                                    Ty.path "core::fmt::rt::Argument",
                                                    "new_display",
                                                    [],
                                                    [ Ty.apply (Ty.path "&") [] [ Ty.path "u32" ] ]
                                                  |),
                                                  [
                                                    M.borrow (|
                                                      Pointer.Kind.Ref,
                                                      M.deref (|
                                                        M.read (|
                                                          M.SubPointer.get_tuple_field (| args, 1 |)
                                                        |)
                                                      |)
                                                    |)
                                                  ]
                                                |);
                                                M.call_closure (|
                                                  Ty.path "core::fmt::rt::Argument",
                                                  M.get_associated_function (|
                                                    Ty.path "core::fmt::rt::Argument",
                                                    "new_display",
                                                    [],
                                                    [ Ty.path "u16" ]
                                                  |),
                                                  [
                                                    M.borrow (|
                                                      Pointer.Kind.Ref,
                                                      M.deref (|
                                                        M.read (|
                                                          M.SubPointer.get_tuple_field (| args, 0 |)
                                                        |)
                                                      |)
                                                    |)
                                                  ]
                                                |)
                                              ]))
                                      ]
                                    |)
                                  |)
                                |)
                              |)
                            |)
                          ]
                        |)
                      ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.deref (| M.read (| γ |) |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "openvm_circuit::arch::execution::ExecutionError::Phantom",
                        "pc"
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "openvm_circuit::arch::execution::ExecutionError::Phantom",
                        "discriminant"
                      |) in
                    let γ1_2 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "openvm_circuit::arch::execution::ExecutionError::Phantom",
                        "inner"
                      |) in
                    let pc := M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "u32" ], γ1_0 |) in
                    let discriminant :=
                      M.alloc (|
                        Ty.apply
                          (Ty.path "&")
                          []
                          [ Ty.path "openvm_instructions::phantom::PhantomDiscriminant" ],
                        γ1_1
                      |) in
                    let inner :=
                      M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "eyre::Report" ], γ1_2 |) in
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                      M.get_associated_function (|
                        Ty.path "core::fmt::Formatter",
                        "write_fmt",
                        [],
                        []
                      |),
                      [
                        M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| __formatter |) |) |);
                        M.call_closure (|
                          Ty.path "core::fmt::Arguments",
                          M.get_associated_function (|
                            Ty.path "core::fmt::Arguments",
                            "new_v1",
                            [ Value.Integer IntegerKind.Usize 3; Value.Integer IntegerKind.Usize 3
                            ],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.alloc (|
                                    Ty.apply
                                      (Ty.path "array")
                                      [ Value.Integer IntegerKind.Usize 3 ]
                                      [ Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ],
                                    Value.Array
                                      [
                                        mk_str (| "at pc " |);
                                        mk_str (| ", discriminant " |);
                                        mk_str (| ", phantom error: " |)
                                      ]
                                  |)
                                |)
                              |)
                            |);
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.alloc (|
                                    Ty.apply
                                      (Ty.path "array")
                                      [ Value.Integer IntegerKind.Usize 3 ]
                                      [ Ty.path "core::fmt::rt::Argument" ],
                                    M.match_operator (|
                                      Ty.apply
                                        (Ty.path "array")
                                        [ Value.Integer IntegerKind.Usize 3 ]
                                        [ Ty.path "core::fmt::rt::Argument" ],
                                      M.alloc (|
                                        Ty.tuple
                                          [
                                            Ty.apply (Ty.path "&") [] [ Ty.path "u16" ];
                                            Ty.apply
                                              (Ty.path "&")
                                              []
                                              [ Ty.apply (Ty.path "&") [] [ Ty.path "u32" ] ];
                                            Ty.apply
                                              (Ty.path "&")
                                              []
                                              [ Ty.apply (Ty.path "&") [] [ Ty.path "eyre::Report" ]
                                              ]
                                          ],
                                        Value.Tuple
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.SubPointer.get_struct_tuple_field (|
                                                M.deref (| M.read (| discriminant |) |),
                                                "openvm_instructions::phantom::PhantomDiscriminant",
                                                0
                                              |)
                                            |);
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.alloc (|
                                                Ty.apply (Ty.path "&") [] [ Ty.path "u32" ],
                                                M.call_closure (|
                                                  Ty.apply (Ty.path "&") [] [ Ty.path "u32" ],
                                                  M.get_trait_method (|
                                                    "thiserror::display::AsDisplay",
                                                    Ty.apply (Ty.path "&") [] [ Ty.path "u32" ],
                                                    [],
                                                    [],
                                                    "as_display",
                                                    [],
                                                    []
                                                  |),
                                                  [ M.borrow (| Pointer.Kind.Ref, pc |) ]
                                                |)
                                              |)
                                            |);
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.alloc (|
                                                Ty.apply
                                                  (Ty.path "&")
                                                  []
                                                  [ Ty.path "eyre::Report" ],
                                                M.call_closure (|
                                                  Ty.apply
                                                    (Ty.path "&")
                                                    []
                                                    [ Ty.path "eyre::Report" ],
                                                  M.get_trait_method (|
                                                    "thiserror::display::AsDisplay",
                                                    Ty.apply
                                                      (Ty.path "&")
                                                      []
                                                      [ Ty.path "eyre::Report" ],
                                                    [],
                                                    [],
                                                    "as_display",
                                                    [],
                                                    []
                                                  |),
                                                  [ M.borrow (| Pointer.Kind.Ref, inner |) ]
                                                |)
                                              |)
                                            |)
                                          ]
                                      |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let args :=
                                              M.copy (|
                                                Ty.tuple
                                                  [
                                                    Ty.apply (Ty.path "&") [] [ Ty.path "u16" ];
                                                    Ty.apply
                                                      (Ty.path "&")
                                                      []
                                                      [ Ty.apply (Ty.path "&") [] [ Ty.path "u32" ]
                                                      ];
                                                    Ty.apply
                                                      (Ty.path "&")
                                                      []
                                                      [
                                                        Ty.apply
                                                          (Ty.path "&")
                                                          []
                                                          [ Ty.path "eyre::Report" ]
                                                      ]
                                                  ],
                                                γ
                                              |) in
                                            Value.Array
                                              [
                                                M.call_closure (|
                                                  Ty.path "core::fmt::rt::Argument",
                                                  M.get_associated_function (|
                                                    Ty.path "core::fmt::rt::Argument",
                                                    "new_display",
                                                    [],
                                                    [ Ty.apply (Ty.path "&") [] [ Ty.path "u32" ] ]
                                                  |),
                                                  [
                                                    M.borrow (|
                                                      Pointer.Kind.Ref,
                                                      M.deref (|
                                                        M.read (|
                                                          M.SubPointer.get_tuple_field (| args, 1 |)
                                                        |)
                                                      |)
                                                    |)
                                                  ]
                                                |);
                                                M.call_closure (|
                                                  Ty.path "core::fmt::rt::Argument",
                                                  M.get_associated_function (|
                                                    Ty.path "core::fmt::rt::Argument",
                                                    "new_display",
                                                    [],
                                                    [ Ty.path "u16" ]
                                                  |),
                                                  [
                                                    M.borrow (|
                                                      Pointer.Kind.Ref,
                                                      M.deref (|
                                                        M.read (|
                                                          M.SubPointer.get_tuple_field (| args, 0 |)
                                                        |)
                                                      |)
                                                    |)
                                                  ]
                                                |);
                                                M.call_closure (|
                                                  Ty.path "core::fmt::rt::Argument",
                                                  M.get_associated_function (|
                                                    Ty.path "core::fmt::rt::Argument",
                                                    "new_display",
                                                    [],
                                                    [
                                                      Ty.apply
                                                        (Ty.path "&")
                                                        []
                                                        [ Ty.path "eyre::Report" ]
                                                    ]
                                                  |),
                                                  [
                                                    M.borrow (|
                                                      Pointer.Kind.Ref,
                                                      M.deref (|
                                                        M.read (|
                                                          M.SubPointer.get_tuple_field (| args, 2 |)
                                                        |)
                                                      |)
                                                    |)
                                                  ]
                                                |)
                                              ]))
                                      ]
                                    |)
                                  |)
                                |)
                              |)
                            |)
                          ]
                        |)
                      ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.deref (| M.read (| γ |) |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "openvm_circuit::arch::execution::ExecutionError::DidNotTerminate"
                      |) in
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                      M.get_associated_function (|
                        Ty.path "core::fmt::Formatter",
                        "write_str",
                        [],
                        []
                      |),
                      [
                        M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| __formatter |) |) |);
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (| mk_str (| "program must terminate" |) |)
                        |)
                      ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.deref (| M.read (| γ |) |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "openvm_circuit::arch::execution::ExecutionError::FailedWithExitCode",
                        0
                      |) in
                    let _0 := M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "u32" ], γ1_0 |) in
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                      M.get_associated_function (|
                        Ty.path "core::fmt::Formatter",
                        "write_fmt",
                        [],
                        []
                      |),
                      [
                        M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| __formatter |) |) |);
                        M.call_closure (|
                          Ty.path "core::fmt::Arguments",
                          M.get_associated_function (|
                            Ty.path "core::fmt::Arguments",
                            "new_v1",
                            [ Value.Integer IntegerKind.Usize 1; Value.Integer IntegerKind.Usize 1
                            ],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.alloc (|
                                    Ty.apply
                                      (Ty.path "array")
                                      [ Value.Integer IntegerKind.Usize 1 ]
                                      [ Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ],
                                    Value.Array [ mk_str (| "program exit code " |) ]
                                  |)
                                |)
                              |)
                            |);
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.alloc (|
                                    Ty.apply
                                      (Ty.path "array")
                                      [ Value.Integer IntegerKind.Usize 1 ]
                                      [ Ty.path "core::fmt::rt::Argument" ],
                                    Value.Array
                                      [
                                        M.call_closure (|
                                          Ty.path "core::fmt::rt::Argument",
                                          M.get_associated_function (|
                                            Ty.path "core::fmt::rt::Argument",
                                            "new_display",
                                            [],
                                            [ Ty.apply (Ty.path "&") [] [ Ty.path "u32" ] ]
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.alloc (|
                                                    Ty.apply (Ty.path "&") [] [ Ty.path "u32" ],
                                                    M.call_closure (|
                                                      Ty.apply (Ty.path "&") [] [ Ty.path "u32" ],
                                                      M.get_trait_method (|
                                                        "thiserror::display::AsDisplay",
                                                        Ty.apply (Ty.path "&") [] [ Ty.path "u32" ],
                                                        [],
                                                        [],
                                                        "as_display",
                                                        [],
                                                        []
                                                      |),
                                                      [ M.borrow (| Pointer.Kind.Ref, _0 |) ]
                                                    |)
                                                  |)
                                                |)
                                              |)
                                            |)
                                          ]
                                        |)
                                      ]
                                  |)
                                |)
                              |)
                            |)
                          ]
                        |)
                      ]
                    |)))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Display"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Display_for_openvm_circuit_arch_execution_ExecutionError.
    
    Module Impl_core_fmt_Debug_for_openvm_circuit_arch_execution_ExecutionError.
      Definition Self : Ty.t := Ty.path "openvm_circuit::arch::execution::ExecutionError".
      
      (* Debug *)
      Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.path "openvm_circuit::arch::execution::ExecutionError" ],
                self
              |) in
            let f :=
              M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "core::fmt::Formatter" ], f |) in
            M.match_operator (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.deref (| M.read (| γ |) |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "openvm_circuit::arch::execution::ExecutionError::Fail",
                        "pc"
                      |) in
                    let __self_0 :=
                      M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "u32" ], γ1_0 |) in
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                      M.get_associated_function (|
                        Ty.path "core::fmt::Formatter",
                        "debug_struct_field1_finish",
                        [],
                        []
                      |),
                      [
                        M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                        M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "Fail" |) |) |);
                        M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "pc" |) |) |);
                        M.call_closure (|
                          Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ],
                          M.pointer_coercion
                            M.PointerCoercion.Unsize
                            (Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.apply (Ty.path "&") [] [ Ty.path "u32" ] ])
                            (Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ]),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (| M.borrow (| Pointer.Kind.Ref, __self_0 |) |)
                            |)
                          ]
                        |)
                      ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.deref (| M.read (| γ |) |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "openvm_circuit::arch::execution::ExecutionError::PcNotFound",
                        "pc"
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "openvm_circuit::arch::execution::ExecutionError::PcNotFound",
                        "step"
                      |) in
                    let γ1_2 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "openvm_circuit::arch::execution::ExecutionError::PcNotFound",
                        "pc_base"
                      |) in
                    let γ1_3 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "openvm_circuit::arch::execution::ExecutionError::PcNotFound",
                        "program_len"
                      |) in
                    let __self_0 :=
                      M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "u32" ], γ1_0 |) in
                    let __self_1 :=
                      M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "u32" ], γ1_1 |) in
                    let __self_2 :=
                      M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "u32" ], γ1_2 |) in
                    let __self_3 :=
                      M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "usize" ], γ1_3 |) in
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                      M.get_associated_function (|
                        Ty.path "core::fmt::Formatter",
                        "debug_struct_field4_finish",
                        [],
                        []
                      |),
                      [
                        M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                        M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "PcNotFound" |) |) |);
                        M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "pc" |) |) |);
                        M.call_closure (|
                          Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ],
                          M.pointer_coercion
                            M.PointerCoercion.Unsize
                            (Ty.apply (Ty.path "&") [] [ Ty.path "u32" ])
                            (Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ]),
                          [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |) ]
                        |);
                        M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "step" |) |) |);
                        M.call_closure (|
                          Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ],
                          M.pointer_coercion
                            M.PointerCoercion.Unsize
                            (Ty.apply (Ty.path "&") [] [ Ty.path "u32" ])
                            (Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ]),
                          [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_1 |) |) |) ]
                        |);
                        M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "pc_base" |) |) |);
                        M.call_closure (|
                          Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ],
                          M.pointer_coercion
                            M.PointerCoercion.Unsize
                            (Ty.apply (Ty.path "&") [] [ Ty.path "u32" ])
                            (Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ]),
                          [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_2 |) |) |) ]
                        |);
                        M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "program_len" |) |) |);
                        M.call_closure (|
                          Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ],
                          M.pointer_coercion
                            M.PointerCoercion.Unsize
                            (Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.apply (Ty.path "&") [] [ Ty.path "usize" ] ])
                            (Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ]),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (| M.borrow (| Pointer.Kind.Ref, __self_3 |) |)
                            |)
                          ]
                        |)
                      ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.deref (| M.read (| γ |) |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "openvm_circuit::arch::execution::ExecutionError::PcOutOfBounds",
                        "pc"
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "openvm_circuit::arch::execution::ExecutionError::PcOutOfBounds",
                        "step"
                      |) in
                    let γ1_2 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "openvm_circuit::arch::execution::ExecutionError::PcOutOfBounds",
                        "pc_base"
                      |) in
                    let γ1_3 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "openvm_circuit::arch::execution::ExecutionError::PcOutOfBounds",
                        "program_len"
                      |) in
                    let __self_0 :=
                      M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "u32" ], γ1_0 |) in
                    let __self_1 :=
                      M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "u32" ], γ1_1 |) in
                    let __self_2 :=
                      M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "u32" ], γ1_2 |) in
                    let __self_3 :=
                      M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "usize" ], γ1_3 |) in
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                      M.get_associated_function (|
                        Ty.path "core::fmt::Formatter",
                        "debug_struct_field4_finish",
                        [],
                        []
                      |),
                      [
                        M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                        M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "PcOutOfBounds" |) |) |);
                        M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "pc" |) |) |);
                        M.call_closure (|
                          Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ],
                          M.pointer_coercion
                            M.PointerCoercion.Unsize
                            (Ty.apply (Ty.path "&") [] [ Ty.path "u32" ])
                            (Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ]),
                          [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |) ]
                        |);
                        M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "step" |) |) |);
                        M.call_closure (|
                          Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ],
                          M.pointer_coercion
                            M.PointerCoercion.Unsize
                            (Ty.apply (Ty.path "&") [] [ Ty.path "u32" ])
                            (Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ]),
                          [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_1 |) |) |) ]
                        |);
                        M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "pc_base" |) |) |);
                        M.call_closure (|
                          Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ],
                          M.pointer_coercion
                            M.PointerCoercion.Unsize
                            (Ty.apply (Ty.path "&") [] [ Ty.path "u32" ])
                            (Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ]),
                          [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_2 |) |) |) ]
                        |);
                        M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "program_len" |) |) |);
                        M.call_closure (|
                          Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ],
                          M.pointer_coercion
                            M.PointerCoercion.Unsize
                            (Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.apply (Ty.path "&") [] [ Ty.path "usize" ] ])
                            (Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ]),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (| M.borrow (| Pointer.Kind.Ref, __self_3 |) |)
                            |)
                          ]
                        |)
                      ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.deref (| M.read (| γ |) |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "openvm_circuit::arch::execution::ExecutionError::DisabledOperation",
                        "pc"
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "openvm_circuit::arch::execution::ExecutionError::DisabledOperation",
                        "opcode"
                      |) in
                    let __self_0 :=
                      M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "u32" ], γ1_0 |) in
                    let __self_1 :=
                      M.alloc (|
                        Ty.apply (Ty.path "&") [] [ Ty.path "openvm_instructions::VmOpcode" ],
                        γ1_1
                      |) in
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                      M.get_associated_function (|
                        Ty.path "core::fmt::Formatter",
                        "debug_struct_field2_finish",
                        [],
                        []
                      |),
                      [
                        M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (| mk_str (| "DisabledOperation" |) |)
                        |);
                        M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "pc" |) |) |);
                        M.call_closure (|
                          Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ],
                          M.pointer_coercion
                            M.PointerCoercion.Unsize
                            (Ty.apply (Ty.path "&") [] [ Ty.path "u32" ])
                            (Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ]),
                          [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |) ]
                        |);
                        M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "opcode" |) |) |);
                        M.call_closure (|
                          Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ],
                          M.pointer_coercion
                            M.PointerCoercion.Unsize
                            (Ty.apply
                              (Ty.path "&")
                              []
                              [
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [ Ty.path "openvm_instructions::VmOpcode" ]
                              ])
                            (Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ]),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (| M.borrow (| Pointer.Kind.Ref, __self_1 |) |)
                            |)
                          ]
                        |)
                      ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.deref (| M.read (| γ |) |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "openvm_circuit::arch::execution::ExecutionError::HintOutOfBounds",
                        "pc"
                      |) in
                    let __self_0 :=
                      M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "u32" ], γ1_0 |) in
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                      M.get_associated_function (|
                        Ty.path "core::fmt::Formatter",
                        "debug_struct_field1_finish",
                        [],
                        []
                      |),
                      [
                        M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (| mk_str (| "HintOutOfBounds" |) |)
                        |);
                        M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "pc" |) |) |);
                        M.call_closure (|
                          Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ],
                          M.pointer_coercion
                            M.PointerCoercion.Unsize
                            (Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.apply (Ty.path "&") [] [ Ty.path "u32" ] ])
                            (Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ]),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (| M.borrow (| Pointer.Kind.Ref, __self_0 |) |)
                            |)
                          ]
                        |)
                      ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.deref (| M.read (| γ |) |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "openvm_circuit::arch::execution::ExecutionError::PublicValueIndexOutOfBounds",
                        "pc"
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "openvm_circuit::arch::execution::ExecutionError::PublicValueIndexOutOfBounds",
                        "num_public_values"
                      |) in
                    let γ1_2 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "openvm_circuit::arch::execution::ExecutionError::PublicValueIndexOutOfBounds",
                        "public_value_index"
                      |) in
                    let __self_0 :=
                      M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "u32" ], γ1_0 |) in
                    let __self_1 :=
                      M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "usize" ], γ1_1 |) in
                    let __self_2 :=
                      M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "usize" ], γ1_2 |) in
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                      M.get_associated_function (|
                        Ty.path "core::fmt::Formatter",
                        "debug_struct_field3_finish",
                        [],
                        []
                      |),
                      [
                        M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (| mk_str (| "PublicValueIndexOutOfBounds" |) |)
                        |);
                        M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "pc" |) |) |);
                        M.call_closure (|
                          Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ],
                          M.pointer_coercion
                            M.PointerCoercion.Unsize
                            (Ty.apply (Ty.path "&") [] [ Ty.path "u32" ])
                            (Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ]),
                          [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |) ]
                        |);
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (| mk_str (| "num_public_values" |) |)
                        |);
                        M.call_closure (|
                          Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ],
                          M.pointer_coercion
                            M.PointerCoercion.Unsize
                            (Ty.apply (Ty.path "&") [] [ Ty.path "usize" ])
                            (Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ]),
                          [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_1 |) |) |) ]
                        |);
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (| mk_str (| "public_value_index" |) |)
                        |);
                        M.call_closure (|
                          Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ],
                          M.pointer_coercion
                            M.PointerCoercion.Unsize
                            (Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.apply (Ty.path "&") [] [ Ty.path "usize" ] ])
                            (Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ]),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (| M.borrow (| Pointer.Kind.Ref, __self_2 |) |)
                            |)
                          ]
                        |)
                      ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.deref (| M.read (| γ |) |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "openvm_circuit::arch::execution::ExecutionError::PublicValueNotEqual",
                        "pc"
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "openvm_circuit::arch::execution::ExecutionError::PublicValueNotEqual",
                        "public_value_index"
                      |) in
                    let γ1_2 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "openvm_circuit::arch::execution::ExecutionError::PublicValueNotEqual",
                        "existing_value"
                      |) in
                    let γ1_3 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "openvm_circuit::arch::execution::ExecutionError::PublicValueNotEqual",
                        "new_value"
                      |) in
                    let __self_0 :=
                      M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "u32" ], γ1_0 |) in
                    let __self_1 :=
                      M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "usize" ], γ1_1 |) in
                    let __self_2 :=
                      M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "usize" ], γ1_2 |) in
                    let __self_3 :=
                      M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "usize" ], γ1_3 |) in
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                      M.get_associated_function (|
                        Ty.path "core::fmt::Formatter",
                        "debug_struct_field4_finish",
                        [],
                        []
                      |),
                      [
                        M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (| mk_str (| "PublicValueNotEqual" |) |)
                        |);
                        M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "pc" |) |) |);
                        M.call_closure (|
                          Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ],
                          M.pointer_coercion
                            M.PointerCoercion.Unsize
                            (Ty.apply (Ty.path "&") [] [ Ty.path "u32" ])
                            (Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ]),
                          [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |) ]
                        |);
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (| mk_str (| "public_value_index" |) |)
                        |);
                        M.call_closure (|
                          Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ],
                          M.pointer_coercion
                            M.PointerCoercion.Unsize
                            (Ty.apply (Ty.path "&") [] [ Ty.path "usize" ])
                            (Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ]),
                          [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_1 |) |) |) ]
                        |);
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (| mk_str (| "existing_value" |) |)
                        |);
                        M.call_closure (|
                          Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ],
                          M.pointer_coercion
                            M.PointerCoercion.Unsize
                            (Ty.apply (Ty.path "&") [] [ Ty.path "usize" ])
                            (Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ]),
                          [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_2 |) |) |) ]
                        |);
                        M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "new_value" |) |) |);
                        M.call_closure (|
                          Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ],
                          M.pointer_coercion
                            M.PointerCoercion.Unsize
                            (Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.apply (Ty.path "&") [] [ Ty.path "usize" ] ])
                            (Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ]),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (| M.borrow (| Pointer.Kind.Ref, __self_3 |) |)
                            |)
                          ]
                        |)
                      ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.deref (| M.read (| γ |) |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "openvm_circuit::arch::execution::ExecutionError::PhantomNotFound",
                        "pc"
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "openvm_circuit::arch::execution::ExecutionError::PhantomNotFound",
                        "discriminant"
                      |) in
                    let __self_0 :=
                      M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "u32" ], γ1_0 |) in
                    let __self_1 :=
                      M.alloc (|
                        Ty.apply
                          (Ty.path "&")
                          []
                          [ Ty.path "openvm_instructions::phantom::PhantomDiscriminant" ],
                        γ1_1
                      |) in
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                      M.get_associated_function (|
                        Ty.path "core::fmt::Formatter",
                        "debug_struct_field2_finish",
                        [],
                        []
                      |),
                      [
                        M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (| mk_str (| "PhantomNotFound" |) |)
                        |);
                        M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "pc" |) |) |);
                        M.call_closure (|
                          Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ],
                          M.pointer_coercion
                            M.PointerCoercion.Unsize
                            (Ty.apply (Ty.path "&") [] [ Ty.path "u32" ])
                            (Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ]),
                          [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |) ]
                        |);
                        M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "discriminant" |) |) |);
                        M.call_closure (|
                          Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ],
                          M.pointer_coercion
                            M.PointerCoercion.Unsize
                            (Ty.apply
                              (Ty.path "&")
                              []
                              [
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [ Ty.path "openvm_instructions::phantom::PhantomDiscriminant" ]
                              ])
                            (Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ]),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (| M.borrow (| Pointer.Kind.Ref, __self_1 |) |)
                            |)
                          ]
                        |)
                      ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.deref (| M.read (| γ |) |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "openvm_circuit::arch::execution::ExecutionError::Phantom",
                        "pc"
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "openvm_circuit::arch::execution::ExecutionError::Phantom",
                        "discriminant"
                      |) in
                    let γ1_2 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "openvm_circuit::arch::execution::ExecutionError::Phantom",
                        "inner"
                      |) in
                    let __self_0 :=
                      M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "u32" ], γ1_0 |) in
                    let __self_1 :=
                      M.alloc (|
                        Ty.apply
                          (Ty.path "&")
                          []
                          [ Ty.path "openvm_instructions::phantom::PhantomDiscriminant" ],
                        γ1_1
                      |) in
                    let __self_2 :=
                      M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "eyre::Report" ], γ1_2 |) in
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                      M.get_associated_function (|
                        Ty.path "core::fmt::Formatter",
                        "debug_struct_field3_finish",
                        [],
                        []
                      |),
                      [
                        M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                        M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "Phantom" |) |) |);
                        M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "pc" |) |) |);
                        M.call_closure (|
                          Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ],
                          M.pointer_coercion
                            M.PointerCoercion.Unsize
                            (Ty.apply (Ty.path "&") [] [ Ty.path "u32" ])
                            (Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ]),
                          [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |) ]
                        |);
                        M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "discriminant" |) |) |);
                        M.call_closure (|
                          Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ],
                          M.pointer_coercion
                            M.PointerCoercion.Unsize
                            (Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.path "openvm_instructions::phantom::PhantomDiscriminant" ])
                            (Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ]),
                          [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_1 |) |) |) ]
                        |);
                        M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "inner" |) |) |);
                        M.call_closure (|
                          Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ],
                          M.pointer_coercion
                            M.PointerCoercion.Unsize
                            (Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.apply (Ty.path "&") [] [ Ty.path "eyre::Report" ] ])
                            (Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ]),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (| M.borrow (| Pointer.Kind.Ref, __self_2 |) |)
                            |)
                          ]
                        |)
                      ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.deref (| M.read (| γ |) |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "openvm_circuit::arch::execution::ExecutionError::DidNotTerminate"
                      |) in
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                      M.get_associated_function (|
                        Ty.path "core::fmt::Formatter",
                        "write_str",
                        [],
                        []
                      |),
                      [
                        M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (| mk_str (| "DidNotTerminate" |) |)
                        |)
                      ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.deref (| M.read (| γ |) |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "openvm_circuit::arch::execution::ExecutionError::FailedWithExitCode",
                        0
                      |) in
                    let __self_0 :=
                      M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "u32" ], γ1_0 |) in
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                      M.get_associated_function (|
                        Ty.path "core::fmt::Formatter",
                        "debug_tuple_field1_finish",
                        [],
                        []
                      |),
                      [
                        M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (| mk_str (| "FailedWithExitCode" |) |)
                        |);
                        M.call_closure (|
                          Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ],
                          M.pointer_coercion
                            M.PointerCoercion.Unsize
                            (Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.apply (Ty.path "&") [] [ Ty.path "u32" ] ])
                            (Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ]),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (| M.borrow (| Pointer.Kind.Ref, __self_0 |) |)
                            |)
                          ]
                        |)
                      ]
                    |)))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Debug"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Debug_for_openvm_circuit_arch_execution_ExecutionError.
    
    (* Trait *)
    (* Empty module 'InstructionExecutor' *)
    
    Module Impl_openvm_circuit_arch_execution_InstructionExecutor_where_openvm_circuit_arch_execution_InstructionExecutor_C_F_F_for_core_cell_RefCell_C.
      Definition Self (F C : Ty.t) : Ty.t := Ty.apply (Ty.path "core::cell::RefCell") [] [ C ].
      
      (*
          fn execute(
              &mut self,
              memory: &mut MemoryController<F>,
              instruction: &Instruction<F>,
              prev_state: ExecutionState<u32>,
          ) -> Result<ExecutionState<u32>> {
              self.borrow_mut().execute(memory, instruction, prev_state)
          }
      *)
      Definition execute (F C : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F C in
        match ε, τ, α with
        | [], [], [ self; memory; instruction; prev_state ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "core::cell::RefCell") [] [ C ] ],
                self
              |) in
            let memory :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&mut")
                  []
                  [
                    Ty.apply
                      (Ty.path "openvm_circuit::system::memory::controller::MemoryController")
                      []
                      [ F ]
                  ],
                memory
              |) in
            let instruction :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.apply (Ty.path "openvm_instructions::instruction::Instruction") [] [ F ] ],
                instruction
              |) in
            let prev_state :=
              M.alloc (|
                Ty.apply
                  (Ty.path "openvm_circuit::arch::execution::ExecutionState")
                  []
                  [ Ty.path "u32" ],
                prev_state
              |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply
                    (Ty.path "openvm_circuit::arch::execution::ExecutionState")
                    []
                    [ Ty.path "u32" ];
                  Ty.path "openvm_circuit::arch::execution::ExecutionError"
                ],
              M.get_trait_method (|
                "openvm_circuit::arch::execution::InstructionExecutor",
                C,
                [],
                [ F ],
                "execute",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply (Ty.path "&mut") [] [ C ],
                      M.get_trait_method (|
                        "core::ops::deref::DerefMut",
                        Ty.apply (Ty.path "core::cell::RefMut") [] [ C ],
                        [],
                        [],
                        "deref_mut",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.alloc (|
                            Ty.apply (Ty.path "core::cell::RefMut") [] [ C ],
                            M.call_closure (|
                              Ty.apply (Ty.path "core::cell::RefMut") [] [ C ],
                              M.get_associated_function (|
                                Ty.apply (Ty.path "core::cell::RefCell") [] [ C ],
                                "borrow_mut",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                            |)
                          |)
                        |)
                      ]
                    |)
                  |)
                |);
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| memory |) |) |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| instruction |) |) |);
                M.read (| prev_state |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn get_opcode_name(&self, opcode: usize) -> String {
              self.borrow().get_opcode_name(opcode)
          }
      *)
      Definition get_opcode_name
          (F C : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self F C in
        match ε, τ, α with
        | [], [], [ self; opcode ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "core::cell::RefCell") [] [ C ] ],
                self
              |) in
            let opcode := M.alloc (| Ty.path "usize", opcode |) in
            M.call_closure (|
              Ty.path "alloc::string::String",
              M.get_trait_method (|
                "openvm_circuit::arch::execution::InstructionExecutor",
                C,
                [],
                [ F ],
                "get_opcode_name",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply (Ty.path "&") [] [ C ],
                      M.get_trait_method (|
                        "core::ops::deref::Deref",
                        Ty.apply (Ty.path "core::cell::Ref") [] [ C ],
                        [],
                        [],
                        "deref",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.alloc (|
                            Ty.apply (Ty.path "core::cell::Ref") [] [ C ],
                            M.call_closure (|
                              Ty.apply (Ty.path "core::cell::Ref") [] [ C ],
                              M.get_associated_function (|
                                Ty.apply (Ty.path "core::cell::RefCell") [] [ C ],
                                "borrow",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                            |)
                          |)
                        |)
                      ]
                    |)
                  |)
                |);
                M.read (| opcode |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (F C : Ty.t),
        M.IsTraitInstance
          "openvm_circuit::arch::execution::InstructionExecutor"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ F ]
          (Self F C)
          (* Instance *)
          [
            ("execute", InstanceField.Method (execute F C));
            ("get_opcode_name", InstanceField.Method (get_opcode_name F C))
          ].
    End Impl_openvm_circuit_arch_execution_InstructionExecutor_where_openvm_circuit_arch_execution_InstructionExecutor_C_F_F_for_core_cell_RefCell_C.
    
    Module Impl_openvm_circuit_arch_execution_InstructionExecutor_where_openvm_circuit_arch_execution_InstructionExecutor_C_F_F_for_alloc_rc_Rc_core_cell_RefCell_C_alloc_alloc_Global.
      Definition Self (F C : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "alloc::rc::Rc")
          []
          [ Ty.apply (Ty.path "core::cell::RefCell") [] [ C ]; Ty.path "alloc::alloc::Global" ].
      
      (*
          fn execute(
              &mut self,
              memory: &mut MemoryController<F>,
              instruction: &Instruction<F>,
              prev_state: ExecutionState<u32>,
          ) -> Result<ExecutionState<u32>> {
              self.borrow_mut().execute(memory, instruction, prev_state)
          }
      *)
      Definition execute (F C : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F C in
        match ε, τ, α with
        | [], [], [ self; memory; instruction; prev_state ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&mut")
                  []
                  [
                    Ty.apply
                      (Ty.path "alloc::rc::Rc")
                      []
                      [
                        Ty.apply (Ty.path "core::cell::RefCell") [] [ C ];
                        Ty.path "alloc::alloc::Global"
                      ]
                  ],
                self
              |) in
            let memory :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&mut")
                  []
                  [
                    Ty.apply
                      (Ty.path "openvm_circuit::system::memory::controller::MemoryController")
                      []
                      [ F ]
                  ],
                memory
              |) in
            let instruction :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.apply (Ty.path "openvm_instructions::instruction::Instruction") [] [ F ] ],
                instruction
              |) in
            let prev_state :=
              M.alloc (|
                Ty.apply
                  (Ty.path "openvm_circuit::arch::execution::ExecutionState")
                  []
                  [ Ty.path "u32" ],
                prev_state
              |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply
                    (Ty.path "openvm_circuit::arch::execution::ExecutionState")
                    []
                    [ Ty.path "u32" ];
                  Ty.path "openvm_circuit::arch::execution::ExecutionError"
                ],
              M.get_trait_method (|
                "openvm_circuit::arch::execution::InstructionExecutor",
                C,
                [],
                [ F ],
                "execute",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply (Ty.path "&mut") [] [ C ],
                      M.get_trait_method (|
                        "core::ops::deref::DerefMut",
                        Ty.apply (Ty.path "core::cell::RefMut") [] [ C ],
                        [],
                        [],
                        "deref_mut",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.alloc (|
                            Ty.apply (Ty.path "core::cell::RefMut") [] [ C ],
                            M.call_closure (|
                              Ty.apply (Ty.path "core::cell::RefMut") [] [ C ],
                              M.get_associated_function (|
                                Ty.apply (Ty.path "core::cell::RefCell") [] [ C ],
                                "borrow_mut",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "&")
                                        []
                                        [ Ty.apply (Ty.path "core::cell::RefCell") [] [ C ] ],
                                      M.get_trait_method (|
                                        "core::ops::deref::Deref",
                                        Ty.apply
                                          (Ty.path "alloc::rc::Rc")
                                          []
                                          [
                                            Ty.apply (Ty.path "core::cell::RefCell") [] [ C ];
                                            Ty.path "alloc::alloc::Global"
                                          ],
                                        [],
                                        [],
                                        "deref",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| self |) |)
                                        |)
                                      ]
                                    |)
                                  |)
                                |)
                              ]
                            |)
                          |)
                        |)
                      ]
                    |)
                  |)
                |);
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| memory |) |) |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| instruction |) |) |);
                M.read (| prev_state |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn get_opcode_name(&self, opcode: usize) -> String {
              self.borrow().get_opcode_name(opcode)
          }
      *)
      Definition get_opcode_name
          (F C : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self F C in
        match ε, τ, α with
        | [], [], [ self; opcode ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path "alloc::rc::Rc")
                      []
                      [
                        Ty.apply (Ty.path "core::cell::RefCell") [] [ C ];
                        Ty.path "alloc::alloc::Global"
                      ]
                  ],
                self
              |) in
            let opcode := M.alloc (| Ty.path "usize", opcode |) in
            M.call_closure (|
              Ty.path "alloc::string::String",
              M.get_trait_method (|
                "openvm_circuit::arch::execution::InstructionExecutor",
                C,
                [],
                [ F ],
                "get_opcode_name",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply (Ty.path "&") [] [ C ],
                      M.get_trait_method (|
                        "core::ops::deref::Deref",
                        Ty.apply (Ty.path "core::cell::Ref") [] [ C ],
                        [],
                        [],
                        "deref",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.alloc (|
                            Ty.apply (Ty.path "core::cell::Ref") [] [ C ],
                            M.call_closure (|
                              Ty.apply (Ty.path "core::cell::Ref") [] [ C ],
                              M.get_associated_function (|
                                Ty.apply (Ty.path "core::cell::RefCell") [] [ C ],
                                "borrow",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "&")
                                        []
                                        [ Ty.apply (Ty.path "core::cell::RefCell") [] [ C ] ],
                                      M.get_trait_method (|
                                        "core::ops::deref::Deref",
                                        Ty.apply
                                          (Ty.path "alloc::rc::Rc")
                                          []
                                          [
                                            Ty.apply (Ty.path "core::cell::RefCell") [] [ C ];
                                            Ty.path "alloc::alloc::Global"
                                          ],
                                        [],
                                        [],
                                        "deref",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| self |) |)
                                        |)
                                      ]
                                    |)
                                  |)
                                |)
                              ]
                            |)
                          |)
                        |)
                      ]
                    |)
                  |)
                |);
                M.read (| opcode |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (F C : Ty.t),
        M.IsTraitInstance
          "openvm_circuit::arch::execution::InstructionExecutor"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ F ]
          (Self F C)
          (* Instance *)
          [
            ("execute", InstanceField.Method (execute F C));
            ("get_opcode_name", InstanceField.Method (get_opcode_name F C))
          ].
    End Impl_openvm_circuit_arch_execution_InstructionExecutor_where_openvm_circuit_arch_execution_InstructionExecutor_C_F_F_for_alloc_rc_Rc_core_cell_RefCell_C_alloc_alloc_Global.
    
    (* StructRecord
      {
        name := "ExecutionState";
        const_params := [];
        ty_params := [ "T" ];
        fields := [ ("pc", T); ("timestamp", T) ];
      } *)
    
    Module Impl_core_clone_Clone_where_core_clone_Clone_T_for_openvm_circuit_arch_execution_ExecutionState_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "openvm_circuit::arch::execution::ExecutionState") [] [ T ].
      
      (* Clone *)
      Definition clone (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.apply (Ty.path "openvm_circuit::arch::execution::ExecutionState") [] [ T ] ],
                self
              |) in
            Value.mkStructRecord
              "openvm_circuit::arch::execution::ExecutionState"
              []
              [ T ]
              [
                ("pc",
                  M.call_closure (|
                    T,
                    M.get_trait_method (| "core::clone::Clone", T, [], [], "clone", [], [] |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "openvm_circuit::arch::execution::ExecutionState",
                              "pc"
                            |)
                          |)
                        |)
                      |)
                    ]
                  |));
                ("timestamp",
                  M.call_closure (|
                    T,
                    M.get_trait_method (| "core::clone::Clone", T, [], [], "clone", [], [] |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "openvm_circuit::arch::execution::ExecutionState",
                              "timestamp"
                            |)
                          |)
                        |)
                      |)
                    ]
                  |))
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::clone::Clone"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [ ("clone", InstanceField.Method (clone T)) ].
    End Impl_core_clone_Clone_where_core_clone_Clone_T_for_openvm_circuit_arch_execution_ExecutionState_T.
    
    Module Impl_core_marker_Copy_where_core_marker_Copy_T_for_openvm_circuit_arch_execution_ExecutionState_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "openvm_circuit::arch::execution::ExecutionState") [] [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::marker::Copy"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [].
    End Impl_core_marker_Copy_where_core_marker_Copy_T_for_openvm_circuit_arch_execution_ExecutionState_T.
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_openvm_circuit_arch_execution_ExecutionState_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "openvm_circuit::arch::execution::ExecutionState") [] [ T ].
      
      (* Debug *)
      Definition fmt (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.apply (Ty.path "openvm_circuit::arch::execution::ExecutionState") [] [ T ] ],
                self
              |) in
            let f :=
              M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "core::fmt::Formatter" ], f |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
              M.get_associated_function (|
                Ty.path "core::fmt::Formatter",
                "debug_struct_field2_finish",
                [],
                []
              |),
              [
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "ExecutionState" |) |) |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "pc" |) |) |);
                M.call_closure (|
                  Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ],
                  M.pointer_coercion
                    M.PointerCoercion.Unsize
                    (Ty.apply (Ty.path "&") [] [ T ])
                    (Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ]),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "openvm_circuit::arch::execution::ExecutionState",
                            "pc"
                          |)
                        |)
                      |)
                    |)
                  ]
                |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "timestamp" |) |) |);
                M.call_closure (|
                  Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ],
                  M.pointer_coercion
                    M.PointerCoercion.Unsize
                    (Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "&") [] [ T ] ])
                    (Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ]),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.alloc (|
                            Ty.apply (Ty.path "&") [] [ T ],
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "openvm_circuit::arch::execution::ExecutionState",
                                "timestamp"
                              |)
                            |)
                          |)
                        |)
                      |)
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [ ("fmt", InstanceField.Method (fmt T)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_openvm_circuit_arch_execution_ExecutionState_T.
    
    Module Impl_core_marker_StructuralPartialEq_for_openvm_circuit_arch_execution_ExecutionState_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "openvm_circuit::arch::execution::ExecutionState") [] [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::marker::StructuralPartialEq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [].
    End Impl_core_marker_StructuralPartialEq_for_openvm_circuit_arch_execution_ExecutionState_T.
    
    Module Impl_core_cmp_PartialEq_where_core_cmp_PartialEq_T_openvm_circuit_arch_execution_ExecutionState_T_for_openvm_circuit_arch_execution_ExecutionState_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "openvm_circuit::arch::execution::ExecutionState") [] [ T ].
      
      (* PartialEq *)
      Definition eq (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.apply (Ty.path "openvm_circuit::arch::execution::ExecutionState") [] [ T ] ],
                self
              |) in
            let other :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.apply (Ty.path "openvm_circuit::arch::execution::ExecutionState") [] [ T ] ],
                other
              |) in
            LogicalOp.and (|
              M.call_closure (|
                Ty.path "bool",
                M.get_trait_method (| "core::cmp::PartialEq", T, [], [ T ], "eq", [], [] |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "openvm_circuit::arch::execution::ExecutionState",
                      "pc"
                    |)
                  |);
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| other |) |),
                      "openvm_circuit::arch::execution::ExecutionState",
                      "pc"
                    |)
                  |)
                ]
              |),
              ltac:(M.monadic
                (M.call_closure (|
                  Ty.path "bool",
                  M.get_trait_method (| "core::cmp::PartialEq", T, [], [ T ], "eq", [], [] |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "openvm_circuit::arch::execution::ExecutionState",
                        "timestamp"
                      |)
                    |);
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| other |) |),
                        "openvm_circuit::arch::execution::ExecutionState",
                        "timestamp"
                      |)
                    |)
                  ]
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::cmp::PartialEq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "openvm_circuit::arch::execution::ExecutionState") [] [ T ] ]
          (Self T)
          (* Instance *) [ ("eq", InstanceField.Method (eq T)) ].
    End Impl_core_cmp_PartialEq_where_core_cmp_PartialEq_T_openvm_circuit_arch_execution_ExecutionState_T_for_openvm_circuit_arch_execution_ExecutionState_T.
    
    Module Impl_core_default_Default_where_core_default_Default_T_for_openvm_circuit_arch_execution_ExecutionState_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "openvm_circuit::arch::execution::ExecutionState") [] [ T ].
      
      (* Default *)
      Definition default (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [] =>
          ltac:(M.monadic
            (Value.mkStructRecord
              "openvm_circuit::arch::execution::ExecutionState"
              []
              [ T ]
              [
                ("pc",
                  M.call_closure (|
                    T,
                    M.get_trait_method (| "core::default::Default", T, [], [], "default", [], [] |),
                    []
                  |));
                ("timestamp",
                  M.call_closure (|
                    T,
                    M.get_trait_method (| "core::default::Default", T, [], [], "default", [], [] |),
                    []
                  |))
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::default::Default"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [ ("default", InstanceField.Method (default T)) ].
    End Impl_core_default_Default_where_core_default_Default_T_for_openvm_circuit_arch_execution_ExecutionState_T.
    
    Module Impl_core_borrow_Borrow_openvm_circuit_arch_execution_ExecutionState_T_for_slice_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "slice") [] [ T ].
      
      (* AlignedBorrow *)
      Definition borrow (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                self
              |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.match_operator (|
                  Ty.tuple [],
                  M.alloc (| Ty.tuple [], Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.use (M.alloc (| Ty.path "bool", Value.Bool true |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.read (|
                          let~ _ : Ty.tuple [] :=
                            M.match_operator (|
                              Ty.tuple [],
                              M.alloc (|
                                Ty.tuple
                                  [
                                    Ty.apply (Ty.path "&") [] [ Ty.path "usize" ];
                                    Ty.apply (Ty.path "&") [] [ Ty.path "usize" ]
                                  ],
                                Value.Tuple
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.alloc (|
                                        Ty.path "usize",
                                        M.call_closure (|
                                          Ty.path "usize",
                                          M.get_associated_function (|
                                            Ty.apply (Ty.path "slice") [] [ T ],
                                            "len",
                                            [],
                                            []
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (| M.read (| self |) |)
                                            |)
                                          ]
                                        |)
                                      |)
                                    |);
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.alloc (|
                                        Ty.path "usize",
                                        M.call_closure (|
                                          Ty.path "usize",
                                          M.get_associated_function (|
                                            Ty.apply
                                              (Ty.path
                                                "openvm_circuit::arch::execution::ExecutionState")
                                              []
                                              [ T ],
                                            "width",
                                            [],
                                            []
                                          |),
                                          []
                                        |)
                                      |)
                                    |)
                                  ]
                              |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                    let left_val :=
                                      M.copy (|
                                        Ty.apply (Ty.path "&") [] [ Ty.path "usize" ],
                                        γ0_0
                                      |) in
                                    let right_val :=
                                      M.copy (|
                                        Ty.apply (Ty.path "&") [] [ Ty.path "usize" ],
                                        γ0_1
                                      |) in
                                    M.match_operator (|
                                      Ty.tuple [],
                                      M.alloc (| Ty.tuple [], Value.Tuple [] |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ :=
                                              M.use
                                                (M.alloc (|
                                                  Ty.path "bool",
                                                  UnOp.not (|
                                                    M.call_closure (|
                                                      Ty.path "bool",
                                                      BinOp.eq,
                                                      [
                                                        M.read (|
                                                          M.deref (| M.read (| left_val |) |)
                                                        |);
                                                        M.read (|
                                                          M.deref (| M.read (| right_val |) |)
                                                        |)
                                                      ]
                                                    |)
                                                  |)
                                                |)) in
                                            let _ :=
                                              is_constant_or_break_match (|
                                                M.read (| γ |),
                                                Value.Bool true
                                              |) in
                                            M.never_to_any (|
                                              M.read (|
                                                let~ kind : Ty.path "core::panicking::AssertKind" :=
                                                  Value.StructTuple
                                                    "core::panicking::AssertKind::Eq"
                                                    []
                                                    []
                                                    [] in
                                                M.alloc (|
                                                  Ty.path "never",
                                                  M.call_closure (|
                                                    Ty.path "never",
                                                    M.get_function (|
                                                      "core::panicking::assert_failed",
                                                      [],
                                                      [ Ty.path "usize"; Ty.path "usize" ]
                                                    |),
                                                    [
                                                      M.read (| kind |);
                                                      M.borrow (|
                                                        Pointer.Kind.Ref,
                                                        M.deref (|
                                                          M.borrow (|
                                                            Pointer.Kind.Ref,
                                                            M.deref (| M.read (| left_val |) |)
                                                          |)
                                                        |)
                                                      |);
                                                      M.borrow (|
                                                        Pointer.Kind.Ref,
                                                        M.deref (|
                                                          M.borrow (|
                                                            Pointer.Kind.Ref,
                                                            M.deref (| M.read (| right_val |) |)
                                                          |)
                                                        |)
                                                      |);
                                                      Value.StructTuple
                                                        "core::option::Option::None"
                                                        []
                                                        [ Ty.path "core::fmt::Arguments" ]
                                                        []
                                                    ]
                                                  |)
                                                |)
                                              |)
                                            |)));
                                        fun γ => ltac:(M.monadic (Value.Tuple []))
                                      ]
                                    |)))
                              ]
                            |) in
                          M.alloc (| Ty.tuple [], Value.Tuple [] |)
                        |)));
                    fun γ => ltac:(M.monadic (Value.Tuple []))
                  ]
                |) in
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.apply (Ty.path "openvm_circuit::arch::execution::ExecutionState") [] [ T ] ],
                M.match_operator (|
                  Ty.apply
                    (Ty.path "&")
                    []
                    [ Ty.apply (Ty.path "openvm_circuit::arch::execution::ExecutionState") [] [ T ]
                    ],
                  M.alloc (|
                    Ty.tuple
                      [
                        Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ];
                        Ty.apply
                          (Ty.path "&")
                          []
                          [
                            Ty.apply
                              (Ty.path "slice")
                              []
                              [
                                Ty.apply
                                  (Ty.path "openvm_circuit::arch::execution::ExecutionState")
                                  []
                                  [ T ]
                              ]
                          ];
                        Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ]
                      ],
                    M.call_closure (|
                      Ty.tuple
                        [
                          Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ];
                          Ty.apply
                            (Ty.path "&")
                            []
                            [
                              Ty.apply
                                (Ty.path "slice")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "openvm_circuit::arch::execution::ExecutionState")
                                    []
                                    [ T ]
                                ]
                            ];
                          Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ]
                        ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "slice") [] [ T ],
                        "align_to",
                        [],
                        [
                          Ty.apply
                            (Ty.path "openvm_circuit::arch::execution::ExecutionState")
                            []
                            [ T ]
                        ]
                      |),
                      [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                        let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                        let γ0_2 := M.SubPointer.get_tuple_field (| γ, 2 |) in
                        let prefix :=
                          M.copy (|
                            Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                            γ0_0
                          |) in
                        let shorts :=
                          M.copy (|
                            Ty.apply
                              (Ty.path "&")
                              []
                              [
                                Ty.apply
                                  (Ty.path "slice")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "openvm_circuit::arch::execution::ExecutionState")
                                      []
                                      [ T ]
                                  ]
                              ],
                            γ0_1
                          |) in
                        let _suffix :=
                          M.copy (|
                            Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                            γ0_2
                          |) in
                        M.read (|
                          let~ _ : Ty.tuple [] :=
                            M.match_operator (|
                              Ty.tuple [],
                              M.alloc (| Ty.tuple [], Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ :=
                                      M.use (M.alloc (| Ty.path "bool", Value.Bool true |)) in
                                    let _ :=
                                      is_constant_or_break_match (|
                                        M.read (| γ |),
                                        Value.Bool true
                                      |) in
                                    M.read (|
                                      let~ _ : Ty.tuple [] :=
                                        M.match_operator (|
                                          Ty.tuple [],
                                          M.alloc (| Ty.tuple [], Value.Tuple [] |),
                                          [
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let γ :=
                                                  M.use
                                                    (M.alloc (|
                                                      Ty.path "bool",
                                                      UnOp.not (|
                                                        M.call_closure (|
                                                          Ty.path "bool",
                                                          M.get_associated_function (|
                                                            Ty.apply (Ty.path "slice") [] [ T ],
                                                            "is_empty",
                                                            [],
                                                            []
                                                          |),
                                                          [
                                                            M.borrow (|
                                                              Pointer.Kind.Ref,
                                                              M.deref (| M.read (| prefix |) |)
                                                            |)
                                                          ]
                                                        |)
                                                      |)
                                                    |)) in
                                                let _ :=
                                                  is_constant_or_break_match (|
                                                    M.read (| γ |),
                                                    Value.Bool true
                                                  |) in
                                                M.never_to_any (|
                                                  M.call_closure (|
                                                    Ty.path "never",
                                                    M.get_function (|
                                                      "core::panicking::panic_fmt",
                                                      [],
                                                      []
                                                    |),
                                                    [
                                                      M.call_closure (|
                                                        Ty.path "core::fmt::Arguments",
                                                        M.get_associated_function (|
                                                          Ty.path "core::fmt::Arguments",
                                                          "new_const",
                                                          [ Value.Integer IntegerKind.Usize 1 ],
                                                          []
                                                        |),
                                                        [
                                                          M.borrow (|
                                                            Pointer.Kind.Ref,
                                                            M.deref (|
                                                              M.borrow (|
                                                                Pointer.Kind.Ref,
                                                                M.alloc (|
                                                                  Ty.apply
                                                                    (Ty.path "array")
                                                                    [
                                                                      Value.Integer
                                                                        IntegerKind.Usize
                                                                        1
                                                                    ]
                                                                    [
                                                                      Ty.apply
                                                                        (Ty.path "&")
                                                                        []
                                                                        [ Ty.path "str" ]
                                                                    ],
                                                                  Value.Array
                                                                    [
                                                                      mk_str (|
                                                                        "Alignment should match"
                                                                      |)
                                                                    ]
                                                                |)
                                                              |)
                                                            |)
                                                          |)
                                                        ]
                                                      |)
                                                    ]
                                                  |)
                                                |)));
                                            fun γ => ltac:(M.monadic (Value.Tuple []))
                                          ]
                                        |) in
                                      M.alloc (| Ty.tuple [], Value.Tuple [] |)
                                    |)));
                                fun γ => ltac:(M.monadic (Value.Tuple []))
                              ]
                            |) in
                          let~ _ : Ty.tuple [] :=
                            M.match_operator (|
                              Ty.tuple [],
                              M.alloc (| Ty.tuple [], Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ :=
                                      M.use (M.alloc (| Ty.path "bool", Value.Bool true |)) in
                                    let _ :=
                                      is_constant_or_break_match (|
                                        M.read (| γ |),
                                        Value.Bool true
                                      |) in
                                    M.read (|
                                      let~ _ : Ty.tuple [] :=
                                        M.match_operator (|
                                          Ty.tuple [],
                                          M.alloc (|
                                            Ty.tuple
                                              [
                                                Ty.apply (Ty.path "&") [] [ Ty.path "usize" ];
                                                Ty.apply (Ty.path "&") [] [ Ty.path "usize" ]
                                              ],
                                            Value.Tuple
                                              [
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.alloc (|
                                                    Ty.path "usize",
                                                    M.call_closure (|
                                                      Ty.path "usize",
                                                      M.get_associated_function (|
                                                        Ty.apply
                                                          (Ty.path "slice")
                                                          []
                                                          [
                                                            Ty.apply
                                                              (Ty.path
                                                                "openvm_circuit::arch::execution::ExecutionState")
                                                              []
                                                              [ T ]
                                                          ],
                                                        "len",
                                                        [],
                                                        []
                                                      |),
                                                      [
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.deref (| M.read (| shorts |) |)
                                                        |)
                                                      ]
                                                    |)
                                                  |)
                                                |);
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.alloc (|
                                                    Ty.path "usize",
                                                    Value.Integer IntegerKind.Usize 1
                                                  |)
                                                |)
                                              ]
                                          |),
                                          [
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let γ0_0 :=
                                                  M.SubPointer.get_tuple_field (| γ, 0 |) in
                                                let γ0_1 :=
                                                  M.SubPointer.get_tuple_field (| γ, 1 |) in
                                                let left_val :=
                                                  M.copy (|
                                                    Ty.apply (Ty.path "&") [] [ Ty.path "usize" ],
                                                    γ0_0
                                                  |) in
                                                let right_val :=
                                                  M.copy (|
                                                    Ty.apply (Ty.path "&") [] [ Ty.path "usize" ],
                                                    γ0_1
                                                  |) in
                                                M.match_operator (|
                                                  Ty.tuple [],
                                                  M.alloc (| Ty.tuple [], Value.Tuple [] |),
                                                  [
                                                    fun γ =>
                                                      ltac:(M.monadic
                                                        (let γ :=
                                                          M.use
                                                            (M.alloc (|
                                                              Ty.path "bool",
                                                              UnOp.not (|
                                                                M.call_closure (|
                                                                  Ty.path "bool",
                                                                  BinOp.eq,
                                                                  [
                                                                    M.read (|
                                                                      M.deref (|
                                                                        M.read (| left_val |)
                                                                      |)
                                                                    |);
                                                                    M.read (|
                                                                      M.deref (|
                                                                        M.read (| right_val |)
                                                                      |)
                                                                    |)
                                                                  ]
                                                                |)
                                                              |)
                                                            |)) in
                                                        let _ :=
                                                          is_constant_or_break_match (|
                                                            M.read (| γ |),
                                                            Value.Bool true
                                                          |) in
                                                        M.never_to_any (|
                                                          M.read (|
                                                            let~ kind :
                                                                Ty.path
                                                                  "core::panicking::AssertKind" :=
                                                              Value.StructTuple
                                                                "core::panicking::AssertKind::Eq"
                                                                []
                                                                []
                                                                [] in
                                                            M.alloc (|
                                                              Ty.path "never",
                                                              M.call_closure (|
                                                                Ty.path "never",
                                                                M.get_function (|
                                                                  "core::panicking::assert_failed",
                                                                  [],
                                                                  [ Ty.path "usize"; Ty.path "usize"
                                                                  ]
                                                                |),
                                                                [
                                                                  M.read (| kind |);
                                                                  M.borrow (|
                                                                    Pointer.Kind.Ref,
                                                                    M.deref (|
                                                                      M.borrow (|
                                                                        Pointer.Kind.Ref,
                                                                        M.deref (|
                                                                          M.read (| left_val |)
                                                                        |)
                                                                      |)
                                                                    |)
                                                                  |);
                                                                  M.borrow (|
                                                                    Pointer.Kind.Ref,
                                                                    M.deref (|
                                                                      M.borrow (|
                                                                        Pointer.Kind.Ref,
                                                                        M.deref (|
                                                                          M.read (| right_val |)
                                                                        |)
                                                                      |)
                                                                    |)
                                                                  |);
                                                                  Value.StructTuple
                                                                    "core::option::Option::None"
                                                                    []
                                                                    [ Ty.path "core::fmt::Arguments"
                                                                    ]
                                                                    []
                                                                ]
                                                              |)
                                                            |)
                                                          |)
                                                        |)));
                                                    fun γ => ltac:(M.monadic (Value.Tuple []))
                                                  ]
                                                |)))
                                          ]
                                        |) in
                                      M.alloc (| Ty.tuple [], Value.Tuple [] |)
                                    |)));
                                fun γ => ltac:(M.monadic (Value.Tuple []))
                              ]
                            |) in
                          M.alloc (|
                            Ty.apply
                              (Ty.path "&")
                              []
                              [
                                Ty.apply
                                  (Ty.path "openvm_circuit::arch::execution::ExecutionState")
                                  []
                                  [ T ]
                              ],
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.SubPointer.get_array_field (|
                                    M.deref (| M.read (| shorts |) |),
                                    Value.Integer IntegerKind.Usize 0
                                  |)
                                |)
                              |)
                            |)
                          |)
                        |)))
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::borrow::Borrow"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "openvm_circuit::arch::execution::ExecutionState") [] [ T ] ]
          (Self T)
          (* Instance *) [ ("borrow", InstanceField.Method (borrow T)) ].
    End Impl_core_borrow_Borrow_openvm_circuit_arch_execution_ExecutionState_T_for_slice_T.
    
    Module Impl_core_borrow_BorrowMut_openvm_circuit_arch_execution_ExecutionState_T_for_slice_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "slice") [] [ T ].
      
      (* AlignedBorrow *)
      Definition borrow_mut (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                self
              |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.read (|
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      Ty.tuple [],
                      M.alloc (| Ty.tuple [], Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.use (M.alloc (| Ty.path "bool", Value.Bool true |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.read (|
                              let~ _ : Ty.tuple [] :=
                                M.match_operator (|
                                  Ty.tuple [],
                                  M.alloc (|
                                    Ty.tuple
                                      [
                                        Ty.apply (Ty.path "&") [] [ Ty.path "usize" ];
                                        Ty.apply (Ty.path "&") [] [ Ty.path "usize" ]
                                      ],
                                    Value.Tuple
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.alloc (|
                                            Ty.path "usize",
                                            M.call_closure (|
                                              Ty.path "usize",
                                              M.get_associated_function (|
                                                Ty.apply (Ty.path "slice") [] [ T ],
                                                "len",
                                                [],
                                                []
                                              |),
                                              [
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (| M.read (| self |) |)
                                                |)
                                              ]
                                            |)
                                          |)
                                        |);
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.alloc (|
                                            Ty.path "usize",
                                            M.call_closure (|
                                              Ty.path "usize",
                                              M.get_associated_function (|
                                                Ty.apply
                                                  (Ty.path
                                                    "openvm_circuit::arch::execution::ExecutionState")
                                                  []
                                                  [ T ],
                                                "width",
                                                [],
                                                []
                                              |),
                                              []
                                            |)
                                          |)
                                        |)
                                      ]
                                  |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                        let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                        let left_val :=
                                          M.copy (|
                                            Ty.apply (Ty.path "&") [] [ Ty.path "usize" ],
                                            γ0_0
                                          |) in
                                        let right_val :=
                                          M.copy (|
                                            Ty.apply (Ty.path "&") [] [ Ty.path "usize" ],
                                            γ0_1
                                          |) in
                                        M.match_operator (|
                                          Ty.tuple [],
                                          M.alloc (| Ty.tuple [], Value.Tuple [] |),
                                          [
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let γ :=
                                                  M.use
                                                    (M.alloc (|
                                                      Ty.path "bool",
                                                      UnOp.not (|
                                                        M.call_closure (|
                                                          Ty.path "bool",
                                                          BinOp.eq,
                                                          [
                                                            M.read (|
                                                              M.deref (| M.read (| left_val |) |)
                                                            |);
                                                            M.read (|
                                                              M.deref (| M.read (| right_val |) |)
                                                            |)
                                                          ]
                                                        |)
                                                      |)
                                                    |)) in
                                                let _ :=
                                                  is_constant_or_break_match (|
                                                    M.read (| γ |),
                                                    Value.Bool true
                                                  |) in
                                                M.never_to_any (|
                                                  M.read (|
                                                    let~ kind :
                                                        Ty.path "core::panicking::AssertKind" :=
                                                      Value.StructTuple
                                                        "core::panicking::AssertKind::Eq"
                                                        []
                                                        []
                                                        [] in
                                                    M.alloc (|
                                                      Ty.path "never",
                                                      M.call_closure (|
                                                        Ty.path "never",
                                                        M.get_function (|
                                                          "core::panicking::assert_failed",
                                                          [],
                                                          [ Ty.path "usize"; Ty.path "usize" ]
                                                        |),
                                                        [
                                                          M.read (| kind |);
                                                          M.borrow (|
                                                            Pointer.Kind.Ref,
                                                            M.deref (|
                                                              M.borrow (|
                                                                Pointer.Kind.Ref,
                                                                M.deref (| M.read (| left_val |) |)
                                                              |)
                                                            |)
                                                          |);
                                                          M.borrow (|
                                                            Pointer.Kind.Ref,
                                                            M.deref (|
                                                              M.borrow (|
                                                                Pointer.Kind.Ref,
                                                                M.deref (| M.read (| right_val |) |)
                                                              |)
                                                            |)
                                                          |);
                                                          Value.StructTuple
                                                            "core::option::Option::None"
                                                            []
                                                            [ Ty.path "core::fmt::Arguments" ]
                                                            []
                                                        ]
                                                      |)
                                                    |)
                                                  |)
                                                |)));
                                            fun γ => ltac:(M.monadic (Value.Tuple []))
                                          ]
                                        |)))
                                  ]
                                |) in
                              M.alloc (| Ty.tuple [], Value.Tuple [] |)
                            |)));
                        fun γ => ltac:(M.monadic (Value.Tuple []))
                      ]
                    |) in
                  M.alloc (|
                    Ty.apply
                      (Ty.path "&mut")
                      []
                      [
                        Ty.apply
                          (Ty.path "openvm_circuit::arch::execution::ExecutionState")
                          []
                          [ T ]
                      ],
                    M.match_operator (|
                      Ty.apply
                        (Ty.path "&mut")
                        []
                        [
                          Ty.apply
                            (Ty.path "openvm_circuit::arch::execution::ExecutionState")
                            []
                            [ T ]
                        ],
                      M.alloc (|
                        Ty.tuple
                          [
                            Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ];
                            Ty.apply
                              (Ty.path "&mut")
                              []
                              [
                                Ty.apply
                                  (Ty.path "slice")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "openvm_circuit::arch::execution::ExecutionState")
                                      []
                                      [ T ]
                                  ]
                              ];
                            Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ]
                          ],
                        M.call_closure (|
                          Ty.tuple
                            [
                              Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ];
                              Ty.apply
                                (Ty.path "&mut")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "slice")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "openvm_circuit::arch::execution::ExecutionState")
                                        []
                                        [ T ]
                                    ]
                                ];
                              Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ]
                            ],
                          M.get_associated_function (|
                            Ty.apply (Ty.path "slice") [] [ T ],
                            "align_to_mut",
                            [],
                            [
                              Ty.apply
                                (Ty.path "openvm_circuit::arch::execution::ExecutionState")
                                []
                                [ T ]
                            ]
                          |),
                          [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |) ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_2 := M.SubPointer.get_tuple_field (| γ, 2 |) in
                            let prefix :=
                              M.copy (|
                                Ty.apply
                                  (Ty.path "&mut")
                                  []
                                  [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                γ0_0
                              |) in
                            let shorts :=
                              M.copy (|
                                Ty.apply
                                  (Ty.path "&mut")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "slice")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path
                                            "openvm_circuit::arch::execution::ExecutionState")
                                          []
                                          [ T ]
                                      ]
                                  ],
                                γ0_1
                              |) in
                            let _suffix :=
                              M.copy (|
                                Ty.apply
                                  (Ty.path "&mut")
                                  []
                                  [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                γ0_2
                              |) in
                            M.read (|
                              let~ _ : Ty.tuple [] :=
                                M.match_operator (|
                                  Ty.tuple [],
                                  M.alloc (| Ty.tuple [], Value.Tuple [] |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ :=
                                          M.use (M.alloc (| Ty.path "bool", Value.Bool true |)) in
                                        let _ :=
                                          is_constant_or_break_match (|
                                            M.read (| γ |),
                                            Value.Bool true
                                          |) in
                                        M.read (|
                                          let~ _ : Ty.tuple [] :=
                                            M.match_operator (|
                                              Ty.tuple [],
                                              M.alloc (| Ty.tuple [], Value.Tuple [] |),
                                              [
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (let γ :=
                                                      M.use
                                                        (M.alloc (|
                                                          Ty.path "bool",
                                                          UnOp.not (|
                                                            M.call_closure (|
                                                              Ty.path "bool",
                                                              M.get_associated_function (|
                                                                Ty.apply (Ty.path "slice") [] [ T ],
                                                                "is_empty",
                                                                [],
                                                                []
                                                              |),
                                                              [
                                                                M.borrow (|
                                                                  Pointer.Kind.Ref,
                                                                  M.deref (| M.read (| prefix |) |)
                                                                |)
                                                              ]
                                                            |)
                                                          |)
                                                        |)) in
                                                    let _ :=
                                                      is_constant_or_break_match (|
                                                        M.read (| γ |),
                                                        Value.Bool true
                                                      |) in
                                                    M.never_to_any (|
                                                      M.call_closure (|
                                                        Ty.path "never",
                                                        M.get_function (|
                                                          "core::panicking::panic_fmt",
                                                          [],
                                                          []
                                                        |),
                                                        [
                                                          M.call_closure (|
                                                            Ty.path "core::fmt::Arguments",
                                                            M.get_associated_function (|
                                                              Ty.path "core::fmt::Arguments",
                                                              "new_const",
                                                              [ Value.Integer IntegerKind.Usize 1 ],
                                                              []
                                                            |),
                                                            [
                                                              M.borrow (|
                                                                Pointer.Kind.Ref,
                                                                M.deref (|
                                                                  M.borrow (|
                                                                    Pointer.Kind.Ref,
                                                                    M.alloc (|
                                                                      Ty.apply
                                                                        (Ty.path "array")
                                                                        [
                                                                          Value.Integer
                                                                            IntegerKind.Usize
                                                                            1
                                                                        ]
                                                                        [
                                                                          Ty.apply
                                                                            (Ty.path "&")
                                                                            []
                                                                            [ Ty.path "str" ]
                                                                        ],
                                                                      Value.Array
                                                                        [
                                                                          mk_str (|
                                                                            "Alignment should match"
                                                                          |)
                                                                        ]
                                                                    |)
                                                                  |)
                                                                |)
                                                              |)
                                                            ]
                                                          |)
                                                        ]
                                                      |)
                                                    |)));
                                                fun γ => ltac:(M.monadic (Value.Tuple []))
                                              ]
                                            |) in
                                          M.alloc (| Ty.tuple [], Value.Tuple [] |)
                                        |)));
                                    fun γ => ltac:(M.monadic (Value.Tuple []))
                                  ]
                                |) in
                              let~ _ : Ty.tuple [] :=
                                M.match_operator (|
                                  Ty.tuple [],
                                  M.alloc (| Ty.tuple [], Value.Tuple [] |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ :=
                                          M.use (M.alloc (| Ty.path "bool", Value.Bool true |)) in
                                        let _ :=
                                          is_constant_or_break_match (|
                                            M.read (| γ |),
                                            Value.Bool true
                                          |) in
                                        M.read (|
                                          let~ _ : Ty.tuple [] :=
                                            M.match_operator (|
                                              Ty.tuple [],
                                              M.alloc (|
                                                Ty.tuple
                                                  [
                                                    Ty.apply (Ty.path "&") [] [ Ty.path "usize" ];
                                                    Ty.apply (Ty.path "&") [] [ Ty.path "usize" ]
                                                  ],
                                                Value.Tuple
                                                  [
                                                    M.borrow (|
                                                      Pointer.Kind.Ref,
                                                      M.alloc (|
                                                        Ty.path "usize",
                                                        M.call_closure (|
                                                          Ty.path "usize",
                                                          M.get_associated_function (|
                                                            Ty.apply
                                                              (Ty.path "slice")
                                                              []
                                                              [
                                                                Ty.apply
                                                                  (Ty.path
                                                                    "openvm_circuit::arch::execution::ExecutionState")
                                                                  []
                                                                  [ T ]
                                                              ],
                                                            "len",
                                                            [],
                                                            []
                                                          |),
                                                          [
                                                            M.borrow (|
                                                              Pointer.Kind.Ref,
                                                              M.deref (| M.read (| shorts |) |)
                                                            |)
                                                          ]
                                                        |)
                                                      |)
                                                    |);
                                                    M.borrow (|
                                                      Pointer.Kind.Ref,
                                                      M.alloc (|
                                                        Ty.path "usize",
                                                        Value.Integer IntegerKind.Usize 1
                                                      |)
                                                    |)
                                                  ]
                                              |),
                                              [
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (let γ0_0 :=
                                                      M.SubPointer.get_tuple_field (| γ, 0 |) in
                                                    let γ0_1 :=
                                                      M.SubPointer.get_tuple_field (| γ, 1 |) in
                                                    let left_val :=
                                                      M.copy (|
                                                        Ty.apply
                                                          (Ty.path "&")
                                                          []
                                                          [ Ty.path "usize" ],
                                                        γ0_0
                                                      |) in
                                                    let right_val :=
                                                      M.copy (|
                                                        Ty.apply
                                                          (Ty.path "&")
                                                          []
                                                          [ Ty.path "usize" ],
                                                        γ0_1
                                                      |) in
                                                    M.match_operator (|
                                                      Ty.tuple [],
                                                      M.alloc (| Ty.tuple [], Value.Tuple [] |),
                                                      [
                                                        fun γ =>
                                                          ltac:(M.monadic
                                                            (let γ :=
                                                              M.use
                                                                (M.alloc (|
                                                                  Ty.path "bool",
                                                                  UnOp.not (|
                                                                    M.call_closure (|
                                                                      Ty.path "bool",
                                                                      BinOp.eq,
                                                                      [
                                                                        M.read (|
                                                                          M.deref (|
                                                                            M.read (| left_val |)
                                                                          |)
                                                                        |);
                                                                        M.read (|
                                                                          M.deref (|
                                                                            M.read (| right_val |)
                                                                          |)
                                                                        |)
                                                                      ]
                                                                    |)
                                                                  |)
                                                                |)) in
                                                            let _ :=
                                                              is_constant_or_break_match (|
                                                                M.read (| γ |),
                                                                Value.Bool true
                                                              |) in
                                                            M.never_to_any (|
                                                              M.read (|
                                                                let~ kind :
                                                                    Ty.path
                                                                      "core::panicking::AssertKind" :=
                                                                  Value.StructTuple
                                                                    "core::panicking::AssertKind::Eq"
                                                                    []
                                                                    []
                                                                    [] in
                                                                M.alloc (|
                                                                  Ty.path "never",
                                                                  M.call_closure (|
                                                                    Ty.path "never",
                                                                    M.get_function (|
                                                                      "core::panicking::assert_failed",
                                                                      [],
                                                                      [
                                                                        Ty.path "usize";
                                                                        Ty.path "usize"
                                                                      ]
                                                                    |),
                                                                    [
                                                                      M.read (| kind |);
                                                                      M.borrow (|
                                                                        Pointer.Kind.Ref,
                                                                        M.deref (|
                                                                          M.borrow (|
                                                                            Pointer.Kind.Ref,
                                                                            M.deref (|
                                                                              M.read (| left_val |)
                                                                            |)
                                                                          |)
                                                                        |)
                                                                      |);
                                                                      M.borrow (|
                                                                        Pointer.Kind.Ref,
                                                                        M.deref (|
                                                                          M.borrow (|
                                                                            Pointer.Kind.Ref,
                                                                            M.deref (|
                                                                              M.read (| right_val |)
                                                                            |)
                                                                          |)
                                                                        |)
                                                                      |);
                                                                      Value.StructTuple
                                                                        "core::option::Option::None"
                                                                        []
                                                                        [
                                                                          Ty.path
                                                                            "core::fmt::Arguments"
                                                                        ]
                                                                        []
                                                                    ]
                                                                  |)
                                                                |)
                                                              |)
                                                            |)));
                                                        fun γ => ltac:(M.monadic (Value.Tuple []))
                                                      ]
                                                    |)))
                                              ]
                                            |) in
                                          M.alloc (| Ty.tuple [], Value.Tuple [] |)
                                        |)));
                                    fun γ => ltac:(M.monadic (Value.Tuple []))
                                  ]
                                |) in
                              M.alloc (|
                                Ty.apply
                                  (Ty.path "&mut")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "openvm_circuit::arch::execution::ExecutionState")
                                      []
                                      [ T ]
                                  ],
                                M.borrow (|
                                  Pointer.Kind.MutRef,
                                  M.deref (|
                                    M.borrow (|
                                      Pointer.Kind.MutRef,
                                      M.SubPointer.get_array_field (|
                                        M.deref (| M.read (| shorts |) |),
                                        Value.Integer IntegerKind.Usize 0
                                      |)
                                    |)
                                  |)
                                |)
                              |)
                            |)))
                      ]
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::borrow::BorrowMut"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "openvm_circuit::arch::execution::ExecutionState") [] [ T ] ]
          (Self T)
          (* Instance *) [ ("borrow_mut", InstanceField.Method (borrow_mut T)) ].
    End Impl_core_borrow_BorrowMut_openvm_circuit_arch_execution_ExecutionState_T_for_slice_T.
    
    Module Impl_openvm_circuit_arch_execution_ExecutionState_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "openvm_circuit::arch::execution::ExecutionState") [] [ T ].
      
      (* AlignedBorrow *)
      Definition width (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [] =>
          ltac:(M.monadic
            (M.call_closure (|
              Ty.path "usize",
              M.get_function (|
                "core::mem::size_of",
                [],
                [
                  Ty.apply
                    (Ty.path "openvm_circuit::arch::execution::ExecutionState")
                    []
                    [ Ty.path "u8" ]
                ]
              |),
              []
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_width :
        forall (T : Ty.t),
        M.IsAssociatedFunction.C (Self T) "width" (width T).
      Admitted.
      Global Typeclasses Opaque width.
      (*
          pub fn new(pc: impl Into<T>, timestamp: impl Into<T>) -> Self {
              Self {
                  pc: pc.into(),
                  timestamp: timestamp.into(),
              }
          }
      *)
      Definition new (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [ impl_Into_T_; impl_Into_T_'1 ], [ pc; timestamp ] =>
          ltac:(M.monadic
            (let pc := M.alloc (| impl_Into_T_, pc |) in
            let timestamp := M.alloc (| impl_Into_T_'1, timestamp |) in
            Value.mkStructRecord
              "openvm_circuit::arch::execution::ExecutionState"
              []
              [ T ]
              [
                ("pc",
                  M.call_closure (|
                    T,
                    M.get_trait_method (|
                      "core::convert::Into",
                      impl_Into_T_,
                      [],
                      [ T ],
                      "into",
                      [],
                      []
                    |),
                    [ M.read (| pc |) ]
                  |));
                ("timestamp",
                  M.call_closure (|
                    T,
                    M.get_trait_method (|
                      "core::convert::Into",
                      impl_Into_T_'1,
                      [],
                      [ T ],
                      "into",
                      [],
                      []
                    |),
                    [ M.read (| timestamp |) ]
                  |))
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_new :
        forall (T : Ty.t),
        M.IsAssociatedFunction.C (Self T) "new" (new T).
      Admitted.
      Global Typeclasses Opaque new.
      
      (*
          pub fn from_iter<I: Iterator<Item = T>>(iter: &mut I) -> Self {
              let mut next = || iter.next().unwrap();
              Self {
                  pc: next(),
                  timestamp: next(),
              }
          }
      *)
      Definition from_iter (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [ _ as I ], [ iter ] =>
          ltac:(M.monadic
            (let iter := M.alloc (| Ty.apply (Ty.path "&mut") [] [ I ], iter |) in
            M.read (|
              let~ next : Ty.function [] T :=
                M.closure
                  (fun γ =>
                    ltac:(M.monadic
                      match γ with
                      | [ α0 ] =>
                        ltac:(M.monadic
                          (M.match_operator (|
                            T,
                            M.alloc (| Ty.tuple [], α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (M.call_closure (|
                                    T,
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "core::option::Option") [] [ T ],
                                      "unwrap",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.apply (Ty.path "core::option::Option") [] [ T ],
                                        M.get_trait_method (|
                                          "core::iter::traits::iterator::Iterator",
                                          I,
                                          [],
                                          [],
                                          "next",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.MutRef,
                                            M.deref (| M.read (| iter |) |)
                                          |)
                                        ]
                                      |)
                                    ]
                                  |)))
                            ]
                          |)))
                      | _ => M.impossible "wrong number of arguments"
                      end)) in
              M.alloc (|
                Ty.apply (Ty.path "openvm_circuit::arch::execution::ExecutionState") [] [ T ],
                Value.mkStructRecord
                  "openvm_circuit::arch::execution::ExecutionState"
                  []
                  [ T ]
                  [
                    ("pc",
                      M.call_closure (|
                        T,
                        M.get_trait_method (|
                          "core::ops::function::FnMut",
                          Ty.function [] T,
                          [],
                          [ Ty.tuple [] ],
                          "call_mut",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.MutRef, next |); Value.Tuple [] ]
                      |));
                    ("timestamp",
                      M.call_closure (|
                        T,
                        M.get_trait_method (|
                          "core::ops::function::FnMut",
                          Ty.function [] T,
                          [],
                          [ Ty.tuple [] ],
                          "call_mut",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.MutRef, next |); Value.Tuple [] ]
                      |))
                  ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_from_iter :
        forall (T : Ty.t),
        M.IsAssociatedFunction.C (Self T) "from_iter" (from_iter T).
      Admitted.
      Global Typeclasses Opaque from_iter.
      
      (*
          pub fn flatten(self) -> [T; 2] {
              [self.pc, self.timestamp]
          }
      *)
      Definition flatten (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "openvm_circuit::arch::execution::ExecutionState") [] [ T ],
                self
              |) in
            Value.Array
              [
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    self,
                    "openvm_circuit::arch::execution::ExecutionState",
                    "pc"
                  |)
                |);
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    self,
                    "openvm_circuit::arch::execution::ExecutionState",
                    "timestamp"
                  |)
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_flatten :
        forall (T : Ty.t),
        M.IsAssociatedFunction.C (Self T) "flatten" (flatten T).
      Admitted.
      Global Typeclasses Opaque flatten.
      
      (*
          pub fn get_width() -> usize {
              2
          }
      *)
      Definition get_width (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [] => ltac:(M.monadic (Value.Integer IntegerKind.Usize 2))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_get_width :
        forall (T : Ty.t),
        M.IsAssociatedFunction.C (Self T) "get_width" (get_width T).
      Admitted.
      Global Typeclasses Opaque get_width.
      
      (*
          pub fn map<U: Clone, F: Fn(T) -> U>(self, function: F) -> ExecutionState<U> {
              ExecutionState::from_iter(&mut self.flatten().map(function).into_iter())
          }
      *)
      Definition map (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [ U; F ], [ self; function ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "openvm_circuit::arch::execution::ExecutionState") [] [ T ],
                self
              |) in
            let function := M.alloc (| F, function |) in
            M.call_closure (|
              Ty.apply (Ty.path "openvm_circuit::arch::execution::ExecutionState") [] [ U ],
              M.get_associated_function (|
                Ty.apply (Ty.path "openvm_circuit::arch::execution::ExecutionState") [] [ U ],
                "from_iter",
                [],
                [
                  Ty.apply
                    (Ty.path "core::array::iter::IntoIter")
                    [ Value.Integer IntegerKind.Usize 2 ]
                    [ U ]
                ]
              |),
              [
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.alloc (|
                        Ty.apply
                          (Ty.path "core::array::iter::IntoIter")
                          [ Value.Integer IntegerKind.Usize 2 ]
                          [ U ],
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::array::iter::IntoIter")
                            [ Value.Integer IntegerKind.Usize 2 ]
                            [ U ],
                          M.get_trait_method (|
                            "core::iter::traits::collect::IntoIterator",
                            Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 2 ] [ U ],
                            [],
                            [],
                            "into_iter",
                            [],
                            []
                          |),
                          [
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "array")
                                [ Value.Integer IntegerKind.Usize 2 ]
                                [ U ],
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "array")
                                  [ Value.Integer IntegerKind.Usize 2 ]
                                  [ T ],
                                "map",
                                [],
                                [ F; U ]
                              |),
                              [
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "array")
                                    [ Value.Integer IntegerKind.Usize 2 ]
                                    [ T ],
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "openvm_circuit::arch::execution::ExecutionState")
                                      []
                                      [ T ],
                                    "flatten",
                                    [],
                                    []
                                  |),
                                  [ M.read (| self |) ]
                                |);
                                M.read (| function |)
                              ]
                            |)
                          ]
                        |)
                      |)
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_map :
        forall (T : Ty.t),
        M.IsAssociatedFunction.C (Self T) "map" (map T).
      Admitted.
      Global Typeclasses Opaque map.
    End Impl_openvm_circuit_arch_execution_ExecutionState_T.
    
    Module underscore.
      Module Impl_serde_ser_Serialize_where_serde_ser_Serialize_T_for_openvm_circuit_arch_execution_ExecutionState_T.
        Definition Self (T : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "openvm_circuit::arch::execution::ExecutionState") [] [ T ].
        
        (* Serialize *)
        Definition serialize (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T in
          match ε, τ, α with
          | [], [ __S ], [ self; __serializer ] =>
            ltac:(M.monadic
              (let self :=
                M.alloc (|
                  Ty.apply
                    (Ty.path "&")
                    []
                    [ Ty.apply (Ty.path "openvm_circuit::arch::execution::ExecutionState") [] [ T ]
                    ],
                  self
                |) in
              let __serializer := M.alloc (| __S, __serializer |) in
              M.catch_return
                (Ty.apply
                  (Ty.path "core::result::Result")
                  []
                  [
                    Ty.associated_in_trait "serde::ser::Serializer" [] [] __S "Ok";
                    Ty.associated_in_trait "serde::ser::Serializer" [] [] __S "Error"
                  ]) (|
                ltac:(M.monadic
                  (M.read (|
                    let~ __serde_state :
                        Ty.associated_in_trait
                          "serde::ser::Serializer"
                          []
                          []
                          __S
                          "SerializeStruct" :=
                      M.match_operator (|
                        Ty.associated_in_trait "serde::ser::Serializer" [] [] __S "SerializeStruct",
                        M.alloc (|
                          Ty.apply
                            (Ty.path "core::ops::control_flow::ControlFlow")
                            []
                            [
                              Ty.apply
                                (Ty.path "core::result::Result")
                                []
                                [
                                  Ty.path "core::convert::Infallible";
                                  Ty.associated_in_trait "serde::ser::Serializer" [] [] __S "Error"
                                ];
                              Ty.associated_in_trait
                                "serde::ser::Serializer"
                                []
                                []
                                __S
                                "SerializeStruct"
                            ],
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "core::ops::control_flow::ControlFlow")
                              []
                              [
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  []
                                  [
                                    Ty.path "core::convert::Infallible";
                                    Ty.associated_in_trait
                                      "serde::ser::Serializer"
                                      []
                                      []
                                      __S
                                      "Error"
                                  ];
                                Ty.associated_in_trait
                                  "serde::ser::Serializer"
                                  []
                                  []
                                  __S
                                  "SerializeStruct"
                              ],
                            M.get_trait_method (|
                              "core::ops::try_trait::Try",
                              Ty.apply
                                (Ty.path "core::result::Result")
                                []
                                [
                                  Ty.associated_in_trait
                                    "serde::ser::Serializer"
                                    []
                                    []
                                    __S
                                    "SerializeStruct";
                                  Ty.associated_in_trait "serde::ser::Serializer" [] [] __S "Error"
                                ],
                              [],
                              [],
                              "branch",
                              [],
                              []
                            |),
                            [
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  []
                                  [
                                    Ty.associated_in_trait
                                      "serde::ser::Serializer"
                                      []
                                      []
                                      __S
                                      "SerializeStruct";
                                    Ty.associated_in_trait
                                      "serde::ser::Serializer"
                                      []
                                      []
                                      __S
                                      "Error"
                                  ],
                                M.get_trait_method (|
                                  "serde::ser::Serializer",
                                  __S,
                                  [],
                                  [],
                                  "serialize_struct",
                                  [],
                                  []
                                |),
                                [
                                  M.read (| __serializer |);
                                  mk_str (| "ExecutionState" |);
                                  M.call_closure (|
                                    Ty.path "usize",
                                    BinOp.Wrap.add,
                                    [
                                      M.call_closure (|
                                        Ty.path "usize",
                                        BinOp.Wrap.add,
                                        [
                                          M.cast (Ty.path "usize") (Value.Bool false);
                                          Value.Integer IntegerKind.Usize 1
                                        ]
                                      |);
                                      Value.Integer IntegerKind.Usize 1
                                    ]
                                  |)
                                ]
                              |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Break",
                                  0
                                |) in
                              let residual :=
                                M.copy (|
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [
                                      Ty.path "core::convert::Infallible";
                                      Ty.associated_in_trait
                                        "serde::ser::Serializer"
                                        []
                                        []
                                        __S
                                        "Error"
                                    ],
                                  γ0_0
                                |) in
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        []
                                        [
                                          Ty.associated_in_trait
                                            "serde::ser::Serializer"
                                            []
                                            []
                                            __S
                                            "Ok";
                                          Ty.associated_in_trait
                                            "serde::ser::Serializer"
                                            []
                                            []
                                            __S
                                            "Error"
                                        ],
                                      M.get_trait_method (|
                                        "core::ops::try_trait::FromResidual",
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          []
                                          [
                                            Ty.associated_in_trait
                                              "serde::ser::Serializer"
                                              []
                                              []
                                              __S
                                              "Ok";
                                            Ty.associated_in_trait
                                              "serde::ser::Serializer"
                                              []
                                              []
                                              __S
                                              "Error"
                                          ],
                                        [],
                                        [
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            []
                                            [
                                              Ty.path "core::convert::Infallible";
                                              Ty.associated_in_trait
                                                "serde::ser::Serializer"
                                                []
                                                []
                                                __S
                                                "Error"
                                            ]
                                        ],
                                        "from_residual",
                                        [],
                                        []
                                      |),
                                      [ M.read (| residual |) ]
                                    |)
                                  |)
                                |)
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Continue",
                                  0
                                |) in
                              let val :=
                                M.copy (|
                                  Ty.associated_in_trait
                                    "serde::ser::Serializer"
                                    []
                                    []
                                    __S
                                    "SerializeStruct",
                                  γ0_0
                                |) in
                              M.read (| val |)))
                        ]
                      |) in
                    let~ _ : Ty.tuple [] :=
                      M.match_operator (|
                        Ty.tuple [],
                        M.alloc (|
                          Ty.apply
                            (Ty.path "core::ops::control_flow::ControlFlow")
                            []
                            [
                              Ty.apply
                                (Ty.path "core::result::Result")
                                []
                                [
                                  Ty.path "core::convert::Infallible";
                                  Ty.associated_in_trait "serde::ser::Serializer" [] [] __S "Error"
                                ];
                              Ty.tuple []
                            ],
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "core::ops::control_flow::ControlFlow")
                              []
                              [
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  []
                                  [
                                    Ty.path "core::convert::Infallible";
                                    Ty.associated_in_trait
                                      "serde::ser::Serializer"
                                      []
                                      []
                                      __S
                                      "Error"
                                  ];
                                Ty.tuple []
                              ],
                            M.get_trait_method (|
                              "core::ops::try_trait::Try",
                              Ty.apply
                                (Ty.path "core::result::Result")
                                []
                                [
                                  Ty.tuple [];
                                  Ty.associated_in_trait "serde::ser::Serializer" [] [] __S "Error"
                                ],
                              [],
                              [],
                              "branch",
                              [],
                              []
                            |),
                            [
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  []
                                  [
                                    Ty.tuple [];
                                    Ty.associated_in_trait
                                      "serde::ser::Serializer"
                                      []
                                      []
                                      __S
                                      "Error"
                                  ],
                                M.get_trait_method (|
                                  "serde::ser::SerializeStruct",
                                  Ty.associated_in_trait
                                    "serde::ser::Serializer"
                                    []
                                    []
                                    __S
                                    "SerializeStruct",
                                  [],
                                  [],
                                  "serialize_field",
                                  [],
                                  [ T ]
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.MutRef,
                                    M.deref (| M.borrow (| Pointer.Kind.MutRef, __serde_state |) |)
                                  |);
                                  mk_str (| "pc" |);
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.SubPointer.get_struct_record_field (|
                                          M.deref (| M.read (| self |) |),
                                          "openvm_circuit::arch::execution::ExecutionState",
                                          "pc"
                                        |)
                                      |)
                                    |)
                                  |)
                                ]
                              |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Break",
                                  0
                                |) in
                              let residual :=
                                M.copy (|
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [
                                      Ty.path "core::convert::Infallible";
                                      Ty.associated_in_trait
                                        "serde::ser::Serializer"
                                        []
                                        []
                                        __S
                                        "Error"
                                    ],
                                  γ0_0
                                |) in
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        []
                                        [
                                          Ty.associated_in_trait
                                            "serde::ser::Serializer"
                                            []
                                            []
                                            __S
                                            "Ok";
                                          Ty.associated_in_trait
                                            "serde::ser::Serializer"
                                            []
                                            []
                                            __S
                                            "Error"
                                        ],
                                      M.get_trait_method (|
                                        "core::ops::try_trait::FromResidual",
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          []
                                          [
                                            Ty.associated_in_trait
                                              "serde::ser::Serializer"
                                              []
                                              []
                                              __S
                                              "Ok";
                                            Ty.associated_in_trait
                                              "serde::ser::Serializer"
                                              []
                                              []
                                              __S
                                              "Error"
                                          ],
                                        [],
                                        [
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            []
                                            [
                                              Ty.path "core::convert::Infallible";
                                              Ty.associated_in_trait
                                                "serde::ser::Serializer"
                                                []
                                                []
                                                __S
                                                "Error"
                                            ]
                                        ],
                                        "from_residual",
                                        [],
                                        []
                                      |),
                                      [ M.read (| residual |) ]
                                    |)
                                  |)
                                |)
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Continue",
                                  0
                                |) in
                              let val := M.copy (| Ty.tuple [], γ0_0 |) in
                              M.read (| val |)))
                        ]
                      |) in
                    let~ _ : Ty.tuple [] :=
                      M.match_operator (|
                        Ty.tuple [],
                        M.alloc (|
                          Ty.apply
                            (Ty.path "core::ops::control_flow::ControlFlow")
                            []
                            [
                              Ty.apply
                                (Ty.path "core::result::Result")
                                []
                                [
                                  Ty.path "core::convert::Infallible";
                                  Ty.associated_in_trait "serde::ser::Serializer" [] [] __S "Error"
                                ];
                              Ty.tuple []
                            ],
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "core::ops::control_flow::ControlFlow")
                              []
                              [
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  []
                                  [
                                    Ty.path "core::convert::Infallible";
                                    Ty.associated_in_trait
                                      "serde::ser::Serializer"
                                      []
                                      []
                                      __S
                                      "Error"
                                  ];
                                Ty.tuple []
                              ],
                            M.get_trait_method (|
                              "core::ops::try_trait::Try",
                              Ty.apply
                                (Ty.path "core::result::Result")
                                []
                                [
                                  Ty.tuple [];
                                  Ty.associated_in_trait "serde::ser::Serializer" [] [] __S "Error"
                                ],
                              [],
                              [],
                              "branch",
                              [],
                              []
                            |),
                            [
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  []
                                  [
                                    Ty.tuple [];
                                    Ty.associated_in_trait
                                      "serde::ser::Serializer"
                                      []
                                      []
                                      __S
                                      "Error"
                                  ],
                                M.get_trait_method (|
                                  "serde::ser::SerializeStruct",
                                  Ty.associated_in_trait
                                    "serde::ser::Serializer"
                                    []
                                    []
                                    __S
                                    "SerializeStruct",
                                  [],
                                  [],
                                  "serialize_field",
                                  [],
                                  [ T ]
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.MutRef,
                                    M.deref (| M.borrow (| Pointer.Kind.MutRef, __serde_state |) |)
                                  |);
                                  mk_str (| "timestamp" |);
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.SubPointer.get_struct_record_field (|
                                          M.deref (| M.read (| self |) |),
                                          "openvm_circuit::arch::execution::ExecutionState",
                                          "timestamp"
                                        |)
                                      |)
                                    |)
                                  |)
                                ]
                              |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Break",
                                  0
                                |) in
                              let residual :=
                                M.copy (|
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [
                                      Ty.path "core::convert::Infallible";
                                      Ty.associated_in_trait
                                        "serde::ser::Serializer"
                                        []
                                        []
                                        __S
                                        "Error"
                                    ],
                                  γ0_0
                                |) in
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        []
                                        [
                                          Ty.associated_in_trait
                                            "serde::ser::Serializer"
                                            []
                                            []
                                            __S
                                            "Ok";
                                          Ty.associated_in_trait
                                            "serde::ser::Serializer"
                                            []
                                            []
                                            __S
                                            "Error"
                                        ],
                                      M.get_trait_method (|
                                        "core::ops::try_trait::FromResidual",
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          []
                                          [
                                            Ty.associated_in_trait
                                              "serde::ser::Serializer"
                                              []
                                              []
                                              __S
                                              "Ok";
                                            Ty.associated_in_trait
                                              "serde::ser::Serializer"
                                              []
                                              []
                                              __S
                                              "Error"
                                          ],
                                        [],
                                        [
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            []
                                            [
                                              Ty.path "core::convert::Infallible";
                                              Ty.associated_in_trait
                                                "serde::ser::Serializer"
                                                []
                                                []
                                                __S
                                                "Error"
                                            ]
                                        ],
                                        "from_residual",
                                        [],
                                        []
                                      |),
                                      [ M.read (| residual |) ]
                                    |)
                                  |)
                                |)
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Continue",
                                  0
                                |) in
                              let val := M.copy (| Ty.tuple [], γ0_0 |) in
                              M.read (| val |)))
                        ]
                      |) in
                    M.alloc (|
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [
                          Ty.associated_in_trait "serde::ser::Serializer" [] [] __S "Ok";
                          Ty.associated_in_trait "serde::ser::Serializer" [] [] __S "Error"
                        ],
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [
                            Ty.associated_in_trait "serde::ser::Serializer" [] [] __S "Ok";
                            Ty.associated_in_trait "serde::ser::Serializer" [] [] __S "Error"
                          ],
                        M.get_trait_method (|
                          "serde::ser::SerializeStruct",
                          Ty.associated_in_trait
                            "serde::ser::Serializer"
                            []
                            []
                            __S
                            "SerializeStruct",
                          [],
                          [],
                          "end",
                          [],
                          []
                        |),
                        [ M.read (| __serde_state |) ]
                      |)
                    |)
                  |)))
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          forall (T : Ty.t),
          M.IsTraitInstance
            "serde::ser::Serialize"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) []
            (Self T)
            (* Instance *) [ ("serialize", InstanceField.Method (serialize T)) ].
      End Impl_serde_ser_Serialize_where_serde_ser_Serialize_T_for_openvm_circuit_arch_execution_ExecutionState_T.
      Module Impl_serde_de_Deserialize_where_serde_de_Deserialize_T_for_openvm_circuit_arch_execution_ExecutionState_T.
        Definition Self (T : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "openvm_circuit::arch::execution::ExecutionState") [] [ T ].
        
        (* Deserialize *)
        Definition deserialize
            (T : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self T in
          match ε, τ, α with
          | [], [ __D ], [ __deserializer ] =>
            ltac:(M.monadic
              (let __deserializer := M.alloc (| __D, __deserializer |) in
              M.call_closure (|
                Ty.apply
                  (Ty.path "core::result::Result")
                  []
                  [
                    Ty.apply (Ty.path "openvm_circuit::arch::execution::ExecutionState") [] [ T ];
                    Ty.associated_in_trait "serde::de::Deserializer" [] [] __D "Error"
                  ],
                M.get_trait_method (|
                  "serde::de::Deserializer",
                  __D,
                  [],
                  [],
                  "deserialize_struct",
                  [],
                  [
                    Ty.apply
                      (Ty.path "openvm_circuit::arch::execution::_'1::deserialize::__Visitor")
                      []
                      [ T ]
                  ]
                |),
                [
                  M.read (| __deserializer |);
                  mk_str (| "ExecutionState" |);
                  M.read (|
                    get_constant (|
                      "openvm_circuit::arch::execution::_'1::deserialize::FIELDS",
                      Ty.apply
                        (Ty.path "&")
                        []
                        [
                          Ty.apply
                            (Ty.path "slice")
                            []
                            [ Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ]
                        ]
                    |)
                  |);
                  Value.mkStructRecord
                    "openvm_circuit::arch::execution::_'1::deserialize::__Visitor"
                    []
                    [ T ]
                    [
                      ("marker",
                        Value.StructTuple
                          "core::marker::PhantomData"
                          []
                          [
                            Ty.apply
                              (Ty.path "openvm_circuit::arch::execution::ExecutionState")
                              []
                              [ T ]
                          ]
                          []);
                      ("lifetime",
                        Value.StructTuple
                          "core::marker::PhantomData"
                          []
                          [ Ty.apply (Ty.path "&") [] [ Ty.tuple [] ] ]
                          [])
                    ]
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          forall (T : Ty.t),
          M.IsTraitInstance
            "serde::de::Deserialize"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) []
            (Self T)
            (* Instance *) [ ("deserialize", InstanceField.Method (deserialize T)) ].
      End Impl_serde_de_Deserialize_where_serde_de_Deserialize_T_for_openvm_circuit_arch_execution_ExecutionState_T.
    End underscore.
    
    
    (* StructRecord
      {
        name := "ExecutionBus";
        const_params := [];
        ty_params := [];
        fields := [ ("inner", Ty.path "openvm_stark_backend::interaction::PermutationCheckBus") ];
      } *)
    
    Module Impl_core_clone_Clone_for_openvm_circuit_arch_execution_ExecutionBus.
      Definition Self : Ty.t := Ty.path "openvm_circuit::arch::execution::ExecutionBus".
      
      (* Clone *)
      Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.path "openvm_circuit::arch::execution::ExecutionBus" ],
                self
              |) in
            M.match_operator (|
              Ty.path "openvm_circuit::arch::execution::ExecutionBus",
              Value.DeclaredButUndefined,
              [ fun γ => ltac:(M.monadic (M.read (| M.deref (| M.read (| self |) |) |))) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::clone::Clone"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("clone", InstanceField.Method clone) ].
    End Impl_core_clone_Clone_for_openvm_circuit_arch_execution_ExecutionBus.
    
    Module Impl_core_marker_Copy_for_openvm_circuit_arch_execution_ExecutionBus.
      Definition Self : Ty.t := Ty.path "openvm_circuit::arch::execution::ExecutionBus".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::Copy"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [].
    End Impl_core_marker_Copy_for_openvm_circuit_arch_execution_ExecutionBus.
    
    Module Impl_core_fmt_Debug_for_openvm_circuit_arch_execution_ExecutionBus.
      Definition Self : Ty.t := Ty.path "openvm_circuit::arch::execution::ExecutionBus".
      
      (* Debug *)
      Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.path "openvm_circuit::arch::execution::ExecutionBus" ],
                self
              |) in
            let f :=
              M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "core::fmt::Formatter" ], f |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
              M.get_associated_function (|
                Ty.path "core::fmt::Formatter",
                "debug_struct_field1_finish",
                [],
                []
              |),
              [
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "ExecutionBus" |) |) |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "inner" |) |) |);
                M.call_closure (|
                  Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ],
                  M.pointer_coercion
                    M.PointerCoercion.Unsize
                    (Ty.apply
                      (Ty.path "&")
                      []
                      [
                        Ty.apply
                          (Ty.path "&")
                          []
                          [ Ty.path "openvm_stark_backend::interaction::PermutationCheckBus" ]
                      ])
                    (Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ]),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.alloc (|
                            Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.path "openvm_stark_backend::interaction::PermutationCheckBus" ],
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "openvm_circuit::arch::execution::ExecutionBus",
                                "inner"
                              |)
                            |)
                          |)
                        |)
                      |)
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Debug"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Debug_for_openvm_circuit_arch_execution_ExecutionBus.
    
    Module Impl_openvm_circuit_arch_execution_ExecutionBus.
      Definition Self : Ty.t := Ty.path "openvm_circuit::arch::execution::ExecutionBus".
      
      (*
          pub const fn new(index: BusIndex) -> Self {
              Self {
                  inner: PermutationCheckBus::new(index),
              }
          }
      *)
      Definition new (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ index ] =>
          ltac:(M.monadic
            (let index := M.alloc (| Ty.path "u16", index |) in
            Value.mkStructRecord
              "openvm_circuit::arch::execution::ExecutionBus"
              []
              []
              [
                ("inner",
                  M.call_closure (|
                    Ty.path "openvm_stark_backend::interaction::PermutationCheckBus",
                    M.get_associated_function (|
                      Ty.path "openvm_stark_backend::interaction::PermutationCheckBus",
                      "new",
                      [],
                      []
                    |),
                    [ M.read (| index |) ]
                  |))
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_new : M.IsAssociatedFunction.C Self "new" new.
      Admitted.
      Global Typeclasses Opaque new.
      
      (*
          pub fn index(&self) -> BusIndex {
              self.inner.index
          }
      *)
      Definition index (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.path "openvm_circuit::arch::execution::ExecutionBus" ],
                self
              |) in
            M.read (|
              M.SubPointer.get_struct_record_field (|
                M.SubPointer.get_struct_record_field (|
                  M.deref (| M.read (| self |) |),
                  "openvm_circuit::arch::execution::ExecutionBus",
                  "inner"
                |),
                "openvm_stark_backend::interaction::PermutationCheckBus",
                "index"
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_index : M.IsAssociatedFunction.C Self "index" index.
      Admitted.
      Global Typeclasses Opaque index.
      (*
          pub fn execute_and_increment_pc<AB: InteractionBuilder>(
              &self,
              builder: &mut AB,
              enabled: impl Into<AB::Expr>,
              prev_state: ExecutionState<AB::Expr>,
              timestamp_change: impl Into<AB::Expr>,
          ) {
              let next_state = ExecutionState {
                  pc: prev_state.pc.clone() + AB::F::ONE,
                  timestamp: prev_state.timestamp.clone() + timestamp_change.into(),
              };
              self.execute(builder, enabled, prev_state, next_state);
          }
      *)
      Definition execute_and_increment_pc
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        match ε, τ, α with
        | [],
            [ AB; impl_Into_AB_Expr_; impl_Into_AB_Expr_'1 ],
            [ self; builder; enabled; prev_state; timestamp_change ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.path "openvm_circuit::arch::execution::ExecutionBus" ],
                self
              |) in
            let builder := M.alloc (| Ty.apply (Ty.path "&mut") [] [ AB ], builder |) in
            let enabled := M.alloc (| impl_Into_AB_Expr_, enabled |) in
            let prev_state :=
              M.alloc (|
                Ty.apply
                  (Ty.path "openvm_circuit::arch::execution::ExecutionState")
                  []
                  [ Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr" ],
                prev_state
              |) in
            let timestamp_change := M.alloc (| impl_Into_AB_Expr_'1, timestamp_change |) in
            M.read (|
              let~ next_state :
                  Ty.apply
                    (Ty.path "openvm_circuit::arch::execution::ExecutionState")
                    []
                    [ Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr" ] :=
                Value.mkStructRecord
                  "openvm_circuit::arch::execution::ExecutionState"
                  []
                  [ Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr" ]
                  [
                    ("pc",
                      M.call_closure (|
                        Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr",
                        M.get_trait_method (|
                          "core::ops::arith::Add",
                          Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr",
                          [],
                          [ Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "F" ],
                          "add",
                          [],
                          []
                        |),
                        [
                          M.call_closure (|
                            Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr",
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr",
                              [],
                              [],
                              "clone",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.SubPointer.get_struct_record_field (|
                                  prev_state,
                                  "openvm_circuit::arch::execution::ExecutionState",
                                  "pc"
                                |)
                              |)
                            ]
                          |);
                          M.read (|
                            get_constant (|
                              "p3_field::field::FieldAlgebra::ONE",
                              Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "F"
                            |)
                          |)
                        ]
                      |));
                    ("timestamp",
                      M.call_closure (|
                        Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr",
                        M.get_trait_method (|
                          "core::ops::arith::Add",
                          Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr",
                          [],
                          [ Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr" ],
                          "add",
                          [],
                          []
                        |),
                        [
                          M.call_closure (|
                            Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr",
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr",
                              [],
                              [],
                              "clone",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.SubPointer.get_struct_record_field (|
                                  prev_state,
                                  "openvm_circuit::arch::execution::ExecutionState",
                                  "timestamp"
                                |)
                              |)
                            ]
                          |);
                          M.call_closure (|
                            Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr",
                            M.get_trait_method (|
                              "core::convert::Into",
                              impl_Into_AB_Expr_'1,
                              [],
                              [ Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr" ],
                              "into",
                              [],
                              []
                            |),
                            [ M.read (| timestamp_change |) ]
                          |)
                        ]
                      |))
                  ] in
              let~ _ : Ty.tuple [] :=
                M.call_closure (|
                  Ty.tuple [],
                  M.get_associated_function (|
                    Ty.path "openvm_circuit::arch::execution::ExecutionBus",
                    "execute",
                    [],
                    [
                      AB;
                      impl_Into_AB_Expr_;
                      Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr";
                      Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr"
                    ]
                  |),
                  [
                    M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                    M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| builder |) |) |);
                    M.read (| enabled |);
                    M.read (| prev_state |);
                    M.read (| next_state |)
                  ]
                |) in
              M.alloc (| Ty.tuple [], Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_execute_and_increment_pc :
        M.IsAssociatedFunction.C Self "execute_and_increment_pc" execute_and_increment_pc.
      Admitted.
      Global Typeclasses Opaque execute_and_increment_pc.
      
      (*
          pub fn execute<AB: InteractionBuilder>(
              &self,
              builder: &mut AB,
              enabled: impl Into<AB::Expr>,
              prev_state: ExecutionState<impl Into<AB::Expr>>,
              next_state: ExecutionState<impl Into<AB::Expr>>,
          ) {
              let enabled = enabled.into();
              self.inner.receive(
                  builder,
                  [prev_state.pc.into(), prev_state.timestamp.into()],
                  enabled.clone(),
              );
              self.inner.send(
                  builder,
                  [next_state.pc.into(), next_state.timestamp.into()],
                  enabled,
              );
          }
      *)
      Definition execute (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [],
            [ AB; impl_Into_AB_Expr_; impl_Into_AB_Expr_'1; impl_Into_AB_Expr_'2 ],
            [ self; builder; enabled; prev_state; next_state ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.path "openvm_circuit::arch::execution::ExecutionBus" ],
                self
              |) in
            let builder := M.alloc (| Ty.apply (Ty.path "&mut") [] [ AB ], builder |) in
            let enabled := M.alloc (| impl_Into_AB_Expr_, enabled |) in
            let prev_state :=
              M.alloc (|
                Ty.apply
                  (Ty.path "openvm_circuit::arch::execution::ExecutionState")
                  []
                  [ impl_Into_AB_Expr_'1 ],
                prev_state
              |) in
            let next_state :=
              M.alloc (|
                Ty.apply
                  (Ty.path "openvm_circuit::arch::execution::ExecutionState")
                  []
                  [ impl_Into_AB_Expr_'2 ],
                next_state
              |) in
            M.read (|
              let~ enabled : Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr" :=
                M.call_closure (|
                  Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr",
                  M.get_trait_method (|
                    "core::convert::Into",
                    impl_Into_AB_Expr_,
                    [],
                    [ Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr" ],
                    "into",
                    [],
                    []
                  |),
                  [ M.read (| enabled |) ]
                |) in
              let~ _ : Ty.tuple [] :=
                M.call_closure (|
                  Ty.tuple [],
                  M.get_associated_function (|
                    Ty.path "openvm_stark_backend::interaction::PermutationCheckBus",
                    "receive",
                    [],
                    [
                      AB;
                      Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr";
                      Ty.apply
                        (Ty.path "array")
                        [ Value.Integer IntegerKind.Usize 2 ]
                        [ Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr" ];
                      Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr"
                    ]
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "openvm_circuit::arch::execution::ExecutionBus",
                        "inner"
                      |)
                    |);
                    M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| builder |) |) |);
                    Value.Array
                      [
                        M.call_closure (|
                          Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr",
                          M.get_trait_method (|
                            "core::convert::Into",
                            impl_Into_AB_Expr_'1,
                            [],
                            [ Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr" ],
                            "into",
                            [],
                            []
                          |),
                          [
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                prev_state,
                                "openvm_circuit::arch::execution::ExecutionState",
                                "pc"
                              |)
                            |)
                          ]
                        |);
                        M.call_closure (|
                          Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr",
                          M.get_trait_method (|
                            "core::convert::Into",
                            impl_Into_AB_Expr_'1,
                            [],
                            [ Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr" ],
                            "into",
                            [],
                            []
                          |),
                          [
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                prev_state,
                                "openvm_circuit::arch::execution::ExecutionState",
                                "timestamp"
                              |)
                            |)
                          ]
                        |)
                      ];
                    M.call_closure (|
                      Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr",
                      M.get_trait_method (|
                        "core::clone::Clone",
                        Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr",
                        [],
                        [],
                        "clone",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.Ref, enabled |) ]
                    |)
                  ]
                |) in
              let~ _ : Ty.tuple [] :=
                M.call_closure (|
                  Ty.tuple [],
                  M.get_associated_function (|
                    Ty.path "openvm_stark_backend::interaction::PermutationCheckBus",
                    "send",
                    [],
                    [
                      AB;
                      Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr";
                      Ty.apply
                        (Ty.path "array")
                        [ Value.Integer IntegerKind.Usize 2 ]
                        [ Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr" ];
                      Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr"
                    ]
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "openvm_circuit::arch::execution::ExecutionBus",
                        "inner"
                      |)
                    |);
                    M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| builder |) |) |);
                    Value.Array
                      [
                        M.call_closure (|
                          Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr",
                          M.get_trait_method (|
                            "core::convert::Into",
                            impl_Into_AB_Expr_'2,
                            [],
                            [ Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr" ],
                            "into",
                            [],
                            []
                          |),
                          [
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                next_state,
                                "openvm_circuit::arch::execution::ExecutionState",
                                "pc"
                              |)
                            |)
                          ]
                        |);
                        M.call_closure (|
                          Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr",
                          M.get_trait_method (|
                            "core::convert::Into",
                            impl_Into_AB_Expr_'2,
                            [],
                            [ Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr" ],
                            "into",
                            [],
                            []
                          |),
                          [
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                next_state,
                                "openvm_circuit::arch::execution::ExecutionState",
                                "timestamp"
                              |)
                            |)
                          ]
                        |)
                      ];
                    M.read (| enabled |)
                  ]
                |) in
              M.alloc (| Ty.tuple [], Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_execute : M.IsAssociatedFunction.C Self "execute" execute.
      Admitted.
      Global Typeclasses Opaque execute.
    End Impl_openvm_circuit_arch_execution_ExecutionBus.
    
    (* StructRecord
      {
        name := "ExecutionBridge";
        const_params := [];
        ty_params := [];
        fields :=
          [
            ("execution_bus", Ty.path "openvm_circuit::arch::execution::ExecutionBus");
            ("program_bus", Ty.path "openvm_circuit::system::program::bus::ProgramBus")
          ];
      } *)
    
    Module Impl_core_marker_Copy_for_openvm_circuit_arch_execution_ExecutionBridge.
      Definition Self : Ty.t := Ty.path "openvm_circuit::arch::execution::ExecutionBridge".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::Copy"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [].
    End Impl_core_marker_Copy_for_openvm_circuit_arch_execution_ExecutionBridge.
    
    Module Impl_core_clone_Clone_for_openvm_circuit_arch_execution_ExecutionBridge.
      Definition Self : Ty.t := Ty.path "openvm_circuit::arch::execution::ExecutionBridge".
      
      (* Clone *)
      Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.path "openvm_circuit::arch::execution::ExecutionBridge" ],
                self
              |) in
            M.match_operator (|
              Ty.path "openvm_circuit::arch::execution::ExecutionBridge",
              Value.DeclaredButUndefined,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      Ty.path "openvm_circuit::arch::execution::ExecutionBridge",
                      Value.DeclaredButUndefined,
                      [ fun γ => ltac:(M.monadic (M.read (| M.deref (| M.read (| self |) |) |))) ]
                    |)))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::clone::Clone"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("clone", InstanceField.Method clone) ].
    End Impl_core_clone_Clone_for_openvm_circuit_arch_execution_ExecutionBridge.
    
    Module Impl_core_fmt_Debug_for_openvm_circuit_arch_execution_ExecutionBridge.
      Definition Self : Ty.t := Ty.path "openvm_circuit::arch::execution::ExecutionBridge".
      
      (* Debug *)
      Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.path "openvm_circuit::arch::execution::ExecutionBridge" ],
                self
              |) in
            let f :=
              M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "core::fmt::Formatter" ], f |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
              M.get_associated_function (|
                Ty.path "core::fmt::Formatter",
                "debug_struct_field2_finish",
                [],
                []
              |),
              [
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "ExecutionBridge" |) |) |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "execution_bus" |) |) |);
                M.call_closure (|
                  Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ],
                  M.pointer_coercion
                    M.PointerCoercion.Unsize
                    (Ty.apply
                      (Ty.path "&")
                      []
                      [ Ty.path "openvm_circuit::arch::execution::ExecutionBus" ])
                    (Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ]),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "openvm_circuit::arch::execution::ExecutionBridge",
                            "execution_bus"
                          |)
                        |)
                      |)
                    |)
                  ]
                |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "program_bus" |) |) |);
                M.call_closure (|
                  Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ],
                  M.pointer_coercion
                    M.PointerCoercion.Unsize
                    (Ty.apply
                      (Ty.path "&")
                      []
                      [
                        Ty.apply
                          (Ty.path "&")
                          []
                          [ Ty.path "openvm_circuit::system::program::bus::ProgramBus" ]
                      ])
                    (Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ]),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.alloc (|
                            Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.path "openvm_circuit::system::program::bus::ProgramBus" ],
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "openvm_circuit::arch::execution::ExecutionBridge",
                                "program_bus"
                              |)
                            |)
                          |)
                        |)
                      |)
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Debug"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Debug_for_openvm_circuit_arch_execution_ExecutionBridge.
    
    (* StructRecord
      {
        name := "ExecutionBridgeInteractor";
        const_params := [];
        ty_params := [ "AB" ];
        fields :=
          [
            ("execution_bus", Ty.path "openvm_circuit::arch::execution::ExecutionBus");
            ("program_bus", Ty.path "openvm_circuit::system::program::bus::ProgramBus");
            ("opcode", Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr");
            ("operands",
              Ty.apply
                (Ty.path "alloc::vec::Vec")
                []
                [
                  Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr";
                  Ty.path "alloc::alloc::Global"
                ]);
            ("from_state",
              Ty.apply
                (Ty.path "openvm_circuit::arch::execution::ExecutionState")
                []
                [ Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr" ]);
            ("to_state",
              Ty.apply
                (Ty.path "openvm_circuit::arch::execution::ExecutionState")
                []
                [ Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr" ])
          ];
      } *)
    
    (*
    Enum PcIncOrSet
    {
      const_params := [];
      ty_params := [ "T" ];
      variants :=
        [
          {
            name := "Inc";
            item := StructTuple [ T ];
          };
          {
            name := "Set";
            item := StructTuple [ T ];
          }
        ];
    }
    *)
    
    Axiom IsDiscriminant_PcIncOrSet_Inc :
      M.IsDiscriminant "openvm_circuit::arch::execution::PcIncOrSet::Inc" 0.
    Axiom IsDiscriminant_PcIncOrSet_Set :
      M.IsDiscriminant "openvm_circuit::arch::execution::PcIncOrSet::Set" 1.
    
    
    
    Module Impl_openvm_circuit_arch_execution_ExecutionBridge.
      Definition Self : Ty.t := Ty.path "openvm_circuit::arch::execution::ExecutionBridge".
      
      (*
          pub fn new(execution_bus: ExecutionBus, program_bus: ProgramBus) -> Self {
              Self {
                  execution_bus,
                  program_bus,
              }
          }
      *)
      Definition new (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ execution_bus; program_bus ] =>
          ltac:(M.monadic
            (let execution_bus :=
              M.alloc (|
                Ty.path "openvm_circuit::arch::execution::ExecutionBus",
                execution_bus
              |) in
            let program_bus :=
              M.alloc (|
                Ty.path "openvm_circuit::system::program::bus::ProgramBus",
                program_bus
              |) in
            Value.mkStructRecord
              "openvm_circuit::arch::execution::ExecutionBridge"
              []
              []
              [
                ("execution_bus", M.read (| execution_bus |));
                ("program_bus", M.read (| program_bus |))
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_new : M.IsAssociatedFunction.C Self "new" new.
      Admitted.
      Global Typeclasses Opaque new.
      
      (*
          pub fn execute_and_increment_or_set_pc<AB: InteractionBuilder>(
              &self,
              opcode: impl Into<AB::Expr>,
              operands: impl IntoIterator<Item = impl Into<AB::Expr>>,
              from_state: ExecutionState<impl Into<AB::Expr> + Clone>,
              timestamp_change: impl Into<AB::Expr>,
              pc_kind: impl Into<PcIncOrSet<AB::Expr>>,
          ) -> ExecutionBridgeInteractor<AB> {
              let to_state = ExecutionState {
                  pc: match pc_kind.into() {
                      PcIncOrSet::Set(to_pc) => to_pc,
                      PcIncOrSet::Inc(pc_inc) => from_state.pc.clone().into() + pc_inc,
                  },
                  timestamp: from_state.timestamp.clone().into() + timestamp_change.into(),
              };
              self.execute(opcode, operands, from_state, to_state)
          }
      *)
      Definition execute_and_increment_or_set_pc
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        match ε, τ, α with
        | [],
            [
              AB;
              impl_Into_AB_Expr_;
              impl_Into_AB_Expr_'1;
              impl_IntoIterator_Item___impl_Into_AB_Expr__;
              impl_Into_AB_Expr___plus__Clone;
              impl_Into_AB_Expr_'2;
              impl_Into_PcIncOrSet_AB_Expr__
            ],
            [ self; opcode; operands; from_state; timestamp_change; pc_kind ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.path "openvm_circuit::arch::execution::ExecutionBridge" ],
                self
              |) in
            let opcode := M.alloc (| impl_Into_AB_Expr_, opcode |) in
            let operands := M.alloc (| impl_IntoIterator_Item___impl_Into_AB_Expr__, operands |) in
            let from_state :=
              M.alloc (|
                Ty.apply
                  (Ty.path "openvm_circuit::arch::execution::ExecutionState")
                  []
                  [ impl_Into_AB_Expr___plus__Clone ],
                from_state
              |) in
            let timestamp_change := M.alloc (| impl_Into_AB_Expr_'2, timestamp_change |) in
            let pc_kind := M.alloc (| impl_Into_PcIncOrSet_AB_Expr__, pc_kind |) in
            M.read (|
              let~ to_state :
                  Ty.apply
                    (Ty.path "openvm_circuit::arch::execution::ExecutionState")
                    []
                    [ Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr" ] :=
                Value.mkStructRecord
                  "openvm_circuit::arch::execution::ExecutionState"
                  []
                  [ Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr" ]
                  [
                    ("pc",
                      M.match_operator (|
                        Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr",
                        M.alloc (|
                          Ty.apply
                            (Ty.path "openvm_circuit::arch::execution::PcIncOrSet")
                            []
                            [ Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr" ],
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "openvm_circuit::arch::execution::PcIncOrSet")
                              []
                              [ Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr" ],
                            M.get_trait_method (|
                              "core::convert::Into",
                              impl_Into_PcIncOrSet_AB_Expr__,
                              [],
                              [
                                Ty.apply
                                  (Ty.path "openvm_circuit::arch::execution::PcIncOrSet")
                                  []
                                  [ Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr"
                                  ]
                              ],
                              "into",
                              [],
                              []
                            |),
                            [ M.read (| pc_kind |) ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "openvm_circuit::arch::execution::PcIncOrSet::Set",
                                  0
                                |) in
                              let to_pc :=
                                M.copy (|
                                  Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr",
                                  γ0_0
                                |) in
                              M.read (| to_pc |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "openvm_circuit::arch::execution::PcIncOrSet::Inc",
                                  0
                                |) in
                              let pc_inc :=
                                M.copy (|
                                  Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr",
                                  γ0_0
                                |) in
                              M.call_closure (|
                                Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr",
                                M.get_trait_method (|
                                  "core::ops::arith::Add",
                                  Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr",
                                  [],
                                  [ Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr"
                                  ],
                                  "add",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.associated_in_trait
                                      "p3_air::air::AirBuilder"
                                      []
                                      []
                                      AB
                                      "Expr",
                                    M.get_trait_method (|
                                      "core::convert::Into",
                                      impl_Into_AB_Expr___plus__Clone,
                                      [],
                                      [
                                        Ty.associated_in_trait
                                          "p3_air::air::AirBuilder"
                                          []
                                          []
                                          AB
                                          "Expr"
                                      ],
                                      "into",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        impl_Into_AB_Expr___plus__Clone,
                                        M.get_trait_method (|
                                          "core::clone::Clone",
                                          impl_Into_AB_Expr___plus__Clone,
                                          [],
                                          [],
                                          "clone",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.SubPointer.get_struct_record_field (|
                                              from_state,
                                              "openvm_circuit::arch::execution::ExecutionState",
                                              "pc"
                                            |)
                                          |)
                                        ]
                                      |)
                                    ]
                                  |);
                                  M.read (| pc_inc |)
                                ]
                              |)))
                        ]
                      |));
                    ("timestamp",
                      M.call_closure (|
                        Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr",
                        M.get_trait_method (|
                          "core::ops::arith::Add",
                          Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr",
                          [],
                          [ Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr" ],
                          "add",
                          [],
                          []
                        |),
                        [
                          M.call_closure (|
                            Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr",
                            M.get_trait_method (|
                              "core::convert::Into",
                              impl_Into_AB_Expr___plus__Clone,
                              [],
                              [ Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr" ],
                              "into",
                              [],
                              []
                            |),
                            [
                              M.call_closure (|
                                impl_Into_AB_Expr___plus__Clone,
                                M.get_trait_method (|
                                  "core::clone::Clone",
                                  impl_Into_AB_Expr___plus__Clone,
                                  [],
                                  [],
                                  "clone",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.SubPointer.get_struct_record_field (|
                                      from_state,
                                      "openvm_circuit::arch::execution::ExecutionState",
                                      "timestamp"
                                    |)
                                  |)
                                ]
                              |)
                            ]
                          |);
                          M.call_closure (|
                            Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr",
                            M.get_trait_method (|
                              "core::convert::Into",
                              impl_Into_AB_Expr_'2,
                              [],
                              [ Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr" ],
                              "into",
                              [],
                              []
                            |),
                            [ M.read (| timestamp_change |) ]
                          |)
                        ]
                      |))
                  ] in
              M.alloc (|
                Ty.apply
                  (Ty.path "openvm_circuit::arch::execution::ExecutionBridgeInteractor")
                  []
                  [ AB ],
                M.call_closure (|
                  Ty.apply
                    (Ty.path "openvm_circuit::arch::execution::ExecutionBridgeInteractor")
                    []
                    [ AB ],
                  M.get_associated_function (|
                    Ty.path "openvm_circuit::arch::execution::ExecutionBridge",
                    "execute",
                    [],
                    [
                      AB;
                      impl_Into_AB_Expr_;
                      impl_Into_AB_Expr_'1;
                      impl_IntoIterator_Item___impl_Into_AB_Expr__;
                      impl_Into_AB_Expr___plus__Clone;
                      Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr"
                    ]
                  |),
                  [
                    M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                    M.read (| opcode |);
                    M.read (| operands |);
                    M.read (| from_state |);
                    M.read (| to_state |)
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_execute_and_increment_or_set_pc :
        M.IsAssociatedFunction.C
          Self
          "execute_and_increment_or_set_pc"
          execute_and_increment_or_set_pc.
      Admitted.
      Global Typeclasses Opaque execute_and_increment_or_set_pc.
      
      (*
          pub fn execute_and_increment_pc<AB: InteractionBuilder>(
              &self,
              opcode: impl Into<AB::Expr>,
              operands: impl IntoIterator<Item = impl Into<AB::Expr>>,
              from_state: ExecutionState<impl Into<AB::Expr> + Clone>,
              timestamp_change: impl Into<AB::Expr>,
          ) -> ExecutionBridgeInteractor<AB> {
              let to_state = ExecutionState {
                  pc: from_state.pc.clone().into() + AB::Expr::from_canonical_u32(DEFAULT_PC_STEP),
                  timestamp: from_state.timestamp.clone().into() + timestamp_change.into(),
              };
              self.execute(opcode, operands, from_state, to_state)
          }
      *)
      Definition execute_and_increment_pc
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        match ε, τ, α with
        | [],
            [
              AB;
              impl_Into_AB_Expr_;
              impl_Into_AB_Expr_'1;
              impl_IntoIterator_Item___impl_Into_AB_Expr__;
              impl_Into_AB_Expr___plus__Clone;
              impl_Into_AB_Expr_'2
            ],
            [ self; opcode; operands; from_state; timestamp_change ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.path "openvm_circuit::arch::execution::ExecutionBridge" ],
                self
              |) in
            let opcode := M.alloc (| impl_Into_AB_Expr_, opcode |) in
            let operands := M.alloc (| impl_IntoIterator_Item___impl_Into_AB_Expr__, operands |) in
            let from_state :=
              M.alloc (|
                Ty.apply
                  (Ty.path "openvm_circuit::arch::execution::ExecutionState")
                  []
                  [ impl_Into_AB_Expr___plus__Clone ],
                from_state
              |) in
            let timestamp_change := M.alloc (| impl_Into_AB_Expr_'2, timestamp_change |) in
            M.read (|
              let~ to_state :
                  Ty.apply
                    (Ty.path "openvm_circuit::arch::execution::ExecutionState")
                    []
                    [ Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr" ] :=
                Value.mkStructRecord
                  "openvm_circuit::arch::execution::ExecutionState"
                  []
                  [ Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr" ]
                  [
                    ("pc",
                      M.call_closure (|
                        Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr",
                        M.get_trait_method (|
                          "core::ops::arith::Add",
                          Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr",
                          [],
                          [ Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr" ],
                          "add",
                          [],
                          []
                        |),
                        [
                          M.call_closure (|
                            Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr",
                            M.get_trait_method (|
                              "core::convert::Into",
                              impl_Into_AB_Expr___plus__Clone,
                              [],
                              [ Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr" ],
                              "into",
                              [],
                              []
                            |),
                            [
                              M.call_closure (|
                                impl_Into_AB_Expr___plus__Clone,
                                M.get_trait_method (|
                                  "core::clone::Clone",
                                  impl_Into_AB_Expr___plus__Clone,
                                  [],
                                  [],
                                  "clone",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.SubPointer.get_struct_record_field (|
                                      from_state,
                                      "openvm_circuit::arch::execution::ExecutionState",
                                      "pc"
                                    |)
                                  |)
                                ]
                              |)
                            ]
                          |);
                          M.call_closure (|
                            Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr",
                            M.get_trait_method (|
                              "p3_field::field::FieldAlgebra",
                              Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr",
                              [],
                              [],
                              "from_canonical_u32",
                              [],
                              []
                            |),
                            [
                              M.read (|
                                get_constant (|
                                  "openvm_instructions::program::DEFAULT_PC_STEP",
                                  Ty.path "u32"
                                |)
                              |)
                            ]
                          |)
                        ]
                      |));
                    ("timestamp",
                      M.call_closure (|
                        Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr",
                        M.get_trait_method (|
                          "core::ops::arith::Add",
                          Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr",
                          [],
                          [ Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr" ],
                          "add",
                          [],
                          []
                        |),
                        [
                          M.call_closure (|
                            Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr",
                            M.get_trait_method (|
                              "core::convert::Into",
                              impl_Into_AB_Expr___plus__Clone,
                              [],
                              [ Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr" ],
                              "into",
                              [],
                              []
                            |),
                            [
                              M.call_closure (|
                                impl_Into_AB_Expr___plus__Clone,
                                M.get_trait_method (|
                                  "core::clone::Clone",
                                  impl_Into_AB_Expr___plus__Clone,
                                  [],
                                  [],
                                  "clone",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.SubPointer.get_struct_record_field (|
                                      from_state,
                                      "openvm_circuit::arch::execution::ExecutionState",
                                      "timestamp"
                                    |)
                                  |)
                                ]
                              |)
                            ]
                          |);
                          M.call_closure (|
                            Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr",
                            M.get_trait_method (|
                              "core::convert::Into",
                              impl_Into_AB_Expr_'2,
                              [],
                              [ Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr" ],
                              "into",
                              [],
                              []
                            |),
                            [ M.read (| timestamp_change |) ]
                          |)
                        ]
                      |))
                  ] in
              M.alloc (|
                Ty.apply
                  (Ty.path "openvm_circuit::arch::execution::ExecutionBridgeInteractor")
                  []
                  [ AB ],
                M.call_closure (|
                  Ty.apply
                    (Ty.path "openvm_circuit::arch::execution::ExecutionBridgeInteractor")
                    []
                    [ AB ],
                  M.get_associated_function (|
                    Ty.path "openvm_circuit::arch::execution::ExecutionBridge",
                    "execute",
                    [],
                    [
                      AB;
                      impl_Into_AB_Expr_;
                      impl_Into_AB_Expr_'1;
                      impl_IntoIterator_Item___impl_Into_AB_Expr__;
                      impl_Into_AB_Expr___plus__Clone;
                      Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr"
                    ]
                  |),
                  [
                    M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                    M.read (| opcode |);
                    M.read (| operands |);
                    M.read (| from_state |);
                    M.read (| to_state |)
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_execute_and_increment_pc :
        M.IsAssociatedFunction.C Self "execute_and_increment_pc" execute_and_increment_pc.
      Admitted.
      Global Typeclasses Opaque execute_and_increment_pc.
      
      (*
          pub fn execute<AB: InteractionBuilder>(
              &self,
              opcode: impl Into<AB::Expr>,
              operands: impl IntoIterator<Item = impl Into<AB::Expr>>,
              from_state: ExecutionState<impl Into<AB::Expr> + Clone>,
              to_state: ExecutionState<impl Into<AB::Expr>>,
          ) -> ExecutionBridgeInteractor<AB> {
              ExecutionBridgeInteractor {
                  execution_bus: self.execution_bus,
                  program_bus: self.program_bus,
                  opcode: opcode.into(),
                  operands: operands.into_iter().map(Into::into).collect(),
                  from_state: from_state.map(Into::into),
                  to_state: to_state.map(Into::into),
              }
          }
      *)
      Definition execute (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [],
            [
              AB;
              impl_Into_AB_Expr_;
              impl_Into_AB_Expr_'1;
              impl_IntoIterator_Item___impl_Into_AB_Expr__;
              impl_Into_AB_Expr___plus__Clone;
              impl_Into_AB_Expr_'2
            ],
            [ self; opcode; operands; from_state; to_state ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.path "openvm_circuit::arch::execution::ExecutionBridge" ],
                self
              |) in
            let opcode := M.alloc (| impl_Into_AB_Expr_, opcode |) in
            let operands := M.alloc (| impl_IntoIterator_Item___impl_Into_AB_Expr__, operands |) in
            let from_state :=
              M.alloc (|
                Ty.apply
                  (Ty.path "openvm_circuit::arch::execution::ExecutionState")
                  []
                  [ impl_Into_AB_Expr___plus__Clone ],
                from_state
              |) in
            let to_state :=
              M.alloc (|
                Ty.apply
                  (Ty.path "openvm_circuit::arch::execution::ExecutionState")
                  []
                  [ impl_Into_AB_Expr_'2 ],
                to_state
              |) in
            Value.mkStructRecord
              "openvm_circuit::arch::execution::ExecutionBridgeInteractor"
              []
              [ AB ]
              [
                ("execution_bus",
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "openvm_circuit::arch::execution::ExecutionBridge",
                      "execution_bus"
                    |)
                  |));
                ("program_bus",
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "openvm_circuit::arch::execution::ExecutionBridge",
                      "program_bus"
                    |)
                  |));
                ("opcode",
                  M.call_closure (|
                    Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr",
                    M.get_trait_method (|
                      "core::convert::Into",
                      impl_Into_AB_Expr_,
                      [],
                      [ Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr" ],
                      "into",
                      [],
                      []
                    |),
                    [ M.read (| opcode |) ]
                  |));
                ("operands",
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      []
                      [
                        Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr";
                        Ty.path "alloc::alloc::Global"
                      ],
                    M.get_trait_method (|
                      "core::iter::traits::iterator::Iterator",
                      Ty.apply
                        (Ty.path "core::iter::adapters::map::Map")
                        []
                        [
                          Ty.associated_in_trait
                            "core::iter::traits::collect::IntoIterator"
                            []
                            []
                            impl_IntoIterator_Item___impl_Into_AB_Expr__
                            "IntoIter";
                          Ty.function
                            [ impl_Into_AB_Expr_'1 ]
                            (Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr")
                        ],
                      [],
                      [],
                      "collect",
                      [],
                      [
                        Ty.apply
                          (Ty.path "alloc::vec::Vec")
                          []
                          [
                            Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr";
                            Ty.path "alloc::alloc::Global"
                          ]
                      ]
                    |),
                    [
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::iter::adapters::map::Map")
                          []
                          [
                            Ty.associated_in_trait
                              "core::iter::traits::collect::IntoIterator"
                              []
                              []
                              impl_IntoIterator_Item___impl_Into_AB_Expr__
                              "IntoIter";
                            Ty.function
                              [ impl_Into_AB_Expr_'1 ]
                              (Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr")
                          ],
                        M.get_trait_method (|
                          "core::iter::traits::iterator::Iterator",
                          Ty.associated_in_trait
                            "core::iter::traits::collect::IntoIterator"
                            []
                            []
                            impl_IntoIterator_Item___impl_Into_AB_Expr__
                            "IntoIter",
                          [],
                          [],
                          "map",
                          [],
                          [
                            Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr";
                            Ty.function
                              [ impl_Into_AB_Expr_'1 ]
                              (Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr")
                          ]
                        |),
                        [
                          M.call_closure (|
                            Ty.associated_in_trait
                              "core::iter::traits::collect::IntoIterator"
                              []
                              []
                              impl_IntoIterator_Item___impl_Into_AB_Expr__
                              "IntoIter",
                            M.get_trait_method (|
                              "core::iter::traits::collect::IntoIterator",
                              impl_IntoIterator_Item___impl_Into_AB_Expr__,
                              [],
                              [],
                              "into_iter",
                              [],
                              []
                            |),
                            [ M.read (| operands |) ]
                          |);
                          M.get_trait_method (|
                            "core::convert::Into",
                            impl_Into_AB_Expr_'1,
                            [],
                            [ Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr" ],
                            "into",
                            [],
                            []
                          |)
                        ]
                      |)
                    ]
                  |));
                ("from_state",
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "openvm_circuit::arch::execution::ExecutionState")
                      []
                      [ Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr" ],
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "openvm_circuit::arch::execution::ExecutionState")
                        []
                        [ impl_Into_AB_Expr___plus__Clone ],
                      "map",
                      [],
                      [
                        Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr";
                        Ty.function
                          [ impl_Into_AB_Expr___plus__Clone ]
                          (Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr")
                      ]
                    |),
                    [
                      M.read (| from_state |);
                      M.get_trait_method (|
                        "core::convert::Into",
                        impl_Into_AB_Expr___plus__Clone,
                        [],
                        [ Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr" ],
                        "into",
                        [],
                        []
                      |)
                    ]
                  |));
                ("to_state",
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "openvm_circuit::arch::execution::ExecutionState")
                      []
                      [ Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr" ],
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "openvm_circuit::arch::execution::ExecutionState")
                        []
                        [ impl_Into_AB_Expr_'2 ],
                      "map",
                      [],
                      [
                        Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr";
                        Ty.function
                          [ impl_Into_AB_Expr_'2 ]
                          (Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr")
                      ]
                    |),
                    [
                      M.read (| to_state |);
                      M.get_trait_method (|
                        "core::convert::Into",
                        impl_Into_AB_Expr_'2,
                        [],
                        [ Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr" ],
                        "into",
                        [],
                        []
                      |)
                    ]
                  |))
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_execute : M.IsAssociatedFunction.C Self "execute" execute.
      Admitted.
      Global Typeclasses Opaque execute.
    End Impl_openvm_circuit_arch_execution_ExecutionBridge.
    
    Module Impl_openvm_circuit_arch_execution_ExecutionBridgeInteractor_AB.
      Definition Self (AB : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "openvm_circuit::arch::execution::ExecutionBridgeInteractor") [] [ AB ].
      
      (*
          pub fn eval(self, builder: &mut AB, enabled: impl Into<AB::Expr>) {
              let enabled = enabled.into();
      
              // Interaction with program
              self.program_bus.lookup_instruction(
                  builder,
                  self.from_state.pc.clone(),
                  self.opcode,
                  self.operands,
                  enabled.clone(),
              );
      
              self.execution_bus
                  .execute(builder, enabled, self.from_state, self.to_state);
          }
      *)
      Definition eval (AB : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self AB in
        match ε, τ, α with
        | [], [ impl_Into_AB_Expr_ ], [ self; builder; enabled ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "openvm_circuit::arch::execution::ExecutionBridgeInteractor")
                  []
                  [ AB ],
                self
              |) in
            let builder := M.alloc (| Ty.apply (Ty.path "&mut") [] [ AB ], builder |) in
            let enabled := M.alloc (| impl_Into_AB_Expr_, enabled |) in
            M.read (|
              let~ enabled : Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr" :=
                M.call_closure (|
                  Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr",
                  M.get_trait_method (|
                    "core::convert::Into",
                    impl_Into_AB_Expr_,
                    [],
                    [ Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr" ],
                    "into",
                    [],
                    []
                  |),
                  [ M.read (| enabled |) ]
                |) in
              let~ _ : Ty.tuple [] :=
                M.call_closure (|
                  Ty.tuple [],
                  M.get_associated_function (|
                    Ty.path "openvm_circuit::system::program::bus::ProgramBus",
                    "lookup_instruction",
                    [],
                    [
                      AB;
                      Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr";
                      Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr";
                      Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr";
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        []
                        [
                          Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr";
                          Ty.path "alloc::alloc::Global"
                        ];
                      Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr"
                    ]
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        self,
                        "openvm_circuit::arch::execution::ExecutionBridgeInteractor",
                        "program_bus"
                      |)
                    |);
                    M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| builder |) |) |);
                    M.call_closure (|
                      Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr",
                      M.get_trait_method (|
                        "core::clone::Clone",
                        Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr",
                        [],
                        [],
                        "clone",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.SubPointer.get_struct_record_field (|
                              self,
                              "openvm_circuit::arch::execution::ExecutionBridgeInteractor",
                              "from_state"
                            |),
                            "openvm_circuit::arch::execution::ExecutionState",
                            "pc"
                          |)
                        |)
                      ]
                    |);
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        self,
                        "openvm_circuit::arch::execution::ExecutionBridgeInteractor",
                        "opcode"
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        self,
                        "openvm_circuit::arch::execution::ExecutionBridgeInteractor",
                        "operands"
                      |)
                    |);
                    M.call_closure (|
                      Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr",
                      M.get_trait_method (|
                        "core::clone::Clone",
                        Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr",
                        [],
                        [],
                        "clone",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.Ref, enabled |) ]
                    |)
                  ]
                |) in
              let~ _ : Ty.tuple [] :=
                M.call_closure (|
                  Ty.tuple [],
                  M.get_associated_function (|
                    Ty.path "openvm_circuit::arch::execution::ExecutionBus",
                    "execute",
                    [],
                    [
                      AB;
                      Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr";
                      Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr";
                      Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr"
                    ]
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        self,
                        "openvm_circuit::arch::execution::ExecutionBridgeInteractor",
                        "execution_bus"
                      |)
                    |);
                    M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| builder |) |) |);
                    M.read (| enabled |);
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        self,
                        "openvm_circuit::arch::execution::ExecutionBridgeInteractor",
                        "from_state"
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        self,
                        "openvm_circuit::arch::execution::ExecutionBridgeInteractor",
                        "to_state"
                      |)
                    |)
                  ]
                |) in
              M.alloc (| Ty.tuple [], Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_eval :
        forall (AB : Ty.t),
        M.IsAssociatedFunction.C (Self AB) "eval" (eval AB).
      Admitted.
      Global Typeclasses Opaque eval.
    End Impl_openvm_circuit_arch_execution_ExecutionBridgeInteractor_AB.
    
    Module Impl_core_convert_From_where_p3_field_field_FieldAlgebra_T_Tuple_u32_core_option_Option_T__for_openvm_circuit_arch_execution_PcIncOrSet_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "openvm_circuit::arch::execution::PcIncOrSet") [] [ T ].
      
      (*
          fn from((pc_inc, to_pc): (u32, Option<T>)) -> Self {
              match to_pc {
                  None => PcIncOrSet::Inc(T::from_canonical_u32(pc_inc)),
                  Some(to_pc) => PcIncOrSet::Set(to_pc),
              }
          }
      *)
      Definition from (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ β0 ] =>
          ltac:(M.monadic
            (let β0 :=
              M.alloc (|
                Ty.tuple [ Ty.path "u32"; Ty.apply (Ty.path "core::option::Option") [] [ T ] ],
                β0
              |) in
            M.match_operator (|
              Ty.apply (Ty.path "openvm_circuit::arch::execution::PcIncOrSet") [] [ T ],
              β0,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let pc_inc :=
                      M.copy (|
                        Ty.path
                          "Type for variables in patterns in function parameters is not handled",
                        γ0_0
                      |) in
                    let to_pc :=
                      M.copy (|
                        Ty.path
                          "Type for variables in patterns in function parameters is not handled",
                        γ0_1
                      |) in
                    M.match_operator (|
                      Ty.apply (Ty.path "openvm_circuit::arch::execution::PcIncOrSet") [] [ T ],
                      to_pc,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let _ := M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                            Value.StructTuple
                              "openvm_circuit::arch::execution::PcIncOrSet::Inc"
                              []
                              [ T ]
                              [
                                M.call_closure (|
                                  T,
                                  M.get_trait_method (|
                                    "p3_field::field::FieldAlgebra",
                                    T,
                                    [],
                                    [],
                                    "from_canonical_u32",
                                    [],
                                    []
                                  |),
                                  [ M.read (| pc_inc |) ]
                                |)
                              ]));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::option::Option::Some",
                                0
                              |) in
                            let to_pc := M.copy (| T, γ0_0 |) in
                            Value.StructTuple
                              "openvm_circuit::arch::execution::PcIncOrSet::Set"
                              []
                              [ T ]
                              [ M.read (| to_pc |) ]))
                      ]
                    |)))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.tuple [ Ty.path "u32"; Ty.apply (Ty.path "core::option::Option") [] [ T ] ] ]
          (Self T)
          (* Instance *) [ ("from", InstanceField.Method (from T)) ].
    End Impl_core_convert_From_where_p3_field_field_FieldAlgebra_T_Tuple_u32_core_option_Option_T__for_openvm_circuit_arch_execution_PcIncOrSet_T.
    
    (* Trait *)
    (* Empty module 'PhantomSubExecutor' *)
  End execution.
End arch.
