(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module arch.
  Module hasher.
    (* Trait *)
    Module Hasher.
      Definition hash
          (CHUNK : Value.t)
          (F Self : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        match ε, τ, α with
        | [], [], [ self; values ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "&") [] [ Self ], self |) in
            let values :=
              M.alloc (|
                Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "array") [ CHUNK ] [ F ] ],
                values
              |) in
            M.call_closure (|
              Ty.apply (Ty.path "array") [ CHUNK ] [ F ],
              M.get_trait_method (|
                "openvm_circuit::arch::hasher::Hasher",
                Self,
                [ CHUNK ],
                [ F ],
                "compress",
                [],
                []
              |),
              [
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| values |) |) |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.alloc (|
                        Ty.apply (Ty.path "array") [ CHUNK ] [ F ],
                        lib.repeat (|
                          M.read (| get_constant (| "p3_field::field::FieldAlgebra::ZERO", F |) |),
                          CHUNK
                        |)
                      |)
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom ProvidedMethod_hash :
        forall (CHUNK : Value.t) (F : Ty.t),
        M.IsProvidedMethod "openvm_circuit::arch::hasher::Hasher" "hash" (hash CHUNK F).
      Definition merkle_root
          (CHUNK : Value.t)
          (F Self : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        match ε, τ, α with
        | [], [], [ self; values ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "&") [] [ Self ], self |) in
            let values :=
              M.alloc (|
                Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ F ] ],
                values
              |) in
            M.read (|
              let~ leaves :
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [ Ty.apply (Ty.path "array") [ CHUNK ] [ F ]; Ty.path "alloc::alloc::Global"
                    ] :=
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [ Ty.apply (Ty.path "array") [ CHUNK ] [ F ]; Ty.path "alloc::alloc::Global" ],
                  M.get_trait_method (|
                    "core::iter::traits::iterator::Iterator",
                    Ty.apply
                      (Ty.path "core::iter::adapters::map::Map")
                      []
                      [
                        Ty.apply
                          (Ty.path "alloc::vec::into_iter::IntoIter")
                          []
                          [
                            Ty.apply (Ty.path "array") [ CHUNK ] [ F ];
                            Ty.path "alloc::alloc::Global"
                          ];
                        Ty.function
                          [ Ty.apply (Ty.path "array") [ CHUNK ] [ F ] ]
                          (Ty.apply (Ty.path "array") [ CHUNK ] [ F ])
                      ],
                    [],
                    [],
                    "collect",
                    [],
                    [
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        []
                        [ Ty.apply (Ty.path "array") [ CHUNK ] [ F ]; Ty.path "alloc::alloc::Global"
                        ]
                    ]
                  |),
                  [
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::iter::adapters::map::Map")
                        []
                        [
                          Ty.apply
                            (Ty.path "alloc::vec::into_iter::IntoIter")
                            []
                            [
                              Ty.apply (Ty.path "array") [ CHUNK ] [ F ];
                              Ty.path "alloc::alloc::Global"
                            ];
                          Ty.function
                            [ Ty.apply (Ty.path "array") [ CHUNK ] [ F ] ]
                            (Ty.apply (Ty.path "array") [ CHUNK ] [ F ])
                        ],
                      M.get_trait_method (|
                        "core::iter::traits::iterator::Iterator",
                        Ty.apply
                          (Ty.path "alloc::vec::into_iter::IntoIter")
                          []
                          [
                            Ty.apply (Ty.path "array") [ CHUNK ] [ F ];
                            Ty.path "alloc::alloc::Global"
                          ],
                        [],
                        [],
                        "map",
                        [],
                        [
                          Ty.apply (Ty.path "array") [ CHUNK ] [ F ];
                          Ty.function
                            [ Ty.apply (Ty.path "array") [ CHUNK ] [ F ] ]
                            (Ty.apply (Ty.path "array") [ CHUNK ] [ F ])
                        ]
                      |),
                      [
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "alloc::vec::into_iter::IntoIter")
                            []
                            [
                              Ty.apply (Ty.path "array") [ CHUNK ] [ F ];
                              Ty.path "alloc::alloc::Global"
                            ],
                          M.get_trait_method (|
                            "core::iter::traits::collect::IntoIterator",
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              []
                              [
                                Ty.apply (Ty.path "array") [ CHUNK ] [ F ];
                                Ty.path "alloc::alloc::Global"
                              ],
                            [],
                            [],
                            "into_iter",
                            [],
                            []
                          |),
                          [
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                []
                                [
                                  Ty.apply (Ty.path "array") [ CHUNK ] [ F ];
                                  Ty.path "alloc::alloc::Global"
                                ],
                              M.get_function (|
                                "openvm_circuit::arch::hasher::chunk_public_values",
                                [ CHUNK ],
                                [ F ]
                              |),
                              [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| values |) |) |) ]
                            |)
                          ]
                        |);
                        M.closure
                          (fun γ =>
                            ltac:(M.monadic
                              match γ with
                              | [ α0 ] =>
                                ltac:(M.monadic
                                  (M.match_operator (|
                                    Ty.apply (Ty.path "array") [ CHUNK ] [ F ],
                                    M.alloc (| Ty.apply (Ty.path "array") [ CHUNK ] [ F ], α0 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let c :=
                                            M.copy (|
                                              Ty.apply (Ty.path "array") [ CHUNK ] [ F ],
                                              γ
                                            |) in
                                          M.call_closure (|
                                            Ty.apply (Ty.path "array") [ CHUNK ] [ F ],
                                            M.get_trait_method (|
                                              "openvm_circuit::arch::hasher::Hasher",
                                              Self,
                                              [ CHUNK ],
                                              [ F ],
                                              "hash",
                                              [],
                                              []
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.read (| self |) |)
                                              |);
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.borrow (| Pointer.Kind.Ref, c |) |)
                                              |)
                                            ]
                                          |)))
                                    ]
                                  |)))
                              | _ => M.impossible "wrong number of arguments"
                              end))
                      ]
                    |)
                  ]
                |) in
              let~ _ : Ty.tuple [] :=
                M.read (|
                  M.loop (|
                    Ty.tuple [],
                    ltac:(M.monadic
                      (M.alloc (|
                        Ty.tuple [],
                        M.match_operator (|
                          Ty.tuple [],
                          M.alloc (| Ty.tuple [], Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.use
                                    (M.alloc (|
                                      Ty.path "bool",
                                      M.call_closure (|
                                        Ty.path "bool",
                                        BinOp.gt,
                                        [
                                          M.call_closure (|
                                            Ty.path "usize",
                                            M.get_associated_function (|
                                              Ty.apply
                                                (Ty.path "alloc::vec::Vec")
                                                []
                                                [
                                                  Ty.apply (Ty.path "array") [ CHUNK ] [ F ];
                                                  Ty.path "alloc::alloc::Global"
                                                ],
                                              "len",
                                              [],
                                              []
                                            |),
                                            [ M.borrow (| Pointer.Kind.Ref, leaves |) ]
                                          |);
                                          Value.Integer IntegerKind.Usize 1
                                        ]
                                      |)
                                    |)) in
                                let _ :=
                                  is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                M.read (|
                                  let~ _ : Ty.tuple [] :=
                                    M.write (|
                                      leaves,
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "alloc::vec::Vec")
                                          []
                                          [
                                            Ty.apply (Ty.path "array") [ CHUNK ] [ F ];
                                            Ty.path "alloc::alloc::Global"
                                          ],
                                        M.get_trait_method (|
                                          "core::iter::traits::iterator::Iterator",
                                          Ty.apply
                                            (Ty.path "core::iter::adapters::map::Map")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "core::slice::iter::ChunksExact")
                                                []
                                                [ Ty.apply (Ty.path "array") [ CHUNK ] [ F ] ];
                                              Ty.function
                                                [
                                                  Ty.apply
                                                    (Ty.path "&")
                                                    []
                                                    [
                                                      Ty.apply
                                                        (Ty.path "slice")
                                                        []
                                                        [ Ty.apply (Ty.path "array") [ CHUNK ] [ F ]
                                                        ]
                                                    ]
                                                ]
                                                (Ty.apply (Ty.path "array") [ CHUNK ] [ F ])
                                            ],
                                          [],
                                          [],
                                          "collect",
                                          [],
                                          [
                                            Ty.apply
                                              (Ty.path "alloc::vec::Vec")
                                              []
                                              [
                                                Ty.apply (Ty.path "array") [ CHUNK ] [ F ];
                                                Ty.path "alloc::alloc::Global"
                                              ]
                                          ]
                                        |),
                                        [
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::iter::adapters::map::Map")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::slice::iter::ChunksExact")
                                                  []
                                                  [ Ty.apply (Ty.path "array") [ CHUNK ] [ F ] ];
                                                Ty.function
                                                  [
                                                    Ty.apply
                                                      (Ty.path "&")
                                                      []
                                                      [
                                                        Ty.apply
                                                          (Ty.path "slice")
                                                          []
                                                          [
                                                            Ty.apply
                                                              (Ty.path "array")
                                                              [ CHUNK ]
                                                              [ F ]
                                                          ]
                                                      ]
                                                  ]
                                                  (Ty.apply (Ty.path "array") [ CHUNK ] [ F ])
                                              ],
                                            M.get_trait_method (|
                                              "core::iter::traits::iterator::Iterator",
                                              Ty.apply
                                                (Ty.path "core::slice::iter::ChunksExact")
                                                []
                                                [ Ty.apply (Ty.path "array") [ CHUNK ] [ F ] ],
                                              [],
                                              [],
                                              "map",
                                              [],
                                              [
                                                Ty.apply (Ty.path "array") [ CHUNK ] [ F ];
                                                Ty.function
                                                  [
                                                    Ty.apply
                                                      (Ty.path "&")
                                                      []
                                                      [
                                                        Ty.apply
                                                          (Ty.path "slice")
                                                          []
                                                          [
                                                            Ty.apply
                                                              (Ty.path "array")
                                                              [ CHUNK ]
                                                              [ F ]
                                                          ]
                                                      ]
                                                  ]
                                                  (Ty.apply (Ty.path "array") [ CHUNK ] [ F ])
                                              ]
                                            |),
                                            [
                                              M.call_closure (|
                                                Ty.apply
                                                  (Ty.path "core::slice::iter::ChunksExact")
                                                  []
                                                  [ Ty.apply (Ty.path "array") [ CHUNK ] [ F ] ],
                                                M.get_associated_function (|
                                                  Ty.apply
                                                    (Ty.path "slice")
                                                    []
                                                    [ Ty.apply (Ty.path "array") [ CHUNK ] [ F ] ],
                                                  "chunks_exact",
                                                  [],
                                                  []
                                                |),
                                                [
                                                  M.borrow (|
                                                    Pointer.Kind.Ref,
                                                    M.deref (|
                                                      M.call_closure (|
                                                        Ty.apply
                                                          (Ty.path "&")
                                                          []
                                                          [
                                                            Ty.apply
                                                              (Ty.path "slice")
                                                              []
                                                              [
                                                                Ty.apply
                                                                  (Ty.path "array")
                                                                  [ CHUNK ]
                                                                  [ F ]
                                                              ]
                                                          ],
                                                        M.get_trait_method (|
                                                          "core::ops::deref::Deref",
                                                          Ty.apply
                                                            (Ty.path "alloc::vec::Vec")
                                                            []
                                                            [
                                                              Ty.apply
                                                                (Ty.path "array")
                                                                [ CHUNK ]
                                                                [ F ];
                                                              Ty.path "alloc::alloc::Global"
                                                            ],
                                                          [],
                                                          [],
                                                          "deref",
                                                          [],
                                                          []
                                                        |),
                                                        [ M.borrow (| Pointer.Kind.Ref, leaves |) ]
                                                      |)
                                                    |)
                                                  |);
                                                  Value.Integer IntegerKind.Usize 2
                                                ]
                                              |);
                                              M.closure
                                                (fun γ =>
                                                  ltac:(M.monadic
                                                    match γ with
                                                    | [ α0 ] =>
                                                      ltac:(M.monadic
                                                        (M.match_operator (|
                                                          Ty.apply
                                                            (Ty.path "array")
                                                            [ CHUNK ]
                                                            [ F ],
                                                          M.alloc (|
                                                            Ty.apply
                                                              (Ty.path "&")
                                                              []
                                                              [
                                                                Ty.apply
                                                                  (Ty.path "slice")
                                                                  []
                                                                  [
                                                                    Ty.apply
                                                                      (Ty.path "array")
                                                                      [ CHUNK ]
                                                                      [ F ]
                                                                  ]
                                                              ],
                                                            α0
                                                          |),
                                                          [
                                                            fun γ =>
                                                              ltac:(M.monadic
                                                                (let c :=
                                                                  M.copy (|
                                                                    Ty.apply
                                                                      (Ty.path "&")
                                                                      []
                                                                      [
                                                                        Ty.apply
                                                                          (Ty.path "slice")
                                                                          []
                                                                          [
                                                                            Ty.apply
                                                                              (Ty.path "array")
                                                                              [ CHUNK ]
                                                                              [ F ]
                                                                          ]
                                                                      ],
                                                                    γ
                                                                  |) in
                                                                M.call_closure (|
                                                                  Ty.apply
                                                                    (Ty.path "array")
                                                                    [ CHUNK ]
                                                                    [ F ],
                                                                  M.get_trait_method (|
                                                                    "openvm_circuit::arch::hasher::Hasher",
                                                                    Self,
                                                                    [ CHUNK ],
                                                                    [ F ],
                                                                    "compress",
                                                                    [],
                                                                    []
                                                                  |),
                                                                  [
                                                                    M.borrow (|
                                                                      Pointer.Kind.Ref,
                                                                      M.deref (|
                                                                        M.read (| self |)
                                                                      |)
                                                                    |);
                                                                    M.borrow (|
                                                                      Pointer.Kind.Ref,
                                                                      M.deref (|
                                                                        M.borrow (|
                                                                          Pointer.Kind.Ref,
                                                                          M.SubPointer.get_array_field (|
                                                                            M.deref (|
                                                                              M.read (| c |)
                                                                            |),
                                                                            Value.Integer
                                                                              IntegerKind.Usize
                                                                              0
                                                                          |)
                                                                        |)
                                                                      |)
                                                                    |);
                                                                    M.borrow (|
                                                                      Pointer.Kind.Ref,
                                                                      M.deref (|
                                                                        M.borrow (|
                                                                          Pointer.Kind.Ref,
                                                                          M.SubPointer.get_array_field (|
                                                                            M.deref (|
                                                                              M.read (| c |)
                                                                            |),
                                                                            Value.Integer
                                                                              IntegerKind.Usize
                                                                              1
                                                                          |)
                                                                        |)
                                                                      |)
                                                                    |)
                                                                  ]
                                                                |)))
                                                          ]
                                                        |)))
                                                    | _ => M.impossible "wrong number of arguments"
                                                    end))
                                            ]
                                          |)
                                        ]
                                      |)
                                    |) in
                                  M.alloc (| Ty.tuple [], Value.Tuple [] |)
                                |)));
                            fun γ =>
                              ltac:(M.monadic
                                (M.never_to_any (|
                                  M.read (|
                                    let~ _ : Ty.tuple [] :=
                                      M.never_to_any (| M.read (| M.break (||) |) |) in
                                    M.alloc (| Ty.tuple [], Value.Tuple [] |)
                                  |)
                                |)))
                          ]
                        |)
                      |)))
                  |)
                |) in
              M.deref (|
                M.call_closure (|
                  Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "array") [ CHUNK ] [ F ] ],
                  M.get_trait_method (|
                    "core::ops::index::Index",
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      []
                      [ Ty.apply (Ty.path "array") [ CHUNK ] [ F ]; Ty.path "alloc::alloc::Global"
                      ],
                    [],
                    [ Ty.path "usize" ],
                    "index",
                    [],
                    []
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, leaves |); Value.Integer IntegerKind.Usize 0 ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom ProvidedMethod_merkle_root :
        forall (CHUNK : Value.t) (F : Ty.t),
        M.IsProvidedMethod
          "openvm_circuit::arch::hasher::Hasher"
          "merkle_root"
          (merkle_root CHUNK F).
    End Hasher.
    
    (* Trait *)
    Module HasherChip.
      Definition hash_and_record
          (CHUNK : Value.t)
          (F Self : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        match ε, τ, α with
        | [], [], [ self; values ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "&mut") [] [ Self ], self |) in
            let values :=
              M.alloc (|
                Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "array") [ CHUNK ] [ F ] ],
                values
              |) in
            M.call_closure (|
              Ty.apply (Ty.path "array") [ CHUNK ] [ F ],
              M.get_trait_method (|
                "openvm_circuit::arch::hasher::HasherChip",
                Self,
                [ CHUNK ],
                [ F ],
                "compress_and_record",
                [],
                []
              |),
              [
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| values |) |) |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.alloc (|
                        Ty.apply (Ty.path "array") [ CHUNK ] [ F ],
                        lib.repeat (|
                          M.read (| get_constant (| "p3_field::field::FieldAlgebra::ZERO", F |) |),
                          CHUNK
                        |)
                      |)
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom ProvidedMethod_hash_and_record :
        forall (CHUNK : Value.t) (F : Ty.t),
        M.IsProvidedMethod
          "openvm_circuit::arch::hasher::HasherChip"
          "hash_and_record"
          (hash_and_record CHUNK F).
    End HasherChip.
    
    (*
    fn chunk_public_values<const CHUNK: usize, F: Field>(public_values: &[F]) -> Vec<[F; CHUNK]> {
        public_values
            .chunks_exact(CHUNK)
            .map(|c| c.try_into().unwrap())
            .collect()
    }
    *)
    Definition chunk_public_values (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [ CHUNK ], [ F ], [ public_values ] =>
        ltac:(M.monadic
          (let public_values :=
            M.alloc (|
              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ F ] ],
              public_values
            |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "alloc::vec::Vec")
              []
              [ Ty.apply (Ty.path "array") [ CHUNK ] [ F ]; Ty.path "alloc::alloc::Global" ],
            M.get_trait_method (|
              "core::iter::traits::iterator::Iterator",
              Ty.apply
                (Ty.path "core::iter::adapters::map::Map")
                []
                [
                  Ty.apply (Ty.path "core::slice::iter::ChunksExact") [] [ F ];
                  Ty.function
                    [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ F ] ] ]
                    (Ty.apply (Ty.path "array") [ CHUNK ] [ F ])
                ],
              [],
              [],
              "collect",
              [],
              [
                Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  []
                  [ Ty.apply (Ty.path "array") [ CHUNK ] [ F ]; Ty.path "alloc::alloc::Global" ]
              ]
            |),
            [
              M.call_closure (|
                Ty.apply
                  (Ty.path "core::iter::adapters::map::Map")
                  []
                  [
                    Ty.apply (Ty.path "core::slice::iter::ChunksExact") [] [ F ];
                    Ty.function
                      [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ F ] ] ]
                      (Ty.apply (Ty.path "array") [ CHUNK ] [ F ])
                  ],
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  Ty.apply (Ty.path "core::slice::iter::ChunksExact") [] [ F ],
                  [],
                  [],
                  "map",
                  [],
                  [
                    Ty.apply (Ty.path "array") [ CHUNK ] [ F ];
                    Ty.function
                      [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ F ] ] ]
                      (Ty.apply (Ty.path "array") [ CHUNK ] [ F ])
                  ]
                |),
                [
                  M.call_closure (|
                    Ty.apply (Ty.path "core::slice::iter::ChunksExact") [] [ F ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "slice") [] [ F ],
                      "chunks_exact",
                      [],
                      []
                    |),
                    [
                      M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| public_values |) |) |);
                      CHUNK
                    ]
                  |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              Ty.apply (Ty.path "array") [ CHUNK ] [ F ],
                              M.alloc (|
                                Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ F ] ],
                                α0
                              |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let c :=
                                      M.copy (|
                                        Ty.apply
                                          (Ty.path "&")
                                          []
                                          [ Ty.apply (Ty.path "slice") [] [ F ] ],
                                        γ
                                      |) in
                                    M.call_closure (|
                                      Ty.apply (Ty.path "array") [ CHUNK ] [ F ],
                                      M.get_associated_function (|
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          []
                                          [
                                            Ty.apply (Ty.path "array") [ CHUNK ] [ F ];
                                            Ty.path "core::array::TryFromSliceError"
                                          ],
                                        "unwrap",
                                        [],
                                        []
                                      |),
                                      [
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            []
                                            [
                                              Ty.apply (Ty.path "array") [ CHUNK ] [ F ];
                                              Ty.path "core::array::TryFromSliceError"
                                            ],
                                          M.get_trait_method (|
                                            "core::convert::TryInto",
                                            Ty.apply
                                              (Ty.path "&")
                                              []
                                              [ Ty.apply (Ty.path "slice") [] [ F ] ],
                                            [],
                                            [ Ty.apply (Ty.path "array") [ CHUNK ] [ F ] ],
                                            "try_into",
                                            [],
                                            []
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (| M.read (| c |) |)
                                            |)
                                          ]
                                        |)
                                      ]
                                    |)))
                              ]
                            |)))
                        | _ => M.impossible "wrong number of arguments"
                        end))
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_chunk_public_values :
      M.IsFunction.C "openvm_circuit::arch::hasher::chunk_public_values" chunk_public_values.
    Admitted.
    Global Typeclasses Opaque chunk_public_values.
  End hasher.
End arch.
