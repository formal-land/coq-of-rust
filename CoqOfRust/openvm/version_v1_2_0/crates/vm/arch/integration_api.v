(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module arch.
  Module integration_api.
    (* Trait *)
    (* Empty module 'VmAdapterInterface' *)
    
    (* Trait *)
    (* Empty module 'VmAdapterChip' *)
    
    (* Trait *)
    (* Empty module 'VmAdapterAir' *)
    
    (* Trait *)
    Module VmCoreChip.
      Definition generate_public_values
          (F I Self : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "&") [] [ Self ], self |) in
            M.call_closure (|
              Ty.apply (Ty.path "alloc::vec::Vec") [] [ F; Ty.path "alloc::alloc::Global" ],
              M.get_associated_function (|
                Ty.apply (Ty.path "alloc::vec::Vec") [] [ F; Ty.path "alloc::alloc::Global" ],
                "new",
                [],
                []
              |),
              []
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom ProvidedMethod_generate_public_values :
        forall (F I : Ty.t),
        M.IsProvidedMethod
          "openvm_circuit::arch::integration_api::VmCoreChip"
          "generate_public_values"
          (generate_public_values F I).
      Definition finalize
          (F I Self : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        match ε, τ, α with
        | [], [], [ self; _trace; _num_records ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "&") [] [ Self ], self |) in
            let _trace :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&mut")
                  []
                  [
                    Ty.apply
                      (Ty.path "p3_matrix::dense::DenseMatrix")
                      []
                      [
                        F;
                        Ty.apply
                          (Ty.path "alloc::vec::Vec")
                          []
                          [ F; Ty.path "alloc::alloc::Global" ]
                      ]
                  ],
                _trace
              |) in
            let _num_records := M.alloc (| Ty.path "usize", _num_records |) in
            Value.Tuple []))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom ProvidedMethod_finalize :
        forall (F I : Ty.t),
        M.IsProvidedMethod
          "openvm_circuit::arch::integration_api::VmCoreChip"
          "finalize"
          (finalize F I).
    End VmCoreChip.
    
    (* Trait *)
    Module VmCoreAir.
      Definition start_offset_expr
          (AB I Self : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "&") [] [ Self ], self |) in
            M.call_closure (|
              Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr",
              M.get_trait_method (|
                "p3_field::field::FieldAlgebra",
                Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr",
                [],
                [],
                "from_canonical_usize",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.path "usize",
                  M.get_trait_method (|
                    "openvm_circuit::arch::integration_api::VmCoreAir",
                    Self,
                    [],
                    [ AB; I ],
                    "start_offset",
                    [],
                    []
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom ProvidedMethod_start_offset_expr :
        forall (AB I : Ty.t),
        M.IsProvidedMethod
          "openvm_circuit::arch::integration_api::VmCoreAir"
          "start_offset_expr"
          (start_offset_expr AB I).
      Definition expr_to_global_expr
          (AB I Self : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        match ε, τ, α with
        | [], [ impl_Into_AB_Expr_ ], [ self; local_expr ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "&") [] [ Self ], self |) in
            let local_expr := M.alloc (| impl_Into_AB_Expr_, local_expr |) in
            M.call_closure (|
              Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr",
              M.get_trait_method (|
                "core::ops::arith::Add",
                Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr",
                [],
                [ Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr" ],
                "add",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr",
                  M.get_trait_method (|
                    "openvm_circuit::arch::integration_api::VmCoreAir",
                    Self,
                    [],
                    [ AB; I ],
                    "start_offset_expr",
                    [],
                    []
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                |);
                M.call_closure (|
                  Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr",
                  M.get_trait_method (|
                    "core::convert::Into",
                    impl_Into_AB_Expr_,
                    [],
                    [ Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr" ],
                    "into",
                    [],
                    []
                  |),
                  [ M.read (| local_expr |) ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom ProvidedMethod_expr_to_global_expr :
        forall (AB I : Ty.t),
        M.IsProvidedMethod
          "openvm_circuit::arch::integration_api::VmCoreAir"
          "expr_to_global_expr"
          (expr_to_global_expr AB I).
      Definition opcode_to_global_expr
          (AB I Self : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        match ε, τ, α with
        | [], [ impl_LocalOpcode ], [ self; local_opcode ] =>
          ltac:(M.monadic
            (let self := M.alloc (| Ty.apply (Ty.path "&") [] [ Self ], self |) in
            let local_opcode := M.alloc (| impl_LocalOpcode, local_opcode |) in
            M.call_closure (|
              Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr",
              M.get_trait_method (|
                "openvm_circuit::arch::integration_api::VmCoreAir",
                Self,
                [],
                [ AB; I ],
                "expr_to_global_expr",
                [],
                [ Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr" ]
              |),
              [
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                M.call_closure (|
                  Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr",
                  M.get_trait_method (|
                    "p3_field::field::FieldAlgebra",
                    Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr",
                    [],
                    [],
                    "from_canonical_usize",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.path "usize",
                      M.get_trait_method (|
                        "openvm_instructions::LocalOpcode",
                        impl_LocalOpcode,
                        [],
                        [],
                        "local_usize",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.Ref, local_opcode |) ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom ProvidedMethod_opcode_to_global_expr :
        forall (AB I : Ty.t),
        M.IsProvidedMethod
          "openvm_circuit::arch::integration_api::VmCoreAir"
          "opcode_to_global_expr"
          (opcode_to_global_expr AB I).
    End VmCoreAir.
    
    (* StructRecord
      {
        name := "AdapterRuntimeContext";
        const_params := [];
        ty_params := [ "T"; "I" ];
        fields :=
          [
            ("to_pc", Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "u32" ]);
            ("writes",
              Ty.associated_in_trait
                "openvm_circuit::arch::integration_api::VmAdapterInterface"
                []
                [ T ]
                I
                "Writes")
          ];
      } *)
    
    Module Impl_openvm_circuit_arch_integration_api_AdapterRuntimeContext_T_I.
      Definition Self (T I : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "openvm_circuit::arch::integration_api::AdapterRuntimeContext")
          []
          [ T; I ].
      
      (*
          pub fn without_pc(writes: impl Into<I::Writes>) -> Self {
              Self {
                  to_pc: None,
                  writes: writes.into(),
              }
          }
      *)
      Definition without_pc
          (T I : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T I in
        match ε, τ, α with
        | [], [ impl_Into_I_Writes_ ], [ writes ] =>
          ltac:(M.monadic
            (let writes := M.alloc (| impl_Into_I_Writes_, writes |) in
            Value.mkStructRecord
              "openvm_circuit::arch::integration_api::AdapterRuntimeContext"
              []
              [ T; I ]
              [
                ("to_pc", Value.StructTuple "core::option::Option::None" [] [ Ty.path "u32" ] []);
                ("writes",
                  M.call_closure (|
                    Ty.associated_in_trait
                      "openvm_circuit::arch::integration_api::VmAdapterInterface"
                      []
                      [ T ]
                      I
                      "Writes",
                    M.get_trait_method (|
                      "core::convert::Into",
                      impl_Into_I_Writes_,
                      [],
                      [
                        Ty.associated_in_trait
                          "openvm_circuit::arch::integration_api::VmAdapterInterface"
                          []
                          [ T ]
                          I
                          "Writes"
                      ],
                      "into",
                      [],
                      []
                    |),
                    [ M.read (| writes |) ]
                  |))
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_without_pc :
        forall (T I : Ty.t),
        M.IsAssociatedFunction.C (Self T I) "without_pc" (without_pc T I).
      Admitted.
      Global Typeclasses Opaque without_pc.
    End Impl_openvm_circuit_arch_integration_api_AdapterRuntimeContext_T_I.
    
    (* StructRecord
      {
        name := "AdapterAirContext";
        const_params := [];
        ty_params := [ "T"; "I" ];
        fields :=
          [
            ("to_pc", Ty.apply (Ty.path "core::option::Option") [] [ T ]);
            ("reads",
              Ty.associated_in_trait
                "openvm_circuit::arch::integration_api::VmAdapterInterface"
                []
                [ T ]
                I
                "Reads");
            ("writes",
              Ty.associated_in_trait
                "openvm_circuit::arch::integration_api::VmAdapterInterface"
                []
                [ T ]
                I
                "Writes");
            ("instruction",
              Ty.associated_in_trait
                "openvm_circuit::arch::integration_api::VmAdapterInterface"
                []
                [ T ]
                I
                "ProcessedInstruction")
          ];
      } *)
    
    (* StructRecord
      {
        name := "VmChipWrapper";
        const_params := [];
        ty_params := [ "F"; "A"; "C" ];
        fields :=
          [
            ("adapter", A);
            ("core", C);
            ("records",
              Ty.apply
                (Ty.path "alloc::vec::Vec")
                []
                [
                  Ty.tuple
                    [
                      Ty.associated_in_trait
                        "openvm_circuit::arch::integration_api::VmAdapterChip"
                        []
                        [ F ]
                        A
                        "ReadRecord";
                      Ty.associated_in_trait
                        "openvm_circuit::arch::integration_api::VmAdapterChip"
                        []
                        [ F ]
                        A
                        "WriteRecord";
                      Ty.associated_in_trait
                        "openvm_circuit::arch::integration_api::VmCoreChip"
                        []
                        [
                          F;
                          Ty.associated_in_trait
                            "openvm_circuit::arch::integration_api::VmAdapterChip"
                            []
                            [ F ]
                            A
                            "Interface"
                        ]
                        C
                        "Record"
                    ];
                  Ty.path "alloc::alloc::Global"
                ]);
            ("offline_memory",
              Ty.apply
                (Ty.path "alloc::sync::Arc")
                []
                [
                  Ty.apply
                    (Ty.path "std::sync::mutex::Mutex")
                    []
                    [
                      Ty.apply
                        (Ty.path "openvm_circuit::system::memory::offline::OfflineMemory")
                        []
                        [ F ]
                    ];
                  Ty.path "alloc::alloc::Global"
                ])
          ];
      } *)
    
    Definition value_DEFAULT_RECORDS_CAPACITY
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      ltac:(M.monadic
        (M.alloc (|
          Ty.path "usize",
          M.call_closure (|
            Ty.path "usize",
            BinOp.Wrap.shl,
            [ Value.Integer IntegerKind.Usize 1; Value.Integer IntegerKind.I32 20 ]
          |)
        |))).
    
    Global Instance Instance_IsConstant_value_DEFAULT_RECORDS_CAPACITY :
      M.IsFunction.C
        "openvm_circuit::arch::integration_api::DEFAULT_RECORDS_CAPACITY"
        value_DEFAULT_RECORDS_CAPACITY.
    Admitted.
    Global Typeclasses Opaque value_DEFAULT_RECORDS_CAPACITY.
    
    Module Impl_openvm_circuit_arch_integration_api_VmChipWrapper_F_A_C.
      Definition Self (F A C : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "openvm_circuit::arch::integration_api::VmChipWrapper") [] [ F; A; C ].
      
      (*
          pub fn new(adapter: A, core: C, offline_memory: Arc<Mutex<OfflineMemory<F>>>) -> Self {
              Self {
                  adapter,
                  core,
                  records: Vec::with_capacity(DEFAULT_RECORDS_CAPACITY),
                  offline_memory,
              }
          }
      *)
      Definition new (F A C : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F A C in
        match ε, τ, α with
        | [], [], [ adapter; core; offline_memory ] =>
          ltac:(M.monadic
            (let adapter := M.alloc (| A, adapter |) in
            let core := M.alloc (| C, core |) in
            let offline_memory :=
              M.alloc (|
                Ty.apply
                  (Ty.path "alloc::sync::Arc")
                  []
                  [
                    Ty.apply
                      (Ty.path "std::sync::mutex::Mutex")
                      []
                      [
                        Ty.apply
                          (Ty.path "openvm_circuit::system::memory::offline::OfflineMemory")
                          []
                          [ F ]
                      ];
                    Ty.path "alloc::alloc::Global"
                  ],
                offline_memory
              |) in
            Value.mkStructRecord
              "openvm_circuit::arch::integration_api::VmChipWrapper"
              []
              [ F; A; C ]
              [
                ("adapter", M.read (| adapter |));
                ("core", M.read (| core |));
                ("records",
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      []
                      [
                        Ty.tuple
                          [
                            Ty.associated_in_trait
                              "openvm_circuit::arch::integration_api::VmAdapterChip"
                              []
                              [ F ]
                              A
                              "ReadRecord";
                            Ty.associated_in_trait
                              "openvm_circuit::arch::integration_api::VmAdapterChip"
                              []
                              [ F ]
                              A
                              "WriteRecord";
                            Ty.associated_in_trait
                              "openvm_circuit::arch::integration_api::VmCoreChip"
                              []
                              [
                                F;
                                Ty.associated_in_trait
                                  "openvm_circuit::arch::integration_api::VmAdapterChip"
                                  []
                                  [ F ]
                                  A
                                  "Interface"
                              ]
                              C
                              "Record"
                          ];
                        Ty.path "alloc::alloc::Global"
                      ],
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        []
                        [
                          Ty.tuple
                            [
                              Ty.associated_in_trait
                                "openvm_circuit::arch::integration_api::VmAdapterChip"
                                []
                                [ F ]
                                A
                                "ReadRecord";
                              Ty.associated_in_trait
                                "openvm_circuit::arch::integration_api::VmAdapterChip"
                                []
                                [ F ]
                                A
                                "WriteRecord";
                              Ty.associated_in_trait
                                "openvm_circuit::arch::integration_api::VmCoreChip"
                                []
                                [
                                  F;
                                  Ty.associated_in_trait
                                    "openvm_circuit::arch::integration_api::VmAdapterChip"
                                    []
                                    [ F ]
                                    A
                                    "Interface"
                                ]
                                C
                                "Record"
                            ];
                          Ty.path "alloc::alloc::Global"
                        ],
                      "with_capacity",
                      [],
                      []
                    |),
                    [
                      M.read (|
                        get_constant (|
                          "openvm_circuit::arch::integration_api::DEFAULT_RECORDS_CAPACITY",
                          Ty.path "usize"
                        |)
                      |)
                    ]
                  |));
                ("offline_memory", M.read (| offline_memory |))
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_new :
        forall (F A C : Ty.t),
        M.IsAssociatedFunction.C (Self F A C) "new" (new F A C).
      Admitted.
      Global Typeclasses Opaque new.
    End Impl_openvm_circuit_arch_integration_api_VmChipWrapper_F_A_C.
    
    Module Impl_openvm_circuit_arch_execution_InstructionExecutor_where_p3_field_field_PrimeField32_F_where_openvm_circuit_arch_integration_api_VmAdapterChip_A_F_where_core_marker_Send_A_where_core_marker_Sync_A_where_openvm_circuit_arch_integration_api_VmCoreChip_M__F_associated_in_trait_openvm_circuit_arch_integration_api_VmAdapterChip__F_A_Interface_where_core_marker_Send_M__where_core_marker_Sync_M__F_for_openvm_circuit_arch_integration_api_VmChipWrapper_F_A_M_.
      Definition Self (F A M_ : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "openvm_circuit::arch::integration_api::VmChipWrapper") [] [ F; A; M_ ].
      
      (*
          fn execute(
              &mut self,
              memory: &mut MemoryController<F>,
              instruction: &Instruction<F>,
              from_state: ExecutionState<u32>,
          ) -> Result<ExecutionState<u32>> {
              let (reads, read_record) = self.adapter.preprocess(memory, instruction)?;
              let (output, core_record) =
                  self.core
                      .execute_instruction(instruction, from_state.pc, reads)?;
              let (to_state, write_record) =
                  self.adapter
                      .postprocess(memory, instruction, from_state, output, &read_record)?;
              self.records.push((read_record, write_record, core_record));
              Ok(to_state)
          }
      *)
      Definition execute
          (F A M_ : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self F A M_ in
        match ε, τ, α with
        | [], [], [ self; memory; instruction; from_state ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&mut")
                  []
                  [
                    Ty.apply
                      (Ty.path "openvm_circuit::arch::integration_api::VmChipWrapper")
                      []
                      [ F; A; M_ ]
                  ],
                self
              |) in
            let memory :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&mut")
                  []
                  [
                    Ty.apply
                      (Ty.path "openvm_circuit::system::memory::controller::MemoryController")
                      []
                      [ F ]
                  ],
                memory
              |) in
            let instruction :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.apply (Ty.path "openvm_instructions::instruction::Instruction") [] [ F ] ],
                instruction
              |) in
            let from_state :=
              M.alloc (|
                Ty.apply
                  (Ty.path "openvm_circuit::arch::execution::ExecutionState")
                  []
                  [ Ty.path "u32" ],
                from_state
              |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply
                    (Ty.path "openvm_circuit::arch::execution::ExecutionState")
                    []
                    [ Ty.path "u32" ];
                  Ty.path "openvm_circuit::arch::execution::ExecutionError"
                ]) (|
              ltac:(M.monadic
                (M.match_operator (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [
                      Ty.apply
                        (Ty.path "openvm_circuit::arch::execution::ExecutionState")
                        []
                        [ Ty.path "u32" ];
                      Ty.path "openvm_circuit::arch::execution::ExecutionError"
                    ],
                  M.alloc (|
                    Ty.tuple
                      [
                        Ty.associated_in_trait
                          "openvm_circuit::arch::integration_api::VmAdapterInterface"
                          []
                          [ F ]
                          (Ty.associated_in_trait
                            "openvm_circuit::arch::integration_api::VmAdapterChip"
                            []
                            [ F ]
                            A
                            "Interface")
                          "Reads";
                        Ty.associated_in_trait
                          "openvm_circuit::arch::integration_api::VmAdapterChip"
                          []
                          [ F ]
                          A
                          "ReadRecord"
                      ],
                    M.match_operator (|
                      Ty.tuple
                        [
                          Ty.associated_in_trait
                            "openvm_circuit::arch::integration_api::VmAdapterInterface"
                            []
                            [ F ]
                            (Ty.associated_in_trait
                              "openvm_circuit::arch::integration_api::VmAdapterChip"
                              []
                              [ F ]
                              A
                              "Interface")
                            "Reads";
                          Ty.associated_in_trait
                            "openvm_circuit::arch::integration_api::VmAdapterChip"
                            []
                            [ F ]
                            A
                            "ReadRecord"
                        ],
                      M.alloc (|
                        Ty.apply
                          (Ty.path "core::ops::control_flow::ControlFlow")
                          []
                          [
                            Ty.apply
                              (Ty.path "core::result::Result")
                              []
                              [
                                Ty.path "core::convert::Infallible";
                                Ty.path "openvm_circuit::arch::execution::ExecutionError"
                              ];
                            Ty.tuple
                              [
                                Ty.associated_in_trait
                                  "openvm_circuit::arch::integration_api::VmAdapterInterface"
                                  []
                                  [ F ]
                                  (Ty.associated_in_trait
                                    "openvm_circuit::arch::integration_api::VmAdapterChip"
                                    []
                                    [ F ]
                                    A
                                    "Interface")
                                  "Reads";
                                Ty.associated_in_trait
                                  "openvm_circuit::arch::integration_api::VmAdapterChip"
                                  []
                                  [ F ]
                                  A
                                  "ReadRecord"
                              ]
                          ],
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::ops::control_flow::ControlFlow")
                            []
                            [
                              Ty.apply
                                (Ty.path "core::result::Result")
                                []
                                [
                                  Ty.path "core::convert::Infallible";
                                  Ty.path "openvm_circuit::arch::execution::ExecutionError"
                                ];
                              Ty.tuple
                                [
                                  Ty.associated_in_trait
                                    "openvm_circuit::arch::integration_api::VmAdapterInterface"
                                    []
                                    [ F ]
                                    (Ty.associated_in_trait
                                      "openvm_circuit::arch::integration_api::VmAdapterChip"
                                      []
                                      [ F ]
                                      A
                                      "Interface")
                                    "Reads";
                                  Ty.associated_in_trait
                                    "openvm_circuit::arch::integration_api::VmAdapterChip"
                                    []
                                    [ F ]
                                    A
                                    "ReadRecord"
                                ]
                            ],
                          M.get_trait_method (|
                            "core::ops::try_trait::Try",
                            Ty.apply
                              (Ty.path "core::result::Result")
                              []
                              [
                                Ty.tuple
                                  [
                                    Ty.associated_in_trait
                                      "openvm_circuit::arch::integration_api::VmAdapterInterface"
                                      []
                                      [ F ]
                                      (Ty.associated_in_trait
                                        "openvm_circuit::arch::integration_api::VmAdapterChip"
                                        []
                                        [ F ]
                                        A
                                        "Interface")
                                      "Reads";
                                    Ty.associated_in_trait
                                      "openvm_circuit::arch::integration_api::VmAdapterChip"
                                      []
                                      [ F ]
                                      A
                                      "ReadRecord"
                                  ];
                                Ty.path "openvm_circuit::arch::execution::ExecutionError"
                              ],
                            [],
                            [],
                            "branch",
                            [],
                            []
                          |),
                          [
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "core::result::Result")
                                []
                                [
                                  Ty.tuple
                                    [
                                      Ty.associated_in_trait
                                        "openvm_circuit::arch::integration_api::VmAdapterInterface"
                                        []
                                        [ F ]
                                        (Ty.associated_in_trait
                                          "openvm_circuit::arch::integration_api::VmAdapterChip"
                                          []
                                          [ F ]
                                          A
                                          "Interface")
                                        "Reads";
                                      Ty.associated_in_trait
                                        "openvm_circuit::arch::integration_api::VmAdapterChip"
                                        []
                                        [ F ]
                                        A
                                        "ReadRecord"
                                    ];
                                  Ty.path "openvm_circuit::arch::execution::ExecutionError"
                                ],
                              M.get_trait_method (|
                                "openvm_circuit::arch::integration_api::VmAdapterChip",
                                A,
                                [],
                                [ F ],
                                "preprocess",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.MutRef,
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "openvm_circuit::arch::integration_api::VmChipWrapper",
                                    "adapter"
                                  |)
                                |);
                                M.borrow (|
                                  Pointer.Kind.MutRef,
                                  M.deref (| M.read (| memory |) |)
                                |);
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (| M.read (| instruction |) |)
                                |)
                              ]
                            |)
                          ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Break",
                                0
                              |) in
                            let residual :=
                              M.copy (|
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  []
                                  [
                                    Ty.path "core::convert::Infallible";
                                    Ty.path "openvm_circuit::arch::execution::ExecutionError"
                                  ],
                                γ0_0
                              |) in
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path
                                            "openvm_circuit::arch::execution::ExecutionState")
                                          []
                                          [ Ty.path "u32" ];
                                        Ty.path "openvm_circuit::arch::execution::ExecutionError"
                                      ],
                                    M.get_trait_method (|
                                      "core::ops::try_trait::FromResidual",
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path
                                              "openvm_circuit::arch::execution::ExecutionState")
                                            []
                                            [ Ty.path "u32" ];
                                          Ty.path "openvm_circuit::arch::execution::ExecutionError"
                                        ],
                                      [],
                                      [
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          []
                                          [
                                            Ty.path "core::convert::Infallible";
                                            Ty.path
                                              "openvm_circuit::arch::execution::ExecutionError"
                                          ]
                                      ],
                                      "from_residual",
                                      [],
                                      []
                                    |),
                                    [ M.read (| residual |) ]
                                  |)
                                |)
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "core::ops::control_flow::ControlFlow::Continue",
                                0
                              |) in
                            let val :=
                              M.copy (|
                                Ty.tuple
                                  [
                                    Ty.associated_in_trait
                                      "openvm_circuit::arch::integration_api::VmAdapterInterface"
                                      []
                                      [ F ]
                                      (Ty.associated_in_trait
                                        "openvm_circuit::arch::integration_api::VmAdapterChip"
                                        []
                                        [ F ]
                                        A
                                        "Interface")
                                      "Reads";
                                    Ty.associated_in_trait
                                      "openvm_circuit::arch::integration_api::VmAdapterChip"
                                      []
                                      [ F ]
                                      A
                                      "ReadRecord"
                                  ],
                                γ0_0
                              |) in
                            M.read (| val |)))
                      ]
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                        let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                        let reads :=
                          M.copy (|
                            Ty.associated_in_trait
                              "openvm_circuit::arch::integration_api::VmAdapterInterface"
                              []
                              [ F ]
                              (Ty.associated_in_trait
                                "openvm_circuit::arch::integration_api::VmAdapterChip"
                                []
                                [ F ]
                                A
                                "Interface")
                              "Reads",
                            γ0_0
                          |) in
                        let read_record :=
                          M.copy (|
                            Ty.associated_in_trait
                              "openvm_circuit::arch::integration_api::VmAdapterChip"
                              []
                              [ F ]
                              A
                              "ReadRecord",
                            γ0_1
                          |) in
                        M.match_operator (|
                          Ty.apply
                            (Ty.path "core::result::Result")
                            []
                            [
                              Ty.apply
                                (Ty.path "openvm_circuit::arch::execution::ExecutionState")
                                []
                                [ Ty.path "u32" ];
                              Ty.path "openvm_circuit::arch::execution::ExecutionError"
                            ],
                          M.alloc (|
                            Ty.tuple
                              [
                                Ty.apply
                                  (Ty.path
                                    "openvm_circuit::arch::integration_api::AdapterRuntimeContext")
                                  []
                                  [
                                    F;
                                    Ty.associated_in_trait
                                      "openvm_circuit::arch::integration_api::VmAdapterChip"
                                      []
                                      [ F ]
                                      A
                                      "Interface"
                                  ];
                                Ty.associated_in_trait
                                  "openvm_circuit::arch::integration_api::VmCoreChip"
                                  []
                                  [
                                    F;
                                    Ty.associated_in_trait
                                      "openvm_circuit::arch::integration_api::VmAdapterChip"
                                      []
                                      [ F ]
                                      A
                                      "Interface"
                                  ]
                                  M_
                                  "Record"
                              ],
                            M.match_operator (|
                              Ty.tuple
                                [
                                  Ty.apply
                                    (Ty.path
                                      "openvm_circuit::arch::integration_api::AdapterRuntimeContext")
                                    []
                                    [
                                      F;
                                      Ty.associated_in_trait
                                        "openvm_circuit::arch::integration_api::VmAdapterChip"
                                        []
                                        [ F ]
                                        A
                                        "Interface"
                                    ];
                                  Ty.associated_in_trait
                                    "openvm_circuit::arch::integration_api::VmCoreChip"
                                    []
                                    [
                                      F;
                                      Ty.associated_in_trait
                                        "openvm_circuit::arch::integration_api::VmAdapterChip"
                                        []
                                        [ F ]
                                        A
                                        "Interface"
                                    ]
                                    M_
                                    "Record"
                                ],
                              M.alloc (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path "openvm_circuit::arch::execution::ExecutionError"
                                      ];
                                    Ty.tuple
                                      [
                                        Ty.apply
                                          (Ty.path
                                            "openvm_circuit::arch::integration_api::AdapterRuntimeContext")
                                          []
                                          [
                                            F;
                                            Ty.associated_in_trait
                                              "openvm_circuit::arch::integration_api::VmAdapterChip"
                                              []
                                              [ F ]
                                              A
                                              "Interface"
                                          ];
                                        Ty.associated_in_trait
                                          "openvm_circuit::arch::integration_api::VmCoreChip"
                                          []
                                          [
                                            F;
                                            Ty.associated_in_trait
                                              "openvm_circuit::arch::integration_api::VmAdapterChip"
                                              []
                                              [ F ]
                                              A
                                              "Interface"
                                          ]
                                          M_
                                          "Record"
                                      ]
                                  ],
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "core::ops::control_flow::ControlFlow")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        []
                                        [
                                          Ty.path "core::convert::Infallible";
                                          Ty.path "openvm_circuit::arch::execution::ExecutionError"
                                        ];
                                      Ty.tuple
                                        [
                                          Ty.apply
                                            (Ty.path
                                              "openvm_circuit::arch::integration_api::AdapterRuntimeContext")
                                            []
                                            [
                                              F;
                                              Ty.associated_in_trait
                                                "openvm_circuit::arch::integration_api::VmAdapterChip"
                                                []
                                                [ F ]
                                                A
                                                "Interface"
                                            ];
                                          Ty.associated_in_trait
                                            "openvm_circuit::arch::integration_api::VmCoreChip"
                                            []
                                            [
                                              F;
                                              Ty.associated_in_trait
                                                "openvm_circuit::arch::integration_api::VmAdapterChip"
                                                []
                                                [ F ]
                                                A
                                                "Interface"
                                            ]
                                            M_
                                            "Record"
                                        ]
                                    ],
                                  M.get_trait_method (|
                                    "core::ops::try_trait::Try",
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.tuple
                                          [
                                            Ty.apply
                                              (Ty.path
                                                "openvm_circuit::arch::integration_api::AdapterRuntimeContext")
                                              []
                                              [
                                                F;
                                                Ty.associated_in_trait
                                                  "openvm_circuit::arch::integration_api::VmAdapterChip"
                                                  []
                                                  [ F ]
                                                  A
                                                  "Interface"
                                              ];
                                            Ty.associated_in_trait
                                              "openvm_circuit::arch::integration_api::VmCoreChip"
                                              []
                                              [
                                                F;
                                                Ty.associated_in_trait
                                                  "openvm_circuit::arch::integration_api::VmAdapterChip"
                                                  []
                                                  [ F ]
                                                  A
                                                  "Interface"
                                              ]
                                              M_
                                              "Record"
                                          ];
                                        Ty.path "openvm_circuit::arch::execution::ExecutionError"
                                      ],
                                    [],
                                    [],
                                    "branch",
                                    [],
                                    []
                                  |),
                                  [
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        []
                                        [
                                          Ty.tuple
                                            [
                                              Ty.apply
                                                (Ty.path
                                                  "openvm_circuit::arch::integration_api::AdapterRuntimeContext")
                                                []
                                                [
                                                  F;
                                                  Ty.associated_in_trait
                                                    "openvm_circuit::arch::integration_api::VmAdapterChip"
                                                    []
                                                    [ F ]
                                                    A
                                                    "Interface"
                                                ];
                                              Ty.associated_in_trait
                                                "openvm_circuit::arch::integration_api::VmCoreChip"
                                                []
                                                [
                                                  F;
                                                  Ty.associated_in_trait
                                                    "openvm_circuit::arch::integration_api::VmAdapterChip"
                                                    []
                                                    [ F ]
                                                    A
                                                    "Interface"
                                                ]
                                                M_
                                                "Record"
                                            ];
                                          Ty.path "openvm_circuit::arch::execution::ExecutionError"
                                        ],
                                      M.get_trait_method (|
                                        "openvm_circuit::arch::integration_api::VmCoreChip",
                                        M_,
                                        [],
                                        [
                                          F;
                                          Ty.associated_in_trait
                                            "openvm_circuit::arch::integration_api::VmAdapterChip"
                                            []
                                            [ F ]
                                            A
                                            "Interface"
                                        ],
                                        "execute_instruction",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.SubPointer.get_struct_record_field (|
                                            M.deref (| M.read (| self |) |),
                                            "openvm_circuit::arch::integration_api::VmChipWrapper",
                                            "core"
                                          |)
                                        |);
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| instruction |) |)
                                        |);
                                        M.read (|
                                          M.SubPointer.get_struct_record_field (|
                                            from_state,
                                            "openvm_circuit::arch::execution::ExecutionState",
                                            "pc"
                                          |)
                                        |);
                                        M.read (| reads |)
                                      ]
                                    |)
                                  ]
                                |)
                              |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ0_0 :=
                                      M.SubPointer.get_struct_tuple_field (|
                                        γ,
                                        "core::ops::control_flow::ControlFlow::Break",
                                        0
                                      |) in
                                    let residual :=
                                      M.copy (|
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          []
                                          [
                                            Ty.path "core::convert::Infallible";
                                            Ty.path
                                              "openvm_circuit::arch::execution::ExecutionError"
                                          ],
                                        γ0_0
                                      |) in
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path
                                                    "openvm_circuit::arch::execution::ExecutionState")
                                                  []
                                                  [ Ty.path "u32" ];
                                                Ty.path
                                                  "openvm_circuit::arch::execution::ExecutionError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path
                                                      "openvm_circuit::arch::execution::ExecutionState")
                                                    []
                                                    [ Ty.path "u32" ];
                                                  Ty.path
                                                    "openvm_circuit::arch::execution::ExecutionError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path
                                                      "openvm_circuit::arch::execution::ExecutionError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)));
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ0_0 :=
                                      M.SubPointer.get_struct_tuple_field (|
                                        γ,
                                        "core::ops::control_flow::ControlFlow::Continue",
                                        0
                                      |) in
                                    let val :=
                                      M.copy (|
                                        Ty.tuple
                                          [
                                            Ty.apply
                                              (Ty.path
                                                "openvm_circuit::arch::integration_api::AdapterRuntimeContext")
                                              []
                                              [
                                                F;
                                                Ty.associated_in_trait
                                                  "openvm_circuit::arch::integration_api::VmAdapterChip"
                                                  []
                                                  [ F ]
                                                  A
                                                  "Interface"
                                              ];
                                            Ty.associated_in_trait
                                              "openvm_circuit::arch::integration_api::VmCoreChip"
                                              []
                                              [
                                                F;
                                                Ty.associated_in_trait
                                                  "openvm_circuit::arch::integration_api::VmAdapterChip"
                                                  []
                                                  [ F ]
                                                  A
                                                  "Interface"
                                              ]
                                              M_
                                              "Record"
                                          ],
                                        γ0_0
                                      |) in
                                    M.read (| val |)))
                              ]
                            |)
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                let output :=
                                  M.copy (|
                                    Ty.apply
                                      (Ty.path
                                        "openvm_circuit::arch::integration_api::AdapterRuntimeContext")
                                      []
                                      [
                                        F;
                                        Ty.associated_in_trait
                                          "openvm_circuit::arch::integration_api::VmAdapterChip"
                                          []
                                          [ F ]
                                          A
                                          "Interface"
                                      ],
                                    γ0_0
                                  |) in
                                let core_record :=
                                  M.copy (|
                                    Ty.associated_in_trait
                                      "openvm_circuit::arch::integration_api::VmCoreChip"
                                      []
                                      [
                                        F;
                                        Ty.associated_in_trait
                                          "openvm_circuit::arch::integration_api::VmAdapterChip"
                                          []
                                          [ F ]
                                          A
                                          "Interface"
                                      ]
                                      M_
                                      "Record",
                                    γ0_1
                                  |) in
                                M.match_operator (|
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "openvm_circuit::arch::execution::ExecutionState")
                                        []
                                        [ Ty.path "u32" ];
                                      Ty.path "openvm_circuit::arch::execution::ExecutionError"
                                    ],
                                  M.alloc (|
                                    Ty.tuple
                                      [
                                        Ty.apply
                                          (Ty.path
                                            "openvm_circuit::arch::execution::ExecutionState")
                                          []
                                          [ Ty.path "u32" ];
                                        Ty.associated_in_trait
                                          "openvm_circuit::arch::integration_api::VmAdapterChip"
                                          []
                                          [ F ]
                                          A
                                          "WriteRecord"
                                      ],
                                    M.match_operator (|
                                      Ty.tuple
                                        [
                                          Ty.apply
                                            (Ty.path
                                              "openvm_circuit::arch::execution::ExecutionState")
                                            []
                                            [ Ty.path "u32" ];
                                          Ty.associated_in_trait
                                            "openvm_circuit::arch::integration_api::VmAdapterChip"
                                            []
                                            [ F ]
                                            A
                                            "WriteRecord"
                                        ],
                                      M.alloc (|
                                        Ty.apply
                                          (Ty.path "core::ops::control_flow::ControlFlow")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.path "core::convert::Infallible";
                                                Ty.path
                                                  "openvm_circuit::arch::execution::ExecutionError"
                                              ];
                                            Ty.tuple
                                              [
                                                Ty.apply
                                                  (Ty.path
                                                    "openvm_circuit::arch::execution::ExecutionState")
                                                  []
                                                  [ Ty.path "u32" ];
                                                Ty.associated_in_trait
                                                  "openvm_circuit::arch::integration_api::VmAdapterChip"
                                                  []
                                                  [ F ]
                                                  A
                                                  "WriteRecord"
                                              ]
                                          ],
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "core::ops::control_flow::ControlFlow")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.path "core::convert::Infallible";
                                                  Ty.path
                                                    "openvm_circuit::arch::execution::ExecutionError"
                                                ];
                                              Ty.tuple
                                                [
                                                  Ty.apply
                                                    (Ty.path
                                                      "openvm_circuit::arch::execution::ExecutionState")
                                                    []
                                                    [ Ty.path "u32" ];
                                                  Ty.associated_in_trait
                                                    "openvm_circuit::arch::integration_api::VmAdapterChip"
                                                    []
                                                    [ F ]
                                                    A
                                                    "WriteRecord"
                                                ]
                                            ],
                                          M.get_trait_method (|
                                            "core::ops::try_trait::Try",
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.tuple
                                                  [
                                                    Ty.apply
                                                      (Ty.path
                                                        "openvm_circuit::arch::execution::ExecutionState")
                                                      []
                                                      [ Ty.path "u32" ];
                                                    Ty.associated_in_trait
                                                      "openvm_circuit::arch::integration_api::VmAdapterChip"
                                                      []
                                                      [ F ]
                                                      A
                                                      "WriteRecord"
                                                  ];
                                                Ty.path
                                                  "openvm_circuit::arch::execution::ExecutionError"
                                              ],
                                            [],
                                            [],
                                            "branch",
                                            [],
                                            []
                                          |),
                                          [
                                            M.call_closure (|
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.tuple
                                                    [
                                                      Ty.apply
                                                        (Ty.path
                                                          "openvm_circuit::arch::execution::ExecutionState")
                                                        []
                                                        [ Ty.path "u32" ];
                                                      Ty.associated_in_trait
                                                        "openvm_circuit::arch::integration_api::VmAdapterChip"
                                                        []
                                                        [ F ]
                                                        A
                                                        "WriteRecord"
                                                    ];
                                                  Ty.path
                                                    "openvm_circuit::arch::execution::ExecutionError"
                                                ],
                                              M.get_trait_method (|
                                                "openvm_circuit::arch::integration_api::VmAdapterChip",
                                                A,
                                                [],
                                                [ F ],
                                                "postprocess",
                                                [],
                                                []
                                              |),
                                              [
                                                M.borrow (|
                                                  Pointer.Kind.MutRef,
                                                  M.SubPointer.get_struct_record_field (|
                                                    M.deref (| M.read (| self |) |),
                                                    "openvm_circuit::arch::integration_api::VmChipWrapper",
                                                    "adapter"
                                                  |)
                                                |);
                                                M.borrow (|
                                                  Pointer.Kind.MutRef,
                                                  M.deref (| M.read (| memory |) |)
                                                |);
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (| M.read (| instruction |) |)
                                                |);
                                                M.read (| from_state |);
                                                M.read (| output |);
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (|
                                                    M.borrow (| Pointer.Kind.Ref, read_record |)
                                                  |)
                                                |)
                                              ]
                                            |)
                                          ]
                                        |)
                                      |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ,
                                                "core::ops::control_flow::ControlFlow::Break",
                                                0
                                              |) in
                                            let residual :=
                                              M.copy (|
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path
                                                      "openvm_circuit::arch::execution::ExecutionError"
                                                  ],
                                                γ0_0
                                              |) in
                                            M.never_to_any (|
                                              M.read (|
                                                M.return_ (|
                                                  M.call_closure (|
                                                    Ty.apply
                                                      (Ty.path "core::result::Result")
                                                      []
                                                      [
                                                        Ty.apply
                                                          (Ty.path
                                                            "openvm_circuit::arch::execution::ExecutionState")
                                                          []
                                                          [ Ty.path "u32" ];
                                                        Ty.path
                                                          "openvm_circuit::arch::execution::ExecutionError"
                                                      ],
                                                    M.get_trait_method (|
                                                      "core::ops::try_trait::FromResidual",
                                                      Ty.apply
                                                        (Ty.path "core::result::Result")
                                                        []
                                                        [
                                                          Ty.apply
                                                            (Ty.path
                                                              "openvm_circuit::arch::execution::ExecutionState")
                                                            []
                                                            [ Ty.path "u32" ];
                                                          Ty.path
                                                            "openvm_circuit::arch::execution::ExecutionError"
                                                        ],
                                                      [],
                                                      [
                                                        Ty.apply
                                                          (Ty.path "core::result::Result")
                                                          []
                                                          [
                                                            Ty.path "core::convert::Infallible";
                                                            Ty.path
                                                              "openvm_circuit::arch::execution::ExecutionError"
                                                          ]
                                                      ],
                                                      "from_residual",
                                                      [],
                                                      []
                                                    |),
                                                    [ M.read (| residual |) ]
                                                  |)
                                                |)
                                              |)
                                            |)));
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 :=
                                              M.SubPointer.get_struct_tuple_field (|
                                                γ,
                                                "core::ops::control_flow::ControlFlow::Continue",
                                                0
                                              |) in
                                            let val :=
                                              M.copy (|
                                                Ty.tuple
                                                  [
                                                    Ty.apply
                                                      (Ty.path
                                                        "openvm_circuit::arch::execution::ExecutionState")
                                                      []
                                                      [ Ty.path "u32" ];
                                                    Ty.associated_in_trait
                                                      "openvm_circuit::arch::integration_api::VmAdapterChip"
                                                      []
                                                      [ F ]
                                                      A
                                                      "WriteRecord"
                                                  ],
                                                γ0_0
                                              |) in
                                            M.read (| val |)))
                                      ]
                                    |)
                                  |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                        let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                        let to_state :=
                                          M.copy (|
                                            Ty.apply
                                              (Ty.path
                                                "openvm_circuit::arch::execution::ExecutionState")
                                              []
                                              [ Ty.path "u32" ],
                                            γ0_0
                                          |) in
                                        let write_record :=
                                          M.copy (|
                                            Ty.associated_in_trait
                                              "openvm_circuit::arch::integration_api::VmAdapterChip"
                                              []
                                              [ F ]
                                              A
                                              "WriteRecord",
                                            γ0_1
                                          |) in
                                        M.read (|
                                          let~ _ : Ty.tuple [] :=
                                            M.call_closure (|
                                              Ty.tuple [],
                                              M.get_associated_function (|
                                                Ty.apply
                                                  (Ty.path "alloc::vec::Vec")
                                                  []
                                                  [
                                                    Ty.tuple
                                                      [
                                                        Ty.associated_in_trait
                                                          "openvm_circuit::arch::integration_api::VmAdapterChip"
                                                          []
                                                          [ F ]
                                                          A
                                                          "ReadRecord";
                                                        Ty.associated_in_trait
                                                          "openvm_circuit::arch::integration_api::VmAdapterChip"
                                                          []
                                                          [ F ]
                                                          A
                                                          "WriteRecord";
                                                        Ty.associated_in_trait
                                                          "openvm_circuit::arch::integration_api::VmCoreChip"
                                                          []
                                                          [
                                                            F;
                                                            Ty.associated_in_trait
                                                              "openvm_circuit::arch::integration_api::VmAdapterChip"
                                                              []
                                                              [ F ]
                                                              A
                                                              "Interface"
                                                          ]
                                                          M_
                                                          "Record"
                                                      ];
                                                    Ty.path "alloc::alloc::Global"
                                                  ],
                                                "push",
                                                [],
                                                []
                                              |),
                                              [
                                                M.borrow (|
                                                  Pointer.Kind.MutRef,
                                                  M.SubPointer.get_struct_record_field (|
                                                    M.deref (| M.read (| self |) |),
                                                    "openvm_circuit::arch::integration_api::VmChipWrapper",
                                                    "records"
                                                  |)
                                                |);
                                                Value.Tuple
                                                  [
                                                    M.read (| read_record |);
                                                    M.read (| write_record |);
                                                    M.read (| core_record |)
                                                  ]
                                              ]
                                            |) in
                                          M.alloc (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path
                                                    "openvm_circuit::arch::execution::ExecutionState")
                                                  []
                                                  [ Ty.path "u32" ];
                                                Ty.path
                                                  "openvm_circuit::arch::execution::ExecutionError"
                                              ],
                                            Value.StructTuple
                                              "core::result::Result::Ok"
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path
                                                    "openvm_circuit::arch::execution::ExecutionState")
                                                  []
                                                  [ Ty.path "u32" ];
                                                Ty.path
                                                  "openvm_circuit::arch::execution::ExecutionError"
                                              ]
                                              [ M.read (| to_state |) ]
                                          |)
                                        |)))
                                  ]
                                |)))
                          ]
                        |)))
                  ]
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn get_opcode_name(&self, opcode: usize) -> String {
              self.core.get_opcode_name(opcode)
          }
      *)
      Definition get_opcode_name
          (F A M_ : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self F A M_ in
        match ε, τ, α with
        | [], [], [ self; opcode ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path "openvm_circuit::arch::integration_api::VmChipWrapper")
                      []
                      [ F; A; M_ ]
                  ],
                self
              |) in
            let opcode := M.alloc (| Ty.path "usize", opcode |) in
            M.call_closure (|
              Ty.path "alloc::string::String",
              M.get_trait_method (|
                "openvm_circuit::arch::integration_api::VmCoreChip",
                M_,
                [],
                [
                  F;
                  Ty.associated_in_trait
                    "openvm_circuit::arch::integration_api::VmAdapterChip"
                    []
                    [ F ]
                    A
                    "Interface"
                ],
                "get_opcode_name",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "openvm_circuit::arch::integration_api::VmChipWrapper",
                    "core"
                  |)
                |);
                M.read (| opcode |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (F A M_ : Ty.t),
        M.IsTraitInstance
          "openvm_circuit::arch::execution::InstructionExecutor"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ F ]
          (Self F A M_)
          (* Instance *)
          [
            ("execute", InstanceField.Method (execute F A M_));
            ("get_opcode_name", InstanceField.Method (get_opcode_name F A M_))
          ].
    End Impl_openvm_circuit_arch_execution_InstructionExecutor_where_p3_field_field_PrimeField32_F_where_openvm_circuit_arch_integration_api_VmAdapterChip_A_F_where_core_marker_Send_A_where_core_marker_Sync_A_where_openvm_circuit_arch_integration_api_VmCoreChip_M__F_associated_in_trait_openvm_circuit_arch_integration_api_VmAdapterChip__F_A_Interface_where_core_marker_Send_M__where_core_marker_Sync_M__F_for_openvm_circuit_arch_integration_api_VmChipWrapper_F_A_M_.
    
    Module Impl_openvm_stark_backend_chip_Chip_where_openvm_stark_backend_config_StarkGenericConfig_SC_where_p3_field_field_PrimeField32_associated_in_trait_p3_commit_domain_PolynomialSpace___associated_in_trait_p3_commit_pcs_Pcs__associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenge_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenger_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Pcs_Domain_Val_where_openvm_circuit_arch_integration_api_VmAdapterChip_A_associated_in_trait_p3_commit_domain_PolynomialSpace___associated_in_trait_p3_commit_pcs_Pcs__associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenge_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenger_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Pcs_Domain_Val_where_core_marker_Send_A_where_core_marker_Sync_A_where_openvm_circuit_arch_integration_api_VmCoreChip_C_associated_in_trait_p3_commit_domain_PolynomialSpace___associated_in_trait_p3_commit_pcs_Pcs__associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenge_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenger_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Pcs_Domain_Val_associated_in_trait_openvm_circuit_arch_integration_api_VmAdapterChip__associated_in_trait_p3_commit_domain_PolynomialSpace___associated_in_trait_p3_commit_pcs_Pcs__associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenge_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenger_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Pcs_Domain_Val_A_Interface_where_core_marker_Send_C_where_core_marker_Sync_C_where_core_marker_Send_associated_in_trait_openvm_circuit_arch_integration_api_VmAdapterChip__associated_in_trait_p3_commit_domain_PolynomialSpace___associated_in_trait_p3_commit_pcs_Pcs__associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenge_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenger_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Pcs_Domain_Val_A_Air_where_core_marker_Sync_associated_in_trait_openvm_circuit_arch_integration_api_VmAdapterChip__associated_in_trait_p3_commit_domain_PolynomialSpace___associated_in_trait_p3_commit_pcs_Pcs__associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenge_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenger_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Pcs_Domain_Val_A_Air_where_openvm_circuit_arch_integration_api_VmAdapterAir_associated_in_trait_openvm_circuit_arch_integration_api_VmAdapterChip__associated_in_trait_p3_commit_domain_PolynomialSpace___associated_in_trait_p3_commit_pcs_Pcs__associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenge_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenger_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Pcs_Domain_Val_A_Air_openvm_stark_backend_air_builders_symbolic_SymbolicRapBuilder_associated_in_trait_p3_commit_domain_PolynomialSpace___associated_in_trait_p3_commit_pcs_Pcs__associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenge_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenger_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Pcs_Domain_Val_where_openvm_circuit_arch_integration_api_VmAdapterAir_associated_in_trait_openvm_circuit_arch_integration_api_VmAdapterChip__associated_in_trait_p3_commit_domain_PolynomialSpace___associated_in_trait_p3_commit_pcs_Pcs__associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenge_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenger_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Pcs_Domain_Val_A_Air_openvm_stark_backend_air_builders_debug_DebugConstraintBuilder_SC_where_core_marker_Send_associated_in_trait_openvm_circuit_arch_integration_api_VmCoreChip__associated_in_trait_p3_commit_domain_PolynomialSpace___associated_in_trait_p3_commit_pcs_Pcs__associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenge_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenger_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Pcs_Domain_Val_associated_in_trait_openvm_circuit_arch_integration_api_VmAdapterChip__associated_in_trait_p3_commit_domain_PolynomialSpace___associated_in_trait_p3_commit_pcs_Pcs__associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenge_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenger_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Pcs_Domain_Val_A_Interface_C_Air_where_core_marker_Sync_associated_in_trait_openvm_circuit_arch_integration_api_VmCoreChip__associated_in_trait_p3_commit_domain_PolynomialSpace___associated_in_trait_p3_commit_pcs_Pcs__associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenge_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenger_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Pcs_Domain_Val_associated_in_trait_openvm_circuit_arch_integration_api_VmAdapterChip__associated_in_trait_p3_commit_domain_PolynomialSpace___associated_in_trait_p3_commit_pcs_Pcs__associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenge_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenger_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Pcs_Domain_Val_A_Interface_C_Air_where_openvm_circuit_arch_integration_api_VmCoreAir_associated_in_trait_openvm_circuit_arch_integration_api_VmCoreChip__associated_in_trait_p3_commit_domain_PolynomialSpace___associated_in_trait_p3_commit_pcs_Pcs__associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenge_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenger_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Pcs_Domain_Val_associated_in_trait_openvm_circuit_arch_integration_api_VmAdapterChip__associated_in_trait_p3_commit_domain_PolynomialSpace___associated_in_trait_p3_commit_pcs_Pcs__associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenge_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenger_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Pcs_Domain_Val_A_Interface_C_Air_openvm_stark_backend_air_builders_symbolic_SymbolicRapBuilder_associated_in_trait_p3_commit_domain_PolynomialSpace___associated_in_trait_p3_commit_pcs_Pcs__associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenge_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenger_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Pcs_Domain_Val_associated_in_trait_openvm_circuit_arch_integration_api_VmAdapterAir__openvm_stark_backend_air_builders_symbolic_SymbolicRapBuilder_associated_in_trait_p3_commit_domain_PolynomialSpace___associated_in_trait_p3_commit_pcs_Pcs__associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenge_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenger_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Pcs_Domain_Val_associated_in_trait_openvm_circuit_arch_integration_api_VmAdapterChip__associated_in_trait_p3_commit_domain_PolynomialSpace___associated_in_trait_p3_commit_pcs_Pcs__associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenge_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenger_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Pcs_Domain_Val_A_Air_Interface_where_openvm_circuit_arch_integration_api_VmCoreAir_associated_in_trait_openvm_circuit_arch_integration_api_VmCoreChip__associated_in_trait_p3_commit_domain_PolynomialSpace___associated_in_trait_p3_commit_pcs_Pcs__associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenge_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenger_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Pcs_Domain_Val_associated_in_trait_openvm_circuit_arch_integration_api_VmAdapterChip__associated_in_trait_p3_commit_domain_PolynomialSpace___associated_in_trait_p3_commit_pcs_Pcs__associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenge_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenger_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Pcs_Domain_Val_A_Interface_C_Air_openvm_stark_backend_air_builders_debug_DebugConstraintBuilder_SC_associated_in_trait_openvm_circuit_arch_integration_api_VmAdapterAir__openvm_stark_backend_air_builders_debug_DebugConstraintBuilder_SC_associated_in_trait_openvm_circuit_arch_integration_api_VmAdapterChip__associated_in_trait_p3_commit_domain_PolynomialSpace___associated_in_trait_p3_commit_pcs_Pcs__associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenge_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenger_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Pcs_Domain_Val_A_Air_Interface_SC_for_openvm_circuit_arch_integration_api_VmChipWrapper_associated_in_trait_p3_commit_domain_PolynomialSpace___associated_in_trait_p3_commit_pcs_Pcs__associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenge_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenger_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Pcs_Domain_Val_A_C.
      Definition Self (SC A C : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "openvm_circuit::arch::integration_api::VmChipWrapper")
          []
          [
            Ty.associated_in_trait
              "p3_commit::domain::PolynomialSpace"
              []
              []
              (Ty.associated_in_trait
                "p3_commit::pcs::Pcs"
                []
                [
                  Ty.associated_in_trait
                    "openvm_stark_backend::config::StarkGenericConfig"
                    []
                    []
                    SC
                    "Challenge";
                  Ty.associated_in_trait
                    "openvm_stark_backend::config::StarkGenericConfig"
                    []
                    []
                    SC
                    "Challenger"
                ]
                (Ty.associated_in_trait
                  "openvm_stark_backend::config::StarkGenericConfig"
                  []
                  []
                  SC
                  "Pcs")
                "Domain")
              "Val";
            A;
            C
          ].
      
      (*
          fn air(&self) -> AirRef<SC> {
              let air: VmAirWrapper<A::Air, C::Air> = VmAirWrapper {
                  adapter: self.adapter.air().clone(),
                  core: self.core.air().clone(),
              };
              Arc::new(air)
          }
      *)
      Definition air (SC A C : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self SC A C in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path "openvm_circuit::arch::integration_api::VmChipWrapper")
                      []
                      [
                        Ty.associated_in_trait
                          "p3_commit::domain::PolynomialSpace"
                          []
                          []
                          (Ty.associated_in_trait
                            "p3_commit::pcs::Pcs"
                            []
                            [
                              Ty.associated_in_trait
                                "openvm_stark_backend::config::StarkGenericConfig"
                                []
                                []
                                SC
                                "Challenge";
                              Ty.associated_in_trait
                                "openvm_stark_backend::config::StarkGenericConfig"
                                []
                                []
                                SC
                                "Challenger"
                            ]
                            (Ty.associated_in_trait
                              "openvm_stark_backend::config::StarkGenericConfig"
                              []
                              []
                              SC
                              "Pcs")
                            "Domain")
                          "Val";
                        A;
                        C
                      ]
                  ],
                self
              |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "alloc::sync::Arc")
                []
                [
                  Ty.dyn [ ("openvm_stark_backend::rap::AnyRap::Trait", []) ];
                  Ty.path "alloc::alloc::Global"
                ],
              M.pointer_coercion
                M.PointerCoercion.Unsize
                (Ty.apply
                  (Ty.path "alloc::sync::Arc")
                  []
                  [
                    Ty.dyn [ ("openvm_stark_backend::rap::AnyRap::Trait", []) ];
                    Ty.path "alloc::alloc::Global"
                  ])
                (Ty.apply
                  (Ty.path "alloc::sync::Arc")
                  []
                  [
                    Ty.dyn [ ("openvm_stark_backend::rap::AnyRap::Trait", []) ];
                    Ty.path "alloc::alloc::Global"
                  ]),
              [
                M.read (|
                  let~ air :
                      Ty.apply
                        (Ty.path "openvm_circuit::arch::integration_api::VmAirWrapper")
                        []
                        [
                          Ty.associated_in_trait
                            "openvm_circuit::arch::integration_api::VmAdapterChip"
                            []
                            [
                              Ty.associated_in_trait
                                "p3_commit::domain::PolynomialSpace"
                                []
                                []
                                (Ty.associated_in_trait
                                  "p3_commit::pcs::Pcs"
                                  []
                                  [
                                    Ty.associated_in_trait
                                      "openvm_stark_backend::config::StarkGenericConfig"
                                      []
                                      []
                                      SC
                                      "Challenge";
                                    Ty.associated_in_trait
                                      "openvm_stark_backend::config::StarkGenericConfig"
                                      []
                                      []
                                      SC
                                      "Challenger"
                                  ]
                                  (Ty.associated_in_trait
                                    "openvm_stark_backend::config::StarkGenericConfig"
                                    []
                                    []
                                    SC
                                    "Pcs")
                                  "Domain")
                                "Val"
                            ]
                            A
                            "Air";
                          Ty.associated_in_trait
                            "openvm_circuit::arch::integration_api::VmCoreChip"
                            []
                            [
                              Ty.associated_in_trait
                                "p3_commit::domain::PolynomialSpace"
                                []
                                []
                                (Ty.associated_in_trait
                                  "p3_commit::pcs::Pcs"
                                  []
                                  [
                                    Ty.associated_in_trait
                                      "openvm_stark_backend::config::StarkGenericConfig"
                                      []
                                      []
                                      SC
                                      "Challenge";
                                    Ty.associated_in_trait
                                      "openvm_stark_backend::config::StarkGenericConfig"
                                      []
                                      []
                                      SC
                                      "Challenger"
                                  ]
                                  (Ty.associated_in_trait
                                    "openvm_stark_backend::config::StarkGenericConfig"
                                    []
                                    []
                                    SC
                                    "Pcs")
                                  "Domain")
                                "Val";
                              Ty.associated_in_trait
                                "openvm_circuit::arch::integration_api::VmAdapterChip"
                                []
                                [
                                  Ty.associated_in_trait
                                    "p3_commit::domain::PolynomialSpace"
                                    []
                                    []
                                    (Ty.associated_in_trait
                                      "p3_commit::pcs::Pcs"
                                      []
                                      [
                                        Ty.associated_in_trait
                                          "openvm_stark_backend::config::StarkGenericConfig"
                                          []
                                          []
                                          SC
                                          "Challenge";
                                        Ty.associated_in_trait
                                          "openvm_stark_backend::config::StarkGenericConfig"
                                          []
                                          []
                                          SC
                                          "Challenger"
                                      ]
                                      (Ty.associated_in_trait
                                        "openvm_stark_backend::config::StarkGenericConfig"
                                        []
                                        []
                                        SC
                                        "Pcs")
                                      "Domain")
                                    "Val"
                                ]
                                A
                                "Interface"
                            ]
                            C
                            "Air"
                        ] :=
                    Value.mkStructRecord
                      "openvm_circuit::arch::integration_api::VmAirWrapper"
                      []
                      [
                        Ty.associated_in_trait
                          "openvm_circuit::arch::integration_api::VmAdapterChip"
                          []
                          [
                            Ty.associated_in_trait
                              "p3_commit::domain::PolynomialSpace"
                              []
                              []
                              (Ty.associated_in_trait
                                "p3_commit::pcs::Pcs"
                                []
                                [
                                  Ty.associated_in_trait
                                    "openvm_stark_backend::config::StarkGenericConfig"
                                    []
                                    []
                                    SC
                                    "Challenge";
                                  Ty.associated_in_trait
                                    "openvm_stark_backend::config::StarkGenericConfig"
                                    []
                                    []
                                    SC
                                    "Challenger"
                                ]
                                (Ty.associated_in_trait
                                  "openvm_stark_backend::config::StarkGenericConfig"
                                  []
                                  []
                                  SC
                                  "Pcs")
                                "Domain")
                              "Val"
                          ]
                          A
                          "Air";
                        Ty.associated_in_trait
                          "openvm_circuit::arch::integration_api::VmCoreChip"
                          []
                          [
                            Ty.associated_in_trait
                              "p3_commit::domain::PolynomialSpace"
                              []
                              []
                              (Ty.associated_in_trait
                                "p3_commit::pcs::Pcs"
                                []
                                [
                                  Ty.associated_in_trait
                                    "openvm_stark_backend::config::StarkGenericConfig"
                                    []
                                    []
                                    SC
                                    "Challenge";
                                  Ty.associated_in_trait
                                    "openvm_stark_backend::config::StarkGenericConfig"
                                    []
                                    []
                                    SC
                                    "Challenger"
                                ]
                                (Ty.associated_in_trait
                                  "openvm_stark_backend::config::StarkGenericConfig"
                                  []
                                  []
                                  SC
                                  "Pcs")
                                "Domain")
                              "Val";
                            Ty.associated_in_trait
                              "openvm_circuit::arch::integration_api::VmAdapterChip"
                              []
                              [
                                Ty.associated_in_trait
                                  "p3_commit::domain::PolynomialSpace"
                                  []
                                  []
                                  (Ty.associated_in_trait
                                    "p3_commit::pcs::Pcs"
                                    []
                                    [
                                      Ty.associated_in_trait
                                        "openvm_stark_backend::config::StarkGenericConfig"
                                        []
                                        []
                                        SC
                                        "Challenge";
                                      Ty.associated_in_trait
                                        "openvm_stark_backend::config::StarkGenericConfig"
                                        []
                                        []
                                        SC
                                        "Challenger"
                                    ]
                                    (Ty.associated_in_trait
                                      "openvm_stark_backend::config::StarkGenericConfig"
                                      []
                                      []
                                      SC
                                      "Pcs")
                                    "Domain")
                                  "Val"
                              ]
                              A
                              "Interface"
                          ]
                          C
                          "Air"
                      ]
                      [
                        ("adapter",
                          M.call_closure (|
                            Ty.associated_in_trait
                              "openvm_circuit::arch::integration_api::VmAdapterChip"
                              []
                              [
                                Ty.associated_in_trait
                                  "p3_commit::domain::PolynomialSpace"
                                  []
                                  []
                                  (Ty.associated_in_trait
                                    "p3_commit::pcs::Pcs"
                                    []
                                    [
                                      Ty.associated_in_trait
                                        "openvm_stark_backend::config::StarkGenericConfig"
                                        []
                                        []
                                        SC
                                        "Challenge";
                                      Ty.associated_in_trait
                                        "openvm_stark_backend::config::StarkGenericConfig"
                                        []
                                        []
                                        SC
                                        "Challenger"
                                    ]
                                    (Ty.associated_in_trait
                                      "openvm_stark_backend::config::StarkGenericConfig"
                                      []
                                      []
                                      SC
                                      "Pcs")
                                    "Domain")
                                  "Val"
                              ]
                              A
                              "Air",
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.associated_in_trait
                                "openvm_circuit::arch::integration_api::VmAdapterChip"
                                []
                                [
                                  Ty.associated_in_trait
                                    "p3_commit::domain::PolynomialSpace"
                                    []
                                    []
                                    (Ty.associated_in_trait
                                      "p3_commit::pcs::Pcs"
                                      []
                                      [
                                        Ty.associated_in_trait
                                          "openvm_stark_backend::config::StarkGenericConfig"
                                          []
                                          []
                                          SC
                                          "Challenge";
                                        Ty.associated_in_trait
                                          "openvm_stark_backend::config::StarkGenericConfig"
                                          []
                                          []
                                          SC
                                          "Challenger"
                                      ]
                                      (Ty.associated_in_trait
                                        "openvm_stark_backend::config::StarkGenericConfig"
                                        []
                                        []
                                        SC
                                        "Pcs")
                                      "Domain")
                                    "Val"
                                ]
                                A
                                "Air",
                              [],
                              [],
                              "clone",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [
                                        Ty.associated_in_trait
                                          "openvm_circuit::arch::integration_api::VmAdapterChip"
                                          []
                                          [
                                            Ty.associated_in_trait
                                              "p3_commit::domain::PolynomialSpace"
                                              []
                                              []
                                              (Ty.associated_in_trait
                                                "p3_commit::pcs::Pcs"
                                                []
                                                [
                                                  Ty.associated_in_trait
                                                    "openvm_stark_backend::config::StarkGenericConfig"
                                                    []
                                                    []
                                                    SC
                                                    "Challenge";
                                                  Ty.associated_in_trait
                                                    "openvm_stark_backend::config::StarkGenericConfig"
                                                    []
                                                    []
                                                    SC
                                                    "Challenger"
                                                ]
                                                (Ty.associated_in_trait
                                                  "openvm_stark_backend::config::StarkGenericConfig"
                                                  []
                                                  []
                                                  SC
                                                  "Pcs")
                                                "Domain")
                                              "Val"
                                          ]
                                          A
                                          "Air"
                                      ],
                                    M.get_trait_method (|
                                      "openvm_circuit::arch::integration_api::VmAdapterChip",
                                      A,
                                      [],
                                      [
                                        Ty.associated_in_trait
                                          "p3_commit::domain::PolynomialSpace"
                                          []
                                          []
                                          (Ty.associated_in_trait
                                            "p3_commit::pcs::Pcs"
                                            []
                                            [
                                              Ty.associated_in_trait
                                                "openvm_stark_backend::config::StarkGenericConfig"
                                                []
                                                []
                                                SC
                                                "Challenge";
                                              Ty.associated_in_trait
                                                "openvm_stark_backend::config::StarkGenericConfig"
                                                []
                                                []
                                                SC
                                                "Challenger"
                                            ]
                                            (Ty.associated_in_trait
                                              "openvm_stark_backend::config::StarkGenericConfig"
                                              []
                                              []
                                              SC
                                              "Pcs")
                                            "Domain")
                                          "Val"
                                      ],
                                      "air",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.SubPointer.get_struct_record_field (|
                                          M.deref (| M.read (| self |) |),
                                          "openvm_circuit::arch::integration_api::VmChipWrapper",
                                          "adapter"
                                        |)
                                      |)
                                    ]
                                  |)
                                |)
                              |)
                            ]
                          |));
                        ("core",
                          M.call_closure (|
                            Ty.associated_in_trait
                              "openvm_circuit::arch::integration_api::VmCoreChip"
                              []
                              [
                                Ty.associated_in_trait
                                  "p3_commit::domain::PolynomialSpace"
                                  []
                                  []
                                  (Ty.associated_in_trait
                                    "p3_commit::pcs::Pcs"
                                    []
                                    [
                                      Ty.associated_in_trait
                                        "openvm_stark_backend::config::StarkGenericConfig"
                                        []
                                        []
                                        SC
                                        "Challenge";
                                      Ty.associated_in_trait
                                        "openvm_stark_backend::config::StarkGenericConfig"
                                        []
                                        []
                                        SC
                                        "Challenger"
                                    ]
                                    (Ty.associated_in_trait
                                      "openvm_stark_backend::config::StarkGenericConfig"
                                      []
                                      []
                                      SC
                                      "Pcs")
                                    "Domain")
                                  "Val";
                                Ty.associated_in_trait
                                  "openvm_circuit::arch::integration_api::VmAdapterChip"
                                  []
                                  [
                                    Ty.associated_in_trait
                                      "p3_commit::domain::PolynomialSpace"
                                      []
                                      []
                                      (Ty.associated_in_trait
                                        "p3_commit::pcs::Pcs"
                                        []
                                        [
                                          Ty.associated_in_trait
                                            "openvm_stark_backend::config::StarkGenericConfig"
                                            []
                                            []
                                            SC
                                            "Challenge";
                                          Ty.associated_in_trait
                                            "openvm_stark_backend::config::StarkGenericConfig"
                                            []
                                            []
                                            SC
                                            "Challenger"
                                        ]
                                        (Ty.associated_in_trait
                                          "openvm_stark_backend::config::StarkGenericConfig"
                                          []
                                          []
                                          SC
                                          "Pcs")
                                        "Domain")
                                      "Val"
                                  ]
                                  A
                                  "Interface"
                              ]
                              C
                              "Air",
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.associated_in_trait
                                "openvm_circuit::arch::integration_api::VmCoreChip"
                                []
                                [
                                  Ty.associated_in_trait
                                    "p3_commit::domain::PolynomialSpace"
                                    []
                                    []
                                    (Ty.associated_in_trait
                                      "p3_commit::pcs::Pcs"
                                      []
                                      [
                                        Ty.associated_in_trait
                                          "openvm_stark_backend::config::StarkGenericConfig"
                                          []
                                          []
                                          SC
                                          "Challenge";
                                        Ty.associated_in_trait
                                          "openvm_stark_backend::config::StarkGenericConfig"
                                          []
                                          []
                                          SC
                                          "Challenger"
                                      ]
                                      (Ty.associated_in_trait
                                        "openvm_stark_backend::config::StarkGenericConfig"
                                        []
                                        []
                                        SC
                                        "Pcs")
                                      "Domain")
                                    "Val";
                                  Ty.associated_in_trait
                                    "openvm_circuit::arch::integration_api::VmAdapterChip"
                                    []
                                    [
                                      Ty.associated_in_trait
                                        "p3_commit::domain::PolynomialSpace"
                                        []
                                        []
                                        (Ty.associated_in_trait
                                          "p3_commit::pcs::Pcs"
                                          []
                                          [
                                            Ty.associated_in_trait
                                              "openvm_stark_backend::config::StarkGenericConfig"
                                              []
                                              []
                                              SC
                                              "Challenge";
                                            Ty.associated_in_trait
                                              "openvm_stark_backend::config::StarkGenericConfig"
                                              []
                                              []
                                              SC
                                              "Challenger"
                                          ]
                                          (Ty.associated_in_trait
                                            "openvm_stark_backend::config::StarkGenericConfig"
                                            []
                                            []
                                            SC
                                            "Pcs")
                                          "Domain")
                                        "Val"
                                    ]
                                    A
                                    "Interface"
                                ]
                                C
                                "Air",
                              [],
                              [],
                              "clone",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [
                                        Ty.associated_in_trait
                                          "openvm_circuit::arch::integration_api::VmCoreChip"
                                          []
                                          [
                                            Ty.associated_in_trait
                                              "p3_commit::domain::PolynomialSpace"
                                              []
                                              []
                                              (Ty.associated_in_trait
                                                "p3_commit::pcs::Pcs"
                                                []
                                                [
                                                  Ty.associated_in_trait
                                                    "openvm_stark_backend::config::StarkGenericConfig"
                                                    []
                                                    []
                                                    SC
                                                    "Challenge";
                                                  Ty.associated_in_trait
                                                    "openvm_stark_backend::config::StarkGenericConfig"
                                                    []
                                                    []
                                                    SC
                                                    "Challenger"
                                                ]
                                                (Ty.associated_in_trait
                                                  "openvm_stark_backend::config::StarkGenericConfig"
                                                  []
                                                  []
                                                  SC
                                                  "Pcs")
                                                "Domain")
                                              "Val";
                                            Ty.associated_in_trait
                                              "openvm_circuit::arch::integration_api::VmAdapterChip"
                                              []
                                              [
                                                Ty.associated_in_trait
                                                  "p3_commit::domain::PolynomialSpace"
                                                  []
                                                  []
                                                  (Ty.associated_in_trait
                                                    "p3_commit::pcs::Pcs"
                                                    []
                                                    [
                                                      Ty.associated_in_trait
                                                        "openvm_stark_backend::config::StarkGenericConfig"
                                                        []
                                                        []
                                                        SC
                                                        "Challenge";
                                                      Ty.associated_in_trait
                                                        "openvm_stark_backend::config::StarkGenericConfig"
                                                        []
                                                        []
                                                        SC
                                                        "Challenger"
                                                    ]
                                                    (Ty.associated_in_trait
                                                      "openvm_stark_backend::config::StarkGenericConfig"
                                                      []
                                                      []
                                                      SC
                                                      "Pcs")
                                                    "Domain")
                                                  "Val"
                                              ]
                                              A
                                              "Interface"
                                          ]
                                          C
                                          "Air"
                                      ],
                                    M.get_trait_method (|
                                      "openvm_circuit::arch::integration_api::VmCoreChip",
                                      C,
                                      [],
                                      [
                                        Ty.associated_in_trait
                                          "p3_commit::domain::PolynomialSpace"
                                          []
                                          []
                                          (Ty.associated_in_trait
                                            "p3_commit::pcs::Pcs"
                                            []
                                            [
                                              Ty.associated_in_trait
                                                "openvm_stark_backend::config::StarkGenericConfig"
                                                []
                                                []
                                                SC
                                                "Challenge";
                                              Ty.associated_in_trait
                                                "openvm_stark_backend::config::StarkGenericConfig"
                                                []
                                                []
                                                SC
                                                "Challenger"
                                            ]
                                            (Ty.associated_in_trait
                                              "openvm_stark_backend::config::StarkGenericConfig"
                                              []
                                              []
                                              SC
                                              "Pcs")
                                            "Domain")
                                          "Val";
                                        Ty.associated_in_trait
                                          "openvm_circuit::arch::integration_api::VmAdapterChip"
                                          []
                                          [
                                            Ty.associated_in_trait
                                              "p3_commit::domain::PolynomialSpace"
                                              []
                                              []
                                              (Ty.associated_in_trait
                                                "p3_commit::pcs::Pcs"
                                                []
                                                [
                                                  Ty.associated_in_trait
                                                    "openvm_stark_backend::config::StarkGenericConfig"
                                                    []
                                                    []
                                                    SC
                                                    "Challenge";
                                                  Ty.associated_in_trait
                                                    "openvm_stark_backend::config::StarkGenericConfig"
                                                    []
                                                    []
                                                    SC
                                                    "Challenger"
                                                ]
                                                (Ty.associated_in_trait
                                                  "openvm_stark_backend::config::StarkGenericConfig"
                                                  []
                                                  []
                                                  SC
                                                  "Pcs")
                                                "Domain")
                                              "Val"
                                          ]
                                          A
                                          "Interface"
                                      ],
                                      "air",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.SubPointer.get_struct_record_field (|
                                          M.deref (| M.read (| self |) |),
                                          "openvm_circuit::arch::integration_api::VmChipWrapper",
                                          "core"
                                        |)
                                      |)
                                    ]
                                  |)
                                |)
                              |)
                            ]
                          |))
                      ] in
                  M.alloc (|
                    Ty.apply
                      (Ty.path "alloc::sync::Arc")
                      []
                      [
                        Ty.dyn [ ("openvm_stark_backend::rap::AnyRap::Trait", []) ];
                        Ty.path "alloc::alloc::Global"
                      ],
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "alloc::sync::Arc")
                        []
                        [
                          Ty.dyn [ ("openvm_stark_backend::rap::AnyRap::Trait", []) ];
                          Ty.path "alloc::alloc::Global"
                        ],
                      M.pointer_coercion
                        M.PointerCoercion.Unsize
                        (Ty.apply
                          (Ty.path "alloc::sync::Arc")
                          []
                          [
                            Ty.apply
                              (Ty.path "openvm_circuit::arch::integration_api::VmAirWrapper")
                              []
                              [
                                Ty.associated_in_trait
                                  "openvm_circuit::arch::integration_api::VmAdapterChip"
                                  []
                                  [
                                    Ty.associated_in_trait
                                      "p3_commit::domain::PolynomialSpace"
                                      []
                                      []
                                      (Ty.associated_in_trait
                                        "p3_commit::pcs::Pcs"
                                        []
                                        [
                                          Ty.associated_in_trait
                                            "openvm_stark_backend::config::StarkGenericConfig"
                                            []
                                            []
                                            SC
                                            "Challenge";
                                          Ty.associated_in_trait
                                            "openvm_stark_backend::config::StarkGenericConfig"
                                            []
                                            []
                                            SC
                                            "Challenger"
                                        ]
                                        (Ty.associated_in_trait
                                          "openvm_stark_backend::config::StarkGenericConfig"
                                          []
                                          []
                                          SC
                                          "Pcs")
                                        "Domain")
                                      "Val"
                                  ]
                                  A
                                  "Air";
                                Ty.associated_in_trait
                                  "openvm_circuit::arch::integration_api::VmCoreChip"
                                  []
                                  [
                                    Ty.associated_in_trait
                                      "p3_commit::domain::PolynomialSpace"
                                      []
                                      []
                                      (Ty.associated_in_trait
                                        "p3_commit::pcs::Pcs"
                                        []
                                        [
                                          Ty.associated_in_trait
                                            "openvm_stark_backend::config::StarkGenericConfig"
                                            []
                                            []
                                            SC
                                            "Challenge";
                                          Ty.associated_in_trait
                                            "openvm_stark_backend::config::StarkGenericConfig"
                                            []
                                            []
                                            SC
                                            "Challenger"
                                        ]
                                        (Ty.associated_in_trait
                                          "openvm_stark_backend::config::StarkGenericConfig"
                                          []
                                          []
                                          SC
                                          "Pcs")
                                        "Domain")
                                      "Val";
                                    Ty.associated_in_trait
                                      "openvm_circuit::arch::integration_api::VmAdapterChip"
                                      []
                                      [
                                        Ty.associated_in_trait
                                          "p3_commit::domain::PolynomialSpace"
                                          []
                                          []
                                          (Ty.associated_in_trait
                                            "p3_commit::pcs::Pcs"
                                            []
                                            [
                                              Ty.associated_in_trait
                                                "openvm_stark_backend::config::StarkGenericConfig"
                                                []
                                                []
                                                SC
                                                "Challenge";
                                              Ty.associated_in_trait
                                                "openvm_stark_backend::config::StarkGenericConfig"
                                                []
                                                []
                                                SC
                                                "Challenger"
                                            ]
                                            (Ty.associated_in_trait
                                              "openvm_stark_backend::config::StarkGenericConfig"
                                              []
                                              []
                                              SC
                                              "Pcs")
                                            "Domain")
                                          "Val"
                                      ]
                                      A
                                      "Interface"
                                  ]
                                  C
                                  "Air"
                              ];
                            Ty.path "alloc::alloc::Global"
                          ])
                        (Ty.apply
                          (Ty.path "alloc::sync::Arc")
                          []
                          [
                            Ty.dyn [ ("openvm_stark_backend::rap::AnyRap::Trait", []) ];
                            Ty.path "alloc::alloc::Global"
                          ]),
                      [
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "alloc::sync::Arc")
                            []
                            [
                              Ty.apply
                                (Ty.path "openvm_circuit::arch::integration_api::VmAirWrapper")
                                []
                                [
                                  Ty.associated_in_trait
                                    "openvm_circuit::arch::integration_api::VmAdapterChip"
                                    []
                                    [
                                      Ty.associated_in_trait
                                        "p3_commit::domain::PolynomialSpace"
                                        []
                                        []
                                        (Ty.associated_in_trait
                                          "p3_commit::pcs::Pcs"
                                          []
                                          [
                                            Ty.associated_in_trait
                                              "openvm_stark_backend::config::StarkGenericConfig"
                                              []
                                              []
                                              SC
                                              "Challenge";
                                            Ty.associated_in_trait
                                              "openvm_stark_backend::config::StarkGenericConfig"
                                              []
                                              []
                                              SC
                                              "Challenger"
                                          ]
                                          (Ty.associated_in_trait
                                            "openvm_stark_backend::config::StarkGenericConfig"
                                            []
                                            []
                                            SC
                                            "Pcs")
                                          "Domain")
                                        "Val"
                                    ]
                                    A
                                    "Air";
                                  Ty.associated_in_trait
                                    "openvm_circuit::arch::integration_api::VmCoreChip"
                                    []
                                    [
                                      Ty.associated_in_trait
                                        "p3_commit::domain::PolynomialSpace"
                                        []
                                        []
                                        (Ty.associated_in_trait
                                          "p3_commit::pcs::Pcs"
                                          []
                                          [
                                            Ty.associated_in_trait
                                              "openvm_stark_backend::config::StarkGenericConfig"
                                              []
                                              []
                                              SC
                                              "Challenge";
                                            Ty.associated_in_trait
                                              "openvm_stark_backend::config::StarkGenericConfig"
                                              []
                                              []
                                              SC
                                              "Challenger"
                                          ]
                                          (Ty.associated_in_trait
                                            "openvm_stark_backend::config::StarkGenericConfig"
                                            []
                                            []
                                            SC
                                            "Pcs")
                                          "Domain")
                                        "Val";
                                      Ty.associated_in_trait
                                        "openvm_circuit::arch::integration_api::VmAdapterChip"
                                        []
                                        [
                                          Ty.associated_in_trait
                                            "p3_commit::domain::PolynomialSpace"
                                            []
                                            []
                                            (Ty.associated_in_trait
                                              "p3_commit::pcs::Pcs"
                                              []
                                              [
                                                Ty.associated_in_trait
                                                  "openvm_stark_backend::config::StarkGenericConfig"
                                                  []
                                                  []
                                                  SC
                                                  "Challenge";
                                                Ty.associated_in_trait
                                                  "openvm_stark_backend::config::StarkGenericConfig"
                                                  []
                                                  []
                                                  SC
                                                  "Challenger"
                                              ]
                                              (Ty.associated_in_trait
                                                "openvm_stark_backend::config::StarkGenericConfig"
                                                []
                                                []
                                                SC
                                                "Pcs")
                                              "Domain")
                                            "Val"
                                        ]
                                        A
                                        "Interface"
                                    ]
                                    C
                                    "Air"
                                ];
                              Ty.path "alloc::alloc::Global"
                            ],
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloc::sync::Arc")
                              []
                              [
                                Ty.apply
                                  (Ty.path "openvm_circuit::arch::integration_api::VmAirWrapper")
                                  []
                                  [
                                    Ty.associated_in_trait
                                      "openvm_circuit::arch::integration_api::VmAdapterChip"
                                      []
                                      [
                                        Ty.associated_in_trait
                                          "p3_commit::domain::PolynomialSpace"
                                          []
                                          []
                                          (Ty.associated_in_trait
                                            "p3_commit::pcs::Pcs"
                                            []
                                            [
                                              Ty.associated_in_trait
                                                "openvm_stark_backend::config::StarkGenericConfig"
                                                []
                                                []
                                                SC
                                                "Challenge";
                                              Ty.associated_in_trait
                                                "openvm_stark_backend::config::StarkGenericConfig"
                                                []
                                                []
                                                SC
                                                "Challenger"
                                            ]
                                            (Ty.associated_in_trait
                                              "openvm_stark_backend::config::StarkGenericConfig"
                                              []
                                              []
                                              SC
                                              "Pcs")
                                            "Domain")
                                          "Val"
                                      ]
                                      A
                                      "Air";
                                    Ty.associated_in_trait
                                      "openvm_circuit::arch::integration_api::VmCoreChip"
                                      []
                                      [
                                        Ty.associated_in_trait
                                          "p3_commit::domain::PolynomialSpace"
                                          []
                                          []
                                          (Ty.associated_in_trait
                                            "p3_commit::pcs::Pcs"
                                            []
                                            [
                                              Ty.associated_in_trait
                                                "openvm_stark_backend::config::StarkGenericConfig"
                                                []
                                                []
                                                SC
                                                "Challenge";
                                              Ty.associated_in_trait
                                                "openvm_stark_backend::config::StarkGenericConfig"
                                                []
                                                []
                                                SC
                                                "Challenger"
                                            ]
                                            (Ty.associated_in_trait
                                              "openvm_stark_backend::config::StarkGenericConfig"
                                              []
                                              []
                                              SC
                                              "Pcs")
                                            "Domain")
                                          "Val";
                                        Ty.associated_in_trait
                                          "openvm_circuit::arch::integration_api::VmAdapterChip"
                                          []
                                          [
                                            Ty.associated_in_trait
                                              "p3_commit::domain::PolynomialSpace"
                                              []
                                              []
                                              (Ty.associated_in_trait
                                                "p3_commit::pcs::Pcs"
                                                []
                                                [
                                                  Ty.associated_in_trait
                                                    "openvm_stark_backend::config::StarkGenericConfig"
                                                    []
                                                    []
                                                    SC
                                                    "Challenge";
                                                  Ty.associated_in_trait
                                                    "openvm_stark_backend::config::StarkGenericConfig"
                                                    []
                                                    []
                                                    SC
                                                    "Challenger"
                                                ]
                                                (Ty.associated_in_trait
                                                  "openvm_stark_backend::config::StarkGenericConfig"
                                                  []
                                                  []
                                                  SC
                                                  "Pcs")
                                                "Domain")
                                              "Val"
                                          ]
                                          A
                                          "Interface"
                                      ]
                                      C
                                      "Air"
                                  ];
                                Ty.path "alloc::alloc::Global"
                              ],
                            "new",
                            [],
                            []
                          |),
                          [ M.read (| air |) ]
                        |)
                      ]
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn generate_air_proof_input(self) -> AirProofInput<SC> {
              let num_records = self.records.len();
              let height = next_power_of_two_or_zero(num_records);
              let core_width = self.core.air().width();
              let adapter_width = self.adapter.air().width();
              let width = core_width + adapter_width;
              let mut values = Val::<SC>::zero_vec(height * width);
      
              let memory = self.offline_memory.lock().unwrap();
      
              // This zip only goes through records.
              // The padding rows between records.len()..height are filled with zeros.
              values
                  .par_chunks_mut(width)
                  .zip(self.records.into_par_iter())
                  .for_each(|(row_slice, record)| {
                      let (adapter_row, core_row) = row_slice.split_at_mut(adapter_width);
                      self.adapter
                          .generate_trace_row(adapter_row, record.0, record.1, &memory);
                      self.core.generate_trace_row(core_row, record.2);
                  });
      
              let mut trace = RowMajorMatrix::new(values, width);
              self.core.finalize(&mut trace, num_records);
      
              AirProofInput::simple(trace, self.core.generate_public_values())
          }
      *)
      Definition generate_air_proof_input
          (SC A C : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self SC A C in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "openvm_circuit::arch::integration_api::VmChipWrapper")
                  []
                  [
                    Ty.associated_in_trait
                      "p3_commit::domain::PolynomialSpace"
                      []
                      []
                      (Ty.associated_in_trait
                        "p3_commit::pcs::Pcs"
                        []
                        [
                          Ty.associated_in_trait
                            "openvm_stark_backend::config::StarkGenericConfig"
                            []
                            []
                            SC
                            "Challenge";
                          Ty.associated_in_trait
                            "openvm_stark_backend::config::StarkGenericConfig"
                            []
                            []
                            SC
                            "Challenger"
                        ]
                        (Ty.associated_in_trait
                          "openvm_stark_backend::config::StarkGenericConfig"
                          []
                          []
                          SC
                          "Pcs")
                        "Domain")
                      "Val";
                    A;
                    C
                  ],
                self
              |) in
            M.read (|
              let~ num_records : Ty.path "usize" :=
                M.call_closure (|
                  Ty.path "usize",
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      []
                      [
                        Ty.tuple
                          [
                            Ty.associated_in_trait
                              "openvm_circuit::arch::integration_api::VmAdapterChip"
                              []
                              [
                                Ty.associated_in_trait
                                  "p3_commit::domain::PolynomialSpace"
                                  []
                                  []
                                  (Ty.associated_in_trait
                                    "p3_commit::pcs::Pcs"
                                    []
                                    [
                                      Ty.associated_in_trait
                                        "openvm_stark_backend::config::StarkGenericConfig"
                                        []
                                        []
                                        SC
                                        "Challenge";
                                      Ty.associated_in_trait
                                        "openvm_stark_backend::config::StarkGenericConfig"
                                        []
                                        []
                                        SC
                                        "Challenger"
                                    ]
                                    (Ty.associated_in_trait
                                      "openvm_stark_backend::config::StarkGenericConfig"
                                      []
                                      []
                                      SC
                                      "Pcs")
                                    "Domain")
                                  "Val"
                              ]
                              A
                              "ReadRecord";
                            Ty.associated_in_trait
                              "openvm_circuit::arch::integration_api::VmAdapterChip"
                              []
                              [
                                Ty.associated_in_trait
                                  "p3_commit::domain::PolynomialSpace"
                                  []
                                  []
                                  (Ty.associated_in_trait
                                    "p3_commit::pcs::Pcs"
                                    []
                                    [
                                      Ty.associated_in_trait
                                        "openvm_stark_backend::config::StarkGenericConfig"
                                        []
                                        []
                                        SC
                                        "Challenge";
                                      Ty.associated_in_trait
                                        "openvm_stark_backend::config::StarkGenericConfig"
                                        []
                                        []
                                        SC
                                        "Challenger"
                                    ]
                                    (Ty.associated_in_trait
                                      "openvm_stark_backend::config::StarkGenericConfig"
                                      []
                                      []
                                      SC
                                      "Pcs")
                                    "Domain")
                                  "Val"
                              ]
                              A
                              "WriteRecord";
                            Ty.associated_in_trait
                              "openvm_circuit::arch::integration_api::VmCoreChip"
                              []
                              [
                                Ty.associated_in_trait
                                  "p3_commit::domain::PolynomialSpace"
                                  []
                                  []
                                  (Ty.associated_in_trait
                                    "p3_commit::pcs::Pcs"
                                    []
                                    [
                                      Ty.associated_in_trait
                                        "openvm_stark_backend::config::StarkGenericConfig"
                                        []
                                        []
                                        SC
                                        "Challenge";
                                      Ty.associated_in_trait
                                        "openvm_stark_backend::config::StarkGenericConfig"
                                        []
                                        []
                                        SC
                                        "Challenger"
                                    ]
                                    (Ty.associated_in_trait
                                      "openvm_stark_backend::config::StarkGenericConfig"
                                      []
                                      []
                                      SC
                                      "Pcs")
                                    "Domain")
                                  "Val";
                                Ty.associated_in_trait
                                  "openvm_circuit::arch::integration_api::VmAdapterChip"
                                  []
                                  [
                                    Ty.associated_in_trait
                                      "p3_commit::domain::PolynomialSpace"
                                      []
                                      []
                                      (Ty.associated_in_trait
                                        "p3_commit::pcs::Pcs"
                                        []
                                        [
                                          Ty.associated_in_trait
                                            "openvm_stark_backend::config::StarkGenericConfig"
                                            []
                                            []
                                            SC
                                            "Challenge";
                                          Ty.associated_in_trait
                                            "openvm_stark_backend::config::StarkGenericConfig"
                                            []
                                            []
                                            SC
                                            "Challenger"
                                        ]
                                        (Ty.associated_in_trait
                                          "openvm_stark_backend::config::StarkGenericConfig"
                                          []
                                          []
                                          SC
                                          "Pcs")
                                        "Domain")
                                      "Val"
                                  ]
                                  A
                                  "Interface"
                              ]
                              C
                              "Record"
                          ];
                        Ty.path "alloc::alloc::Global"
                      ],
                    "len",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        self,
                        "openvm_circuit::arch::integration_api::VmChipWrapper",
                        "records"
                      |)
                    |)
                  ]
                |) in
              let~ height : Ty.path "usize" :=
                M.call_closure (|
                  Ty.path "usize",
                  M.get_function (|
                    "openvm_circuit_primitives::utils::next_power_of_two_or_zero",
                    [],
                    []
                  |),
                  [ M.read (| num_records |) ]
                |) in
              let~ core_width : Ty.path "usize" :=
                M.call_closure (|
                  Ty.path "usize",
                  M.get_trait_method (|
                    "p3_air::air::BaseAir",
                    Ty.associated_in_trait
                      "openvm_circuit::arch::integration_api::VmCoreChip"
                      []
                      [
                        Ty.associated_in_trait
                          "p3_commit::domain::PolynomialSpace"
                          []
                          []
                          (Ty.associated_in_trait
                            "p3_commit::pcs::Pcs"
                            []
                            [
                              Ty.associated_in_trait
                                "openvm_stark_backend::config::StarkGenericConfig"
                                []
                                []
                                SC
                                "Challenge";
                              Ty.associated_in_trait
                                "openvm_stark_backend::config::StarkGenericConfig"
                                []
                                []
                                SC
                                "Challenger"
                            ]
                            (Ty.associated_in_trait
                              "openvm_stark_backend::config::StarkGenericConfig"
                              []
                              []
                              SC
                              "Pcs")
                            "Domain")
                          "Val";
                        Ty.associated_in_trait
                          "openvm_circuit::arch::integration_api::VmAdapterChip"
                          []
                          [
                            Ty.associated_in_trait
                              "p3_commit::domain::PolynomialSpace"
                              []
                              []
                              (Ty.associated_in_trait
                                "p3_commit::pcs::Pcs"
                                []
                                [
                                  Ty.associated_in_trait
                                    "openvm_stark_backend::config::StarkGenericConfig"
                                    []
                                    []
                                    SC
                                    "Challenge";
                                  Ty.associated_in_trait
                                    "openvm_stark_backend::config::StarkGenericConfig"
                                    []
                                    []
                                    SC
                                    "Challenger"
                                ]
                                (Ty.associated_in_trait
                                  "openvm_stark_backend::config::StarkGenericConfig"
                                  []
                                  []
                                  SC
                                  "Pcs")
                                "Domain")
                              "Val"
                          ]
                          A
                          "Interface"
                      ]
                      C
                      "Air",
                    [],
                    [
                      Ty.associated_in_trait
                        "p3_commit::domain::PolynomialSpace"
                        []
                        []
                        (Ty.associated_in_trait
                          "p3_commit::pcs::Pcs"
                          []
                          [
                            Ty.associated_in_trait
                              "openvm_stark_backend::config::StarkGenericConfig"
                              []
                              []
                              SC
                              "Challenge";
                            Ty.associated_in_trait
                              "openvm_stark_backend::config::StarkGenericConfig"
                              []
                              []
                              SC
                              "Challenger"
                          ]
                          (Ty.associated_in_trait
                            "openvm_stark_backend::config::StarkGenericConfig"
                            []
                            []
                            SC
                            "Pcs")
                          "Domain")
                        "Val"
                    ],
                    "width",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "&")
                            []
                            [
                              Ty.associated_in_trait
                                "openvm_circuit::arch::integration_api::VmCoreChip"
                                []
                                [
                                  Ty.associated_in_trait
                                    "p3_commit::domain::PolynomialSpace"
                                    []
                                    []
                                    (Ty.associated_in_trait
                                      "p3_commit::pcs::Pcs"
                                      []
                                      [
                                        Ty.associated_in_trait
                                          "openvm_stark_backend::config::StarkGenericConfig"
                                          []
                                          []
                                          SC
                                          "Challenge";
                                        Ty.associated_in_trait
                                          "openvm_stark_backend::config::StarkGenericConfig"
                                          []
                                          []
                                          SC
                                          "Challenger"
                                      ]
                                      (Ty.associated_in_trait
                                        "openvm_stark_backend::config::StarkGenericConfig"
                                        []
                                        []
                                        SC
                                        "Pcs")
                                      "Domain")
                                    "Val";
                                  Ty.associated_in_trait
                                    "openvm_circuit::arch::integration_api::VmAdapterChip"
                                    []
                                    [
                                      Ty.associated_in_trait
                                        "p3_commit::domain::PolynomialSpace"
                                        []
                                        []
                                        (Ty.associated_in_trait
                                          "p3_commit::pcs::Pcs"
                                          []
                                          [
                                            Ty.associated_in_trait
                                              "openvm_stark_backend::config::StarkGenericConfig"
                                              []
                                              []
                                              SC
                                              "Challenge";
                                            Ty.associated_in_trait
                                              "openvm_stark_backend::config::StarkGenericConfig"
                                              []
                                              []
                                              SC
                                              "Challenger"
                                          ]
                                          (Ty.associated_in_trait
                                            "openvm_stark_backend::config::StarkGenericConfig"
                                            []
                                            []
                                            SC
                                            "Pcs")
                                          "Domain")
                                        "Val"
                                    ]
                                    A
                                    "Interface"
                                ]
                                C
                                "Air"
                            ],
                          M.get_trait_method (|
                            "openvm_circuit::arch::integration_api::VmCoreChip",
                            C,
                            [],
                            [
                              Ty.associated_in_trait
                                "p3_commit::domain::PolynomialSpace"
                                []
                                []
                                (Ty.associated_in_trait
                                  "p3_commit::pcs::Pcs"
                                  []
                                  [
                                    Ty.associated_in_trait
                                      "openvm_stark_backend::config::StarkGenericConfig"
                                      []
                                      []
                                      SC
                                      "Challenge";
                                    Ty.associated_in_trait
                                      "openvm_stark_backend::config::StarkGenericConfig"
                                      []
                                      []
                                      SC
                                      "Challenger"
                                  ]
                                  (Ty.associated_in_trait
                                    "openvm_stark_backend::config::StarkGenericConfig"
                                    []
                                    []
                                    SC
                                    "Pcs")
                                  "Domain")
                                "Val";
                              Ty.associated_in_trait
                                "openvm_circuit::arch::integration_api::VmAdapterChip"
                                []
                                [
                                  Ty.associated_in_trait
                                    "p3_commit::domain::PolynomialSpace"
                                    []
                                    []
                                    (Ty.associated_in_trait
                                      "p3_commit::pcs::Pcs"
                                      []
                                      [
                                        Ty.associated_in_trait
                                          "openvm_stark_backend::config::StarkGenericConfig"
                                          []
                                          []
                                          SC
                                          "Challenge";
                                        Ty.associated_in_trait
                                          "openvm_stark_backend::config::StarkGenericConfig"
                                          []
                                          []
                                          SC
                                          "Challenger"
                                      ]
                                      (Ty.associated_in_trait
                                        "openvm_stark_backend::config::StarkGenericConfig"
                                        []
                                        []
                                        SC
                                        "Pcs")
                                      "Domain")
                                    "Val"
                                ]
                                A
                                "Interface"
                            ],
                            "air",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.SubPointer.get_struct_record_field (|
                                self,
                                "openvm_circuit::arch::integration_api::VmChipWrapper",
                                "core"
                              |)
                            |)
                          ]
                        |)
                      |)
                    |)
                  ]
                |) in
              let~ adapter_width : Ty.path "usize" :=
                M.call_closure (|
                  Ty.path "usize",
                  M.get_trait_method (|
                    "p3_air::air::BaseAir",
                    Ty.associated_in_trait
                      "openvm_circuit::arch::integration_api::VmAdapterChip"
                      []
                      [
                        Ty.associated_in_trait
                          "p3_commit::domain::PolynomialSpace"
                          []
                          []
                          (Ty.associated_in_trait
                            "p3_commit::pcs::Pcs"
                            []
                            [
                              Ty.associated_in_trait
                                "openvm_stark_backend::config::StarkGenericConfig"
                                []
                                []
                                SC
                                "Challenge";
                              Ty.associated_in_trait
                                "openvm_stark_backend::config::StarkGenericConfig"
                                []
                                []
                                SC
                                "Challenger"
                            ]
                            (Ty.associated_in_trait
                              "openvm_stark_backend::config::StarkGenericConfig"
                              []
                              []
                              SC
                              "Pcs")
                            "Domain")
                          "Val"
                      ]
                      A
                      "Air",
                    [],
                    [
                      Ty.associated_in_trait
                        "p3_commit::domain::PolynomialSpace"
                        []
                        []
                        (Ty.associated_in_trait
                          "p3_commit::pcs::Pcs"
                          []
                          [
                            Ty.associated_in_trait
                              "openvm_stark_backend::config::StarkGenericConfig"
                              []
                              []
                              SC
                              "Challenge";
                            Ty.associated_in_trait
                              "openvm_stark_backend::config::StarkGenericConfig"
                              []
                              []
                              SC
                              "Challenger"
                          ]
                          (Ty.associated_in_trait
                            "openvm_stark_backend::config::StarkGenericConfig"
                            []
                            []
                            SC
                            "Pcs")
                          "Domain")
                        "Val"
                    ],
                    "width",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "&")
                            []
                            [
                              Ty.associated_in_trait
                                "openvm_circuit::arch::integration_api::VmAdapterChip"
                                []
                                [
                                  Ty.associated_in_trait
                                    "p3_commit::domain::PolynomialSpace"
                                    []
                                    []
                                    (Ty.associated_in_trait
                                      "p3_commit::pcs::Pcs"
                                      []
                                      [
                                        Ty.associated_in_trait
                                          "openvm_stark_backend::config::StarkGenericConfig"
                                          []
                                          []
                                          SC
                                          "Challenge";
                                        Ty.associated_in_trait
                                          "openvm_stark_backend::config::StarkGenericConfig"
                                          []
                                          []
                                          SC
                                          "Challenger"
                                      ]
                                      (Ty.associated_in_trait
                                        "openvm_stark_backend::config::StarkGenericConfig"
                                        []
                                        []
                                        SC
                                        "Pcs")
                                      "Domain")
                                    "Val"
                                ]
                                A
                                "Air"
                            ],
                          M.get_trait_method (|
                            "openvm_circuit::arch::integration_api::VmAdapterChip",
                            A,
                            [],
                            [
                              Ty.associated_in_trait
                                "p3_commit::domain::PolynomialSpace"
                                []
                                []
                                (Ty.associated_in_trait
                                  "p3_commit::pcs::Pcs"
                                  []
                                  [
                                    Ty.associated_in_trait
                                      "openvm_stark_backend::config::StarkGenericConfig"
                                      []
                                      []
                                      SC
                                      "Challenge";
                                    Ty.associated_in_trait
                                      "openvm_stark_backend::config::StarkGenericConfig"
                                      []
                                      []
                                      SC
                                      "Challenger"
                                  ]
                                  (Ty.associated_in_trait
                                    "openvm_stark_backend::config::StarkGenericConfig"
                                    []
                                    []
                                    SC
                                    "Pcs")
                                  "Domain")
                                "Val"
                            ],
                            "air",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.SubPointer.get_struct_record_field (|
                                self,
                                "openvm_circuit::arch::integration_api::VmChipWrapper",
                                "adapter"
                              |)
                            |)
                          ]
                        |)
                      |)
                    |)
                  ]
                |) in
              let~ width : Ty.path "usize" :=
                M.call_closure (|
                  Ty.path "usize",
                  BinOp.Wrap.add,
                  [ M.read (| core_width |); M.read (| adapter_width |) ]
                |) in
              let~ values :
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [
                      Ty.associated_in_trait
                        "p3_commit::domain::PolynomialSpace"
                        []
                        []
                        (Ty.associated_in_trait
                          "p3_commit::pcs::Pcs"
                          []
                          [
                            Ty.associated_in_trait
                              "openvm_stark_backend::config::StarkGenericConfig"
                              []
                              []
                              SC
                              "Challenge";
                            Ty.associated_in_trait
                              "openvm_stark_backend::config::StarkGenericConfig"
                              []
                              []
                              SC
                              "Challenger"
                          ]
                          (Ty.associated_in_trait
                            "openvm_stark_backend::config::StarkGenericConfig"
                            []
                            []
                            SC
                            "Pcs")
                          "Domain")
                        "Val";
                      Ty.path "alloc::alloc::Global"
                    ] :=
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [
                      Ty.associated_in_trait
                        "p3_commit::domain::PolynomialSpace"
                        []
                        []
                        (Ty.associated_in_trait
                          "p3_commit::pcs::Pcs"
                          []
                          [
                            Ty.associated_in_trait
                              "openvm_stark_backend::config::StarkGenericConfig"
                              []
                              []
                              SC
                              "Challenge";
                            Ty.associated_in_trait
                              "openvm_stark_backend::config::StarkGenericConfig"
                              []
                              []
                              SC
                              "Challenger"
                          ]
                          (Ty.associated_in_trait
                            "openvm_stark_backend::config::StarkGenericConfig"
                            []
                            []
                            SC
                            "Pcs")
                          "Domain")
                        "Val";
                      Ty.path "alloc::alloc::Global"
                    ],
                  M.get_trait_method (|
                    "p3_field::field::FieldAlgebra",
                    Ty.associated_in_trait
                      "p3_commit::domain::PolynomialSpace"
                      []
                      []
                      (Ty.associated_in_trait
                        "p3_commit::pcs::Pcs"
                        []
                        [
                          Ty.associated_in_trait
                            "openvm_stark_backend::config::StarkGenericConfig"
                            []
                            []
                            SC
                            "Challenge";
                          Ty.associated_in_trait
                            "openvm_stark_backend::config::StarkGenericConfig"
                            []
                            []
                            SC
                            "Challenger"
                        ]
                        (Ty.associated_in_trait
                          "openvm_stark_backend::config::StarkGenericConfig"
                          []
                          []
                          SC
                          "Pcs")
                        "Domain")
                      "Val",
                    [],
                    [],
                    "zero_vec",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.path "usize",
                      BinOp.Wrap.mul,
                      [ M.read (| height |); M.read (| width |) ]
                    |)
                  ]
                |) in
              let~ memory :
                  Ty.apply
                    (Ty.path "std::sync::mutex::MutexGuard")
                    []
                    [
                      Ty.apply
                        (Ty.path "openvm_circuit::system::memory::offline::OfflineMemory")
                        []
                        [
                          Ty.associated_in_trait
                            "p3_commit::domain::PolynomialSpace"
                            []
                            []
                            (Ty.associated_in_trait
                              "p3_commit::pcs::Pcs"
                              []
                              [
                                Ty.associated_in_trait
                                  "openvm_stark_backend::config::StarkGenericConfig"
                                  []
                                  []
                                  SC
                                  "Challenge";
                                Ty.associated_in_trait
                                  "openvm_stark_backend::config::StarkGenericConfig"
                                  []
                                  []
                                  SC
                                  "Challenger"
                              ]
                              (Ty.associated_in_trait
                                "openvm_stark_backend::config::StarkGenericConfig"
                                []
                                []
                                SC
                                "Pcs")
                              "Domain")
                            "Val"
                        ]
                    ] :=
                M.call_closure (|
                  Ty.apply
                    (Ty.path "std::sync::mutex::MutexGuard")
                    []
                    [
                      Ty.apply
                        (Ty.path "openvm_circuit::system::memory::offline::OfflineMemory")
                        []
                        [
                          Ty.associated_in_trait
                            "p3_commit::domain::PolynomialSpace"
                            []
                            []
                            (Ty.associated_in_trait
                              "p3_commit::pcs::Pcs"
                              []
                              [
                                Ty.associated_in_trait
                                  "openvm_stark_backend::config::StarkGenericConfig"
                                  []
                                  []
                                  SC
                                  "Challenge";
                                Ty.associated_in_trait
                                  "openvm_stark_backend::config::StarkGenericConfig"
                                  []
                                  []
                                  SC
                                  "Challenger"
                              ]
                              (Ty.associated_in_trait
                                "openvm_stark_backend::config::StarkGenericConfig"
                                []
                                []
                                SC
                                "Pcs")
                              "Domain")
                            "Val"
                        ]
                    ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [
                        Ty.apply
                          (Ty.path "std::sync::mutex::MutexGuard")
                          []
                          [
                            Ty.apply
                              (Ty.path "openvm_circuit::system::memory::offline::OfflineMemory")
                              []
                              [
                                Ty.associated_in_trait
                                  "p3_commit::domain::PolynomialSpace"
                                  []
                                  []
                                  (Ty.associated_in_trait
                                    "p3_commit::pcs::Pcs"
                                    []
                                    [
                                      Ty.associated_in_trait
                                        "openvm_stark_backend::config::StarkGenericConfig"
                                        []
                                        []
                                        SC
                                        "Challenge";
                                      Ty.associated_in_trait
                                        "openvm_stark_backend::config::StarkGenericConfig"
                                        []
                                        []
                                        SC
                                        "Challenger"
                                    ]
                                    (Ty.associated_in_trait
                                      "openvm_stark_backend::config::StarkGenericConfig"
                                      []
                                      []
                                      SC
                                      "Pcs")
                                    "Domain")
                                  "Val"
                              ]
                          ];
                        Ty.apply
                          (Ty.path "std::sync::poison::PoisonError")
                          []
                          [
                            Ty.apply
                              (Ty.path "std::sync::mutex::MutexGuard")
                              []
                              [
                                Ty.apply
                                  (Ty.path "openvm_circuit::system::memory::offline::OfflineMemory")
                                  []
                                  [
                                    Ty.associated_in_trait
                                      "p3_commit::domain::PolynomialSpace"
                                      []
                                      []
                                      (Ty.associated_in_trait
                                        "p3_commit::pcs::Pcs"
                                        []
                                        [
                                          Ty.associated_in_trait
                                            "openvm_stark_backend::config::StarkGenericConfig"
                                            []
                                            []
                                            SC
                                            "Challenge";
                                          Ty.associated_in_trait
                                            "openvm_stark_backend::config::StarkGenericConfig"
                                            []
                                            []
                                            SC
                                            "Challenger"
                                        ]
                                        (Ty.associated_in_trait
                                          "openvm_stark_backend::config::StarkGenericConfig"
                                          []
                                          []
                                          SC
                                          "Pcs")
                                        "Domain")
                                      "Val"
                                  ]
                              ]
                          ]
                      ],
                    "unwrap",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [
                          Ty.apply
                            (Ty.path "std::sync::mutex::MutexGuard")
                            []
                            [
                              Ty.apply
                                (Ty.path "openvm_circuit::system::memory::offline::OfflineMemory")
                                []
                                [
                                  Ty.associated_in_trait
                                    "p3_commit::domain::PolynomialSpace"
                                    []
                                    []
                                    (Ty.associated_in_trait
                                      "p3_commit::pcs::Pcs"
                                      []
                                      [
                                        Ty.associated_in_trait
                                          "openvm_stark_backend::config::StarkGenericConfig"
                                          []
                                          []
                                          SC
                                          "Challenge";
                                        Ty.associated_in_trait
                                          "openvm_stark_backend::config::StarkGenericConfig"
                                          []
                                          []
                                          SC
                                          "Challenger"
                                      ]
                                      (Ty.associated_in_trait
                                        "openvm_stark_backend::config::StarkGenericConfig"
                                        []
                                        []
                                        SC
                                        "Pcs")
                                      "Domain")
                                    "Val"
                                ]
                            ];
                          Ty.apply
                            (Ty.path "std::sync::poison::PoisonError")
                            []
                            [
                              Ty.apply
                                (Ty.path "std::sync::mutex::MutexGuard")
                                []
                                [
                                  Ty.apply
                                    (Ty.path
                                      "openvm_circuit::system::memory::offline::OfflineMemory")
                                    []
                                    [
                                      Ty.associated_in_trait
                                        "p3_commit::domain::PolynomialSpace"
                                        []
                                        []
                                        (Ty.associated_in_trait
                                          "p3_commit::pcs::Pcs"
                                          []
                                          [
                                            Ty.associated_in_trait
                                              "openvm_stark_backend::config::StarkGenericConfig"
                                              []
                                              []
                                              SC
                                              "Challenge";
                                            Ty.associated_in_trait
                                              "openvm_stark_backend::config::StarkGenericConfig"
                                              []
                                              []
                                              SC
                                              "Challenger"
                                          ]
                                          (Ty.associated_in_trait
                                            "openvm_stark_backend::config::StarkGenericConfig"
                                            []
                                            []
                                            SC
                                            "Pcs")
                                          "Domain")
                                        "Val"
                                    ]
                                ]
                            ]
                        ],
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "std::sync::mutex::Mutex")
                          []
                          [
                            Ty.apply
                              (Ty.path "openvm_circuit::system::memory::offline::OfflineMemory")
                              []
                              [
                                Ty.associated_in_trait
                                  "p3_commit::domain::PolynomialSpace"
                                  []
                                  []
                                  (Ty.associated_in_trait
                                    "p3_commit::pcs::Pcs"
                                    []
                                    [
                                      Ty.associated_in_trait
                                        "openvm_stark_backend::config::StarkGenericConfig"
                                        []
                                        []
                                        SC
                                        "Challenge";
                                      Ty.associated_in_trait
                                        "openvm_stark_backend::config::StarkGenericConfig"
                                        []
                                        []
                                        SC
                                        "Challenger"
                                    ]
                                    (Ty.associated_in_trait
                                      "openvm_stark_backend::config::StarkGenericConfig"
                                      []
                                      []
                                      SC
                                      "Pcs")
                                    "Domain")
                                  "Val"
                              ]
                          ],
                        "lock",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (|
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "&")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "std::sync::mutex::Mutex")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path
                                          "openvm_circuit::system::memory::offline::OfflineMemory")
                                        []
                                        [
                                          Ty.associated_in_trait
                                            "p3_commit::domain::PolynomialSpace"
                                            []
                                            []
                                            (Ty.associated_in_trait
                                              "p3_commit::pcs::Pcs"
                                              []
                                              [
                                                Ty.associated_in_trait
                                                  "openvm_stark_backend::config::StarkGenericConfig"
                                                  []
                                                  []
                                                  SC
                                                  "Challenge";
                                                Ty.associated_in_trait
                                                  "openvm_stark_backend::config::StarkGenericConfig"
                                                  []
                                                  []
                                                  SC
                                                  "Challenger"
                                              ]
                                              (Ty.associated_in_trait
                                                "openvm_stark_backend::config::StarkGenericConfig"
                                                []
                                                []
                                                SC
                                                "Pcs")
                                              "Domain")
                                            "Val"
                                        ]
                                    ]
                                ],
                              M.get_trait_method (|
                                "core::ops::deref::Deref",
                                Ty.apply
                                  (Ty.path "alloc::sync::Arc")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "std::sync::mutex::Mutex")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path
                                            "openvm_circuit::system::memory::offline::OfflineMemory")
                                          []
                                          [
                                            Ty.associated_in_trait
                                              "p3_commit::domain::PolynomialSpace"
                                              []
                                              []
                                              (Ty.associated_in_trait
                                                "p3_commit::pcs::Pcs"
                                                []
                                                [
                                                  Ty.associated_in_trait
                                                    "openvm_stark_backend::config::StarkGenericConfig"
                                                    []
                                                    []
                                                    SC
                                                    "Challenge";
                                                  Ty.associated_in_trait
                                                    "openvm_stark_backend::config::StarkGenericConfig"
                                                    []
                                                    []
                                                    SC
                                                    "Challenger"
                                                ]
                                                (Ty.associated_in_trait
                                                  "openvm_stark_backend::config::StarkGenericConfig"
                                                  []
                                                  []
                                                  SC
                                                  "Pcs")
                                                "Domain")
                                              "Val"
                                          ]
                                      ];
                                    Ty.path "alloc::alloc::Global"
                                  ],
                                [],
                                [],
                                "deref",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.SubPointer.get_struct_record_field (|
                                    self,
                                    "openvm_circuit::arch::integration_api::VmChipWrapper",
                                    "offline_memory"
                                  |)
                                |)
                              ]
                            |)
                          |)
                        |)
                      ]
                    |)
                  ]
                |) in
              let~ _ : Ty.tuple [] :=
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "rayon::iter::ParallelIterator",
                    Ty.apply
                      (Ty.path "rayon::iter::zip::Zip")
                      []
                      [
                        Ty.apply
                          (Ty.path "rayon::slice::chunks::ChunksMut")
                          []
                          [
                            Ty.associated_in_trait
                              "p3_commit::domain::PolynomialSpace"
                              []
                              []
                              (Ty.associated_in_trait
                                "p3_commit::pcs::Pcs"
                                []
                                [
                                  Ty.associated_in_trait
                                    "openvm_stark_backend::config::StarkGenericConfig"
                                    []
                                    []
                                    SC
                                    "Challenge";
                                  Ty.associated_in_trait
                                    "openvm_stark_backend::config::StarkGenericConfig"
                                    []
                                    []
                                    SC
                                    "Challenger"
                                ]
                                (Ty.associated_in_trait
                                  "openvm_stark_backend::config::StarkGenericConfig"
                                  []
                                  []
                                  SC
                                  "Pcs")
                                "Domain")
                              "Val"
                          ];
                        Ty.apply
                          (Ty.path "rayon::vec::IntoIter")
                          []
                          [
                            Ty.tuple
                              [
                                Ty.associated_in_trait
                                  "openvm_circuit::arch::integration_api::VmAdapterChip"
                                  []
                                  [
                                    Ty.associated_in_trait
                                      "p3_commit::domain::PolynomialSpace"
                                      []
                                      []
                                      (Ty.associated_in_trait
                                        "p3_commit::pcs::Pcs"
                                        []
                                        [
                                          Ty.associated_in_trait
                                            "openvm_stark_backend::config::StarkGenericConfig"
                                            []
                                            []
                                            SC
                                            "Challenge";
                                          Ty.associated_in_trait
                                            "openvm_stark_backend::config::StarkGenericConfig"
                                            []
                                            []
                                            SC
                                            "Challenger"
                                        ]
                                        (Ty.associated_in_trait
                                          "openvm_stark_backend::config::StarkGenericConfig"
                                          []
                                          []
                                          SC
                                          "Pcs")
                                        "Domain")
                                      "Val"
                                  ]
                                  A
                                  "ReadRecord";
                                Ty.associated_in_trait
                                  "openvm_circuit::arch::integration_api::VmAdapterChip"
                                  []
                                  [
                                    Ty.associated_in_trait
                                      "p3_commit::domain::PolynomialSpace"
                                      []
                                      []
                                      (Ty.associated_in_trait
                                        "p3_commit::pcs::Pcs"
                                        []
                                        [
                                          Ty.associated_in_trait
                                            "openvm_stark_backend::config::StarkGenericConfig"
                                            []
                                            []
                                            SC
                                            "Challenge";
                                          Ty.associated_in_trait
                                            "openvm_stark_backend::config::StarkGenericConfig"
                                            []
                                            []
                                            SC
                                            "Challenger"
                                        ]
                                        (Ty.associated_in_trait
                                          "openvm_stark_backend::config::StarkGenericConfig"
                                          []
                                          []
                                          SC
                                          "Pcs")
                                        "Domain")
                                      "Val"
                                  ]
                                  A
                                  "WriteRecord";
                                Ty.associated_in_trait
                                  "openvm_circuit::arch::integration_api::VmCoreChip"
                                  []
                                  [
                                    Ty.associated_in_trait
                                      "p3_commit::domain::PolynomialSpace"
                                      []
                                      []
                                      (Ty.associated_in_trait
                                        "p3_commit::pcs::Pcs"
                                        []
                                        [
                                          Ty.associated_in_trait
                                            "openvm_stark_backend::config::StarkGenericConfig"
                                            []
                                            []
                                            SC
                                            "Challenge";
                                          Ty.associated_in_trait
                                            "openvm_stark_backend::config::StarkGenericConfig"
                                            []
                                            []
                                            SC
                                            "Challenger"
                                        ]
                                        (Ty.associated_in_trait
                                          "openvm_stark_backend::config::StarkGenericConfig"
                                          []
                                          []
                                          SC
                                          "Pcs")
                                        "Domain")
                                      "Val";
                                    Ty.associated_in_trait
                                      "openvm_circuit::arch::integration_api::VmAdapterChip"
                                      []
                                      [
                                        Ty.associated_in_trait
                                          "p3_commit::domain::PolynomialSpace"
                                          []
                                          []
                                          (Ty.associated_in_trait
                                            "p3_commit::pcs::Pcs"
                                            []
                                            [
                                              Ty.associated_in_trait
                                                "openvm_stark_backend::config::StarkGenericConfig"
                                                []
                                                []
                                                SC
                                                "Challenge";
                                              Ty.associated_in_trait
                                                "openvm_stark_backend::config::StarkGenericConfig"
                                                []
                                                []
                                                SC
                                                "Challenger"
                                            ]
                                            (Ty.associated_in_trait
                                              "openvm_stark_backend::config::StarkGenericConfig"
                                              []
                                              []
                                              SC
                                              "Pcs")
                                            "Domain")
                                          "Val"
                                      ]
                                      A
                                      "Interface"
                                  ]
                                  C
                                  "Record"
                              ]
                          ]
                      ],
                    [],
                    [],
                    "for_each",
                    [],
                    [
                      Ty.function
                        [
                          Ty.tuple
                            [
                              Ty.apply
                                (Ty.path "&mut")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "slice")
                                    []
                                    [
                                      Ty.associated_in_trait
                                        "p3_commit::domain::PolynomialSpace"
                                        []
                                        []
                                        (Ty.associated_in_trait
                                          "p3_commit::pcs::Pcs"
                                          []
                                          [
                                            Ty.associated_in_trait
                                              "openvm_stark_backend::config::StarkGenericConfig"
                                              []
                                              []
                                              SC
                                              "Challenge";
                                            Ty.associated_in_trait
                                              "openvm_stark_backend::config::StarkGenericConfig"
                                              []
                                              []
                                              SC
                                              "Challenger"
                                          ]
                                          (Ty.associated_in_trait
                                            "openvm_stark_backend::config::StarkGenericConfig"
                                            []
                                            []
                                            SC
                                            "Pcs")
                                          "Domain")
                                        "Val"
                                    ]
                                ];
                              Ty.tuple
                                [
                                  Ty.associated_in_trait
                                    "openvm_circuit::arch::integration_api::VmAdapterChip"
                                    []
                                    [
                                      Ty.associated_in_trait
                                        "p3_commit::domain::PolynomialSpace"
                                        []
                                        []
                                        (Ty.associated_in_trait
                                          "p3_commit::pcs::Pcs"
                                          []
                                          [
                                            Ty.associated_in_trait
                                              "openvm_stark_backend::config::StarkGenericConfig"
                                              []
                                              []
                                              SC
                                              "Challenge";
                                            Ty.associated_in_trait
                                              "openvm_stark_backend::config::StarkGenericConfig"
                                              []
                                              []
                                              SC
                                              "Challenger"
                                          ]
                                          (Ty.associated_in_trait
                                            "openvm_stark_backend::config::StarkGenericConfig"
                                            []
                                            []
                                            SC
                                            "Pcs")
                                          "Domain")
                                        "Val"
                                    ]
                                    A
                                    "ReadRecord";
                                  Ty.associated_in_trait
                                    "openvm_circuit::arch::integration_api::VmAdapterChip"
                                    []
                                    [
                                      Ty.associated_in_trait
                                        "p3_commit::domain::PolynomialSpace"
                                        []
                                        []
                                        (Ty.associated_in_trait
                                          "p3_commit::pcs::Pcs"
                                          []
                                          [
                                            Ty.associated_in_trait
                                              "openvm_stark_backend::config::StarkGenericConfig"
                                              []
                                              []
                                              SC
                                              "Challenge";
                                            Ty.associated_in_trait
                                              "openvm_stark_backend::config::StarkGenericConfig"
                                              []
                                              []
                                              SC
                                              "Challenger"
                                          ]
                                          (Ty.associated_in_trait
                                            "openvm_stark_backend::config::StarkGenericConfig"
                                            []
                                            []
                                            SC
                                            "Pcs")
                                          "Domain")
                                        "Val"
                                    ]
                                    A
                                    "WriteRecord";
                                  Ty.associated_in_trait
                                    "openvm_circuit::arch::integration_api::VmCoreChip"
                                    []
                                    [
                                      Ty.associated_in_trait
                                        "p3_commit::domain::PolynomialSpace"
                                        []
                                        []
                                        (Ty.associated_in_trait
                                          "p3_commit::pcs::Pcs"
                                          []
                                          [
                                            Ty.associated_in_trait
                                              "openvm_stark_backend::config::StarkGenericConfig"
                                              []
                                              []
                                              SC
                                              "Challenge";
                                            Ty.associated_in_trait
                                              "openvm_stark_backend::config::StarkGenericConfig"
                                              []
                                              []
                                              SC
                                              "Challenger"
                                          ]
                                          (Ty.associated_in_trait
                                            "openvm_stark_backend::config::StarkGenericConfig"
                                            []
                                            []
                                            SC
                                            "Pcs")
                                          "Domain")
                                        "Val";
                                      Ty.associated_in_trait
                                        "openvm_circuit::arch::integration_api::VmAdapterChip"
                                        []
                                        [
                                          Ty.associated_in_trait
                                            "p3_commit::domain::PolynomialSpace"
                                            []
                                            []
                                            (Ty.associated_in_trait
                                              "p3_commit::pcs::Pcs"
                                              []
                                              [
                                                Ty.associated_in_trait
                                                  "openvm_stark_backend::config::StarkGenericConfig"
                                                  []
                                                  []
                                                  SC
                                                  "Challenge";
                                                Ty.associated_in_trait
                                                  "openvm_stark_backend::config::StarkGenericConfig"
                                                  []
                                                  []
                                                  SC
                                                  "Challenger"
                                              ]
                                              (Ty.associated_in_trait
                                                "openvm_stark_backend::config::StarkGenericConfig"
                                                []
                                                []
                                                SC
                                                "Pcs")
                                              "Domain")
                                            "Val"
                                        ]
                                        A
                                        "Interface"
                                    ]
                                    C
                                    "Record"
                                ]
                            ]
                        ]
                        (Ty.tuple [])
                    ]
                  |),
                  [
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "rayon::iter::zip::Zip")
                        []
                        [
                          Ty.apply
                            (Ty.path "rayon::slice::chunks::ChunksMut")
                            []
                            [
                              Ty.associated_in_trait
                                "p3_commit::domain::PolynomialSpace"
                                []
                                []
                                (Ty.associated_in_trait
                                  "p3_commit::pcs::Pcs"
                                  []
                                  [
                                    Ty.associated_in_trait
                                      "openvm_stark_backend::config::StarkGenericConfig"
                                      []
                                      []
                                      SC
                                      "Challenge";
                                    Ty.associated_in_trait
                                      "openvm_stark_backend::config::StarkGenericConfig"
                                      []
                                      []
                                      SC
                                      "Challenger"
                                  ]
                                  (Ty.associated_in_trait
                                    "openvm_stark_backend::config::StarkGenericConfig"
                                    []
                                    []
                                    SC
                                    "Pcs")
                                  "Domain")
                                "Val"
                            ];
                          Ty.apply
                            (Ty.path "rayon::vec::IntoIter")
                            []
                            [
                              Ty.tuple
                                [
                                  Ty.associated_in_trait
                                    "openvm_circuit::arch::integration_api::VmAdapterChip"
                                    []
                                    [
                                      Ty.associated_in_trait
                                        "p3_commit::domain::PolynomialSpace"
                                        []
                                        []
                                        (Ty.associated_in_trait
                                          "p3_commit::pcs::Pcs"
                                          []
                                          [
                                            Ty.associated_in_trait
                                              "openvm_stark_backend::config::StarkGenericConfig"
                                              []
                                              []
                                              SC
                                              "Challenge";
                                            Ty.associated_in_trait
                                              "openvm_stark_backend::config::StarkGenericConfig"
                                              []
                                              []
                                              SC
                                              "Challenger"
                                          ]
                                          (Ty.associated_in_trait
                                            "openvm_stark_backend::config::StarkGenericConfig"
                                            []
                                            []
                                            SC
                                            "Pcs")
                                          "Domain")
                                        "Val"
                                    ]
                                    A
                                    "ReadRecord";
                                  Ty.associated_in_trait
                                    "openvm_circuit::arch::integration_api::VmAdapterChip"
                                    []
                                    [
                                      Ty.associated_in_trait
                                        "p3_commit::domain::PolynomialSpace"
                                        []
                                        []
                                        (Ty.associated_in_trait
                                          "p3_commit::pcs::Pcs"
                                          []
                                          [
                                            Ty.associated_in_trait
                                              "openvm_stark_backend::config::StarkGenericConfig"
                                              []
                                              []
                                              SC
                                              "Challenge";
                                            Ty.associated_in_trait
                                              "openvm_stark_backend::config::StarkGenericConfig"
                                              []
                                              []
                                              SC
                                              "Challenger"
                                          ]
                                          (Ty.associated_in_trait
                                            "openvm_stark_backend::config::StarkGenericConfig"
                                            []
                                            []
                                            SC
                                            "Pcs")
                                          "Domain")
                                        "Val"
                                    ]
                                    A
                                    "WriteRecord";
                                  Ty.associated_in_trait
                                    "openvm_circuit::arch::integration_api::VmCoreChip"
                                    []
                                    [
                                      Ty.associated_in_trait
                                        "p3_commit::domain::PolynomialSpace"
                                        []
                                        []
                                        (Ty.associated_in_trait
                                          "p3_commit::pcs::Pcs"
                                          []
                                          [
                                            Ty.associated_in_trait
                                              "openvm_stark_backend::config::StarkGenericConfig"
                                              []
                                              []
                                              SC
                                              "Challenge";
                                            Ty.associated_in_trait
                                              "openvm_stark_backend::config::StarkGenericConfig"
                                              []
                                              []
                                              SC
                                              "Challenger"
                                          ]
                                          (Ty.associated_in_trait
                                            "openvm_stark_backend::config::StarkGenericConfig"
                                            []
                                            []
                                            SC
                                            "Pcs")
                                          "Domain")
                                        "Val";
                                      Ty.associated_in_trait
                                        "openvm_circuit::arch::integration_api::VmAdapterChip"
                                        []
                                        [
                                          Ty.associated_in_trait
                                            "p3_commit::domain::PolynomialSpace"
                                            []
                                            []
                                            (Ty.associated_in_trait
                                              "p3_commit::pcs::Pcs"
                                              []
                                              [
                                                Ty.associated_in_trait
                                                  "openvm_stark_backend::config::StarkGenericConfig"
                                                  []
                                                  []
                                                  SC
                                                  "Challenge";
                                                Ty.associated_in_trait
                                                  "openvm_stark_backend::config::StarkGenericConfig"
                                                  []
                                                  []
                                                  SC
                                                  "Challenger"
                                              ]
                                              (Ty.associated_in_trait
                                                "openvm_stark_backend::config::StarkGenericConfig"
                                                []
                                                []
                                                SC
                                                "Pcs")
                                              "Domain")
                                            "Val"
                                        ]
                                        A
                                        "Interface"
                                    ]
                                    C
                                    "Record"
                                ]
                            ]
                        ],
                      M.get_trait_method (|
                        "rayon::iter::IndexedParallelIterator",
                        Ty.apply
                          (Ty.path "rayon::slice::chunks::ChunksMut")
                          []
                          [
                            Ty.associated_in_trait
                              "p3_commit::domain::PolynomialSpace"
                              []
                              []
                              (Ty.associated_in_trait
                                "p3_commit::pcs::Pcs"
                                []
                                [
                                  Ty.associated_in_trait
                                    "openvm_stark_backend::config::StarkGenericConfig"
                                    []
                                    []
                                    SC
                                    "Challenge";
                                  Ty.associated_in_trait
                                    "openvm_stark_backend::config::StarkGenericConfig"
                                    []
                                    []
                                    SC
                                    "Challenger"
                                ]
                                (Ty.associated_in_trait
                                  "openvm_stark_backend::config::StarkGenericConfig"
                                  []
                                  []
                                  SC
                                  "Pcs")
                                "Domain")
                              "Val"
                          ],
                        [],
                        [],
                        "zip",
                        [],
                        [
                          Ty.apply
                            (Ty.path "rayon::vec::IntoIter")
                            []
                            [
                              Ty.tuple
                                [
                                  Ty.associated_in_trait
                                    "openvm_circuit::arch::integration_api::VmAdapterChip"
                                    []
                                    [
                                      Ty.associated_in_trait
                                        "p3_commit::domain::PolynomialSpace"
                                        []
                                        []
                                        (Ty.associated_in_trait
                                          "p3_commit::pcs::Pcs"
                                          []
                                          [
                                            Ty.associated_in_trait
                                              "openvm_stark_backend::config::StarkGenericConfig"
                                              []
                                              []
                                              SC
                                              "Challenge";
                                            Ty.associated_in_trait
                                              "openvm_stark_backend::config::StarkGenericConfig"
                                              []
                                              []
                                              SC
                                              "Challenger"
                                          ]
                                          (Ty.associated_in_trait
                                            "openvm_stark_backend::config::StarkGenericConfig"
                                            []
                                            []
                                            SC
                                            "Pcs")
                                          "Domain")
                                        "Val"
                                    ]
                                    A
                                    "ReadRecord";
                                  Ty.associated_in_trait
                                    "openvm_circuit::arch::integration_api::VmAdapterChip"
                                    []
                                    [
                                      Ty.associated_in_trait
                                        "p3_commit::domain::PolynomialSpace"
                                        []
                                        []
                                        (Ty.associated_in_trait
                                          "p3_commit::pcs::Pcs"
                                          []
                                          [
                                            Ty.associated_in_trait
                                              "openvm_stark_backend::config::StarkGenericConfig"
                                              []
                                              []
                                              SC
                                              "Challenge";
                                            Ty.associated_in_trait
                                              "openvm_stark_backend::config::StarkGenericConfig"
                                              []
                                              []
                                              SC
                                              "Challenger"
                                          ]
                                          (Ty.associated_in_trait
                                            "openvm_stark_backend::config::StarkGenericConfig"
                                            []
                                            []
                                            SC
                                            "Pcs")
                                          "Domain")
                                        "Val"
                                    ]
                                    A
                                    "WriteRecord";
                                  Ty.associated_in_trait
                                    "openvm_circuit::arch::integration_api::VmCoreChip"
                                    []
                                    [
                                      Ty.associated_in_trait
                                        "p3_commit::domain::PolynomialSpace"
                                        []
                                        []
                                        (Ty.associated_in_trait
                                          "p3_commit::pcs::Pcs"
                                          []
                                          [
                                            Ty.associated_in_trait
                                              "openvm_stark_backend::config::StarkGenericConfig"
                                              []
                                              []
                                              SC
                                              "Challenge";
                                            Ty.associated_in_trait
                                              "openvm_stark_backend::config::StarkGenericConfig"
                                              []
                                              []
                                              SC
                                              "Challenger"
                                          ]
                                          (Ty.associated_in_trait
                                            "openvm_stark_backend::config::StarkGenericConfig"
                                            []
                                            []
                                            SC
                                            "Pcs")
                                          "Domain")
                                        "Val";
                                      Ty.associated_in_trait
                                        "openvm_circuit::arch::integration_api::VmAdapterChip"
                                        []
                                        [
                                          Ty.associated_in_trait
                                            "p3_commit::domain::PolynomialSpace"
                                            []
                                            []
                                            (Ty.associated_in_trait
                                              "p3_commit::pcs::Pcs"
                                              []
                                              [
                                                Ty.associated_in_trait
                                                  "openvm_stark_backend::config::StarkGenericConfig"
                                                  []
                                                  []
                                                  SC
                                                  "Challenge";
                                                Ty.associated_in_trait
                                                  "openvm_stark_backend::config::StarkGenericConfig"
                                                  []
                                                  []
                                                  SC
                                                  "Challenger"
                                              ]
                                              (Ty.associated_in_trait
                                                "openvm_stark_backend::config::StarkGenericConfig"
                                                []
                                                []
                                                SC
                                                "Pcs")
                                              "Domain")
                                            "Val"
                                        ]
                                        A
                                        "Interface"
                                    ]
                                    C
                                    "Record"
                                ]
                            ]
                        ]
                      |),
                      [
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "rayon::slice::chunks::ChunksMut")
                            []
                            [
                              Ty.associated_in_trait
                                "p3_commit::domain::PolynomialSpace"
                                []
                                []
                                (Ty.associated_in_trait
                                  "p3_commit::pcs::Pcs"
                                  []
                                  [
                                    Ty.associated_in_trait
                                      "openvm_stark_backend::config::StarkGenericConfig"
                                      []
                                      []
                                      SC
                                      "Challenge";
                                    Ty.associated_in_trait
                                      "openvm_stark_backend::config::StarkGenericConfig"
                                      []
                                      []
                                      SC
                                      "Challenger"
                                  ]
                                  (Ty.associated_in_trait
                                    "openvm_stark_backend::config::StarkGenericConfig"
                                    []
                                    []
                                    SC
                                    "Pcs")
                                  "Domain")
                                "Val"
                            ],
                          M.get_trait_method (|
                            "rayon::slice::ParallelSliceMut",
                            Ty.apply
                              (Ty.path "slice")
                              []
                              [
                                Ty.associated_in_trait
                                  "p3_commit::domain::PolynomialSpace"
                                  []
                                  []
                                  (Ty.associated_in_trait
                                    "p3_commit::pcs::Pcs"
                                    []
                                    [
                                      Ty.associated_in_trait
                                        "openvm_stark_backend::config::StarkGenericConfig"
                                        []
                                        []
                                        SC
                                        "Challenge";
                                      Ty.associated_in_trait
                                        "openvm_stark_backend::config::StarkGenericConfig"
                                        []
                                        []
                                        SC
                                        "Challenger"
                                    ]
                                    (Ty.associated_in_trait
                                      "openvm_stark_backend::config::StarkGenericConfig"
                                      []
                                      []
                                      SC
                                      "Pcs")
                                    "Domain")
                                  "Val"
                              ],
                            [],
                            [
                              Ty.associated_in_trait
                                "p3_commit::domain::PolynomialSpace"
                                []
                                []
                                (Ty.associated_in_trait
                                  "p3_commit::pcs::Pcs"
                                  []
                                  [
                                    Ty.associated_in_trait
                                      "openvm_stark_backend::config::StarkGenericConfig"
                                      []
                                      []
                                      SC
                                      "Challenge";
                                    Ty.associated_in_trait
                                      "openvm_stark_backend::config::StarkGenericConfig"
                                      []
                                      []
                                      SC
                                      "Challenger"
                                  ]
                                  (Ty.associated_in_trait
                                    "openvm_stark_backend::config::StarkGenericConfig"
                                    []
                                    []
                                    SC
                                    "Pcs")
                                  "Domain")
                                "Val"
                            ],
                            "par_chunks_mut",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.MutRef,
                              M.deref (|
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "&mut")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "slice")
                                        []
                                        [
                                          Ty.associated_in_trait
                                            "p3_commit::domain::PolynomialSpace"
                                            []
                                            []
                                            (Ty.associated_in_trait
                                              "p3_commit::pcs::Pcs"
                                              []
                                              [
                                                Ty.associated_in_trait
                                                  "openvm_stark_backend::config::StarkGenericConfig"
                                                  []
                                                  []
                                                  SC
                                                  "Challenge";
                                                Ty.associated_in_trait
                                                  "openvm_stark_backend::config::StarkGenericConfig"
                                                  []
                                                  []
                                                  SC
                                                  "Challenger"
                                              ]
                                              (Ty.associated_in_trait
                                                "openvm_stark_backend::config::StarkGenericConfig"
                                                []
                                                []
                                                SC
                                                "Pcs")
                                              "Domain")
                                            "Val"
                                        ]
                                    ],
                                  M.get_trait_method (|
                                    "core::ops::deref::DerefMut",
                                    Ty.apply
                                      (Ty.path "alloc::vec::Vec")
                                      []
                                      [
                                        Ty.associated_in_trait
                                          "p3_commit::domain::PolynomialSpace"
                                          []
                                          []
                                          (Ty.associated_in_trait
                                            "p3_commit::pcs::Pcs"
                                            []
                                            [
                                              Ty.associated_in_trait
                                                "openvm_stark_backend::config::StarkGenericConfig"
                                                []
                                                []
                                                SC
                                                "Challenge";
                                              Ty.associated_in_trait
                                                "openvm_stark_backend::config::StarkGenericConfig"
                                                []
                                                []
                                                SC
                                                "Challenger"
                                            ]
                                            (Ty.associated_in_trait
                                              "openvm_stark_backend::config::StarkGenericConfig"
                                              []
                                              []
                                              SC
                                              "Pcs")
                                            "Domain")
                                          "Val";
                                        Ty.path "alloc::alloc::Global"
                                      ],
                                    [],
                                    [],
                                    "deref_mut",
                                    [],
                                    []
                                  |),
                                  [ M.borrow (| Pointer.Kind.MutRef, values |) ]
                                |)
                              |)
                            |);
                            M.read (| width |)
                          ]
                        |);
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "rayon::vec::IntoIter")
                            []
                            [
                              Ty.tuple
                                [
                                  Ty.associated_in_trait
                                    "openvm_circuit::arch::integration_api::VmAdapterChip"
                                    []
                                    [
                                      Ty.associated_in_trait
                                        "p3_commit::domain::PolynomialSpace"
                                        []
                                        []
                                        (Ty.associated_in_trait
                                          "p3_commit::pcs::Pcs"
                                          []
                                          [
                                            Ty.associated_in_trait
                                              "openvm_stark_backend::config::StarkGenericConfig"
                                              []
                                              []
                                              SC
                                              "Challenge";
                                            Ty.associated_in_trait
                                              "openvm_stark_backend::config::StarkGenericConfig"
                                              []
                                              []
                                              SC
                                              "Challenger"
                                          ]
                                          (Ty.associated_in_trait
                                            "openvm_stark_backend::config::StarkGenericConfig"
                                            []
                                            []
                                            SC
                                            "Pcs")
                                          "Domain")
                                        "Val"
                                    ]
                                    A
                                    "ReadRecord";
                                  Ty.associated_in_trait
                                    "openvm_circuit::arch::integration_api::VmAdapterChip"
                                    []
                                    [
                                      Ty.associated_in_trait
                                        "p3_commit::domain::PolynomialSpace"
                                        []
                                        []
                                        (Ty.associated_in_trait
                                          "p3_commit::pcs::Pcs"
                                          []
                                          [
                                            Ty.associated_in_trait
                                              "openvm_stark_backend::config::StarkGenericConfig"
                                              []
                                              []
                                              SC
                                              "Challenge";
                                            Ty.associated_in_trait
                                              "openvm_stark_backend::config::StarkGenericConfig"
                                              []
                                              []
                                              SC
                                              "Challenger"
                                          ]
                                          (Ty.associated_in_trait
                                            "openvm_stark_backend::config::StarkGenericConfig"
                                            []
                                            []
                                            SC
                                            "Pcs")
                                          "Domain")
                                        "Val"
                                    ]
                                    A
                                    "WriteRecord";
                                  Ty.associated_in_trait
                                    "openvm_circuit::arch::integration_api::VmCoreChip"
                                    []
                                    [
                                      Ty.associated_in_trait
                                        "p3_commit::domain::PolynomialSpace"
                                        []
                                        []
                                        (Ty.associated_in_trait
                                          "p3_commit::pcs::Pcs"
                                          []
                                          [
                                            Ty.associated_in_trait
                                              "openvm_stark_backend::config::StarkGenericConfig"
                                              []
                                              []
                                              SC
                                              "Challenge";
                                            Ty.associated_in_trait
                                              "openvm_stark_backend::config::StarkGenericConfig"
                                              []
                                              []
                                              SC
                                              "Challenger"
                                          ]
                                          (Ty.associated_in_trait
                                            "openvm_stark_backend::config::StarkGenericConfig"
                                            []
                                            []
                                            SC
                                            "Pcs")
                                          "Domain")
                                        "Val";
                                      Ty.associated_in_trait
                                        "openvm_circuit::arch::integration_api::VmAdapterChip"
                                        []
                                        [
                                          Ty.associated_in_trait
                                            "p3_commit::domain::PolynomialSpace"
                                            []
                                            []
                                            (Ty.associated_in_trait
                                              "p3_commit::pcs::Pcs"
                                              []
                                              [
                                                Ty.associated_in_trait
                                                  "openvm_stark_backend::config::StarkGenericConfig"
                                                  []
                                                  []
                                                  SC
                                                  "Challenge";
                                                Ty.associated_in_trait
                                                  "openvm_stark_backend::config::StarkGenericConfig"
                                                  []
                                                  []
                                                  SC
                                                  "Challenger"
                                              ]
                                              (Ty.associated_in_trait
                                                "openvm_stark_backend::config::StarkGenericConfig"
                                                []
                                                []
                                                SC
                                                "Pcs")
                                              "Domain")
                                            "Val"
                                        ]
                                        A
                                        "Interface"
                                    ]
                                    C
                                    "Record"
                                ]
                            ],
                          M.get_trait_method (|
                            "rayon::iter::IntoParallelIterator",
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              []
                              [
                                Ty.tuple
                                  [
                                    Ty.associated_in_trait
                                      "openvm_circuit::arch::integration_api::VmAdapterChip"
                                      []
                                      [
                                        Ty.associated_in_trait
                                          "p3_commit::domain::PolynomialSpace"
                                          []
                                          []
                                          (Ty.associated_in_trait
                                            "p3_commit::pcs::Pcs"
                                            []
                                            [
                                              Ty.associated_in_trait
                                                "openvm_stark_backend::config::StarkGenericConfig"
                                                []
                                                []
                                                SC
                                                "Challenge";
                                              Ty.associated_in_trait
                                                "openvm_stark_backend::config::StarkGenericConfig"
                                                []
                                                []
                                                SC
                                                "Challenger"
                                            ]
                                            (Ty.associated_in_trait
                                              "openvm_stark_backend::config::StarkGenericConfig"
                                              []
                                              []
                                              SC
                                              "Pcs")
                                            "Domain")
                                          "Val"
                                      ]
                                      A
                                      "ReadRecord";
                                    Ty.associated_in_trait
                                      "openvm_circuit::arch::integration_api::VmAdapterChip"
                                      []
                                      [
                                        Ty.associated_in_trait
                                          "p3_commit::domain::PolynomialSpace"
                                          []
                                          []
                                          (Ty.associated_in_trait
                                            "p3_commit::pcs::Pcs"
                                            []
                                            [
                                              Ty.associated_in_trait
                                                "openvm_stark_backend::config::StarkGenericConfig"
                                                []
                                                []
                                                SC
                                                "Challenge";
                                              Ty.associated_in_trait
                                                "openvm_stark_backend::config::StarkGenericConfig"
                                                []
                                                []
                                                SC
                                                "Challenger"
                                            ]
                                            (Ty.associated_in_trait
                                              "openvm_stark_backend::config::StarkGenericConfig"
                                              []
                                              []
                                              SC
                                              "Pcs")
                                            "Domain")
                                          "Val"
                                      ]
                                      A
                                      "WriteRecord";
                                    Ty.associated_in_trait
                                      "openvm_circuit::arch::integration_api::VmCoreChip"
                                      []
                                      [
                                        Ty.associated_in_trait
                                          "p3_commit::domain::PolynomialSpace"
                                          []
                                          []
                                          (Ty.associated_in_trait
                                            "p3_commit::pcs::Pcs"
                                            []
                                            [
                                              Ty.associated_in_trait
                                                "openvm_stark_backend::config::StarkGenericConfig"
                                                []
                                                []
                                                SC
                                                "Challenge";
                                              Ty.associated_in_trait
                                                "openvm_stark_backend::config::StarkGenericConfig"
                                                []
                                                []
                                                SC
                                                "Challenger"
                                            ]
                                            (Ty.associated_in_trait
                                              "openvm_stark_backend::config::StarkGenericConfig"
                                              []
                                              []
                                              SC
                                              "Pcs")
                                            "Domain")
                                          "Val";
                                        Ty.associated_in_trait
                                          "openvm_circuit::arch::integration_api::VmAdapterChip"
                                          []
                                          [
                                            Ty.associated_in_trait
                                              "p3_commit::domain::PolynomialSpace"
                                              []
                                              []
                                              (Ty.associated_in_trait
                                                "p3_commit::pcs::Pcs"
                                                []
                                                [
                                                  Ty.associated_in_trait
                                                    "openvm_stark_backend::config::StarkGenericConfig"
                                                    []
                                                    []
                                                    SC
                                                    "Challenge";
                                                  Ty.associated_in_trait
                                                    "openvm_stark_backend::config::StarkGenericConfig"
                                                    []
                                                    []
                                                    SC
                                                    "Challenger"
                                                ]
                                                (Ty.associated_in_trait
                                                  "openvm_stark_backend::config::StarkGenericConfig"
                                                  []
                                                  []
                                                  SC
                                                  "Pcs")
                                                "Domain")
                                              "Val"
                                          ]
                                          A
                                          "Interface"
                                      ]
                                      C
                                      "Record"
                                  ];
                                Ty.path "alloc::alloc::Global"
                              ],
                            [],
                            [],
                            "into_par_iter",
                            [],
                            []
                          |),
                          [
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                self,
                                "openvm_circuit::arch::integration_api::VmChipWrapper",
                                "records"
                              |)
                            |)
                          ]
                        |)
                      ]
                    |);
                    M.closure
                      (fun γ =>
                        ltac:(M.monadic
                          match γ with
                          | [ α0 ] =>
                            ltac:(M.monadic
                              (M.match_operator (|
                                Ty.tuple [],
                                M.alloc (|
                                  Ty.tuple
                                    [
                                      Ty.apply
                                        (Ty.path "&mut")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "slice")
                                            []
                                            [
                                              Ty.associated_in_trait
                                                "p3_commit::domain::PolynomialSpace"
                                                []
                                                []
                                                (Ty.associated_in_trait
                                                  "p3_commit::pcs::Pcs"
                                                  []
                                                  [
                                                    Ty.associated_in_trait
                                                      "openvm_stark_backend::config::StarkGenericConfig"
                                                      []
                                                      []
                                                      SC
                                                      "Challenge";
                                                    Ty.associated_in_trait
                                                      "openvm_stark_backend::config::StarkGenericConfig"
                                                      []
                                                      []
                                                      SC
                                                      "Challenger"
                                                  ]
                                                  (Ty.associated_in_trait
                                                    "openvm_stark_backend::config::StarkGenericConfig"
                                                    []
                                                    []
                                                    SC
                                                    "Pcs")
                                                  "Domain")
                                                "Val"
                                            ]
                                        ];
                                      Ty.tuple
                                        [
                                          Ty.associated_in_trait
                                            "openvm_circuit::arch::integration_api::VmAdapterChip"
                                            []
                                            [
                                              Ty.associated_in_trait
                                                "p3_commit::domain::PolynomialSpace"
                                                []
                                                []
                                                (Ty.associated_in_trait
                                                  "p3_commit::pcs::Pcs"
                                                  []
                                                  [
                                                    Ty.associated_in_trait
                                                      "openvm_stark_backend::config::StarkGenericConfig"
                                                      []
                                                      []
                                                      SC
                                                      "Challenge";
                                                    Ty.associated_in_trait
                                                      "openvm_stark_backend::config::StarkGenericConfig"
                                                      []
                                                      []
                                                      SC
                                                      "Challenger"
                                                  ]
                                                  (Ty.associated_in_trait
                                                    "openvm_stark_backend::config::StarkGenericConfig"
                                                    []
                                                    []
                                                    SC
                                                    "Pcs")
                                                  "Domain")
                                                "Val"
                                            ]
                                            A
                                            "ReadRecord";
                                          Ty.associated_in_trait
                                            "openvm_circuit::arch::integration_api::VmAdapterChip"
                                            []
                                            [
                                              Ty.associated_in_trait
                                                "p3_commit::domain::PolynomialSpace"
                                                []
                                                []
                                                (Ty.associated_in_trait
                                                  "p3_commit::pcs::Pcs"
                                                  []
                                                  [
                                                    Ty.associated_in_trait
                                                      "openvm_stark_backend::config::StarkGenericConfig"
                                                      []
                                                      []
                                                      SC
                                                      "Challenge";
                                                    Ty.associated_in_trait
                                                      "openvm_stark_backend::config::StarkGenericConfig"
                                                      []
                                                      []
                                                      SC
                                                      "Challenger"
                                                  ]
                                                  (Ty.associated_in_trait
                                                    "openvm_stark_backend::config::StarkGenericConfig"
                                                    []
                                                    []
                                                    SC
                                                    "Pcs")
                                                  "Domain")
                                                "Val"
                                            ]
                                            A
                                            "WriteRecord";
                                          Ty.associated_in_trait
                                            "openvm_circuit::arch::integration_api::VmCoreChip"
                                            []
                                            [
                                              Ty.associated_in_trait
                                                "p3_commit::domain::PolynomialSpace"
                                                []
                                                []
                                                (Ty.associated_in_trait
                                                  "p3_commit::pcs::Pcs"
                                                  []
                                                  [
                                                    Ty.associated_in_trait
                                                      "openvm_stark_backend::config::StarkGenericConfig"
                                                      []
                                                      []
                                                      SC
                                                      "Challenge";
                                                    Ty.associated_in_trait
                                                      "openvm_stark_backend::config::StarkGenericConfig"
                                                      []
                                                      []
                                                      SC
                                                      "Challenger"
                                                  ]
                                                  (Ty.associated_in_trait
                                                    "openvm_stark_backend::config::StarkGenericConfig"
                                                    []
                                                    []
                                                    SC
                                                    "Pcs")
                                                  "Domain")
                                                "Val";
                                              Ty.associated_in_trait
                                                "openvm_circuit::arch::integration_api::VmAdapterChip"
                                                []
                                                [
                                                  Ty.associated_in_trait
                                                    "p3_commit::domain::PolynomialSpace"
                                                    []
                                                    []
                                                    (Ty.associated_in_trait
                                                      "p3_commit::pcs::Pcs"
                                                      []
                                                      [
                                                        Ty.associated_in_trait
                                                          "openvm_stark_backend::config::StarkGenericConfig"
                                                          []
                                                          []
                                                          SC
                                                          "Challenge";
                                                        Ty.associated_in_trait
                                                          "openvm_stark_backend::config::StarkGenericConfig"
                                                          []
                                                          []
                                                          SC
                                                          "Challenger"
                                                      ]
                                                      (Ty.associated_in_trait
                                                        "openvm_stark_backend::config::StarkGenericConfig"
                                                        []
                                                        []
                                                        SC
                                                        "Pcs")
                                                      "Domain")
                                                    "Val"
                                                ]
                                                A
                                                "Interface"
                                            ]
                                            C
                                            "Record"
                                        ]
                                    ],
                                  α0
                                |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                      let row_slice :=
                                        M.copy (|
                                          Ty.apply
                                            (Ty.path "&mut")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "slice")
                                                []
                                                [
                                                  Ty.associated_in_trait
                                                    "p3_commit::domain::PolynomialSpace"
                                                    []
                                                    []
                                                    (Ty.associated_in_trait
                                                      "p3_commit::pcs::Pcs"
                                                      []
                                                      [
                                                        Ty.associated_in_trait
                                                          "openvm_stark_backend::config::StarkGenericConfig"
                                                          []
                                                          []
                                                          SC
                                                          "Challenge";
                                                        Ty.associated_in_trait
                                                          "openvm_stark_backend::config::StarkGenericConfig"
                                                          []
                                                          []
                                                          SC
                                                          "Challenger"
                                                      ]
                                                      (Ty.associated_in_trait
                                                        "openvm_stark_backend::config::StarkGenericConfig"
                                                        []
                                                        []
                                                        SC
                                                        "Pcs")
                                                      "Domain")
                                                    "Val"
                                                ]
                                            ],
                                          γ0_0
                                        |) in
                                      let record :=
                                        M.copy (|
                                          Ty.tuple
                                            [
                                              Ty.associated_in_trait
                                                "openvm_circuit::arch::integration_api::VmAdapterChip"
                                                []
                                                [
                                                  Ty.associated_in_trait
                                                    "p3_commit::domain::PolynomialSpace"
                                                    []
                                                    []
                                                    (Ty.associated_in_trait
                                                      "p3_commit::pcs::Pcs"
                                                      []
                                                      [
                                                        Ty.associated_in_trait
                                                          "openvm_stark_backend::config::StarkGenericConfig"
                                                          []
                                                          []
                                                          SC
                                                          "Challenge";
                                                        Ty.associated_in_trait
                                                          "openvm_stark_backend::config::StarkGenericConfig"
                                                          []
                                                          []
                                                          SC
                                                          "Challenger"
                                                      ]
                                                      (Ty.associated_in_trait
                                                        "openvm_stark_backend::config::StarkGenericConfig"
                                                        []
                                                        []
                                                        SC
                                                        "Pcs")
                                                      "Domain")
                                                    "Val"
                                                ]
                                                A
                                                "ReadRecord";
                                              Ty.associated_in_trait
                                                "openvm_circuit::arch::integration_api::VmAdapterChip"
                                                []
                                                [
                                                  Ty.associated_in_trait
                                                    "p3_commit::domain::PolynomialSpace"
                                                    []
                                                    []
                                                    (Ty.associated_in_trait
                                                      "p3_commit::pcs::Pcs"
                                                      []
                                                      [
                                                        Ty.associated_in_trait
                                                          "openvm_stark_backend::config::StarkGenericConfig"
                                                          []
                                                          []
                                                          SC
                                                          "Challenge";
                                                        Ty.associated_in_trait
                                                          "openvm_stark_backend::config::StarkGenericConfig"
                                                          []
                                                          []
                                                          SC
                                                          "Challenger"
                                                      ]
                                                      (Ty.associated_in_trait
                                                        "openvm_stark_backend::config::StarkGenericConfig"
                                                        []
                                                        []
                                                        SC
                                                        "Pcs")
                                                      "Domain")
                                                    "Val"
                                                ]
                                                A
                                                "WriteRecord";
                                              Ty.associated_in_trait
                                                "openvm_circuit::arch::integration_api::VmCoreChip"
                                                []
                                                [
                                                  Ty.associated_in_trait
                                                    "p3_commit::domain::PolynomialSpace"
                                                    []
                                                    []
                                                    (Ty.associated_in_trait
                                                      "p3_commit::pcs::Pcs"
                                                      []
                                                      [
                                                        Ty.associated_in_trait
                                                          "openvm_stark_backend::config::StarkGenericConfig"
                                                          []
                                                          []
                                                          SC
                                                          "Challenge";
                                                        Ty.associated_in_trait
                                                          "openvm_stark_backend::config::StarkGenericConfig"
                                                          []
                                                          []
                                                          SC
                                                          "Challenger"
                                                      ]
                                                      (Ty.associated_in_trait
                                                        "openvm_stark_backend::config::StarkGenericConfig"
                                                        []
                                                        []
                                                        SC
                                                        "Pcs")
                                                      "Domain")
                                                    "Val";
                                                  Ty.associated_in_trait
                                                    "openvm_circuit::arch::integration_api::VmAdapterChip"
                                                    []
                                                    [
                                                      Ty.associated_in_trait
                                                        "p3_commit::domain::PolynomialSpace"
                                                        []
                                                        []
                                                        (Ty.associated_in_trait
                                                          "p3_commit::pcs::Pcs"
                                                          []
                                                          [
                                                            Ty.associated_in_trait
                                                              "openvm_stark_backend::config::StarkGenericConfig"
                                                              []
                                                              []
                                                              SC
                                                              "Challenge";
                                                            Ty.associated_in_trait
                                                              "openvm_stark_backend::config::StarkGenericConfig"
                                                              []
                                                              []
                                                              SC
                                                              "Challenger"
                                                          ]
                                                          (Ty.associated_in_trait
                                                            "openvm_stark_backend::config::StarkGenericConfig"
                                                            []
                                                            []
                                                            SC
                                                            "Pcs")
                                                          "Domain")
                                                        "Val"
                                                    ]
                                                    A
                                                    "Interface"
                                                ]
                                                C
                                                "Record"
                                            ],
                                          γ0_1
                                        |) in
                                      M.match_operator (|
                                        Ty.tuple [],
                                        M.alloc (|
                                          Ty.tuple
                                            [
                                              Ty.apply
                                                (Ty.path "&mut")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "slice")
                                                    []
                                                    [
                                                      Ty.associated_in_trait
                                                        "p3_commit::domain::PolynomialSpace"
                                                        []
                                                        []
                                                        (Ty.associated_in_trait
                                                          "p3_commit::pcs::Pcs"
                                                          []
                                                          [
                                                            Ty.associated_in_trait
                                                              "openvm_stark_backend::config::StarkGenericConfig"
                                                              []
                                                              []
                                                              SC
                                                              "Challenge";
                                                            Ty.associated_in_trait
                                                              "openvm_stark_backend::config::StarkGenericConfig"
                                                              []
                                                              []
                                                              SC
                                                              "Challenger"
                                                          ]
                                                          (Ty.associated_in_trait
                                                            "openvm_stark_backend::config::StarkGenericConfig"
                                                            []
                                                            []
                                                            SC
                                                            "Pcs")
                                                          "Domain")
                                                        "Val"
                                                    ]
                                                ];
                                              Ty.apply
                                                (Ty.path "&mut")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "slice")
                                                    []
                                                    [
                                                      Ty.associated_in_trait
                                                        "p3_commit::domain::PolynomialSpace"
                                                        []
                                                        []
                                                        (Ty.associated_in_trait
                                                          "p3_commit::pcs::Pcs"
                                                          []
                                                          [
                                                            Ty.associated_in_trait
                                                              "openvm_stark_backend::config::StarkGenericConfig"
                                                              []
                                                              []
                                                              SC
                                                              "Challenge";
                                                            Ty.associated_in_trait
                                                              "openvm_stark_backend::config::StarkGenericConfig"
                                                              []
                                                              []
                                                              SC
                                                              "Challenger"
                                                          ]
                                                          (Ty.associated_in_trait
                                                            "openvm_stark_backend::config::StarkGenericConfig"
                                                            []
                                                            []
                                                            SC
                                                            "Pcs")
                                                          "Domain")
                                                        "Val"
                                                    ]
                                                ]
                                            ],
                                          M.call_closure (|
                                            Ty.tuple
                                              [
                                                Ty.apply
                                                  (Ty.path "&mut")
                                                  []
                                                  [
                                                    Ty.apply
                                                      (Ty.path "slice")
                                                      []
                                                      [
                                                        Ty.associated_in_trait
                                                          "p3_commit::domain::PolynomialSpace"
                                                          []
                                                          []
                                                          (Ty.associated_in_trait
                                                            "p3_commit::pcs::Pcs"
                                                            []
                                                            [
                                                              Ty.associated_in_trait
                                                                "openvm_stark_backend::config::StarkGenericConfig"
                                                                []
                                                                []
                                                                SC
                                                                "Challenge";
                                                              Ty.associated_in_trait
                                                                "openvm_stark_backend::config::StarkGenericConfig"
                                                                []
                                                                []
                                                                SC
                                                                "Challenger"
                                                            ]
                                                            (Ty.associated_in_trait
                                                              "openvm_stark_backend::config::StarkGenericConfig"
                                                              []
                                                              []
                                                              SC
                                                              "Pcs")
                                                            "Domain")
                                                          "Val"
                                                      ]
                                                  ];
                                                Ty.apply
                                                  (Ty.path "&mut")
                                                  []
                                                  [
                                                    Ty.apply
                                                      (Ty.path "slice")
                                                      []
                                                      [
                                                        Ty.associated_in_trait
                                                          "p3_commit::domain::PolynomialSpace"
                                                          []
                                                          []
                                                          (Ty.associated_in_trait
                                                            "p3_commit::pcs::Pcs"
                                                            []
                                                            [
                                                              Ty.associated_in_trait
                                                                "openvm_stark_backend::config::StarkGenericConfig"
                                                                []
                                                                []
                                                                SC
                                                                "Challenge";
                                                              Ty.associated_in_trait
                                                                "openvm_stark_backend::config::StarkGenericConfig"
                                                                []
                                                                []
                                                                SC
                                                                "Challenger"
                                                            ]
                                                            (Ty.associated_in_trait
                                                              "openvm_stark_backend::config::StarkGenericConfig"
                                                              []
                                                              []
                                                              SC
                                                              "Pcs")
                                                            "Domain")
                                                          "Val"
                                                      ]
                                                  ]
                                              ],
                                            M.get_associated_function (|
                                              Ty.apply
                                                (Ty.path "slice")
                                                []
                                                [
                                                  Ty.associated_in_trait
                                                    "p3_commit::domain::PolynomialSpace"
                                                    []
                                                    []
                                                    (Ty.associated_in_trait
                                                      "p3_commit::pcs::Pcs"
                                                      []
                                                      [
                                                        Ty.associated_in_trait
                                                          "openvm_stark_backend::config::StarkGenericConfig"
                                                          []
                                                          []
                                                          SC
                                                          "Challenge";
                                                        Ty.associated_in_trait
                                                          "openvm_stark_backend::config::StarkGenericConfig"
                                                          []
                                                          []
                                                          SC
                                                          "Challenger"
                                                      ]
                                                      (Ty.associated_in_trait
                                                        "openvm_stark_backend::config::StarkGenericConfig"
                                                        []
                                                        []
                                                        SC
                                                        "Pcs")
                                                      "Domain")
                                                    "Val"
                                                ],
                                              "split_at_mut",
                                              [],
                                              []
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.MutRef,
                                                M.deref (| M.read (| row_slice |) |)
                                              |);
                                              M.read (| adapter_width |)
                                            ]
                                          |)
                                        |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let γ0_0 :=
                                                M.SubPointer.get_tuple_field (| γ, 0 |) in
                                              let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                              let adapter_row :=
                                                M.copy (|
                                                  Ty.apply
                                                    (Ty.path "&mut")
                                                    []
                                                    [
                                                      Ty.apply
                                                        (Ty.path "slice")
                                                        []
                                                        [
                                                          Ty.associated_in_trait
                                                            "p3_commit::domain::PolynomialSpace"
                                                            []
                                                            []
                                                            (Ty.associated_in_trait
                                                              "p3_commit::pcs::Pcs"
                                                              []
                                                              [
                                                                Ty.associated_in_trait
                                                                  "openvm_stark_backend::config::StarkGenericConfig"
                                                                  []
                                                                  []
                                                                  SC
                                                                  "Challenge";
                                                                Ty.associated_in_trait
                                                                  "openvm_stark_backend::config::StarkGenericConfig"
                                                                  []
                                                                  []
                                                                  SC
                                                                  "Challenger"
                                                              ]
                                                              (Ty.associated_in_trait
                                                                "openvm_stark_backend::config::StarkGenericConfig"
                                                                []
                                                                []
                                                                SC
                                                                "Pcs")
                                                              "Domain")
                                                            "Val"
                                                        ]
                                                    ],
                                                  γ0_0
                                                |) in
                                              let core_row :=
                                                M.copy (|
                                                  Ty.apply
                                                    (Ty.path "&mut")
                                                    []
                                                    [
                                                      Ty.apply
                                                        (Ty.path "slice")
                                                        []
                                                        [
                                                          Ty.associated_in_trait
                                                            "p3_commit::domain::PolynomialSpace"
                                                            []
                                                            []
                                                            (Ty.associated_in_trait
                                                              "p3_commit::pcs::Pcs"
                                                              []
                                                              [
                                                                Ty.associated_in_trait
                                                                  "openvm_stark_backend::config::StarkGenericConfig"
                                                                  []
                                                                  []
                                                                  SC
                                                                  "Challenge";
                                                                Ty.associated_in_trait
                                                                  "openvm_stark_backend::config::StarkGenericConfig"
                                                                  []
                                                                  []
                                                                  SC
                                                                  "Challenger"
                                                              ]
                                                              (Ty.associated_in_trait
                                                                "openvm_stark_backend::config::StarkGenericConfig"
                                                                []
                                                                []
                                                                SC
                                                                "Pcs")
                                                              "Domain")
                                                            "Val"
                                                        ]
                                                    ],
                                                  γ0_1
                                                |) in
                                              M.read (|
                                                let~ _ : Ty.tuple [] :=
                                                  M.call_closure (|
                                                    Ty.tuple [],
                                                    M.get_trait_method (|
                                                      "openvm_circuit::arch::integration_api::VmAdapterChip",
                                                      A,
                                                      [],
                                                      [
                                                        Ty.associated_in_trait
                                                          "p3_commit::domain::PolynomialSpace"
                                                          []
                                                          []
                                                          (Ty.associated_in_trait
                                                            "p3_commit::pcs::Pcs"
                                                            []
                                                            [
                                                              Ty.associated_in_trait
                                                                "openvm_stark_backend::config::StarkGenericConfig"
                                                                []
                                                                []
                                                                SC
                                                                "Challenge";
                                                              Ty.associated_in_trait
                                                                "openvm_stark_backend::config::StarkGenericConfig"
                                                                []
                                                                []
                                                                SC
                                                                "Challenger"
                                                            ]
                                                            (Ty.associated_in_trait
                                                              "openvm_stark_backend::config::StarkGenericConfig"
                                                              []
                                                              []
                                                              SC
                                                              "Pcs")
                                                            "Domain")
                                                          "Val"
                                                      ],
                                                      "generate_trace_row",
                                                      [],
                                                      []
                                                    |),
                                                    [
                                                      M.borrow (|
                                                        Pointer.Kind.Ref,
                                                        M.SubPointer.get_struct_record_field (|
                                                          self,
                                                          "openvm_circuit::arch::integration_api::VmChipWrapper",
                                                          "adapter"
                                                        |)
                                                      |);
                                                      M.borrow (|
                                                        Pointer.Kind.MutRef,
                                                        M.deref (| M.read (| adapter_row |) |)
                                                      |);
                                                      M.read (|
                                                        M.SubPointer.get_tuple_field (| record, 0 |)
                                                      |);
                                                      M.read (|
                                                        M.SubPointer.get_tuple_field (| record, 1 |)
                                                      |);
                                                      M.borrow (|
                                                        Pointer.Kind.Ref,
                                                        M.deref (|
                                                          M.call_closure (|
                                                            Ty.apply
                                                              (Ty.path "&")
                                                              []
                                                              [
                                                                Ty.apply
                                                                  (Ty.path
                                                                    "openvm_circuit::system::memory::offline::OfflineMemory")
                                                                  []
                                                                  [
                                                                    Ty.associated_in_trait
                                                                      "p3_commit::domain::PolynomialSpace"
                                                                      []
                                                                      []
                                                                      (Ty.associated_in_trait
                                                                        "p3_commit::pcs::Pcs"
                                                                        []
                                                                        [
                                                                          Ty.associated_in_trait
                                                                            "openvm_stark_backend::config::StarkGenericConfig"
                                                                            []
                                                                            []
                                                                            SC
                                                                            "Challenge";
                                                                          Ty.associated_in_trait
                                                                            "openvm_stark_backend::config::StarkGenericConfig"
                                                                            []
                                                                            []
                                                                            SC
                                                                            "Challenger"
                                                                        ]
                                                                        (Ty.associated_in_trait
                                                                          "openvm_stark_backend::config::StarkGenericConfig"
                                                                          []
                                                                          []
                                                                          SC
                                                                          "Pcs")
                                                                        "Domain")
                                                                      "Val"
                                                                  ]
                                                              ],
                                                            M.get_trait_method (|
                                                              "core::ops::deref::Deref",
                                                              Ty.apply
                                                                (Ty.path
                                                                  "std::sync::mutex::MutexGuard")
                                                                []
                                                                [
                                                                  Ty.apply
                                                                    (Ty.path
                                                                      "openvm_circuit::system::memory::offline::OfflineMemory")
                                                                    []
                                                                    [
                                                                      Ty.associated_in_trait
                                                                        "p3_commit::domain::PolynomialSpace"
                                                                        []
                                                                        []
                                                                        (Ty.associated_in_trait
                                                                          "p3_commit::pcs::Pcs"
                                                                          []
                                                                          [
                                                                            Ty.associated_in_trait
                                                                              "openvm_stark_backend::config::StarkGenericConfig"
                                                                              []
                                                                              []
                                                                              SC
                                                                              "Challenge";
                                                                            Ty.associated_in_trait
                                                                              "openvm_stark_backend::config::StarkGenericConfig"
                                                                              []
                                                                              []
                                                                              SC
                                                                              "Challenger"
                                                                          ]
                                                                          (Ty.associated_in_trait
                                                                            "openvm_stark_backend::config::StarkGenericConfig"
                                                                            []
                                                                            []
                                                                            SC
                                                                            "Pcs")
                                                                          "Domain")
                                                                        "Val"
                                                                    ]
                                                                ],
                                                              [],
                                                              [],
                                                              "deref",
                                                              [],
                                                              []
                                                            |),
                                                            [
                                                              M.borrow (|
                                                                Pointer.Kind.Ref,
                                                                M.deref (|
                                                                  M.borrow (|
                                                                    Pointer.Kind.Ref,
                                                                    memory
                                                                  |)
                                                                |)
                                                              |)
                                                            ]
                                                          |)
                                                        |)
                                                      |)
                                                    ]
                                                  |) in
                                                let~ _ : Ty.tuple [] :=
                                                  M.call_closure (|
                                                    Ty.tuple [],
                                                    M.get_trait_method (|
                                                      "openvm_circuit::arch::integration_api::VmCoreChip",
                                                      C,
                                                      [],
                                                      [
                                                        Ty.associated_in_trait
                                                          "p3_commit::domain::PolynomialSpace"
                                                          []
                                                          []
                                                          (Ty.associated_in_trait
                                                            "p3_commit::pcs::Pcs"
                                                            []
                                                            [
                                                              Ty.associated_in_trait
                                                                "openvm_stark_backend::config::StarkGenericConfig"
                                                                []
                                                                []
                                                                SC
                                                                "Challenge";
                                                              Ty.associated_in_trait
                                                                "openvm_stark_backend::config::StarkGenericConfig"
                                                                []
                                                                []
                                                                SC
                                                                "Challenger"
                                                            ]
                                                            (Ty.associated_in_trait
                                                              "openvm_stark_backend::config::StarkGenericConfig"
                                                              []
                                                              []
                                                              SC
                                                              "Pcs")
                                                            "Domain")
                                                          "Val";
                                                        Ty.associated_in_trait
                                                          "openvm_circuit::arch::integration_api::VmAdapterChip"
                                                          []
                                                          [
                                                            Ty.associated_in_trait
                                                              "p3_commit::domain::PolynomialSpace"
                                                              []
                                                              []
                                                              (Ty.associated_in_trait
                                                                "p3_commit::pcs::Pcs"
                                                                []
                                                                [
                                                                  Ty.associated_in_trait
                                                                    "openvm_stark_backend::config::StarkGenericConfig"
                                                                    []
                                                                    []
                                                                    SC
                                                                    "Challenge";
                                                                  Ty.associated_in_trait
                                                                    "openvm_stark_backend::config::StarkGenericConfig"
                                                                    []
                                                                    []
                                                                    SC
                                                                    "Challenger"
                                                                ]
                                                                (Ty.associated_in_trait
                                                                  "openvm_stark_backend::config::StarkGenericConfig"
                                                                  []
                                                                  []
                                                                  SC
                                                                  "Pcs")
                                                                "Domain")
                                                              "Val"
                                                          ]
                                                          A
                                                          "Interface"
                                                      ],
                                                      "generate_trace_row",
                                                      [],
                                                      []
                                                    |),
                                                    [
                                                      M.borrow (|
                                                        Pointer.Kind.Ref,
                                                        M.SubPointer.get_struct_record_field (|
                                                          self,
                                                          "openvm_circuit::arch::integration_api::VmChipWrapper",
                                                          "core"
                                                        |)
                                                      |);
                                                      M.borrow (|
                                                        Pointer.Kind.MutRef,
                                                        M.deref (| M.read (| core_row |) |)
                                                      |);
                                                      M.read (|
                                                        M.SubPointer.get_tuple_field (| record, 2 |)
                                                      |)
                                                    ]
                                                  |) in
                                                M.alloc (| Ty.tuple [], Value.Tuple [] |)
                                              |)))
                                        ]
                                      |)))
                                ]
                              |)))
                          | _ => M.impossible "wrong number of arguments"
                          end))
                  ]
                |) in
              let~ trace :
                  Ty.apply
                    (Ty.path "p3_matrix::dense::DenseMatrix")
                    []
                    [
                      Ty.associated_in_trait
                        "p3_commit::domain::PolynomialSpace"
                        []
                        []
                        (Ty.associated_in_trait
                          "p3_commit::pcs::Pcs"
                          []
                          [
                            Ty.associated_in_trait
                              "openvm_stark_backend::config::StarkGenericConfig"
                              []
                              []
                              SC
                              "Challenge";
                            Ty.associated_in_trait
                              "openvm_stark_backend::config::StarkGenericConfig"
                              []
                              []
                              SC
                              "Challenger"
                          ]
                          (Ty.associated_in_trait
                            "openvm_stark_backend::config::StarkGenericConfig"
                            []
                            []
                            SC
                            "Pcs")
                          "Domain")
                        "Val";
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        []
                        [
                          Ty.associated_in_trait
                            "p3_commit::domain::PolynomialSpace"
                            []
                            []
                            (Ty.associated_in_trait
                              "p3_commit::pcs::Pcs"
                              []
                              [
                                Ty.associated_in_trait
                                  "openvm_stark_backend::config::StarkGenericConfig"
                                  []
                                  []
                                  SC
                                  "Challenge";
                                Ty.associated_in_trait
                                  "openvm_stark_backend::config::StarkGenericConfig"
                                  []
                                  []
                                  SC
                                  "Challenger"
                              ]
                              (Ty.associated_in_trait
                                "openvm_stark_backend::config::StarkGenericConfig"
                                []
                                []
                                SC
                                "Pcs")
                              "Domain")
                            "Val";
                          Ty.path "alloc::alloc::Global"
                        ]
                    ] :=
                M.call_closure (|
                  Ty.apply
                    (Ty.path "p3_matrix::dense::DenseMatrix")
                    []
                    [
                      Ty.associated_in_trait
                        "p3_commit::domain::PolynomialSpace"
                        []
                        []
                        (Ty.associated_in_trait
                          "p3_commit::pcs::Pcs"
                          []
                          [
                            Ty.associated_in_trait
                              "openvm_stark_backend::config::StarkGenericConfig"
                              []
                              []
                              SC
                              "Challenge";
                            Ty.associated_in_trait
                              "openvm_stark_backend::config::StarkGenericConfig"
                              []
                              []
                              SC
                              "Challenger"
                          ]
                          (Ty.associated_in_trait
                            "openvm_stark_backend::config::StarkGenericConfig"
                            []
                            []
                            SC
                            "Pcs")
                          "Domain")
                        "Val";
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        []
                        [
                          Ty.associated_in_trait
                            "p3_commit::domain::PolynomialSpace"
                            []
                            []
                            (Ty.associated_in_trait
                              "p3_commit::pcs::Pcs"
                              []
                              [
                                Ty.associated_in_trait
                                  "openvm_stark_backend::config::StarkGenericConfig"
                                  []
                                  []
                                  SC
                                  "Challenge";
                                Ty.associated_in_trait
                                  "openvm_stark_backend::config::StarkGenericConfig"
                                  []
                                  []
                                  SC
                                  "Challenger"
                              ]
                              (Ty.associated_in_trait
                                "openvm_stark_backend::config::StarkGenericConfig"
                                []
                                []
                                SC
                                "Pcs")
                              "Domain")
                            "Val";
                          Ty.path "alloc::alloc::Global"
                        ]
                    ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "p3_matrix::dense::DenseMatrix")
                      []
                      [
                        Ty.associated_in_trait
                          "p3_commit::domain::PolynomialSpace"
                          []
                          []
                          (Ty.associated_in_trait
                            "p3_commit::pcs::Pcs"
                            []
                            [
                              Ty.associated_in_trait
                                "openvm_stark_backend::config::StarkGenericConfig"
                                []
                                []
                                SC
                                "Challenge";
                              Ty.associated_in_trait
                                "openvm_stark_backend::config::StarkGenericConfig"
                                []
                                []
                                SC
                                "Challenger"
                            ]
                            (Ty.associated_in_trait
                              "openvm_stark_backend::config::StarkGenericConfig"
                              []
                              []
                              SC
                              "Pcs")
                            "Domain")
                          "Val";
                        Ty.apply
                          (Ty.path "alloc::vec::Vec")
                          []
                          [
                            Ty.associated_in_trait
                              "p3_commit::domain::PolynomialSpace"
                              []
                              []
                              (Ty.associated_in_trait
                                "p3_commit::pcs::Pcs"
                                []
                                [
                                  Ty.associated_in_trait
                                    "openvm_stark_backend::config::StarkGenericConfig"
                                    []
                                    []
                                    SC
                                    "Challenge";
                                  Ty.associated_in_trait
                                    "openvm_stark_backend::config::StarkGenericConfig"
                                    []
                                    []
                                    SC
                                    "Challenger"
                                ]
                                (Ty.associated_in_trait
                                  "openvm_stark_backend::config::StarkGenericConfig"
                                  []
                                  []
                                  SC
                                  "Pcs")
                                "Domain")
                              "Val";
                            Ty.path "alloc::alloc::Global"
                          ]
                      ],
                    "new",
                    [],
                    []
                  |),
                  [ M.read (| values |); M.read (| width |) ]
                |) in
              let~ _ : Ty.tuple [] :=
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "openvm_circuit::arch::integration_api::VmCoreChip",
                    C,
                    [],
                    [
                      Ty.associated_in_trait
                        "p3_commit::domain::PolynomialSpace"
                        []
                        []
                        (Ty.associated_in_trait
                          "p3_commit::pcs::Pcs"
                          []
                          [
                            Ty.associated_in_trait
                              "openvm_stark_backend::config::StarkGenericConfig"
                              []
                              []
                              SC
                              "Challenge";
                            Ty.associated_in_trait
                              "openvm_stark_backend::config::StarkGenericConfig"
                              []
                              []
                              SC
                              "Challenger"
                          ]
                          (Ty.associated_in_trait
                            "openvm_stark_backend::config::StarkGenericConfig"
                            []
                            []
                            SC
                            "Pcs")
                          "Domain")
                        "Val";
                      Ty.associated_in_trait
                        "openvm_circuit::arch::integration_api::VmAdapterChip"
                        []
                        [
                          Ty.associated_in_trait
                            "p3_commit::domain::PolynomialSpace"
                            []
                            []
                            (Ty.associated_in_trait
                              "p3_commit::pcs::Pcs"
                              []
                              [
                                Ty.associated_in_trait
                                  "openvm_stark_backend::config::StarkGenericConfig"
                                  []
                                  []
                                  SC
                                  "Challenge";
                                Ty.associated_in_trait
                                  "openvm_stark_backend::config::StarkGenericConfig"
                                  []
                                  []
                                  SC
                                  "Challenger"
                              ]
                              (Ty.associated_in_trait
                                "openvm_stark_backend::config::StarkGenericConfig"
                                []
                                []
                                SC
                                "Pcs")
                              "Domain")
                            "Val"
                        ]
                        A
                        "Interface"
                    ],
                    "finalize",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        self,
                        "openvm_circuit::arch::integration_api::VmChipWrapper",
                        "core"
                      |)
                    |);
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.deref (| M.borrow (| Pointer.Kind.MutRef, trace |) |)
                    |);
                    M.read (| num_records |)
                  ]
                |) in
              M.alloc (|
                Ty.apply (Ty.path "openvm_stark_backend::prover::types::AirProofInput") [] [ SC ],
                M.call_closure (|
                  Ty.apply (Ty.path "openvm_stark_backend::prover::types::AirProofInput") [] [ SC ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "openvm_stark_backend::prover::types::AirProofInput")
                      []
                      [ SC ],
                    "simple",
                    [],
                    []
                  |),
                  [
                    M.read (| trace |);
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        []
                        [
                          Ty.associated_in_trait
                            "p3_commit::domain::PolynomialSpace"
                            []
                            []
                            (Ty.associated_in_trait
                              "p3_commit::pcs::Pcs"
                              []
                              [
                                Ty.associated_in_trait
                                  "openvm_stark_backend::config::StarkGenericConfig"
                                  []
                                  []
                                  SC
                                  "Challenge";
                                Ty.associated_in_trait
                                  "openvm_stark_backend::config::StarkGenericConfig"
                                  []
                                  []
                                  SC
                                  "Challenger"
                              ]
                              (Ty.associated_in_trait
                                "openvm_stark_backend::config::StarkGenericConfig"
                                []
                                []
                                SC
                                "Pcs")
                              "Domain")
                            "Val";
                          Ty.path "alloc::alloc::Global"
                        ],
                      M.get_trait_method (|
                        "openvm_circuit::arch::integration_api::VmCoreChip",
                        C,
                        [],
                        [
                          Ty.associated_in_trait
                            "p3_commit::domain::PolynomialSpace"
                            []
                            []
                            (Ty.associated_in_trait
                              "p3_commit::pcs::Pcs"
                              []
                              [
                                Ty.associated_in_trait
                                  "openvm_stark_backend::config::StarkGenericConfig"
                                  []
                                  []
                                  SC
                                  "Challenge";
                                Ty.associated_in_trait
                                  "openvm_stark_backend::config::StarkGenericConfig"
                                  []
                                  []
                                  SC
                                  "Challenger"
                              ]
                              (Ty.associated_in_trait
                                "openvm_stark_backend::config::StarkGenericConfig"
                                []
                                []
                                SC
                                "Pcs")
                              "Domain")
                            "Val";
                          Ty.associated_in_trait
                            "openvm_circuit::arch::integration_api::VmAdapterChip"
                            []
                            [
                              Ty.associated_in_trait
                                "p3_commit::domain::PolynomialSpace"
                                []
                                []
                                (Ty.associated_in_trait
                                  "p3_commit::pcs::Pcs"
                                  []
                                  [
                                    Ty.associated_in_trait
                                      "openvm_stark_backend::config::StarkGenericConfig"
                                      []
                                      []
                                      SC
                                      "Challenge";
                                    Ty.associated_in_trait
                                      "openvm_stark_backend::config::StarkGenericConfig"
                                      []
                                      []
                                      SC
                                      "Challenger"
                                  ]
                                  (Ty.associated_in_trait
                                    "openvm_stark_backend::config::StarkGenericConfig"
                                    []
                                    []
                                    SC
                                    "Pcs")
                                  "Domain")
                                "Val"
                            ]
                            A
                            "Interface"
                        ],
                        "generate_public_values",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            self,
                            "openvm_circuit::arch::integration_api::VmChipWrapper",
                            "core"
                          |)
                        |)
                      ]
                    |)
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (SC A C : Ty.t),
        M.IsTraitInstance
          "openvm_stark_backend::chip::Chip"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ SC ]
          (Self SC A C)
          (* Instance *)
          [
            ("air", InstanceField.Method (air SC A C));
            ("generate_air_proof_input", InstanceField.Method (generate_air_proof_input SC A C))
          ].
    End Impl_openvm_stark_backend_chip_Chip_where_openvm_stark_backend_config_StarkGenericConfig_SC_where_p3_field_field_PrimeField32_associated_in_trait_p3_commit_domain_PolynomialSpace___associated_in_trait_p3_commit_pcs_Pcs__associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenge_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenger_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Pcs_Domain_Val_where_openvm_circuit_arch_integration_api_VmAdapterChip_A_associated_in_trait_p3_commit_domain_PolynomialSpace___associated_in_trait_p3_commit_pcs_Pcs__associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenge_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenger_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Pcs_Domain_Val_where_core_marker_Send_A_where_core_marker_Sync_A_where_openvm_circuit_arch_integration_api_VmCoreChip_C_associated_in_trait_p3_commit_domain_PolynomialSpace___associated_in_trait_p3_commit_pcs_Pcs__associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenge_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenger_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Pcs_Domain_Val_associated_in_trait_openvm_circuit_arch_integration_api_VmAdapterChip__associated_in_trait_p3_commit_domain_PolynomialSpace___associated_in_trait_p3_commit_pcs_Pcs__associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenge_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenger_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Pcs_Domain_Val_A_Interface_where_core_marker_Send_C_where_core_marker_Sync_C_where_core_marker_Send_associated_in_trait_openvm_circuit_arch_integration_api_VmAdapterChip__associated_in_trait_p3_commit_domain_PolynomialSpace___associated_in_trait_p3_commit_pcs_Pcs__associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenge_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenger_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Pcs_Domain_Val_A_Air_where_core_marker_Sync_associated_in_trait_openvm_circuit_arch_integration_api_VmAdapterChip__associated_in_trait_p3_commit_domain_PolynomialSpace___associated_in_trait_p3_commit_pcs_Pcs__associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenge_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenger_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Pcs_Domain_Val_A_Air_where_openvm_circuit_arch_integration_api_VmAdapterAir_associated_in_trait_openvm_circuit_arch_integration_api_VmAdapterChip__associated_in_trait_p3_commit_domain_PolynomialSpace___associated_in_trait_p3_commit_pcs_Pcs__associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenge_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenger_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Pcs_Domain_Val_A_Air_openvm_stark_backend_air_builders_symbolic_SymbolicRapBuilder_associated_in_trait_p3_commit_domain_PolynomialSpace___associated_in_trait_p3_commit_pcs_Pcs__associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenge_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenger_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Pcs_Domain_Val_where_openvm_circuit_arch_integration_api_VmAdapterAir_associated_in_trait_openvm_circuit_arch_integration_api_VmAdapterChip__associated_in_trait_p3_commit_domain_PolynomialSpace___associated_in_trait_p3_commit_pcs_Pcs__associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenge_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenger_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Pcs_Domain_Val_A_Air_openvm_stark_backend_air_builders_debug_DebugConstraintBuilder_SC_where_core_marker_Send_associated_in_trait_openvm_circuit_arch_integration_api_VmCoreChip__associated_in_trait_p3_commit_domain_PolynomialSpace___associated_in_trait_p3_commit_pcs_Pcs__associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenge_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenger_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Pcs_Domain_Val_associated_in_trait_openvm_circuit_arch_integration_api_VmAdapterChip__associated_in_trait_p3_commit_domain_PolynomialSpace___associated_in_trait_p3_commit_pcs_Pcs__associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenge_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenger_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Pcs_Domain_Val_A_Interface_C_Air_where_core_marker_Sync_associated_in_trait_openvm_circuit_arch_integration_api_VmCoreChip__associated_in_trait_p3_commit_domain_PolynomialSpace___associated_in_trait_p3_commit_pcs_Pcs__associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenge_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenger_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Pcs_Domain_Val_associated_in_trait_openvm_circuit_arch_integration_api_VmAdapterChip__associated_in_trait_p3_commit_domain_PolynomialSpace___associated_in_trait_p3_commit_pcs_Pcs__associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenge_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenger_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Pcs_Domain_Val_A_Interface_C_Air_where_openvm_circuit_arch_integration_api_VmCoreAir_associated_in_trait_openvm_circuit_arch_integration_api_VmCoreChip__associated_in_trait_p3_commit_domain_PolynomialSpace___associated_in_trait_p3_commit_pcs_Pcs__associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenge_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenger_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Pcs_Domain_Val_associated_in_trait_openvm_circuit_arch_integration_api_VmAdapterChip__associated_in_trait_p3_commit_domain_PolynomialSpace___associated_in_trait_p3_commit_pcs_Pcs__associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenge_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenger_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Pcs_Domain_Val_A_Interface_C_Air_openvm_stark_backend_air_builders_symbolic_SymbolicRapBuilder_associated_in_trait_p3_commit_domain_PolynomialSpace___associated_in_trait_p3_commit_pcs_Pcs__associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenge_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenger_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Pcs_Domain_Val_associated_in_trait_openvm_circuit_arch_integration_api_VmAdapterAir__openvm_stark_backend_air_builders_symbolic_SymbolicRapBuilder_associated_in_trait_p3_commit_domain_PolynomialSpace___associated_in_trait_p3_commit_pcs_Pcs__associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenge_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenger_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Pcs_Domain_Val_associated_in_trait_openvm_circuit_arch_integration_api_VmAdapterChip__associated_in_trait_p3_commit_domain_PolynomialSpace___associated_in_trait_p3_commit_pcs_Pcs__associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenge_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenger_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Pcs_Domain_Val_A_Air_Interface_where_openvm_circuit_arch_integration_api_VmCoreAir_associated_in_trait_openvm_circuit_arch_integration_api_VmCoreChip__associated_in_trait_p3_commit_domain_PolynomialSpace___associated_in_trait_p3_commit_pcs_Pcs__associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenge_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenger_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Pcs_Domain_Val_associated_in_trait_openvm_circuit_arch_integration_api_VmAdapterChip__associated_in_trait_p3_commit_domain_PolynomialSpace___associated_in_trait_p3_commit_pcs_Pcs__associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenge_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenger_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Pcs_Domain_Val_A_Interface_C_Air_openvm_stark_backend_air_builders_debug_DebugConstraintBuilder_SC_associated_in_trait_openvm_circuit_arch_integration_api_VmAdapterAir__openvm_stark_backend_air_builders_debug_DebugConstraintBuilder_SC_associated_in_trait_openvm_circuit_arch_integration_api_VmAdapterChip__associated_in_trait_p3_commit_domain_PolynomialSpace___associated_in_trait_p3_commit_pcs_Pcs__associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenge_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenger_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Pcs_Domain_Val_A_Air_Interface_SC_for_openvm_circuit_arch_integration_api_VmChipWrapper_associated_in_trait_p3_commit_domain_PolynomialSpace___associated_in_trait_p3_commit_pcs_Pcs__associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenge_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenger_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Pcs_Domain_Val_A_C.
    
    Module Impl_openvm_stark_backend_chip_ChipUsageGetter_where_openvm_circuit_arch_integration_api_VmAdapterChip_A_F_where_core_marker_Sync_A_where_openvm_circuit_arch_integration_api_VmCoreChip_M__F_associated_in_trait_openvm_circuit_arch_integration_api_VmAdapterChip__F_A_Interface_where_core_marker_Sync_M__for_openvm_circuit_arch_integration_api_VmChipWrapper_F_A_M_.
      Definition Self (F A M_ : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "openvm_circuit::arch::integration_api::VmChipWrapper") [] [ F; A; M_ ].
      
      (*
          fn air_name(&self) -> String {
              format!(
                  "<{},{}>",
                  get_air_name(self.adapter.air()),
                  get_air_name(self.core.air())
              )
          }
      *)
      Definition air_name
          (F A M_ : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self F A M_ in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path "openvm_circuit::arch::integration_api::VmChipWrapper")
                      []
                      [ F; A; M_ ]
                  ],
                self
              |) in
            M.call_closure (|
              Ty.path "alloc::string::String",
              M.get_function (| "core::hint::must_use", [], [ Ty.path "alloc::string::String" ] |),
              [
                M.read (|
                  let~ res : Ty.path "alloc::string::String" :=
                    M.call_closure (|
                      Ty.path "alloc::string::String",
                      M.get_function (| "alloc::fmt::format", [], [] |),
                      [
                        M.call_closure (|
                          Ty.path "core::fmt::Arguments",
                          M.get_associated_function (|
                            Ty.path "core::fmt::Arguments",
                            "new_v1",
                            [ Value.Integer IntegerKind.Usize 3; Value.Integer IntegerKind.Usize 2
                            ],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.alloc (|
                                    Ty.apply
                                      (Ty.path "array")
                                      [ Value.Integer IntegerKind.Usize 3 ]
                                      [ Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ],
                                    Value.Array
                                      [ mk_str (| "<" |); mk_str (| "," |); mk_str (| ">" |) ]
                                  |)
                                |)
                              |)
                            |);
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.alloc (|
                                    Ty.apply
                                      (Ty.path "array")
                                      [ Value.Integer IntegerKind.Usize 2 ]
                                      [ Ty.path "core::fmt::rt::Argument" ],
                                    Value.Array
                                      [
                                        M.call_closure (|
                                          Ty.path "core::fmt::rt::Argument",
                                          M.get_associated_function (|
                                            Ty.path "core::fmt::rt::Argument",
                                            "new_display",
                                            [],
                                            [ Ty.path "alloc::string::String" ]
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.alloc (|
                                                    Ty.path "alloc::string::String",
                                                    M.call_closure (|
                                                      Ty.path "alloc::string::String",
                                                      M.get_function (|
                                                        "openvm_stark_backend::rap::get_air_name",
                                                        [],
                                                        [
                                                          Ty.associated_in_trait
                                                            "openvm_circuit::arch::integration_api::VmAdapterChip"
                                                            []
                                                            [ F ]
                                                            A
                                                            "Air"
                                                        ]
                                                      |),
                                                      [
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.deref (|
                                                            M.call_closure (|
                                                              Ty.apply
                                                                (Ty.path "&")
                                                                []
                                                                [
                                                                  Ty.associated_in_trait
                                                                    "openvm_circuit::arch::integration_api::VmAdapterChip"
                                                                    []
                                                                    [ F ]
                                                                    A
                                                                    "Air"
                                                                ],
                                                              M.get_trait_method (|
                                                                "openvm_circuit::arch::integration_api::VmAdapterChip",
                                                                A,
                                                                [],
                                                                [ F ],
                                                                "air",
                                                                [],
                                                                []
                                                              |),
                                                              [
                                                                M.borrow (|
                                                                  Pointer.Kind.Ref,
                                                                  M.SubPointer.get_struct_record_field (|
                                                                    M.deref (| M.read (| self |) |),
                                                                    "openvm_circuit::arch::integration_api::VmChipWrapper",
                                                                    "adapter"
                                                                  |)
                                                                |)
                                                              ]
                                                            |)
                                                          |)
                                                        |)
                                                      ]
                                                    |)
                                                  |)
                                                |)
                                              |)
                                            |)
                                          ]
                                        |);
                                        M.call_closure (|
                                          Ty.path "core::fmt::rt::Argument",
                                          M.get_associated_function (|
                                            Ty.path "core::fmt::rt::Argument",
                                            "new_display",
                                            [],
                                            [ Ty.path "alloc::string::String" ]
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.alloc (|
                                                    Ty.path "alloc::string::String",
                                                    M.call_closure (|
                                                      Ty.path "alloc::string::String",
                                                      M.get_function (|
                                                        "openvm_stark_backend::rap::get_air_name",
                                                        [],
                                                        [
                                                          Ty.associated_in_trait
                                                            "openvm_circuit::arch::integration_api::VmCoreChip"
                                                            []
                                                            [
                                                              F;
                                                              Ty.associated_in_trait
                                                                "openvm_circuit::arch::integration_api::VmAdapterChip"
                                                                []
                                                                [ F ]
                                                                A
                                                                "Interface"
                                                            ]
                                                            M_
                                                            "Air"
                                                        ]
                                                      |),
                                                      [
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.deref (|
                                                            M.call_closure (|
                                                              Ty.apply
                                                                (Ty.path "&")
                                                                []
                                                                [
                                                                  Ty.associated_in_trait
                                                                    "openvm_circuit::arch::integration_api::VmCoreChip"
                                                                    []
                                                                    [
                                                                      F;
                                                                      Ty.associated_in_trait
                                                                        "openvm_circuit::arch::integration_api::VmAdapterChip"
                                                                        []
                                                                        [ F ]
                                                                        A
                                                                        "Interface"
                                                                    ]
                                                                    M_
                                                                    "Air"
                                                                ],
                                                              M.get_trait_method (|
                                                                "openvm_circuit::arch::integration_api::VmCoreChip",
                                                                M_,
                                                                [],
                                                                [
                                                                  F;
                                                                  Ty.associated_in_trait
                                                                    "openvm_circuit::arch::integration_api::VmAdapterChip"
                                                                    []
                                                                    [ F ]
                                                                    A
                                                                    "Interface"
                                                                ],
                                                                "air",
                                                                [],
                                                                []
                                                              |),
                                                              [
                                                                M.borrow (|
                                                                  Pointer.Kind.Ref,
                                                                  M.SubPointer.get_struct_record_field (|
                                                                    M.deref (| M.read (| self |) |),
                                                                    "openvm_circuit::arch::integration_api::VmChipWrapper",
                                                                    "core"
                                                                  |)
                                                                |)
                                                              ]
                                                            |)
                                                          |)
                                                        |)
                                                      ]
                                                    |)
                                                  |)
                                                |)
                                              |)
                                            |)
                                          ]
                                        |)
                                      ]
                                  |)
                                |)
                              |)
                            |)
                          ]
                        |)
                      ]
                    |) in
                  res
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn current_trace_height(&self) -> usize {
              self.records.len()
          }
      *)
      Definition current_trace_height
          (F A M_ : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self F A M_ in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path "openvm_circuit::arch::integration_api::VmChipWrapper")
                      []
                      [ F; A; M_ ]
                  ],
                self
              |) in
            M.call_closure (|
              Ty.path "usize",
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  []
                  [
                    Ty.tuple
                      [
                        Ty.associated_in_trait
                          "openvm_circuit::arch::integration_api::VmAdapterChip"
                          []
                          [ F ]
                          A
                          "ReadRecord";
                        Ty.associated_in_trait
                          "openvm_circuit::arch::integration_api::VmAdapterChip"
                          []
                          [ F ]
                          A
                          "WriteRecord";
                        Ty.associated_in_trait
                          "openvm_circuit::arch::integration_api::VmCoreChip"
                          []
                          [
                            F;
                            Ty.associated_in_trait
                              "openvm_circuit::arch::integration_api::VmAdapterChip"
                              []
                              [ F ]
                              A
                              "Interface"
                          ]
                          M_
                          "Record"
                      ];
                    Ty.path "alloc::alloc::Global"
                  ],
                "len",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "openvm_circuit::arch::integration_api::VmChipWrapper",
                    "records"
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn trace_width(&self) -> usize {
              self.adapter.air().width() + self.core.air().width()
          }
      *)
      Definition trace_width
          (F A M_ : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self F A M_ in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path "openvm_circuit::arch::integration_api::VmChipWrapper")
                      []
                      [ F; A; M_ ]
                  ],
                self
              |) in
            M.call_closure (|
              Ty.path "usize",
              BinOp.Wrap.add,
              [
                M.call_closure (|
                  Ty.path "usize",
                  M.get_trait_method (|
                    "p3_air::air::BaseAir",
                    Ty.associated_in_trait
                      "openvm_circuit::arch::integration_api::VmAdapterChip"
                      []
                      [ F ]
                      A
                      "Air",
                    [],
                    [ F ],
                    "width",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "&")
                            []
                            [
                              Ty.associated_in_trait
                                "openvm_circuit::arch::integration_api::VmAdapterChip"
                                []
                                [ F ]
                                A
                                "Air"
                            ],
                          M.get_trait_method (|
                            "openvm_circuit::arch::integration_api::VmAdapterChip",
                            A,
                            [],
                            [ F ],
                            "air",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "openvm_circuit::arch::integration_api::VmChipWrapper",
                                "adapter"
                              |)
                            |)
                          ]
                        |)
                      |)
                    |)
                  ]
                |);
                M.call_closure (|
                  Ty.path "usize",
                  M.get_trait_method (|
                    "p3_air::air::BaseAir",
                    Ty.associated_in_trait
                      "openvm_circuit::arch::integration_api::VmCoreChip"
                      []
                      [
                        F;
                        Ty.associated_in_trait
                          "openvm_circuit::arch::integration_api::VmAdapterChip"
                          []
                          [ F ]
                          A
                          "Interface"
                      ]
                      M_
                      "Air",
                    [],
                    [ F ],
                    "width",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "&")
                            []
                            [
                              Ty.associated_in_trait
                                "openvm_circuit::arch::integration_api::VmCoreChip"
                                []
                                [
                                  F;
                                  Ty.associated_in_trait
                                    "openvm_circuit::arch::integration_api::VmAdapterChip"
                                    []
                                    [ F ]
                                    A
                                    "Interface"
                                ]
                                M_
                                "Air"
                            ],
                          M.get_trait_method (|
                            "openvm_circuit::arch::integration_api::VmCoreChip",
                            M_,
                            [],
                            [
                              F;
                              Ty.associated_in_trait
                                "openvm_circuit::arch::integration_api::VmAdapterChip"
                                []
                                [ F ]
                                A
                                "Interface"
                            ],
                            "air",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "openvm_circuit::arch::integration_api::VmChipWrapper",
                                "core"
                              |)
                            |)
                          ]
                        |)
                      |)
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (F A M_ : Ty.t),
        M.IsTraitInstance
          "openvm_stark_backend::chip::ChipUsageGetter"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self F A M_)
          (* Instance *)
          [
            ("air_name", InstanceField.Method (air_name F A M_));
            ("current_trace_height", InstanceField.Method (current_trace_height F A M_));
            ("trace_width", InstanceField.Method (trace_width F A M_))
          ].
    End Impl_openvm_stark_backend_chip_ChipUsageGetter_where_openvm_circuit_arch_integration_api_VmAdapterChip_A_F_where_core_marker_Sync_A_where_openvm_circuit_arch_integration_api_VmCoreChip_M__F_associated_in_trait_openvm_circuit_arch_integration_api_VmAdapterChip__F_A_Interface_where_core_marker_Sync_M__for_openvm_circuit_arch_integration_api_VmChipWrapper_F_A_M_.
    
    (* StructRecord
      {
        name := "VmAirWrapper";
        const_params := [];
        ty_params := [ "A"; "C" ];
        fields := [ ("adapter", A); ("core", C) ];
      } *)
    
    Module Impl_p3_air_air_BaseAir_where_p3_air_air_BaseAir_A_F_where_p3_air_air_BaseAir_C_F_F_for_openvm_circuit_arch_integration_api_VmAirWrapper_A_C.
      Definition Self (F A C : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "openvm_circuit::arch::integration_api::VmAirWrapper") [] [ A; C ].
      
      (*
          fn width(&self) -> usize {
              self.adapter.width() + self.core.width()
          }
      *)
      Definition width (F A C : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F A C in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path "openvm_circuit::arch::integration_api::VmAirWrapper")
                      []
                      [ A; C ]
                  ],
                self
              |) in
            M.call_closure (|
              Ty.path "usize",
              BinOp.Wrap.add,
              [
                M.call_closure (|
                  Ty.path "usize",
                  M.get_trait_method (| "p3_air::air::BaseAir", A, [], [ F ], "width", [], [] |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "openvm_circuit::arch::integration_api::VmAirWrapper",
                        "adapter"
                      |)
                    |)
                  ]
                |);
                M.call_closure (|
                  Ty.path "usize",
                  M.get_trait_method (| "p3_air::air::BaseAir", C, [], [ F ], "width", [], [] |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "openvm_circuit::arch::integration_api::VmAirWrapper",
                        "core"
                      |)
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (F A C : Ty.t),
        M.IsTraitInstance
          "p3_air::air::BaseAir"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ F ]
          (Self F A C)
          (* Instance *) [ ("width", InstanceField.Method (width F A C)) ].
    End Impl_p3_air_air_BaseAir_where_p3_air_air_BaseAir_A_F_where_p3_air_air_BaseAir_C_F_F_for_openvm_circuit_arch_integration_api_VmAirWrapper_A_C.
    
    Module Impl_openvm_stark_backend_rap_BaseAirWithPublicValues_where_p3_air_air_BaseAir_A_F_where_openvm_stark_backend_rap_BaseAirWithPublicValues_M__F_F_for_openvm_circuit_arch_integration_api_VmAirWrapper_A_M_.
      Definition Self (F A M_ : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "openvm_circuit::arch::integration_api::VmAirWrapper") [] [ A; M_ ].
      
      (*
          fn num_public_values(&self) -> usize {
              self.core.num_public_values()
          }
      *)
      Definition num_public_values
          (F A M_ : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self F A M_ in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path "openvm_circuit::arch::integration_api::VmAirWrapper")
                      []
                      [ A; M_ ]
                  ],
                self
              |) in
            M.call_closure (|
              Ty.path "usize",
              M.get_trait_method (|
                "openvm_stark_backend::rap::BaseAirWithPublicValues",
                M_,
                [],
                [ F ],
                "num_public_values",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "openvm_circuit::arch::integration_api::VmAirWrapper",
                    "core"
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (F A M_ : Ty.t),
        M.IsTraitInstance
          "openvm_stark_backend::rap::BaseAirWithPublicValues"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ F ]
          (Self F A M_)
          (* Instance *) [ ("num_public_values", InstanceField.Method (num_public_values F A M_)) ].
    End Impl_openvm_stark_backend_rap_BaseAirWithPublicValues_where_p3_air_air_BaseAir_A_F_where_openvm_stark_backend_rap_BaseAirWithPublicValues_M__F_F_for_openvm_circuit_arch_integration_api_VmAirWrapper_A_M_.
    
    Module Impl_openvm_stark_backend_rap_PartitionedBaseAir_where_p3_air_air_BaseAir_A_F_where_p3_air_air_BaseAir_M__F_F_for_openvm_circuit_arch_integration_api_VmAirWrapper_A_M_.
      Definition Self (F A M_ : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "openvm_circuit::arch::integration_api::VmAirWrapper") [] [ A; M_ ].
      
      Axiom Implements :
        forall (F A M_ : Ty.t),
        M.IsTraitInstance
          "openvm_stark_backend::rap::PartitionedBaseAir"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ F ]
          (Self F A M_)
          (* Instance *) [].
    End Impl_openvm_stark_backend_rap_PartitionedBaseAir_where_p3_air_air_BaseAir_A_F_where_p3_air_air_BaseAir_M__F_F_for_openvm_circuit_arch_integration_api_VmAirWrapper_A_M_.
    
    Module Impl_p3_air_air_Air_where_p3_air_air_AirBuilder_AB_where_openvm_circuit_arch_integration_api_VmAdapterAir_A_AB_where_openvm_circuit_arch_integration_api_VmCoreAir_M__AB_associated_in_trait_openvm_circuit_arch_integration_api_VmAdapterAir__AB_A_Interface_AB_for_openvm_circuit_arch_integration_api_VmAirWrapper_A_M_.
      Definition Self (AB A M_ : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "openvm_circuit::arch::integration_api::VmAirWrapper") [] [ A; M_ ].
      
      (*
          fn eval(&self, builder: &mut AB) {
              let main = builder.main();
              let local = main.row_slice(0);
              let local: &[AB::Var] = ( *local).borrow();
              let (local_adapter, local_core) = local.split_at(self.adapter.width());
      
              let ctx = self
                  .core
                  .eval(builder, local_core, self.adapter.get_from_pc(local_adapter));
              self.adapter.eval(builder, local_adapter, ctx);
          }
      *)
      Definition eval (AB A M_ : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self AB A M_ in
        match ε, τ, α with
        | [], [], [ self; builder ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path "openvm_circuit::arch::integration_api::VmAirWrapper")
                      []
                      [ A; M_ ]
                  ],
                self
              |) in
            let builder := M.alloc (| Ty.apply (Ty.path "&mut") [] [ AB ], builder |) in
            M.read (|
              let~ main : Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "M" :=
                M.call_closure (|
                  Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "M",
                  M.get_trait_method (| "p3_air::air::AirBuilder", AB, [], [], "main", [], [] |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| builder |) |) |) ]
                |) in
              let~ local :
                  Ty.associated_in_trait
                    "p3_matrix::Matrix"
                    []
                    [ Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Var" ]
                    (Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "M")
                    "{{synthetic}}'2" :=
                M.call_closure (|
                  Ty.associated_in_trait
                    "p3_matrix::Matrix"
                    []
                    [ Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Var" ]
                    (Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "M")
                    "{{synthetic}}'2",
                  M.get_trait_method (|
                    "p3_matrix::Matrix",
                    Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "M",
                    [],
                    [ Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Var" ],
                    "row_slice",
                    [],
                    []
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, main |); Value.Integer IntegerKind.Usize 0 ]
                |) in
              let~ local :
                  Ty.apply
                    (Ty.path "&")
                    []
                    [
                      Ty.apply
                        (Ty.path "slice")
                        []
                        [ Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Var" ]
                    ] :=
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "&")
                        []
                        [
                          Ty.apply
                            (Ty.path "slice")
                            []
                            [ Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Var" ]
                        ],
                      M.get_trait_method (|
                        "core::borrow::Borrow",
                        Ty.apply
                          (Ty.path "slice")
                          []
                          [ Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Var" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "slice")
                            []
                            [ Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Var" ]
                        ],
                        "borrow",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (|
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "&")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "slice")
                                    []
                                    [
                                      Ty.associated_in_trait
                                        "p3_air::air::AirBuilder"
                                        []
                                        []
                                        AB
                                        "Var"
                                    ]
                                ],
                              M.get_trait_method (|
                                "core::ops::deref::Deref",
                                Ty.associated_in_trait
                                  "p3_matrix::Matrix"
                                  []
                                  [ Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Var"
                                  ]
                                  (Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "M")
                                  "{{synthetic}}'2",
                                [],
                                [],
                                "deref",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.Ref, local |) ]
                            |)
                          |)
                        |)
                      ]
                    |)
                  |)
                |) in
              M.alloc (|
                Ty.tuple [],
                M.match_operator (|
                  Ty.tuple [],
                  M.alloc (|
                    Ty.tuple
                      [
                        Ty.apply
                          (Ty.path "&")
                          []
                          [
                            Ty.apply
                              (Ty.path "slice")
                              []
                              [ Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Var" ]
                          ];
                        Ty.apply
                          (Ty.path "&")
                          []
                          [
                            Ty.apply
                              (Ty.path "slice")
                              []
                              [ Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Var" ]
                          ]
                      ],
                    M.call_closure (|
                      Ty.tuple
                        [
                          Ty.apply
                            (Ty.path "&")
                            []
                            [
                              Ty.apply
                                (Ty.path "slice")
                                []
                                [ Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Var" ]
                            ];
                          Ty.apply
                            (Ty.path "&")
                            []
                            [
                              Ty.apply
                                (Ty.path "slice")
                                []
                                [ Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Var" ]
                            ]
                        ],
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "slice")
                          []
                          [ Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Var" ],
                        "split_at",
                        [],
                        []
                      |),
                      [
                        M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| local |) |) |);
                        M.call_closure (|
                          Ty.path "usize",
                          M.get_trait_method (|
                            "p3_air::air::BaseAir",
                            A,
                            [],
                            [ Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "F" ],
                            "width",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "openvm_circuit::arch::integration_api::VmAirWrapper",
                                "adapter"
                              |)
                            |)
                          ]
                        |)
                      ]
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                        let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                        let local_adapter :=
                          M.copy (|
                            Ty.apply
                              (Ty.path "&")
                              []
                              [
                                Ty.apply
                                  (Ty.path "slice")
                                  []
                                  [ Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Var"
                                  ]
                              ],
                            γ0_0
                          |) in
                        let local_core :=
                          M.copy (|
                            Ty.apply
                              (Ty.path "&")
                              []
                              [
                                Ty.apply
                                  (Ty.path "slice")
                                  []
                                  [ Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Var"
                                  ]
                              ],
                            γ0_1
                          |) in
                        M.read (|
                          let~ ctx :
                              Ty.apply
                                (Ty.path "openvm_circuit::arch::integration_api::AdapterAirContext")
                                []
                                [
                                  Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr";
                                  Ty.associated_in_trait
                                    "openvm_circuit::arch::integration_api::VmAdapterAir"
                                    []
                                    [ AB ]
                                    A
                                    "Interface"
                                ] :=
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "openvm_circuit::arch::integration_api::AdapterAirContext")
                                []
                                [
                                  Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr";
                                  Ty.associated_in_trait
                                    "openvm_circuit::arch::integration_api::VmAdapterAir"
                                    []
                                    [ AB ]
                                    A
                                    "Interface"
                                ],
                              M.get_trait_method (|
                                "openvm_circuit::arch::integration_api::VmCoreAir",
                                M_,
                                [],
                                [
                                  AB;
                                  Ty.associated_in_trait
                                    "openvm_circuit::arch::integration_api::VmAdapterAir"
                                    []
                                    [ AB ]
                                    A
                                    "Interface"
                                ],
                                "eval",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "openvm_circuit::arch::integration_api::VmAirWrapper",
                                    "core"
                                  |)
                                |);
                                M.borrow (|
                                  Pointer.Kind.MutRef,
                                  M.deref (| M.read (| builder |) |)
                                |);
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (| M.read (| local_core |) |)
                                |);
                                M.call_closure (|
                                  Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Var",
                                  M.get_trait_method (|
                                    "openvm_circuit::arch::integration_api::VmAdapterAir",
                                    A,
                                    [],
                                    [ AB ],
                                    "get_from_pc",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.SubPointer.get_struct_record_field (|
                                        M.deref (| M.read (| self |) |),
                                        "openvm_circuit::arch::integration_api::VmAirWrapper",
                                        "adapter"
                                      |)
                                    |);
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (| M.read (| local_adapter |) |)
                                    |)
                                  ]
                                |)
                              ]
                            |) in
                          let~ _ : Ty.tuple [] :=
                            M.call_closure (|
                              Ty.tuple [],
                              M.get_trait_method (|
                                "openvm_circuit::arch::integration_api::VmAdapterAir",
                                A,
                                [],
                                [ AB ],
                                "eval",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "openvm_circuit::arch::integration_api::VmAirWrapper",
                                    "adapter"
                                  |)
                                |);
                                M.borrow (|
                                  Pointer.Kind.MutRef,
                                  M.deref (| M.read (| builder |) |)
                                |);
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (| M.read (| local_adapter |) |)
                                |);
                                M.read (| ctx |)
                              ]
                            |) in
                          M.alloc (| Ty.tuple [], Value.Tuple [] |)
                        |)))
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (AB A M_ : Ty.t),
        M.IsTraitInstance
          "p3_air::air::Air"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ AB ]
          (Self AB A M_)
          (* Instance *) [ ("eval", InstanceField.Method (eval AB A M_)) ].
    End Impl_p3_air_air_Air_where_p3_air_air_AirBuilder_AB_where_openvm_circuit_arch_integration_api_VmAdapterAir_A_AB_where_openvm_circuit_arch_integration_api_VmCoreAir_M__AB_associated_in_trait_openvm_circuit_arch_integration_api_VmAdapterAir__AB_A_Interface_AB_for_openvm_circuit_arch_integration_api_VmAirWrapper_A_M_.
    
    (* StructTuple
      {
        name := "BasicAdapterInterface";
        const_params := [ "NUM_READS"; "NUM_WRITES"; "READ_SIZE"; "WRITE_SIZE" ];
        ty_params := [ "T"; "PI" ];
        fields :=
          [
            Ty.apply (Ty.path "core::marker::PhantomData") [] [ T ];
            Ty.apply (Ty.path "core::marker::PhantomData") [] [ PI ]
          ];
      } *)
    
    Module Impl_openvm_circuit_arch_integration_api_VmAdapterInterface_T_for_openvm_circuit_arch_integration_api_BasicAdapterInterface_NUM_READS_NUM_WRITES_READ_SIZE_WRITE_SIZE_T_PI.
      Definition Self (NUM_READS NUM_WRITES READ_SIZE WRITE_SIZE : Value.t) (T PI : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "openvm_circuit::arch::integration_api::BasicAdapterInterface")
          [ NUM_READS; NUM_WRITES; READ_SIZE; WRITE_SIZE ]
          [ T; PI ].
      
      (*     type Reads = [[T; READ_SIZE]; NUM_READS]; *)
      Definition _Reads
          (NUM_READS NUM_WRITES READ_SIZE WRITE_SIZE : Value.t)
          (T PI : Ty.t)
          : Ty.t :=
        Ty.apply (Ty.path "array") [ NUM_READS ] [ Ty.apply (Ty.path "array") [ READ_SIZE ] [ T ] ].
      
      (*     type Writes = [[T; WRITE_SIZE]; NUM_WRITES]; *)
      Definition _Writes
          (NUM_READS NUM_WRITES READ_SIZE WRITE_SIZE : Value.t)
          (T PI : Ty.t)
          : Ty.t :=
        Ty.apply
          (Ty.path "array")
          [ NUM_WRITES ]
          [ Ty.apply (Ty.path "array") [ WRITE_SIZE ] [ T ] ].
      
      (*     type ProcessedInstruction = PI; *)
      Definition _ProcessedInstruction
          (NUM_READS NUM_WRITES READ_SIZE WRITE_SIZE : Value.t)
          (T PI : Ty.t)
          : Ty.t :=
        PI.
      
      Axiom Implements :
        forall (NUM_READS NUM_WRITES READ_SIZE WRITE_SIZE : Value.t) (T PI : Ty.t),
        M.IsTraitInstance
          "openvm_circuit::arch::integration_api::VmAdapterInterface"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ T ]
          (Self NUM_READS NUM_WRITES READ_SIZE WRITE_SIZE T PI)
          (* Instance *)
          [
            ("Reads", InstanceField.Ty (_Reads NUM_READS NUM_WRITES READ_SIZE WRITE_SIZE T PI));
            ("Writes", InstanceField.Ty (_Writes NUM_READS NUM_WRITES READ_SIZE WRITE_SIZE T PI));
            ("ProcessedInstruction",
              InstanceField.Ty
                (_ProcessedInstruction NUM_READS NUM_WRITES READ_SIZE WRITE_SIZE T PI))
          ].
    End Impl_openvm_circuit_arch_integration_api_VmAdapterInterface_T_for_openvm_circuit_arch_integration_api_BasicAdapterInterface_NUM_READS_NUM_WRITES_READ_SIZE_WRITE_SIZE_T_PI.
    
    (* StructTuple
      {
        name := "VecHeapAdapterInterface";
        const_params :=
          [ "NUM_READS"; "BLOCKS_PER_READ"; "BLOCKS_PER_WRITE"; "READ_SIZE"; "WRITE_SIZE" ];
        ty_params := [ "T" ];
        fields := [ Ty.apply (Ty.path "core::marker::PhantomData") [] [ T ] ];
      } *)
    
    Module Impl_openvm_circuit_arch_integration_api_VmAdapterInterface_T_for_openvm_circuit_arch_integration_api_VecHeapAdapterInterface_NUM_READS_BLOCKS_PER_READ_BLOCKS_PER_WRITE_READ_SIZE_WRITE_SIZE_T.
      Definition Self
          (NUM_READS BLOCKS_PER_READ BLOCKS_PER_WRITE READ_SIZE WRITE_SIZE : Value.t)
          (T : Ty.t)
          : Ty.t :=
        Ty.apply
          (Ty.path "openvm_circuit::arch::integration_api::VecHeapAdapterInterface")
          [ NUM_READS; BLOCKS_PER_READ; BLOCKS_PER_WRITE; READ_SIZE; WRITE_SIZE ]
          [ T ].
      
      (*     type Reads = [[[T; READ_SIZE]; BLOCKS_PER_READ]; NUM_READS]; *)
      Definition _Reads
          (NUM_READS BLOCKS_PER_READ BLOCKS_PER_WRITE READ_SIZE WRITE_SIZE : Value.t)
          (T : Ty.t)
          : Ty.t :=
        Ty.apply
          (Ty.path "array")
          [ NUM_READS ]
          [
            Ty.apply
              (Ty.path "array")
              [ BLOCKS_PER_READ ]
              [ Ty.apply (Ty.path "array") [ READ_SIZE ] [ T ] ]
          ].
      
      (*     type Writes = [[T; WRITE_SIZE]; BLOCKS_PER_WRITE]; *)
      Definition _Writes
          (NUM_READS BLOCKS_PER_READ BLOCKS_PER_WRITE READ_SIZE WRITE_SIZE : Value.t)
          (T : Ty.t)
          : Ty.t :=
        Ty.apply
          (Ty.path "array")
          [ BLOCKS_PER_WRITE ]
          [ Ty.apply (Ty.path "array") [ WRITE_SIZE ] [ T ] ].
      
      (*     type ProcessedInstruction = MinimalInstruction<T>; *)
      Definition _ProcessedInstruction
          (NUM_READS BLOCKS_PER_READ BLOCKS_PER_WRITE READ_SIZE WRITE_SIZE : Value.t)
          (T : Ty.t)
          : Ty.t :=
        Ty.apply (Ty.path "openvm_circuit::arch::integration_api::MinimalInstruction") [] [ T ].
      
      Axiom Implements :
        forall
          (NUM_READS BLOCKS_PER_READ BLOCKS_PER_WRITE READ_SIZE WRITE_SIZE : Value.t)
          (T : Ty.t),
        M.IsTraitInstance
          "openvm_circuit::arch::integration_api::VmAdapterInterface"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ T ]
          (Self NUM_READS BLOCKS_PER_READ BLOCKS_PER_WRITE READ_SIZE WRITE_SIZE T)
          (* Instance *)
          [
            ("Reads",
              InstanceField.Ty
                (_Reads NUM_READS BLOCKS_PER_READ BLOCKS_PER_WRITE READ_SIZE WRITE_SIZE T));
            ("Writes",
              InstanceField.Ty
                (_Writes NUM_READS BLOCKS_PER_READ BLOCKS_PER_WRITE READ_SIZE WRITE_SIZE T));
            ("ProcessedInstruction",
              InstanceField.Ty
                (_ProcessedInstruction
                  NUM_READS
                  BLOCKS_PER_READ
                  BLOCKS_PER_WRITE
                  READ_SIZE
                  WRITE_SIZE
                  T))
          ].
    End Impl_openvm_circuit_arch_integration_api_VmAdapterInterface_T_for_openvm_circuit_arch_integration_api_VecHeapAdapterInterface_NUM_READS_BLOCKS_PER_READ_BLOCKS_PER_WRITE_READ_SIZE_WRITE_SIZE_T.
    
    (* StructTuple
      {
        name := "VecHeapTwoReadsAdapterInterface";
        const_params :=
          [ "BLOCKS_PER_READ1"; "BLOCKS_PER_READ2"; "BLOCKS_PER_WRITE"; "READ_SIZE"; "WRITE_SIZE" ];
        ty_params := [ "T" ];
        fields := [ Ty.apply (Ty.path "core::marker::PhantomData") [] [ T ] ];
      } *)
    
    Module Impl_openvm_circuit_arch_integration_api_VmAdapterInterface_T_for_openvm_circuit_arch_integration_api_VecHeapTwoReadsAdapterInterface_BLOCKS_PER_READ1_BLOCKS_PER_READ2_BLOCKS_PER_WRITE_READ_SIZE_WRITE_SIZE_T.
      Definition Self
          (BLOCKS_PER_READ1 BLOCKS_PER_READ2 BLOCKS_PER_WRITE READ_SIZE WRITE_SIZE : Value.t)
          (T : Ty.t)
          : Ty.t :=
        Ty.apply
          (Ty.path "openvm_circuit::arch::integration_api::VecHeapTwoReadsAdapterInterface")
          [ BLOCKS_PER_READ1; BLOCKS_PER_READ2; BLOCKS_PER_WRITE; READ_SIZE; WRITE_SIZE ]
          [ T ].
      
      (*
          type Reads = (
              [[T; READ_SIZE]; BLOCKS_PER_READ1],
              [[T; READ_SIZE]; BLOCKS_PER_READ2],
          );
      *)
      Definition _Reads
          (BLOCKS_PER_READ1 BLOCKS_PER_READ2 BLOCKS_PER_WRITE READ_SIZE WRITE_SIZE : Value.t)
          (T : Ty.t)
          : Ty.t :=
        Ty.tuple
          [
            Ty.apply
              (Ty.path "array")
              [ BLOCKS_PER_READ1 ]
              [ Ty.apply (Ty.path "array") [ READ_SIZE ] [ T ] ];
            Ty.apply
              (Ty.path "array")
              [ BLOCKS_PER_READ2 ]
              [ Ty.apply (Ty.path "array") [ READ_SIZE ] [ T ] ]
          ].
      
      (*     type Writes = [[T; WRITE_SIZE]; BLOCKS_PER_WRITE]; *)
      Definition _Writes
          (BLOCKS_PER_READ1 BLOCKS_PER_READ2 BLOCKS_PER_WRITE READ_SIZE WRITE_SIZE : Value.t)
          (T : Ty.t)
          : Ty.t :=
        Ty.apply
          (Ty.path "array")
          [ BLOCKS_PER_WRITE ]
          [ Ty.apply (Ty.path "array") [ WRITE_SIZE ] [ T ] ].
      
      (*     type ProcessedInstruction = MinimalInstruction<T>; *)
      Definition _ProcessedInstruction
          (BLOCKS_PER_READ1 BLOCKS_PER_READ2 BLOCKS_PER_WRITE READ_SIZE WRITE_SIZE : Value.t)
          (T : Ty.t)
          : Ty.t :=
        Ty.apply (Ty.path "openvm_circuit::arch::integration_api::MinimalInstruction") [] [ T ].
      
      Axiom Implements :
        forall
          (BLOCKS_PER_READ1 BLOCKS_PER_READ2 BLOCKS_PER_WRITE READ_SIZE WRITE_SIZE : Value.t)
          (T : Ty.t),
        M.IsTraitInstance
          "openvm_circuit::arch::integration_api::VmAdapterInterface"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ T ]
          (Self BLOCKS_PER_READ1 BLOCKS_PER_READ2 BLOCKS_PER_WRITE READ_SIZE WRITE_SIZE T)
          (* Instance *)
          [
            ("Reads",
              InstanceField.Ty
                (_Reads BLOCKS_PER_READ1 BLOCKS_PER_READ2 BLOCKS_PER_WRITE READ_SIZE WRITE_SIZE T));
            ("Writes",
              InstanceField.Ty
                (_Writes
                  BLOCKS_PER_READ1
                  BLOCKS_PER_READ2
                  BLOCKS_PER_WRITE
                  READ_SIZE
                  WRITE_SIZE
                  T));
            ("ProcessedInstruction",
              InstanceField.Ty
                (_ProcessedInstruction
                  BLOCKS_PER_READ1
                  BLOCKS_PER_READ2
                  BLOCKS_PER_WRITE
                  READ_SIZE
                  WRITE_SIZE
                  T))
          ].
    End Impl_openvm_circuit_arch_integration_api_VmAdapterInterface_T_for_openvm_circuit_arch_integration_api_VecHeapTwoReadsAdapterInterface_BLOCKS_PER_READ1_BLOCKS_PER_READ2_BLOCKS_PER_WRITE_READ_SIZE_WRITE_SIZE_T.
    
    (* StructTuple
      {
        name := "FlatInterface";
        const_params := [ "READ_CELLS"; "WRITE_CELLS" ];
        ty_params := [ "T"; "PI" ];
        fields :=
          [
            Ty.apply (Ty.path "core::marker::PhantomData") [] [ T ];
            Ty.apply (Ty.path "core::marker::PhantomData") [] [ PI ]
          ];
      } *)
    
    Module Impl_openvm_circuit_arch_integration_api_VmAdapterInterface_T_for_openvm_circuit_arch_integration_api_FlatInterface_READ_CELLS_WRITE_CELLS_T_PI.
      Definition Self (READ_CELLS WRITE_CELLS : Value.t) (T PI : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "openvm_circuit::arch::integration_api::FlatInterface")
          [ READ_CELLS; WRITE_CELLS ]
          [ T; PI ].
      
      (*     type Reads = [T; READ_CELLS]; *)
      Definition _Reads (READ_CELLS WRITE_CELLS : Value.t) (T PI : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "array") [ READ_CELLS ] [ T ].
      
      (*     type Writes = [T; WRITE_CELLS]; *)
      Definition _Writes (READ_CELLS WRITE_CELLS : Value.t) (T PI : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "array") [ WRITE_CELLS ] [ T ].
      
      (*     type ProcessedInstruction = PI; *)
      Definition _ProcessedInstruction (READ_CELLS WRITE_CELLS : Value.t) (T PI : Ty.t) : Ty.t :=
        PI.
      
      Axiom Implements :
        forall (READ_CELLS WRITE_CELLS : Value.t) (T PI : Ty.t),
        M.IsTraitInstance
          "openvm_circuit::arch::integration_api::VmAdapterInterface"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ T ]
          (Self READ_CELLS WRITE_CELLS T PI)
          (* Instance *)
          [
            ("Reads", InstanceField.Ty (_Reads READ_CELLS WRITE_CELLS T PI));
            ("Writes", InstanceField.Ty (_Writes READ_CELLS WRITE_CELLS T PI));
            ("ProcessedInstruction",
              InstanceField.Ty (_ProcessedInstruction READ_CELLS WRITE_CELLS T PI))
          ].
    End Impl_openvm_circuit_arch_integration_api_VmAdapterInterface_T_for_openvm_circuit_arch_integration_api_FlatInterface_READ_CELLS_WRITE_CELLS_T_PI.
    
    (* StructTuple
      {
        name := "DynAdapterInterface";
        const_params := [];
        ty_params := [ "T" ];
        fields := [ Ty.apply (Ty.path "core::marker::PhantomData") [] [ T ] ];
      } *)
    
    Module underscore.
      Module Impl_serde_ser_Serialize_for_openvm_circuit_arch_integration_api_DynAdapterInterface_T.
        Definition Self (T : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "openvm_circuit::arch::integration_api::DynAdapterInterface") [] [ T ].
        
        (* Serialize *)
        Definition serialize (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T in
          match ε, τ, α with
          | [], [ __S ], [ self; __serializer ] =>
            ltac:(M.monadic
              (let self :=
                M.alloc (|
                  Ty.apply
                    (Ty.path "&")
                    []
                    [
                      Ty.apply
                        (Ty.path "openvm_circuit::arch::integration_api::DynAdapterInterface")
                        []
                        [ T ]
                    ],
                  self
                |) in
              let __serializer := M.alloc (| __S, __serializer |) in
              M.call_closure (|
                Ty.apply
                  (Ty.path "core::result::Result")
                  []
                  [
                    Ty.associated_in_trait "serde::ser::Serializer" [] [] __S "Ok";
                    Ty.associated_in_trait "serde::ser::Serializer" [] [] __S "Error"
                  ],
                M.get_trait_method (|
                  "serde::ser::Serializer",
                  __S,
                  [],
                  [],
                  "serialize_newtype_struct",
                  [],
                  [ Ty.apply (Ty.path "core::marker::PhantomData") [] [ T ] ]
                |),
                [
                  M.read (| __serializer |);
                  mk_str (| "DynAdapterInterface" |);
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_tuple_field (|
                          M.deref (| M.read (| self |) |),
                          "openvm_circuit::arch::integration_api::DynAdapterInterface",
                          0
                        |)
                      |)
                    |)
                  |)
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          forall (T : Ty.t),
          M.IsTraitInstance
            "serde::ser::Serialize"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) []
            (Self T)
            (* Instance *) [ ("serialize", InstanceField.Method (serialize T)) ].
      End Impl_serde_ser_Serialize_for_openvm_circuit_arch_integration_api_DynAdapterInterface_T.
      Module Impl_serde_de_Deserialize_for_openvm_circuit_arch_integration_api_DynAdapterInterface_T.
        Definition Self (T : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "openvm_circuit::arch::integration_api::DynAdapterInterface") [] [ T ].
        
        (* Deserialize *)
        Definition deserialize
            (T : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self T in
          match ε, τ, α with
          | [], [ __D ], [ __deserializer ] =>
            ltac:(M.monadic
              (let __deserializer := M.alloc (| __D, __deserializer |) in
              M.call_closure (|
                Ty.apply
                  (Ty.path "core::result::Result")
                  []
                  [
                    Ty.apply
                      (Ty.path "openvm_circuit::arch::integration_api::DynAdapterInterface")
                      []
                      [ T ];
                    Ty.associated_in_trait "serde::de::Deserializer" [] [] __D "Error"
                  ],
                M.get_trait_method (|
                  "serde::de::Deserializer",
                  __D,
                  [],
                  [],
                  "deserialize_newtype_struct",
                  [],
                  [
                    Ty.apply
                      (Ty.path "openvm_circuit::arch::integration_api::_'1::deserialize::__Visitor")
                      []
                      [ T ]
                  ]
                |),
                [
                  M.read (| __deserializer |);
                  mk_str (| "DynAdapterInterface" |);
                  Value.mkStructRecord
                    "openvm_circuit::arch::integration_api::_'1::deserialize::__Visitor"
                    []
                    [ T ]
                    [
                      ("marker",
                        Value.StructTuple
                          "core::marker::PhantomData"
                          []
                          [
                            Ty.apply
                              (Ty.path "openvm_circuit::arch::integration_api::DynAdapterInterface")
                              []
                              [ T ]
                          ]
                          []);
                      ("lifetime",
                        Value.StructTuple
                          "core::marker::PhantomData"
                          []
                          [ Ty.apply (Ty.path "&") [] [ Ty.tuple [] ] ]
                          [])
                    ]
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          forall (T : Ty.t),
          M.IsTraitInstance
            "serde::de::Deserialize"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) []
            (Self T)
            (* Instance *) [ ("deserialize", InstanceField.Method (deserialize T)) ].
      End Impl_serde_de_Deserialize_for_openvm_circuit_arch_integration_api_DynAdapterInterface_T.
    End underscore.
    
    
    Module Impl_openvm_circuit_arch_integration_api_VmAdapterInterface_T_for_openvm_circuit_arch_integration_api_DynAdapterInterface_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "openvm_circuit::arch::integration_api::DynAdapterInterface") [] [ T ].
      
      (*     type Reads = DynArray<T>; *)
      Definition _Reads (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "openvm_circuit::arch::integration_api::DynArray") [] [ T ].
      
      (*     type Writes = DynArray<T>; *)
      Definition _Writes (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "openvm_circuit::arch::integration_api::DynArray") [] [ T ].
      
      (*     type ProcessedInstruction = DynArray<T>; *)
      Definition _ProcessedInstruction (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "openvm_circuit::arch::integration_api::DynArray") [] [ T ].
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "openvm_circuit::arch::integration_api::VmAdapterInterface"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ T ]
          (Self T)
          (* Instance *)
          [
            ("Reads", InstanceField.Ty (_Reads T));
            ("Writes", InstanceField.Ty (_Writes T));
            ("ProcessedInstruction", InstanceField.Ty (_ProcessedInstruction T))
          ].
    End Impl_openvm_circuit_arch_integration_api_VmAdapterInterface_T_for_openvm_circuit_arch_integration_api_DynAdapterInterface_T.
    
    (* StructTuple
      {
        name := "DynArray";
        const_params := [];
        ty_params := [ "T" ];
        fields := [ Ty.apply (Ty.path "alloc::vec::Vec") [] [ T; Ty.path "alloc::alloc::Global" ] ];
      } *)
    
    Module Impl_core_clone_Clone_where_core_clone_Clone_T_for_openvm_circuit_arch_integration_api_DynArray_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "openvm_circuit::arch::integration_api::DynArray") [] [ T ].
      
      (* Clone *)
      Definition clone (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.apply (Ty.path "openvm_circuit::arch::integration_api::DynArray") [] [ T ] ],
                self
              |) in
            Value.StructTuple
              "openvm_circuit::arch::integration_api::DynArray"
              []
              [ T ]
              [
                M.call_closure (|
                  Ty.apply (Ty.path "alloc::vec::Vec") [] [ T; Ty.path "alloc::alloc::Global" ],
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.apply (Ty.path "alloc::vec::Vec") [] [ T; Ty.path "alloc::alloc::Global" ],
                    [],
                    [],
                    "clone",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_tuple_field (|
                            M.deref (| M.read (| self |) |),
                            "openvm_circuit::arch::integration_api::DynArray",
                            0
                          |)
                        |)
                      |)
                    |)
                  ]
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::clone::Clone"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [ ("clone", InstanceField.Method (clone T)) ].
    End Impl_core_clone_Clone_where_core_clone_Clone_T_for_openvm_circuit_arch_integration_api_DynArray_T.
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_openvm_circuit_arch_integration_api_DynArray_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "openvm_circuit::arch::integration_api::DynArray") [] [ T ].
      
      (* Debug *)
      Definition fmt (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.apply (Ty.path "openvm_circuit::arch::integration_api::DynArray") [] [ T ] ],
                self
              |) in
            let f :=
              M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "core::fmt::Formatter" ], f |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
              M.get_associated_function (|
                Ty.path "core::fmt::Formatter",
                "debug_tuple_field1_finish",
                [],
                []
              |),
              [
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "DynArray" |) |) |);
                M.call_closure (|
                  Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ],
                  M.pointer_coercion
                    M.PointerCoercion.Unsize
                    (Ty.apply
                      (Ty.path "&")
                      []
                      [
                        Ty.apply
                          (Ty.path "&")
                          []
                          [
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              []
                              [ T; Ty.path "alloc::alloc::Global" ]
                          ]
                      ])
                    (Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ]),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.alloc (|
                            Ty.apply
                              (Ty.path "&")
                              []
                              [
                                Ty.apply
                                  (Ty.path "alloc::vec::Vec")
                                  []
                                  [ T; Ty.path "alloc::alloc::Global" ]
                              ],
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.SubPointer.get_struct_tuple_field (|
                                M.deref (| M.read (| self |) |),
                                "openvm_circuit::arch::integration_api::DynArray",
                                0
                              |)
                            |)
                          |)
                        |)
                      |)
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [ ("fmt", InstanceField.Method (fmt T)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_openvm_circuit_arch_integration_api_DynArray_T.
    
    Module Impl_core_default_Default_where_core_default_Default_T_for_openvm_circuit_arch_integration_api_DynArray_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "openvm_circuit::arch::integration_api::DynArray") [] [ T ].
      
      (* Default *)
      Definition default (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [] =>
          ltac:(M.monadic
            (Value.StructTuple
              "openvm_circuit::arch::integration_api::DynArray"
              []
              [ T ]
              [
                M.call_closure (|
                  Ty.apply (Ty.path "alloc::vec::Vec") [] [ T; Ty.path "alloc::alloc::Global" ],
                  M.get_trait_method (|
                    "core::default::Default",
                    Ty.apply (Ty.path "alloc::vec::Vec") [] [ T; Ty.path "alloc::alloc::Global" ],
                    [],
                    [],
                    "default",
                    [],
                    []
                  |),
                  []
                |)
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::default::Default"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T)
          (* Instance *) [ ("default", InstanceField.Method (default T)) ].
    End Impl_core_default_Default_where_core_default_Default_T_for_openvm_circuit_arch_integration_api_DynArray_T.
    
    (* StructRecord
      {
        name := "MinimalInstruction";
        const_params := [];
        ty_params := [ "T" ];
        fields := [ ("is_valid", T); ("opcode", T) ];
      } *)
    
    Module Impl_core_borrow_Borrow_openvm_circuit_arch_integration_api_MinimalInstruction_T_for_slice_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "slice") [] [ T ].
      
      (* AlignedBorrow *)
      Definition borrow (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                self
              |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.match_operator (|
                  Ty.tuple [],
                  M.alloc (| Ty.tuple [], Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.use (M.alloc (| Ty.path "bool", Value.Bool true |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.read (|
                          let~ _ : Ty.tuple [] :=
                            M.match_operator (|
                              Ty.tuple [],
                              M.alloc (|
                                Ty.tuple
                                  [
                                    Ty.apply (Ty.path "&") [] [ Ty.path "usize" ];
                                    Ty.apply (Ty.path "&") [] [ Ty.path "usize" ]
                                  ],
                                Value.Tuple
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.alloc (|
                                        Ty.path "usize",
                                        M.call_closure (|
                                          Ty.path "usize",
                                          M.get_associated_function (|
                                            Ty.apply (Ty.path "slice") [] [ T ],
                                            "len",
                                            [],
                                            []
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (| M.read (| self |) |)
                                            |)
                                          ]
                                        |)
                                      |)
                                    |);
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.alloc (|
                                        Ty.path "usize",
                                        M.call_closure (|
                                          Ty.path "usize",
                                          M.get_associated_function (|
                                            Ty.apply
                                              (Ty.path
                                                "openvm_circuit::arch::integration_api::MinimalInstruction")
                                              []
                                              [ T ],
                                            "width",
                                            [],
                                            []
                                          |),
                                          []
                                        |)
                                      |)
                                    |)
                                  ]
                              |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                    let left_val :=
                                      M.copy (|
                                        Ty.apply (Ty.path "&") [] [ Ty.path "usize" ],
                                        γ0_0
                                      |) in
                                    let right_val :=
                                      M.copy (|
                                        Ty.apply (Ty.path "&") [] [ Ty.path "usize" ],
                                        γ0_1
                                      |) in
                                    M.match_operator (|
                                      Ty.tuple [],
                                      M.alloc (| Ty.tuple [], Value.Tuple [] |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ :=
                                              M.use
                                                (M.alloc (|
                                                  Ty.path "bool",
                                                  UnOp.not (|
                                                    M.call_closure (|
                                                      Ty.path "bool",
                                                      BinOp.eq,
                                                      [
                                                        M.read (|
                                                          M.deref (| M.read (| left_val |) |)
                                                        |);
                                                        M.read (|
                                                          M.deref (| M.read (| right_val |) |)
                                                        |)
                                                      ]
                                                    |)
                                                  |)
                                                |)) in
                                            let _ :=
                                              is_constant_or_break_match (|
                                                M.read (| γ |),
                                                Value.Bool true
                                              |) in
                                            M.never_to_any (|
                                              M.read (|
                                                let~ kind : Ty.path "core::panicking::AssertKind" :=
                                                  Value.StructTuple
                                                    "core::panicking::AssertKind::Eq"
                                                    []
                                                    []
                                                    [] in
                                                M.alloc (|
                                                  Ty.path "never",
                                                  M.call_closure (|
                                                    Ty.path "never",
                                                    M.get_function (|
                                                      "core::panicking::assert_failed",
                                                      [],
                                                      [ Ty.path "usize"; Ty.path "usize" ]
                                                    |),
                                                    [
                                                      M.read (| kind |);
                                                      M.borrow (|
                                                        Pointer.Kind.Ref,
                                                        M.deref (|
                                                          M.borrow (|
                                                            Pointer.Kind.Ref,
                                                            M.deref (| M.read (| left_val |) |)
                                                          |)
                                                        |)
                                                      |);
                                                      M.borrow (|
                                                        Pointer.Kind.Ref,
                                                        M.deref (|
                                                          M.borrow (|
                                                            Pointer.Kind.Ref,
                                                            M.deref (| M.read (| right_val |) |)
                                                          |)
                                                        |)
                                                      |);
                                                      Value.StructTuple
                                                        "core::option::Option::None"
                                                        []
                                                        [ Ty.path "core::fmt::Arguments" ]
                                                        []
                                                    ]
                                                  |)
                                                |)
                                              |)
                                            |)));
                                        fun γ => ltac:(M.monadic (Value.Tuple []))
                                      ]
                                    |)))
                              ]
                            |) in
                          M.alloc (| Ty.tuple [], Value.Tuple [] |)
                        |)));
                    fun γ => ltac:(M.monadic (Value.Tuple []))
                  ]
                |) in
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path "openvm_circuit::arch::integration_api::MinimalInstruction")
                      []
                      [ T ]
                  ],
                M.match_operator (|
                  Ty.apply
                    (Ty.path "&")
                    []
                    [
                      Ty.apply
                        (Ty.path "openvm_circuit::arch::integration_api::MinimalInstruction")
                        []
                        [ T ]
                    ],
                  M.alloc (|
                    Ty.tuple
                      [
                        Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ];
                        Ty.apply
                          (Ty.path "&")
                          []
                          [
                            Ty.apply
                              (Ty.path "slice")
                              []
                              [
                                Ty.apply
                                  (Ty.path
                                    "openvm_circuit::arch::integration_api::MinimalInstruction")
                                  []
                                  [ T ]
                              ]
                          ];
                        Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ]
                      ],
                    M.call_closure (|
                      Ty.tuple
                        [
                          Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ];
                          Ty.apply
                            (Ty.path "&")
                            []
                            [
                              Ty.apply
                                (Ty.path "slice")
                                []
                                [
                                  Ty.apply
                                    (Ty.path
                                      "openvm_circuit::arch::integration_api::MinimalInstruction")
                                    []
                                    [ T ]
                                ]
                            ];
                          Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ]
                        ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "slice") [] [ T ],
                        "align_to",
                        [],
                        [
                          Ty.apply
                            (Ty.path "openvm_circuit::arch::integration_api::MinimalInstruction")
                            []
                            [ T ]
                        ]
                      |),
                      [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                        let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                        let γ0_2 := M.SubPointer.get_tuple_field (| γ, 2 |) in
                        let prefix :=
                          M.copy (|
                            Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                            γ0_0
                          |) in
                        let shorts :=
                          M.copy (|
                            Ty.apply
                              (Ty.path "&")
                              []
                              [
                                Ty.apply
                                  (Ty.path "slice")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path
                                        "openvm_circuit::arch::integration_api::MinimalInstruction")
                                      []
                                      [ T ]
                                  ]
                              ],
                            γ0_1
                          |) in
                        let _suffix :=
                          M.copy (|
                            Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                            γ0_2
                          |) in
                        M.read (|
                          let~ _ : Ty.tuple [] :=
                            M.match_operator (|
                              Ty.tuple [],
                              M.alloc (| Ty.tuple [], Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ :=
                                      M.use (M.alloc (| Ty.path "bool", Value.Bool true |)) in
                                    let _ :=
                                      is_constant_or_break_match (|
                                        M.read (| γ |),
                                        Value.Bool true
                                      |) in
                                    M.read (|
                                      let~ _ : Ty.tuple [] :=
                                        M.match_operator (|
                                          Ty.tuple [],
                                          M.alloc (| Ty.tuple [], Value.Tuple [] |),
                                          [
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let γ :=
                                                  M.use
                                                    (M.alloc (|
                                                      Ty.path "bool",
                                                      UnOp.not (|
                                                        M.call_closure (|
                                                          Ty.path "bool",
                                                          M.get_associated_function (|
                                                            Ty.apply (Ty.path "slice") [] [ T ],
                                                            "is_empty",
                                                            [],
                                                            []
                                                          |),
                                                          [
                                                            M.borrow (|
                                                              Pointer.Kind.Ref,
                                                              M.deref (| M.read (| prefix |) |)
                                                            |)
                                                          ]
                                                        |)
                                                      |)
                                                    |)) in
                                                let _ :=
                                                  is_constant_or_break_match (|
                                                    M.read (| γ |),
                                                    Value.Bool true
                                                  |) in
                                                M.never_to_any (|
                                                  M.call_closure (|
                                                    Ty.path "never",
                                                    M.get_function (|
                                                      "core::panicking::panic_fmt",
                                                      [],
                                                      []
                                                    |),
                                                    [
                                                      M.call_closure (|
                                                        Ty.path "core::fmt::Arguments",
                                                        M.get_associated_function (|
                                                          Ty.path "core::fmt::Arguments",
                                                          "new_const",
                                                          [ Value.Integer IntegerKind.Usize 1 ],
                                                          []
                                                        |),
                                                        [
                                                          M.borrow (|
                                                            Pointer.Kind.Ref,
                                                            M.deref (|
                                                              M.borrow (|
                                                                Pointer.Kind.Ref,
                                                                M.alloc (|
                                                                  Ty.apply
                                                                    (Ty.path "array")
                                                                    [
                                                                      Value.Integer
                                                                        IntegerKind.Usize
                                                                        1
                                                                    ]
                                                                    [
                                                                      Ty.apply
                                                                        (Ty.path "&")
                                                                        []
                                                                        [ Ty.path "str" ]
                                                                    ],
                                                                  Value.Array
                                                                    [
                                                                      mk_str (|
                                                                        "Alignment should match"
                                                                      |)
                                                                    ]
                                                                |)
                                                              |)
                                                            |)
                                                          |)
                                                        ]
                                                      |)
                                                    ]
                                                  |)
                                                |)));
                                            fun γ => ltac:(M.monadic (Value.Tuple []))
                                          ]
                                        |) in
                                      M.alloc (| Ty.tuple [], Value.Tuple [] |)
                                    |)));
                                fun γ => ltac:(M.monadic (Value.Tuple []))
                              ]
                            |) in
                          let~ _ : Ty.tuple [] :=
                            M.match_operator (|
                              Ty.tuple [],
                              M.alloc (| Ty.tuple [], Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ :=
                                      M.use (M.alloc (| Ty.path "bool", Value.Bool true |)) in
                                    let _ :=
                                      is_constant_or_break_match (|
                                        M.read (| γ |),
                                        Value.Bool true
                                      |) in
                                    M.read (|
                                      let~ _ : Ty.tuple [] :=
                                        M.match_operator (|
                                          Ty.tuple [],
                                          M.alloc (|
                                            Ty.tuple
                                              [
                                                Ty.apply (Ty.path "&") [] [ Ty.path "usize" ];
                                                Ty.apply (Ty.path "&") [] [ Ty.path "usize" ]
                                              ],
                                            Value.Tuple
                                              [
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.alloc (|
                                                    Ty.path "usize",
                                                    M.call_closure (|
                                                      Ty.path "usize",
                                                      M.get_associated_function (|
                                                        Ty.apply
                                                          (Ty.path "slice")
                                                          []
                                                          [
                                                            Ty.apply
                                                              (Ty.path
                                                                "openvm_circuit::arch::integration_api::MinimalInstruction")
                                                              []
                                                              [ T ]
                                                          ],
                                                        "len",
                                                        [],
                                                        []
                                                      |),
                                                      [
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.deref (| M.read (| shorts |) |)
                                                        |)
                                                      ]
                                                    |)
                                                  |)
                                                |);
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.alloc (|
                                                    Ty.path "usize",
                                                    Value.Integer IntegerKind.Usize 1
                                                  |)
                                                |)
                                              ]
                                          |),
                                          [
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let γ0_0 :=
                                                  M.SubPointer.get_tuple_field (| γ, 0 |) in
                                                let γ0_1 :=
                                                  M.SubPointer.get_tuple_field (| γ, 1 |) in
                                                let left_val :=
                                                  M.copy (|
                                                    Ty.apply (Ty.path "&") [] [ Ty.path "usize" ],
                                                    γ0_0
                                                  |) in
                                                let right_val :=
                                                  M.copy (|
                                                    Ty.apply (Ty.path "&") [] [ Ty.path "usize" ],
                                                    γ0_1
                                                  |) in
                                                M.match_operator (|
                                                  Ty.tuple [],
                                                  M.alloc (| Ty.tuple [], Value.Tuple [] |),
                                                  [
                                                    fun γ =>
                                                      ltac:(M.monadic
                                                        (let γ :=
                                                          M.use
                                                            (M.alloc (|
                                                              Ty.path "bool",
                                                              UnOp.not (|
                                                                M.call_closure (|
                                                                  Ty.path "bool",
                                                                  BinOp.eq,
                                                                  [
                                                                    M.read (|
                                                                      M.deref (|
                                                                        M.read (| left_val |)
                                                                      |)
                                                                    |);
                                                                    M.read (|
                                                                      M.deref (|
                                                                        M.read (| right_val |)
                                                                      |)
                                                                    |)
                                                                  ]
                                                                |)
                                                              |)
                                                            |)) in
                                                        let _ :=
                                                          is_constant_or_break_match (|
                                                            M.read (| γ |),
                                                            Value.Bool true
                                                          |) in
                                                        M.never_to_any (|
                                                          M.read (|
                                                            let~ kind :
                                                                Ty.path
                                                                  "core::panicking::AssertKind" :=
                                                              Value.StructTuple
                                                                "core::panicking::AssertKind::Eq"
                                                                []
                                                                []
                                                                [] in
                                                            M.alloc (|
                                                              Ty.path "never",
                                                              M.call_closure (|
                                                                Ty.path "never",
                                                                M.get_function (|
                                                                  "core::panicking::assert_failed",
                                                                  [],
                                                                  [ Ty.path "usize"; Ty.path "usize"
                                                                  ]
                                                                |),
                                                                [
                                                                  M.read (| kind |);
                                                                  M.borrow (|
                                                                    Pointer.Kind.Ref,
                                                                    M.deref (|
                                                                      M.borrow (|
                                                                        Pointer.Kind.Ref,
                                                                        M.deref (|
                                                                          M.read (| left_val |)
                                                                        |)
                                                                      |)
                                                                    |)
                                                                  |);
                                                                  M.borrow (|
                                                                    Pointer.Kind.Ref,
                                                                    M.deref (|
                                                                      M.borrow (|
                                                                        Pointer.Kind.Ref,
                                                                        M.deref (|
                                                                          M.read (| right_val |)
                                                                        |)
                                                                      |)
                                                                    |)
                                                                  |);
                                                                  Value.StructTuple
                                                                    "core::option::Option::None"
                                                                    []
                                                                    [ Ty.path "core::fmt::Arguments"
                                                                    ]
                                                                    []
                                                                ]
                                                              |)
                                                            |)
                                                          |)
                                                        |)));
                                                    fun γ => ltac:(M.monadic (Value.Tuple []))
                                                  ]
                                                |)))
                                          ]
                                        |) in
                                      M.alloc (| Ty.tuple [], Value.Tuple [] |)
                                    |)));
                                fun γ => ltac:(M.monadic (Value.Tuple []))
                              ]
                            |) in
                          M.alloc (|
                            Ty.apply
                              (Ty.path "&")
                              []
                              [
                                Ty.apply
                                  (Ty.path
                                    "openvm_circuit::arch::integration_api::MinimalInstruction")
                                  []
                                  [ T ]
                              ],
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.SubPointer.get_array_field (|
                                    M.deref (| M.read (| shorts |) |),
                                    Value.Integer IntegerKind.Usize 0
                                  |)
                                |)
                              |)
                            |)
                          |)
                        |)))
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::borrow::Borrow"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "openvm_circuit::arch::integration_api::MinimalInstruction") [] [ T ]
          ]
          (Self T)
          (* Instance *) [ ("borrow", InstanceField.Method (borrow T)) ].
    End Impl_core_borrow_Borrow_openvm_circuit_arch_integration_api_MinimalInstruction_T_for_slice_T.
    
    Module Impl_core_borrow_BorrowMut_openvm_circuit_arch_integration_api_MinimalInstruction_T_for_slice_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "slice") [] [ T ].
      
      (* AlignedBorrow *)
      Definition borrow_mut (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                self
              |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.read (|
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      Ty.tuple [],
                      M.alloc (| Ty.tuple [], Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.use (M.alloc (| Ty.path "bool", Value.Bool true |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.read (|
                              let~ _ : Ty.tuple [] :=
                                M.match_operator (|
                                  Ty.tuple [],
                                  M.alloc (|
                                    Ty.tuple
                                      [
                                        Ty.apply (Ty.path "&") [] [ Ty.path "usize" ];
                                        Ty.apply (Ty.path "&") [] [ Ty.path "usize" ]
                                      ],
                                    Value.Tuple
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.alloc (|
                                            Ty.path "usize",
                                            M.call_closure (|
                                              Ty.path "usize",
                                              M.get_associated_function (|
                                                Ty.apply (Ty.path "slice") [] [ T ],
                                                "len",
                                                [],
                                                []
                                              |),
                                              [
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (| M.read (| self |) |)
                                                |)
                                              ]
                                            |)
                                          |)
                                        |);
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.alloc (|
                                            Ty.path "usize",
                                            M.call_closure (|
                                              Ty.path "usize",
                                              M.get_associated_function (|
                                                Ty.apply
                                                  (Ty.path
                                                    "openvm_circuit::arch::integration_api::MinimalInstruction")
                                                  []
                                                  [ T ],
                                                "width",
                                                [],
                                                []
                                              |),
                                              []
                                            |)
                                          |)
                                        |)
                                      ]
                                  |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                        let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                        let left_val :=
                                          M.copy (|
                                            Ty.apply (Ty.path "&") [] [ Ty.path "usize" ],
                                            γ0_0
                                          |) in
                                        let right_val :=
                                          M.copy (|
                                            Ty.apply (Ty.path "&") [] [ Ty.path "usize" ],
                                            γ0_1
                                          |) in
                                        M.match_operator (|
                                          Ty.tuple [],
                                          M.alloc (| Ty.tuple [], Value.Tuple [] |),
                                          [
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let γ :=
                                                  M.use
                                                    (M.alloc (|
                                                      Ty.path "bool",
                                                      UnOp.not (|
                                                        M.call_closure (|
                                                          Ty.path "bool",
                                                          BinOp.eq,
                                                          [
                                                            M.read (|
                                                              M.deref (| M.read (| left_val |) |)
                                                            |);
                                                            M.read (|
                                                              M.deref (| M.read (| right_val |) |)
                                                            |)
                                                          ]
                                                        |)
                                                      |)
                                                    |)) in
                                                let _ :=
                                                  is_constant_or_break_match (|
                                                    M.read (| γ |),
                                                    Value.Bool true
                                                  |) in
                                                M.never_to_any (|
                                                  M.read (|
                                                    let~ kind :
                                                        Ty.path "core::panicking::AssertKind" :=
                                                      Value.StructTuple
                                                        "core::panicking::AssertKind::Eq"
                                                        []
                                                        []
                                                        [] in
                                                    M.alloc (|
                                                      Ty.path "never",
                                                      M.call_closure (|
                                                        Ty.path "never",
                                                        M.get_function (|
                                                          "core::panicking::assert_failed",
                                                          [],
                                                          [ Ty.path "usize"; Ty.path "usize" ]
                                                        |),
                                                        [
                                                          M.read (| kind |);
                                                          M.borrow (|
                                                            Pointer.Kind.Ref,
                                                            M.deref (|
                                                              M.borrow (|
                                                                Pointer.Kind.Ref,
                                                                M.deref (| M.read (| left_val |) |)
                                                              |)
                                                            |)
                                                          |);
                                                          M.borrow (|
                                                            Pointer.Kind.Ref,
                                                            M.deref (|
                                                              M.borrow (|
                                                                Pointer.Kind.Ref,
                                                                M.deref (| M.read (| right_val |) |)
                                                              |)
                                                            |)
                                                          |);
                                                          Value.StructTuple
                                                            "core::option::Option::None"
                                                            []
                                                            [ Ty.path "core::fmt::Arguments" ]
                                                            []
                                                        ]
                                                      |)
                                                    |)
                                                  |)
                                                |)));
                                            fun γ => ltac:(M.monadic (Value.Tuple []))
                                          ]
                                        |)))
                                  ]
                                |) in
                              M.alloc (| Ty.tuple [], Value.Tuple [] |)
                            |)));
                        fun γ => ltac:(M.monadic (Value.Tuple []))
                      ]
                    |) in
                  M.alloc (|
                    Ty.apply
                      (Ty.path "&mut")
                      []
                      [
                        Ty.apply
                          (Ty.path "openvm_circuit::arch::integration_api::MinimalInstruction")
                          []
                          [ T ]
                      ],
                    M.match_operator (|
                      Ty.apply
                        (Ty.path "&mut")
                        []
                        [
                          Ty.apply
                            (Ty.path "openvm_circuit::arch::integration_api::MinimalInstruction")
                            []
                            [ T ]
                        ],
                      M.alloc (|
                        Ty.tuple
                          [
                            Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ];
                            Ty.apply
                              (Ty.path "&mut")
                              []
                              [
                                Ty.apply
                                  (Ty.path "slice")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path
                                        "openvm_circuit::arch::integration_api::MinimalInstruction")
                                      []
                                      [ T ]
                                  ]
                              ];
                            Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ]
                          ],
                        M.call_closure (|
                          Ty.tuple
                            [
                              Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ];
                              Ty.apply
                                (Ty.path "&mut")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "slice")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path
                                          "openvm_circuit::arch::integration_api::MinimalInstruction")
                                        []
                                        [ T ]
                                    ]
                                ];
                              Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ]
                            ],
                          M.get_associated_function (|
                            Ty.apply (Ty.path "slice") [] [ T ],
                            "align_to_mut",
                            [],
                            [
                              Ty.apply
                                (Ty.path
                                  "openvm_circuit::arch::integration_api::MinimalInstruction")
                                []
                                [ T ]
                            ]
                          |),
                          [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |) ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_2 := M.SubPointer.get_tuple_field (| γ, 2 |) in
                            let prefix :=
                              M.copy (|
                                Ty.apply
                                  (Ty.path "&mut")
                                  []
                                  [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                γ0_0
                              |) in
                            let shorts :=
                              M.copy (|
                                Ty.apply
                                  (Ty.path "&mut")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "slice")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path
                                            "openvm_circuit::arch::integration_api::MinimalInstruction")
                                          []
                                          [ T ]
                                      ]
                                  ],
                                γ0_1
                              |) in
                            let _suffix :=
                              M.copy (|
                                Ty.apply
                                  (Ty.path "&mut")
                                  []
                                  [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                γ0_2
                              |) in
                            M.read (|
                              let~ _ : Ty.tuple [] :=
                                M.match_operator (|
                                  Ty.tuple [],
                                  M.alloc (| Ty.tuple [], Value.Tuple [] |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ :=
                                          M.use (M.alloc (| Ty.path "bool", Value.Bool true |)) in
                                        let _ :=
                                          is_constant_or_break_match (|
                                            M.read (| γ |),
                                            Value.Bool true
                                          |) in
                                        M.read (|
                                          let~ _ : Ty.tuple [] :=
                                            M.match_operator (|
                                              Ty.tuple [],
                                              M.alloc (| Ty.tuple [], Value.Tuple [] |),
                                              [
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (let γ :=
                                                      M.use
                                                        (M.alloc (|
                                                          Ty.path "bool",
                                                          UnOp.not (|
                                                            M.call_closure (|
                                                              Ty.path "bool",
                                                              M.get_associated_function (|
                                                                Ty.apply (Ty.path "slice") [] [ T ],
                                                                "is_empty",
                                                                [],
                                                                []
                                                              |),
                                                              [
                                                                M.borrow (|
                                                                  Pointer.Kind.Ref,
                                                                  M.deref (| M.read (| prefix |) |)
                                                                |)
                                                              ]
                                                            |)
                                                          |)
                                                        |)) in
                                                    let _ :=
                                                      is_constant_or_break_match (|
                                                        M.read (| γ |),
                                                        Value.Bool true
                                                      |) in
                                                    M.never_to_any (|
                                                      M.call_closure (|
                                                        Ty.path "never",
                                                        M.get_function (|
                                                          "core::panicking::panic_fmt",
                                                          [],
                                                          []
                                                        |),
                                                        [
                                                          M.call_closure (|
                                                            Ty.path "core::fmt::Arguments",
                                                            M.get_associated_function (|
                                                              Ty.path "core::fmt::Arguments",
                                                              "new_const",
                                                              [ Value.Integer IntegerKind.Usize 1 ],
                                                              []
                                                            |),
                                                            [
                                                              M.borrow (|
                                                                Pointer.Kind.Ref,
                                                                M.deref (|
                                                                  M.borrow (|
                                                                    Pointer.Kind.Ref,
                                                                    M.alloc (|
                                                                      Ty.apply
                                                                        (Ty.path "array")
                                                                        [
                                                                          Value.Integer
                                                                            IntegerKind.Usize
                                                                            1
                                                                        ]
                                                                        [
                                                                          Ty.apply
                                                                            (Ty.path "&")
                                                                            []
                                                                            [ Ty.path "str" ]
                                                                        ],
                                                                      Value.Array
                                                                        [
                                                                          mk_str (|
                                                                            "Alignment should match"
                                                                          |)
                                                                        ]
                                                                    |)
                                                                  |)
                                                                |)
                                                              |)
                                                            ]
                                                          |)
                                                        ]
                                                      |)
                                                    |)));
                                                fun γ => ltac:(M.monadic (Value.Tuple []))
                                              ]
                                            |) in
                                          M.alloc (| Ty.tuple [], Value.Tuple [] |)
                                        |)));
                                    fun γ => ltac:(M.monadic (Value.Tuple []))
                                  ]
                                |) in
                              let~ _ : Ty.tuple [] :=
                                M.match_operator (|
                                  Ty.tuple [],
                                  M.alloc (| Ty.tuple [], Value.Tuple [] |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ :=
                                          M.use (M.alloc (| Ty.path "bool", Value.Bool true |)) in
                                        let _ :=
                                          is_constant_or_break_match (|
                                            M.read (| γ |),
                                            Value.Bool true
                                          |) in
                                        M.read (|
                                          let~ _ : Ty.tuple [] :=
                                            M.match_operator (|
                                              Ty.tuple [],
                                              M.alloc (|
                                                Ty.tuple
                                                  [
                                                    Ty.apply (Ty.path "&") [] [ Ty.path "usize" ];
                                                    Ty.apply (Ty.path "&") [] [ Ty.path "usize" ]
                                                  ],
                                                Value.Tuple
                                                  [
                                                    M.borrow (|
                                                      Pointer.Kind.Ref,
                                                      M.alloc (|
                                                        Ty.path "usize",
                                                        M.call_closure (|
                                                          Ty.path "usize",
                                                          M.get_associated_function (|
                                                            Ty.apply
                                                              (Ty.path "slice")
                                                              []
                                                              [
                                                                Ty.apply
                                                                  (Ty.path
                                                                    "openvm_circuit::arch::integration_api::MinimalInstruction")
                                                                  []
                                                                  [ T ]
                                                              ],
                                                            "len",
                                                            [],
                                                            []
                                                          |),
                                                          [
                                                            M.borrow (|
                                                              Pointer.Kind.Ref,
                                                              M.deref (| M.read (| shorts |) |)
                                                            |)
                                                          ]
                                                        |)
                                                      |)
                                                    |);
                                                    M.borrow (|
                                                      Pointer.Kind.Ref,
                                                      M.alloc (|
                                                        Ty.path "usize",
                                                        Value.Integer IntegerKind.Usize 1
                                                      |)
                                                    |)
                                                  ]
                                              |),
                                              [
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (let γ0_0 :=
                                                      M.SubPointer.get_tuple_field (| γ, 0 |) in
                                                    let γ0_1 :=
                                                      M.SubPointer.get_tuple_field (| γ, 1 |) in
                                                    let left_val :=
                                                      M.copy (|
                                                        Ty.apply
                                                          (Ty.path "&")
                                                          []
                                                          [ Ty.path "usize" ],
                                                        γ0_0
                                                      |) in
                                                    let right_val :=
                                                      M.copy (|
                                                        Ty.apply
                                                          (Ty.path "&")
                                                          []
                                                          [ Ty.path "usize" ],
                                                        γ0_1
                                                      |) in
                                                    M.match_operator (|
                                                      Ty.tuple [],
                                                      M.alloc (| Ty.tuple [], Value.Tuple [] |),
                                                      [
                                                        fun γ =>
                                                          ltac:(M.monadic
                                                            (let γ :=
                                                              M.use
                                                                (M.alloc (|
                                                                  Ty.path "bool",
                                                                  UnOp.not (|
                                                                    M.call_closure (|
                                                                      Ty.path "bool",
                                                                      BinOp.eq,
                                                                      [
                                                                        M.read (|
                                                                          M.deref (|
                                                                            M.read (| left_val |)
                                                                          |)
                                                                        |);
                                                                        M.read (|
                                                                          M.deref (|
                                                                            M.read (| right_val |)
                                                                          |)
                                                                        |)
                                                                      ]
                                                                    |)
                                                                  |)
                                                                |)) in
                                                            let _ :=
                                                              is_constant_or_break_match (|
                                                                M.read (| γ |),
                                                                Value.Bool true
                                                              |) in
                                                            M.never_to_any (|
                                                              M.read (|
                                                                let~ kind :
                                                                    Ty.path
                                                                      "core::panicking::AssertKind" :=
                                                                  Value.StructTuple
                                                                    "core::panicking::AssertKind::Eq"
                                                                    []
                                                                    []
                                                                    [] in
                                                                M.alloc (|
                                                                  Ty.path "never",
                                                                  M.call_closure (|
                                                                    Ty.path "never",
                                                                    M.get_function (|
                                                                      "core::panicking::assert_failed",
                                                                      [],
                                                                      [
                                                                        Ty.path "usize";
                                                                        Ty.path "usize"
                                                                      ]
                                                                    |),
                                                                    [
                                                                      M.read (| kind |);
                                                                      M.borrow (|
                                                                        Pointer.Kind.Ref,
                                                                        M.deref (|
                                                                          M.borrow (|
                                                                            Pointer.Kind.Ref,
                                                                            M.deref (|
                                                                              M.read (| left_val |)
                                                                            |)
                                                                          |)
                                                                        |)
                                                                      |);
                                                                      M.borrow (|
                                                                        Pointer.Kind.Ref,
                                                                        M.deref (|
                                                                          M.borrow (|
                                                                            Pointer.Kind.Ref,
                                                                            M.deref (|
                                                                              M.read (| right_val |)
                                                                            |)
                                                                          |)
                                                                        |)
                                                                      |);
                                                                      Value.StructTuple
                                                                        "core::option::Option::None"
                                                                        []
                                                                        [
                                                                          Ty.path
                                                                            "core::fmt::Arguments"
                                                                        ]
                                                                        []
                                                                    ]
                                                                  |)
                                                                |)
                                                              |)
                                                            |)));
                                                        fun γ => ltac:(M.monadic (Value.Tuple []))
                                                      ]
                                                    |)))
                                              ]
                                            |) in
                                          M.alloc (| Ty.tuple [], Value.Tuple [] |)
                                        |)));
                                    fun γ => ltac:(M.monadic (Value.Tuple []))
                                  ]
                                |) in
                              M.alloc (|
                                Ty.apply
                                  (Ty.path "&mut")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path
                                        "openvm_circuit::arch::integration_api::MinimalInstruction")
                                      []
                                      [ T ]
                                  ],
                                M.borrow (|
                                  Pointer.Kind.MutRef,
                                  M.deref (|
                                    M.borrow (|
                                      Pointer.Kind.MutRef,
                                      M.SubPointer.get_array_field (|
                                        M.deref (| M.read (| shorts |) |),
                                        Value.Integer IntegerKind.Usize 0
                                      |)
                                    |)
                                  |)
                                |)
                              |)
                            |)))
                      ]
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::borrow::BorrowMut"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "openvm_circuit::arch::integration_api::MinimalInstruction") [] [ T ]
          ]
          (Self T)
          (* Instance *) [ ("borrow_mut", InstanceField.Method (borrow_mut T)) ].
    End Impl_core_borrow_BorrowMut_openvm_circuit_arch_integration_api_MinimalInstruction_T_for_slice_T.
    
    Module Impl_openvm_circuit_arch_integration_api_MinimalInstruction_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "openvm_circuit::arch::integration_api::MinimalInstruction") [] [ T ].
      
      (* AlignedBorrow *)
      Definition width (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [] =>
          ltac:(M.monadic
            (M.call_closure (|
              Ty.path "usize",
              M.get_function (|
                "core::mem::size_of",
                [],
                [
                  Ty.apply
                    (Ty.path "openvm_circuit::arch::integration_api::MinimalInstruction")
                    []
                    [ Ty.path "u8" ]
                ]
              |),
              []
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_width :
        forall (T : Ty.t),
        M.IsAssociatedFunction.C (Self T) "width" (width T).
      Admitted.
      Global Typeclasses Opaque width.
    End Impl_openvm_circuit_arch_integration_api_MinimalInstruction_T.
    
    (* StructRecord
      {
        name := "ImmInstruction";
        const_params := [];
        ty_params := [ "T" ];
        fields := [ ("is_valid", T); ("opcode", T); ("immediate", T) ];
      } *)
    
    Module Impl_core_borrow_Borrow_openvm_circuit_arch_integration_api_ImmInstruction_T_for_slice_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "slice") [] [ T ].
      
      (* AlignedBorrow *)
      Definition borrow (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                self
              |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.match_operator (|
                  Ty.tuple [],
                  M.alloc (| Ty.tuple [], Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.use (M.alloc (| Ty.path "bool", Value.Bool true |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.read (|
                          let~ _ : Ty.tuple [] :=
                            M.match_operator (|
                              Ty.tuple [],
                              M.alloc (|
                                Ty.tuple
                                  [
                                    Ty.apply (Ty.path "&") [] [ Ty.path "usize" ];
                                    Ty.apply (Ty.path "&") [] [ Ty.path "usize" ]
                                  ],
                                Value.Tuple
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.alloc (|
                                        Ty.path "usize",
                                        M.call_closure (|
                                          Ty.path "usize",
                                          M.get_associated_function (|
                                            Ty.apply (Ty.path "slice") [] [ T ],
                                            "len",
                                            [],
                                            []
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (| M.read (| self |) |)
                                            |)
                                          ]
                                        |)
                                      |)
                                    |);
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.alloc (|
                                        Ty.path "usize",
                                        M.call_closure (|
                                          Ty.path "usize",
                                          M.get_associated_function (|
                                            Ty.apply
                                              (Ty.path
                                                "openvm_circuit::arch::integration_api::ImmInstruction")
                                              []
                                              [ T ],
                                            "width",
                                            [],
                                            []
                                          |),
                                          []
                                        |)
                                      |)
                                    |)
                                  ]
                              |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                    let left_val :=
                                      M.copy (|
                                        Ty.apply (Ty.path "&") [] [ Ty.path "usize" ],
                                        γ0_0
                                      |) in
                                    let right_val :=
                                      M.copy (|
                                        Ty.apply (Ty.path "&") [] [ Ty.path "usize" ],
                                        γ0_1
                                      |) in
                                    M.match_operator (|
                                      Ty.tuple [],
                                      M.alloc (| Ty.tuple [], Value.Tuple [] |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ :=
                                              M.use
                                                (M.alloc (|
                                                  Ty.path "bool",
                                                  UnOp.not (|
                                                    M.call_closure (|
                                                      Ty.path "bool",
                                                      BinOp.eq,
                                                      [
                                                        M.read (|
                                                          M.deref (| M.read (| left_val |) |)
                                                        |);
                                                        M.read (|
                                                          M.deref (| M.read (| right_val |) |)
                                                        |)
                                                      ]
                                                    |)
                                                  |)
                                                |)) in
                                            let _ :=
                                              is_constant_or_break_match (|
                                                M.read (| γ |),
                                                Value.Bool true
                                              |) in
                                            M.never_to_any (|
                                              M.read (|
                                                let~ kind : Ty.path "core::panicking::AssertKind" :=
                                                  Value.StructTuple
                                                    "core::panicking::AssertKind::Eq"
                                                    []
                                                    []
                                                    [] in
                                                M.alloc (|
                                                  Ty.path "never",
                                                  M.call_closure (|
                                                    Ty.path "never",
                                                    M.get_function (|
                                                      "core::panicking::assert_failed",
                                                      [],
                                                      [ Ty.path "usize"; Ty.path "usize" ]
                                                    |),
                                                    [
                                                      M.read (| kind |);
                                                      M.borrow (|
                                                        Pointer.Kind.Ref,
                                                        M.deref (|
                                                          M.borrow (|
                                                            Pointer.Kind.Ref,
                                                            M.deref (| M.read (| left_val |) |)
                                                          |)
                                                        |)
                                                      |);
                                                      M.borrow (|
                                                        Pointer.Kind.Ref,
                                                        M.deref (|
                                                          M.borrow (|
                                                            Pointer.Kind.Ref,
                                                            M.deref (| M.read (| right_val |) |)
                                                          |)
                                                        |)
                                                      |);
                                                      Value.StructTuple
                                                        "core::option::Option::None"
                                                        []
                                                        [ Ty.path "core::fmt::Arguments" ]
                                                        []
                                                    ]
                                                  |)
                                                |)
                                              |)
                                            |)));
                                        fun γ => ltac:(M.monadic (Value.Tuple []))
                                      ]
                                    |)))
                              ]
                            |) in
                          M.alloc (| Ty.tuple [], Value.Tuple [] |)
                        |)));
                    fun γ => ltac:(M.monadic (Value.Tuple []))
                  ]
                |) in
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path "openvm_circuit::arch::integration_api::ImmInstruction")
                      []
                      [ T ]
                  ],
                M.match_operator (|
                  Ty.apply
                    (Ty.path "&")
                    []
                    [
                      Ty.apply
                        (Ty.path "openvm_circuit::arch::integration_api::ImmInstruction")
                        []
                        [ T ]
                    ],
                  M.alloc (|
                    Ty.tuple
                      [
                        Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ];
                        Ty.apply
                          (Ty.path "&")
                          []
                          [
                            Ty.apply
                              (Ty.path "slice")
                              []
                              [
                                Ty.apply
                                  (Ty.path "openvm_circuit::arch::integration_api::ImmInstruction")
                                  []
                                  [ T ]
                              ]
                          ];
                        Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ]
                      ],
                    M.call_closure (|
                      Ty.tuple
                        [
                          Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ];
                          Ty.apply
                            (Ty.path "&")
                            []
                            [
                              Ty.apply
                                (Ty.path "slice")
                                []
                                [
                                  Ty.apply
                                    (Ty.path
                                      "openvm_circuit::arch::integration_api::ImmInstruction")
                                    []
                                    [ T ]
                                ]
                            ];
                          Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ]
                        ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "slice") [] [ T ],
                        "align_to",
                        [],
                        [
                          Ty.apply
                            (Ty.path "openvm_circuit::arch::integration_api::ImmInstruction")
                            []
                            [ T ]
                        ]
                      |),
                      [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                        let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                        let γ0_2 := M.SubPointer.get_tuple_field (| γ, 2 |) in
                        let prefix :=
                          M.copy (|
                            Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                            γ0_0
                          |) in
                        let shorts :=
                          M.copy (|
                            Ty.apply
                              (Ty.path "&")
                              []
                              [
                                Ty.apply
                                  (Ty.path "slice")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path
                                        "openvm_circuit::arch::integration_api::ImmInstruction")
                                      []
                                      [ T ]
                                  ]
                              ],
                            γ0_1
                          |) in
                        let _suffix :=
                          M.copy (|
                            Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                            γ0_2
                          |) in
                        M.read (|
                          let~ _ : Ty.tuple [] :=
                            M.match_operator (|
                              Ty.tuple [],
                              M.alloc (| Ty.tuple [], Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ :=
                                      M.use (M.alloc (| Ty.path "bool", Value.Bool true |)) in
                                    let _ :=
                                      is_constant_or_break_match (|
                                        M.read (| γ |),
                                        Value.Bool true
                                      |) in
                                    M.read (|
                                      let~ _ : Ty.tuple [] :=
                                        M.match_operator (|
                                          Ty.tuple [],
                                          M.alloc (| Ty.tuple [], Value.Tuple [] |),
                                          [
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let γ :=
                                                  M.use
                                                    (M.alloc (|
                                                      Ty.path "bool",
                                                      UnOp.not (|
                                                        M.call_closure (|
                                                          Ty.path "bool",
                                                          M.get_associated_function (|
                                                            Ty.apply (Ty.path "slice") [] [ T ],
                                                            "is_empty",
                                                            [],
                                                            []
                                                          |),
                                                          [
                                                            M.borrow (|
                                                              Pointer.Kind.Ref,
                                                              M.deref (| M.read (| prefix |) |)
                                                            |)
                                                          ]
                                                        |)
                                                      |)
                                                    |)) in
                                                let _ :=
                                                  is_constant_or_break_match (|
                                                    M.read (| γ |),
                                                    Value.Bool true
                                                  |) in
                                                M.never_to_any (|
                                                  M.call_closure (|
                                                    Ty.path "never",
                                                    M.get_function (|
                                                      "core::panicking::panic_fmt",
                                                      [],
                                                      []
                                                    |),
                                                    [
                                                      M.call_closure (|
                                                        Ty.path "core::fmt::Arguments",
                                                        M.get_associated_function (|
                                                          Ty.path "core::fmt::Arguments",
                                                          "new_const",
                                                          [ Value.Integer IntegerKind.Usize 1 ],
                                                          []
                                                        |),
                                                        [
                                                          M.borrow (|
                                                            Pointer.Kind.Ref,
                                                            M.deref (|
                                                              M.borrow (|
                                                                Pointer.Kind.Ref,
                                                                M.alloc (|
                                                                  Ty.apply
                                                                    (Ty.path "array")
                                                                    [
                                                                      Value.Integer
                                                                        IntegerKind.Usize
                                                                        1
                                                                    ]
                                                                    [
                                                                      Ty.apply
                                                                        (Ty.path "&")
                                                                        []
                                                                        [ Ty.path "str" ]
                                                                    ],
                                                                  Value.Array
                                                                    [
                                                                      mk_str (|
                                                                        "Alignment should match"
                                                                      |)
                                                                    ]
                                                                |)
                                                              |)
                                                            |)
                                                          |)
                                                        ]
                                                      |)
                                                    ]
                                                  |)
                                                |)));
                                            fun γ => ltac:(M.monadic (Value.Tuple []))
                                          ]
                                        |) in
                                      M.alloc (| Ty.tuple [], Value.Tuple [] |)
                                    |)));
                                fun γ => ltac:(M.monadic (Value.Tuple []))
                              ]
                            |) in
                          let~ _ : Ty.tuple [] :=
                            M.match_operator (|
                              Ty.tuple [],
                              M.alloc (| Ty.tuple [], Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ :=
                                      M.use (M.alloc (| Ty.path "bool", Value.Bool true |)) in
                                    let _ :=
                                      is_constant_or_break_match (|
                                        M.read (| γ |),
                                        Value.Bool true
                                      |) in
                                    M.read (|
                                      let~ _ : Ty.tuple [] :=
                                        M.match_operator (|
                                          Ty.tuple [],
                                          M.alloc (|
                                            Ty.tuple
                                              [
                                                Ty.apply (Ty.path "&") [] [ Ty.path "usize" ];
                                                Ty.apply (Ty.path "&") [] [ Ty.path "usize" ]
                                              ],
                                            Value.Tuple
                                              [
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.alloc (|
                                                    Ty.path "usize",
                                                    M.call_closure (|
                                                      Ty.path "usize",
                                                      M.get_associated_function (|
                                                        Ty.apply
                                                          (Ty.path "slice")
                                                          []
                                                          [
                                                            Ty.apply
                                                              (Ty.path
                                                                "openvm_circuit::arch::integration_api::ImmInstruction")
                                                              []
                                                              [ T ]
                                                          ],
                                                        "len",
                                                        [],
                                                        []
                                                      |),
                                                      [
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.deref (| M.read (| shorts |) |)
                                                        |)
                                                      ]
                                                    |)
                                                  |)
                                                |);
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.alloc (|
                                                    Ty.path "usize",
                                                    Value.Integer IntegerKind.Usize 1
                                                  |)
                                                |)
                                              ]
                                          |),
                                          [
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let γ0_0 :=
                                                  M.SubPointer.get_tuple_field (| γ, 0 |) in
                                                let γ0_1 :=
                                                  M.SubPointer.get_tuple_field (| γ, 1 |) in
                                                let left_val :=
                                                  M.copy (|
                                                    Ty.apply (Ty.path "&") [] [ Ty.path "usize" ],
                                                    γ0_0
                                                  |) in
                                                let right_val :=
                                                  M.copy (|
                                                    Ty.apply (Ty.path "&") [] [ Ty.path "usize" ],
                                                    γ0_1
                                                  |) in
                                                M.match_operator (|
                                                  Ty.tuple [],
                                                  M.alloc (| Ty.tuple [], Value.Tuple [] |),
                                                  [
                                                    fun γ =>
                                                      ltac:(M.monadic
                                                        (let γ :=
                                                          M.use
                                                            (M.alloc (|
                                                              Ty.path "bool",
                                                              UnOp.not (|
                                                                M.call_closure (|
                                                                  Ty.path "bool",
                                                                  BinOp.eq,
                                                                  [
                                                                    M.read (|
                                                                      M.deref (|
                                                                        M.read (| left_val |)
                                                                      |)
                                                                    |);
                                                                    M.read (|
                                                                      M.deref (|
                                                                        M.read (| right_val |)
                                                                      |)
                                                                    |)
                                                                  ]
                                                                |)
                                                              |)
                                                            |)) in
                                                        let _ :=
                                                          is_constant_or_break_match (|
                                                            M.read (| γ |),
                                                            Value.Bool true
                                                          |) in
                                                        M.never_to_any (|
                                                          M.read (|
                                                            let~ kind :
                                                                Ty.path
                                                                  "core::panicking::AssertKind" :=
                                                              Value.StructTuple
                                                                "core::panicking::AssertKind::Eq"
                                                                []
                                                                []
                                                                [] in
                                                            M.alloc (|
                                                              Ty.path "never",
                                                              M.call_closure (|
                                                                Ty.path "never",
                                                                M.get_function (|
                                                                  "core::panicking::assert_failed",
                                                                  [],
                                                                  [ Ty.path "usize"; Ty.path "usize"
                                                                  ]
                                                                |),
                                                                [
                                                                  M.read (| kind |);
                                                                  M.borrow (|
                                                                    Pointer.Kind.Ref,
                                                                    M.deref (|
                                                                      M.borrow (|
                                                                        Pointer.Kind.Ref,
                                                                        M.deref (|
                                                                          M.read (| left_val |)
                                                                        |)
                                                                      |)
                                                                    |)
                                                                  |);
                                                                  M.borrow (|
                                                                    Pointer.Kind.Ref,
                                                                    M.deref (|
                                                                      M.borrow (|
                                                                        Pointer.Kind.Ref,
                                                                        M.deref (|
                                                                          M.read (| right_val |)
                                                                        |)
                                                                      |)
                                                                    |)
                                                                  |);
                                                                  Value.StructTuple
                                                                    "core::option::Option::None"
                                                                    []
                                                                    [ Ty.path "core::fmt::Arguments"
                                                                    ]
                                                                    []
                                                                ]
                                                              |)
                                                            |)
                                                          |)
                                                        |)));
                                                    fun γ => ltac:(M.monadic (Value.Tuple []))
                                                  ]
                                                |)))
                                          ]
                                        |) in
                                      M.alloc (| Ty.tuple [], Value.Tuple [] |)
                                    |)));
                                fun γ => ltac:(M.monadic (Value.Tuple []))
                              ]
                            |) in
                          M.alloc (|
                            Ty.apply
                              (Ty.path "&")
                              []
                              [
                                Ty.apply
                                  (Ty.path "openvm_circuit::arch::integration_api::ImmInstruction")
                                  []
                                  [ T ]
                              ],
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.SubPointer.get_array_field (|
                                    M.deref (| M.read (| shorts |) |),
                                    Value.Integer IntegerKind.Usize 0
                                  |)
                                |)
                              |)
                            |)
                          |)
                        |)))
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::borrow::Borrow"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "openvm_circuit::arch::integration_api::ImmInstruction") [] [ T ] ]
          (Self T)
          (* Instance *) [ ("borrow", InstanceField.Method (borrow T)) ].
    End Impl_core_borrow_Borrow_openvm_circuit_arch_integration_api_ImmInstruction_T_for_slice_T.
    
    Module Impl_core_borrow_BorrowMut_openvm_circuit_arch_integration_api_ImmInstruction_T_for_slice_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "slice") [] [ T ].
      
      (* AlignedBorrow *)
      Definition borrow_mut (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                self
              |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.read (|
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      Ty.tuple [],
                      M.alloc (| Ty.tuple [], Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.use (M.alloc (| Ty.path "bool", Value.Bool true |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.read (|
                              let~ _ : Ty.tuple [] :=
                                M.match_operator (|
                                  Ty.tuple [],
                                  M.alloc (|
                                    Ty.tuple
                                      [
                                        Ty.apply (Ty.path "&") [] [ Ty.path "usize" ];
                                        Ty.apply (Ty.path "&") [] [ Ty.path "usize" ]
                                      ],
                                    Value.Tuple
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.alloc (|
                                            Ty.path "usize",
                                            M.call_closure (|
                                              Ty.path "usize",
                                              M.get_associated_function (|
                                                Ty.apply (Ty.path "slice") [] [ T ],
                                                "len",
                                                [],
                                                []
                                              |),
                                              [
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (| M.read (| self |) |)
                                                |)
                                              ]
                                            |)
                                          |)
                                        |);
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.alloc (|
                                            Ty.path "usize",
                                            M.call_closure (|
                                              Ty.path "usize",
                                              M.get_associated_function (|
                                                Ty.apply
                                                  (Ty.path
                                                    "openvm_circuit::arch::integration_api::ImmInstruction")
                                                  []
                                                  [ T ],
                                                "width",
                                                [],
                                                []
                                              |),
                                              []
                                            |)
                                          |)
                                        |)
                                      ]
                                  |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                        let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                        let left_val :=
                                          M.copy (|
                                            Ty.apply (Ty.path "&") [] [ Ty.path "usize" ],
                                            γ0_0
                                          |) in
                                        let right_val :=
                                          M.copy (|
                                            Ty.apply (Ty.path "&") [] [ Ty.path "usize" ],
                                            γ0_1
                                          |) in
                                        M.match_operator (|
                                          Ty.tuple [],
                                          M.alloc (| Ty.tuple [], Value.Tuple [] |),
                                          [
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let γ :=
                                                  M.use
                                                    (M.alloc (|
                                                      Ty.path "bool",
                                                      UnOp.not (|
                                                        M.call_closure (|
                                                          Ty.path "bool",
                                                          BinOp.eq,
                                                          [
                                                            M.read (|
                                                              M.deref (| M.read (| left_val |) |)
                                                            |);
                                                            M.read (|
                                                              M.deref (| M.read (| right_val |) |)
                                                            |)
                                                          ]
                                                        |)
                                                      |)
                                                    |)) in
                                                let _ :=
                                                  is_constant_or_break_match (|
                                                    M.read (| γ |),
                                                    Value.Bool true
                                                  |) in
                                                M.never_to_any (|
                                                  M.read (|
                                                    let~ kind :
                                                        Ty.path "core::panicking::AssertKind" :=
                                                      Value.StructTuple
                                                        "core::panicking::AssertKind::Eq"
                                                        []
                                                        []
                                                        [] in
                                                    M.alloc (|
                                                      Ty.path "never",
                                                      M.call_closure (|
                                                        Ty.path "never",
                                                        M.get_function (|
                                                          "core::panicking::assert_failed",
                                                          [],
                                                          [ Ty.path "usize"; Ty.path "usize" ]
                                                        |),
                                                        [
                                                          M.read (| kind |);
                                                          M.borrow (|
                                                            Pointer.Kind.Ref,
                                                            M.deref (|
                                                              M.borrow (|
                                                                Pointer.Kind.Ref,
                                                                M.deref (| M.read (| left_val |) |)
                                                              |)
                                                            |)
                                                          |);
                                                          M.borrow (|
                                                            Pointer.Kind.Ref,
                                                            M.deref (|
                                                              M.borrow (|
                                                                Pointer.Kind.Ref,
                                                                M.deref (| M.read (| right_val |) |)
                                                              |)
                                                            |)
                                                          |);
                                                          Value.StructTuple
                                                            "core::option::Option::None"
                                                            []
                                                            [ Ty.path "core::fmt::Arguments" ]
                                                            []
                                                        ]
                                                      |)
                                                    |)
                                                  |)
                                                |)));
                                            fun γ => ltac:(M.monadic (Value.Tuple []))
                                          ]
                                        |)))
                                  ]
                                |) in
                              M.alloc (| Ty.tuple [], Value.Tuple [] |)
                            |)));
                        fun γ => ltac:(M.monadic (Value.Tuple []))
                      ]
                    |) in
                  M.alloc (|
                    Ty.apply
                      (Ty.path "&mut")
                      []
                      [
                        Ty.apply
                          (Ty.path "openvm_circuit::arch::integration_api::ImmInstruction")
                          []
                          [ T ]
                      ],
                    M.match_operator (|
                      Ty.apply
                        (Ty.path "&mut")
                        []
                        [
                          Ty.apply
                            (Ty.path "openvm_circuit::arch::integration_api::ImmInstruction")
                            []
                            [ T ]
                        ],
                      M.alloc (|
                        Ty.tuple
                          [
                            Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ];
                            Ty.apply
                              (Ty.path "&mut")
                              []
                              [
                                Ty.apply
                                  (Ty.path "slice")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path
                                        "openvm_circuit::arch::integration_api::ImmInstruction")
                                      []
                                      [ T ]
                                  ]
                              ];
                            Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ]
                          ],
                        M.call_closure (|
                          Ty.tuple
                            [
                              Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ];
                              Ty.apply
                                (Ty.path "&mut")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "slice")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path
                                          "openvm_circuit::arch::integration_api::ImmInstruction")
                                        []
                                        [ T ]
                                    ]
                                ];
                              Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ]
                            ],
                          M.get_associated_function (|
                            Ty.apply (Ty.path "slice") [] [ T ],
                            "align_to_mut",
                            [],
                            [
                              Ty.apply
                                (Ty.path "openvm_circuit::arch::integration_api::ImmInstruction")
                                []
                                [ T ]
                            ]
                          |),
                          [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |) ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_2 := M.SubPointer.get_tuple_field (| γ, 2 |) in
                            let prefix :=
                              M.copy (|
                                Ty.apply
                                  (Ty.path "&mut")
                                  []
                                  [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                γ0_0
                              |) in
                            let shorts :=
                              M.copy (|
                                Ty.apply
                                  (Ty.path "&mut")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "slice")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path
                                            "openvm_circuit::arch::integration_api::ImmInstruction")
                                          []
                                          [ T ]
                                      ]
                                  ],
                                γ0_1
                              |) in
                            let _suffix :=
                              M.copy (|
                                Ty.apply
                                  (Ty.path "&mut")
                                  []
                                  [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                γ0_2
                              |) in
                            M.read (|
                              let~ _ : Ty.tuple [] :=
                                M.match_operator (|
                                  Ty.tuple [],
                                  M.alloc (| Ty.tuple [], Value.Tuple [] |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ :=
                                          M.use (M.alloc (| Ty.path "bool", Value.Bool true |)) in
                                        let _ :=
                                          is_constant_or_break_match (|
                                            M.read (| γ |),
                                            Value.Bool true
                                          |) in
                                        M.read (|
                                          let~ _ : Ty.tuple [] :=
                                            M.match_operator (|
                                              Ty.tuple [],
                                              M.alloc (| Ty.tuple [], Value.Tuple [] |),
                                              [
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (let γ :=
                                                      M.use
                                                        (M.alloc (|
                                                          Ty.path "bool",
                                                          UnOp.not (|
                                                            M.call_closure (|
                                                              Ty.path "bool",
                                                              M.get_associated_function (|
                                                                Ty.apply (Ty.path "slice") [] [ T ],
                                                                "is_empty",
                                                                [],
                                                                []
                                                              |),
                                                              [
                                                                M.borrow (|
                                                                  Pointer.Kind.Ref,
                                                                  M.deref (| M.read (| prefix |) |)
                                                                |)
                                                              ]
                                                            |)
                                                          |)
                                                        |)) in
                                                    let _ :=
                                                      is_constant_or_break_match (|
                                                        M.read (| γ |),
                                                        Value.Bool true
                                                      |) in
                                                    M.never_to_any (|
                                                      M.call_closure (|
                                                        Ty.path "never",
                                                        M.get_function (|
                                                          "core::panicking::panic_fmt",
                                                          [],
                                                          []
                                                        |),
                                                        [
                                                          M.call_closure (|
                                                            Ty.path "core::fmt::Arguments",
                                                            M.get_associated_function (|
                                                              Ty.path "core::fmt::Arguments",
                                                              "new_const",
                                                              [ Value.Integer IntegerKind.Usize 1 ],
                                                              []
                                                            |),
                                                            [
                                                              M.borrow (|
                                                                Pointer.Kind.Ref,
                                                                M.deref (|
                                                                  M.borrow (|
                                                                    Pointer.Kind.Ref,
                                                                    M.alloc (|
                                                                      Ty.apply
                                                                        (Ty.path "array")
                                                                        [
                                                                          Value.Integer
                                                                            IntegerKind.Usize
                                                                            1
                                                                        ]
                                                                        [
                                                                          Ty.apply
                                                                            (Ty.path "&")
                                                                            []
                                                                            [ Ty.path "str" ]
                                                                        ],
                                                                      Value.Array
                                                                        [
                                                                          mk_str (|
                                                                            "Alignment should match"
                                                                          |)
                                                                        ]
                                                                    |)
                                                                  |)
                                                                |)
                                                              |)
                                                            ]
                                                          |)
                                                        ]
                                                      |)
                                                    |)));
                                                fun γ => ltac:(M.monadic (Value.Tuple []))
                                              ]
                                            |) in
                                          M.alloc (| Ty.tuple [], Value.Tuple [] |)
                                        |)));
                                    fun γ => ltac:(M.monadic (Value.Tuple []))
                                  ]
                                |) in
                              let~ _ : Ty.tuple [] :=
                                M.match_operator (|
                                  Ty.tuple [],
                                  M.alloc (| Ty.tuple [], Value.Tuple [] |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ :=
                                          M.use (M.alloc (| Ty.path "bool", Value.Bool true |)) in
                                        let _ :=
                                          is_constant_or_break_match (|
                                            M.read (| γ |),
                                            Value.Bool true
                                          |) in
                                        M.read (|
                                          let~ _ : Ty.tuple [] :=
                                            M.match_operator (|
                                              Ty.tuple [],
                                              M.alloc (|
                                                Ty.tuple
                                                  [
                                                    Ty.apply (Ty.path "&") [] [ Ty.path "usize" ];
                                                    Ty.apply (Ty.path "&") [] [ Ty.path "usize" ]
                                                  ],
                                                Value.Tuple
                                                  [
                                                    M.borrow (|
                                                      Pointer.Kind.Ref,
                                                      M.alloc (|
                                                        Ty.path "usize",
                                                        M.call_closure (|
                                                          Ty.path "usize",
                                                          M.get_associated_function (|
                                                            Ty.apply
                                                              (Ty.path "slice")
                                                              []
                                                              [
                                                                Ty.apply
                                                                  (Ty.path
                                                                    "openvm_circuit::arch::integration_api::ImmInstruction")
                                                                  []
                                                                  [ T ]
                                                              ],
                                                            "len",
                                                            [],
                                                            []
                                                          |),
                                                          [
                                                            M.borrow (|
                                                              Pointer.Kind.Ref,
                                                              M.deref (| M.read (| shorts |) |)
                                                            |)
                                                          ]
                                                        |)
                                                      |)
                                                    |);
                                                    M.borrow (|
                                                      Pointer.Kind.Ref,
                                                      M.alloc (|
                                                        Ty.path "usize",
                                                        Value.Integer IntegerKind.Usize 1
                                                      |)
                                                    |)
                                                  ]
                                              |),
                                              [
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (let γ0_0 :=
                                                      M.SubPointer.get_tuple_field (| γ, 0 |) in
                                                    let γ0_1 :=
                                                      M.SubPointer.get_tuple_field (| γ, 1 |) in
                                                    let left_val :=
                                                      M.copy (|
                                                        Ty.apply
                                                          (Ty.path "&")
                                                          []
                                                          [ Ty.path "usize" ],
                                                        γ0_0
                                                      |) in
                                                    let right_val :=
                                                      M.copy (|
                                                        Ty.apply
                                                          (Ty.path "&")
                                                          []
                                                          [ Ty.path "usize" ],
                                                        γ0_1
                                                      |) in
                                                    M.match_operator (|
                                                      Ty.tuple [],
                                                      M.alloc (| Ty.tuple [], Value.Tuple [] |),
                                                      [
                                                        fun γ =>
                                                          ltac:(M.monadic
                                                            (let γ :=
                                                              M.use
                                                                (M.alloc (|
                                                                  Ty.path "bool",
                                                                  UnOp.not (|
                                                                    M.call_closure (|
                                                                      Ty.path "bool",
                                                                      BinOp.eq,
                                                                      [
                                                                        M.read (|
                                                                          M.deref (|
                                                                            M.read (| left_val |)
                                                                          |)
                                                                        |);
                                                                        M.read (|
                                                                          M.deref (|
                                                                            M.read (| right_val |)
                                                                          |)
                                                                        |)
                                                                      ]
                                                                    |)
                                                                  |)
                                                                |)) in
                                                            let _ :=
                                                              is_constant_or_break_match (|
                                                                M.read (| γ |),
                                                                Value.Bool true
                                                              |) in
                                                            M.never_to_any (|
                                                              M.read (|
                                                                let~ kind :
                                                                    Ty.path
                                                                      "core::panicking::AssertKind" :=
                                                                  Value.StructTuple
                                                                    "core::panicking::AssertKind::Eq"
                                                                    []
                                                                    []
                                                                    [] in
                                                                M.alloc (|
                                                                  Ty.path "never",
                                                                  M.call_closure (|
                                                                    Ty.path "never",
                                                                    M.get_function (|
                                                                      "core::panicking::assert_failed",
                                                                      [],
                                                                      [
                                                                        Ty.path "usize";
                                                                        Ty.path "usize"
                                                                      ]
                                                                    |),
                                                                    [
                                                                      M.read (| kind |);
                                                                      M.borrow (|
                                                                        Pointer.Kind.Ref,
                                                                        M.deref (|
                                                                          M.borrow (|
                                                                            Pointer.Kind.Ref,
                                                                            M.deref (|
                                                                              M.read (| left_val |)
                                                                            |)
                                                                          |)
                                                                        |)
                                                                      |);
                                                                      M.borrow (|
                                                                        Pointer.Kind.Ref,
                                                                        M.deref (|
                                                                          M.borrow (|
                                                                            Pointer.Kind.Ref,
                                                                            M.deref (|
                                                                              M.read (| right_val |)
                                                                            |)
                                                                          |)
                                                                        |)
                                                                      |);
                                                                      Value.StructTuple
                                                                        "core::option::Option::None"
                                                                        []
                                                                        [
                                                                          Ty.path
                                                                            "core::fmt::Arguments"
                                                                        ]
                                                                        []
                                                                    ]
                                                                  |)
                                                                |)
                                                              |)
                                                            |)));
                                                        fun γ => ltac:(M.monadic (Value.Tuple []))
                                                      ]
                                                    |)))
                                              ]
                                            |) in
                                          M.alloc (| Ty.tuple [], Value.Tuple [] |)
                                        |)));
                                    fun γ => ltac:(M.monadic (Value.Tuple []))
                                  ]
                                |) in
                              M.alloc (|
                                Ty.apply
                                  (Ty.path "&mut")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path
                                        "openvm_circuit::arch::integration_api::ImmInstruction")
                                      []
                                      [ T ]
                                  ],
                                M.borrow (|
                                  Pointer.Kind.MutRef,
                                  M.deref (|
                                    M.borrow (|
                                      Pointer.Kind.MutRef,
                                      M.SubPointer.get_array_field (|
                                        M.deref (| M.read (| shorts |) |),
                                        Value.Integer IntegerKind.Usize 0
                                      |)
                                    |)
                                  |)
                                |)
                              |)
                            |)))
                      ]
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::borrow::BorrowMut"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "openvm_circuit::arch::integration_api::ImmInstruction") [] [ T ] ]
          (Self T)
          (* Instance *) [ ("borrow_mut", InstanceField.Method (borrow_mut T)) ].
    End Impl_core_borrow_BorrowMut_openvm_circuit_arch_integration_api_ImmInstruction_T_for_slice_T.
    
    Module Impl_openvm_circuit_arch_integration_api_ImmInstruction_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "openvm_circuit::arch::integration_api::ImmInstruction") [] [ T ].
      
      (* AlignedBorrow *)
      Definition width (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [] =>
          ltac:(M.monadic
            (M.call_closure (|
              Ty.path "usize",
              M.get_function (|
                "core::mem::size_of",
                [],
                [
                  Ty.apply
                    (Ty.path "openvm_circuit::arch::integration_api::ImmInstruction")
                    []
                    [ Ty.path "u8" ]
                ]
              |),
              []
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_width :
        forall (T : Ty.t),
        M.IsAssociatedFunction.C (Self T) "width" (width T).
      Admitted.
      Global Typeclasses Opaque width.
    End Impl_openvm_circuit_arch_integration_api_ImmInstruction_T.
    
    (* StructRecord
      {
        name := "SignedImmInstruction";
        const_params := [];
        ty_params := [ "T" ];
        fields := [ ("is_valid", T); ("opcode", T); ("immediate", T); ("imm_sign", T) ];
      } *)
    
    Module Impl_core_borrow_Borrow_openvm_circuit_arch_integration_api_SignedImmInstruction_T_for_slice_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "slice") [] [ T ].
      
      (* AlignedBorrow *)
      Definition borrow (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                self
              |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.match_operator (|
                  Ty.tuple [],
                  M.alloc (| Ty.tuple [], Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.use (M.alloc (| Ty.path "bool", Value.Bool true |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.read (|
                          let~ _ : Ty.tuple [] :=
                            M.match_operator (|
                              Ty.tuple [],
                              M.alloc (|
                                Ty.tuple
                                  [
                                    Ty.apply (Ty.path "&") [] [ Ty.path "usize" ];
                                    Ty.apply (Ty.path "&") [] [ Ty.path "usize" ]
                                  ],
                                Value.Tuple
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.alloc (|
                                        Ty.path "usize",
                                        M.call_closure (|
                                          Ty.path "usize",
                                          M.get_associated_function (|
                                            Ty.apply (Ty.path "slice") [] [ T ],
                                            "len",
                                            [],
                                            []
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (| M.read (| self |) |)
                                            |)
                                          ]
                                        |)
                                      |)
                                    |);
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.alloc (|
                                        Ty.path "usize",
                                        M.call_closure (|
                                          Ty.path "usize",
                                          M.get_associated_function (|
                                            Ty.apply
                                              (Ty.path
                                                "openvm_circuit::arch::integration_api::SignedImmInstruction")
                                              []
                                              [ T ],
                                            "width",
                                            [],
                                            []
                                          |),
                                          []
                                        |)
                                      |)
                                    |)
                                  ]
                              |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                    let left_val :=
                                      M.copy (|
                                        Ty.apply (Ty.path "&") [] [ Ty.path "usize" ],
                                        γ0_0
                                      |) in
                                    let right_val :=
                                      M.copy (|
                                        Ty.apply (Ty.path "&") [] [ Ty.path "usize" ],
                                        γ0_1
                                      |) in
                                    M.match_operator (|
                                      Ty.tuple [],
                                      M.alloc (| Ty.tuple [], Value.Tuple [] |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ :=
                                              M.use
                                                (M.alloc (|
                                                  Ty.path "bool",
                                                  UnOp.not (|
                                                    M.call_closure (|
                                                      Ty.path "bool",
                                                      BinOp.eq,
                                                      [
                                                        M.read (|
                                                          M.deref (| M.read (| left_val |) |)
                                                        |);
                                                        M.read (|
                                                          M.deref (| M.read (| right_val |) |)
                                                        |)
                                                      ]
                                                    |)
                                                  |)
                                                |)) in
                                            let _ :=
                                              is_constant_or_break_match (|
                                                M.read (| γ |),
                                                Value.Bool true
                                              |) in
                                            M.never_to_any (|
                                              M.read (|
                                                let~ kind : Ty.path "core::panicking::AssertKind" :=
                                                  Value.StructTuple
                                                    "core::panicking::AssertKind::Eq"
                                                    []
                                                    []
                                                    [] in
                                                M.alloc (|
                                                  Ty.path "never",
                                                  M.call_closure (|
                                                    Ty.path "never",
                                                    M.get_function (|
                                                      "core::panicking::assert_failed",
                                                      [],
                                                      [ Ty.path "usize"; Ty.path "usize" ]
                                                    |),
                                                    [
                                                      M.read (| kind |);
                                                      M.borrow (|
                                                        Pointer.Kind.Ref,
                                                        M.deref (|
                                                          M.borrow (|
                                                            Pointer.Kind.Ref,
                                                            M.deref (| M.read (| left_val |) |)
                                                          |)
                                                        |)
                                                      |);
                                                      M.borrow (|
                                                        Pointer.Kind.Ref,
                                                        M.deref (|
                                                          M.borrow (|
                                                            Pointer.Kind.Ref,
                                                            M.deref (| M.read (| right_val |) |)
                                                          |)
                                                        |)
                                                      |);
                                                      Value.StructTuple
                                                        "core::option::Option::None"
                                                        []
                                                        [ Ty.path "core::fmt::Arguments" ]
                                                        []
                                                    ]
                                                  |)
                                                |)
                                              |)
                                            |)));
                                        fun γ => ltac:(M.monadic (Value.Tuple []))
                                      ]
                                    |)))
                              ]
                            |) in
                          M.alloc (| Ty.tuple [], Value.Tuple [] |)
                        |)));
                    fun γ => ltac:(M.monadic (Value.Tuple []))
                  ]
                |) in
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path "openvm_circuit::arch::integration_api::SignedImmInstruction")
                      []
                      [ T ]
                  ],
                M.match_operator (|
                  Ty.apply
                    (Ty.path "&")
                    []
                    [
                      Ty.apply
                        (Ty.path "openvm_circuit::arch::integration_api::SignedImmInstruction")
                        []
                        [ T ]
                    ],
                  M.alloc (|
                    Ty.tuple
                      [
                        Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ];
                        Ty.apply
                          (Ty.path "&")
                          []
                          [
                            Ty.apply
                              (Ty.path "slice")
                              []
                              [
                                Ty.apply
                                  (Ty.path
                                    "openvm_circuit::arch::integration_api::SignedImmInstruction")
                                  []
                                  [ T ]
                              ]
                          ];
                        Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ]
                      ],
                    M.call_closure (|
                      Ty.tuple
                        [
                          Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ];
                          Ty.apply
                            (Ty.path "&")
                            []
                            [
                              Ty.apply
                                (Ty.path "slice")
                                []
                                [
                                  Ty.apply
                                    (Ty.path
                                      "openvm_circuit::arch::integration_api::SignedImmInstruction")
                                    []
                                    [ T ]
                                ]
                            ];
                          Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ]
                        ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "slice") [] [ T ],
                        "align_to",
                        [],
                        [
                          Ty.apply
                            (Ty.path "openvm_circuit::arch::integration_api::SignedImmInstruction")
                            []
                            [ T ]
                        ]
                      |),
                      [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                        let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                        let γ0_2 := M.SubPointer.get_tuple_field (| γ, 2 |) in
                        let prefix :=
                          M.copy (|
                            Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                            γ0_0
                          |) in
                        let shorts :=
                          M.copy (|
                            Ty.apply
                              (Ty.path "&")
                              []
                              [
                                Ty.apply
                                  (Ty.path "slice")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path
                                        "openvm_circuit::arch::integration_api::SignedImmInstruction")
                                      []
                                      [ T ]
                                  ]
                              ],
                            γ0_1
                          |) in
                        let _suffix :=
                          M.copy (|
                            Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                            γ0_2
                          |) in
                        M.read (|
                          let~ _ : Ty.tuple [] :=
                            M.match_operator (|
                              Ty.tuple [],
                              M.alloc (| Ty.tuple [], Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ :=
                                      M.use (M.alloc (| Ty.path "bool", Value.Bool true |)) in
                                    let _ :=
                                      is_constant_or_break_match (|
                                        M.read (| γ |),
                                        Value.Bool true
                                      |) in
                                    M.read (|
                                      let~ _ : Ty.tuple [] :=
                                        M.match_operator (|
                                          Ty.tuple [],
                                          M.alloc (| Ty.tuple [], Value.Tuple [] |),
                                          [
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let γ :=
                                                  M.use
                                                    (M.alloc (|
                                                      Ty.path "bool",
                                                      UnOp.not (|
                                                        M.call_closure (|
                                                          Ty.path "bool",
                                                          M.get_associated_function (|
                                                            Ty.apply (Ty.path "slice") [] [ T ],
                                                            "is_empty",
                                                            [],
                                                            []
                                                          |),
                                                          [
                                                            M.borrow (|
                                                              Pointer.Kind.Ref,
                                                              M.deref (| M.read (| prefix |) |)
                                                            |)
                                                          ]
                                                        |)
                                                      |)
                                                    |)) in
                                                let _ :=
                                                  is_constant_or_break_match (|
                                                    M.read (| γ |),
                                                    Value.Bool true
                                                  |) in
                                                M.never_to_any (|
                                                  M.call_closure (|
                                                    Ty.path "never",
                                                    M.get_function (|
                                                      "core::panicking::panic_fmt",
                                                      [],
                                                      []
                                                    |),
                                                    [
                                                      M.call_closure (|
                                                        Ty.path "core::fmt::Arguments",
                                                        M.get_associated_function (|
                                                          Ty.path "core::fmt::Arguments",
                                                          "new_const",
                                                          [ Value.Integer IntegerKind.Usize 1 ],
                                                          []
                                                        |),
                                                        [
                                                          M.borrow (|
                                                            Pointer.Kind.Ref,
                                                            M.deref (|
                                                              M.borrow (|
                                                                Pointer.Kind.Ref,
                                                                M.alloc (|
                                                                  Ty.apply
                                                                    (Ty.path "array")
                                                                    [
                                                                      Value.Integer
                                                                        IntegerKind.Usize
                                                                        1
                                                                    ]
                                                                    [
                                                                      Ty.apply
                                                                        (Ty.path "&")
                                                                        []
                                                                        [ Ty.path "str" ]
                                                                    ],
                                                                  Value.Array
                                                                    [
                                                                      mk_str (|
                                                                        "Alignment should match"
                                                                      |)
                                                                    ]
                                                                |)
                                                              |)
                                                            |)
                                                          |)
                                                        ]
                                                      |)
                                                    ]
                                                  |)
                                                |)));
                                            fun γ => ltac:(M.monadic (Value.Tuple []))
                                          ]
                                        |) in
                                      M.alloc (| Ty.tuple [], Value.Tuple [] |)
                                    |)));
                                fun γ => ltac:(M.monadic (Value.Tuple []))
                              ]
                            |) in
                          let~ _ : Ty.tuple [] :=
                            M.match_operator (|
                              Ty.tuple [],
                              M.alloc (| Ty.tuple [], Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ :=
                                      M.use (M.alloc (| Ty.path "bool", Value.Bool true |)) in
                                    let _ :=
                                      is_constant_or_break_match (|
                                        M.read (| γ |),
                                        Value.Bool true
                                      |) in
                                    M.read (|
                                      let~ _ : Ty.tuple [] :=
                                        M.match_operator (|
                                          Ty.tuple [],
                                          M.alloc (|
                                            Ty.tuple
                                              [
                                                Ty.apply (Ty.path "&") [] [ Ty.path "usize" ];
                                                Ty.apply (Ty.path "&") [] [ Ty.path "usize" ]
                                              ],
                                            Value.Tuple
                                              [
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.alloc (|
                                                    Ty.path "usize",
                                                    M.call_closure (|
                                                      Ty.path "usize",
                                                      M.get_associated_function (|
                                                        Ty.apply
                                                          (Ty.path "slice")
                                                          []
                                                          [
                                                            Ty.apply
                                                              (Ty.path
                                                                "openvm_circuit::arch::integration_api::SignedImmInstruction")
                                                              []
                                                              [ T ]
                                                          ],
                                                        "len",
                                                        [],
                                                        []
                                                      |),
                                                      [
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.deref (| M.read (| shorts |) |)
                                                        |)
                                                      ]
                                                    |)
                                                  |)
                                                |);
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.alloc (|
                                                    Ty.path "usize",
                                                    Value.Integer IntegerKind.Usize 1
                                                  |)
                                                |)
                                              ]
                                          |),
                                          [
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let γ0_0 :=
                                                  M.SubPointer.get_tuple_field (| γ, 0 |) in
                                                let γ0_1 :=
                                                  M.SubPointer.get_tuple_field (| γ, 1 |) in
                                                let left_val :=
                                                  M.copy (|
                                                    Ty.apply (Ty.path "&") [] [ Ty.path "usize" ],
                                                    γ0_0
                                                  |) in
                                                let right_val :=
                                                  M.copy (|
                                                    Ty.apply (Ty.path "&") [] [ Ty.path "usize" ],
                                                    γ0_1
                                                  |) in
                                                M.match_operator (|
                                                  Ty.tuple [],
                                                  M.alloc (| Ty.tuple [], Value.Tuple [] |),
                                                  [
                                                    fun γ =>
                                                      ltac:(M.monadic
                                                        (let γ :=
                                                          M.use
                                                            (M.alloc (|
                                                              Ty.path "bool",
                                                              UnOp.not (|
                                                                M.call_closure (|
                                                                  Ty.path "bool",
                                                                  BinOp.eq,
                                                                  [
                                                                    M.read (|
                                                                      M.deref (|
                                                                        M.read (| left_val |)
                                                                      |)
                                                                    |);
                                                                    M.read (|
                                                                      M.deref (|
                                                                        M.read (| right_val |)
                                                                      |)
                                                                    |)
                                                                  ]
                                                                |)
                                                              |)
                                                            |)) in
                                                        let _ :=
                                                          is_constant_or_break_match (|
                                                            M.read (| γ |),
                                                            Value.Bool true
                                                          |) in
                                                        M.never_to_any (|
                                                          M.read (|
                                                            let~ kind :
                                                                Ty.path
                                                                  "core::panicking::AssertKind" :=
                                                              Value.StructTuple
                                                                "core::panicking::AssertKind::Eq"
                                                                []
                                                                []
                                                                [] in
                                                            M.alloc (|
                                                              Ty.path "never",
                                                              M.call_closure (|
                                                                Ty.path "never",
                                                                M.get_function (|
                                                                  "core::panicking::assert_failed",
                                                                  [],
                                                                  [ Ty.path "usize"; Ty.path "usize"
                                                                  ]
                                                                |),
                                                                [
                                                                  M.read (| kind |);
                                                                  M.borrow (|
                                                                    Pointer.Kind.Ref,
                                                                    M.deref (|
                                                                      M.borrow (|
                                                                        Pointer.Kind.Ref,
                                                                        M.deref (|
                                                                          M.read (| left_val |)
                                                                        |)
                                                                      |)
                                                                    |)
                                                                  |);
                                                                  M.borrow (|
                                                                    Pointer.Kind.Ref,
                                                                    M.deref (|
                                                                      M.borrow (|
                                                                        Pointer.Kind.Ref,
                                                                        M.deref (|
                                                                          M.read (| right_val |)
                                                                        |)
                                                                      |)
                                                                    |)
                                                                  |);
                                                                  Value.StructTuple
                                                                    "core::option::Option::None"
                                                                    []
                                                                    [ Ty.path "core::fmt::Arguments"
                                                                    ]
                                                                    []
                                                                ]
                                                              |)
                                                            |)
                                                          |)
                                                        |)));
                                                    fun γ => ltac:(M.monadic (Value.Tuple []))
                                                  ]
                                                |)))
                                          ]
                                        |) in
                                      M.alloc (| Ty.tuple [], Value.Tuple [] |)
                                    |)));
                                fun γ => ltac:(M.monadic (Value.Tuple []))
                              ]
                            |) in
                          M.alloc (|
                            Ty.apply
                              (Ty.path "&")
                              []
                              [
                                Ty.apply
                                  (Ty.path
                                    "openvm_circuit::arch::integration_api::SignedImmInstruction")
                                  []
                                  [ T ]
                              ],
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.SubPointer.get_array_field (|
                                    M.deref (| M.read (| shorts |) |),
                                    Value.Integer IntegerKind.Usize 0
                                  |)
                                |)
                              |)
                            |)
                          |)
                        |)))
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::borrow::Borrow"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "openvm_circuit::arch::integration_api::SignedImmInstruction")
              []
              [ T ]
          ]
          (Self T)
          (* Instance *) [ ("borrow", InstanceField.Method (borrow T)) ].
    End Impl_core_borrow_Borrow_openvm_circuit_arch_integration_api_SignedImmInstruction_T_for_slice_T.
    
    Module Impl_core_borrow_BorrowMut_openvm_circuit_arch_integration_api_SignedImmInstruction_T_for_slice_T.
      Definition Self (T : Ty.t) : Ty.t := Ty.apply (Ty.path "slice") [] [ T ].
      
      (* AlignedBorrow *)
      Definition borrow_mut (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                self
              |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.read (|
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      Ty.tuple [],
                      M.alloc (| Ty.tuple [], Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.use (M.alloc (| Ty.path "bool", Value.Bool true |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.read (|
                              let~ _ : Ty.tuple [] :=
                                M.match_operator (|
                                  Ty.tuple [],
                                  M.alloc (|
                                    Ty.tuple
                                      [
                                        Ty.apply (Ty.path "&") [] [ Ty.path "usize" ];
                                        Ty.apply (Ty.path "&") [] [ Ty.path "usize" ]
                                      ],
                                    Value.Tuple
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.alloc (|
                                            Ty.path "usize",
                                            M.call_closure (|
                                              Ty.path "usize",
                                              M.get_associated_function (|
                                                Ty.apply (Ty.path "slice") [] [ T ],
                                                "len",
                                                [],
                                                []
                                              |),
                                              [
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (| M.read (| self |) |)
                                                |)
                                              ]
                                            |)
                                          |)
                                        |);
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.alloc (|
                                            Ty.path "usize",
                                            M.call_closure (|
                                              Ty.path "usize",
                                              M.get_associated_function (|
                                                Ty.apply
                                                  (Ty.path
                                                    "openvm_circuit::arch::integration_api::SignedImmInstruction")
                                                  []
                                                  [ T ],
                                                "width",
                                                [],
                                                []
                                              |),
                                              []
                                            |)
                                          |)
                                        |)
                                      ]
                                  |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                        let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                        let left_val :=
                                          M.copy (|
                                            Ty.apply (Ty.path "&") [] [ Ty.path "usize" ],
                                            γ0_0
                                          |) in
                                        let right_val :=
                                          M.copy (|
                                            Ty.apply (Ty.path "&") [] [ Ty.path "usize" ],
                                            γ0_1
                                          |) in
                                        M.match_operator (|
                                          Ty.tuple [],
                                          M.alloc (| Ty.tuple [], Value.Tuple [] |),
                                          [
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let γ :=
                                                  M.use
                                                    (M.alloc (|
                                                      Ty.path "bool",
                                                      UnOp.not (|
                                                        M.call_closure (|
                                                          Ty.path "bool",
                                                          BinOp.eq,
                                                          [
                                                            M.read (|
                                                              M.deref (| M.read (| left_val |) |)
                                                            |);
                                                            M.read (|
                                                              M.deref (| M.read (| right_val |) |)
                                                            |)
                                                          ]
                                                        |)
                                                      |)
                                                    |)) in
                                                let _ :=
                                                  is_constant_or_break_match (|
                                                    M.read (| γ |),
                                                    Value.Bool true
                                                  |) in
                                                M.never_to_any (|
                                                  M.read (|
                                                    let~ kind :
                                                        Ty.path "core::panicking::AssertKind" :=
                                                      Value.StructTuple
                                                        "core::panicking::AssertKind::Eq"
                                                        []
                                                        []
                                                        [] in
                                                    M.alloc (|
                                                      Ty.path "never",
                                                      M.call_closure (|
                                                        Ty.path "never",
                                                        M.get_function (|
                                                          "core::panicking::assert_failed",
                                                          [],
                                                          [ Ty.path "usize"; Ty.path "usize" ]
                                                        |),
                                                        [
                                                          M.read (| kind |);
                                                          M.borrow (|
                                                            Pointer.Kind.Ref,
                                                            M.deref (|
                                                              M.borrow (|
                                                                Pointer.Kind.Ref,
                                                                M.deref (| M.read (| left_val |) |)
                                                              |)
                                                            |)
                                                          |);
                                                          M.borrow (|
                                                            Pointer.Kind.Ref,
                                                            M.deref (|
                                                              M.borrow (|
                                                                Pointer.Kind.Ref,
                                                                M.deref (| M.read (| right_val |) |)
                                                              |)
                                                            |)
                                                          |);
                                                          Value.StructTuple
                                                            "core::option::Option::None"
                                                            []
                                                            [ Ty.path "core::fmt::Arguments" ]
                                                            []
                                                        ]
                                                      |)
                                                    |)
                                                  |)
                                                |)));
                                            fun γ => ltac:(M.monadic (Value.Tuple []))
                                          ]
                                        |)))
                                  ]
                                |) in
                              M.alloc (| Ty.tuple [], Value.Tuple [] |)
                            |)));
                        fun γ => ltac:(M.monadic (Value.Tuple []))
                      ]
                    |) in
                  M.alloc (|
                    Ty.apply
                      (Ty.path "&mut")
                      []
                      [
                        Ty.apply
                          (Ty.path "openvm_circuit::arch::integration_api::SignedImmInstruction")
                          []
                          [ T ]
                      ],
                    M.match_operator (|
                      Ty.apply
                        (Ty.path "&mut")
                        []
                        [
                          Ty.apply
                            (Ty.path "openvm_circuit::arch::integration_api::SignedImmInstruction")
                            []
                            [ T ]
                        ],
                      M.alloc (|
                        Ty.tuple
                          [
                            Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ];
                            Ty.apply
                              (Ty.path "&mut")
                              []
                              [
                                Ty.apply
                                  (Ty.path "slice")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path
                                        "openvm_circuit::arch::integration_api::SignedImmInstruction")
                                      []
                                      [ T ]
                                  ]
                              ];
                            Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ]
                          ],
                        M.call_closure (|
                          Ty.tuple
                            [
                              Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ];
                              Ty.apply
                                (Ty.path "&mut")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "slice")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path
                                          "openvm_circuit::arch::integration_api::SignedImmInstruction")
                                        []
                                        [ T ]
                                    ]
                                ];
                              Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ T ] ]
                            ],
                          M.get_associated_function (|
                            Ty.apply (Ty.path "slice") [] [ T ],
                            "align_to_mut",
                            [],
                            [
                              Ty.apply
                                (Ty.path
                                  "openvm_circuit::arch::integration_api::SignedImmInstruction")
                                []
                                [ T ]
                            ]
                          |),
                          [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |) ]
                        |)
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_2 := M.SubPointer.get_tuple_field (| γ, 2 |) in
                            let prefix :=
                              M.copy (|
                                Ty.apply
                                  (Ty.path "&mut")
                                  []
                                  [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                γ0_0
                              |) in
                            let shorts :=
                              M.copy (|
                                Ty.apply
                                  (Ty.path "&mut")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "slice")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path
                                            "openvm_circuit::arch::integration_api::SignedImmInstruction")
                                          []
                                          [ T ]
                                      ]
                                  ],
                                γ0_1
                              |) in
                            let _suffix :=
                              M.copy (|
                                Ty.apply
                                  (Ty.path "&mut")
                                  []
                                  [ Ty.apply (Ty.path "slice") [] [ T ] ],
                                γ0_2
                              |) in
                            M.read (|
                              let~ _ : Ty.tuple [] :=
                                M.match_operator (|
                                  Ty.tuple [],
                                  M.alloc (| Ty.tuple [], Value.Tuple [] |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ :=
                                          M.use (M.alloc (| Ty.path "bool", Value.Bool true |)) in
                                        let _ :=
                                          is_constant_or_break_match (|
                                            M.read (| γ |),
                                            Value.Bool true
                                          |) in
                                        M.read (|
                                          let~ _ : Ty.tuple [] :=
                                            M.match_operator (|
                                              Ty.tuple [],
                                              M.alloc (| Ty.tuple [], Value.Tuple [] |),
                                              [
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (let γ :=
                                                      M.use
                                                        (M.alloc (|
                                                          Ty.path "bool",
                                                          UnOp.not (|
                                                            M.call_closure (|
                                                              Ty.path "bool",
                                                              M.get_associated_function (|
                                                                Ty.apply (Ty.path "slice") [] [ T ],
                                                                "is_empty",
                                                                [],
                                                                []
                                                              |),
                                                              [
                                                                M.borrow (|
                                                                  Pointer.Kind.Ref,
                                                                  M.deref (| M.read (| prefix |) |)
                                                                |)
                                                              ]
                                                            |)
                                                          |)
                                                        |)) in
                                                    let _ :=
                                                      is_constant_or_break_match (|
                                                        M.read (| γ |),
                                                        Value.Bool true
                                                      |) in
                                                    M.never_to_any (|
                                                      M.call_closure (|
                                                        Ty.path "never",
                                                        M.get_function (|
                                                          "core::panicking::panic_fmt",
                                                          [],
                                                          []
                                                        |),
                                                        [
                                                          M.call_closure (|
                                                            Ty.path "core::fmt::Arguments",
                                                            M.get_associated_function (|
                                                              Ty.path "core::fmt::Arguments",
                                                              "new_const",
                                                              [ Value.Integer IntegerKind.Usize 1 ],
                                                              []
                                                            |),
                                                            [
                                                              M.borrow (|
                                                                Pointer.Kind.Ref,
                                                                M.deref (|
                                                                  M.borrow (|
                                                                    Pointer.Kind.Ref,
                                                                    M.alloc (|
                                                                      Ty.apply
                                                                        (Ty.path "array")
                                                                        [
                                                                          Value.Integer
                                                                            IntegerKind.Usize
                                                                            1
                                                                        ]
                                                                        [
                                                                          Ty.apply
                                                                            (Ty.path "&")
                                                                            []
                                                                            [ Ty.path "str" ]
                                                                        ],
                                                                      Value.Array
                                                                        [
                                                                          mk_str (|
                                                                            "Alignment should match"
                                                                          |)
                                                                        ]
                                                                    |)
                                                                  |)
                                                                |)
                                                              |)
                                                            ]
                                                          |)
                                                        ]
                                                      |)
                                                    |)));
                                                fun γ => ltac:(M.monadic (Value.Tuple []))
                                              ]
                                            |) in
                                          M.alloc (| Ty.tuple [], Value.Tuple [] |)
                                        |)));
                                    fun γ => ltac:(M.monadic (Value.Tuple []))
                                  ]
                                |) in
                              let~ _ : Ty.tuple [] :=
                                M.match_operator (|
                                  Ty.tuple [],
                                  M.alloc (| Ty.tuple [], Value.Tuple [] |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ :=
                                          M.use (M.alloc (| Ty.path "bool", Value.Bool true |)) in
                                        let _ :=
                                          is_constant_or_break_match (|
                                            M.read (| γ |),
                                            Value.Bool true
                                          |) in
                                        M.read (|
                                          let~ _ : Ty.tuple [] :=
                                            M.match_operator (|
                                              Ty.tuple [],
                                              M.alloc (|
                                                Ty.tuple
                                                  [
                                                    Ty.apply (Ty.path "&") [] [ Ty.path "usize" ];
                                                    Ty.apply (Ty.path "&") [] [ Ty.path "usize" ]
                                                  ],
                                                Value.Tuple
                                                  [
                                                    M.borrow (|
                                                      Pointer.Kind.Ref,
                                                      M.alloc (|
                                                        Ty.path "usize",
                                                        M.call_closure (|
                                                          Ty.path "usize",
                                                          M.get_associated_function (|
                                                            Ty.apply
                                                              (Ty.path "slice")
                                                              []
                                                              [
                                                                Ty.apply
                                                                  (Ty.path
                                                                    "openvm_circuit::arch::integration_api::SignedImmInstruction")
                                                                  []
                                                                  [ T ]
                                                              ],
                                                            "len",
                                                            [],
                                                            []
                                                          |),
                                                          [
                                                            M.borrow (|
                                                              Pointer.Kind.Ref,
                                                              M.deref (| M.read (| shorts |) |)
                                                            |)
                                                          ]
                                                        |)
                                                      |)
                                                    |);
                                                    M.borrow (|
                                                      Pointer.Kind.Ref,
                                                      M.alloc (|
                                                        Ty.path "usize",
                                                        Value.Integer IntegerKind.Usize 1
                                                      |)
                                                    |)
                                                  ]
                                              |),
                                              [
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (let γ0_0 :=
                                                      M.SubPointer.get_tuple_field (| γ, 0 |) in
                                                    let γ0_1 :=
                                                      M.SubPointer.get_tuple_field (| γ, 1 |) in
                                                    let left_val :=
                                                      M.copy (|
                                                        Ty.apply
                                                          (Ty.path "&")
                                                          []
                                                          [ Ty.path "usize" ],
                                                        γ0_0
                                                      |) in
                                                    let right_val :=
                                                      M.copy (|
                                                        Ty.apply
                                                          (Ty.path "&")
                                                          []
                                                          [ Ty.path "usize" ],
                                                        γ0_1
                                                      |) in
                                                    M.match_operator (|
                                                      Ty.tuple [],
                                                      M.alloc (| Ty.tuple [], Value.Tuple [] |),
                                                      [
                                                        fun γ =>
                                                          ltac:(M.monadic
                                                            (let γ :=
                                                              M.use
                                                                (M.alloc (|
                                                                  Ty.path "bool",
                                                                  UnOp.not (|
                                                                    M.call_closure (|
                                                                      Ty.path "bool",
                                                                      BinOp.eq,
                                                                      [
                                                                        M.read (|
                                                                          M.deref (|
                                                                            M.read (| left_val |)
                                                                          |)
                                                                        |);
                                                                        M.read (|
                                                                          M.deref (|
                                                                            M.read (| right_val |)
                                                                          |)
                                                                        |)
                                                                      ]
                                                                    |)
                                                                  |)
                                                                |)) in
                                                            let _ :=
                                                              is_constant_or_break_match (|
                                                                M.read (| γ |),
                                                                Value.Bool true
                                                              |) in
                                                            M.never_to_any (|
                                                              M.read (|
                                                                let~ kind :
                                                                    Ty.path
                                                                      "core::panicking::AssertKind" :=
                                                                  Value.StructTuple
                                                                    "core::panicking::AssertKind::Eq"
                                                                    []
                                                                    []
                                                                    [] in
                                                                M.alloc (|
                                                                  Ty.path "never",
                                                                  M.call_closure (|
                                                                    Ty.path "never",
                                                                    M.get_function (|
                                                                      "core::panicking::assert_failed",
                                                                      [],
                                                                      [
                                                                        Ty.path "usize";
                                                                        Ty.path "usize"
                                                                      ]
                                                                    |),
                                                                    [
                                                                      M.read (| kind |);
                                                                      M.borrow (|
                                                                        Pointer.Kind.Ref,
                                                                        M.deref (|
                                                                          M.borrow (|
                                                                            Pointer.Kind.Ref,
                                                                            M.deref (|
                                                                              M.read (| left_val |)
                                                                            |)
                                                                          |)
                                                                        |)
                                                                      |);
                                                                      M.borrow (|
                                                                        Pointer.Kind.Ref,
                                                                        M.deref (|
                                                                          M.borrow (|
                                                                            Pointer.Kind.Ref,
                                                                            M.deref (|
                                                                              M.read (| right_val |)
                                                                            |)
                                                                          |)
                                                                        |)
                                                                      |);
                                                                      Value.StructTuple
                                                                        "core::option::Option::None"
                                                                        []
                                                                        [
                                                                          Ty.path
                                                                            "core::fmt::Arguments"
                                                                        ]
                                                                        []
                                                                    ]
                                                                  |)
                                                                |)
                                                              |)
                                                            |)));
                                                        fun γ => ltac:(M.monadic (Value.Tuple []))
                                                      ]
                                                    |)))
                                              ]
                                            |) in
                                          M.alloc (| Ty.tuple [], Value.Tuple [] |)
                                        |)));
                                    fun γ => ltac:(M.monadic (Value.Tuple []))
                                  ]
                                |) in
                              M.alloc (|
                                Ty.apply
                                  (Ty.path "&mut")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path
                                        "openvm_circuit::arch::integration_api::SignedImmInstruction")
                                      []
                                      [ T ]
                                  ],
                                M.borrow (|
                                  Pointer.Kind.MutRef,
                                  M.deref (|
                                    M.borrow (|
                                      Pointer.Kind.MutRef,
                                      M.SubPointer.get_array_field (|
                                        M.deref (| M.read (| shorts |) |),
                                        Value.Integer IntegerKind.Usize 0
                                      |)
                                    |)
                                  |)
                                |)
                              |)
                            |)))
                      ]
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T : Ty.t),
        M.IsTraitInstance
          "core::borrow::BorrowMut"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [
            Ty.apply
              (Ty.path "openvm_circuit::arch::integration_api::SignedImmInstruction")
              []
              [ T ]
          ]
          (Self T)
          (* Instance *) [ ("borrow_mut", InstanceField.Method (borrow_mut T)) ].
    End Impl_core_borrow_BorrowMut_openvm_circuit_arch_integration_api_SignedImmInstruction_T_for_slice_T.
    
    Module Impl_openvm_circuit_arch_integration_api_SignedImmInstruction_T.
      Definition Self (T : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "openvm_circuit::arch::integration_api::SignedImmInstruction") [] [ T ].
      
      (* AlignedBorrow *)
      Definition width (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self T in
        match ε, τ, α with
        | [], [], [] =>
          ltac:(M.monadic
            (M.call_closure (|
              Ty.path "usize",
              M.get_function (|
                "core::mem::size_of",
                [],
                [
                  Ty.apply
                    (Ty.path "openvm_circuit::arch::integration_api::SignedImmInstruction")
                    []
                    [ Ty.path "u8" ]
                ]
              |),
              []
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_width :
        forall (T : Ty.t),
        M.IsAssociatedFunction.C (Self T) "width" (width T).
      Admitted.
      Global Typeclasses Opaque width.
    End Impl_openvm_circuit_arch_integration_api_SignedImmInstruction_T.
    
    Module conversions.
      Module Impl_core_convert_From_openvm_circuit_arch_integration_api_AdapterAirContext_T_openvm_circuit_arch_integration_api_VecHeapAdapterInterface_NUM_READS_BLOCKS_PER_READ_BLOCKS_PER_WRITE_READ_SIZE_WRITE_SIZE_T_for_openvm_circuit_arch_integration_api_AdapterAirContext_T_openvm_circuit_arch_integration_api_DynAdapterInterface_T.
        Definition Self
            (NUM_READS BLOCKS_PER_READ BLOCKS_PER_WRITE READ_SIZE WRITE_SIZE : Value.t)
            (T : Ty.t)
            : Ty.t :=
          Ty.apply
            (Ty.path "openvm_circuit::arch::integration_api::AdapterAirContext")
            []
            [
              T;
              Ty.apply
                (Ty.path "openvm_circuit::arch::integration_api::DynAdapterInterface")
                []
                [ T ]
            ].
        
        (*
                fn from(
                    ctx: AdapterAirContext<
                        T,
                        VecHeapAdapterInterface<
                            T,
                            NUM_READS,
                            BLOCKS_PER_READ,
                            BLOCKS_PER_WRITE,
                            READ_SIZE,
                            WRITE_SIZE,
                        >,
                    >,
                ) -> Self {
                    AdapterAirContext {
                        to_pc: ctx.to_pc,
                        reads: ctx.reads.into(),
                        writes: ctx.writes.into(),
                        instruction: ctx.instruction.into(),
                    }
                }
        *)
        Definition from
            (NUM_READS BLOCKS_PER_READ BLOCKS_PER_WRITE READ_SIZE WRITE_SIZE : Value.t)
            (T : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t :=
            Self NUM_READS BLOCKS_PER_READ BLOCKS_PER_WRITE READ_SIZE WRITE_SIZE T in
          match ε, τ, α with
          | [], [], [ ctx ] =>
            ltac:(M.monadic
              (let ctx :=
                M.alloc (|
                  Ty.apply
                    (Ty.path "openvm_circuit::arch::integration_api::AdapterAirContext")
                    []
                    [
                      T;
                      Ty.apply
                        (Ty.path "openvm_circuit::arch::integration_api::VecHeapAdapterInterface")
                        [ NUM_READS; BLOCKS_PER_READ; BLOCKS_PER_WRITE; READ_SIZE; WRITE_SIZE ]
                        [ T ]
                    ],
                  ctx
                |) in
              Value.mkStructRecord
                "openvm_circuit::arch::integration_api::AdapterAirContext"
                []
                [
                  T;
                  Ty.apply
                    (Ty.path "openvm_circuit::arch::integration_api::DynAdapterInterface")
                    []
                    [ T ]
                ]
                [
                  ("to_pc",
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        ctx,
                        "openvm_circuit::arch::integration_api::AdapterAirContext",
                        "to_pc"
                      |)
                    |));
                  ("reads",
                    M.call_closure (|
                      Ty.apply (Ty.path "openvm_circuit::arch::integration_api::DynArray") [] [ T ],
                      M.get_trait_method (|
                        "core::convert::Into",
                        Ty.apply
                          (Ty.path "array")
                          [ NUM_READS ]
                          [
                            Ty.apply
                              (Ty.path "array")
                              [ BLOCKS_PER_READ ]
                              [ Ty.apply (Ty.path "array") [ READ_SIZE ] [ T ] ]
                          ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "openvm_circuit::arch::integration_api::DynArray")
                            []
                            [ T ]
                        ],
                        "into",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            ctx,
                            "openvm_circuit::arch::integration_api::AdapterAirContext",
                            "reads"
                          |)
                        |)
                      ]
                    |));
                  ("writes",
                    M.call_closure (|
                      Ty.apply (Ty.path "openvm_circuit::arch::integration_api::DynArray") [] [ T ],
                      M.get_trait_method (|
                        "core::convert::Into",
                        Ty.apply
                          (Ty.path "array")
                          [ BLOCKS_PER_WRITE ]
                          [ Ty.apply (Ty.path "array") [ WRITE_SIZE ] [ T ] ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "openvm_circuit::arch::integration_api::DynArray")
                            []
                            [ T ]
                        ],
                        "into",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            ctx,
                            "openvm_circuit::arch::integration_api::AdapterAirContext",
                            "writes"
                          |)
                        |)
                      ]
                    |));
                  ("instruction",
                    M.call_closure (|
                      Ty.apply (Ty.path "openvm_circuit::arch::integration_api::DynArray") [] [ T ],
                      M.get_trait_method (|
                        "core::convert::Into",
                        Ty.apply
                          (Ty.path "openvm_circuit::arch::integration_api::MinimalInstruction")
                          []
                          [ T ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "openvm_circuit::arch::integration_api::DynArray")
                            []
                            [ T ]
                        ],
                        "into",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            ctx,
                            "openvm_circuit::arch::integration_api::AdapterAirContext",
                            "instruction"
                          |)
                        |)
                      ]
                    |))
                ]))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          forall
            (NUM_READS BLOCKS_PER_READ BLOCKS_PER_WRITE READ_SIZE WRITE_SIZE : Value.t)
            (T : Ty.t),
          M.IsTraitInstance
            "core::convert::From"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *)
            [
              Ty.apply
                (Ty.path "openvm_circuit::arch::integration_api::AdapterAirContext")
                []
                [
                  T;
                  Ty.apply
                    (Ty.path "openvm_circuit::arch::integration_api::VecHeapAdapterInterface")
                    [ NUM_READS; BLOCKS_PER_READ; BLOCKS_PER_WRITE; READ_SIZE; WRITE_SIZE ]
                    [ T ]
                ]
            ]
            (Self NUM_READS BLOCKS_PER_READ BLOCKS_PER_WRITE READ_SIZE WRITE_SIZE T)
            (* Instance *)
            [
              ("from",
                InstanceField.Method
                  (from NUM_READS BLOCKS_PER_READ BLOCKS_PER_WRITE READ_SIZE WRITE_SIZE T))
            ].
      End Impl_core_convert_From_openvm_circuit_arch_integration_api_AdapterAirContext_T_openvm_circuit_arch_integration_api_VecHeapAdapterInterface_NUM_READS_BLOCKS_PER_READ_BLOCKS_PER_WRITE_READ_SIZE_WRITE_SIZE_T_for_openvm_circuit_arch_integration_api_AdapterAirContext_T_openvm_circuit_arch_integration_api_DynAdapterInterface_T.
      
      Module Impl_core_convert_From_openvm_circuit_arch_integration_api_AdapterRuntimeContext_T_openvm_circuit_arch_integration_api_VecHeapAdapterInterface_NUM_READS_BLOCKS_PER_READ_BLOCKS_PER_WRITE_READ_SIZE_WRITE_SIZE_T_for_openvm_circuit_arch_integration_api_AdapterRuntimeContext_T_openvm_circuit_arch_integration_api_DynAdapterInterface_T.
        Definition Self
            (NUM_READS BLOCKS_PER_READ BLOCKS_PER_WRITE READ_SIZE WRITE_SIZE : Value.t)
            (T : Ty.t)
            : Ty.t :=
          Ty.apply
            (Ty.path "openvm_circuit::arch::integration_api::AdapterRuntimeContext")
            []
            [
              T;
              Ty.apply
                (Ty.path "openvm_circuit::arch::integration_api::DynAdapterInterface")
                []
                [ T ]
            ].
        
        (*
                fn from(
                    ctx: AdapterRuntimeContext<
                        T,
                        VecHeapAdapterInterface<
                            T,
                            NUM_READS,
                            BLOCKS_PER_READ,
                            BLOCKS_PER_WRITE,
                            READ_SIZE,
                            WRITE_SIZE,
                        >,
                    >,
                ) -> Self {
                    AdapterRuntimeContext {
                        to_pc: ctx.to_pc,
                        writes: ctx.writes.into(),
                    }
                }
        *)
        Definition from
            (NUM_READS BLOCKS_PER_READ BLOCKS_PER_WRITE READ_SIZE WRITE_SIZE : Value.t)
            (T : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t :=
            Self NUM_READS BLOCKS_PER_READ BLOCKS_PER_WRITE READ_SIZE WRITE_SIZE T in
          match ε, τ, α with
          | [], [], [ ctx ] =>
            ltac:(M.monadic
              (let ctx :=
                M.alloc (|
                  Ty.apply
                    (Ty.path "openvm_circuit::arch::integration_api::AdapterRuntimeContext")
                    []
                    [
                      T;
                      Ty.apply
                        (Ty.path "openvm_circuit::arch::integration_api::VecHeapAdapterInterface")
                        [ NUM_READS; BLOCKS_PER_READ; BLOCKS_PER_WRITE; READ_SIZE; WRITE_SIZE ]
                        [ T ]
                    ],
                  ctx
                |) in
              Value.mkStructRecord
                "openvm_circuit::arch::integration_api::AdapterRuntimeContext"
                []
                [
                  T;
                  Ty.apply
                    (Ty.path "openvm_circuit::arch::integration_api::DynAdapterInterface")
                    []
                    [ T ]
                ]
                [
                  ("to_pc",
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        ctx,
                        "openvm_circuit::arch::integration_api::AdapterRuntimeContext",
                        "to_pc"
                      |)
                    |));
                  ("writes",
                    M.call_closure (|
                      Ty.apply (Ty.path "openvm_circuit::arch::integration_api::DynArray") [] [ T ],
                      M.get_trait_method (|
                        "core::convert::Into",
                        Ty.apply
                          (Ty.path "array")
                          [ BLOCKS_PER_WRITE ]
                          [ Ty.apply (Ty.path "array") [ WRITE_SIZE ] [ T ] ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "openvm_circuit::arch::integration_api::DynArray")
                            []
                            [ T ]
                        ],
                        "into",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            ctx,
                            "openvm_circuit::arch::integration_api::AdapterRuntimeContext",
                            "writes"
                          |)
                        |)
                      ]
                    |))
                ]))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          forall
            (NUM_READS BLOCKS_PER_READ BLOCKS_PER_WRITE READ_SIZE WRITE_SIZE : Value.t)
            (T : Ty.t),
          M.IsTraitInstance
            "core::convert::From"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *)
            [
              Ty.apply
                (Ty.path "openvm_circuit::arch::integration_api::AdapterRuntimeContext")
                []
                [
                  T;
                  Ty.apply
                    (Ty.path "openvm_circuit::arch::integration_api::VecHeapAdapterInterface")
                    [ NUM_READS; BLOCKS_PER_READ; BLOCKS_PER_WRITE; READ_SIZE; WRITE_SIZE ]
                    [ T ]
                ]
            ]
            (Self NUM_READS BLOCKS_PER_READ BLOCKS_PER_WRITE READ_SIZE WRITE_SIZE T)
            (* Instance *)
            [
              ("from",
                InstanceField.Method
                  (from NUM_READS BLOCKS_PER_READ BLOCKS_PER_WRITE READ_SIZE WRITE_SIZE T))
            ].
      End Impl_core_convert_From_openvm_circuit_arch_integration_api_AdapterRuntimeContext_T_openvm_circuit_arch_integration_api_VecHeapAdapterInterface_NUM_READS_BLOCKS_PER_READ_BLOCKS_PER_WRITE_READ_SIZE_WRITE_SIZE_T_for_openvm_circuit_arch_integration_api_AdapterRuntimeContext_T_openvm_circuit_arch_integration_api_DynAdapterInterface_T.
      
      Module Impl_core_convert_From_openvm_circuit_arch_integration_api_AdapterAirContext_T_openvm_circuit_arch_integration_api_DynAdapterInterface_T_for_openvm_circuit_arch_integration_api_AdapterAirContext_T_openvm_circuit_arch_integration_api_VecHeapAdapterInterface_NUM_READS_BLOCKS_PER_READ_BLOCKS_PER_WRITE_READ_SIZE_WRITE_SIZE_T.
        Definition Self
            (NUM_READS BLOCKS_PER_READ BLOCKS_PER_WRITE READ_SIZE WRITE_SIZE : Value.t)
            (T : Ty.t)
            : Ty.t :=
          Ty.apply
            (Ty.path "openvm_circuit::arch::integration_api::AdapterAirContext")
            []
            [
              T;
              Ty.apply
                (Ty.path "openvm_circuit::arch::integration_api::VecHeapAdapterInterface")
                [ NUM_READS; BLOCKS_PER_READ; BLOCKS_PER_WRITE; READ_SIZE; WRITE_SIZE ]
                [ T ]
            ].
        
        (*
                fn from(ctx: AdapterAirContext<T, DynAdapterInterface<T>>) -> Self {
                    AdapterAirContext {
                        to_pc: ctx.to_pc,
                        reads: ctx.reads.into(),
                        writes: ctx.writes.into(),
                        instruction: ctx.instruction.into(),
                    }
                }
        *)
        Definition from
            (NUM_READS BLOCKS_PER_READ BLOCKS_PER_WRITE READ_SIZE WRITE_SIZE : Value.t)
            (T : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t :=
            Self NUM_READS BLOCKS_PER_READ BLOCKS_PER_WRITE READ_SIZE WRITE_SIZE T in
          match ε, τ, α with
          | [], [], [ ctx ] =>
            ltac:(M.monadic
              (let ctx :=
                M.alloc (|
                  Ty.apply
                    (Ty.path "openvm_circuit::arch::integration_api::AdapterAirContext")
                    []
                    [
                      T;
                      Ty.apply
                        (Ty.path "openvm_circuit::arch::integration_api::DynAdapterInterface")
                        []
                        [ T ]
                    ],
                  ctx
                |) in
              Value.mkStructRecord
                "openvm_circuit::arch::integration_api::AdapterAirContext"
                []
                [
                  T;
                  Ty.apply
                    (Ty.path "openvm_circuit::arch::integration_api::VecHeapAdapterInterface")
                    [ NUM_READS; BLOCKS_PER_READ; BLOCKS_PER_WRITE; READ_SIZE; WRITE_SIZE ]
                    [ T ]
                ]
                [
                  ("to_pc",
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        ctx,
                        "openvm_circuit::arch::integration_api::AdapterAirContext",
                        "to_pc"
                      |)
                    |));
                  ("reads",
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "array")
                        [ NUM_READS ]
                        [
                          Ty.apply
                            (Ty.path "array")
                            [ BLOCKS_PER_READ ]
                            [ Ty.apply (Ty.path "array") [ READ_SIZE ] [ T ] ]
                        ],
                      M.get_trait_method (|
                        "core::convert::Into",
                        Ty.apply
                          (Ty.path "openvm_circuit::arch::integration_api::DynArray")
                          []
                          [ T ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "array")
                            [ NUM_READS ]
                            [
                              Ty.apply
                                (Ty.path "array")
                                [ BLOCKS_PER_READ ]
                                [ Ty.apply (Ty.path "array") [ READ_SIZE ] [ T ] ]
                            ]
                        ],
                        "into",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            ctx,
                            "openvm_circuit::arch::integration_api::AdapterAirContext",
                            "reads"
                          |)
                        |)
                      ]
                    |));
                  ("writes",
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "array")
                        [ BLOCKS_PER_WRITE ]
                        [ Ty.apply (Ty.path "array") [ WRITE_SIZE ] [ T ] ],
                      M.get_trait_method (|
                        "core::convert::Into",
                        Ty.apply
                          (Ty.path "openvm_circuit::arch::integration_api::DynArray")
                          []
                          [ T ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "array")
                            [ BLOCKS_PER_WRITE ]
                            [ Ty.apply (Ty.path "array") [ WRITE_SIZE ] [ T ] ]
                        ],
                        "into",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            ctx,
                            "openvm_circuit::arch::integration_api::AdapterAirContext",
                            "writes"
                          |)
                        |)
                      ]
                    |));
                  ("instruction",
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "openvm_circuit::arch::integration_api::MinimalInstruction")
                        []
                        [ T ],
                      M.get_trait_method (|
                        "core::convert::Into",
                        Ty.apply
                          (Ty.path "openvm_circuit::arch::integration_api::DynArray")
                          []
                          [ T ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "openvm_circuit::arch::integration_api::MinimalInstruction")
                            []
                            [ T ]
                        ],
                        "into",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            ctx,
                            "openvm_circuit::arch::integration_api::AdapterAirContext",
                            "instruction"
                          |)
                        |)
                      ]
                    |))
                ]))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          forall
            (NUM_READS BLOCKS_PER_READ BLOCKS_PER_WRITE READ_SIZE WRITE_SIZE : Value.t)
            (T : Ty.t),
          M.IsTraitInstance
            "core::convert::From"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *)
            [
              Ty.apply
                (Ty.path "openvm_circuit::arch::integration_api::AdapterAirContext")
                []
                [
                  T;
                  Ty.apply
                    (Ty.path "openvm_circuit::arch::integration_api::DynAdapterInterface")
                    []
                    [ T ]
                ]
            ]
            (Self NUM_READS BLOCKS_PER_READ BLOCKS_PER_WRITE READ_SIZE WRITE_SIZE T)
            (* Instance *)
            [
              ("from",
                InstanceField.Method
                  (from NUM_READS BLOCKS_PER_READ BLOCKS_PER_WRITE READ_SIZE WRITE_SIZE T))
            ].
      End Impl_core_convert_From_openvm_circuit_arch_integration_api_AdapterAirContext_T_openvm_circuit_arch_integration_api_DynAdapterInterface_T_for_openvm_circuit_arch_integration_api_AdapterAirContext_T_openvm_circuit_arch_integration_api_VecHeapAdapterInterface_NUM_READS_BLOCKS_PER_READ_BLOCKS_PER_WRITE_READ_SIZE_WRITE_SIZE_T.
      
      Module Impl_core_convert_From_openvm_circuit_arch_integration_api_AdapterRuntimeContext_T_openvm_circuit_arch_integration_api_DynAdapterInterface_T_for_openvm_circuit_arch_integration_api_AdapterRuntimeContext_T_openvm_circuit_arch_integration_api_VecHeapAdapterInterface_NUM_READS_BLOCKS_PER_READ_BLOCKS_PER_WRITE_READ_SIZE_WRITE_SIZE_T.
        Definition Self
            (NUM_READS BLOCKS_PER_READ BLOCKS_PER_WRITE READ_SIZE WRITE_SIZE : Value.t)
            (T : Ty.t)
            : Ty.t :=
          Ty.apply
            (Ty.path "openvm_circuit::arch::integration_api::AdapterRuntimeContext")
            []
            [
              T;
              Ty.apply
                (Ty.path "openvm_circuit::arch::integration_api::VecHeapAdapterInterface")
                [ NUM_READS; BLOCKS_PER_READ; BLOCKS_PER_WRITE; READ_SIZE; WRITE_SIZE ]
                [ T ]
            ].
        
        (*
                fn from(ctx: AdapterRuntimeContext<T, DynAdapterInterface<T>>) -> Self {
                    AdapterRuntimeContext {
                        to_pc: ctx.to_pc,
                        writes: ctx.writes.into(),
                    }
                }
        *)
        Definition from
            (NUM_READS BLOCKS_PER_READ BLOCKS_PER_WRITE READ_SIZE WRITE_SIZE : Value.t)
            (T : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t :=
            Self NUM_READS BLOCKS_PER_READ BLOCKS_PER_WRITE READ_SIZE WRITE_SIZE T in
          match ε, τ, α with
          | [], [], [ ctx ] =>
            ltac:(M.monadic
              (let ctx :=
                M.alloc (|
                  Ty.apply
                    (Ty.path "openvm_circuit::arch::integration_api::AdapterRuntimeContext")
                    []
                    [
                      T;
                      Ty.apply
                        (Ty.path "openvm_circuit::arch::integration_api::DynAdapterInterface")
                        []
                        [ T ]
                    ],
                  ctx
                |) in
              Value.mkStructRecord
                "openvm_circuit::arch::integration_api::AdapterRuntimeContext"
                []
                [
                  T;
                  Ty.apply
                    (Ty.path "openvm_circuit::arch::integration_api::VecHeapAdapterInterface")
                    [ NUM_READS; BLOCKS_PER_READ; BLOCKS_PER_WRITE; READ_SIZE; WRITE_SIZE ]
                    [ T ]
                ]
                [
                  ("to_pc",
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        ctx,
                        "openvm_circuit::arch::integration_api::AdapterRuntimeContext",
                        "to_pc"
                      |)
                    |));
                  ("writes",
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "array")
                        [ BLOCKS_PER_WRITE ]
                        [ Ty.apply (Ty.path "array") [ WRITE_SIZE ] [ T ] ],
                      M.get_trait_method (|
                        "core::convert::Into",
                        Ty.apply
                          (Ty.path "openvm_circuit::arch::integration_api::DynArray")
                          []
                          [ T ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "array")
                            [ BLOCKS_PER_WRITE ]
                            [ Ty.apply (Ty.path "array") [ WRITE_SIZE ] [ T ] ]
                        ],
                        "into",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            ctx,
                            "openvm_circuit::arch::integration_api::AdapterRuntimeContext",
                            "writes"
                          |)
                        |)
                      ]
                    |))
                ]))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          forall
            (NUM_READS BLOCKS_PER_READ BLOCKS_PER_WRITE READ_SIZE WRITE_SIZE : Value.t)
            (T : Ty.t),
          M.IsTraitInstance
            "core::convert::From"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *)
            [
              Ty.apply
                (Ty.path "openvm_circuit::arch::integration_api::AdapterRuntimeContext")
                []
                [
                  T;
                  Ty.apply
                    (Ty.path "openvm_circuit::arch::integration_api::DynAdapterInterface")
                    []
                    [ T ]
                ]
            ]
            (Self NUM_READS BLOCKS_PER_READ BLOCKS_PER_WRITE READ_SIZE WRITE_SIZE T)
            (* Instance *)
            [
              ("from",
                InstanceField.Method
                  (from NUM_READS BLOCKS_PER_READ BLOCKS_PER_WRITE READ_SIZE WRITE_SIZE T))
            ].
      End Impl_core_convert_From_openvm_circuit_arch_integration_api_AdapterRuntimeContext_T_openvm_circuit_arch_integration_api_DynAdapterInterface_T_for_openvm_circuit_arch_integration_api_AdapterRuntimeContext_T_openvm_circuit_arch_integration_api_VecHeapAdapterInterface_NUM_READS_BLOCKS_PER_READ_BLOCKS_PER_WRITE_READ_SIZE_WRITE_SIZE_T.
      
      Module Impl_core_convert_From_where_core_clone_Clone_T_openvm_circuit_arch_integration_api_AdapterAirContext_T_openvm_circuit_arch_integration_api_DynAdapterInterface_T_for_openvm_circuit_arch_integration_api_AdapterAirContext_T_openvm_circuit_arch_integration_api_VecHeapTwoReadsAdapterInterface_BLOCKS_PER_READ1_BLOCKS_PER_READ2_BLOCKS_PER_WRITE_READ_SIZE_WRITE_SIZE_T.
        Definition Self
            (BLOCKS_PER_READ1 BLOCKS_PER_READ2 BLOCKS_PER_WRITE READ_SIZE WRITE_SIZE : Value.t)
            (T : Ty.t)
            : Ty.t :=
          Ty.apply
            (Ty.path "openvm_circuit::arch::integration_api::AdapterAirContext")
            []
            [
              T;
              Ty.apply
                (Ty.path "openvm_circuit::arch::integration_api::VecHeapTwoReadsAdapterInterface")
                [ BLOCKS_PER_READ1; BLOCKS_PER_READ2; BLOCKS_PER_WRITE; READ_SIZE; WRITE_SIZE ]
                [ T ]
            ].
        
        (*
                fn from(ctx: AdapterAirContext<T, DynAdapterInterface<T>>) -> Self {
                    AdapterAirContext {
                        to_pc: ctx.to_pc,
                        reads: ctx.reads.into(),
                        writes: ctx.writes.into(),
                        instruction: ctx.instruction.into(),
                    }
                }
        *)
        Definition from
            (BLOCKS_PER_READ1 BLOCKS_PER_READ2 BLOCKS_PER_WRITE READ_SIZE WRITE_SIZE : Value.t)
            (T : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t :=
            Self BLOCKS_PER_READ1 BLOCKS_PER_READ2 BLOCKS_PER_WRITE READ_SIZE WRITE_SIZE T in
          match ε, τ, α with
          | [], [], [ ctx ] =>
            ltac:(M.monadic
              (let ctx :=
                M.alloc (|
                  Ty.apply
                    (Ty.path "openvm_circuit::arch::integration_api::AdapterAirContext")
                    []
                    [
                      T;
                      Ty.apply
                        (Ty.path "openvm_circuit::arch::integration_api::DynAdapterInterface")
                        []
                        [ T ]
                    ],
                  ctx
                |) in
              Value.mkStructRecord
                "openvm_circuit::arch::integration_api::AdapterAirContext"
                []
                [
                  T;
                  Ty.apply
                    (Ty.path
                      "openvm_circuit::arch::integration_api::VecHeapTwoReadsAdapterInterface")
                    [ BLOCKS_PER_READ1; BLOCKS_PER_READ2; BLOCKS_PER_WRITE; READ_SIZE; WRITE_SIZE ]
                    [ T ]
                ]
                [
                  ("to_pc",
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        ctx,
                        "openvm_circuit::arch::integration_api::AdapterAirContext",
                        "to_pc"
                      |)
                    |));
                  ("reads",
                    M.call_closure (|
                      Ty.tuple
                        [
                          Ty.apply
                            (Ty.path "array")
                            [ BLOCKS_PER_READ1 ]
                            [ Ty.apply (Ty.path "array") [ READ_SIZE ] [ T ] ];
                          Ty.apply
                            (Ty.path "array")
                            [ BLOCKS_PER_READ2 ]
                            [ Ty.apply (Ty.path "array") [ READ_SIZE ] [ T ] ]
                        ],
                      M.get_trait_method (|
                        "core::convert::Into",
                        Ty.apply
                          (Ty.path "openvm_circuit::arch::integration_api::DynArray")
                          []
                          [ T ],
                        [],
                        [
                          Ty.tuple
                            [
                              Ty.apply
                                (Ty.path "array")
                                [ BLOCKS_PER_READ1 ]
                                [ Ty.apply (Ty.path "array") [ READ_SIZE ] [ T ] ];
                              Ty.apply
                                (Ty.path "array")
                                [ BLOCKS_PER_READ2 ]
                                [ Ty.apply (Ty.path "array") [ READ_SIZE ] [ T ] ]
                            ]
                        ],
                        "into",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            ctx,
                            "openvm_circuit::arch::integration_api::AdapterAirContext",
                            "reads"
                          |)
                        |)
                      ]
                    |));
                  ("writes",
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "array")
                        [ BLOCKS_PER_WRITE ]
                        [ Ty.apply (Ty.path "array") [ WRITE_SIZE ] [ T ] ],
                      M.get_trait_method (|
                        "core::convert::Into",
                        Ty.apply
                          (Ty.path "openvm_circuit::arch::integration_api::DynArray")
                          []
                          [ T ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "array")
                            [ BLOCKS_PER_WRITE ]
                            [ Ty.apply (Ty.path "array") [ WRITE_SIZE ] [ T ] ]
                        ],
                        "into",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            ctx,
                            "openvm_circuit::arch::integration_api::AdapterAirContext",
                            "writes"
                          |)
                        |)
                      ]
                    |));
                  ("instruction",
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "openvm_circuit::arch::integration_api::MinimalInstruction")
                        []
                        [ T ],
                      M.get_trait_method (|
                        "core::convert::Into",
                        Ty.apply
                          (Ty.path "openvm_circuit::arch::integration_api::DynArray")
                          []
                          [ T ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "openvm_circuit::arch::integration_api::MinimalInstruction")
                            []
                            [ T ]
                        ],
                        "into",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            ctx,
                            "openvm_circuit::arch::integration_api::AdapterAirContext",
                            "instruction"
                          |)
                        |)
                      ]
                    |))
                ]))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          forall
            (BLOCKS_PER_READ1 BLOCKS_PER_READ2 BLOCKS_PER_WRITE READ_SIZE WRITE_SIZE : Value.t)
            (T : Ty.t),
          M.IsTraitInstance
            "core::convert::From"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *)
            [
              Ty.apply
                (Ty.path "openvm_circuit::arch::integration_api::AdapterAirContext")
                []
                [
                  T;
                  Ty.apply
                    (Ty.path "openvm_circuit::arch::integration_api::DynAdapterInterface")
                    []
                    [ T ]
                ]
            ]
            (Self BLOCKS_PER_READ1 BLOCKS_PER_READ2 BLOCKS_PER_WRITE READ_SIZE WRITE_SIZE T)
            (* Instance *)
            [
              ("from",
                InstanceField.Method
                  (from BLOCKS_PER_READ1 BLOCKS_PER_READ2 BLOCKS_PER_WRITE READ_SIZE WRITE_SIZE T))
            ].
      End Impl_core_convert_From_where_core_clone_Clone_T_openvm_circuit_arch_integration_api_AdapterAirContext_T_openvm_circuit_arch_integration_api_DynAdapterInterface_T_for_openvm_circuit_arch_integration_api_AdapterAirContext_T_openvm_circuit_arch_integration_api_VecHeapTwoReadsAdapterInterface_BLOCKS_PER_READ1_BLOCKS_PER_READ2_BLOCKS_PER_WRITE_READ_SIZE_WRITE_SIZE_T.
      
      Module Impl_core_convert_From_openvm_circuit_arch_integration_api_AdapterRuntimeContext_T_openvm_circuit_arch_integration_api_DynAdapterInterface_T_for_openvm_circuit_arch_integration_api_AdapterRuntimeContext_T_openvm_circuit_arch_integration_api_VecHeapTwoReadsAdapterInterface_BLOCKS_PER_READ1_BLOCKS_PER_READ2_BLOCKS_PER_WRITE_READ_SIZE_WRITE_SIZE_T.
        Definition Self
            (BLOCKS_PER_READ1 BLOCKS_PER_READ2 BLOCKS_PER_WRITE READ_SIZE WRITE_SIZE : Value.t)
            (T : Ty.t)
            : Ty.t :=
          Ty.apply
            (Ty.path "openvm_circuit::arch::integration_api::AdapterRuntimeContext")
            []
            [
              T;
              Ty.apply
                (Ty.path "openvm_circuit::arch::integration_api::VecHeapTwoReadsAdapterInterface")
                [ BLOCKS_PER_READ1; BLOCKS_PER_READ2; BLOCKS_PER_WRITE; READ_SIZE; WRITE_SIZE ]
                [ T ]
            ].
        
        (*
                fn from(ctx: AdapterRuntimeContext<T, DynAdapterInterface<T>>) -> Self {
                    AdapterRuntimeContext {
                        to_pc: ctx.to_pc,
                        writes: ctx.writes.into(),
                    }
                }
        *)
        Definition from
            (BLOCKS_PER_READ1 BLOCKS_PER_READ2 BLOCKS_PER_WRITE READ_SIZE WRITE_SIZE : Value.t)
            (T : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t :=
            Self BLOCKS_PER_READ1 BLOCKS_PER_READ2 BLOCKS_PER_WRITE READ_SIZE WRITE_SIZE T in
          match ε, τ, α with
          | [], [], [ ctx ] =>
            ltac:(M.monadic
              (let ctx :=
                M.alloc (|
                  Ty.apply
                    (Ty.path "openvm_circuit::arch::integration_api::AdapterRuntimeContext")
                    []
                    [
                      T;
                      Ty.apply
                        (Ty.path "openvm_circuit::arch::integration_api::DynAdapterInterface")
                        []
                        [ T ]
                    ],
                  ctx
                |) in
              Value.mkStructRecord
                "openvm_circuit::arch::integration_api::AdapterRuntimeContext"
                []
                [
                  T;
                  Ty.apply
                    (Ty.path
                      "openvm_circuit::arch::integration_api::VecHeapTwoReadsAdapterInterface")
                    [ BLOCKS_PER_READ1; BLOCKS_PER_READ2; BLOCKS_PER_WRITE; READ_SIZE; WRITE_SIZE ]
                    [ T ]
                ]
                [
                  ("to_pc",
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        ctx,
                        "openvm_circuit::arch::integration_api::AdapterRuntimeContext",
                        "to_pc"
                      |)
                    |));
                  ("writes",
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "array")
                        [ BLOCKS_PER_WRITE ]
                        [ Ty.apply (Ty.path "array") [ WRITE_SIZE ] [ T ] ],
                      M.get_trait_method (|
                        "core::convert::Into",
                        Ty.apply
                          (Ty.path "openvm_circuit::arch::integration_api::DynArray")
                          []
                          [ T ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "array")
                            [ BLOCKS_PER_WRITE ]
                            [ Ty.apply (Ty.path "array") [ WRITE_SIZE ] [ T ] ]
                        ],
                        "into",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            ctx,
                            "openvm_circuit::arch::integration_api::AdapterRuntimeContext",
                            "writes"
                          |)
                        |)
                      ]
                    |))
                ]))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          forall
            (BLOCKS_PER_READ1 BLOCKS_PER_READ2 BLOCKS_PER_WRITE READ_SIZE WRITE_SIZE : Value.t)
            (T : Ty.t),
          M.IsTraitInstance
            "core::convert::From"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *)
            [
              Ty.apply
                (Ty.path "openvm_circuit::arch::integration_api::AdapterRuntimeContext")
                []
                [
                  T;
                  Ty.apply
                    (Ty.path "openvm_circuit::arch::integration_api::DynAdapterInterface")
                    []
                    [ T ]
                ]
            ]
            (Self BLOCKS_PER_READ1 BLOCKS_PER_READ2 BLOCKS_PER_WRITE READ_SIZE WRITE_SIZE T)
            (* Instance *)
            [
              ("from",
                InstanceField.Method
                  (from BLOCKS_PER_READ1 BLOCKS_PER_READ2 BLOCKS_PER_WRITE READ_SIZE WRITE_SIZE T))
            ].
      End Impl_core_convert_From_openvm_circuit_arch_integration_api_AdapterRuntimeContext_T_openvm_circuit_arch_integration_api_DynAdapterInterface_T_for_openvm_circuit_arch_integration_api_AdapterRuntimeContext_T_openvm_circuit_arch_integration_api_VecHeapTwoReadsAdapterInterface_BLOCKS_PER_READ1_BLOCKS_PER_READ2_BLOCKS_PER_WRITE_READ_SIZE_WRITE_SIZE_T.
      
      Module Impl_core_convert_From_openvm_circuit_arch_integration_api_AdapterRuntimeContext_T_openvm_circuit_arch_integration_api_BasicAdapterInterface_BASIC_NUM_READS_BASIC_NUM_WRITES_READ_SIZE_WRITE_SIZE_T_PI_for_openvm_circuit_arch_integration_api_AdapterRuntimeContext_T_openvm_circuit_arch_integration_api_VecHeapAdapterInterface_NUM_READS_BLOCKS_PER_READ_BLOCKS_PER_WRITE_READ_SIZE_WRITE_SIZE_T.
        Definition Self
            (BASIC_NUM_READS
              BASIC_NUM_WRITES
              NUM_READS
              BLOCKS_PER_READ
              BLOCKS_PER_WRITE
              READ_SIZE
              WRITE_SIZE
              :
              Value.t)
            (T PI : Ty.t)
            : Ty.t :=
          Ty.apply
            (Ty.path "openvm_circuit::arch::integration_api::AdapterRuntimeContext")
            []
            [
              T;
              Ty.apply
                (Ty.path "openvm_circuit::arch::integration_api::VecHeapAdapterInterface")
                [ NUM_READS; BLOCKS_PER_READ; BLOCKS_PER_WRITE; READ_SIZE; WRITE_SIZE ]
                [ T ]
            ].
        
        (*
                fn from(
                    ctx: AdapterRuntimeContext<
                        T,
                        BasicAdapterInterface<
                            T,
                            PI,
                            BASIC_NUM_READS,
                            BASIC_NUM_WRITES,
                            READ_SIZE,
                            WRITE_SIZE,
                        >,
                    >,
                ) -> Self {
                    assert_eq!(BASIC_NUM_WRITES, BLOCKS_PER_WRITE);
                    let mut writes_it = ctx.writes.into_iter();
                    let writes = from_fn(|_| writes_it.next().unwrap());
                    AdapterRuntimeContext {
                        to_pc: ctx.to_pc,
                        writes,
                    }
                }
        *)
        Definition from
            (BASIC_NUM_READS
              BASIC_NUM_WRITES
              NUM_READS
              BLOCKS_PER_READ
              BLOCKS_PER_WRITE
              READ_SIZE
              WRITE_SIZE
              :
              Value.t)
            (T PI : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t :=
            Self
              BASIC_NUM_READS
              BASIC_NUM_WRITES
              NUM_READS
              BLOCKS_PER_READ
              BLOCKS_PER_WRITE
              READ_SIZE
              WRITE_SIZE
              T
              PI in
          match ε, τ, α with
          | [], [], [ ctx ] =>
            ltac:(M.monadic
              (let ctx :=
                M.alloc (|
                  Ty.apply
                    (Ty.path "openvm_circuit::arch::integration_api::AdapterRuntimeContext")
                    []
                    [
                      T;
                      Ty.apply
                        (Ty.path "openvm_circuit::arch::integration_api::BasicAdapterInterface")
                        [ BASIC_NUM_READS; BASIC_NUM_WRITES; READ_SIZE; WRITE_SIZE ]
                        [ T; PI ]
                    ],
                  ctx
                |) in
              M.read (|
                let~ _ : Ty.tuple [] :=
                  M.match_operator (|
                    Ty.tuple [],
                    M.alloc (|
                      Ty.tuple
                        [
                          Ty.apply (Ty.path "&") [] [ Ty.path "usize" ];
                          Ty.apply (Ty.path "&") [] [ Ty.path "usize" ]
                        ],
                      Value.Tuple
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.alloc (| Ty.path "usize", BASIC_NUM_WRITES |)
                          |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.alloc (| Ty.path "usize", BLOCKS_PER_WRITE |)
                          |)
                        ]
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                          let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                          let left_val :=
                            M.copy (| Ty.apply (Ty.path "&") [] [ Ty.path "usize" ], γ0_0 |) in
                          let right_val :=
                            M.copy (| Ty.apply (Ty.path "&") [] [ Ty.path "usize" ], γ0_1 |) in
                          M.match_operator (|
                            Ty.tuple [],
                            M.alloc (| Ty.tuple [], Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ :=
                                    M.use
                                      (M.alloc (|
                                        Ty.path "bool",
                                        UnOp.not (|
                                          M.call_closure (|
                                            Ty.path "bool",
                                            BinOp.eq,
                                            [
                                              M.read (| M.deref (| M.read (| left_val |) |) |);
                                              M.read (| M.deref (| M.read (| right_val |) |) |)
                                            ]
                                          |)
                                        |)
                                      |)) in
                                  let _ :=
                                    is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  M.never_to_any (|
                                    M.read (|
                                      let~ kind : Ty.path "core::panicking::AssertKind" :=
                                        Value.StructTuple
                                          "core::panicking::AssertKind::Eq"
                                          []
                                          []
                                          [] in
                                      M.alloc (|
                                        Ty.path "never",
                                        M.call_closure (|
                                          Ty.path "never",
                                          M.get_function (|
                                            "core::panicking::assert_failed",
                                            [],
                                            [ Ty.path "usize"; Ty.path "usize" ]
                                          |),
                                          [
                                            M.read (| kind |);
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (| M.read (| left_val |) |)
                                                |)
                                              |)
                                            |);
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (| M.read (| right_val |) |)
                                                |)
                                              |)
                                            |);
                                            Value.StructTuple
                                              "core::option::Option::None"
                                              []
                                              [ Ty.path "core::fmt::Arguments" ]
                                              []
                                          ]
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ => ltac:(M.monadic (Value.Tuple []))
                            ]
                          |)))
                    ]
                  |) in
                let~ writes_it :
                    Ty.apply
                      (Ty.path "core::array::iter::IntoIter")
                      [ BASIC_NUM_WRITES ]
                      [ Ty.apply (Ty.path "array") [ WRITE_SIZE ] [ T ] ] :=
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::array::iter::IntoIter")
                      [ BASIC_NUM_WRITES ]
                      [ Ty.apply (Ty.path "array") [ WRITE_SIZE ] [ T ] ],
                    M.get_trait_method (|
                      "core::iter::traits::collect::IntoIterator",
                      Ty.apply
                        (Ty.path "array")
                        [ BASIC_NUM_WRITES ]
                        [ Ty.apply (Ty.path "array") [ WRITE_SIZE ] [ T ] ],
                      [],
                      [],
                      "into_iter",
                      [],
                      []
                    |),
                    [
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          ctx,
                          "openvm_circuit::arch::integration_api::AdapterRuntimeContext",
                          "writes"
                        |)
                      |)
                    ]
                  |) in
                let~ writes :
                    Ty.apply
                      (Ty.path "array")
                      [ BLOCKS_PER_WRITE ]
                      [ Ty.apply (Ty.path "array") [ WRITE_SIZE ] [ T ] ] :=
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "array")
                      [ BLOCKS_PER_WRITE ]
                      [ Ty.apply (Ty.path "array") [ WRITE_SIZE ] [ T ] ],
                    M.get_function (|
                      "core::array::from_fn",
                      [ BLOCKS_PER_WRITE ],
                      [
                        Ty.apply (Ty.path "array") [ WRITE_SIZE ] [ T ];
                        Ty.function
                          [ Ty.path "usize" ]
                          (Ty.apply (Ty.path "array") [ WRITE_SIZE ] [ T ])
                      ]
                    |),
                    [
                      M.closure
                        (fun γ =>
                          ltac:(M.monadic
                            match γ with
                            | [ α0 ] =>
                              ltac:(M.monadic
                                (M.match_operator (|
                                  Ty.apply (Ty.path "array") [ WRITE_SIZE ] [ T ],
                                  M.alloc (| Ty.path "usize", α0 |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (M.call_closure (|
                                          Ty.apply (Ty.path "array") [ WRITE_SIZE ] [ T ],
                                          M.get_associated_function (|
                                            Ty.apply
                                              (Ty.path "core::option::Option")
                                              []
                                              [ Ty.apply (Ty.path "array") [ WRITE_SIZE ] [ T ] ],
                                            "unwrap",
                                            [],
                                            []
                                          |),
                                          [
                                            M.call_closure (|
                                              Ty.apply
                                                (Ty.path "core::option::Option")
                                                []
                                                [ Ty.apply (Ty.path "array") [ WRITE_SIZE ] [ T ] ],
                                              M.get_trait_method (|
                                                "core::iter::traits::iterator::Iterator",
                                                Ty.apply
                                                  (Ty.path "core::array::iter::IntoIter")
                                                  [ BASIC_NUM_WRITES ]
                                                  [ Ty.apply (Ty.path "array") [ WRITE_SIZE ] [ T ]
                                                  ],
                                                [],
                                                [],
                                                "next",
                                                [],
                                                []
                                              |),
                                              [ M.borrow (| Pointer.Kind.MutRef, writes_it |) ]
                                            |)
                                          ]
                                        |)))
                                  ]
                                |)))
                            | _ => M.impossible "wrong number of arguments"
                            end))
                    ]
                  |) in
                M.alloc (|
                  Ty.apply
                    (Ty.path "openvm_circuit::arch::integration_api::AdapterRuntimeContext")
                    []
                    [
                      T;
                      Ty.apply
                        (Ty.path "openvm_circuit::arch::integration_api::VecHeapAdapterInterface")
                        [ NUM_READS; BLOCKS_PER_READ; BLOCKS_PER_WRITE; READ_SIZE; WRITE_SIZE ]
                        [ T ]
                    ],
                  Value.mkStructRecord
                    "openvm_circuit::arch::integration_api::AdapterRuntimeContext"
                    []
                    [
                      T;
                      Ty.apply
                        (Ty.path "openvm_circuit::arch::integration_api::VecHeapAdapterInterface")
                        [ NUM_READS; BLOCKS_PER_READ; BLOCKS_PER_WRITE; READ_SIZE; WRITE_SIZE ]
                        [ T ]
                    ]
                    [
                      ("to_pc",
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            ctx,
                            "openvm_circuit::arch::integration_api::AdapterRuntimeContext",
                            "to_pc"
                          |)
                        |));
                      ("writes", M.read (| writes |))
                    ]
                |)
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          forall
            (BASIC_NUM_READS
              BASIC_NUM_WRITES
              NUM_READS
              BLOCKS_PER_READ
              BLOCKS_PER_WRITE
              READ_SIZE
              WRITE_SIZE
              :
              Value.t)
            (T PI : Ty.t),
          M.IsTraitInstance
            "core::convert::From"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *)
            [
              Ty.apply
                (Ty.path "openvm_circuit::arch::integration_api::AdapterRuntimeContext")
                []
                [
                  T;
                  Ty.apply
                    (Ty.path "openvm_circuit::arch::integration_api::BasicAdapterInterface")
                    [ BASIC_NUM_READS; BASIC_NUM_WRITES; READ_SIZE; WRITE_SIZE ]
                    [ T; PI ]
                ]
            ]
            (Self
              BASIC_NUM_READS
              BASIC_NUM_WRITES
              NUM_READS
              BLOCKS_PER_READ
              BLOCKS_PER_WRITE
              READ_SIZE
              WRITE_SIZE
              T
              PI)
            (* Instance *)
            [
              ("from",
                InstanceField.Method
                  (from
                    BASIC_NUM_READS
                    BASIC_NUM_WRITES
                    NUM_READS
                    BLOCKS_PER_READ
                    BLOCKS_PER_WRITE
                    READ_SIZE
                    WRITE_SIZE
                    T
                    PI))
            ].
      End Impl_core_convert_From_openvm_circuit_arch_integration_api_AdapterRuntimeContext_T_openvm_circuit_arch_integration_api_BasicAdapterInterface_BASIC_NUM_READS_BASIC_NUM_WRITES_READ_SIZE_WRITE_SIZE_T_PI_for_openvm_circuit_arch_integration_api_AdapterRuntimeContext_T_openvm_circuit_arch_integration_api_VecHeapAdapterInterface_NUM_READS_BLOCKS_PER_READ_BLOCKS_PER_WRITE_READ_SIZE_WRITE_SIZE_T.
      
      Module Impl_core_convert_From_where_core_convert_Into_PI_openvm_circuit_arch_integration_api_MinimalInstruction_T_openvm_circuit_arch_integration_api_AdapterAirContext_T_openvm_circuit_arch_integration_api_BasicAdapterInterface_BASIC_NUM_READS_BASIC_NUM_WRITES_READ_SIZE_WRITE_SIZE_T_PI_for_openvm_circuit_arch_integration_api_AdapterAirContext_T_openvm_circuit_arch_integration_api_VecHeapAdapterInterface_NUM_READS_BLOCKS_PER_READ_BLOCKS_PER_WRITE_READ_SIZE_WRITE_SIZE_T.
        Definition Self
            (BASIC_NUM_READS
              BASIC_NUM_WRITES
              NUM_READS
              BLOCKS_PER_READ
              BLOCKS_PER_WRITE
              READ_SIZE
              WRITE_SIZE
              :
              Value.t)
            (T PI : Ty.t)
            : Ty.t :=
          Ty.apply
            (Ty.path "openvm_circuit::arch::integration_api::AdapterAirContext")
            []
            [
              T;
              Ty.apply
                (Ty.path "openvm_circuit::arch::integration_api::VecHeapAdapterInterface")
                [ NUM_READS; BLOCKS_PER_READ; BLOCKS_PER_WRITE; READ_SIZE; WRITE_SIZE ]
                [ T ]
            ].
        
        (*
                fn from(
                    ctx: AdapterAirContext<
                        T,
                        BasicAdapterInterface<
                            T,
                            PI,
                            BASIC_NUM_READS,
                            BASIC_NUM_WRITES,
                            READ_SIZE,
                            WRITE_SIZE,
                        >,
                    >,
                ) -> Self {
                    assert_eq!(BASIC_NUM_READS, NUM_READS * BLOCKS_PER_READ);
                    let mut reads_it = ctx.reads.into_iter();
                    let reads = from_fn(|_| from_fn(|_| reads_it.next().unwrap()));
                    assert_eq!(BASIC_NUM_WRITES, BLOCKS_PER_WRITE);
                    let mut writes_it = ctx.writes.into_iter();
                    let writes = from_fn(|_| writes_it.next().unwrap());
                    AdapterAirContext {
                        to_pc: ctx.to_pc,
                        reads,
                        writes,
                        instruction: ctx.instruction.into(),
                    }
                }
        *)
        Definition from
            (BASIC_NUM_READS
              BASIC_NUM_WRITES
              NUM_READS
              BLOCKS_PER_READ
              BLOCKS_PER_WRITE
              READ_SIZE
              WRITE_SIZE
              :
              Value.t)
            (T PI : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t :=
            Self
              BASIC_NUM_READS
              BASIC_NUM_WRITES
              NUM_READS
              BLOCKS_PER_READ
              BLOCKS_PER_WRITE
              READ_SIZE
              WRITE_SIZE
              T
              PI in
          match ε, τ, α with
          | [], [], [ ctx ] =>
            ltac:(M.monadic
              (let ctx :=
                M.alloc (|
                  Ty.apply
                    (Ty.path "openvm_circuit::arch::integration_api::AdapterAirContext")
                    []
                    [
                      T;
                      Ty.apply
                        (Ty.path "openvm_circuit::arch::integration_api::BasicAdapterInterface")
                        [ BASIC_NUM_READS; BASIC_NUM_WRITES; READ_SIZE; WRITE_SIZE ]
                        [ T; PI ]
                    ],
                  ctx
                |) in
              M.read (|
                let~ _ : Ty.tuple [] :=
                  M.match_operator (|
                    Ty.tuple [],
                    M.alloc (|
                      Ty.tuple
                        [
                          Ty.apply (Ty.path "&") [] [ Ty.path "usize" ];
                          Ty.apply (Ty.path "&") [] [ Ty.path "usize" ]
                        ],
                      Value.Tuple
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.alloc (| Ty.path "usize", BASIC_NUM_READS |)
                          |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.alloc (|
                              Ty.path "usize",
                              M.call_closure (|
                                Ty.path "usize",
                                BinOp.Wrap.mul,
                                [ NUM_READS; BLOCKS_PER_READ ]
                              |)
                            |)
                          |)
                        ]
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                          let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                          let left_val :=
                            M.copy (| Ty.apply (Ty.path "&") [] [ Ty.path "usize" ], γ0_0 |) in
                          let right_val :=
                            M.copy (| Ty.apply (Ty.path "&") [] [ Ty.path "usize" ], γ0_1 |) in
                          M.match_operator (|
                            Ty.tuple [],
                            M.alloc (| Ty.tuple [], Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ :=
                                    M.use
                                      (M.alloc (|
                                        Ty.path "bool",
                                        UnOp.not (|
                                          M.call_closure (|
                                            Ty.path "bool",
                                            BinOp.eq,
                                            [
                                              M.read (| M.deref (| M.read (| left_val |) |) |);
                                              M.read (| M.deref (| M.read (| right_val |) |) |)
                                            ]
                                          |)
                                        |)
                                      |)) in
                                  let _ :=
                                    is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  M.never_to_any (|
                                    M.read (|
                                      let~ kind : Ty.path "core::panicking::AssertKind" :=
                                        Value.StructTuple
                                          "core::panicking::AssertKind::Eq"
                                          []
                                          []
                                          [] in
                                      M.alloc (|
                                        Ty.path "never",
                                        M.call_closure (|
                                          Ty.path "never",
                                          M.get_function (|
                                            "core::panicking::assert_failed",
                                            [],
                                            [ Ty.path "usize"; Ty.path "usize" ]
                                          |),
                                          [
                                            M.read (| kind |);
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (| M.read (| left_val |) |)
                                                |)
                                              |)
                                            |);
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (| M.read (| right_val |) |)
                                                |)
                                              |)
                                            |);
                                            Value.StructTuple
                                              "core::option::Option::None"
                                              []
                                              [ Ty.path "core::fmt::Arguments" ]
                                              []
                                          ]
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ => ltac:(M.monadic (Value.Tuple []))
                            ]
                          |)))
                    ]
                  |) in
                let~ reads_it :
                    Ty.apply
                      (Ty.path "core::array::iter::IntoIter")
                      [ BASIC_NUM_READS ]
                      [ Ty.apply (Ty.path "array") [ READ_SIZE ] [ T ] ] :=
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::array::iter::IntoIter")
                      [ BASIC_NUM_READS ]
                      [ Ty.apply (Ty.path "array") [ READ_SIZE ] [ T ] ],
                    M.get_trait_method (|
                      "core::iter::traits::collect::IntoIterator",
                      Ty.apply
                        (Ty.path "array")
                        [ BASIC_NUM_READS ]
                        [ Ty.apply (Ty.path "array") [ READ_SIZE ] [ T ] ],
                      [],
                      [],
                      "into_iter",
                      [],
                      []
                    |),
                    [
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          ctx,
                          "openvm_circuit::arch::integration_api::AdapterAirContext",
                          "reads"
                        |)
                      |)
                    ]
                  |) in
                let~ reads :
                    Ty.apply
                      (Ty.path "array")
                      [ NUM_READS ]
                      [
                        Ty.apply
                          (Ty.path "array")
                          [ BLOCKS_PER_READ ]
                          [ Ty.apply (Ty.path "array") [ READ_SIZE ] [ T ] ]
                      ] :=
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "array")
                      [ NUM_READS ]
                      [
                        Ty.apply
                          (Ty.path "array")
                          [ BLOCKS_PER_READ ]
                          [ Ty.apply (Ty.path "array") [ READ_SIZE ] [ T ] ]
                      ],
                    M.get_function (|
                      "core::array::from_fn",
                      [ NUM_READS ],
                      [
                        Ty.apply
                          (Ty.path "array")
                          [ BLOCKS_PER_READ ]
                          [ Ty.apply (Ty.path "array") [ READ_SIZE ] [ T ] ];
                        Ty.function
                          [ Ty.path "usize" ]
                          (Ty.apply
                            (Ty.path "array")
                            [ BLOCKS_PER_READ ]
                            [ Ty.apply (Ty.path "array") [ READ_SIZE ] [ T ] ])
                      ]
                    |),
                    [
                      M.closure
                        (fun γ =>
                          ltac:(M.monadic
                            match γ with
                            | [ α0 ] =>
                              ltac:(M.monadic
                                (M.match_operator (|
                                  Ty.apply
                                    (Ty.path "array")
                                    [ BLOCKS_PER_READ ]
                                    [ Ty.apply (Ty.path "array") [ READ_SIZE ] [ T ] ],
                                  M.alloc (| Ty.path "usize", α0 |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (M.call_closure (|
                                          Ty.apply
                                            (Ty.path "array")
                                            [ BLOCKS_PER_READ ]
                                            [ Ty.apply (Ty.path "array") [ READ_SIZE ] [ T ] ],
                                          M.get_function (|
                                            "core::array::from_fn",
                                            [ BLOCKS_PER_READ ],
                                            [
                                              Ty.apply (Ty.path "array") [ READ_SIZE ] [ T ];
                                              Ty.function
                                                [ Ty.path "usize" ]
                                                (Ty.apply (Ty.path "array") [ READ_SIZE ] [ T ])
                                            ]
                                          |),
                                          [
                                            M.closure
                                              (fun γ =>
                                                ltac:(M.monadic
                                                  match γ with
                                                  | [ α0 ] =>
                                                    ltac:(M.monadic
                                                      (M.match_operator (|
                                                        Ty.apply
                                                          (Ty.path "array")
                                                          [ READ_SIZE ]
                                                          [ T ],
                                                        M.alloc (| Ty.path "usize", α0 |),
                                                        [
                                                          fun γ =>
                                                            ltac:(M.monadic
                                                              (M.call_closure (|
                                                                Ty.apply
                                                                  (Ty.path "array")
                                                                  [ READ_SIZE ]
                                                                  [ T ],
                                                                M.get_associated_function (|
                                                                  Ty.apply
                                                                    (Ty.path "core::option::Option")
                                                                    []
                                                                    [
                                                                      Ty.apply
                                                                        (Ty.path "array")
                                                                        [ READ_SIZE ]
                                                                        [ T ]
                                                                    ],
                                                                  "unwrap",
                                                                  [],
                                                                  []
                                                                |),
                                                                [
                                                                  M.call_closure (|
                                                                    Ty.apply
                                                                      (Ty.path
                                                                        "core::option::Option")
                                                                      []
                                                                      [
                                                                        Ty.apply
                                                                          (Ty.path "array")
                                                                          [ READ_SIZE ]
                                                                          [ T ]
                                                                      ],
                                                                    M.get_trait_method (|
                                                                      "core::iter::traits::iterator::Iterator",
                                                                      Ty.apply
                                                                        (Ty.path
                                                                          "core::array::iter::IntoIter")
                                                                        [ BASIC_NUM_READS ]
                                                                        [
                                                                          Ty.apply
                                                                            (Ty.path "array")
                                                                            [ READ_SIZE ]
                                                                            [ T ]
                                                                        ],
                                                                      [],
                                                                      [],
                                                                      "next",
                                                                      [],
                                                                      []
                                                                    |),
                                                                    [
                                                                      M.borrow (|
                                                                        Pointer.Kind.MutRef,
                                                                        reads_it
                                                                      |)
                                                                    ]
                                                                  |)
                                                                ]
                                                              |)))
                                                        ]
                                                      |)))
                                                  | _ => M.impossible "wrong number of arguments"
                                                  end))
                                          ]
                                        |)))
                                  ]
                                |)))
                            | _ => M.impossible "wrong number of arguments"
                            end))
                    ]
                  |) in
                let~ _ : Ty.tuple [] :=
                  M.match_operator (|
                    Ty.tuple [],
                    M.alloc (|
                      Ty.tuple
                        [
                          Ty.apply (Ty.path "&") [] [ Ty.path "usize" ];
                          Ty.apply (Ty.path "&") [] [ Ty.path "usize" ]
                        ],
                      Value.Tuple
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.alloc (| Ty.path "usize", BASIC_NUM_WRITES |)
                          |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.alloc (| Ty.path "usize", BLOCKS_PER_WRITE |)
                          |)
                        ]
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                          let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                          let left_val :=
                            M.copy (| Ty.apply (Ty.path "&") [] [ Ty.path "usize" ], γ0_0 |) in
                          let right_val :=
                            M.copy (| Ty.apply (Ty.path "&") [] [ Ty.path "usize" ], γ0_1 |) in
                          M.match_operator (|
                            Ty.tuple [],
                            M.alloc (| Ty.tuple [], Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ :=
                                    M.use
                                      (M.alloc (|
                                        Ty.path "bool",
                                        UnOp.not (|
                                          M.call_closure (|
                                            Ty.path "bool",
                                            BinOp.eq,
                                            [
                                              M.read (| M.deref (| M.read (| left_val |) |) |);
                                              M.read (| M.deref (| M.read (| right_val |) |) |)
                                            ]
                                          |)
                                        |)
                                      |)) in
                                  let _ :=
                                    is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  M.never_to_any (|
                                    M.read (|
                                      let~ kind : Ty.path "core::panicking::AssertKind" :=
                                        Value.StructTuple
                                          "core::panicking::AssertKind::Eq"
                                          []
                                          []
                                          [] in
                                      M.alloc (|
                                        Ty.path "never",
                                        M.call_closure (|
                                          Ty.path "never",
                                          M.get_function (|
                                            "core::panicking::assert_failed",
                                            [],
                                            [ Ty.path "usize"; Ty.path "usize" ]
                                          |),
                                          [
                                            M.read (| kind |);
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (| M.read (| left_val |) |)
                                                |)
                                              |)
                                            |);
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (| M.read (| right_val |) |)
                                                |)
                                              |)
                                            |);
                                            Value.StructTuple
                                              "core::option::Option::None"
                                              []
                                              [ Ty.path "core::fmt::Arguments" ]
                                              []
                                          ]
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ => ltac:(M.monadic (Value.Tuple []))
                            ]
                          |)))
                    ]
                  |) in
                let~ writes_it :
                    Ty.apply
                      (Ty.path "core::array::iter::IntoIter")
                      [ BASIC_NUM_WRITES ]
                      [ Ty.apply (Ty.path "array") [ WRITE_SIZE ] [ T ] ] :=
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::array::iter::IntoIter")
                      [ BASIC_NUM_WRITES ]
                      [ Ty.apply (Ty.path "array") [ WRITE_SIZE ] [ T ] ],
                    M.get_trait_method (|
                      "core::iter::traits::collect::IntoIterator",
                      Ty.apply
                        (Ty.path "array")
                        [ BASIC_NUM_WRITES ]
                        [ Ty.apply (Ty.path "array") [ WRITE_SIZE ] [ T ] ],
                      [],
                      [],
                      "into_iter",
                      [],
                      []
                    |),
                    [
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          ctx,
                          "openvm_circuit::arch::integration_api::AdapterAirContext",
                          "writes"
                        |)
                      |)
                    ]
                  |) in
                let~ writes :
                    Ty.apply
                      (Ty.path "array")
                      [ BLOCKS_PER_WRITE ]
                      [ Ty.apply (Ty.path "array") [ WRITE_SIZE ] [ T ] ] :=
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "array")
                      [ BLOCKS_PER_WRITE ]
                      [ Ty.apply (Ty.path "array") [ WRITE_SIZE ] [ T ] ],
                    M.get_function (|
                      "core::array::from_fn",
                      [ BLOCKS_PER_WRITE ],
                      [
                        Ty.apply (Ty.path "array") [ WRITE_SIZE ] [ T ];
                        Ty.function
                          [ Ty.path "usize" ]
                          (Ty.apply (Ty.path "array") [ WRITE_SIZE ] [ T ])
                      ]
                    |),
                    [
                      M.closure
                        (fun γ =>
                          ltac:(M.monadic
                            match γ with
                            | [ α0 ] =>
                              ltac:(M.monadic
                                (M.match_operator (|
                                  Ty.apply (Ty.path "array") [ WRITE_SIZE ] [ T ],
                                  M.alloc (| Ty.path "usize", α0 |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (M.call_closure (|
                                          Ty.apply (Ty.path "array") [ WRITE_SIZE ] [ T ],
                                          M.get_associated_function (|
                                            Ty.apply
                                              (Ty.path "core::option::Option")
                                              []
                                              [ Ty.apply (Ty.path "array") [ WRITE_SIZE ] [ T ] ],
                                            "unwrap",
                                            [],
                                            []
                                          |),
                                          [
                                            M.call_closure (|
                                              Ty.apply
                                                (Ty.path "core::option::Option")
                                                []
                                                [ Ty.apply (Ty.path "array") [ WRITE_SIZE ] [ T ] ],
                                              M.get_trait_method (|
                                                "core::iter::traits::iterator::Iterator",
                                                Ty.apply
                                                  (Ty.path "core::array::iter::IntoIter")
                                                  [ BASIC_NUM_WRITES ]
                                                  [ Ty.apply (Ty.path "array") [ WRITE_SIZE ] [ T ]
                                                  ],
                                                [],
                                                [],
                                                "next",
                                                [],
                                                []
                                              |),
                                              [ M.borrow (| Pointer.Kind.MutRef, writes_it |) ]
                                            |)
                                          ]
                                        |)))
                                  ]
                                |)))
                            | _ => M.impossible "wrong number of arguments"
                            end))
                    ]
                  |) in
                M.alloc (|
                  Ty.apply
                    (Ty.path "openvm_circuit::arch::integration_api::AdapterAirContext")
                    []
                    [
                      T;
                      Ty.apply
                        (Ty.path "openvm_circuit::arch::integration_api::VecHeapAdapterInterface")
                        [ NUM_READS; BLOCKS_PER_READ; BLOCKS_PER_WRITE; READ_SIZE; WRITE_SIZE ]
                        [ T ]
                    ],
                  Value.mkStructRecord
                    "openvm_circuit::arch::integration_api::AdapterAirContext"
                    []
                    [
                      T;
                      Ty.apply
                        (Ty.path "openvm_circuit::arch::integration_api::VecHeapAdapterInterface")
                        [ NUM_READS; BLOCKS_PER_READ; BLOCKS_PER_WRITE; READ_SIZE; WRITE_SIZE ]
                        [ T ]
                    ]
                    [
                      ("to_pc",
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            ctx,
                            "openvm_circuit::arch::integration_api::AdapterAirContext",
                            "to_pc"
                          |)
                        |));
                      ("reads", M.read (| reads |));
                      ("writes", M.read (| writes |));
                      ("instruction",
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "openvm_circuit::arch::integration_api::MinimalInstruction")
                            []
                            [ T ],
                          M.get_trait_method (|
                            "core::convert::Into",
                            PI,
                            [],
                            [
                              Ty.apply
                                (Ty.path
                                  "openvm_circuit::arch::integration_api::MinimalInstruction")
                                []
                                [ T ]
                            ],
                            "into",
                            [],
                            []
                          |),
                          [
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                ctx,
                                "openvm_circuit::arch::integration_api::AdapterAirContext",
                                "instruction"
                              |)
                            |)
                          ]
                        |))
                    ]
                |)
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          forall
            (BASIC_NUM_READS
              BASIC_NUM_WRITES
              NUM_READS
              BLOCKS_PER_READ
              BLOCKS_PER_WRITE
              READ_SIZE
              WRITE_SIZE
              :
              Value.t)
            (T PI : Ty.t),
          M.IsTraitInstance
            "core::convert::From"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *)
            [
              Ty.apply
                (Ty.path "openvm_circuit::arch::integration_api::AdapterAirContext")
                []
                [
                  T;
                  Ty.apply
                    (Ty.path "openvm_circuit::arch::integration_api::BasicAdapterInterface")
                    [ BASIC_NUM_READS; BASIC_NUM_WRITES; READ_SIZE; WRITE_SIZE ]
                    [ T; PI ]
                ]
            ]
            (Self
              BASIC_NUM_READS
              BASIC_NUM_WRITES
              NUM_READS
              BLOCKS_PER_READ
              BLOCKS_PER_WRITE
              READ_SIZE
              WRITE_SIZE
              T
              PI)
            (* Instance *)
            [
              ("from",
                InstanceField.Method
                  (from
                    BASIC_NUM_READS
                    BASIC_NUM_WRITES
                    NUM_READS
                    BLOCKS_PER_READ
                    BLOCKS_PER_WRITE
                    READ_SIZE
                    WRITE_SIZE
                    T
                    PI))
            ].
      End Impl_core_convert_From_where_core_convert_Into_PI_openvm_circuit_arch_integration_api_MinimalInstruction_T_openvm_circuit_arch_integration_api_AdapterAirContext_T_openvm_circuit_arch_integration_api_BasicAdapterInterface_BASIC_NUM_READS_BASIC_NUM_WRITES_READ_SIZE_WRITE_SIZE_T_PI_for_openvm_circuit_arch_integration_api_AdapterAirContext_T_openvm_circuit_arch_integration_api_VecHeapAdapterInterface_NUM_READS_BLOCKS_PER_READ_BLOCKS_PER_WRITE_READ_SIZE_WRITE_SIZE_T.
      
      Module Impl_core_convert_From_openvm_circuit_arch_integration_api_AdapterAirContext_T_openvm_circuit_arch_integration_api_BasicAdapterInterface_NUM_READS_NUM_WRITES_READ_SIZE_WRITE_SIZE_T_PI_for_openvm_circuit_arch_integration_api_AdapterAirContext_T_openvm_circuit_arch_integration_api_FlatInterface_READ_CELLS_WRITE_CELLS_T_PI.
        Definition Self
            (NUM_READS NUM_WRITES READ_SIZE WRITE_SIZE READ_CELLS WRITE_CELLS : Value.t)
            (T PI : Ty.t)
            : Ty.t :=
          Ty.apply
            (Ty.path "openvm_circuit::arch::integration_api::AdapterAirContext")
            []
            [
              T;
              Ty.apply
                (Ty.path "openvm_circuit::arch::integration_api::FlatInterface")
                [ READ_CELLS; WRITE_CELLS ]
                [ T; PI ]
            ].
        
        (*
                fn from(
                    ctx: AdapterAirContext<
                        T,
                        BasicAdapterInterface<T, PI, NUM_READS, NUM_WRITES, READ_SIZE, WRITE_SIZE>,
                    >,
                ) -> AdapterAirContext<T, FlatInterface<T, PI, READ_CELLS, WRITE_CELLS>> {
                    assert_eq!(READ_CELLS, NUM_READS * READ_SIZE);
                    assert_eq!(WRITE_CELLS, NUM_WRITES * WRITE_SIZE);
                    let mut reads_it = ctx.reads.into_iter().flatten();
                    let reads = from_fn(|_| reads_it.next().unwrap());
                    let mut writes_it = ctx.writes.into_iter().flatten();
                    let writes = from_fn(|_| writes_it.next().unwrap());
                    AdapterAirContext {
                        to_pc: ctx.to_pc,
                        reads,
                        writes,
                        instruction: ctx.instruction,
                    }
                }
        *)
        Definition from
            (NUM_READS NUM_WRITES READ_SIZE WRITE_SIZE READ_CELLS WRITE_CELLS : Value.t)
            (T PI : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t :=
            Self NUM_READS NUM_WRITES READ_SIZE WRITE_SIZE READ_CELLS WRITE_CELLS T PI in
          match ε, τ, α with
          | [], [], [ ctx ] =>
            ltac:(M.monadic
              (let ctx :=
                M.alloc (|
                  Ty.apply
                    (Ty.path "openvm_circuit::arch::integration_api::AdapterAirContext")
                    []
                    [
                      T;
                      Ty.apply
                        (Ty.path "openvm_circuit::arch::integration_api::BasicAdapterInterface")
                        [ NUM_READS; NUM_WRITES; READ_SIZE; WRITE_SIZE ]
                        [ T; PI ]
                    ],
                  ctx
                |) in
              M.read (|
                let~ _ : Ty.tuple [] :=
                  M.match_operator (|
                    Ty.tuple [],
                    M.alloc (|
                      Ty.tuple
                        [
                          Ty.apply (Ty.path "&") [] [ Ty.path "usize" ];
                          Ty.apply (Ty.path "&") [] [ Ty.path "usize" ]
                        ],
                      Value.Tuple
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.alloc (| Ty.path "usize", READ_CELLS |)
                          |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.alloc (|
                              Ty.path "usize",
                              M.call_closure (|
                                Ty.path "usize",
                                BinOp.Wrap.mul,
                                [ NUM_READS; READ_SIZE ]
                              |)
                            |)
                          |)
                        ]
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                          let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                          let left_val :=
                            M.copy (| Ty.apply (Ty.path "&") [] [ Ty.path "usize" ], γ0_0 |) in
                          let right_val :=
                            M.copy (| Ty.apply (Ty.path "&") [] [ Ty.path "usize" ], γ0_1 |) in
                          M.match_operator (|
                            Ty.tuple [],
                            M.alloc (| Ty.tuple [], Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ :=
                                    M.use
                                      (M.alloc (|
                                        Ty.path "bool",
                                        UnOp.not (|
                                          M.call_closure (|
                                            Ty.path "bool",
                                            BinOp.eq,
                                            [
                                              M.read (| M.deref (| M.read (| left_val |) |) |);
                                              M.read (| M.deref (| M.read (| right_val |) |) |)
                                            ]
                                          |)
                                        |)
                                      |)) in
                                  let _ :=
                                    is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  M.never_to_any (|
                                    M.read (|
                                      let~ kind : Ty.path "core::panicking::AssertKind" :=
                                        Value.StructTuple
                                          "core::panicking::AssertKind::Eq"
                                          []
                                          []
                                          [] in
                                      M.alloc (|
                                        Ty.path "never",
                                        M.call_closure (|
                                          Ty.path "never",
                                          M.get_function (|
                                            "core::panicking::assert_failed",
                                            [],
                                            [ Ty.path "usize"; Ty.path "usize" ]
                                          |),
                                          [
                                            M.read (| kind |);
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (| M.read (| left_val |) |)
                                                |)
                                              |)
                                            |);
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (| M.read (| right_val |) |)
                                                |)
                                              |)
                                            |);
                                            Value.StructTuple
                                              "core::option::Option::None"
                                              []
                                              [ Ty.path "core::fmt::Arguments" ]
                                              []
                                          ]
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ => ltac:(M.monadic (Value.Tuple []))
                            ]
                          |)))
                    ]
                  |) in
                let~ _ : Ty.tuple [] :=
                  M.match_operator (|
                    Ty.tuple [],
                    M.alloc (|
                      Ty.tuple
                        [
                          Ty.apply (Ty.path "&") [] [ Ty.path "usize" ];
                          Ty.apply (Ty.path "&") [] [ Ty.path "usize" ]
                        ],
                      Value.Tuple
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.alloc (| Ty.path "usize", WRITE_CELLS |)
                          |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.alloc (|
                              Ty.path "usize",
                              M.call_closure (|
                                Ty.path "usize",
                                BinOp.Wrap.mul,
                                [ NUM_WRITES; WRITE_SIZE ]
                              |)
                            |)
                          |)
                        ]
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                          let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                          let left_val :=
                            M.copy (| Ty.apply (Ty.path "&") [] [ Ty.path "usize" ], γ0_0 |) in
                          let right_val :=
                            M.copy (| Ty.apply (Ty.path "&") [] [ Ty.path "usize" ], γ0_1 |) in
                          M.match_operator (|
                            Ty.tuple [],
                            M.alloc (| Ty.tuple [], Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ :=
                                    M.use
                                      (M.alloc (|
                                        Ty.path "bool",
                                        UnOp.not (|
                                          M.call_closure (|
                                            Ty.path "bool",
                                            BinOp.eq,
                                            [
                                              M.read (| M.deref (| M.read (| left_val |) |) |);
                                              M.read (| M.deref (| M.read (| right_val |) |) |)
                                            ]
                                          |)
                                        |)
                                      |)) in
                                  let _ :=
                                    is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  M.never_to_any (|
                                    M.read (|
                                      let~ kind : Ty.path "core::panicking::AssertKind" :=
                                        Value.StructTuple
                                          "core::panicking::AssertKind::Eq"
                                          []
                                          []
                                          [] in
                                      M.alloc (|
                                        Ty.path "never",
                                        M.call_closure (|
                                          Ty.path "never",
                                          M.get_function (|
                                            "core::panicking::assert_failed",
                                            [],
                                            [ Ty.path "usize"; Ty.path "usize" ]
                                          |),
                                          [
                                            M.read (| kind |);
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (| M.read (| left_val |) |)
                                                |)
                                              |)
                                            |);
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (| M.read (| right_val |) |)
                                                |)
                                              |)
                                            |);
                                            Value.StructTuple
                                              "core::option::Option::None"
                                              []
                                              [ Ty.path "core::fmt::Arguments" ]
                                              []
                                          ]
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ => ltac:(M.monadic (Value.Tuple []))
                            ]
                          |)))
                    ]
                  |) in
                let~ reads_it :
                    Ty.apply
                      (Ty.path "core::iter::adapters::flatten::Flatten")
                      []
                      [
                        Ty.apply
                          (Ty.path "core::array::iter::IntoIter")
                          [ NUM_READS ]
                          [ Ty.apply (Ty.path "array") [ READ_SIZE ] [ T ] ]
                      ] :=
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::iter::adapters::flatten::Flatten")
                      []
                      [
                        Ty.apply
                          (Ty.path "core::array::iter::IntoIter")
                          [ NUM_READS ]
                          [ Ty.apply (Ty.path "array") [ READ_SIZE ] [ T ] ]
                      ],
                    M.get_trait_method (|
                      "core::iter::traits::iterator::Iterator",
                      Ty.apply
                        (Ty.path "core::array::iter::IntoIter")
                        [ NUM_READS ]
                        [ Ty.apply (Ty.path "array") [ READ_SIZE ] [ T ] ],
                      [],
                      [],
                      "flatten",
                      [],
                      []
                    |),
                    [
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::array::iter::IntoIter")
                          [ NUM_READS ]
                          [ Ty.apply (Ty.path "array") [ READ_SIZE ] [ T ] ],
                        M.get_trait_method (|
                          "core::iter::traits::collect::IntoIterator",
                          Ty.apply
                            (Ty.path "array")
                            [ NUM_READS ]
                            [ Ty.apply (Ty.path "array") [ READ_SIZE ] [ T ] ],
                          [],
                          [],
                          "into_iter",
                          [],
                          []
                        |),
                        [
                          M.read (|
                            M.SubPointer.get_struct_record_field (|
                              ctx,
                              "openvm_circuit::arch::integration_api::AdapterAirContext",
                              "reads"
                            |)
                          |)
                        ]
                      |)
                    ]
                  |) in
                let~ reads : Ty.apply (Ty.path "array") [ READ_CELLS ] [ T ] :=
                  M.call_closure (|
                    Ty.apply (Ty.path "array") [ READ_CELLS ] [ T ],
                    M.get_function (|
                      "core::array::from_fn",
                      [ READ_CELLS ],
                      [ T; Ty.function [ Ty.path "usize" ] T ]
                    |),
                    [
                      M.closure
                        (fun γ =>
                          ltac:(M.monadic
                            match γ with
                            | [ α0 ] =>
                              ltac:(M.monadic
                                (M.match_operator (|
                                  T,
                                  M.alloc (| Ty.path "usize", α0 |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (M.call_closure (|
                                          T,
                                          M.get_associated_function (|
                                            Ty.apply (Ty.path "core::option::Option") [] [ T ],
                                            "unwrap",
                                            [],
                                            []
                                          |),
                                          [
                                            M.call_closure (|
                                              Ty.apply (Ty.path "core::option::Option") [] [ T ],
                                              M.get_trait_method (|
                                                "core::iter::traits::iterator::Iterator",
                                                Ty.apply
                                                  (Ty.path "core::iter::adapters::flatten::Flatten")
                                                  []
                                                  [
                                                    Ty.apply
                                                      (Ty.path "core::array::iter::IntoIter")
                                                      [ NUM_READS ]
                                                      [
                                                        Ty.apply
                                                          (Ty.path "array")
                                                          [ READ_SIZE ]
                                                          [ T ]
                                                      ]
                                                  ],
                                                [],
                                                [],
                                                "next",
                                                [],
                                                []
                                              |),
                                              [ M.borrow (| Pointer.Kind.MutRef, reads_it |) ]
                                            |)
                                          ]
                                        |)))
                                  ]
                                |)))
                            | _ => M.impossible "wrong number of arguments"
                            end))
                    ]
                  |) in
                let~ writes_it :
                    Ty.apply
                      (Ty.path "core::iter::adapters::flatten::Flatten")
                      []
                      [
                        Ty.apply
                          (Ty.path "core::array::iter::IntoIter")
                          [ NUM_WRITES ]
                          [ Ty.apply (Ty.path "array") [ WRITE_SIZE ] [ T ] ]
                      ] :=
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::iter::adapters::flatten::Flatten")
                      []
                      [
                        Ty.apply
                          (Ty.path "core::array::iter::IntoIter")
                          [ NUM_WRITES ]
                          [ Ty.apply (Ty.path "array") [ WRITE_SIZE ] [ T ] ]
                      ],
                    M.get_trait_method (|
                      "core::iter::traits::iterator::Iterator",
                      Ty.apply
                        (Ty.path "core::array::iter::IntoIter")
                        [ NUM_WRITES ]
                        [ Ty.apply (Ty.path "array") [ WRITE_SIZE ] [ T ] ],
                      [],
                      [],
                      "flatten",
                      [],
                      []
                    |),
                    [
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::array::iter::IntoIter")
                          [ NUM_WRITES ]
                          [ Ty.apply (Ty.path "array") [ WRITE_SIZE ] [ T ] ],
                        M.get_trait_method (|
                          "core::iter::traits::collect::IntoIterator",
                          Ty.apply
                            (Ty.path "array")
                            [ NUM_WRITES ]
                            [ Ty.apply (Ty.path "array") [ WRITE_SIZE ] [ T ] ],
                          [],
                          [],
                          "into_iter",
                          [],
                          []
                        |),
                        [
                          M.read (|
                            M.SubPointer.get_struct_record_field (|
                              ctx,
                              "openvm_circuit::arch::integration_api::AdapterAirContext",
                              "writes"
                            |)
                          |)
                        ]
                      |)
                    ]
                  |) in
                let~ writes : Ty.apply (Ty.path "array") [ WRITE_CELLS ] [ T ] :=
                  M.call_closure (|
                    Ty.apply (Ty.path "array") [ WRITE_CELLS ] [ T ],
                    M.get_function (|
                      "core::array::from_fn",
                      [ WRITE_CELLS ],
                      [ T; Ty.function [ Ty.path "usize" ] T ]
                    |),
                    [
                      M.closure
                        (fun γ =>
                          ltac:(M.monadic
                            match γ with
                            | [ α0 ] =>
                              ltac:(M.monadic
                                (M.match_operator (|
                                  T,
                                  M.alloc (| Ty.path "usize", α0 |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (M.call_closure (|
                                          T,
                                          M.get_associated_function (|
                                            Ty.apply (Ty.path "core::option::Option") [] [ T ],
                                            "unwrap",
                                            [],
                                            []
                                          |),
                                          [
                                            M.call_closure (|
                                              Ty.apply (Ty.path "core::option::Option") [] [ T ],
                                              M.get_trait_method (|
                                                "core::iter::traits::iterator::Iterator",
                                                Ty.apply
                                                  (Ty.path "core::iter::adapters::flatten::Flatten")
                                                  []
                                                  [
                                                    Ty.apply
                                                      (Ty.path "core::array::iter::IntoIter")
                                                      [ NUM_WRITES ]
                                                      [
                                                        Ty.apply
                                                          (Ty.path "array")
                                                          [ WRITE_SIZE ]
                                                          [ T ]
                                                      ]
                                                  ],
                                                [],
                                                [],
                                                "next",
                                                [],
                                                []
                                              |),
                                              [ M.borrow (| Pointer.Kind.MutRef, writes_it |) ]
                                            |)
                                          ]
                                        |)))
                                  ]
                                |)))
                            | _ => M.impossible "wrong number of arguments"
                            end))
                    ]
                  |) in
                M.alloc (|
                  Ty.apply
                    (Ty.path "openvm_circuit::arch::integration_api::AdapterAirContext")
                    []
                    [
                      T;
                      Ty.apply
                        (Ty.path "openvm_circuit::arch::integration_api::FlatInterface")
                        [ READ_CELLS; WRITE_CELLS ]
                        [ T; PI ]
                    ],
                  Value.mkStructRecord
                    "openvm_circuit::arch::integration_api::AdapterAirContext"
                    []
                    [
                      T;
                      Ty.apply
                        (Ty.path "openvm_circuit::arch::integration_api::FlatInterface")
                        [ READ_CELLS; WRITE_CELLS ]
                        [ T; PI ]
                    ]
                    [
                      ("to_pc",
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            ctx,
                            "openvm_circuit::arch::integration_api::AdapterAirContext",
                            "to_pc"
                          |)
                        |));
                      ("reads", M.read (| reads |));
                      ("writes", M.read (| writes |));
                      ("instruction",
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            ctx,
                            "openvm_circuit::arch::integration_api::AdapterAirContext",
                            "instruction"
                          |)
                        |))
                    ]
                |)
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          forall
            (NUM_READS NUM_WRITES READ_SIZE WRITE_SIZE READ_CELLS WRITE_CELLS : Value.t)
            (T PI : Ty.t),
          M.IsTraitInstance
            "core::convert::From"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *)
            [
              Ty.apply
                (Ty.path "openvm_circuit::arch::integration_api::AdapterAirContext")
                []
                [
                  T;
                  Ty.apply
                    (Ty.path "openvm_circuit::arch::integration_api::BasicAdapterInterface")
                    [ NUM_READS; NUM_WRITES; READ_SIZE; WRITE_SIZE ]
                    [ T; PI ]
                ]
            ]
            (Self NUM_READS NUM_WRITES READ_SIZE WRITE_SIZE READ_CELLS WRITE_CELLS T PI)
            (* Instance *)
            [
              ("from",
                InstanceField.Method
                  (from NUM_READS NUM_WRITES READ_SIZE WRITE_SIZE READ_CELLS WRITE_CELLS T PI))
            ].
      End Impl_core_convert_From_openvm_circuit_arch_integration_api_AdapterAirContext_T_openvm_circuit_arch_integration_api_BasicAdapterInterface_NUM_READS_NUM_WRITES_READ_SIZE_WRITE_SIZE_T_PI_for_openvm_circuit_arch_integration_api_AdapterAirContext_T_openvm_circuit_arch_integration_api_FlatInterface_READ_CELLS_WRITE_CELLS_T_PI.
      
      Module Impl_core_convert_From_openvm_circuit_arch_integration_api_AdapterAirContext_T_openvm_circuit_arch_integration_api_FlatInterface_READ_CELLS_WRITE_CELLS_T_PI_for_openvm_circuit_arch_integration_api_AdapterAirContext_T_openvm_circuit_arch_integration_api_BasicAdapterInterface_NUM_READS_NUM_WRITES_READ_SIZE_WRITE_SIZE_T_PI.
        Definition Self
            (NUM_READS NUM_WRITES READ_SIZE WRITE_SIZE READ_CELLS WRITE_CELLS : Value.t)
            (T PI : Ty.t)
            : Ty.t :=
          Ty.apply
            (Ty.path "openvm_circuit::arch::integration_api::AdapterAirContext")
            []
            [
              T;
              Ty.apply
                (Ty.path "openvm_circuit::arch::integration_api::BasicAdapterInterface")
                [ NUM_READS; NUM_WRITES; READ_SIZE; WRITE_SIZE ]
                [ T; PI ]
            ].
        
        (*
                fn from(
                    AdapterAirContext {
                        to_pc,
                        reads,
                        writes,
                        instruction,
                    }: AdapterAirContext<T, FlatInterface<T, PI, READ_CELLS, WRITE_CELLS>>,
                ) -> AdapterAirContext<
                    T,
                    BasicAdapterInterface<T, PI, NUM_READS, NUM_WRITES, READ_SIZE, WRITE_SIZE>,
                > {
                    assert_eq!(READ_CELLS, NUM_READS * READ_SIZE);
                    assert_eq!(WRITE_CELLS, NUM_WRITES * WRITE_SIZE);
                    let mut reads_it = reads.into_iter();
                    let reads: [[T; READ_SIZE]; NUM_READS] =
                        from_fn(|_| from_fn(|_| reads_it.next().unwrap()));
                    let mut writes_it = writes.into_iter();
                    let writes: [[T; WRITE_SIZE]; NUM_WRITES] =
                        from_fn(|_| from_fn(|_| writes_it.next().unwrap()));
                    AdapterAirContext {
                        to_pc,
                        reads,
                        writes,
                        instruction,
                    }
                }
        *)
        Definition from
            (NUM_READS NUM_WRITES READ_SIZE WRITE_SIZE READ_CELLS WRITE_CELLS : Value.t)
            (T PI : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t :=
            Self NUM_READS NUM_WRITES READ_SIZE WRITE_SIZE READ_CELLS WRITE_CELLS T PI in
          match ε, τ, α with
          | [], [], [ β0 ] =>
            ltac:(M.monadic
              (let β0 :=
                M.alloc (|
                  Ty.apply
                    (Ty.path "openvm_circuit::arch::integration_api::AdapterAirContext")
                    []
                    [
                      T;
                      Ty.apply
                        (Ty.path "openvm_circuit::arch::integration_api::FlatInterface")
                        [ READ_CELLS; WRITE_CELLS ]
                        [ T; PI ]
                    ],
                  β0
                |) in
              M.match_operator (|
                Ty.apply
                  (Ty.path "openvm_circuit::arch::integration_api::AdapterAirContext")
                  []
                  [
                    T;
                    Ty.apply
                      (Ty.path "openvm_circuit::arch::integration_api::BasicAdapterInterface")
                      [ NUM_READS; NUM_WRITES; READ_SIZE; WRITE_SIZE ]
                      [ T; PI ]
                  ],
                β0,
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 :=
                        M.SubPointer.get_struct_record_field (|
                          γ,
                          "openvm_circuit::arch::integration_api::AdapterAirContext",
                          "to_pc"
                        |) in
                      let γ0_1 :=
                        M.SubPointer.get_struct_record_field (|
                          γ,
                          "openvm_circuit::arch::integration_api::AdapterAirContext",
                          "reads"
                        |) in
                      let γ0_2 :=
                        M.SubPointer.get_struct_record_field (|
                          γ,
                          "openvm_circuit::arch::integration_api::AdapterAirContext",
                          "writes"
                        |) in
                      let γ0_3 :=
                        M.SubPointer.get_struct_record_field (|
                          γ,
                          "openvm_circuit::arch::integration_api::AdapterAirContext",
                          "instruction"
                        |) in
                      let to_pc :=
                        M.copy (|
                          Ty.path
                            "Type for variables in patterns in function parameters is not handled",
                          γ0_0
                        |) in
                      let reads :=
                        M.copy (|
                          Ty.path
                            "Type for variables in patterns in function parameters is not handled",
                          γ0_1
                        |) in
                      let writes :=
                        M.copy (|
                          Ty.path
                            "Type for variables in patterns in function parameters is not handled",
                          γ0_2
                        |) in
                      let instruction :=
                        M.copy (|
                          Ty.path
                            "Type for variables in patterns in function parameters is not handled",
                          γ0_3
                        |) in
                      M.read (|
                        let~ _ : Ty.tuple [] :=
                          M.match_operator (|
                            Ty.tuple [],
                            M.alloc (|
                              Ty.tuple
                                [
                                  Ty.apply (Ty.path "&") [] [ Ty.path "usize" ];
                                  Ty.apply (Ty.path "&") [] [ Ty.path "usize" ]
                                ],
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (| Ty.path "usize", READ_CELLS |)
                                  |);
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Ty.path "usize",
                                      M.call_closure (|
                                        Ty.path "usize",
                                        BinOp.Wrap.mul,
                                        [ NUM_READS; READ_SIZE ]
                                      |)
                                    |)
                                  |)
                                ]
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                  let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                  let left_val :=
                                    M.copy (|
                                      Ty.apply (Ty.path "&") [] [ Ty.path "usize" ],
                                      γ0_0
                                    |) in
                                  let right_val :=
                                    M.copy (|
                                      Ty.apply (Ty.path "&") [] [ Ty.path "usize" ],
                                      γ0_1
                                    |) in
                                  M.match_operator (|
                                    Ty.tuple [],
                                    M.alloc (| Ty.tuple [], Value.Tuple [] |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let γ :=
                                            M.use
                                              (M.alloc (|
                                                Ty.path "bool",
                                                UnOp.not (|
                                                  M.call_closure (|
                                                    Ty.path "bool",
                                                    BinOp.eq,
                                                    [
                                                      M.read (|
                                                        M.deref (| M.read (| left_val |) |)
                                                      |);
                                                      M.read (|
                                                        M.deref (| M.read (| right_val |) |)
                                                      |)
                                                    ]
                                                  |)
                                                |)
                                              |)) in
                                          let _ :=
                                            is_constant_or_break_match (|
                                              M.read (| γ |),
                                              Value.Bool true
                                            |) in
                                          M.never_to_any (|
                                            M.read (|
                                              let~ kind : Ty.path "core::panicking::AssertKind" :=
                                                Value.StructTuple
                                                  "core::panicking::AssertKind::Eq"
                                                  []
                                                  []
                                                  [] in
                                              M.alloc (|
                                                Ty.path "never",
                                                M.call_closure (|
                                                  Ty.path "never",
                                                  M.get_function (|
                                                    "core::panicking::assert_failed",
                                                    [],
                                                    [ Ty.path "usize"; Ty.path "usize" ]
                                                  |),
                                                  [
                                                    M.read (| kind |);
                                                    M.borrow (|
                                                      Pointer.Kind.Ref,
                                                      M.deref (|
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.deref (| M.read (| left_val |) |)
                                                        |)
                                                      |)
                                                    |);
                                                    M.borrow (|
                                                      Pointer.Kind.Ref,
                                                      M.deref (|
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.deref (| M.read (| right_val |) |)
                                                        |)
                                                      |)
                                                    |);
                                                    Value.StructTuple
                                                      "core::option::Option::None"
                                                      []
                                                      [ Ty.path "core::fmt::Arguments" ]
                                                      []
                                                  ]
                                                |)
                                              |)
                                            |)
                                          |)));
                                      fun γ => ltac:(M.monadic (Value.Tuple []))
                                    ]
                                  |)))
                            ]
                          |) in
                        let~ _ : Ty.tuple [] :=
                          M.match_operator (|
                            Ty.tuple [],
                            M.alloc (|
                              Ty.tuple
                                [
                                  Ty.apply (Ty.path "&") [] [ Ty.path "usize" ];
                                  Ty.apply (Ty.path "&") [] [ Ty.path "usize" ]
                                ],
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (| Ty.path "usize", WRITE_CELLS |)
                                  |);
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (|
                                      Ty.path "usize",
                                      M.call_closure (|
                                        Ty.path "usize",
                                        BinOp.Wrap.mul,
                                        [ NUM_WRITES; WRITE_SIZE ]
                                      |)
                                    |)
                                  |)
                                ]
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                  let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                  let left_val :=
                                    M.copy (|
                                      Ty.apply (Ty.path "&") [] [ Ty.path "usize" ],
                                      γ0_0
                                    |) in
                                  let right_val :=
                                    M.copy (|
                                      Ty.apply (Ty.path "&") [] [ Ty.path "usize" ],
                                      γ0_1
                                    |) in
                                  M.match_operator (|
                                    Ty.tuple [],
                                    M.alloc (| Ty.tuple [], Value.Tuple [] |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let γ :=
                                            M.use
                                              (M.alloc (|
                                                Ty.path "bool",
                                                UnOp.not (|
                                                  M.call_closure (|
                                                    Ty.path "bool",
                                                    BinOp.eq,
                                                    [
                                                      M.read (|
                                                        M.deref (| M.read (| left_val |) |)
                                                      |);
                                                      M.read (|
                                                        M.deref (| M.read (| right_val |) |)
                                                      |)
                                                    ]
                                                  |)
                                                |)
                                              |)) in
                                          let _ :=
                                            is_constant_or_break_match (|
                                              M.read (| γ |),
                                              Value.Bool true
                                            |) in
                                          M.never_to_any (|
                                            M.read (|
                                              let~ kind : Ty.path "core::panicking::AssertKind" :=
                                                Value.StructTuple
                                                  "core::panicking::AssertKind::Eq"
                                                  []
                                                  []
                                                  [] in
                                              M.alloc (|
                                                Ty.path "never",
                                                M.call_closure (|
                                                  Ty.path "never",
                                                  M.get_function (|
                                                    "core::panicking::assert_failed",
                                                    [],
                                                    [ Ty.path "usize"; Ty.path "usize" ]
                                                  |),
                                                  [
                                                    M.read (| kind |);
                                                    M.borrow (|
                                                      Pointer.Kind.Ref,
                                                      M.deref (|
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.deref (| M.read (| left_val |) |)
                                                        |)
                                                      |)
                                                    |);
                                                    M.borrow (|
                                                      Pointer.Kind.Ref,
                                                      M.deref (|
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.deref (| M.read (| right_val |) |)
                                                        |)
                                                      |)
                                                    |);
                                                    Value.StructTuple
                                                      "core::option::Option::None"
                                                      []
                                                      [ Ty.path "core::fmt::Arguments" ]
                                                      []
                                                  ]
                                                |)
                                              |)
                                            |)
                                          |)));
                                      fun γ => ltac:(M.monadic (Value.Tuple []))
                                    ]
                                  |)))
                            ]
                          |) in
                        let~ reads_it :
                            Ty.apply (Ty.path "core::array::iter::IntoIter") [ READ_CELLS ] [ T ] :=
                          M.call_closure (|
                            Ty.apply (Ty.path "core::array::iter::IntoIter") [ READ_CELLS ] [ T ],
                            M.get_trait_method (|
                              "core::iter::traits::collect::IntoIterator",
                              Ty.apply (Ty.path "array") [ READ_CELLS ] [ T ],
                              [],
                              [],
                              "into_iter",
                              [],
                              []
                            |),
                            [ M.read (| reads |) ]
                          |) in
                        let~ reads :
                            Ty.apply
                              (Ty.path "array")
                              [ NUM_READS ]
                              [ Ty.apply (Ty.path "array") [ READ_SIZE ] [ T ] ] :=
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "array")
                              [ NUM_READS ]
                              [ Ty.apply (Ty.path "array") [ READ_SIZE ] [ T ] ],
                            M.get_function (|
                              "core::array::from_fn",
                              [ NUM_READS ],
                              [
                                Ty.apply (Ty.path "array") [ READ_SIZE ] [ T ];
                                Ty.function
                                  [ Ty.path "usize" ]
                                  (Ty.apply (Ty.path "array") [ READ_SIZE ] [ T ])
                              ]
                            |),
                            [
                              M.closure
                                (fun γ =>
                                  ltac:(M.monadic
                                    match γ with
                                    | [ α0 ] =>
                                      ltac:(M.monadic
                                        (M.match_operator (|
                                          Ty.apply (Ty.path "array") [ READ_SIZE ] [ T ],
                                          M.alloc (| Ty.path "usize", α0 |),
                                          [
                                            fun γ =>
                                              ltac:(M.monadic
                                                (M.call_closure (|
                                                  Ty.apply (Ty.path "array") [ READ_SIZE ] [ T ],
                                                  M.get_function (|
                                                    "core::array::from_fn",
                                                    [ READ_SIZE ],
                                                    [ T; Ty.function [ Ty.path "usize" ] T ]
                                                  |),
                                                  [
                                                    M.closure
                                                      (fun γ =>
                                                        ltac:(M.monadic
                                                          match γ with
                                                          | [ α0 ] =>
                                                            ltac:(M.monadic
                                                              (M.match_operator (|
                                                                T,
                                                                M.alloc (| Ty.path "usize", α0 |),
                                                                [
                                                                  fun γ =>
                                                                    ltac:(M.monadic
                                                                      (M.call_closure (|
                                                                        T,
                                                                        M.get_associated_function (|
                                                                          Ty.apply
                                                                            (Ty.path
                                                                              "core::option::Option")
                                                                            []
                                                                            [ T ],
                                                                          "unwrap",
                                                                          [],
                                                                          []
                                                                        |),
                                                                        [
                                                                          M.call_closure (|
                                                                            Ty.apply
                                                                              (Ty.path
                                                                                "core::option::Option")
                                                                              []
                                                                              [ T ],
                                                                            M.get_trait_method (|
                                                                              "core::iter::traits::iterator::Iterator",
                                                                              Ty.apply
                                                                                (Ty.path
                                                                                  "core::array::iter::IntoIter")
                                                                                [ READ_CELLS ]
                                                                                [ T ],
                                                                              [],
                                                                              [],
                                                                              "next",
                                                                              [],
                                                                              []
                                                                            |),
                                                                            [
                                                                              M.borrow (|
                                                                                Pointer.Kind.MutRef,
                                                                                reads_it
                                                                              |)
                                                                            ]
                                                                          |)
                                                                        ]
                                                                      |)))
                                                                ]
                                                              |)))
                                                          | _ =>
                                                            M.impossible "wrong number of arguments"
                                                          end))
                                                  ]
                                                |)))
                                          ]
                                        |)))
                                    | _ => M.impossible "wrong number of arguments"
                                    end))
                            ]
                          |) in
                        let~ writes_it :
                            Ty.apply
                              (Ty.path "core::array::iter::IntoIter")
                              [ WRITE_CELLS ]
                              [ T ] :=
                          M.call_closure (|
                            Ty.apply (Ty.path "core::array::iter::IntoIter") [ WRITE_CELLS ] [ T ],
                            M.get_trait_method (|
                              "core::iter::traits::collect::IntoIterator",
                              Ty.apply (Ty.path "array") [ WRITE_CELLS ] [ T ],
                              [],
                              [],
                              "into_iter",
                              [],
                              []
                            |),
                            [ M.read (| writes |) ]
                          |) in
                        let~ writes :
                            Ty.apply
                              (Ty.path "array")
                              [ NUM_WRITES ]
                              [ Ty.apply (Ty.path "array") [ WRITE_SIZE ] [ T ] ] :=
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "array")
                              [ NUM_WRITES ]
                              [ Ty.apply (Ty.path "array") [ WRITE_SIZE ] [ T ] ],
                            M.get_function (|
                              "core::array::from_fn",
                              [ NUM_WRITES ],
                              [
                                Ty.apply (Ty.path "array") [ WRITE_SIZE ] [ T ];
                                Ty.function
                                  [ Ty.path "usize" ]
                                  (Ty.apply (Ty.path "array") [ WRITE_SIZE ] [ T ])
                              ]
                            |),
                            [
                              M.closure
                                (fun γ =>
                                  ltac:(M.monadic
                                    match γ with
                                    | [ α0 ] =>
                                      ltac:(M.monadic
                                        (M.match_operator (|
                                          Ty.apply (Ty.path "array") [ WRITE_SIZE ] [ T ],
                                          M.alloc (| Ty.path "usize", α0 |),
                                          [
                                            fun γ =>
                                              ltac:(M.monadic
                                                (M.call_closure (|
                                                  Ty.apply (Ty.path "array") [ WRITE_SIZE ] [ T ],
                                                  M.get_function (|
                                                    "core::array::from_fn",
                                                    [ WRITE_SIZE ],
                                                    [ T; Ty.function [ Ty.path "usize" ] T ]
                                                  |),
                                                  [
                                                    M.closure
                                                      (fun γ =>
                                                        ltac:(M.monadic
                                                          match γ with
                                                          | [ α0 ] =>
                                                            ltac:(M.monadic
                                                              (M.match_operator (|
                                                                T,
                                                                M.alloc (| Ty.path "usize", α0 |),
                                                                [
                                                                  fun γ =>
                                                                    ltac:(M.monadic
                                                                      (M.call_closure (|
                                                                        T,
                                                                        M.get_associated_function (|
                                                                          Ty.apply
                                                                            (Ty.path
                                                                              "core::option::Option")
                                                                            []
                                                                            [ T ],
                                                                          "unwrap",
                                                                          [],
                                                                          []
                                                                        |),
                                                                        [
                                                                          M.call_closure (|
                                                                            Ty.apply
                                                                              (Ty.path
                                                                                "core::option::Option")
                                                                              []
                                                                              [ T ],
                                                                            M.get_trait_method (|
                                                                              "core::iter::traits::iterator::Iterator",
                                                                              Ty.apply
                                                                                (Ty.path
                                                                                  "core::array::iter::IntoIter")
                                                                                [ WRITE_CELLS ]
                                                                                [ T ],
                                                                              [],
                                                                              [],
                                                                              "next",
                                                                              [],
                                                                              []
                                                                            |),
                                                                            [
                                                                              M.borrow (|
                                                                                Pointer.Kind.MutRef,
                                                                                writes_it
                                                                              |)
                                                                            ]
                                                                          |)
                                                                        ]
                                                                      |)))
                                                                ]
                                                              |)))
                                                          | _ =>
                                                            M.impossible "wrong number of arguments"
                                                          end))
                                                  ]
                                                |)))
                                          ]
                                        |)))
                                    | _ => M.impossible "wrong number of arguments"
                                    end))
                            ]
                          |) in
                        M.alloc (|
                          Ty.apply
                            (Ty.path "openvm_circuit::arch::integration_api::AdapterAirContext")
                            []
                            [
                              T;
                              Ty.apply
                                (Ty.path
                                  "openvm_circuit::arch::integration_api::BasicAdapterInterface")
                                [ NUM_READS; NUM_WRITES; READ_SIZE; WRITE_SIZE ]
                                [ T; PI ]
                            ],
                          Value.mkStructRecord
                            "openvm_circuit::arch::integration_api::AdapterAirContext"
                            []
                            [
                              T;
                              Ty.apply
                                (Ty.path
                                  "openvm_circuit::arch::integration_api::BasicAdapterInterface")
                                [ NUM_READS; NUM_WRITES; READ_SIZE; WRITE_SIZE ]
                                [ T; PI ]
                            ]
                            [
                              ("to_pc", M.read (| to_pc |));
                              ("reads", M.read (| reads |));
                              ("writes", M.read (| writes |));
                              ("instruction", M.read (| instruction |))
                            ]
                        |)
                      |)))
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          forall
            (NUM_READS NUM_WRITES READ_SIZE WRITE_SIZE READ_CELLS WRITE_CELLS : Value.t)
            (T PI : Ty.t),
          M.IsTraitInstance
            "core::convert::From"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *)
            [
              Ty.apply
                (Ty.path "openvm_circuit::arch::integration_api::AdapterAirContext")
                []
                [
                  T;
                  Ty.apply
                    (Ty.path "openvm_circuit::arch::integration_api::FlatInterface")
                    [ READ_CELLS; WRITE_CELLS ]
                    [ T; PI ]
                ]
            ]
            (Self NUM_READS NUM_WRITES READ_SIZE WRITE_SIZE READ_CELLS WRITE_CELLS T PI)
            (* Instance *)
            [
              ("from",
                InstanceField.Method
                  (from NUM_READS NUM_WRITES READ_SIZE WRITE_SIZE READ_CELLS WRITE_CELLS T PI))
            ].
      End Impl_core_convert_From_openvm_circuit_arch_integration_api_AdapterAirContext_T_openvm_circuit_arch_integration_api_FlatInterface_READ_CELLS_WRITE_CELLS_T_PI_for_openvm_circuit_arch_integration_api_AdapterAirContext_T_openvm_circuit_arch_integration_api_BasicAdapterInterface_NUM_READS_NUM_WRITES_READ_SIZE_WRITE_SIZE_T_PI.
      
      Module Impl_core_convert_From_openvm_circuit_arch_integration_api_AdapterRuntimeContext_T_openvm_circuit_arch_integration_api_BasicAdapterInterface_NUM_READS_NUM_WRITES_READ_SIZE_WRITE_SIZE_T_PI_for_openvm_circuit_arch_integration_api_AdapterRuntimeContext_T_openvm_circuit_arch_integration_api_FlatInterface_READ_CELLS_WRITE_CELLS_T_PI.
        Definition Self
            (NUM_READS NUM_WRITES READ_SIZE WRITE_SIZE READ_CELLS WRITE_CELLS : Value.t)
            (T PI : Ty.t)
            : Ty.t :=
          Ty.apply
            (Ty.path "openvm_circuit::arch::integration_api::AdapterRuntimeContext")
            []
            [
              T;
              Ty.apply
                (Ty.path "openvm_circuit::arch::integration_api::FlatInterface")
                [ READ_CELLS; WRITE_CELLS ]
                [ T; PI ]
            ].
        
        (*
                fn from(
                    ctx: AdapterRuntimeContext<
                        T,
                        BasicAdapterInterface<T, PI, NUM_READS, NUM_WRITES, READ_SIZE, WRITE_SIZE>,
                    >,
                ) -> AdapterRuntimeContext<T, FlatInterface<T, PI, READ_CELLS, WRITE_CELLS>> {
                    assert_eq!(WRITE_CELLS, NUM_WRITES * WRITE_SIZE);
                    let mut writes_it = ctx.writes.into_iter().flatten();
                    let writes = from_fn(|_| writes_it.next().unwrap());
                    AdapterRuntimeContext {
                        to_pc: ctx.to_pc,
                        writes,
                    }
                }
        *)
        Definition from
            (NUM_READS NUM_WRITES READ_SIZE WRITE_SIZE READ_CELLS WRITE_CELLS : Value.t)
            (T PI : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t :=
            Self NUM_READS NUM_WRITES READ_SIZE WRITE_SIZE READ_CELLS WRITE_CELLS T PI in
          match ε, τ, α with
          | [], [], [ ctx ] =>
            ltac:(M.monadic
              (let ctx :=
                M.alloc (|
                  Ty.apply
                    (Ty.path "openvm_circuit::arch::integration_api::AdapterRuntimeContext")
                    []
                    [
                      T;
                      Ty.apply
                        (Ty.path "openvm_circuit::arch::integration_api::BasicAdapterInterface")
                        [ NUM_READS; NUM_WRITES; READ_SIZE; WRITE_SIZE ]
                        [ T; PI ]
                    ],
                  ctx
                |) in
              M.read (|
                let~ _ : Ty.tuple [] :=
                  M.match_operator (|
                    Ty.tuple [],
                    M.alloc (|
                      Ty.tuple
                        [
                          Ty.apply (Ty.path "&") [] [ Ty.path "usize" ];
                          Ty.apply (Ty.path "&") [] [ Ty.path "usize" ]
                        ],
                      Value.Tuple
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.alloc (| Ty.path "usize", WRITE_CELLS |)
                          |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.alloc (|
                              Ty.path "usize",
                              M.call_closure (|
                                Ty.path "usize",
                                BinOp.Wrap.mul,
                                [ NUM_WRITES; WRITE_SIZE ]
                              |)
                            |)
                          |)
                        ]
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                          let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                          let left_val :=
                            M.copy (| Ty.apply (Ty.path "&") [] [ Ty.path "usize" ], γ0_0 |) in
                          let right_val :=
                            M.copy (| Ty.apply (Ty.path "&") [] [ Ty.path "usize" ], γ0_1 |) in
                          M.match_operator (|
                            Ty.tuple [],
                            M.alloc (| Ty.tuple [], Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ :=
                                    M.use
                                      (M.alloc (|
                                        Ty.path "bool",
                                        UnOp.not (|
                                          M.call_closure (|
                                            Ty.path "bool",
                                            BinOp.eq,
                                            [
                                              M.read (| M.deref (| M.read (| left_val |) |) |);
                                              M.read (| M.deref (| M.read (| right_val |) |) |)
                                            ]
                                          |)
                                        |)
                                      |)) in
                                  let _ :=
                                    is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  M.never_to_any (|
                                    M.read (|
                                      let~ kind : Ty.path "core::panicking::AssertKind" :=
                                        Value.StructTuple
                                          "core::panicking::AssertKind::Eq"
                                          []
                                          []
                                          [] in
                                      M.alloc (|
                                        Ty.path "never",
                                        M.call_closure (|
                                          Ty.path "never",
                                          M.get_function (|
                                            "core::panicking::assert_failed",
                                            [],
                                            [ Ty.path "usize"; Ty.path "usize" ]
                                          |),
                                          [
                                            M.read (| kind |);
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (| M.read (| left_val |) |)
                                                |)
                                              |)
                                            |);
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (| M.read (| right_val |) |)
                                                |)
                                              |)
                                            |);
                                            Value.StructTuple
                                              "core::option::Option::None"
                                              []
                                              [ Ty.path "core::fmt::Arguments" ]
                                              []
                                          ]
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ => ltac:(M.monadic (Value.Tuple []))
                            ]
                          |)))
                    ]
                  |) in
                let~ writes_it :
                    Ty.apply
                      (Ty.path "core::iter::adapters::flatten::Flatten")
                      []
                      [
                        Ty.apply
                          (Ty.path "core::array::iter::IntoIter")
                          [ NUM_WRITES ]
                          [ Ty.apply (Ty.path "array") [ WRITE_SIZE ] [ T ] ]
                      ] :=
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::iter::adapters::flatten::Flatten")
                      []
                      [
                        Ty.apply
                          (Ty.path "core::array::iter::IntoIter")
                          [ NUM_WRITES ]
                          [ Ty.apply (Ty.path "array") [ WRITE_SIZE ] [ T ] ]
                      ],
                    M.get_trait_method (|
                      "core::iter::traits::iterator::Iterator",
                      Ty.apply
                        (Ty.path "core::array::iter::IntoIter")
                        [ NUM_WRITES ]
                        [ Ty.apply (Ty.path "array") [ WRITE_SIZE ] [ T ] ],
                      [],
                      [],
                      "flatten",
                      [],
                      []
                    |),
                    [
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::array::iter::IntoIter")
                          [ NUM_WRITES ]
                          [ Ty.apply (Ty.path "array") [ WRITE_SIZE ] [ T ] ],
                        M.get_trait_method (|
                          "core::iter::traits::collect::IntoIterator",
                          Ty.apply
                            (Ty.path "array")
                            [ NUM_WRITES ]
                            [ Ty.apply (Ty.path "array") [ WRITE_SIZE ] [ T ] ],
                          [],
                          [],
                          "into_iter",
                          [],
                          []
                        |),
                        [
                          M.read (|
                            M.SubPointer.get_struct_record_field (|
                              ctx,
                              "openvm_circuit::arch::integration_api::AdapterRuntimeContext",
                              "writes"
                            |)
                          |)
                        ]
                      |)
                    ]
                  |) in
                let~ writes : Ty.apply (Ty.path "array") [ WRITE_CELLS ] [ T ] :=
                  M.call_closure (|
                    Ty.apply (Ty.path "array") [ WRITE_CELLS ] [ T ],
                    M.get_function (|
                      "core::array::from_fn",
                      [ WRITE_CELLS ],
                      [ T; Ty.function [ Ty.path "usize" ] T ]
                    |),
                    [
                      M.closure
                        (fun γ =>
                          ltac:(M.monadic
                            match γ with
                            | [ α0 ] =>
                              ltac:(M.monadic
                                (M.match_operator (|
                                  T,
                                  M.alloc (| Ty.path "usize", α0 |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (M.call_closure (|
                                          T,
                                          M.get_associated_function (|
                                            Ty.apply (Ty.path "core::option::Option") [] [ T ],
                                            "unwrap",
                                            [],
                                            []
                                          |),
                                          [
                                            M.call_closure (|
                                              Ty.apply (Ty.path "core::option::Option") [] [ T ],
                                              M.get_trait_method (|
                                                "core::iter::traits::iterator::Iterator",
                                                Ty.apply
                                                  (Ty.path "core::iter::adapters::flatten::Flatten")
                                                  []
                                                  [
                                                    Ty.apply
                                                      (Ty.path "core::array::iter::IntoIter")
                                                      [ NUM_WRITES ]
                                                      [
                                                        Ty.apply
                                                          (Ty.path "array")
                                                          [ WRITE_SIZE ]
                                                          [ T ]
                                                      ]
                                                  ],
                                                [],
                                                [],
                                                "next",
                                                [],
                                                []
                                              |),
                                              [ M.borrow (| Pointer.Kind.MutRef, writes_it |) ]
                                            |)
                                          ]
                                        |)))
                                  ]
                                |)))
                            | _ => M.impossible "wrong number of arguments"
                            end))
                    ]
                  |) in
                M.alloc (|
                  Ty.apply
                    (Ty.path "openvm_circuit::arch::integration_api::AdapterRuntimeContext")
                    []
                    [
                      T;
                      Ty.apply
                        (Ty.path "openvm_circuit::arch::integration_api::FlatInterface")
                        [ READ_CELLS; WRITE_CELLS ]
                        [ T; PI ]
                    ],
                  Value.mkStructRecord
                    "openvm_circuit::arch::integration_api::AdapterRuntimeContext"
                    []
                    [
                      T;
                      Ty.apply
                        (Ty.path "openvm_circuit::arch::integration_api::FlatInterface")
                        [ READ_CELLS; WRITE_CELLS ]
                        [ T; PI ]
                    ]
                    [
                      ("to_pc",
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            ctx,
                            "openvm_circuit::arch::integration_api::AdapterRuntimeContext",
                            "to_pc"
                          |)
                        |));
                      ("writes", M.read (| writes |))
                    ]
                |)
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          forall
            (NUM_READS NUM_WRITES READ_SIZE WRITE_SIZE READ_CELLS WRITE_CELLS : Value.t)
            (T PI : Ty.t),
          M.IsTraitInstance
            "core::convert::From"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *)
            [
              Ty.apply
                (Ty.path "openvm_circuit::arch::integration_api::AdapterRuntimeContext")
                []
                [
                  T;
                  Ty.apply
                    (Ty.path "openvm_circuit::arch::integration_api::BasicAdapterInterface")
                    [ NUM_READS; NUM_WRITES; READ_SIZE; WRITE_SIZE ]
                    [ T; PI ]
                ]
            ]
            (Self NUM_READS NUM_WRITES READ_SIZE WRITE_SIZE READ_CELLS WRITE_CELLS T PI)
            (* Instance *)
            [
              ("from",
                InstanceField.Method
                  (from NUM_READS NUM_WRITES READ_SIZE WRITE_SIZE READ_CELLS WRITE_CELLS T PI))
            ].
      End Impl_core_convert_From_openvm_circuit_arch_integration_api_AdapterRuntimeContext_T_openvm_circuit_arch_integration_api_BasicAdapterInterface_NUM_READS_NUM_WRITES_READ_SIZE_WRITE_SIZE_T_PI_for_openvm_circuit_arch_integration_api_AdapterRuntimeContext_T_openvm_circuit_arch_integration_api_FlatInterface_READ_CELLS_WRITE_CELLS_T_PI.
      
      Module Impl_core_convert_From_where_p3_field_field_FieldAlgebra_T_openvm_circuit_arch_integration_api_AdapterRuntimeContext_T_openvm_circuit_arch_integration_api_FlatInterface_READ_CELLS_WRITE_CELLS_T_PI_for_openvm_circuit_arch_integration_api_AdapterRuntimeContext_T_openvm_circuit_arch_integration_api_BasicAdapterInterface_NUM_READS_NUM_WRITES_READ_SIZE_WRITE_SIZE_T_PI.
        Definition Self
            (NUM_READS NUM_WRITES READ_SIZE WRITE_SIZE READ_CELLS WRITE_CELLS : Value.t)
            (T PI : Ty.t)
            : Ty.t :=
          Ty.apply
            (Ty.path "openvm_circuit::arch::integration_api::AdapterRuntimeContext")
            []
            [
              T;
              Ty.apply
                (Ty.path "openvm_circuit::arch::integration_api::BasicAdapterInterface")
                [ NUM_READS; NUM_WRITES; READ_SIZE; WRITE_SIZE ]
                [ T; PI ]
            ].
        
        (*
                fn from(
                    ctx: AdapterRuntimeContext<T, FlatInterface<T, PI, READ_CELLS, WRITE_CELLS>>,
                ) -> AdapterRuntimeContext<
                    T,
                    BasicAdapterInterface<T, PI, NUM_READS, NUM_WRITES, READ_SIZE, WRITE_SIZE>,
                > {
                    assert_eq!(WRITE_CELLS, NUM_WRITES * WRITE_SIZE);
                    let mut writes_it = ctx.writes.into_iter();
                    let writes: [[T; WRITE_SIZE]; NUM_WRITES] =
                        from_fn(|_| from_fn(|_| writes_it.next().unwrap()));
                    AdapterRuntimeContext {
                        to_pc: ctx.to_pc,
                        writes,
                    }
                }
        *)
        Definition from
            (NUM_READS NUM_WRITES READ_SIZE WRITE_SIZE READ_CELLS WRITE_CELLS : Value.t)
            (T PI : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t :=
            Self NUM_READS NUM_WRITES READ_SIZE WRITE_SIZE READ_CELLS WRITE_CELLS T PI in
          match ε, τ, α with
          | [], [], [ ctx ] =>
            ltac:(M.monadic
              (let ctx :=
                M.alloc (|
                  Ty.apply
                    (Ty.path "openvm_circuit::arch::integration_api::AdapterRuntimeContext")
                    []
                    [
                      T;
                      Ty.apply
                        (Ty.path "openvm_circuit::arch::integration_api::FlatInterface")
                        [ READ_CELLS; WRITE_CELLS ]
                        [ T; PI ]
                    ],
                  ctx
                |) in
              M.read (|
                let~ _ : Ty.tuple [] :=
                  M.match_operator (|
                    Ty.tuple [],
                    M.alloc (|
                      Ty.tuple
                        [
                          Ty.apply (Ty.path "&") [] [ Ty.path "usize" ];
                          Ty.apply (Ty.path "&") [] [ Ty.path "usize" ]
                        ],
                      Value.Tuple
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.alloc (| Ty.path "usize", WRITE_CELLS |)
                          |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.alloc (|
                              Ty.path "usize",
                              M.call_closure (|
                                Ty.path "usize",
                                BinOp.Wrap.mul,
                                [ NUM_WRITES; WRITE_SIZE ]
                              |)
                            |)
                          |)
                        ]
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                          let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                          let left_val :=
                            M.copy (| Ty.apply (Ty.path "&") [] [ Ty.path "usize" ], γ0_0 |) in
                          let right_val :=
                            M.copy (| Ty.apply (Ty.path "&") [] [ Ty.path "usize" ], γ0_1 |) in
                          M.match_operator (|
                            Ty.tuple [],
                            M.alloc (| Ty.tuple [], Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ :=
                                    M.use
                                      (M.alloc (|
                                        Ty.path "bool",
                                        UnOp.not (|
                                          M.call_closure (|
                                            Ty.path "bool",
                                            BinOp.eq,
                                            [
                                              M.read (| M.deref (| M.read (| left_val |) |) |);
                                              M.read (| M.deref (| M.read (| right_val |) |) |)
                                            ]
                                          |)
                                        |)
                                      |)) in
                                  let _ :=
                                    is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  M.never_to_any (|
                                    M.read (|
                                      let~ kind : Ty.path "core::panicking::AssertKind" :=
                                        Value.StructTuple
                                          "core::panicking::AssertKind::Eq"
                                          []
                                          []
                                          [] in
                                      M.alloc (|
                                        Ty.path "never",
                                        M.call_closure (|
                                          Ty.path "never",
                                          M.get_function (|
                                            "core::panicking::assert_failed",
                                            [],
                                            [ Ty.path "usize"; Ty.path "usize" ]
                                          |),
                                          [
                                            M.read (| kind |);
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (| M.read (| left_val |) |)
                                                |)
                                              |)
                                            |);
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (| M.read (| right_val |) |)
                                                |)
                                              |)
                                            |);
                                            Value.StructTuple
                                              "core::option::Option::None"
                                              []
                                              [ Ty.path "core::fmt::Arguments" ]
                                              []
                                          ]
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ => ltac:(M.monadic (Value.Tuple []))
                            ]
                          |)))
                    ]
                  |) in
                let~ writes_it :
                    Ty.apply (Ty.path "core::array::iter::IntoIter") [ WRITE_CELLS ] [ T ] :=
                  M.call_closure (|
                    Ty.apply (Ty.path "core::array::iter::IntoIter") [ WRITE_CELLS ] [ T ],
                    M.get_trait_method (|
                      "core::iter::traits::collect::IntoIterator",
                      Ty.apply (Ty.path "array") [ WRITE_CELLS ] [ T ],
                      [],
                      [],
                      "into_iter",
                      [],
                      []
                    |),
                    [
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          ctx,
                          "openvm_circuit::arch::integration_api::AdapterRuntimeContext",
                          "writes"
                        |)
                      |)
                    ]
                  |) in
                let~ writes :
                    Ty.apply
                      (Ty.path "array")
                      [ NUM_WRITES ]
                      [ Ty.apply (Ty.path "array") [ WRITE_SIZE ] [ T ] ] :=
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "array")
                      [ NUM_WRITES ]
                      [ Ty.apply (Ty.path "array") [ WRITE_SIZE ] [ T ] ],
                    M.get_function (|
                      "core::array::from_fn",
                      [ NUM_WRITES ],
                      [
                        Ty.apply (Ty.path "array") [ WRITE_SIZE ] [ T ];
                        Ty.function
                          [ Ty.path "usize" ]
                          (Ty.apply (Ty.path "array") [ WRITE_SIZE ] [ T ])
                      ]
                    |),
                    [
                      M.closure
                        (fun γ =>
                          ltac:(M.monadic
                            match γ with
                            | [ α0 ] =>
                              ltac:(M.monadic
                                (M.match_operator (|
                                  Ty.apply (Ty.path "array") [ WRITE_SIZE ] [ T ],
                                  M.alloc (| Ty.path "usize", α0 |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (M.call_closure (|
                                          Ty.apply (Ty.path "array") [ WRITE_SIZE ] [ T ],
                                          M.get_function (|
                                            "core::array::from_fn",
                                            [ WRITE_SIZE ],
                                            [ T; Ty.function [ Ty.path "usize" ] T ]
                                          |),
                                          [
                                            M.closure
                                              (fun γ =>
                                                ltac:(M.monadic
                                                  match γ with
                                                  | [ α0 ] =>
                                                    ltac:(M.monadic
                                                      (M.match_operator (|
                                                        T,
                                                        M.alloc (| Ty.path "usize", α0 |),
                                                        [
                                                          fun γ =>
                                                            ltac:(M.monadic
                                                              (M.call_closure (|
                                                                T,
                                                                M.get_associated_function (|
                                                                  Ty.apply
                                                                    (Ty.path "core::option::Option")
                                                                    []
                                                                    [ T ],
                                                                  "unwrap",
                                                                  [],
                                                                  []
                                                                |),
                                                                [
                                                                  M.call_closure (|
                                                                    Ty.apply
                                                                      (Ty.path
                                                                        "core::option::Option")
                                                                      []
                                                                      [ T ],
                                                                    M.get_trait_method (|
                                                                      "core::iter::traits::iterator::Iterator",
                                                                      Ty.apply
                                                                        (Ty.path
                                                                          "core::array::iter::IntoIter")
                                                                        [ WRITE_CELLS ]
                                                                        [ T ],
                                                                      [],
                                                                      [],
                                                                      "next",
                                                                      [],
                                                                      []
                                                                    |),
                                                                    [
                                                                      M.borrow (|
                                                                        Pointer.Kind.MutRef,
                                                                        writes_it
                                                                      |)
                                                                    ]
                                                                  |)
                                                                ]
                                                              |)))
                                                        ]
                                                      |)))
                                                  | _ => M.impossible "wrong number of arguments"
                                                  end))
                                          ]
                                        |)))
                                  ]
                                |)))
                            | _ => M.impossible "wrong number of arguments"
                            end))
                    ]
                  |) in
                M.alloc (|
                  Ty.apply
                    (Ty.path "openvm_circuit::arch::integration_api::AdapterRuntimeContext")
                    []
                    [
                      T;
                      Ty.apply
                        (Ty.path "openvm_circuit::arch::integration_api::BasicAdapterInterface")
                        [ NUM_READS; NUM_WRITES; READ_SIZE; WRITE_SIZE ]
                        [ T; PI ]
                    ],
                  Value.mkStructRecord
                    "openvm_circuit::arch::integration_api::AdapterRuntimeContext"
                    []
                    [
                      T;
                      Ty.apply
                        (Ty.path "openvm_circuit::arch::integration_api::BasicAdapterInterface")
                        [ NUM_READS; NUM_WRITES; READ_SIZE; WRITE_SIZE ]
                        [ T; PI ]
                    ]
                    [
                      ("to_pc",
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            ctx,
                            "openvm_circuit::arch::integration_api::AdapterRuntimeContext",
                            "to_pc"
                          |)
                        |));
                      ("writes", M.read (| writes |))
                    ]
                |)
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          forall
            (NUM_READS NUM_WRITES READ_SIZE WRITE_SIZE READ_CELLS WRITE_CELLS : Value.t)
            (T PI : Ty.t),
          M.IsTraitInstance
            "core::convert::From"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *)
            [
              Ty.apply
                (Ty.path "openvm_circuit::arch::integration_api::AdapterRuntimeContext")
                []
                [
                  T;
                  Ty.apply
                    (Ty.path "openvm_circuit::arch::integration_api::FlatInterface")
                    [ READ_CELLS; WRITE_CELLS ]
                    [ T; PI ]
                ]
            ]
            (Self NUM_READS NUM_WRITES READ_SIZE WRITE_SIZE READ_CELLS WRITE_CELLS T PI)
            (* Instance *)
            [
              ("from",
                InstanceField.Method
                  (from NUM_READS NUM_WRITES READ_SIZE WRITE_SIZE READ_CELLS WRITE_CELLS T PI))
            ].
      End Impl_core_convert_From_where_p3_field_field_FieldAlgebra_T_openvm_circuit_arch_integration_api_AdapterRuntimeContext_T_openvm_circuit_arch_integration_api_FlatInterface_READ_CELLS_WRITE_CELLS_T_PI_for_openvm_circuit_arch_integration_api_AdapterRuntimeContext_T_openvm_circuit_arch_integration_api_BasicAdapterInterface_NUM_READS_NUM_WRITES_READ_SIZE_WRITE_SIZE_T_PI.
      
      Module Impl_core_convert_From_alloc_vec_Vec_T_alloc_alloc_Global_for_openvm_circuit_arch_integration_api_DynArray_T.
        Definition Self (T : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "openvm_circuit::arch::integration_api::DynArray") [] [ T ].
        
        (*
                fn from(v: Vec<T>) -> Self {
                    Self(v)
                }
        *)
        Definition from (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T in
          match ε, τ, α with
          | [], [], [ v ] =>
            ltac:(M.monadic
              (let v :=
                M.alloc (|
                  Ty.apply (Ty.path "alloc::vec::Vec") [] [ T; Ty.path "alloc::alloc::Global" ],
                  v
                |) in
              Value.StructTuple
                "openvm_circuit::arch::integration_api::DynArray"
                []
                [ T ]
                [ M.read (| v |) ]))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          forall (T : Ty.t),
          M.IsTraitInstance
            "core::convert::From"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *)
            [ Ty.apply (Ty.path "alloc::vec::Vec") [] [ T; Ty.path "alloc::alloc::Global" ] ]
            (Self T)
            (* Instance *) [ ("from", InstanceField.Method (from T)) ].
      End Impl_core_convert_From_alloc_vec_Vec_T_alloc_alloc_Global_for_openvm_circuit_arch_integration_api_DynArray_T.
      
      Module Impl_core_convert_From_openvm_circuit_arch_integration_api_DynArray_T_for_alloc_vec_Vec_T_alloc_alloc_Global.
        Definition Self (T : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "alloc::vec::Vec") [] [ T; Ty.path "alloc::alloc::Global" ].
        
        (*
                fn from(v: DynArray<T>) -> Vec<T> {
                    v.0
                }
        *)
        Definition from (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T in
          match ε, τ, α with
          | [], [], [ v ] =>
            ltac:(M.monadic
              (let v :=
                M.alloc (|
                  Ty.apply (Ty.path "openvm_circuit::arch::integration_api::DynArray") [] [ T ],
                  v
                |) in
              M.read (|
                M.SubPointer.get_struct_tuple_field (|
                  v,
                  "openvm_circuit::arch::integration_api::DynArray",
                  0
                |)
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          forall (T : Ty.t),
          M.IsTraitInstance
            "core::convert::From"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *)
            [ Ty.apply (Ty.path "openvm_circuit::arch::integration_api::DynArray") [] [ T ] ]
            (Self T)
            (* Instance *) [ ("from", InstanceField.Method (from T)) ].
      End Impl_core_convert_From_openvm_circuit_arch_integration_api_DynArray_T_for_alloc_vec_Vec_T_alloc_alloc_Global.
      
      Module Impl_core_convert_From_array_M__array_N_T_for_openvm_circuit_arch_integration_api_DynArray_T.
        Definition Self (N M_ : Value.t) (T : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "openvm_circuit::arch::integration_api::DynArray") [] [ T ].
        
        (*
                fn from(v: [[T; N]; M]) -> Self {
                    Self(v.into_iter().flatten().collect())
                }
        *)
        Definition from
            (N M_ : Value.t)
            (T : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self N M_ T in
          match ε, τ, α with
          | [], [], [ v ] =>
            ltac:(M.monadic
              (let v :=
                M.alloc (|
                  Ty.apply (Ty.path "array") [ M_ ] [ Ty.apply (Ty.path "array") [ N ] [ T ] ],
                  v
                |) in
              Value.StructTuple
                "openvm_circuit::arch::integration_api::DynArray"
                []
                [ T ]
                [
                  M.call_closure (|
                    Ty.apply (Ty.path "alloc::vec::Vec") [] [ T; Ty.path "alloc::alloc::Global" ],
                    M.get_trait_method (|
                      "core::iter::traits::iterator::Iterator",
                      Ty.apply
                        (Ty.path "core::iter::adapters::flatten::Flatten")
                        []
                        [
                          Ty.apply
                            (Ty.path "core::array::iter::IntoIter")
                            [ M_ ]
                            [ Ty.apply (Ty.path "array") [ N ] [ T ] ]
                        ],
                      [],
                      [],
                      "collect",
                      [],
                      [
                        Ty.apply
                          (Ty.path "alloc::vec::Vec")
                          []
                          [ T; Ty.path "alloc::alloc::Global" ]
                      ]
                    |),
                    [
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::iter::adapters::flatten::Flatten")
                          []
                          [
                            Ty.apply
                              (Ty.path "core::array::iter::IntoIter")
                              [ M_ ]
                              [ Ty.apply (Ty.path "array") [ N ] [ T ] ]
                          ],
                        M.get_trait_method (|
                          "core::iter::traits::iterator::Iterator",
                          Ty.apply
                            (Ty.path "core::array::iter::IntoIter")
                            [ M_ ]
                            [ Ty.apply (Ty.path "array") [ N ] [ T ] ],
                          [],
                          [],
                          "flatten",
                          [],
                          []
                        |),
                        [
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "core::array::iter::IntoIter")
                              [ M_ ]
                              [ Ty.apply (Ty.path "array") [ N ] [ T ] ],
                            M.get_trait_method (|
                              "core::iter::traits::collect::IntoIterator",
                              Ty.apply
                                (Ty.path "array")
                                [ M_ ]
                                [ Ty.apply (Ty.path "array") [ N ] [ T ] ],
                              [],
                              [],
                              "into_iter",
                              [],
                              []
                            |),
                            [ M.read (| v |) ]
                          |)
                        ]
                      |)
                    ]
                  |)
                ]))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          forall (N M_ : Value.t) (T : Ty.t),
          M.IsTraitInstance
            "core::convert::From"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *)
            [ Ty.apply (Ty.path "array") [ M_ ] [ Ty.apply (Ty.path "array") [ N ] [ T ] ] ]
            (Self N M_ T)
            (* Instance *) [ ("from", InstanceField.Method (from N M_ T)) ].
      End Impl_core_convert_From_array_M__array_N_T_for_openvm_circuit_arch_integration_api_DynArray_T.
      
      Module Impl_core_convert_From_openvm_circuit_arch_integration_api_DynArray_T_for_array_M__array_N_T.
        Definition Self (N M_ : Value.t) (T : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "array") [ M_ ] [ Ty.apply (Ty.path "array") [ N ] [ T ] ].
        
        (*
                fn from(v: DynArray<T>) -> Self {
                    assert_eq!(v.0.len(), N * M, "Incorrect vector length {}", v.0.len());
                    let mut it = v.0.into_iter();
                    from_fn(|_| from_fn(|_| it.next().unwrap()))
                }
        *)
        Definition from
            (N M_ : Value.t)
            (T : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self N M_ T in
          match ε, τ, α with
          | [], [], [ v ] =>
            ltac:(M.monadic
              (let v :=
                M.alloc (|
                  Ty.apply (Ty.path "openvm_circuit::arch::integration_api::DynArray") [] [ T ],
                  v
                |) in
              M.read (|
                let~ _ : Ty.tuple [] :=
                  M.match_operator (|
                    Ty.tuple [],
                    M.alloc (|
                      Ty.tuple
                        [
                          Ty.apply (Ty.path "&") [] [ Ty.path "usize" ];
                          Ty.apply (Ty.path "&") [] [ Ty.path "usize" ]
                        ],
                      Value.Tuple
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.alloc (|
                              Ty.path "usize",
                              M.call_closure (|
                                Ty.path "usize",
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "alloc::vec::Vec")
                                    []
                                    [ T; Ty.path "alloc::alloc::Global" ],
                                  "len",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.SubPointer.get_struct_tuple_field (|
                                      v,
                                      "openvm_circuit::arch::integration_api::DynArray",
                                      0
                                    |)
                                  |)
                                ]
                              |)
                            |)
                          |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.alloc (|
                              Ty.path "usize",
                              M.call_closure (| Ty.path "usize", BinOp.Wrap.mul, [ N; M_ ] |)
                            |)
                          |)
                        ]
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                          let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                          let left_val :=
                            M.copy (| Ty.apply (Ty.path "&") [] [ Ty.path "usize" ], γ0_0 |) in
                          let right_val :=
                            M.copy (| Ty.apply (Ty.path "&") [] [ Ty.path "usize" ], γ0_1 |) in
                          M.match_operator (|
                            Ty.tuple [],
                            M.alloc (| Ty.tuple [], Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ :=
                                    M.use
                                      (M.alloc (|
                                        Ty.path "bool",
                                        UnOp.not (|
                                          M.call_closure (|
                                            Ty.path "bool",
                                            BinOp.eq,
                                            [
                                              M.read (| M.deref (| M.read (| left_val |) |) |);
                                              M.read (| M.deref (| M.read (| right_val |) |) |)
                                            ]
                                          |)
                                        |)
                                      |)) in
                                  let _ :=
                                    is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  M.never_to_any (|
                                    M.read (|
                                      let~ kind : Ty.path "core::panicking::AssertKind" :=
                                        Value.StructTuple
                                          "core::panicking::AssertKind::Eq"
                                          []
                                          []
                                          [] in
                                      M.alloc (|
                                        Ty.path "never",
                                        M.call_closure (|
                                          Ty.path "never",
                                          M.get_function (|
                                            "core::panicking::assert_failed",
                                            [],
                                            [ Ty.path "usize"; Ty.path "usize" ]
                                          |),
                                          [
                                            M.read (| kind |);
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (| M.read (| left_val |) |)
                                                |)
                                              |)
                                            |);
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (| M.read (| right_val |) |)
                                                |)
                                              |)
                                            |);
                                            Value.StructTuple
                                              "core::option::Option::Some"
                                              []
                                              [ Ty.path "core::fmt::Arguments" ]
                                              [
                                                M.call_closure (|
                                                  Ty.path "core::fmt::Arguments",
                                                  M.get_associated_function (|
                                                    Ty.path "core::fmt::Arguments",
                                                    "new_v1",
                                                    [
                                                      Value.Integer IntegerKind.Usize 1;
                                                      Value.Integer IntegerKind.Usize 1
                                                    ],
                                                    []
                                                  |),
                                                  [
                                                    M.borrow (|
                                                      Pointer.Kind.Ref,
                                                      M.deref (|
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.alloc (|
                                                            Ty.apply
                                                              (Ty.path "array")
                                                              [ Value.Integer IntegerKind.Usize 1 ]
                                                              [
                                                                Ty.apply
                                                                  (Ty.path "&")
                                                                  []
                                                                  [ Ty.path "str" ]
                                                              ],
                                                            Value.Array
                                                              [
                                                                mk_str (|
                                                                  "Incorrect vector length "
                                                                |)
                                                              ]
                                                          |)
                                                        |)
                                                      |)
                                                    |);
                                                    M.borrow (|
                                                      Pointer.Kind.Ref,
                                                      M.deref (|
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.alloc (|
                                                            Ty.apply
                                                              (Ty.path "array")
                                                              [ Value.Integer IntegerKind.Usize 1 ]
                                                              [ Ty.path "core::fmt::rt::Argument" ],
                                                            Value.Array
                                                              [
                                                                M.call_closure (|
                                                                  Ty.path "core::fmt::rt::Argument",
                                                                  M.get_associated_function (|
                                                                    Ty.path
                                                                      "core::fmt::rt::Argument",
                                                                    "new_display",
                                                                    [],
                                                                    [ Ty.path "usize" ]
                                                                  |),
                                                                  [
                                                                    M.borrow (|
                                                                      Pointer.Kind.Ref,
                                                                      M.deref (|
                                                                        M.borrow (|
                                                                          Pointer.Kind.Ref,
                                                                          M.alloc (|
                                                                            Ty.path "usize",
                                                                            M.call_closure (|
                                                                              Ty.path "usize",
                                                                              M.get_associated_function (|
                                                                                Ty.apply
                                                                                  (Ty.path
                                                                                    "alloc::vec::Vec")
                                                                                  []
                                                                                  [
                                                                                    T;
                                                                                    Ty.path
                                                                                      "alloc::alloc::Global"
                                                                                  ],
                                                                                "len",
                                                                                [],
                                                                                []
                                                                              |),
                                                                              [
                                                                                M.borrow (|
                                                                                  Pointer.Kind.Ref,
                                                                                  M.SubPointer.get_struct_tuple_field (|
                                                                                    v,
                                                                                    "openvm_circuit::arch::integration_api::DynArray",
                                                                                    0
                                                                                  |)
                                                                                |)
                                                                              ]
                                                                            |)
                                                                          |)
                                                                        |)
                                                                      |)
                                                                    |)
                                                                  ]
                                                                |)
                                                              ]
                                                          |)
                                                        |)
                                                      |)
                                                    |)
                                                  ]
                                                |)
                                              ]
                                          ]
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ => ltac:(M.monadic (Value.Tuple []))
                            ]
                          |)))
                    ]
                  |) in
                let~ it :
                    Ty.apply
                      (Ty.path "alloc::vec::into_iter::IntoIter")
                      []
                      [ T; Ty.path "alloc::alloc::Global" ] :=
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "alloc::vec::into_iter::IntoIter")
                      []
                      [ T; Ty.path "alloc::alloc::Global" ],
                    M.get_trait_method (|
                      "core::iter::traits::collect::IntoIterator",
                      Ty.apply (Ty.path "alloc::vec::Vec") [] [ T; Ty.path "alloc::alloc::Global" ],
                      [],
                      [],
                      "into_iter",
                      [],
                      []
                    |),
                    [
                      M.read (|
                        M.SubPointer.get_struct_tuple_field (|
                          v,
                          "openvm_circuit::arch::integration_api::DynArray",
                          0
                        |)
                      |)
                    ]
                  |) in
                M.alloc (|
                  Ty.apply (Ty.path "array") [ M_ ] [ Ty.apply (Ty.path "array") [ N ] [ T ] ],
                  M.call_closure (|
                    Ty.apply (Ty.path "array") [ M_ ] [ Ty.apply (Ty.path "array") [ N ] [ T ] ],
                    M.get_function (|
                      "core::array::from_fn",
                      [ M_ ],
                      [
                        Ty.apply (Ty.path "array") [ N ] [ T ];
                        Ty.function [ Ty.path "usize" ] (Ty.apply (Ty.path "array") [ N ] [ T ])
                      ]
                    |),
                    [
                      M.closure
                        (fun γ =>
                          ltac:(M.monadic
                            match γ with
                            | [ α0 ] =>
                              ltac:(M.monadic
                                (M.match_operator (|
                                  Ty.apply (Ty.path "array") [ N ] [ T ],
                                  M.alloc (| Ty.path "usize", α0 |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (M.call_closure (|
                                          Ty.apply (Ty.path "array") [ N ] [ T ],
                                          M.get_function (|
                                            "core::array::from_fn",
                                            [ N ],
                                            [ T; Ty.function [ Ty.path "usize" ] T ]
                                          |),
                                          [
                                            M.closure
                                              (fun γ =>
                                                ltac:(M.monadic
                                                  match γ with
                                                  | [ α0 ] =>
                                                    ltac:(M.monadic
                                                      (M.match_operator (|
                                                        T,
                                                        M.alloc (| Ty.path "usize", α0 |),
                                                        [
                                                          fun γ =>
                                                            ltac:(M.monadic
                                                              (M.call_closure (|
                                                                T,
                                                                M.get_associated_function (|
                                                                  Ty.apply
                                                                    (Ty.path "core::option::Option")
                                                                    []
                                                                    [ T ],
                                                                  "unwrap",
                                                                  [],
                                                                  []
                                                                |),
                                                                [
                                                                  M.call_closure (|
                                                                    Ty.apply
                                                                      (Ty.path
                                                                        "core::option::Option")
                                                                      []
                                                                      [ T ],
                                                                    M.get_trait_method (|
                                                                      "core::iter::traits::iterator::Iterator",
                                                                      Ty.apply
                                                                        (Ty.path
                                                                          "alloc::vec::into_iter::IntoIter")
                                                                        []
                                                                        [
                                                                          T;
                                                                          Ty.path
                                                                            "alloc::alloc::Global"
                                                                        ],
                                                                      [],
                                                                      [],
                                                                      "next",
                                                                      [],
                                                                      []
                                                                    |),
                                                                    [
                                                                      M.borrow (|
                                                                        Pointer.Kind.MutRef,
                                                                        it
                                                                      |)
                                                                    ]
                                                                  |)
                                                                ]
                                                              |)))
                                                        ]
                                                      |)))
                                                  | _ => M.impossible "wrong number of arguments"
                                                  end))
                                          ]
                                        |)))
                                  ]
                                |)))
                            | _ => M.impossible "wrong number of arguments"
                            end))
                    ]
                  |)
                |)
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          forall (N M_ : Value.t) (T : Ty.t),
          M.IsTraitInstance
            "core::convert::From"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *)
            [ Ty.apply (Ty.path "openvm_circuit::arch::integration_api::DynArray") [] [ T ] ]
            (Self N M_ T)
            (* Instance *) [ ("from", InstanceField.Method (from N M_ T)) ].
      End Impl_core_convert_From_openvm_circuit_arch_integration_api_DynArray_T_for_array_M__array_N_T.
      
      Module Impl_core_convert_From_array_R_array_M__array_N_T_for_openvm_circuit_arch_integration_api_DynArray_T.
        Definition Self (N M_ R : Value.t) (T : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "openvm_circuit::arch::integration_api::DynArray") [] [ T ].
        
        (*
                fn from(v: [[[T; N]; M]; R]) -> Self {
                    Self(
                        v.into_iter()
                            .flat_map(|x| x.into_iter().flatten())
                            .collect(),
                    )
                }
        *)
        Definition from
            (N M_ R : Value.t)
            (T : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self N M_ R T in
          match ε, τ, α with
          | [], [], [ v ] =>
            ltac:(M.monadic
              (let v :=
                M.alloc (|
                  Ty.apply
                    (Ty.path "array")
                    [ R ]
                    [ Ty.apply (Ty.path "array") [ M_ ] [ Ty.apply (Ty.path "array") [ N ] [ T ] ]
                    ],
                  v
                |) in
              Value.StructTuple
                "openvm_circuit::arch::integration_api::DynArray"
                []
                [ T ]
                [
                  M.call_closure (|
                    Ty.apply (Ty.path "alloc::vec::Vec") [] [ T; Ty.path "alloc::alloc::Global" ],
                    M.get_trait_method (|
                      "core::iter::traits::iterator::Iterator",
                      Ty.apply
                        (Ty.path "core::iter::adapters::flatten::FlatMap")
                        []
                        [
                          Ty.apply
                            (Ty.path "core::array::iter::IntoIter")
                            [ R ]
                            [
                              Ty.apply
                                (Ty.path "array")
                                [ M_ ]
                                [ Ty.apply (Ty.path "array") [ N ] [ T ] ]
                            ];
                          Ty.apply
                            (Ty.path "core::iter::adapters::flatten::Flatten")
                            []
                            [
                              Ty.apply
                                (Ty.path "core::array::iter::IntoIter")
                                [ M_ ]
                                [ Ty.apply (Ty.path "array") [ N ] [ T ] ]
                            ];
                          Ty.function
                            [
                              Ty.apply
                                (Ty.path "array")
                                [ M_ ]
                                [ Ty.apply (Ty.path "array") [ N ] [ T ] ]
                            ]
                            (Ty.apply
                              (Ty.path "core::iter::adapters::flatten::Flatten")
                              []
                              [
                                Ty.apply
                                  (Ty.path "core::array::iter::IntoIter")
                                  [ M_ ]
                                  [ Ty.apply (Ty.path "array") [ N ] [ T ] ]
                              ])
                        ],
                      [],
                      [],
                      "collect",
                      [],
                      [
                        Ty.apply
                          (Ty.path "alloc::vec::Vec")
                          []
                          [ T; Ty.path "alloc::alloc::Global" ]
                      ]
                    |),
                    [
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::iter::adapters::flatten::FlatMap")
                          []
                          [
                            Ty.apply
                              (Ty.path "core::array::iter::IntoIter")
                              [ R ]
                              [
                                Ty.apply
                                  (Ty.path "array")
                                  [ M_ ]
                                  [ Ty.apply (Ty.path "array") [ N ] [ T ] ]
                              ];
                            Ty.apply
                              (Ty.path "core::iter::adapters::flatten::Flatten")
                              []
                              [
                                Ty.apply
                                  (Ty.path "core::array::iter::IntoIter")
                                  [ M_ ]
                                  [ Ty.apply (Ty.path "array") [ N ] [ T ] ]
                              ];
                            Ty.function
                              [
                                Ty.apply
                                  (Ty.path "array")
                                  [ M_ ]
                                  [ Ty.apply (Ty.path "array") [ N ] [ T ] ]
                              ]
                              (Ty.apply
                                (Ty.path "core::iter::adapters::flatten::Flatten")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "core::array::iter::IntoIter")
                                    [ M_ ]
                                    [ Ty.apply (Ty.path "array") [ N ] [ T ] ]
                                ])
                          ],
                        M.get_trait_method (|
                          "core::iter::traits::iterator::Iterator",
                          Ty.apply
                            (Ty.path "core::array::iter::IntoIter")
                            [ R ]
                            [
                              Ty.apply
                                (Ty.path "array")
                                [ M_ ]
                                [ Ty.apply (Ty.path "array") [ N ] [ T ] ]
                            ],
                          [],
                          [],
                          "flat_map",
                          [],
                          [
                            Ty.apply
                              (Ty.path "core::iter::adapters::flatten::Flatten")
                              []
                              [
                                Ty.apply
                                  (Ty.path "core::array::iter::IntoIter")
                                  [ M_ ]
                                  [ Ty.apply (Ty.path "array") [ N ] [ T ] ]
                              ];
                            Ty.function
                              [
                                Ty.apply
                                  (Ty.path "array")
                                  [ M_ ]
                                  [ Ty.apply (Ty.path "array") [ N ] [ T ] ]
                              ]
                              (Ty.apply
                                (Ty.path "core::iter::adapters::flatten::Flatten")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "core::array::iter::IntoIter")
                                    [ M_ ]
                                    [ Ty.apply (Ty.path "array") [ N ] [ T ] ]
                                ])
                          ]
                        |),
                        [
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "core::array::iter::IntoIter")
                              [ R ]
                              [
                                Ty.apply
                                  (Ty.path "array")
                                  [ M_ ]
                                  [ Ty.apply (Ty.path "array") [ N ] [ T ] ]
                              ],
                            M.get_trait_method (|
                              "core::iter::traits::collect::IntoIterator",
                              Ty.apply
                                (Ty.path "array")
                                [ R ]
                                [
                                  Ty.apply
                                    (Ty.path "array")
                                    [ M_ ]
                                    [ Ty.apply (Ty.path "array") [ N ] [ T ] ]
                                ],
                              [],
                              [],
                              "into_iter",
                              [],
                              []
                            |),
                            [ M.read (| v |) ]
                          |);
                          M.closure
                            (fun γ =>
                              ltac:(M.monadic
                                match γ with
                                | [ α0 ] =>
                                  ltac:(M.monadic
                                    (M.match_operator (|
                                      Ty.apply
                                        (Ty.path "core::iter::adapters::flatten::Flatten")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "core::array::iter::IntoIter")
                                            [ M_ ]
                                            [ Ty.apply (Ty.path "array") [ N ] [ T ] ]
                                        ],
                                      M.alloc (|
                                        Ty.apply
                                          (Ty.path "array")
                                          [ M_ ]
                                          [ Ty.apply (Ty.path "array") [ N ] [ T ] ],
                                        α0
                                      |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let x :=
                                              M.copy (|
                                                Ty.apply
                                                  (Ty.path "array")
                                                  [ M_ ]
                                                  [ Ty.apply (Ty.path "array") [ N ] [ T ] ],
                                                γ
                                              |) in
                                            M.call_closure (|
                                              Ty.apply
                                                (Ty.path "core::iter::adapters::flatten::Flatten")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::array::iter::IntoIter")
                                                    [ M_ ]
                                                    [ Ty.apply (Ty.path "array") [ N ] [ T ] ]
                                                ],
                                              M.get_trait_method (|
                                                "core::iter::traits::iterator::Iterator",
                                                Ty.apply
                                                  (Ty.path "core::array::iter::IntoIter")
                                                  [ M_ ]
                                                  [ Ty.apply (Ty.path "array") [ N ] [ T ] ],
                                                [],
                                                [],
                                                "flatten",
                                                [],
                                                []
                                              |),
                                              [
                                                M.call_closure (|
                                                  Ty.apply
                                                    (Ty.path "core::array::iter::IntoIter")
                                                    [ M_ ]
                                                    [ Ty.apply (Ty.path "array") [ N ] [ T ] ],
                                                  M.get_trait_method (|
                                                    "core::iter::traits::collect::IntoIterator",
                                                    Ty.apply
                                                      (Ty.path "array")
                                                      [ M_ ]
                                                      [ Ty.apply (Ty.path "array") [ N ] [ T ] ],
                                                    [],
                                                    [],
                                                    "into_iter",
                                                    [],
                                                    []
                                                  |),
                                                  [ M.read (| x |) ]
                                                |)
                                              ]
                                            |)))
                                      ]
                                    |)))
                                | _ => M.impossible "wrong number of arguments"
                                end))
                        ]
                      |)
                    ]
                  |)
                ]))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          forall (N M_ R : Value.t) (T : Ty.t),
          M.IsTraitInstance
            "core::convert::From"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *)
            [
              Ty.apply
                (Ty.path "array")
                [ R ]
                [ Ty.apply (Ty.path "array") [ M_ ] [ Ty.apply (Ty.path "array") [ N ] [ T ] ] ]
            ]
            (Self N M_ R T)
            (* Instance *) [ ("from", InstanceField.Method (from N M_ R T)) ].
      End Impl_core_convert_From_array_R_array_M__array_N_T_for_openvm_circuit_arch_integration_api_DynArray_T.
      
      Module Impl_core_convert_From_openvm_circuit_arch_integration_api_DynArray_T_for_array_R_array_M__array_N_T.
        Definition Self (N M_ R : Value.t) (T : Ty.t) : Ty.t :=
          Ty.apply
            (Ty.path "array")
            [ R ]
            [ Ty.apply (Ty.path "array") [ M_ ] [ Ty.apply (Ty.path "array") [ N ] [ T ] ] ].
        
        (*
                fn from(v: DynArray<T>) -> Self {
                    assert_eq!(
                        v.0.len(),
                        N * M * R,
                        "Incorrect vector length {}",
                        v.0.len()
                    );
                    let mut it = v.0.into_iter();
                    from_fn(|_| from_fn(|_| from_fn(|_| it.next().unwrap())))
                }
        *)
        Definition from
            (N M_ R : Value.t)
            (T : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self N M_ R T in
          match ε, τ, α with
          | [], [], [ v ] =>
            ltac:(M.monadic
              (let v :=
                M.alloc (|
                  Ty.apply (Ty.path "openvm_circuit::arch::integration_api::DynArray") [] [ T ],
                  v
                |) in
              M.read (|
                let~ _ : Ty.tuple [] :=
                  M.match_operator (|
                    Ty.tuple [],
                    M.alloc (|
                      Ty.tuple
                        [
                          Ty.apply (Ty.path "&") [] [ Ty.path "usize" ];
                          Ty.apply (Ty.path "&") [] [ Ty.path "usize" ]
                        ],
                      Value.Tuple
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.alloc (|
                              Ty.path "usize",
                              M.call_closure (|
                                Ty.path "usize",
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "alloc::vec::Vec")
                                    []
                                    [ T; Ty.path "alloc::alloc::Global" ],
                                  "len",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.SubPointer.get_struct_tuple_field (|
                                      v,
                                      "openvm_circuit::arch::integration_api::DynArray",
                                      0
                                    |)
                                  |)
                                ]
                              |)
                            |)
                          |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.alloc (|
                              Ty.path "usize",
                              M.call_closure (|
                                Ty.path "usize",
                                BinOp.Wrap.mul,
                                [ M.call_closure (| Ty.path "usize", BinOp.Wrap.mul, [ N; M_ ] |); R
                                ]
                              |)
                            |)
                          |)
                        ]
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                          let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                          let left_val :=
                            M.copy (| Ty.apply (Ty.path "&") [] [ Ty.path "usize" ], γ0_0 |) in
                          let right_val :=
                            M.copy (| Ty.apply (Ty.path "&") [] [ Ty.path "usize" ], γ0_1 |) in
                          M.match_operator (|
                            Ty.tuple [],
                            M.alloc (| Ty.tuple [], Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ :=
                                    M.use
                                      (M.alloc (|
                                        Ty.path "bool",
                                        UnOp.not (|
                                          M.call_closure (|
                                            Ty.path "bool",
                                            BinOp.eq,
                                            [
                                              M.read (| M.deref (| M.read (| left_val |) |) |);
                                              M.read (| M.deref (| M.read (| right_val |) |) |)
                                            ]
                                          |)
                                        |)
                                      |)) in
                                  let _ :=
                                    is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  M.never_to_any (|
                                    M.read (|
                                      let~ kind : Ty.path "core::panicking::AssertKind" :=
                                        Value.StructTuple
                                          "core::panicking::AssertKind::Eq"
                                          []
                                          []
                                          [] in
                                      M.alloc (|
                                        Ty.path "never",
                                        M.call_closure (|
                                          Ty.path "never",
                                          M.get_function (|
                                            "core::panicking::assert_failed",
                                            [],
                                            [ Ty.path "usize"; Ty.path "usize" ]
                                          |),
                                          [
                                            M.read (| kind |);
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (| M.read (| left_val |) |)
                                                |)
                                              |)
                                            |);
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (| M.read (| right_val |) |)
                                                |)
                                              |)
                                            |);
                                            Value.StructTuple
                                              "core::option::Option::Some"
                                              []
                                              [ Ty.path "core::fmt::Arguments" ]
                                              [
                                                M.call_closure (|
                                                  Ty.path "core::fmt::Arguments",
                                                  M.get_associated_function (|
                                                    Ty.path "core::fmt::Arguments",
                                                    "new_v1",
                                                    [
                                                      Value.Integer IntegerKind.Usize 1;
                                                      Value.Integer IntegerKind.Usize 1
                                                    ],
                                                    []
                                                  |),
                                                  [
                                                    M.borrow (|
                                                      Pointer.Kind.Ref,
                                                      M.deref (|
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.alloc (|
                                                            Ty.apply
                                                              (Ty.path "array")
                                                              [ Value.Integer IntegerKind.Usize 1 ]
                                                              [
                                                                Ty.apply
                                                                  (Ty.path "&")
                                                                  []
                                                                  [ Ty.path "str" ]
                                                              ],
                                                            Value.Array
                                                              [
                                                                mk_str (|
                                                                  "Incorrect vector length "
                                                                |)
                                                              ]
                                                          |)
                                                        |)
                                                      |)
                                                    |);
                                                    M.borrow (|
                                                      Pointer.Kind.Ref,
                                                      M.deref (|
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.alloc (|
                                                            Ty.apply
                                                              (Ty.path "array")
                                                              [ Value.Integer IntegerKind.Usize 1 ]
                                                              [ Ty.path "core::fmt::rt::Argument" ],
                                                            Value.Array
                                                              [
                                                                M.call_closure (|
                                                                  Ty.path "core::fmt::rt::Argument",
                                                                  M.get_associated_function (|
                                                                    Ty.path
                                                                      "core::fmt::rt::Argument",
                                                                    "new_display",
                                                                    [],
                                                                    [ Ty.path "usize" ]
                                                                  |),
                                                                  [
                                                                    M.borrow (|
                                                                      Pointer.Kind.Ref,
                                                                      M.deref (|
                                                                        M.borrow (|
                                                                          Pointer.Kind.Ref,
                                                                          M.alloc (|
                                                                            Ty.path "usize",
                                                                            M.call_closure (|
                                                                              Ty.path "usize",
                                                                              M.get_associated_function (|
                                                                                Ty.apply
                                                                                  (Ty.path
                                                                                    "alloc::vec::Vec")
                                                                                  []
                                                                                  [
                                                                                    T;
                                                                                    Ty.path
                                                                                      "alloc::alloc::Global"
                                                                                  ],
                                                                                "len",
                                                                                [],
                                                                                []
                                                                              |),
                                                                              [
                                                                                M.borrow (|
                                                                                  Pointer.Kind.Ref,
                                                                                  M.SubPointer.get_struct_tuple_field (|
                                                                                    v,
                                                                                    "openvm_circuit::arch::integration_api::DynArray",
                                                                                    0
                                                                                  |)
                                                                                |)
                                                                              ]
                                                                            |)
                                                                          |)
                                                                        |)
                                                                      |)
                                                                    |)
                                                                  ]
                                                                |)
                                                              ]
                                                          |)
                                                        |)
                                                      |)
                                                    |)
                                                  ]
                                                |)
                                              ]
                                          ]
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ => ltac:(M.monadic (Value.Tuple []))
                            ]
                          |)))
                    ]
                  |) in
                let~ it :
                    Ty.apply
                      (Ty.path "alloc::vec::into_iter::IntoIter")
                      []
                      [ T; Ty.path "alloc::alloc::Global" ] :=
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "alloc::vec::into_iter::IntoIter")
                      []
                      [ T; Ty.path "alloc::alloc::Global" ],
                    M.get_trait_method (|
                      "core::iter::traits::collect::IntoIterator",
                      Ty.apply (Ty.path "alloc::vec::Vec") [] [ T; Ty.path "alloc::alloc::Global" ],
                      [],
                      [],
                      "into_iter",
                      [],
                      []
                    |),
                    [
                      M.read (|
                        M.SubPointer.get_struct_tuple_field (|
                          v,
                          "openvm_circuit::arch::integration_api::DynArray",
                          0
                        |)
                      |)
                    ]
                  |) in
                M.alloc (|
                  Ty.apply
                    (Ty.path "array")
                    [ R ]
                    [ Ty.apply (Ty.path "array") [ M_ ] [ Ty.apply (Ty.path "array") [ N ] [ T ] ]
                    ],
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "array")
                      [ R ]
                      [ Ty.apply (Ty.path "array") [ M_ ] [ Ty.apply (Ty.path "array") [ N ] [ T ] ]
                      ],
                    M.get_function (|
                      "core::array::from_fn",
                      [ R ],
                      [
                        Ty.apply
                          (Ty.path "array")
                          [ M_ ]
                          [ Ty.apply (Ty.path "array") [ N ] [ T ] ];
                        Ty.function
                          [ Ty.path "usize" ]
                          (Ty.apply
                            (Ty.path "array")
                            [ M_ ]
                            [ Ty.apply (Ty.path "array") [ N ] [ T ] ])
                      ]
                    |),
                    [
                      M.closure
                        (fun γ =>
                          ltac:(M.monadic
                            match γ with
                            | [ α0 ] =>
                              ltac:(M.monadic
                                (M.match_operator (|
                                  Ty.apply
                                    (Ty.path "array")
                                    [ M_ ]
                                    [ Ty.apply (Ty.path "array") [ N ] [ T ] ],
                                  M.alloc (| Ty.path "usize", α0 |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (M.call_closure (|
                                          Ty.apply
                                            (Ty.path "array")
                                            [ M_ ]
                                            [ Ty.apply (Ty.path "array") [ N ] [ T ] ],
                                          M.get_function (|
                                            "core::array::from_fn",
                                            [ M_ ],
                                            [
                                              Ty.apply (Ty.path "array") [ N ] [ T ];
                                              Ty.function
                                                [ Ty.path "usize" ]
                                                (Ty.apply (Ty.path "array") [ N ] [ T ])
                                            ]
                                          |),
                                          [
                                            M.closure
                                              (fun γ =>
                                                ltac:(M.monadic
                                                  match γ with
                                                  | [ α0 ] =>
                                                    ltac:(M.monadic
                                                      (M.match_operator (|
                                                        Ty.apply (Ty.path "array") [ N ] [ T ],
                                                        M.alloc (| Ty.path "usize", α0 |),
                                                        [
                                                          fun γ =>
                                                            ltac:(M.monadic
                                                              (M.call_closure (|
                                                                Ty.apply
                                                                  (Ty.path "array")
                                                                  [ N ]
                                                                  [ T ],
                                                                M.get_function (|
                                                                  "core::array::from_fn",
                                                                  [ N ],
                                                                  [
                                                                    T;
                                                                    Ty.function
                                                                      [ Ty.path "usize" ]
                                                                      T
                                                                  ]
                                                                |),
                                                                [
                                                                  M.closure
                                                                    (fun γ =>
                                                                      ltac:(M.monadic
                                                                        match γ with
                                                                        | [ α0 ] =>
                                                                          ltac:(M.monadic
                                                                            (M.match_operator (|
                                                                              T,
                                                                              M.alloc (|
                                                                                Ty.path "usize",
                                                                                α0
                                                                              |),
                                                                              [
                                                                                fun γ =>
                                                                                  ltac:(M.monadic
                                                                                    (M.call_closure (|
                                                                                      T,
                                                                                      M.get_associated_function (|
                                                                                        Ty.apply
                                                                                          (Ty.path
                                                                                            "core::option::Option")
                                                                                          []
                                                                                          [ T ],
                                                                                        "unwrap",
                                                                                        [],
                                                                                        []
                                                                                      |),
                                                                                      [
                                                                                        M.call_closure (|
                                                                                          Ty.apply
                                                                                            (Ty.path
                                                                                              "core::option::Option")
                                                                                            []
                                                                                            [ T ],
                                                                                          M.get_trait_method (|
                                                                                            "core::iter::traits::iterator::Iterator",
                                                                                            Ty.apply
                                                                                              (Ty.path
                                                                                                "alloc::vec::into_iter::IntoIter")
                                                                                              []
                                                                                              [
                                                                                                T;
                                                                                                Ty.path
                                                                                                  "alloc::alloc::Global"
                                                                                              ],
                                                                                            [],
                                                                                            [],
                                                                                            "next",
                                                                                            [],
                                                                                            []
                                                                                          |),
                                                                                          [
                                                                                            M.borrow (|
                                                                                              Pointer.Kind.MutRef,
                                                                                              it
                                                                                            |)
                                                                                          ]
                                                                                        |)
                                                                                      ]
                                                                                    |)))
                                                                              ]
                                                                            |)))
                                                                        | _ =>
                                                                          M.impossible
                                                                            "wrong number of arguments"
                                                                        end))
                                                                ]
                                                              |)))
                                                        ]
                                                      |)))
                                                  | _ => M.impossible "wrong number of arguments"
                                                  end))
                                          ]
                                        |)))
                                  ]
                                |)))
                            | _ => M.impossible "wrong number of arguments"
                            end))
                    ]
                  |)
                |)
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          forall (N M_ R : Value.t) (T : Ty.t),
          M.IsTraitInstance
            "core::convert::From"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *)
            [ Ty.apply (Ty.path "openvm_circuit::arch::integration_api::DynArray") [] [ T ] ]
            (Self N M_ R T)
            (* Instance *) [ ("from", InstanceField.Method (from N M_ R T)) ].
      End Impl_core_convert_From_openvm_circuit_arch_integration_api_DynArray_T_for_array_R_array_M__array_N_T.
      
      Module Impl_core_convert_From_Tuple_array_M1_array_N_T_array_M2_array_N_T__for_openvm_circuit_arch_integration_api_DynArray_T.
        Definition Self (N M1 M2 : Value.t) (T : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "openvm_circuit::arch::integration_api::DynArray") [] [ T ].
        
        (*
                fn from(v: ([[T; N]; M1], [[T; N]; M2])) -> Self {
                    let vec =
                        v.0.into_iter()
                            .flatten()
                            .chain(v.1.into_iter().flatten())
                            .collect();
                    Self(vec)
                }
        *)
        Definition from
            (N M1 M2 : Value.t)
            (T : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self N M1 M2 T in
          match ε, τ, α with
          | [], [], [ v ] =>
            ltac:(M.monadic
              (let v :=
                M.alloc (|
                  Ty.tuple
                    [
                      Ty.apply (Ty.path "array") [ M1 ] [ Ty.apply (Ty.path "array") [ N ] [ T ] ];
                      Ty.apply (Ty.path "array") [ M2 ] [ Ty.apply (Ty.path "array") [ N ] [ T ] ]
                    ],
                  v
                |) in
              M.read (|
                let~ vec :
                    Ty.apply (Ty.path "alloc::vec::Vec") [] [ T; Ty.path "alloc::alloc::Global" ] :=
                  M.call_closure (|
                    Ty.apply (Ty.path "alloc::vec::Vec") [] [ T; Ty.path "alloc::alloc::Global" ],
                    M.get_trait_method (|
                      "core::iter::traits::iterator::Iterator",
                      Ty.apply
                        (Ty.path "core::iter::adapters::chain::Chain")
                        []
                        [
                          Ty.apply
                            (Ty.path "core::iter::adapters::flatten::Flatten")
                            []
                            [
                              Ty.apply
                                (Ty.path "core::array::iter::IntoIter")
                                [ M1 ]
                                [ Ty.apply (Ty.path "array") [ N ] [ T ] ]
                            ];
                          Ty.apply
                            (Ty.path "core::iter::adapters::flatten::Flatten")
                            []
                            [
                              Ty.apply
                                (Ty.path "core::array::iter::IntoIter")
                                [ M2 ]
                                [ Ty.apply (Ty.path "array") [ N ] [ T ] ]
                            ]
                        ],
                      [],
                      [],
                      "collect",
                      [],
                      [
                        Ty.apply
                          (Ty.path "alloc::vec::Vec")
                          []
                          [ T; Ty.path "alloc::alloc::Global" ]
                      ]
                    |),
                    [
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::iter::adapters::chain::Chain")
                          []
                          [
                            Ty.apply
                              (Ty.path "core::iter::adapters::flatten::Flatten")
                              []
                              [
                                Ty.apply
                                  (Ty.path "core::array::iter::IntoIter")
                                  [ M1 ]
                                  [ Ty.apply (Ty.path "array") [ N ] [ T ] ]
                              ];
                            Ty.apply
                              (Ty.path "core::iter::adapters::flatten::Flatten")
                              []
                              [
                                Ty.apply
                                  (Ty.path "core::array::iter::IntoIter")
                                  [ M2 ]
                                  [ Ty.apply (Ty.path "array") [ N ] [ T ] ]
                              ]
                          ],
                        M.get_trait_method (|
                          "core::iter::traits::iterator::Iterator",
                          Ty.apply
                            (Ty.path "core::iter::adapters::flatten::Flatten")
                            []
                            [
                              Ty.apply
                                (Ty.path "core::array::iter::IntoIter")
                                [ M1 ]
                                [ Ty.apply (Ty.path "array") [ N ] [ T ] ]
                            ],
                          [],
                          [],
                          "chain",
                          [],
                          [
                            Ty.apply
                              (Ty.path "core::iter::adapters::flatten::Flatten")
                              []
                              [
                                Ty.apply
                                  (Ty.path "core::array::iter::IntoIter")
                                  [ M2 ]
                                  [ Ty.apply (Ty.path "array") [ N ] [ T ] ]
                              ]
                          ]
                        |),
                        [
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "core::iter::adapters::flatten::Flatten")
                              []
                              [
                                Ty.apply
                                  (Ty.path "core::array::iter::IntoIter")
                                  [ M1 ]
                                  [ Ty.apply (Ty.path "array") [ N ] [ T ] ]
                              ],
                            M.get_trait_method (|
                              "core::iter::traits::iterator::Iterator",
                              Ty.apply
                                (Ty.path "core::array::iter::IntoIter")
                                [ M1 ]
                                [ Ty.apply (Ty.path "array") [ N ] [ T ] ],
                              [],
                              [],
                              "flatten",
                              [],
                              []
                            |),
                            [
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::array::iter::IntoIter")
                                  [ M1 ]
                                  [ Ty.apply (Ty.path "array") [ N ] [ T ] ],
                                M.get_trait_method (|
                                  "core::iter::traits::collect::IntoIterator",
                                  Ty.apply
                                    (Ty.path "array")
                                    [ M1 ]
                                    [ Ty.apply (Ty.path "array") [ N ] [ T ] ],
                                  [],
                                  [],
                                  "into_iter",
                                  [],
                                  []
                                |),
                                [ M.read (| M.SubPointer.get_tuple_field (| v, 0 |) |) ]
                              |)
                            ]
                          |);
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "core::iter::adapters::flatten::Flatten")
                              []
                              [
                                Ty.apply
                                  (Ty.path "core::array::iter::IntoIter")
                                  [ M2 ]
                                  [ Ty.apply (Ty.path "array") [ N ] [ T ] ]
                              ],
                            M.get_trait_method (|
                              "core::iter::traits::iterator::Iterator",
                              Ty.apply
                                (Ty.path "core::array::iter::IntoIter")
                                [ M2 ]
                                [ Ty.apply (Ty.path "array") [ N ] [ T ] ],
                              [],
                              [],
                              "flatten",
                              [],
                              []
                            |),
                            [
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::array::iter::IntoIter")
                                  [ M2 ]
                                  [ Ty.apply (Ty.path "array") [ N ] [ T ] ],
                                M.get_trait_method (|
                                  "core::iter::traits::collect::IntoIterator",
                                  Ty.apply
                                    (Ty.path "array")
                                    [ M2 ]
                                    [ Ty.apply (Ty.path "array") [ N ] [ T ] ],
                                  [],
                                  [],
                                  "into_iter",
                                  [],
                                  []
                                |),
                                [ M.read (| M.SubPointer.get_tuple_field (| v, 1 |) |) ]
                              |)
                            ]
                          |)
                        ]
                      |)
                    ]
                  |) in
                M.alloc (|
                  Ty.apply (Ty.path "openvm_circuit::arch::integration_api::DynArray") [] [ T ],
                  Value.StructTuple
                    "openvm_circuit::arch::integration_api::DynArray"
                    []
                    [ T ]
                    [ M.read (| vec |) ]
                |)
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          forall (N M1 M2 : Value.t) (T : Ty.t),
          M.IsTraitInstance
            "core::convert::From"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *)
            [
              Ty.tuple
                [
                  Ty.apply (Ty.path "array") [ M1 ] [ Ty.apply (Ty.path "array") [ N ] [ T ] ];
                  Ty.apply (Ty.path "array") [ M2 ] [ Ty.apply (Ty.path "array") [ N ] [ T ] ]
                ]
            ]
            (Self N M1 M2 T)
            (* Instance *) [ ("from", InstanceField.Method (from N M1 M2 T)) ].
      End Impl_core_convert_From_Tuple_array_M1_array_N_T_array_M2_array_N_T__for_openvm_circuit_arch_integration_api_DynArray_T.
      
      Module Impl_core_convert_From_openvm_circuit_arch_integration_api_DynArray_T_for_Tuple_array_M1_array_N_T_array_M2_array_N_T_.
        Definition Self (N M1 M2 : Value.t) (T : Ty.t) : Ty.t :=
          Ty.tuple
            [
              Ty.apply (Ty.path "array") [ M1 ] [ Ty.apply (Ty.path "array") [ N ] [ T ] ];
              Ty.apply (Ty.path "array") [ M2 ] [ Ty.apply (Ty.path "array") [ N ] [ T ] ]
            ].
        
        (*
                fn from(v: DynArray<T>) -> Self {
                    assert_eq!(
                        v.0.len(),
                        N * (M1 + M2),
                        "Incorrect vector length {}",
                        v.0.len()
                    );
                    let mut it = v.0.into_iter();
                    (
                        from_fn(|_| from_fn(|_| it.next().unwrap())),
                        from_fn(|_| from_fn(|_| it.next().unwrap())),
                    )
                }
        *)
        Definition from
            (N M1 M2 : Value.t)
            (T : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self N M1 M2 T in
          match ε, τ, α with
          | [], [], [ v ] =>
            ltac:(M.monadic
              (let v :=
                M.alloc (|
                  Ty.apply (Ty.path "openvm_circuit::arch::integration_api::DynArray") [] [ T ],
                  v
                |) in
              M.read (|
                let~ _ : Ty.tuple [] :=
                  M.match_operator (|
                    Ty.tuple [],
                    M.alloc (|
                      Ty.tuple
                        [
                          Ty.apply (Ty.path "&") [] [ Ty.path "usize" ];
                          Ty.apply (Ty.path "&") [] [ Ty.path "usize" ]
                        ],
                      Value.Tuple
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.alloc (|
                              Ty.path "usize",
                              M.call_closure (|
                                Ty.path "usize",
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "alloc::vec::Vec")
                                    []
                                    [ T; Ty.path "alloc::alloc::Global" ],
                                  "len",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.SubPointer.get_struct_tuple_field (|
                                      v,
                                      "openvm_circuit::arch::integration_api::DynArray",
                                      0
                                    |)
                                  |)
                                ]
                              |)
                            |)
                          |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.alloc (|
                              Ty.path "usize",
                              M.call_closure (|
                                Ty.path "usize",
                                BinOp.Wrap.mul,
                                [
                                  N;
                                  M.call_closure (| Ty.path "usize", BinOp.Wrap.add, [ M1; M2 ] |)
                                ]
                              |)
                            |)
                          |)
                        ]
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                          let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                          let left_val :=
                            M.copy (| Ty.apply (Ty.path "&") [] [ Ty.path "usize" ], γ0_0 |) in
                          let right_val :=
                            M.copy (| Ty.apply (Ty.path "&") [] [ Ty.path "usize" ], γ0_1 |) in
                          M.match_operator (|
                            Ty.tuple [],
                            M.alloc (| Ty.tuple [], Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ :=
                                    M.use
                                      (M.alloc (|
                                        Ty.path "bool",
                                        UnOp.not (|
                                          M.call_closure (|
                                            Ty.path "bool",
                                            BinOp.eq,
                                            [
                                              M.read (| M.deref (| M.read (| left_val |) |) |);
                                              M.read (| M.deref (| M.read (| right_val |) |) |)
                                            ]
                                          |)
                                        |)
                                      |)) in
                                  let _ :=
                                    is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  M.never_to_any (|
                                    M.read (|
                                      let~ kind : Ty.path "core::panicking::AssertKind" :=
                                        Value.StructTuple
                                          "core::panicking::AssertKind::Eq"
                                          []
                                          []
                                          [] in
                                      M.alloc (|
                                        Ty.path "never",
                                        M.call_closure (|
                                          Ty.path "never",
                                          M.get_function (|
                                            "core::panicking::assert_failed",
                                            [],
                                            [ Ty.path "usize"; Ty.path "usize" ]
                                          |),
                                          [
                                            M.read (| kind |);
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (| M.read (| left_val |) |)
                                                |)
                                              |)
                                            |);
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (| M.read (| right_val |) |)
                                                |)
                                              |)
                                            |);
                                            Value.StructTuple
                                              "core::option::Option::Some"
                                              []
                                              [ Ty.path "core::fmt::Arguments" ]
                                              [
                                                M.call_closure (|
                                                  Ty.path "core::fmt::Arguments",
                                                  M.get_associated_function (|
                                                    Ty.path "core::fmt::Arguments",
                                                    "new_v1",
                                                    [
                                                      Value.Integer IntegerKind.Usize 1;
                                                      Value.Integer IntegerKind.Usize 1
                                                    ],
                                                    []
                                                  |),
                                                  [
                                                    M.borrow (|
                                                      Pointer.Kind.Ref,
                                                      M.deref (|
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.alloc (|
                                                            Ty.apply
                                                              (Ty.path "array")
                                                              [ Value.Integer IntegerKind.Usize 1 ]
                                                              [
                                                                Ty.apply
                                                                  (Ty.path "&")
                                                                  []
                                                                  [ Ty.path "str" ]
                                                              ],
                                                            Value.Array
                                                              [
                                                                mk_str (|
                                                                  "Incorrect vector length "
                                                                |)
                                                              ]
                                                          |)
                                                        |)
                                                      |)
                                                    |);
                                                    M.borrow (|
                                                      Pointer.Kind.Ref,
                                                      M.deref (|
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.alloc (|
                                                            Ty.apply
                                                              (Ty.path "array")
                                                              [ Value.Integer IntegerKind.Usize 1 ]
                                                              [ Ty.path "core::fmt::rt::Argument" ],
                                                            Value.Array
                                                              [
                                                                M.call_closure (|
                                                                  Ty.path "core::fmt::rt::Argument",
                                                                  M.get_associated_function (|
                                                                    Ty.path
                                                                      "core::fmt::rt::Argument",
                                                                    "new_display",
                                                                    [],
                                                                    [ Ty.path "usize" ]
                                                                  |),
                                                                  [
                                                                    M.borrow (|
                                                                      Pointer.Kind.Ref,
                                                                      M.deref (|
                                                                        M.borrow (|
                                                                          Pointer.Kind.Ref,
                                                                          M.alloc (|
                                                                            Ty.path "usize",
                                                                            M.call_closure (|
                                                                              Ty.path "usize",
                                                                              M.get_associated_function (|
                                                                                Ty.apply
                                                                                  (Ty.path
                                                                                    "alloc::vec::Vec")
                                                                                  []
                                                                                  [
                                                                                    T;
                                                                                    Ty.path
                                                                                      "alloc::alloc::Global"
                                                                                  ],
                                                                                "len",
                                                                                [],
                                                                                []
                                                                              |),
                                                                              [
                                                                                M.borrow (|
                                                                                  Pointer.Kind.Ref,
                                                                                  M.SubPointer.get_struct_tuple_field (|
                                                                                    v,
                                                                                    "openvm_circuit::arch::integration_api::DynArray",
                                                                                    0
                                                                                  |)
                                                                                |)
                                                                              ]
                                                                            |)
                                                                          |)
                                                                        |)
                                                                      |)
                                                                    |)
                                                                  ]
                                                                |)
                                                              ]
                                                          |)
                                                        |)
                                                      |)
                                                    |)
                                                  ]
                                                |)
                                              ]
                                          ]
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ => ltac:(M.monadic (Value.Tuple []))
                            ]
                          |)))
                    ]
                  |) in
                let~ it :
                    Ty.apply
                      (Ty.path "alloc::vec::into_iter::IntoIter")
                      []
                      [ T; Ty.path "alloc::alloc::Global" ] :=
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "alloc::vec::into_iter::IntoIter")
                      []
                      [ T; Ty.path "alloc::alloc::Global" ],
                    M.get_trait_method (|
                      "core::iter::traits::collect::IntoIterator",
                      Ty.apply (Ty.path "alloc::vec::Vec") [] [ T; Ty.path "alloc::alloc::Global" ],
                      [],
                      [],
                      "into_iter",
                      [],
                      []
                    |),
                    [
                      M.read (|
                        M.SubPointer.get_struct_tuple_field (|
                          v,
                          "openvm_circuit::arch::integration_api::DynArray",
                          0
                        |)
                      |)
                    ]
                  |) in
                M.alloc (|
                  Ty.tuple
                    [
                      Ty.apply (Ty.path "array") [ M1 ] [ Ty.apply (Ty.path "array") [ N ] [ T ] ];
                      Ty.apply (Ty.path "array") [ M2 ] [ Ty.apply (Ty.path "array") [ N ] [ T ] ]
                    ],
                  Value.Tuple
                    [
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "array")
                          [ M1 ]
                          [ Ty.apply (Ty.path "array") [ N ] [ T ] ],
                        M.get_function (|
                          "core::array::from_fn",
                          [ M1 ],
                          [
                            Ty.apply (Ty.path "array") [ N ] [ T ];
                            Ty.function [ Ty.path "usize" ] (Ty.apply (Ty.path "array") [ N ] [ T ])
                          ]
                        |),
                        [
                          M.closure
                            (fun γ =>
                              ltac:(M.monadic
                                match γ with
                                | [ α0 ] =>
                                  ltac:(M.monadic
                                    (M.match_operator (|
                                      Ty.apply (Ty.path "array") [ N ] [ T ],
                                      M.alloc (| Ty.path "usize", α0 |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (M.call_closure (|
                                              Ty.apply (Ty.path "array") [ N ] [ T ],
                                              M.get_function (|
                                                "core::array::from_fn",
                                                [ N ],
                                                [ T; Ty.function [ Ty.path "usize" ] T ]
                                              |),
                                              [
                                                M.closure
                                                  (fun γ =>
                                                    ltac:(M.monadic
                                                      match γ with
                                                      | [ α0 ] =>
                                                        ltac:(M.monadic
                                                          (M.match_operator (|
                                                            T,
                                                            M.alloc (| Ty.path "usize", α0 |),
                                                            [
                                                              fun γ =>
                                                                ltac:(M.monadic
                                                                  (M.call_closure (|
                                                                    T,
                                                                    M.get_associated_function (|
                                                                      Ty.apply
                                                                        (Ty.path
                                                                          "core::option::Option")
                                                                        []
                                                                        [ T ],
                                                                      "unwrap",
                                                                      [],
                                                                      []
                                                                    |),
                                                                    [
                                                                      M.call_closure (|
                                                                        Ty.apply
                                                                          (Ty.path
                                                                            "core::option::Option")
                                                                          []
                                                                          [ T ],
                                                                        M.get_trait_method (|
                                                                          "core::iter::traits::iterator::Iterator",
                                                                          Ty.apply
                                                                            (Ty.path
                                                                              "alloc::vec::into_iter::IntoIter")
                                                                            []
                                                                            [
                                                                              T;
                                                                              Ty.path
                                                                                "alloc::alloc::Global"
                                                                            ],
                                                                          [],
                                                                          [],
                                                                          "next",
                                                                          [],
                                                                          []
                                                                        |),
                                                                        [
                                                                          M.borrow (|
                                                                            Pointer.Kind.MutRef,
                                                                            it
                                                                          |)
                                                                        ]
                                                                      |)
                                                                    ]
                                                                  |)))
                                                            ]
                                                          |)))
                                                      | _ =>
                                                        M.impossible "wrong number of arguments"
                                                      end))
                                              ]
                                            |)))
                                      ]
                                    |)))
                                | _ => M.impossible "wrong number of arguments"
                                end))
                        ]
                      |);
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "array")
                          [ M2 ]
                          [ Ty.apply (Ty.path "array") [ N ] [ T ] ],
                        M.get_function (|
                          "core::array::from_fn",
                          [ M2 ],
                          [
                            Ty.apply (Ty.path "array") [ N ] [ T ];
                            Ty.function [ Ty.path "usize" ] (Ty.apply (Ty.path "array") [ N ] [ T ])
                          ]
                        |),
                        [
                          M.closure
                            (fun γ =>
                              ltac:(M.monadic
                                match γ with
                                | [ α0 ] =>
                                  ltac:(M.monadic
                                    (M.match_operator (|
                                      Ty.apply (Ty.path "array") [ N ] [ T ],
                                      M.alloc (| Ty.path "usize", α0 |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (M.call_closure (|
                                              Ty.apply (Ty.path "array") [ N ] [ T ],
                                              M.get_function (|
                                                "core::array::from_fn",
                                                [ N ],
                                                [ T; Ty.function [ Ty.path "usize" ] T ]
                                              |),
                                              [
                                                M.closure
                                                  (fun γ =>
                                                    ltac:(M.monadic
                                                      match γ with
                                                      | [ α0 ] =>
                                                        ltac:(M.monadic
                                                          (M.match_operator (|
                                                            T,
                                                            M.alloc (| Ty.path "usize", α0 |),
                                                            [
                                                              fun γ =>
                                                                ltac:(M.monadic
                                                                  (M.call_closure (|
                                                                    T,
                                                                    M.get_associated_function (|
                                                                      Ty.apply
                                                                        (Ty.path
                                                                          "core::option::Option")
                                                                        []
                                                                        [ T ],
                                                                      "unwrap",
                                                                      [],
                                                                      []
                                                                    |),
                                                                    [
                                                                      M.call_closure (|
                                                                        Ty.apply
                                                                          (Ty.path
                                                                            "core::option::Option")
                                                                          []
                                                                          [ T ],
                                                                        M.get_trait_method (|
                                                                          "core::iter::traits::iterator::Iterator",
                                                                          Ty.apply
                                                                            (Ty.path
                                                                              "alloc::vec::into_iter::IntoIter")
                                                                            []
                                                                            [
                                                                              T;
                                                                              Ty.path
                                                                                "alloc::alloc::Global"
                                                                            ],
                                                                          [],
                                                                          [],
                                                                          "next",
                                                                          [],
                                                                          []
                                                                        |),
                                                                        [
                                                                          M.borrow (|
                                                                            Pointer.Kind.MutRef,
                                                                            it
                                                                          |)
                                                                        ]
                                                                      |)
                                                                    ]
                                                                  |)))
                                                            ]
                                                          |)))
                                                      | _ =>
                                                        M.impossible "wrong number of arguments"
                                                      end))
                                              ]
                                            |)))
                                      ]
                                    |)))
                                | _ => M.impossible "wrong number of arguments"
                                end))
                        ]
                      |)
                    ]
                |)
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          forall (N M1 M2 : Value.t) (T : Ty.t),
          M.IsTraitInstance
            "core::convert::From"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *)
            [ Ty.apply (Ty.path "openvm_circuit::arch::integration_api::DynArray") [] [ T ] ]
            (Self N M1 M2 T)
            (* Instance *) [ ("from", InstanceField.Method (from N M1 M2 T)) ].
      End Impl_core_convert_From_openvm_circuit_arch_integration_api_DynArray_T_for_Tuple_array_M1_array_N_T_array_M2_array_N_T_.
      
      Module Impl_core_convert_From_where_core_convert_Into_PI_openvm_circuit_arch_integration_api_DynArray_T_openvm_circuit_arch_integration_api_AdapterAirContext_T_openvm_circuit_arch_integration_api_BasicAdapterInterface_NUM_READS_NUM_WRITES_READ_SIZE_WRITE_SIZE_T_PI_for_openvm_circuit_arch_integration_api_AdapterAirContext_T_openvm_circuit_arch_integration_api_DynAdapterInterface_T.
        Definition Self
            (NUM_READS NUM_WRITES READ_SIZE WRITE_SIZE : Value.t)
            (T PI : Ty.t)
            : Ty.t :=
          Ty.apply
            (Ty.path "openvm_circuit::arch::integration_api::AdapterAirContext")
            []
            [
              T;
              Ty.apply
                (Ty.path "openvm_circuit::arch::integration_api::DynAdapterInterface")
                []
                [ T ]
            ].
        
        (*
                fn from(
                    ctx: AdapterAirContext<
                        T,
                        BasicAdapterInterface<T, PI, NUM_READS, NUM_WRITES, READ_SIZE, WRITE_SIZE>,
                    >,
                ) -> Self {
                    AdapterAirContext {
                        to_pc: ctx.to_pc,
                        reads: ctx.reads.into(),
                        writes: ctx.writes.into(),
                        instruction: ctx.instruction.into(),
                    }
                }
        *)
        Definition from
            (NUM_READS NUM_WRITES READ_SIZE WRITE_SIZE : Value.t)
            (T PI : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self NUM_READS NUM_WRITES READ_SIZE WRITE_SIZE T PI in
          match ε, τ, α with
          | [], [], [ ctx ] =>
            ltac:(M.monadic
              (let ctx :=
                M.alloc (|
                  Ty.apply
                    (Ty.path "openvm_circuit::arch::integration_api::AdapterAirContext")
                    []
                    [
                      T;
                      Ty.apply
                        (Ty.path "openvm_circuit::arch::integration_api::BasicAdapterInterface")
                        [ NUM_READS; NUM_WRITES; READ_SIZE; WRITE_SIZE ]
                        [ T; PI ]
                    ],
                  ctx
                |) in
              Value.mkStructRecord
                "openvm_circuit::arch::integration_api::AdapterAirContext"
                []
                [
                  T;
                  Ty.apply
                    (Ty.path "openvm_circuit::arch::integration_api::DynAdapterInterface")
                    []
                    [ T ]
                ]
                [
                  ("to_pc",
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        ctx,
                        "openvm_circuit::arch::integration_api::AdapterAirContext",
                        "to_pc"
                      |)
                    |));
                  ("reads",
                    M.call_closure (|
                      Ty.apply (Ty.path "openvm_circuit::arch::integration_api::DynArray") [] [ T ],
                      M.get_trait_method (|
                        "core::convert::Into",
                        Ty.apply
                          (Ty.path "array")
                          [ NUM_READS ]
                          [ Ty.apply (Ty.path "array") [ READ_SIZE ] [ T ] ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "openvm_circuit::arch::integration_api::DynArray")
                            []
                            [ T ]
                        ],
                        "into",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            ctx,
                            "openvm_circuit::arch::integration_api::AdapterAirContext",
                            "reads"
                          |)
                        |)
                      ]
                    |));
                  ("writes",
                    M.call_closure (|
                      Ty.apply (Ty.path "openvm_circuit::arch::integration_api::DynArray") [] [ T ],
                      M.get_trait_method (|
                        "core::convert::Into",
                        Ty.apply
                          (Ty.path "array")
                          [ NUM_WRITES ]
                          [ Ty.apply (Ty.path "array") [ WRITE_SIZE ] [ T ] ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "openvm_circuit::arch::integration_api::DynArray")
                            []
                            [ T ]
                        ],
                        "into",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            ctx,
                            "openvm_circuit::arch::integration_api::AdapterAirContext",
                            "writes"
                          |)
                        |)
                      ]
                    |));
                  ("instruction",
                    M.call_closure (|
                      Ty.apply (Ty.path "openvm_circuit::arch::integration_api::DynArray") [] [ T ],
                      M.get_trait_method (|
                        "core::convert::Into",
                        PI,
                        [],
                        [
                          Ty.apply
                            (Ty.path "openvm_circuit::arch::integration_api::DynArray")
                            []
                            [ T ]
                        ],
                        "into",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            ctx,
                            "openvm_circuit::arch::integration_api::AdapterAirContext",
                            "instruction"
                          |)
                        |)
                      ]
                    |))
                ]))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          forall (NUM_READS NUM_WRITES READ_SIZE WRITE_SIZE : Value.t) (T PI : Ty.t),
          M.IsTraitInstance
            "core::convert::From"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *)
            [
              Ty.apply
                (Ty.path "openvm_circuit::arch::integration_api::AdapterAirContext")
                []
                [
                  T;
                  Ty.apply
                    (Ty.path "openvm_circuit::arch::integration_api::BasicAdapterInterface")
                    [ NUM_READS; NUM_WRITES; READ_SIZE; WRITE_SIZE ]
                    [ T; PI ]
                ]
            ]
            (Self NUM_READS NUM_WRITES READ_SIZE WRITE_SIZE T PI)
            (* Instance *)
            [ ("from", InstanceField.Method (from NUM_READS NUM_WRITES READ_SIZE WRITE_SIZE T PI))
            ].
      End Impl_core_convert_From_where_core_convert_Into_PI_openvm_circuit_arch_integration_api_DynArray_T_openvm_circuit_arch_integration_api_AdapterAirContext_T_openvm_circuit_arch_integration_api_BasicAdapterInterface_NUM_READS_NUM_WRITES_READ_SIZE_WRITE_SIZE_T_PI_for_openvm_circuit_arch_integration_api_AdapterAirContext_T_openvm_circuit_arch_integration_api_DynAdapterInterface_T.
      
      Module Impl_core_convert_From_openvm_circuit_arch_integration_api_AdapterRuntimeContext_T_openvm_circuit_arch_integration_api_BasicAdapterInterface_NUM_READS_NUM_WRITES_READ_SIZE_WRITE_SIZE_T_PI_for_openvm_circuit_arch_integration_api_AdapterRuntimeContext_T_openvm_circuit_arch_integration_api_DynAdapterInterface_T.
        Definition Self
            (NUM_READS NUM_WRITES READ_SIZE WRITE_SIZE : Value.t)
            (T PI : Ty.t)
            : Ty.t :=
          Ty.apply
            (Ty.path "openvm_circuit::arch::integration_api::AdapterRuntimeContext")
            []
            [
              T;
              Ty.apply
                (Ty.path "openvm_circuit::arch::integration_api::DynAdapterInterface")
                []
                [ T ]
            ].
        
        (*
                fn from(
                    ctx: AdapterRuntimeContext<
                        T,
                        BasicAdapterInterface<T, PI, NUM_READS, NUM_WRITES, READ_SIZE, WRITE_SIZE>,
                    >,
                ) -> Self {
                    AdapterRuntimeContext {
                        to_pc: ctx.to_pc,
                        writes: ctx.writes.into(),
                    }
                }
        *)
        Definition from
            (NUM_READS NUM_WRITES READ_SIZE WRITE_SIZE : Value.t)
            (T PI : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self NUM_READS NUM_WRITES READ_SIZE WRITE_SIZE T PI in
          match ε, τ, α with
          | [], [], [ ctx ] =>
            ltac:(M.monadic
              (let ctx :=
                M.alloc (|
                  Ty.apply
                    (Ty.path "openvm_circuit::arch::integration_api::AdapterRuntimeContext")
                    []
                    [
                      T;
                      Ty.apply
                        (Ty.path "openvm_circuit::arch::integration_api::BasicAdapterInterface")
                        [ NUM_READS; NUM_WRITES; READ_SIZE; WRITE_SIZE ]
                        [ T; PI ]
                    ],
                  ctx
                |) in
              Value.mkStructRecord
                "openvm_circuit::arch::integration_api::AdapterRuntimeContext"
                []
                [
                  T;
                  Ty.apply
                    (Ty.path "openvm_circuit::arch::integration_api::DynAdapterInterface")
                    []
                    [ T ]
                ]
                [
                  ("to_pc",
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        ctx,
                        "openvm_circuit::arch::integration_api::AdapterRuntimeContext",
                        "to_pc"
                      |)
                    |));
                  ("writes",
                    M.call_closure (|
                      Ty.apply (Ty.path "openvm_circuit::arch::integration_api::DynArray") [] [ T ],
                      M.get_trait_method (|
                        "core::convert::Into",
                        Ty.apply
                          (Ty.path "array")
                          [ NUM_WRITES ]
                          [ Ty.apply (Ty.path "array") [ WRITE_SIZE ] [ T ] ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "openvm_circuit::arch::integration_api::DynArray")
                            []
                            [ T ]
                        ],
                        "into",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            ctx,
                            "openvm_circuit::arch::integration_api::AdapterRuntimeContext",
                            "writes"
                          |)
                        |)
                      ]
                    |))
                ]))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          forall (NUM_READS NUM_WRITES READ_SIZE WRITE_SIZE : Value.t) (T PI : Ty.t),
          M.IsTraitInstance
            "core::convert::From"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *)
            [
              Ty.apply
                (Ty.path "openvm_circuit::arch::integration_api::AdapterRuntimeContext")
                []
                [
                  T;
                  Ty.apply
                    (Ty.path "openvm_circuit::arch::integration_api::BasicAdapterInterface")
                    [ NUM_READS; NUM_WRITES; READ_SIZE; WRITE_SIZE ]
                    [ T; PI ]
                ]
            ]
            (Self NUM_READS NUM_WRITES READ_SIZE WRITE_SIZE T PI)
            (* Instance *)
            [ ("from", InstanceField.Method (from NUM_READS NUM_WRITES READ_SIZE WRITE_SIZE T PI))
            ].
      End Impl_core_convert_From_openvm_circuit_arch_integration_api_AdapterRuntimeContext_T_openvm_circuit_arch_integration_api_BasicAdapterInterface_NUM_READS_NUM_WRITES_READ_SIZE_WRITE_SIZE_T_PI_for_openvm_circuit_arch_integration_api_AdapterRuntimeContext_T_openvm_circuit_arch_integration_api_DynAdapterInterface_T.
      
      Module Impl_core_convert_From_where_core_convert_From_PI_openvm_circuit_arch_integration_api_DynArray_T_openvm_circuit_arch_integration_api_AdapterAirContext_T_openvm_circuit_arch_integration_api_DynAdapterInterface_T_for_openvm_circuit_arch_integration_api_AdapterAirContext_T_openvm_circuit_arch_integration_api_BasicAdapterInterface_NUM_READS_NUM_WRITES_READ_SIZE_WRITE_SIZE_T_PI.
        Definition Self
            (NUM_READS NUM_WRITES READ_SIZE WRITE_SIZE : Value.t)
            (T PI : Ty.t)
            : Ty.t :=
          Ty.apply
            (Ty.path "openvm_circuit::arch::integration_api::AdapterAirContext")
            []
            [
              T;
              Ty.apply
                (Ty.path "openvm_circuit::arch::integration_api::BasicAdapterInterface")
                [ NUM_READS; NUM_WRITES; READ_SIZE; WRITE_SIZE ]
                [ T; PI ]
            ].
        
        (*
                fn from(ctx: AdapterAirContext<T, DynAdapterInterface<T>>) -> Self {
                    AdapterAirContext {
                        to_pc: ctx.to_pc,
                        reads: ctx.reads.into(),
                        writes: ctx.writes.into(),
                        instruction: ctx.instruction.into(),
                    }
                }
        *)
        Definition from
            (NUM_READS NUM_WRITES READ_SIZE WRITE_SIZE : Value.t)
            (T PI : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self NUM_READS NUM_WRITES READ_SIZE WRITE_SIZE T PI in
          match ε, τ, α with
          | [], [], [ ctx ] =>
            ltac:(M.monadic
              (let ctx :=
                M.alloc (|
                  Ty.apply
                    (Ty.path "openvm_circuit::arch::integration_api::AdapterAirContext")
                    []
                    [
                      T;
                      Ty.apply
                        (Ty.path "openvm_circuit::arch::integration_api::DynAdapterInterface")
                        []
                        [ T ]
                    ],
                  ctx
                |) in
              Value.mkStructRecord
                "openvm_circuit::arch::integration_api::AdapterAirContext"
                []
                [
                  T;
                  Ty.apply
                    (Ty.path "openvm_circuit::arch::integration_api::BasicAdapterInterface")
                    [ NUM_READS; NUM_WRITES; READ_SIZE; WRITE_SIZE ]
                    [ T; PI ]
                ]
                [
                  ("to_pc",
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        ctx,
                        "openvm_circuit::arch::integration_api::AdapterAirContext",
                        "to_pc"
                      |)
                    |));
                  ("reads",
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "array")
                        [ NUM_READS ]
                        [ Ty.apply (Ty.path "array") [ READ_SIZE ] [ T ] ],
                      M.get_trait_method (|
                        "core::convert::Into",
                        Ty.apply
                          (Ty.path "openvm_circuit::arch::integration_api::DynArray")
                          []
                          [ T ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "array")
                            [ NUM_READS ]
                            [ Ty.apply (Ty.path "array") [ READ_SIZE ] [ T ] ]
                        ],
                        "into",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            ctx,
                            "openvm_circuit::arch::integration_api::AdapterAirContext",
                            "reads"
                          |)
                        |)
                      ]
                    |));
                  ("writes",
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "array")
                        [ NUM_WRITES ]
                        [ Ty.apply (Ty.path "array") [ WRITE_SIZE ] [ T ] ],
                      M.get_trait_method (|
                        "core::convert::Into",
                        Ty.apply
                          (Ty.path "openvm_circuit::arch::integration_api::DynArray")
                          []
                          [ T ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "array")
                            [ NUM_WRITES ]
                            [ Ty.apply (Ty.path "array") [ WRITE_SIZE ] [ T ] ]
                        ],
                        "into",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            ctx,
                            "openvm_circuit::arch::integration_api::AdapterAirContext",
                            "writes"
                          |)
                        |)
                      ]
                    |));
                  ("instruction",
                    M.call_closure (|
                      PI,
                      M.get_trait_method (|
                        "core::convert::Into",
                        Ty.apply
                          (Ty.path "openvm_circuit::arch::integration_api::DynArray")
                          []
                          [ T ],
                        [],
                        [ PI ],
                        "into",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            ctx,
                            "openvm_circuit::arch::integration_api::AdapterAirContext",
                            "instruction"
                          |)
                        |)
                      ]
                    |))
                ]))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          forall (NUM_READS NUM_WRITES READ_SIZE WRITE_SIZE : Value.t) (T PI : Ty.t),
          M.IsTraitInstance
            "core::convert::From"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *)
            [
              Ty.apply
                (Ty.path "openvm_circuit::arch::integration_api::AdapterAirContext")
                []
                [
                  T;
                  Ty.apply
                    (Ty.path "openvm_circuit::arch::integration_api::DynAdapterInterface")
                    []
                    [ T ]
                ]
            ]
            (Self NUM_READS NUM_WRITES READ_SIZE WRITE_SIZE T PI)
            (* Instance *)
            [ ("from", InstanceField.Method (from NUM_READS NUM_WRITES READ_SIZE WRITE_SIZE T PI))
            ].
      End Impl_core_convert_From_where_core_convert_From_PI_openvm_circuit_arch_integration_api_DynArray_T_openvm_circuit_arch_integration_api_AdapterAirContext_T_openvm_circuit_arch_integration_api_DynAdapterInterface_T_for_openvm_circuit_arch_integration_api_AdapterAirContext_T_openvm_circuit_arch_integration_api_BasicAdapterInterface_NUM_READS_NUM_WRITES_READ_SIZE_WRITE_SIZE_T_PI.
      
      Module Impl_core_convert_From_openvm_circuit_arch_integration_api_AdapterRuntimeContext_T_openvm_circuit_arch_integration_api_DynAdapterInterface_T_for_openvm_circuit_arch_integration_api_AdapterRuntimeContext_T_openvm_circuit_arch_integration_api_BasicAdapterInterface_NUM_READS_NUM_WRITES_READ_SIZE_WRITE_SIZE_T_PI.
        Definition Self
            (NUM_READS NUM_WRITES READ_SIZE WRITE_SIZE : Value.t)
            (T PI : Ty.t)
            : Ty.t :=
          Ty.apply
            (Ty.path "openvm_circuit::arch::integration_api::AdapterRuntimeContext")
            []
            [
              T;
              Ty.apply
                (Ty.path "openvm_circuit::arch::integration_api::BasicAdapterInterface")
                [ NUM_READS; NUM_WRITES; READ_SIZE; WRITE_SIZE ]
                [ T; PI ]
            ].
        
        (*
                fn from(ctx: AdapterRuntimeContext<T, DynAdapterInterface<T>>) -> Self {
                    AdapterRuntimeContext {
                        to_pc: ctx.to_pc,
                        writes: ctx.writes.into(),
                    }
                }
        *)
        Definition from
            (NUM_READS NUM_WRITES READ_SIZE WRITE_SIZE : Value.t)
            (T PI : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self NUM_READS NUM_WRITES READ_SIZE WRITE_SIZE T PI in
          match ε, τ, α with
          | [], [], [ ctx ] =>
            ltac:(M.monadic
              (let ctx :=
                M.alloc (|
                  Ty.apply
                    (Ty.path "openvm_circuit::arch::integration_api::AdapterRuntimeContext")
                    []
                    [
                      T;
                      Ty.apply
                        (Ty.path "openvm_circuit::arch::integration_api::DynAdapterInterface")
                        []
                        [ T ]
                    ],
                  ctx
                |) in
              Value.mkStructRecord
                "openvm_circuit::arch::integration_api::AdapterRuntimeContext"
                []
                [
                  T;
                  Ty.apply
                    (Ty.path "openvm_circuit::arch::integration_api::BasicAdapterInterface")
                    [ NUM_READS; NUM_WRITES; READ_SIZE; WRITE_SIZE ]
                    [ T; PI ]
                ]
                [
                  ("to_pc",
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        ctx,
                        "openvm_circuit::arch::integration_api::AdapterRuntimeContext",
                        "to_pc"
                      |)
                    |));
                  ("writes",
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "array")
                        [ NUM_WRITES ]
                        [ Ty.apply (Ty.path "array") [ WRITE_SIZE ] [ T ] ],
                      M.get_trait_method (|
                        "core::convert::Into",
                        Ty.apply
                          (Ty.path "openvm_circuit::arch::integration_api::DynArray")
                          []
                          [ T ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "array")
                            [ NUM_WRITES ]
                            [ Ty.apply (Ty.path "array") [ WRITE_SIZE ] [ T ] ]
                        ],
                        "into",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            ctx,
                            "openvm_circuit::arch::integration_api::AdapterRuntimeContext",
                            "writes"
                          |)
                        |)
                      ]
                    |))
                ]))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          forall (NUM_READS NUM_WRITES READ_SIZE WRITE_SIZE : Value.t) (T PI : Ty.t),
          M.IsTraitInstance
            "core::convert::From"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *)
            [
              Ty.apply
                (Ty.path "openvm_circuit::arch::integration_api::AdapterRuntimeContext")
                []
                [
                  T;
                  Ty.apply
                    (Ty.path "openvm_circuit::arch::integration_api::DynAdapterInterface")
                    []
                    [ T ]
                ]
            ]
            (Self NUM_READS NUM_WRITES READ_SIZE WRITE_SIZE T PI)
            (* Instance *)
            [ ("from", InstanceField.Method (from NUM_READS NUM_WRITES READ_SIZE WRITE_SIZE T PI))
            ].
      End Impl_core_convert_From_openvm_circuit_arch_integration_api_AdapterRuntimeContext_T_openvm_circuit_arch_integration_api_DynAdapterInterface_T_for_openvm_circuit_arch_integration_api_AdapterRuntimeContext_T_openvm_circuit_arch_integration_api_BasicAdapterInterface_NUM_READS_NUM_WRITES_READ_SIZE_WRITE_SIZE_T_PI.
      
      Module Impl_core_convert_From_where_core_clone_Clone_T_where_core_convert_Into_PI_openvm_circuit_arch_integration_api_DynArray_T_openvm_circuit_arch_integration_api_AdapterAirContext_T_openvm_circuit_arch_integration_api_FlatInterface_READ_CELLS_WRITE_CELLS_T_PI_for_openvm_circuit_arch_integration_api_AdapterAirContext_T_openvm_circuit_arch_integration_api_DynAdapterInterface_T.
        Definition Self (READ_CELLS WRITE_CELLS : Value.t) (T PI : Ty.t) : Ty.t :=
          Ty.apply
            (Ty.path "openvm_circuit::arch::integration_api::AdapterAirContext")
            []
            [
              T;
              Ty.apply
                (Ty.path "openvm_circuit::arch::integration_api::DynAdapterInterface")
                []
                [ T ]
            ].
        
        (*
                fn from(ctx: AdapterAirContext<T, FlatInterface<T, PI, READ_CELLS, WRITE_CELLS>>) -> Self {
                    AdapterAirContext {
                        to_pc: ctx.to_pc,
                        reads: ctx.reads.to_vec().into(),
                        writes: ctx.writes.to_vec().into(),
                        instruction: ctx.instruction.into(),
                    }
                }
        *)
        Definition from
            (READ_CELLS WRITE_CELLS : Value.t)
            (T PI : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self READ_CELLS WRITE_CELLS T PI in
          match ε, τ, α with
          | [], [], [ ctx ] =>
            ltac:(M.monadic
              (let ctx :=
                M.alloc (|
                  Ty.apply
                    (Ty.path "openvm_circuit::arch::integration_api::AdapterAirContext")
                    []
                    [
                      T;
                      Ty.apply
                        (Ty.path "openvm_circuit::arch::integration_api::FlatInterface")
                        [ READ_CELLS; WRITE_CELLS ]
                        [ T; PI ]
                    ],
                  ctx
                |) in
              Value.mkStructRecord
                "openvm_circuit::arch::integration_api::AdapterAirContext"
                []
                [
                  T;
                  Ty.apply
                    (Ty.path "openvm_circuit::arch::integration_api::DynAdapterInterface")
                    []
                    [ T ]
                ]
                [
                  ("to_pc",
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        ctx,
                        "openvm_circuit::arch::integration_api::AdapterAirContext",
                        "to_pc"
                      |)
                    |));
                  ("reads",
                    M.call_closure (|
                      Ty.apply (Ty.path "openvm_circuit::arch::integration_api::DynArray") [] [ T ],
                      M.get_trait_method (|
                        "core::convert::Into",
                        Ty.apply
                          (Ty.path "alloc::vec::Vec")
                          []
                          [ T; Ty.path "alloc::alloc::Global" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "openvm_circuit::arch::integration_api::DynArray")
                            []
                            [ T ]
                        ],
                        "into",
                        [],
                        []
                      |),
                      [
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            []
                            [ T; Ty.path "alloc::alloc::Global" ],
                          M.get_associated_function (|
                            Ty.apply (Ty.path "slice") [] [ T ],
                            "to_vec",
                            [],
                            []
                          |),
                          [
                            M.call_closure (|
                              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                              M.pointer_coercion
                                M.PointerCoercion.Unsize
                                (Ty.apply
                                  (Ty.path "&")
                                  []
                                  [ Ty.apply (Ty.path "array") [ READ_CELLS ] [ T ] ])
                                (Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ]),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.SubPointer.get_struct_record_field (|
                                    ctx,
                                    "openvm_circuit::arch::integration_api::AdapterAirContext",
                                    "reads"
                                  |)
                                |)
                              ]
                            |)
                          ]
                        |)
                      ]
                    |));
                  ("writes",
                    M.call_closure (|
                      Ty.apply (Ty.path "openvm_circuit::arch::integration_api::DynArray") [] [ T ],
                      M.get_trait_method (|
                        "core::convert::Into",
                        Ty.apply
                          (Ty.path "alloc::vec::Vec")
                          []
                          [ T; Ty.path "alloc::alloc::Global" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "openvm_circuit::arch::integration_api::DynArray")
                            []
                            [ T ]
                        ],
                        "into",
                        [],
                        []
                      |),
                      [
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            []
                            [ T; Ty.path "alloc::alloc::Global" ],
                          M.get_associated_function (|
                            Ty.apply (Ty.path "slice") [] [ T ],
                            "to_vec",
                            [],
                            []
                          |),
                          [
                            M.call_closure (|
                              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                              M.pointer_coercion
                                M.PointerCoercion.Unsize
                                (Ty.apply
                                  (Ty.path "&")
                                  []
                                  [ Ty.apply (Ty.path "array") [ WRITE_CELLS ] [ T ] ])
                                (Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ]),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.SubPointer.get_struct_record_field (|
                                    ctx,
                                    "openvm_circuit::arch::integration_api::AdapterAirContext",
                                    "writes"
                                  |)
                                |)
                              ]
                            |)
                          ]
                        |)
                      ]
                    |));
                  ("instruction",
                    M.call_closure (|
                      Ty.apply (Ty.path "openvm_circuit::arch::integration_api::DynArray") [] [ T ],
                      M.get_trait_method (|
                        "core::convert::Into",
                        PI,
                        [],
                        [
                          Ty.apply
                            (Ty.path "openvm_circuit::arch::integration_api::DynArray")
                            []
                            [ T ]
                        ],
                        "into",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            ctx,
                            "openvm_circuit::arch::integration_api::AdapterAirContext",
                            "instruction"
                          |)
                        |)
                      ]
                    |))
                ]))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          forall (READ_CELLS WRITE_CELLS : Value.t) (T PI : Ty.t),
          M.IsTraitInstance
            "core::convert::From"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *)
            [
              Ty.apply
                (Ty.path "openvm_circuit::arch::integration_api::AdapterAirContext")
                []
                [
                  T;
                  Ty.apply
                    (Ty.path "openvm_circuit::arch::integration_api::FlatInterface")
                    [ READ_CELLS; WRITE_CELLS ]
                    [ T; PI ]
                ]
            ]
            (Self READ_CELLS WRITE_CELLS T PI)
            (* Instance *) [ ("from", InstanceField.Method (from READ_CELLS WRITE_CELLS T PI)) ].
      End Impl_core_convert_From_where_core_clone_Clone_T_where_core_convert_Into_PI_openvm_circuit_arch_integration_api_DynArray_T_openvm_circuit_arch_integration_api_AdapterAirContext_T_openvm_circuit_arch_integration_api_FlatInterface_READ_CELLS_WRITE_CELLS_T_PI_for_openvm_circuit_arch_integration_api_AdapterAirContext_T_openvm_circuit_arch_integration_api_DynAdapterInterface_T.
      
      Module Impl_core_convert_From_where_core_clone_Clone_T_openvm_circuit_arch_integration_api_AdapterRuntimeContext_T_openvm_circuit_arch_integration_api_FlatInterface_READ_CELLS_WRITE_CELLS_T_PI_for_openvm_circuit_arch_integration_api_AdapterRuntimeContext_T_openvm_circuit_arch_integration_api_DynAdapterInterface_T.
        Definition Self (READ_CELLS WRITE_CELLS : Value.t) (T PI : Ty.t) : Ty.t :=
          Ty.apply
            (Ty.path "openvm_circuit::arch::integration_api::AdapterRuntimeContext")
            []
            [
              T;
              Ty.apply
                (Ty.path "openvm_circuit::arch::integration_api::DynAdapterInterface")
                []
                [ T ]
            ].
        
        (*
                fn from(
                    ctx: AdapterRuntimeContext<T, FlatInterface<T, PI, READ_CELLS, WRITE_CELLS>>,
                ) -> Self {
                    AdapterRuntimeContext {
                        to_pc: ctx.to_pc,
                        writes: ctx.writes.to_vec().into(),
                    }
                }
        *)
        Definition from
            (READ_CELLS WRITE_CELLS : Value.t)
            (T PI : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self READ_CELLS WRITE_CELLS T PI in
          match ε, τ, α with
          | [], [], [ ctx ] =>
            ltac:(M.monadic
              (let ctx :=
                M.alloc (|
                  Ty.apply
                    (Ty.path "openvm_circuit::arch::integration_api::AdapterRuntimeContext")
                    []
                    [
                      T;
                      Ty.apply
                        (Ty.path "openvm_circuit::arch::integration_api::FlatInterface")
                        [ READ_CELLS; WRITE_CELLS ]
                        [ T; PI ]
                    ],
                  ctx
                |) in
              Value.mkStructRecord
                "openvm_circuit::arch::integration_api::AdapterRuntimeContext"
                []
                [
                  T;
                  Ty.apply
                    (Ty.path "openvm_circuit::arch::integration_api::DynAdapterInterface")
                    []
                    [ T ]
                ]
                [
                  ("to_pc",
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        ctx,
                        "openvm_circuit::arch::integration_api::AdapterRuntimeContext",
                        "to_pc"
                      |)
                    |));
                  ("writes",
                    M.call_closure (|
                      Ty.apply (Ty.path "openvm_circuit::arch::integration_api::DynArray") [] [ T ],
                      M.get_trait_method (|
                        "core::convert::Into",
                        Ty.apply
                          (Ty.path "alloc::vec::Vec")
                          []
                          [ T; Ty.path "alloc::alloc::Global" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "openvm_circuit::arch::integration_api::DynArray")
                            []
                            [ T ]
                        ],
                        "into",
                        [],
                        []
                      |),
                      [
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            []
                            [ T; Ty.path "alloc::alloc::Global" ],
                          M.get_associated_function (|
                            Ty.apply (Ty.path "slice") [] [ T ],
                            "to_vec",
                            [],
                            []
                          |),
                          [
                            M.call_closure (|
                              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                              M.pointer_coercion
                                M.PointerCoercion.Unsize
                                (Ty.apply
                                  (Ty.path "&")
                                  []
                                  [ Ty.apply (Ty.path "array") [ WRITE_CELLS ] [ T ] ])
                                (Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ]),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.SubPointer.get_struct_record_field (|
                                    ctx,
                                    "openvm_circuit::arch::integration_api::AdapterRuntimeContext",
                                    "writes"
                                  |)
                                |)
                              ]
                            |)
                          ]
                        |)
                      ]
                    |))
                ]))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          forall (READ_CELLS WRITE_CELLS : Value.t) (T PI : Ty.t),
          M.IsTraitInstance
            "core::convert::From"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *)
            [
              Ty.apply
                (Ty.path "openvm_circuit::arch::integration_api::AdapterRuntimeContext")
                []
                [
                  T;
                  Ty.apply
                    (Ty.path "openvm_circuit::arch::integration_api::FlatInterface")
                    [ READ_CELLS; WRITE_CELLS ]
                    [ T; PI ]
                ]
            ]
            (Self READ_CELLS WRITE_CELLS T PI)
            (* Instance *) [ ("from", InstanceField.Method (from READ_CELLS WRITE_CELLS T PI)) ].
      End Impl_core_convert_From_where_core_clone_Clone_T_openvm_circuit_arch_integration_api_AdapterRuntimeContext_T_openvm_circuit_arch_integration_api_FlatInterface_READ_CELLS_WRITE_CELLS_T_PI_for_openvm_circuit_arch_integration_api_AdapterRuntimeContext_T_openvm_circuit_arch_integration_api_DynAdapterInterface_T.
      
      Module Impl_core_convert_From_openvm_circuit_arch_integration_api_MinimalInstruction_T_for_openvm_circuit_arch_integration_api_DynArray_T.
        Definition Self (T : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "openvm_circuit::arch::integration_api::DynArray") [] [ T ].
        
        (*
                fn from(m: MinimalInstruction<T>) -> Self {
                    Self(vec![m.is_valid, m.opcode])
                }
        *)
        Definition from (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T in
          match ε, τ, α with
          | [], [], [ m ] =>
            ltac:(M.monadic
              (let m :=
                M.alloc (|
                  Ty.apply
                    (Ty.path "openvm_circuit::arch::integration_api::MinimalInstruction")
                    []
                    [ T ],
                  m
                |) in
              Value.StructTuple
                "openvm_circuit::arch::integration_api::DynArray"
                []
                [ T ]
                [
                  M.call_closure (|
                    Ty.apply (Ty.path "alloc::vec::Vec") [] [ T; Ty.path "alloc::alloc::Global" ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "slice") [] [ T ],
                      "into_vec",
                      [],
                      [ Ty.path "alloc::alloc::Global" ]
                    |),
                    [
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "alloc::boxed::Box")
                          []
                          [ Ty.apply (Ty.path "slice") [] [ T ]; Ty.path "alloc::alloc::Global" ],
                        M.pointer_coercion
                          M.PointerCoercion.Unsize
                          (Ty.apply
                            (Ty.path "alloc::boxed::Box")
                            []
                            [
                              Ty.apply
                                (Ty.path "array")
                                [ Value.Integer IntegerKind.Usize 2 ]
                                [ T ];
                              Ty.path "alloc::alloc::Global"
                            ])
                          (Ty.apply
                            (Ty.path "alloc::boxed::Box")
                            []
                            [ Ty.apply (Ty.path "slice") [] [ T ]; Ty.path "alloc::alloc::Global"
                            ]),
                        [
                          M.read (|
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "alloc::boxed::Box")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "array")
                                    [ Value.Integer IntegerKind.Usize 2 ]
                                    [ T ];
                                  Ty.path "alloc::alloc::Global"
                                ],
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "alloc::boxed::Box")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "array")
                                      [ Value.Integer IntegerKind.Usize 2 ]
                                      [ T ];
                                    Ty.path "alloc::alloc::Global"
                                  ],
                                "new",
                                [],
                                []
                              |),
                              [
                                M.alloc (|
                                  Ty.apply
                                    (Ty.path "array")
                                    [ Value.Integer IntegerKind.Usize 2 ]
                                    [ T ],
                                  Value.Array
                                    [
                                      M.read (|
                                        M.SubPointer.get_struct_record_field (|
                                          m,
                                          "openvm_circuit::arch::integration_api::MinimalInstruction",
                                          "is_valid"
                                        |)
                                      |);
                                      M.read (|
                                        M.SubPointer.get_struct_record_field (|
                                          m,
                                          "openvm_circuit::arch::integration_api::MinimalInstruction",
                                          "opcode"
                                        |)
                                      |)
                                    ]
                                |)
                              ]
                            |)
                          |)
                        ]
                      |)
                    ]
                  |)
                ]))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          forall (T : Ty.t),
          M.IsTraitInstance
            "core::convert::From"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *)
            [
              Ty.apply
                (Ty.path "openvm_circuit::arch::integration_api::MinimalInstruction")
                []
                [ T ]
            ]
            (Self T)
            (* Instance *) [ ("from", InstanceField.Method (from T)) ].
      End Impl_core_convert_From_openvm_circuit_arch_integration_api_MinimalInstruction_T_for_openvm_circuit_arch_integration_api_DynArray_T.
      
      Module Impl_core_convert_From_openvm_circuit_arch_integration_api_DynArray_T_for_openvm_circuit_arch_integration_api_MinimalInstruction_T.
        Definition Self (T : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "openvm_circuit::arch::integration_api::MinimalInstruction") [] [ T ].
        
        (*
                fn from(m: DynArray<T>) -> Self {
                    let mut m = m.0.into_iter();
                    MinimalInstruction {
                        is_valid: m.next().unwrap(),
                        opcode: m.next().unwrap(),
                    }
                }
        *)
        Definition from (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T in
          match ε, τ, α with
          | [], [], [ m ] =>
            ltac:(M.monadic
              (let m :=
                M.alloc (|
                  Ty.apply (Ty.path "openvm_circuit::arch::integration_api::DynArray") [] [ T ],
                  m
                |) in
              M.read (|
                let~ m :
                    Ty.apply
                      (Ty.path "alloc::vec::into_iter::IntoIter")
                      []
                      [ T; Ty.path "alloc::alloc::Global" ] :=
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "alloc::vec::into_iter::IntoIter")
                      []
                      [ T; Ty.path "alloc::alloc::Global" ],
                    M.get_trait_method (|
                      "core::iter::traits::collect::IntoIterator",
                      Ty.apply (Ty.path "alloc::vec::Vec") [] [ T; Ty.path "alloc::alloc::Global" ],
                      [],
                      [],
                      "into_iter",
                      [],
                      []
                    |),
                    [
                      M.read (|
                        M.SubPointer.get_struct_tuple_field (|
                          m,
                          "openvm_circuit::arch::integration_api::DynArray",
                          0
                        |)
                      |)
                    ]
                  |) in
                M.alloc (|
                  Ty.apply
                    (Ty.path "openvm_circuit::arch::integration_api::MinimalInstruction")
                    []
                    [ T ],
                  Value.mkStructRecord
                    "openvm_circuit::arch::integration_api::MinimalInstruction"
                    []
                    [ T ]
                    [
                      ("is_valid",
                        M.call_closure (|
                          T,
                          M.get_associated_function (|
                            Ty.apply (Ty.path "core::option::Option") [] [ T ],
                            "unwrap",
                            [],
                            []
                          |),
                          [
                            M.call_closure (|
                              Ty.apply (Ty.path "core::option::Option") [] [ T ],
                              M.get_trait_method (|
                                "core::iter::traits::iterator::Iterator",
                                Ty.apply
                                  (Ty.path "alloc::vec::into_iter::IntoIter")
                                  []
                                  [ T; Ty.path "alloc::alloc::Global" ],
                                [],
                                [],
                                "next",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.MutRef, m |) ]
                            |)
                          ]
                        |));
                      ("opcode",
                        M.call_closure (|
                          T,
                          M.get_associated_function (|
                            Ty.apply (Ty.path "core::option::Option") [] [ T ],
                            "unwrap",
                            [],
                            []
                          |),
                          [
                            M.call_closure (|
                              Ty.apply (Ty.path "core::option::Option") [] [ T ],
                              M.get_trait_method (|
                                "core::iter::traits::iterator::Iterator",
                                Ty.apply
                                  (Ty.path "alloc::vec::into_iter::IntoIter")
                                  []
                                  [ T; Ty.path "alloc::alloc::Global" ],
                                [],
                                [],
                                "next",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.MutRef, m |) ]
                            |)
                          ]
                        |))
                    ]
                |)
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          forall (T : Ty.t),
          M.IsTraitInstance
            "core::convert::From"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *)
            [ Ty.apply (Ty.path "openvm_circuit::arch::integration_api::DynArray") [] [ T ] ]
            (Self T)
            (* Instance *) [ ("from", InstanceField.Method (from T)) ].
      End Impl_core_convert_From_openvm_circuit_arch_integration_api_DynArray_T_for_openvm_circuit_arch_integration_api_MinimalInstruction_T.
      
      Module Impl_core_convert_From_openvm_circuit_arch_integration_api_DynArray_T_for_openvm_circuit_arch_integration_api_ImmInstruction_T.
        Definition Self (T : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "openvm_circuit::arch::integration_api::ImmInstruction") [] [ T ].
        
        (*
                fn from(m: DynArray<T>) -> Self {
                    let mut m = m.0.into_iter();
                    ImmInstruction {
                        is_valid: m.next().unwrap(),
                        opcode: m.next().unwrap(),
                        immediate: m.next().unwrap(),
                    }
                }
        *)
        Definition from (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T in
          match ε, τ, α with
          | [], [], [ m ] =>
            ltac:(M.monadic
              (let m :=
                M.alloc (|
                  Ty.apply (Ty.path "openvm_circuit::arch::integration_api::DynArray") [] [ T ],
                  m
                |) in
              M.read (|
                let~ m :
                    Ty.apply
                      (Ty.path "alloc::vec::into_iter::IntoIter")
                      []
                      [ T; Ty.path "alloc::alloc::Global" ] :=
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "alloc::vec::into_iter::IntoIter")
                      []
                      [ T; Ty.path "alloc::alloc::Global" ],
                    M.get_trait_method (|
                      "core::iter::traits::collect::IntoIterator",
                      Ty.apply (Ty.path "alloc::vec::Vec") [] [ T; Ty.path "alloc::alloc::Global" ],
                      [],
                      [],
                      "into_iter",
                      [],
                      []
                    |),
                    [
                      M.read (|
                        M.SubPointer.get_struct_tuple_field (|
                          m,
                          "openvm_circuit::arch::integration_api::DynArray",
                          0
                        |)
                      |)
                    ]
                  |) in
                M.alloc (|
                  Ty.apply
                    (Ty.path "openvm_circuit::arch::integration_api::ImmInstruction")
                    []
                    [ T ],
                  Value.mkStructRecord
                    "openvm_circuit::arch::integration_api::ImmInstruction"
                    []
                    [ T ]
                    [
                      ("is_valid",
                        M.call_closure (|
                          T,
                          M.get_associated_function (|
                            Ty.apply (Ty.path "core::option::Option") [] [ T ],
                            "unwrap",
                            [],
                            []
                          |),
                          [
                            M.call_closure (|
                              Ty.apply (Ty.path "core::option::Option") [] [ T ],
                              M.get_trait_method (|
                                "core::iter::traits::iterator::Iterator",
                                Ty.apply
                                  (Ty.path "alloc::vec::into_iter::IntoIter")
                                  []
                                  [ T; Ty.path "alloc::alloc::Global" ],
                                [],
                                [],
                                "next",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.MutRef, m |) ]
                            |)
                          ]
                        |));
                      ("opcode",
                        M.call_closure (|
                          T,
                          M.get_associated_function (|
                            Ty.apply (Ty.path "core::option::Option") [] [ T ],
                            "unwrap",
                            [],
                            []
                          |),
                          [
                            M.call_closure (|
                              Ty.apply (Ty.path "core::option::Option") [] [ T ],
                              M.get_trait_method (|
                                "core::iter::traits::iterator::Iterator",
                                Ty.apply
                                  (Ty.path "alloc::vec::into_iter::IntoIter")
                                  []
                                  [ T; Ty.path "alloc::alloc::Global" ],
                                [],
                                [],
                                "next",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.MutRef, m |) ]
                            |)
                          ]
                        |));
                      ("immediate",
                        M.call_closure (|
                          T,
                          M.get_associated_function (|
                            Ty.apply (Ty.path "core::option::Option") [] [ T ],
                            "unwrap",
                            [],
                            []
                          |),
                          [
                            M.call_closure (|
                              Ty.apply (Ty.path "core::option::Option") [] [ T ],
                              M.get_trait_method (|
                                "core::iter::traits::iterator::Iterator",
                                Ty.apply
                                  (Ty.path "alloc::vec::into_iter::IntoIter")
                                  []
                                  [ T; Ty.path "alloc::alloc::Global" ],
                                [],
                                [],
                                "next",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.MutRef, m |) ]
                            |)
                          ]
                        |))
                    ]
                |)
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          forall (T : Ty.t),
          M.IsTraitInstance
            "core::convert::From"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *)
            [ Ty.apply (Ty.path "openvm_circuit::arch::integration_api::DynArray") [] [ T ] ]
            (Self T)
            (* Instance *) [ ("from", InstanceField.Method (from T)) ].
      End Impl_core_convert_From_openvm_circuit_arch_integration_api_DynArray_T_for_openvm_circuit_arch_integration_api_ImmInstruction_T.
      
      Module Impl_core_convert_From_openvm_circuit_arch_integration_api_ImmInstruction_T_for_openvm_circuit_arch_integration_api_DynArray_T.
        Definition Self (T : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "openvm_circuit::arch::integration_api::DynArray") [] [ T ].
        
        (*
                fn from(instruction: ImmInstruction<T>) -> Self {
                    DynArray::from(vec![
                        instruction.is_valid,
                        instruction.opcode,
                        instruction.immediate,
                    ])
                }
        *)
        Definition from (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T in
          match ε, τ, α with
          | [], [], [ instruction ] =>
            ltac:(M.monadic
              (let instruction :=
                M.alloc (|
                  Ty.apply
                    (Ty.path "openvm_circuit::arch::integration_api::ImmInstruction")
                    []
                    [ T ],
                  instruction
                |) in
              M.call_closure (|
                Ty.apply (Ty.path "openvm_circuit::arch::integration_api::DynArray") [] [ T ],
                M.get_trait_method (|
                  "core::convert::From",
                  Ty.apply (Ty.path "openvm_circuit::arch::integration_api::DynArray") [] [ T ],
                  [],
                  [ Ty.apply (Ty.path "alloc::vec::Vec") [] [ T; Ty.path "alloc::alloc::Global" ] ],
                  "from",
                  [],
                  []
                |),
                [
                  M.call_closure (|
                    Ty.apply (Ty.path "alloc::vec::Vec") [] [ T; Ty.path "alloc::alloc::Global" ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "slice") [] [ T ],
                      "into_vec",
                      [],
                      [ Ty.path "alloc::alloc::Global" ]
                    |),
                    [
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "alloc::boxed::Box")
                          []
                          [ Ty.apply (Ty.path "slice") [] [ T ]; Ty.path "alloc::alloc::Global" ],
                        M.pointer_coercion
                          M.PointerCoercion.Unsize
                          (Ty.apply
                            (Ty.path "alloc::boxed::Box")
                            []
                            [
                              Ty.apply
                                (Ty.path "array")
                                [ Value.Integer IntegerKind.Usize 3 ]
                                [ T ];
                              Ty.path "alloc::alloc::Global"
                            ])
                          (Ty.apply
                            (Ty.path "alloc::boxed::Box")
                            []
                            [ Ty.apply (Ty.path "slice") [] [ T ]; Ty.path "alloc::alloc::Global"
                            ]),
                        [
                          M.read (|
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "alloc::boxed::Box")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "array")
                                    [ Value.Integer IntegerKind.Usize 3 ]
                                    [ T ];
                                  Ty.path "alloc::alloc::Global"
                                ],
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "alloc::boxed::Box")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "array")
                                      [ Value.Integer IntegerKind.Usize 3 ]
                                      [ T ];
                                    Ty.path "alloc::alloc::Global"
                                  ],
                                "new",
                                [],
                                []
                              |),
                              [
                                M.alloc (|
                                  Ty.apply
                                    (Ty.path "array")
                                    [ Value.Integer IntegerKind.Usize 3 ]
                                    [ T ],
                                  Value.Array
                                    [
                                      M.read (|
                                        M.SubPointer.get_struct_record_field (|
                                          instruction,
                                          "openvm_circuit::arch::integration_api::ImmInstruction",
                                          "is_valid"
                                        |)
                                      |);
                                      M.read (|
                                        M.SubPointer.get_struct_record_field (|
                                          instruction,
                                          "openvm_circuit::arch::integration_api::ImmInstruction",
                                          "opcode"
                                        |)
                                      |);
                                      M.read (|
                                        M.SubPointer.get_struct_record_field (|
                                          instruction,
                                          "openvm_circuit::arch::integration_api::ImmInstruction",
                                          "immediate"
                                        |)
                                      |)
                                    ]
                                |)
                              ]
                            |)
                          |)
                        ]
                      |)
                    ]
                  |)
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          forall (T : Ty.t),
          M.IsTraitInstance
            "core::convert::From"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *)
            [ Ty.apply (Ty.path "openvm_circuit::arch::integration_api::ImmInstruction") [] [ T ] ]
            (Self T)
            (* Instance *) [ ("from", InstanceField.Method (from T)) ].
      End Impl_core_convert_From_openvm_circuit_arch_integration_api_ImmInstruction_T_for_openvm_circuit_arch_integration_api_DynArray_T.
    End conversions.
  End integration_api.
End arch.
