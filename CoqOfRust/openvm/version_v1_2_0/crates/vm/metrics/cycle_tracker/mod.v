(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module metrics.
  Module cycle_tracker.
    (* StructRecord
      {
        name := "CycleTracker";
        const_params := [];
        ty_params := [];
        fields :=
          [
            ("stack",
              Ty.apply
                (Ty.path "alloc::vec::Vec")
                []
                [ Ty.path "alloc::string::String"; Ty.path "alloc::alloc::Global" ])
          ];
      } *)
    
    Module Impl_core_clone_Clone_for_openvm_circuit_metrics_cycle_tracker_CycleTracker.
      Definition Self : Ty.t := Ty.path "openvm_circuit::metrics::cycle_tracker::CycleTracker".
      
      (* Clone *)
      Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.path "openvm_circuit::metrics::cycle_tracker::CycleTracker" ],
                self
              |) in
            Value.mkStructRecord
              "openvm_circuit::metrics::cycle_tracker::CycleTracker"
              []
              []
              [
                ("stack",
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      []
                      [ Ty.path "alloc::string::String"; Ty.path "alloc::alloc::Global" ],
                    M.get_trait_method (|
                      "core::clone::Clone",
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        []
                        [ Ty.path "alloc::string::String"; Ty.path "alloc::alloc::Global" ],
                      [],
                      [],
                      "clone",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "openvm_circuit::metrics::cycle_tracker::CycleTracker",
                              "stack"
                            |)
                          |)
                        |)
                      |)
                    ]
                  |))
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::clone::Clone"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("clone", InstanceField.Method clone) ].
    End Impl_core_clone_Clone_for_openvm_circuit_metrics_cycle_tracker_CycleTracker.
    
    Module Impl_core_fmt_Debug_for_openvm_circuit_metrics_cycle_tracker_CycleTracker.
      Definition Self : Ty.t := Ty.path "openvm_circuit::metrics::cycle_tracker::CycleTracker".
      
      (* Debug *)
      Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.path "openvm_circuit::metrics::cycle_tracker::CycleTracker" ],
                self
              |) in
            let f :=
              M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "core::fmt::Formatter" ], f |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
              M.get_associated_function (|
                Ty.path "core::fmt::Formatter",
                "debug_struct_field1_finish",
                [],
                []
              |),
              [
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "CycleTracker" |) |) |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "stack" |) |) |);
                M.call_closure (|
                  Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ],
                  M.pointer_coercion
                    M.PointerCoercion.Unsize
                    (Ty.apply
                      (Ty.path "&")
                      []
                      [
                        Ty.apply
                          (Ty.path "&")
                          []
                          [
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              []
                              [ Ty.path "alloc::string::String"; Ty.path "alloc::alloc::Global" ]
                          ]
                      ])
                    (Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ]),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.alloc (|
                            Ty.apply
                              (Ty.path "&")
                              []
                              [
                                Ty.apply
                                  (Ty.path "alloc::vec::Vec")
                                  []
                                  [ Ty.path "alloc::string::String"; Ty.path "alloc::alloc::Global"
                                  ]
                              ],
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "openvm_circuit::metrics::cycle_tracker::CycleTracker",
                                "stack"
                              |)
                            |)
                          |)
                        |)
                      |)
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Debug"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Debug_for_openvm_circuit_metrics_cycle_tracker_CycleTracker.
    
    Module Impl_core_default_Default_for_openvm_circuit_metrics_cycle_tracker_CycleTracker.
      Definition Self : Ty.t := Ty.path "openvm_circuit::metrics::cycle_tracker::CycleTracker".
      
      (* Default *)
      Definition default (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [] =>
          ltac:(M.monadic
            (Value.mkStructRecord
              "openvm_circuit::metrics::cycle_tracker::CycleTracker"
              []
              []
              [
                ("stack",
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      []
                      [ Ty.path "alloc::string::String"; Ty.path "alloc::alloc::Global" ],
                    M.get_trait_method (|
                      "core::default::Default",
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        []
                        [ Ty.path "alloc::string::String"; Ty.path "alloc::alloc::Global" ],
                      [],
                      [],
                      "default",
                      [],
                      []
                    |),
                    []
                  |))
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::default::Default"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("default", InstanceField.Method default) ].
    End Impl_core_default_Default_for_openvm_circuit_metrics_cycle_tracker_CycleTracker.
    
    Module Impl_openvm_circuit_metrics_cycle_tracker_CycleTracker.
      Definition Self : Ty.t := Ty.path "openvm_circuit::metrics::cycle_tracker::CycleTracker".
      
      (*
          pub fn new() -> Self {
              Self::default()
          }
      *)
      Definition new (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [] =>
          ltac:(M.monadic
            (M.call_closure (|
              Ty.path "openvm_circuit::metrics::cycle_tracker::CycleTracker",
              M.get_trait_method (|
                "core::default::Default",
                Ty.path "openvm_circuit::metrics::cycle_tracker::CycleTracker",
                [],
                [],
                "default",
                [],
                []
              |),
              []
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_new : M.IsAssociatedFunction.C Self "new" new.
      Admitted.
      Global Typeclasses Opaque new.
      
      (*
          pub fn top(&self) -> Option<&String> {
              self.stack.last()
          }
      *)
      Definition top (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.path "openvm_circuit::metrics::cycle_tracker::CycleTracker" ],
                self
              |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::option::Option")
                []
                [ Ty.apply (Ty.path "&") [] [ Ty.path "alloc::string::String" ] ],
              M.get_associated_function (|
                Ty.apply (Ty.path "slice") [] [ Ty.path "alloc::string::String" ],
                "last",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "&")
                        []
                        [ Ty.apply (Ty.path "slice") [] [ Ty.path "alloc::string::String" ] ],
                      M.get_trait_method (|
                        "core::ops::deref::Deref",
                        Ty.apply
                          (Ty.path "alloc::vec::Vec")
                          []
                          [ Ty.path "alloc::string::String"; Ty.path "alloc::alloc::Global" ],
                        [],
                        [],
                        "deref",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "openvm_circuit::metrics::cycle_tracker::CycleTracker",
                            "stack"
                          |)
                        |)
                      ]
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_top : M.IsAssociatedFunction.C Self "top" top.
      Admitted.
      Global Typeclasses Opaque top.
      
      (*
          pub fn start(&mut self, mut name: String) {
              // hack to remove "CT-" prefix
              if name.starts_with("CT-") {
                  name = name.split_off(3);
              }
              self.stack.push(name);
          }
      *)
      Definition start (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; name ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&mut")
                  []
                  [ Ty.path "openvm_circuit::metrics::cycle_tracker::CycleTracker" ],
                self
              |) in
            let name := M.alloc (| Ty.path "alloc::string::String", name |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.match_operator (|
                  Ty.tuple [],
                  M.alloc (| Ty.tuple [], Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              Ty.path "bool",
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_associated_function (|
                                  Ty.path "str",
                                  "starts_with",
                                  [],
                                  [ Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ]
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.call_closure (|
                                        Ty.apply (Ty.path "&") [] [ Ty.path "str" ],
                                        M.get_trait_method (|
                                          "core::ops::deref::Deref",
                                          Ty.path "alloc::string::String",
                                          [],
                                          [],
                                          "deref",
                                          [],
                                          []
                                        |),
                                        [ M.borrow (| Pointer.Kind.Ref, name |) ]
                                      |)
                                    |)
                                  |);
                                  mk_str (| "CT-" |)
                                ]
                              |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.read (|
                          let~ _ : Ty.tuple [] :=
                            M.write (|
                              name,
                              M.call_closure (|
                                Ty.path "alloc::string::String",
                                M.get_associated_function (|
                                  Ty.path "alloc::string::String",
                                  "split_off",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (| Pointer.Kind.MutRef, name |);
                                  Value.Integer IntegerKind.Usize 3
                                ]
                              |)
                            |) in
                          M.alloc (| Ty.tuple [], Value.Tuple [] |)
                        |)));
                    fun γ => ltac:(M.monadic (Value.Tuple []))
                  ]
                |) in
              let~ _ : Ty.tuple [] :=
                M.call_closure (|
                  Ty.tuple [],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      []
                      [ Ty.path "alloc::string::String"; Ty.path "alloc::alloc::Global" ],
                    "push",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "openvm_circuit::metrics::cycle_tracker::CycleTracker",
                        "stack"
                      |)
                    |);
                    M.read (| name |)
                  ]
                |) in
              M.alloc (| Ty.tuple [], Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_start : M.IsAssociatedFunction.C Self "start" start.
      Admitted.
      Global Typeclasses Opaque start.
      
      (*
          pub fn end(&mut self, mut name: String) {
              // hack to remove "CT-" prefix
              if name.starts_with("CT-") {
                  name = name.split_off(3);
              }
              let stack_top = self.stack.pop();
              assert_eq!(stack_top.unwrap(), name, "Stack top does not match name");
          }
      *)
      Definition end_ (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; name ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&mut")
                  []
                  [ Ty.path "openvm_circuit::metrics::cycle_tracker::CycleTracker" ],
                self
              |) in
            let name := M.alloc (| Ty.path "alloc::string::String", name |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.match_operator (|
                  Ty.tuple [],
                  M.alloc (| Ty.tuple [], Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              Ty.path "bool",
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_associated_function (|
                                  Ty.path "str",
                                  "starts_with",
                                  [],
                                  [ Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ]
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.call_closure (|
                                        Ty.apply (Ty.path "&") [] [ Ty.path "str" ],
                                        M.get_trait_method (|
                                          "core::ops::deref::Deref",
                                          Ty.path "alloc::string::String",
                                          [],
                                          [],
                                          "deref",
                                          [],
                                          []
                                        |),
                                        [ M.borrow (| Pointer.Kind.Ref, name |) ]
                                      |)
                                    |)
                                  |);
                                  mk_str (| "CT-" |)
                                ]
                              |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.read (|
                          let~ _ : Ty.tuple [] :=
                            M.write (|
                              name,
                              M.call_closure (|
                                Ty.path "alloc::string::String",
                                M.get_associated_function (|
                                  Ty.path "alloc::string::String",
                                  "split_off",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (| Pointer.Kind.MutRef, name |);
                                  Value.Integer IntegerKind.Usize 3
                                ]
                              |)
                            |) in
                          M.alloc (| Ty.tuple [], Value.Tuple [] |)
                        |)));
                    fun γ => ltac:(M.monadic (Value.Tuple []))
                  ]
                |) in
              let~ stack_top :
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [ Ty.path "alloc::string::String" ] :=
                M.call_closure (|
                  Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "alloc::string::String" ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      []
                      [ Ty.path "alloc::string::String"; Ty.path "alloc::alloc::Global" ],
                    "pop",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "openvm_circuit::metrics::cycle_tracker::CycleTracker",
                        "stack"
                      |)
                    |)
                  ]
                |) in
              let~ _ : Ty.tuple [] :=
                M.match_operator (|
                  Ty.tuple [],
                  M.alloc (|
                    Ty.tuple
                      [
                        Ty.apply (Ty.path "&") [] [ Ty.path "alloc::string::String" ];
                        Ty.apply (Ty.path "&") [] [ Ty.path "alloc::string::String" ]
                      ],
                    Value.Tuple
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.alloc (|
                            Ty.path "alloc::string::String",
                            M.call_closure (|
                              Ty.path "alloc::string::String",
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "core::option::Option")
                                  []
                                  [ Ty.path "alloc::string::String" ],
                                "unwrap",
                                [],
                                []
                              |),
                              [ M.read (| stack_top |) ]
                            |)
                          |)
                        |);
                        M.borrow (| Pointer.Kind.Ref, name |)
                      ]
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                        let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                        let left_val :=
                          M.copy (|
                            Ty.apply (Ty.path "&") [] [ Ty.path "alloc::string::String" ],
                            γ0_0
                          |) in
                        let right_val :=
                          M.copy (|
                            Ty.apply (Ty.path "&") [] [ Ty.path "alloc::string::String" ],
                            γ0_1
                          |) in
                        M.match_operator (|
                          Ty.tuple [],
                          M.alloc (| Ty.tuple [], Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.use
                                    (M.alloc (|
                                      Ty.path "bool",
                                      UnOp.not (|
                                        M.call_closure (|
                                          Ty.path "bool",
                                          M.get_trait_method (|
                                            "core::cmp::PartialEq",
                                            Ty.path "alloc::string::String",
                                            [],
                                            [ Ty.path "alloc::string::String" ],
                                            "eq",
                                            [],
                                            []
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (| M.read (| left_val |) |)
                                            |);
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (| M.read (| right_val |) |)
                                            |)
                                          ]
                                        |)
                                      |)
                                    |)) in
                                let _ :=
                                  is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                M.never_to_any (|
                                  M.read (|
                                    let~ kind : Ty.path "core::panicking::AssertKind" :=
                                      Value.StructTuple
                                        "core::panicking::AssertKind::Eq"
                                        []
                                        []
                                        [] in
                                    M.alloc (|
                                      Ty.path "never",
                                      M.call_closure (|
                                        Ty.path "never",
                                        M.get_function (|
                                          "core::panicking::assert_failed",
                                          [],
                                          [
                                            Ty.path "alloc::string::String";
                                            Ty.path "alloc::string::String"
                                          ]
                                        |),
                                        [
                                          M.read (| kind |);
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (|
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.read (| left_val |) |)
                                              |)
                                            |)
                                          |);
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (|
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.read (| right_val |) |)
                                              |)
                                            |)
                                          |);
                                          Value.StructTuple
                                            "core::option::Option::Some"
                                            []
                                            [ Ty.path "core::fmt::Arguments" ]
                                            [
                                              M.call_closure (|
                                                Ty.path "core::fmt::Arguments",
                                                M.get_associated_function (|
                                                  Ty.path "core::fmt::Arguments",
                                                  "new_const",
                                                  [ Value.Integer IntegerKind.Usize 1 ],
                                                  []
                                                |),
                                                [
                                                  M.borrow (|
                                                    Pointer.Kind.Ref,
                                                    M.deref (|
                                                      M.borrow (|
                                                        Pointer.Kind.Ref,
                                                        M.alloc (|
                                                          Ty.apply
                                                            (Ty.path "array")
                                                            [ Value.Integer IntegerKind.Usize 1 ]
                                                            [
                                                              Ty.apply
                                                                (Ty.path "&")
                                                                []
                                                                [ Ty.path "str" ]
                                                            ],
                                                          Value.Array
                                                            [
                                                              mk_str (|
                                                                "Stack top does not match name"
                                                              |)
                                                            ]
                                                        |)
                                                      |)
                                                    |)
                                                  |)
                                                ]
                                              |)
                                            ]
                                        ]
                                      |)
                                    |)
                                  |)
                                |)));
                            fun γ => ltac:(M.monadic (Value.Tuple []))
                          ]
                        |)))
                  ]
                |) in
              M.alloc (| Ty.tuple [], Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_end_ : M.IsAssociatedFunction.C Self "end" end_.
      Admitted.
      Global Typeclasses Opaque end_.
      
      (*
          pub fn force_end(&mut self) {
              self.stack.pop();
          }
      *)
      Definition force_end (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&mut")
                  []
                  [ Ty.path "openvm_circuit::metrics::cycle_tracker::CycleTracker" ],
                self
              |) in
            M.read (|
              let~ _ :
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [ Ty.path "alloc::string::String" ] :=
                M.call_closure (|
                  Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "alloc::string::String" ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      []
                      [ Ty.path "alloc::string::String"; Ty.path "alloc::alloc::Global" ],
                    "pop",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "openvm_circuit::metrics::cycle_tracker::CycleTracker",
                        "stack"
                      |)
                    |)
                  ]
                |) in
              M.alloc (| Ty.tuple [], Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_force_end :
        M.IsAssociatedFunction.C Self "force_end" force_end.
      Admitted.
      Global Typeclasses Opaque force_end.
      
      (*
          pub fn get_full_name(&self) -> String {
              self.stack.join(";")
          }
      *)
      Definition get_full_name (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.path "openvm_circuit::metrics::cycle_tracker::CycleTracker" ],
                self
              |) in
            M.call_closure (|
              Ty.path "alloc::string::String",
              M.get_associated_function (|
                Ty.apply (Ty.path "slice") [] [ Ty.path "alloc::string::String" ],
                "join",
                [],
                [ Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ]
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "&")
                        []
                        [ Ty.apply (Ty.path "slice") [] [ Ty.path "alloc::string::String" ] ],
                      M.get_trait_method (|
                        "core::ops::deref::Deref",
                        Ty.apply
                          (Ty.path "alloc::vec::Vec")
                          []
                          [ Ty.path "alloc::string::String"; Ty.path "alloc::alloc::Global" ],
                        [],
                        [],
                        "deref",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "openvm_circuit::metrics::cycle_tracker::CycleTracker",
                            "stack"
                          |)
                        |)
                      ]
                    |)
                  |)
                |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| ";" |) |) |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_get_full_name :
        M.IsAssociatedFunction.C Self "get_full_name" get_full_name.
      Admitted.
      Global Typeclasses Opaque get_full_name.
    End Impl_openvm_circuit_metrics_cycle_tracker_CycleTracker.
    
    Module emit.
      Module Impl_openvm_circuit_metrics_cycle_tracker_CycleTracker.
        Definition Self : Ty.t := Ty.path "openvm_circuit::metrics::cycle_tracker::CycleTracker".
        
        (*
                pub fn increment_opcode(&self, (dsl_ir, opcode): &(Option<String>, String)) {
                    let labels = [
                        ("opcode", opcode.clone()),
                        ("dsl_ir", dsl_ir.clone().unwrap_or_default()),
                        ("cycle_tracker_span", self.get_full_name()),
                    ];
                    counter!("frequency", &labels).increment(1u64);
                }
        *)
        Definition increment_opcode (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          match ε, τ, α with
          | [], [], [ self; β1 ] =>
            ltac:(M.monadic
              (let self :=
                M.alloc (|
                  Ty.apply
                    (Ty.path "&")
                    []
                    [ Ty.path "openvm_circuit::metrics::cycle_tracker::CycleTracker" ],
                  self
                |) in
              let β1 :=
                M.alloc (|
                  Ty.apply
                    (Ty.path "&")
                    []
                    [
                      Ty.tuple
                        [
                          Ty.apply
                            (Ty.path "core::option::Option")
                            []
                            [ Ty.path "alloc::string::String" ];
                          Ty.path "alloc::string::String"
                        ]
                    ],
                  β1
                |) in
              M.match_operator (|
                Ty.tuple [],
                β1,
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let dsl_ir :=
                        M.copy (|
                          Ty.path
                            "Type for variables in patterns in function parameters is not handled",
                          γ0_0
                        |) in
                      let opcode :=
                        M.copy (|
                          Ty.path
                            "Type for variables in patterns in function parameters is not handled",
                          γ0_1
                        |) in
                      M.read (|
                        let~ labels :
                            Ty.apply
                              (Ty.path "array")
                              [ Value.Integer IntegerKind.Usize 3 ]
                              [
                                Ty.tuple
                                  [
                                    Ty.apply (Ty.path "&") [] [ Ty.path "str" ];
                                    Ty.path "alloc::string::String"
                                  ]
                              ] :=
                          Value.Array
                            [
                              Value.Tuple
                                [
                                  mk_str (| "opcode" |);
                                  M.call_closure (|
                                    Ty.path "alloc::string::String",
                                    M.get_trait_method (|
                                      "core::clone::Clone",
                                      Ty.path "alloc::string::String",
                                      [],
                                      [],
                                      "clone",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (| M.read (| opcode |) |)
                                      |)
                                    ]
                                  |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| mk_str (| "dsl_ir" |) |)
                                  |);
                                  M.call_closure (|
                                    Ty.path "alloc::string::String",
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "core::option::Option")
                                        []
                                        [ Ty.path "alloc::string::String" ],
                                      "unwrap_or_default",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "core::option::Option")
                                          []
                                          [ Ty.path "alloc::string::String" ],
                                        M.get_trait_method (|
                                          "core::clone::Clone",
                                          Ty.apply
                                            (Ty.path "core::option::Option")
                                            []
                                            [ Ty.path "alloc::string::String" ],
                                          [],
                                          [],
                                          "clone",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (| M.read (| dsl_ir |) |)
                                          |)
                                        ]
                                      |)
                                    ]
                                  |)
                                ];
                              Value.Tuple
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (| mk_str (| "cycle_tracker_span" |) |)
                                  |);
                                  M.call_closure (|
                                    Ty.path "alloc::string::String",
                                    M.get_associated_function (|
                                      Ty.path
                                        "openvm_circuit::metrics::cycle_tracker::CycleTracker",
                                      "get_full_name",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (| M.read (| self |) |)
                                      |)
                                    ]
                                  |)
                                ]
                            ] in
                        let~ _ : Ty.tuple [] :=
                          M.call_closure (|
                            Ty.tuple [],
                            M.get_associated_function (|
                              Ty.path "metrics::handles::Counter",
                              "increment",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                let~ metric_key : Ty.path "metrics::key::Key" :=
                                  M.call_closure (|
                                    Ty.path "metrics::key::Key",
                                    M.get_associated_function (|
                                      Ty.path "metrics::key::Key",
                                      "from_parts",
                                      [],
                                      [
                                        Ty.apply (Ty.path "&") [] [ Ty.path "str" ];
                                        Ty.apply
                                          (Ty.path "&")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "array")
                                              [ Value.Integer IntegerKind.Usize 3 ]
                                              [
                                                Ty.tuple
                                                  [
                                                    Ty.apply (Ty.path "&") [] [ Ty.path "str" ];
                                                    Ty.path "alloc::string::String"
                                                  ]
                                              ]
                                          ]
                                      ]
                                    |),
                                    [
                                      mk_str (| "frequency" |);
                                      M.borrow (| Pointer.Kind.Ref, labels |)
                                    ]
                                  |) in
                                let~ metadata :
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [ Ty.path "metrics::metadata::Metadata" ] :=
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.read (|
                                        get_constant (|
                                          "openvm_circuit::metrics::cycle_tracker::emit::increment_opcode::METADATA",
                                          Ty.apply
                                            (Ty.path "&")
                                            []
                                            [ Ty.path "metrics::metadata::Metadata" ]
                                        |)
                                      |)
                                    |)
                                  |) in
                                M.alloc (|
                                  Ty.path "metrics::handles::Counter",
                                  M.call_closure (|
                                    Ty.path "metrics::handles::Counter",
                                    M.get_function (|
                                      "metrics::recorder::with_recorder",
                                      [],
                                      [
                                        Ty.path "metrics::handles::Counter";
                                        Ty.function
                                          [
                                            Ty.apply
                                              (Ty.path "&")
                                              []
                                              [
                                                Ty.dyn
                                                  [ ("metrics::recorder::Recorder::Trait", []) ]
                                              ]
                                          ]
                                          (Ty.path "metrics::handles::Counter")
                                      ]
                                    |),
                                    [
                                      M.closure
                                        (fun γ =>
                                          ltac:(M.monadic
                                            match γ with
                                            | [ α0 ] =>
                                              ltac:(M.monadic
                                                (M.match_operator (|
                                                  Ty.path "metrics::handles::Counter",
                                                  M.alloc (|
                                                    Ty.apply
                                                      (Ty.path "&")
                                                      []
                                                      [
                                                        Ty.dyn
                                                          [
                                                            ("metrics::recorder::Recorder::Trait",
                                                              [])
                                                          ]
                                                      ],
                                                    α0
                                                  |),
                                                  [
                                                    fun γ =>
                                                      ltac:(M.monadic
                                                        (let recorder :=
                                                          M.copy (|
                                                            Ty.apply
                                                              (Ty.path "&")
                                                              []
                                                              [
                                                                Ty.dyn
                                                                  [
                                                                    ("metrics::recorder::Recorder::Trait",
                                                                      [])
                                                                  ]
                                                              ],
                                                            γ
                                                          |) in
                                                        M.call_closure (|
                                                          Ty.path "metrics::handles::Counter",
                                                          M.get_trait_method (|
                                                            "metrics::recorder::Recorder",
                                                            Ty.dyn
                                                              [
                                                                ("metrics::recorder::Recorder::Trait",
                                                                  [])
                                                              ],
                                                            [],
                                                            [],
                                                            "register_counter",
                                                            [],
                                                            []
                                                          |),
                                                          [
                                                            M.borrow (|
                                                              Pointer.Kind.Ref,
                                                              M.deref (| M.read (| recorder |) |)
                                                            |);
                                                            M.borrow (|
                                                              Pointer.Kind.Ref,
                                                              M.deref (|
                                                                M.borrow (|
                                                                  Pointer.Kind.Ref,
                                                                  metric_key
                                                                |)
                                                              |)
                                                            |);
                                                            M.borrow (|
                                                              Pointer.Kind.Ref,
                                                              M.deref (| M.read (| metadata |) |)
                                                            |)
                                                          ]
                                                        |)))
                                                  ]
                                                |)))
                                            | _ => M.impossible "wrong number of arguments"
                                            end))
                                    ]
                                  |)
                                |)
                              |);
                              Value.Integer IntegerKind.U64 1
                            ]
                          |) in
                        M.alloc (| Ty.tuple [], Value.Tuple [] |)
                      |)))
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Global Instance AssociatedFunction_increment_opcode :
          M.IsAssociatedFunction.C Self "increment_opcode" increment_opcode.
        Admitted.
        Global Typeclasses Opaque increment_opcode.
        
        (*
                pub fn increment_cells_used(
                    &self,
                    (dsl_ir, opcode, air_name): &(Option<String>, String, String),
                    trace_cells_used: usize,
                ) {
                    if trace_cells_used == 0 {
                        return;
                    }
                    let labels = [
                        ("air_name", air_name.clone()),
                        ("opcode", opcode.clone()),
                        ("dsl_ir", dsl_ir.clone().unwrap_or_default()),
                        ("cycle_tracker_span", self.get_full_name()),
                    ];
                    counter!("cells_used", &labels).increment(trace_cells_used as u64);
                }
        *)
        Definition increment_cells_used (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          match ε, τ, α with
          | [], [], [ self; β1; trace_cells_used ] =>
            ltac:(M.monadic
              (let self :=
                M.alloc (|
                  Ty.apply
                    (Ty.path "&")
                    []
                    [ Ty.path "openvm_circuit::metrics::cycle_tracker::CycleTracker" ],
                  self
                |) in
              let β1 :=
                M.alloc (|
                  Ty.apply
                    (Ty.path "&")
                    []
                    [
                      Ty.tuple
                        [
                          Ty.apply
                            (Ty.path "core::option::Option")
                            []
                            [ Ty.path "alloc::string::String" ];
                          Ty.path "alloc::string::String";
                          Ty.path "alloc::string::String"
                        ]
                    ],
                  β1
                |) in
              let trace_cells_used := M.alloc (| Ty.path "usize", trace_cells_used |) in
              M.match_operator (|
                Ty.tuple [],
                β1,
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let γ0_2 := M.SubPointer.get_tuple_field (| γ, 2 |) in
                      let dsl_ir :=
                        M.copy (|
                          Ty.path
                            "Type for variables in patterns in function parameters is not handled",
                          γ0_0
                        |) in
                      let opcode :=
                        M.copy (|
                          Ty.path
                            "Type for variables in patterns in function parameters is not handled",
                          γ0_1
                        |) in
                      let air_name :=
                        M.copy (|
                          Ty.path
                            "Type for variables in patterns in function parameters is not handled",
                          γ0_2
                        |) in
                      M.catch_return (Ty.tuple []) (|
                        ltac:(M.monadic
                          (M.read (|
                            let~ _ : Ty.tuple [] :=
                              M.match_operator (|
                                Ty.tuple [],
                                M.alloc (| Ty.tuple [], Value.Tuple [] |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ :=
                                        M.use
                                          (M.alloc (|
                                            Ty.path "bool",
                                            M.call_closure (|
                                              Ty.path "bool",
                                              BinOp.eq,
                                              [
                                                M.read (| trace_cells_used |);
                                                Value.Integer IntegerKind.Usize 0
                                              ]
                                            |)
                                          |)) in
                                      let _ :=
                                        is_constant_or_break_match (|
                                          M.read (| γ |),
                                          Value.Bool true
                                        |) in
                                      M.never_to_any (|
                                        M.read (| M.return_ (| Value.Tuple [] |) |)
                                      |)));
                                  fun γ => ltac:(M.monadic (Value.Tuple []))
                                ]
                              |) in
                            let~ labels :
                                Ty.apply
                                  (Ty.path "array")
                                  [ Value.Integer IntegerKind.Usize 4 ]
                                  [
                                    Ty.tuple
                                      [
                                        Ty.apply (Ty.path "&") [] [ Ty.path "str" ];
                                        Ty.path "alloc::string::String"
                                      ]
                                  ] :=
                              Value.Array
                                [
                                  Value.Tuple
                                    [
                                      mk_str (| "air_name" |);
                                      M.call_closure (|
                                        Ty.path "alloc::string::String",
                                        M.get_trait_method (|
                                          "core::clone::Clone",
                                          Ty.path "alloc::string::String",
                                          [],
                                          [],
                                          "clone",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (| M.read (| air_name |) |)
                                          |)
                                        ]
                                      |)
                                    ];
                                  Value.Tuple
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (| mk_str (| "opcode" |) |)
                                      |);
                                      M.call_closure (|
                                        Ty.path "alloc::string::String",
                                        M.get_trait_method (|
                                          "core::clone::Clone",
                                          Ty.path "alloc::string::String",
                                          [],
                                          [],
                                          "clone",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (| M.read (| opcode |) |)
                                          |)
                                        ]
                                      |)
                                    ];
                                  Value.Tuple
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (| mk_str (| "dsl_ir" |) |)
                                      |);
                                      M.call_closure (|
                                        Ty.path "alloc::string::String",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "core::option::Option")
                                            []
                                            [ Ty.path "alloc::string::String" ],
                                          "unwrap_or_default",
                                          [],
                                          []
                                        |),
                                        [
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::option::Option")
                                              []
                                              [ Ty.path "alloc::string::String" ],
                                            M.get_trait_method (|
                                              "core::clone::Clone",
                                              Ty.apply
                                                (Ty.path "core::option::Option")
                                                []
                                                [ Ty.path "alloc::string::String" ],
                                              [],
                                              [],
                                              "clone",
                                              [],
                                              []
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.read (| dsl_ir |) |)
                                              |)
                                            ]
                                          |)
                                        ]
                                      |)
                                    ];
                                  Value.Tuple
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (| mk_str (| "cycle_tracker_span" |) |)
                                      |);
                                      M.call_closure (|
                                        Ty.path "alloc::string::String",
                                        M.get_associated_function (|
                                          Ty.path
                                            "openvm_circuit::metrics::cycle_tracker::CycleTracker",
                                          "get_full_name",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (| M.read (| self |) |)
                                          |)
                                        ]
                                      |)
                                    ]
                                ] in
                            let~ _ : Ty.tuple [] :=
                              M.call_closure (|
                                Ty.tuple [],
                                M.get_associated_function (|
                                  Ty.path "metrics::handles::Counter",
                                  "increment",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    let~ metric_key : Ty.path "metrics::key::Key" :=
                                      M.call_closure (|
                                        Ty.path "metrics::key::Key",
                                        M.get_associated_function (|
                                          Ty.path "metrics::key::Key",
                                          "from_parts",
                                          [],
                                          [
                                            Ty.apply (Ty.path "&") [] [ Ty.path "str" ];
                                            Ty.apply
                                              (Ty.path "&")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "array")
                                                  [ Value.Integer IntegerKind.Usize 4 ]
                                                  [
                                                    Ty.tuple
                                                      [
                                                        Ty.apply (Ty.path "&") [] [ Ty.path "str" ];
                                                        Ty.path "alloc::string::String"
                                                      ]
                                                  ]
                                              ]
                                          ]
                                        |),
                                        [
                                          mk_str (| "cells_used" |);
                                          M.borrow (| Pointer.Kind.Ref, labels |)
                                        ]
                                      |) in
                                    let~ metadata :
                                        Ty.apply
                                          (Ty.path "&")
                                          []
                                          [ Ty.path "metrics::metadata::Metadata" ] :=
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (|
                                          M.read (|
                                            get_constant (|
                                              "openvm_circuit::metrics::cycle_tracker::emit::increment_cells_used::METADATA",
                                              Ty.apply
                                                (Ty.path "&")
                                                []
                                                [ Ty.path "metrics::metadata::Metadata" ]
                                            |)
                                          |)
                                        |)
                                      |) in
                                    M.alloc (|
                                      Ty.path "metrics::handles::Counter",
                                      M.call_closure (|
                                        Ty.path "metrics::handles::Counter",
                                        M.get_function (|
                                          "metrics::recorder::with_recorder",
                                          [],
                                          [
                                            Ty.path "metrics::handles::Counter";
                                            Ty.function
                                              [
                                                Ty.apply
                                                  (Ty.path "&")
                                                  []
                                                  [
                                                    Ty.dyn
                                                      [ ("metrics::recorder::Recorder::Trait", []) ]
                                                  ]
                                              ]
                                              (Ty.path "metrics::handles::Counter")
                                          ]
                                        |),
                                        [
                                          M.closure
                                            (fun γ =>
                                              ltac:(M.monadic
                                                match γ with
                                                | [ α0 ] =>
                                                  ltac:(M.monadic
                                                    (M.match_operator (|
                                                      Ty.path "metrics::handles::Counter",
                                                      M.alloc (|
                                                        Ty.apply
                                                          (Ty.path "&")
                                                          []
                                                          [
                                                            Ty.dyn
                                                              [
                                                                ("metrics::recorder::Recorder::Trait",
                                                                  [])
                                                              ]
                                                          ],
                                                        α0
                                                      |),
                                                      [
                                                        fun γ =>
                                                          ltac:(M.monadic
                                                            (let recorder :=
                                                              M.copy (|
                                                                Ty.apply
                                                                  (Ty.path "&")
                                                                  []
                                                                  [
                                                                    Ty.dyn
                                                                      [
                                                                        ("metrics::recorder::Recorder::Trait",
                                                                          [])
                                                                      ]
                                                                  ],
                                                                γ
                                                              |) in
                                                            M.call_closure (|
                                                              Ty.path "metrics::handles::Counter",
                                                              M.get_trait_method (|
                                                                "metrics::recorder::Recorder",
                                                                Ty.dyn
                                                                  [
                                                                    ("metrics::recorder::Recorder::Trait",
                                                                      [])
                                                                  ],
                                                                [],
                                                                [],
                                                                "register_counter",
                                                                [],
                                                                []
                                                              |),
                                                              [
                                                                M.borrow (|
                                                                  Pointer.Kind.Ref,
                                                                  M.deref (|
                                                                    M.read (| recorder |)
                                                                  |)
                                                                |);
                                                                M.borrow (|
                                                                  Pointer.Kind.Ref,
                                                                  M.deref (|
                                                                    M.borrow (|
                                                                      Pointer.Kind.Ref,
                                                                      metric_key
                                                                    |)
                                                                  |)
                                                                |);
                                                                M.borrow (|
                                                                  Pointer.Kind.Ref,
                                                                  M.deref (|
                                                                    M.read (| metadata |)
                                                                  |)
                                                                |)
                                                              ]
                                                            |)))
                                                      ]
                                                    |)))
                                                | _ => M.impossible "wrong number of arguments"
                                                end))
                                        ]
                                      |)
                                    |)
                                  |);
                                  M.cast (Ty.path "u64") (M.read (| trace_cells_used |))
                                ]
                              |) in
                            M.alloc (| Ty.tuple [], Value.Tuple [] |)
                          |)))
                      |)))
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Global Instance AssociatedFunction_increment_cells_used :
          M.IsAssociatedFunction.C Self "increment_cells_used" increment_cells_used.
        Admitted.
        Global Typeclasses Opaque increment_cells_used.
      End Impl_openvm_circuit_metrics_cycle_tracker_CycleTracker.
    End emit.
  End cycle_tracker.
End metrics.
