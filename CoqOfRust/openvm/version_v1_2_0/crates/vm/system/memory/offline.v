(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module system.
  Module memory.
    Module offline.
      Definition value_INITIAL_TIMESTAMP
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        ltac:(M.monadic (M.alloc (| Ty.path "u32", Value.Integer IntegerKind.U32 0 |))).
      
      Global Instance Instance_IsConstant_value_INITIAL_TIMESTAMP :
        M.IsFunction.C
          "openvm_circuit::system::memory::offline::INITIAL_TIMESTAMP"
          value_INITIAL_TIMESTAMP.
      Admitted.
      Global Typeclasses Opaque value_INITIAL_TIMESTAMP.
      
      (* StructRecord
        {
          name := "BlockData";
          const_params := [];
          ty_params := [];
          fields :=
            [ ("pointer", Ty.path "u32"); ("timestamp", Ty.path "u32"); ("size", Ty.path "usize") ];
        } *)
      
      Module Impl_core_clone_Clone_for_openvm_circuit_system_memory_offline_BlockData.
        Definition Self : Ty.t := Ty.path "openvm_circuit::system::memory::offline::BlockData".
        
        (* Clone *)
        Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self :=
                M.alloc (|
                  Ty.apply
                    (Ty.path "&")
                    []
                    [ Ty.path "openvm_circuit::system::memory::offline::BlockData" ],
                  self
                |) in
              Value.mkStructRecord
                "openvm_circuit::system::memory::offline::BlockData"
                []
                []
                [
                  ("pointer",
                    M.call_closure (|
                      Ty.path "u32",
                      M.get_trait_method (|
                        "core::clone::Clone",
                        Ty.path "u32",
                        [],
                        [],
                        "clone",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (|
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "openvm_circuit::system::memory::offline::BlockData",
                                "pointer"
                              |)
                            |)
                          |)
                        |)
                      ]
                    |));
                  ("timestamp",
                    M.call_closure (|
                      Ty.path "u32",
                      M.get_trait_method (|
                        "core::clone::Clone",
                        Ty.path "u32",
                        [],
                        [],
                        "clone",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (|
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "openvm_circuit::system::memory::offline::BlockData",
                                "timestamp"
                              |)
                            |)
                          |)
                        |)
                      ]
                    |));
                  ("size",
                    M.call_closure (|
                      Ty.path "usize",
                      M.get_trait_method (|
                        "core::clone::Clone",
                        Ty.path "usize",
                        [],
                        [],
                        "clone",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (|
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "openvm_circuit::system::memory::offline::BlockData",
                                "size"
                              |)
                            |)
                          |)
                        |)
                      ]
                    |))
                ]))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::clone::Clone"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) []
            Self
            (* Instance *) [ ("clone", InstanceField.Method clone) ].
      End Impl_core_clone_Clone_for_openvm_circuit_system_memory_offline_BlockData.
      
      Module Impl_core_default_Default_for_openvm_circuit_system_memory_offline_BlockData.
        Definition Self : Ty.t := Ty.path "openvm_circuit::system::memory::offline::BlockData".
        
        (* Default *)
        Definition default (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          match ε, τ, α with
          | [], [], [] =>
            ltac:(M.monadic
              (Value.mkStructRecord
                "openvm_circuit::system::memory::offline::BlockData"
                []
                []
                [
                  ("pointer",
                    M.call_closure (|
                      Ty.path "u32",
                      M.get_trait_method (|
                        "core::default::Default",
                        Ty.path "u32",
                        [],
                        [],
                        "default",
                        [],
                        []
                      |),
                      []
                    |));
                  ("timestamp",
                    M.call_closure (|
                      Ty.path "u32",
                      M.get_trait_method (|
                        "core::default::Default",
                        Ty.path "u32",
                        [],
                        [],
                        "default",
                        [],
                        []
                      |),
                      []
                    |));
                  ("size",
                    M.call_closure (|
                      Ty.path "usize",
                      M.get_trait_method (|
                        "core::default::Default",
                        Ty.path "usize",
                        [],
                        [],
                        "default",
                        [],
                        []
                      |),
                      []
                    |))
                ]))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::default::Default"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) []
            Self
            (* Instance *) [ ("default", InstanceField.Method default) ].
      End Impl_core_default_Default_for_openvm_circuit_system_memory_offline_BlockData.
      
      Module Impl_core_marker_StructuralPartialEq_for_openvm_circuit_system_memory_offline_BlockData.
        Definition Self : Ty.t := Ty.path "openvm_circuit::system::memory::offline::BlockData".
        
        Axiom Implements :
          M.IsTraitInstance
            "core::marker::StructuralPartialEq"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) []
            Self
            (* Instance *) [].
      End Impl_core_marker_StructuralPartialEq_for_openvm_circuit_system_memory_offline_BlockData.
      
      Module Impl_core_cmp_PartialEq_openvm_circuit_system_memory_offline_BlockData_for_openvm_circuit_system_memory_offline_BlockData.
        Definition Self : Ty.t := Ty.path "openvm_circuit::system::memory::offline::BlockData".
        
        (* PartialEq *)
        Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          match ε, τ, α with
          | [], [], [ self; other ] =>
            ltac:(M.monadic
              (let self :=
                M.alloc (|
                  Ty.apply
                    (Ty.path "&")
                    []
                    [ Ty.path "openvm_circuit::system::memory::offline::BlockData" ],
                  self
                |) in
              let other :=
                M.alloc (|
                  Ty.apply
                    (Ty.path "&")
                    []
                    [ Ty.path "openvm_circuit::system::memory::offline::BlockData" ],
                  other
                |) in
              LogicalOp.and (|
                LogicalOp.and (|
                  M.call_closure (|
                    Ty.path "bool",
                    BinOp.eq,
                    [
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "openvm_circuit::system::memory::offline::BlockData",
                          "pointer"
                        |)
                      |);
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| other |) |),
                          "openvm_circuit::system::memory::offline::BlockData",
                          "pointer"
                        |)
                      |)
                    ]
                  |),
                  ltac:(M.monadic
                    (M.call_closure (|
                      Ty.path "bool",
                      BinOp.eq,
                      [
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "openvm_circuit::system::memory::offline::BlockData",
                            "timestamp"
                          |)
                        |);
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| other |) |),
                            "openvm_circuit::system::memory::offline::BlockData",
                            "timestamp"
                          |)
                        |)
                      ]
                    |)))
                |),
                ltac:(M.monadic
                  (M.call_closure (|
                    Ty.path "bool",
                    BinOp.eq,
                    [
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "openvm_circuit::system::memory::offline::BlockData",
                          "size"
                        |)
                      |);
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| other |) |),
                          "openvm_circuit::system::memory::offline::BlockData",
                          "size"
                        |)
                      |)
                    ]
                  |)))
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::cmp::PartialEq"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *)
            [ Ty.path "openvm_circuit::system::memory::offline::BlockData" ]
            Self
            (* Instance *) [ ("eq", InstanceField.Method eq) ].
      End Impl_core_cmp_PartialEq_openvm_circuit_system_memory_offline_BlockData_for_openvm_circuit_system_memory_offline_BlockData.
      
      Module Impl_core_cmp_Eq_for_openvm_circuit_system_memory_offline_BlockData.
        Definition Self : Ty.t := Ty.path "openvm_circuit::system::memory::offline::BlockData".
        
        (* Eq *)
        Definition assert_receiver_is_total_eq
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self :=
                M.alloc (|
                  Ty.apply
                    (Ty.path "&")
                    []
                    [ Ty.path "openvm_circuit::system::memory::offline::BlockData" ],
                  self
                |) in
              M.match_operator (|
                Ty.tuple [],
                Value.DeclaredButUndefined,
                [
                  fun γ =>
                    ltac:(M.monadic
                      (M.match_operator (|
                        Ty.tuple [],
                        Value.DeclaredButUndefined,
                        [ fun γ => ltac:(M.monadic (Value.Tuple [])) ]
                      |)))
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::cmp::Eq"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) []
            Self
            (* Instance *)
            [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
      End Impl_core_cmp_Eq_for_openvm_circuit_system_memory_offline_BlockData.
      
      Module Impl_core_fmt_Debug_for_openvm_circuit_system_memory_offline_BlockData.
        Definition Self : Ty.t := Ty.path "openvm_circuit::system::memory::offline::BlockData".
        
        (* Debug *)
        Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          match ε, τ, α with
          | [], [], [ self; f ] =>
            ltac:(M.monadic
              (let self :=
                M.alloc (|
                  Ty.apply
                    (Ty.path "&")
                    []
                    [ Ty.path "openvm_circuit::system::memory::offline::BlockData" ],
                  self
                |) in
              let f :=
                M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "core::fmt::Formatter" ], f |) in
              M.call_closure (|
                Ty.apply
                  (Ty.path "core::result::Result")
                  []
                  [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                M.get_associated_function (|
                  Ty.path "core::fmt::Formatter",
                  "debug_struct_field3_finish",
                  [],
                  []
                |),
                [
                  M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                  M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "BlockData" |) |) |);
                  M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "pointer" |) |) |);
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ],
                    M.pointer_coercion
                      M.PointerCoercion.Unsize
                      (Ty.apply (Ty.path "&") [] [ Ty.path "u32" ])
                      (Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ]),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "openvm_circuit::system::memory::offline::BlockData",
                              "pointer"
                            |)
                          |)
                        |)
                      |)
                    ]
                  |);
                  M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "timestamp" |) |) |);
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ],
                    M.pointer_coercion
                      M.PointerCoercion.Unsize
                      (Ty.apply (Ty.path "&") [] [ Ty.path "u32" ])
                      (Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ]),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "openvm_circuit::system::memory::offline::BlockData",
                              "timestamp"
                            |)
                          |)
                        |)
                      |)
                    ]
                  |);
                  M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "size" |) |) |);
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ],
                    M.pointer_coercion
                      M.PointerCoercion.Unsize
                      (Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "&") [] [ Ty.path "usize" ] ])
                      (Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ]),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.alloc (|
                              Ty.apply (Ty.path "&") [] [ Ty.path "usize" ],
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "openvm_circuit::system::memory::offline::BlockData",
                                  "size"
                                |)
                              |)
                            |)
                          |)
                        |)
                      |)
                    ]
                  |)
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          M.IsTraitInstance
            "core::fmt::Debug"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) []
            Self
            (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
      End Impl_core_fmt_Debug_for_openvm_circuit_system_memory_offline_BlockData.
      
      (* StructRecord
        {
          name := "BlockMap";
          const_params := [];
          ty_params := [];
          fields :=
            [
              ("id",
                Ty.apply
                  (Ty.path "openvm_circuit::system::memory::paged_vec::AddressMap")
                  [
                    M.unevaluated_const
                      (mk_str (| "openvm_circuit_system_memory_offline_BlockMap_discriminant" |))
                  ]
                  [ Ty.path "usize" ]);
              ("storage",
                Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  []
                  [
                    Ty.path "openvm_circuit::system::memory::offline::BlockData";
                    Ty.path "alloc::alloc::Global"
                  ]);
              ("initial_block_size", Ty.path "usize")
            ];
        } *)
      
      Module Impl_openvm_circuit_system_memory_offline_BlockMap.
        Definition Self : Ty.t := Ty.path "openvm_circuit::system::memory::offline::BlockMap".
        
        (*
            pub fn from_mem_config(mem_config: &MemoryConfig, initial_block_size: usize) -> Self {
                assert!(initial_block_size.is_power_of_two());
                Self {
                    id: AddressMap::from_mem_config(mem_config),
                    storage: vec![],
                    initial_block_size,
                }
            }
        *)
        Definition from_mem_config (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          match ε, τ, α with
          | [], [], [ mem_config; initial_block_size ] =>
            ltac:(M.monadic
              (let mem_config :=
                M.alloc (|
                  Ty.apply
                    (Ty.path "&")
                    []
                    [ Ty.path "openvm_circuit::arch::config::MemoryConfig" ],
                  mem_config
                |) in
              let initial_block_size := M.alloc (| Ty.path "usize", initial_block_size |) in
              M.read (|
                let~ _ : Ty.tuple [] :=
                  M.match_operator (|
                    Ty.tuple [],
                    M.alloc (| Ty.tuple [], Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                Ty.path "bool",
                                UnOp.not (|
                                  M.call_closure (|
                                    Ty.path "bool",
                                    M.get_associated_function (|
                                      Ty.path "usize",
                                      "is_power_of_two",
                                      [],
                                      []
                                    |),
                                    [ M.read (| initial_block_size |) ]
                                  |)
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.never_to_any (|
                            M.call_closure (|
                              Ty.path "never",
                              M.get_function (| "core::panicking::panic", [], [] |),
                              [
                                mk_str (|
                                  "assertion failed: initial_block_size.is_power_of_two()"
                                |)
                              ]
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (Value.Tuple []))
                    ]
                  |) in
                M.alloc (|
                  Ty.path "openvm_circuit::system::memory::offline::BlockMap",
                  Value.mkStructRecord
                    "openvm_circuit::system::memory::offline::BlockMap"
                    []
                    []
                    [
                      ("id",
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "openvm_circuit::system::memory::paged_vec::AddressMap")
                            [ Value.Integer IntegerKind.Usize 4096 ]
                            [ Ty.path "usize" ],
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "openvm_circuit::system::memory::paged_vec::AddressMap")
                              [ Value.Integer IntegerKind.Usize 4096 ]
                              [ Ty.path "usize" ],
                            "from_mem_config",
                            [],
                            []
                          |),
                          [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| mem_config |) |) |) ]
                        |));
                      ("storage",
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            []
                            [
                              Ty.path "openvm_circuit::system::memory::offline::BlockData";
                              Ty.path "alloc::alloc::Global"
                            ],
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              []
                              [
                                Ty.path "openvm_circuit::system::memory::offline::BlockData";
                                Ty.path "alloc::alloc::Global"
                              ],
                            "new",
                            [],
                            []
                          |),
                          []
                        |));
                      ("initial_block_size", M.read (| initial_block_size |))
                    ]
                |)
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Global Instance AssociatedFunction_from_mem_config :
          M.IsAssociatedFunction.C Self "from_mem_config" from_mem_config.
        Admitted.
        Global Typeclasses Opaque from_mem_config.
        
        (*
            fn initial_block_data(pointer: u32, initial_block_size: usize) -> BlockData {
                let aligned_pointer = (pointer / initial_block_size as u32) * initial_block_size as u32;
                BlockData {
                    pointer: aligned_pointer,
                    size: initial_block_size,
                    timestamp: INITIAL_TIMESTAMP,
                }
            }
        *)
        Definition initial_block_data (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          match ε, τ, α with
          | [], [], [ pointer; initial_block_size ] =>
            ltac:(M.monadic
              (let pointer := M.alloc (| Ty.path "u32", pointer |) in
              let initial_block_size := M.alloc (| Ty.path "usize", initial_block_size |) in
              M.read (|
                let~ aligned_pointer : Ty.path "u32" :=
                  M.call_closure (|
                    Ty.path "u32",
                    BinOp.Wrap.mul,
                    [
                      M.call_closure (|
                        Ty.path "u32",
                        BinOp.Wrap.div,
                        [
                          M.read (| pointer |);
                          M.cast (Ty.path "u32") (M.read (| initial_block_size |))
                        ]
                      |);
                      M.cast (Ty.path "u32") (M.read (| initial_block_size |))
                    ]
                  |) in
                M.alloc (|
                  Ty.path "openvm_circuit::system::memory::offline::BlockData",
                  Value.mkStructRecord
                    "openvm_circuit::system::memory::offline::BlockData"
                    []
                    []
                    [
                      ("pointer", M.read (| aligned_pointer |));
                      ("size", M.read (| initial_block_size |));
                      ("timestamp",
                        M.read (|
                          get_constant (|
                            "openvm_circuit::system::memory::offline::INITIAL_TIMESTAMP",
                            Ty.path "u32"
                          |)
                        |))
                    ]
                |)
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Global Instance AssociatedFunction_initial_block_data :
          M.IsAssociatedFunction.C Self "initial_block_data" initial_block_data.
        Admitted.
        Global Typeclasses Opaque initial_block_data.
        
        (*
            pub fn get_without_adding(&self, address: &(u32, u32)) -> BlockData {
                let idx = self.id.get(address).unwrap_or(&0);
                if idx == &0 {
                    Self::initial_block_data(address.1, self.initial_block_size)
                } else {
                    self.storage[idx - 1].clone()
                }
            }
        *)
        Definition get_without_adding (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          match ε, τ, α with
          | [], [], [ self; address ] =>
            ltac:(M.monadic
              (let self :=
                M.alloc (|
                  Ty.apply
                    (Ty.path "&")
                    []
                    [ Ty.path "openvm_circuit::system::memory::offline::BlockMap" ],
                  self
                |) in
              let address :=
                M.alloc (|
                  Ty.apply (Ty.path "&") [] [ Ty.tuple [ Ty.path "u32"; Ty.path "u32" ] ],
                  address
                |) in
              M.read (|
                let~ idx : Ty.apply (Ty.path "&") [] [ Ty.path "usize" ] :=
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ Ty.path "usize" ],
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "core::option::Option")
                        []
                        [ Ty.apply (Ty.path "&") [] [ Ty.path "usize" ] ],
                      "unwrap_or",
                      [],
                      []
                    |),
                    [
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::option::Option")
                          []
                          [ Ty.apply (Ty.path "&") [] [ Ty.path "usize" ] ],
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "openvm_circuit::system::memory::paged_vec::AddressMap")
                            [ Value.Integer IntegerKind.Usize 4096 ]
                            [ Ty.path "usize" ],
                          "get",
                          [],
                          []
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "openvm_circuit::system::memory::offline::BlockMap",
                              "id"
                            |)
                          |);
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| address |) |) |)
                        ]
                      |);
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.alloc (| Ty.path "usize", Value.Integer IntegerKind.Usize 0 |)
                          |)
                        |)
                      |)
                    ]
                  |) in
                M.alloc (|
                  Ty.path "openvm_circuit::system::memory::offline::BlockData",
                  M.match_operator (|
                    Ty.path "openvm_circuit::system::memory::offline::BlockData",
                    M.alloc (| Ty.tuple [], Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                Ty.path "bool",
                                M.call_closure (|
                                  Ty.path "bool",
                                  M.get_trait_method (|
                                    "core::cmp::PartialEq",
                                    Ty.apply (Ty.path "&") [] [ Ty.path "usize" ],
                                    [],
                                    [ Ty.apply (Ty.path "&") [] [ Ty.path "usize" ] ],
                                    "eq",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (| Pointer.Kind.Ref, idx |);
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.alloc (|
                                        Ty.apply (Ty.path "&") [] [ Ty.path "usize" ],
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.alloc (|
                                            Ty.path "usize",
                                            Value.Integer IntegerKind.Usize 0
                                          |)
                                        |)
                                      |)
                                    |)
                                  ]
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.call_closure (|
                            Ty.path "openvm_circuit::system::memory::offline::BlockData",
                            M.get_associated_function (|
                              Ty.path "openvm_circuit::system::memory::offline::BlockMap",
                              "initial_block_data",
                              [],
                              []
                            |),
                            [
                              M.read (|
                                M.SubPointer.get_tuple_field (|
                                  M.deref (| M.read (| address |) |),
                                  1
                                |)
                              |);
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "openvm_circuit::system::memory::offline::BlockMap",
                                  "initial_block_size"
                                |)
                              |)
                            ]
                          |)));
                      fun γ =>
                        ltac:(M.monadic
                          (M.call_closure (|
                            Ty.path "openvm_circuit::system::memory::offline::BlockData",
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.path "openvm_circuit::system::memory::offline::BlockData",
                              [],
                              [],
                              "clone",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [ Ty.path "openvm_circuit::system::memory::offline::BlockData"
                                      ],
                                    M.get_trait_method (|
                                      "core::ops::index::Index",
                                      Ty.apply
                                        (Ty.path "alloc::vec::Vec")
                                        []
                                        [
                                          Ty.path
                                            "openvm_circuit::system::memory::offline::BlockData";
                                          Ty.path "alloc::alloc::Global"
                                        ],
                                      [],
                                      [ Ty.path "usize" ],
                                      "index",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.SubPointer.get_struct_record_field (|
                                          M.deref (| M.read (| self |) |),
                                          "openvm_circuit::system::memory::offline::BlockMap",
                                          "storage"
                                        |)
                                      |);
                                      M.call_closure (|
                                        Ty.path "usize",
                                        M.get_trait_method (|
                                          "core::ops::arith::Sub",
                                          Ty.apply (Ty.path "&") [] [ Ty.path "usize" ],
                                          [],
                                          [ Ty.path "usize" ],
                                          "sub",
                                          [],
                                          []
                                        |),
                                        [ M.read (| idx |); Value.Integer IntegerKind.Usize 1 ]
                                      |)
                                    ]
                                  |)
                                |)
                              |)
                            ]
                          |)))
                    ]
                  |)
                |)
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Global Instance AssociatedFunction_get_without_adding :
          M.IsAssociatedFunction.C Self "get_without_adding" get_without_adding.
        Admitted.
        Global Typeclasses Opaque get_without_adding.
        
        (*
            pub fn get(&mut self, address: &(u32, u32)) -> &BlockData {
                let (address_space, pointer) = *address;
                let idx = self.id.get(&(address_space, pointer)).unwrap_or(&0);
                if idx == &0 {
                    // `initial_block_size` is a power of two, as asserted in `from_mem_config`.
                    let pointer = pointer & !(self.initial_block_size as u32 - 1);
                    self.set_range(
                        &(address_space, pointer),
                        self.initial_block_size,
                        Self::initial_block_data(pointer, self.initial_block_size),
                    );
                    self.storage.last().unwrap()
                } else {
                    &self.storage[idx - 1]
                }
            }
        *)
        Definition get (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          match ε, τ, α with
          | [], [], [ self; address ] =>
            ltac:(M.monadic
              (let self :=
                M.alloc (|
                  Ty.apply
                    (Ty.path "&mut")
                    []
                    [ Ty.path "openvm_circuit::system::memory::offline::BlockMap" ],
                  self
                |) in
              let address :=
                M.alloc (|
                  Ty.apply (Ty.path "&") [] [ Ty.tuple [ Ty.path "u32"; Ty.path "u32" ] ],
                  address
                |) in
              M.match_operator (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.path "openvm_circuit::system::memory::offline::BlockData" ],
                M.deref (| M.read (| address |) |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let address_space := M.copy (| Ty.path "u32", γ0_0 |) in
                      let pointer := M.copy (| Ty.path "u32", γ0_1 |) in
                      M.read (|
                        let~ idx : Ty.apply (Ty.path "&") [] [ Ty.path "usize" ] :=
                          M.call_closure (|
                            Ty.apply (Ty.path "&") [] [ Ty.path "usize" ],
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "core::option::Option")
                                []
                                [ Ty.apply (Ty.path "&") [] [ Ty.path "usize" ] ],
                              "unwrap_or",
                              [],
                              []
                            |),
                            [
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::option::Option")
                                  []
                                  [ Ty.apply (Ty.path "&") [] [ Ty.path "usize" ] ],
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path
                                      "openvm_circuit::system::memory::paged_vec::AddressMap")
                                    [ Value.Integer IntegerKind.Usize 4096 ]
                                    [ Ty.path "usize" ],
                                  "get",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "openvm_circuit::system::memory::offline::BlockMap",
                                      "id"
                                    |)
                                  |);
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.alloc (|
                                          Ty.tuple [ Ty.path "u32"; Ty.path "u32" ],
                                          Value.Tuple
                                            [ M.read (| address_space |); M.read (| pointer |) ]
                                        |)
                                      |)
                                    |)
                                  |)
                                ]
                              |);
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (|
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.alloc (| Ty.path "usize", Value.Integer IntegerKind.Usize 0 |)
                                  |)
                                |)
                              |)
                            ]
                          |) in
                        M.alloc (|
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.path "openvm_circuit::system::memory::offline::BlockData" ],
                          M.match_operator (|
                            Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.path "openvm_circuit::system::memory::offline::BlockData" ],
                            M.alloc (| Ty.tuple [], Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ :=
                                    M.use
                                      (M.alloc (|
                                        Ty.path "bool",
                                        M.call_closure (|
                                          Ty.path "bool",
                                          M.get_trait_method (|
                                            "core::cmp::PartialEq",
                                            Ty.apply (Ty.path "&") [] [ Ty.path "usize" ],
                                            [],
                                            [ Ty.apply (Ty.path "&") [] [ Ty.path "usize" ] ],
                                            "eq",
                                            [],
                                            []
                                          |),
                                          [
                                            M.borrow (| Pointer.Kind.Ref, idx |);
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.alloc (|
                                                Ty.apply (Ty.path "&") [] [ Ty.path "usize" ],
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.alloc (|
                                                    Ty.path "usize",
                                                    Value.Integer IntegerKind.Usize 0
                                                  |)
                                                |)
                                              |)
                                            |)
                                          ]
                                        |)
                                      |)) in
                                  let _ :=
                                    is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  M.read (|
                                    let~ pointer : Ty.path "u32" :=
                                      M.call_closure (|
                                        Ty.path "u32",
                                        BinOp.Wrap.bit_and,
                                        [
                                          M.read (| pointer |);
                                          UnOp.not (|
                                            M.call_closure (|
                                              Ty.path "u32",
                                              BinOp.Wrap.sub,
                                              [
                                                M.cast
                                                  (Ty.path "u32")
                                                  (M.read (|
                                                    M.SubPointer.get_struct_record_field (|
                                                      M.deref (| M.read (| self |) |),
                                                      "openvm_circuit::system::memory::offline::BlockMap",
                                                      "initial_block_size"
                                                    |)
                                                  |));
                                                Value.Integer IntegerKind.U32 1
                                              ]
                                            |)
                                          |)
                                        ]
                                      |) in
                                    let~ _ : Ty.tuple [] :=
                                      M.call_closure (|
                                        Ty.tuple [],
                                        M.get_associated_function (|
                                          Ty.path
                                            "openvm_circuit::system::memory::offline::BlockMap",
                                          "set_range",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.MutRef,
                                            M.deref (| M.read (| self |) |)
                                          |);
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (|
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.alloc (|
                                                  Ty.tuple [ Ty.path "u32"; Ty.path "u32" ],
                                                  Value.Tuple
                                                    [
                                                      M.read (| address_space |);
                                                      M.read (| pointer |)
                                                    ]
                                                |)
                                              |)
                                            |)
                                          |);
                                          M.read (|
                                            M.SubPointer.get_struct_record_field (|
                                              M.deref (| M.read (| self |) |),
                                              "openvm_circuit::system::memory::offline::BlockMap",
                                              "initial_block_size"
                                            |)
                                          |);
                                          M.call_closure (|
                                            Ty.path
                                              "openvm_circuit::system::memory::offline::BlockData",
                                            M.get_associated_function (|
                                              Ty.path
                                                "openvm_circuit::system::memory::offline::BlockMap",
                                              "initial_block_data",
                                              [],
                                              []
                                            |),
                                            [
                                              M.read (| pointer |);
                                              M.read (|
                                                M.SubPointer.get_struct_record_field (|
                                                  M.deref (| M.read (| self |) |),
                                                  "openvm_circuit::system::memory::offline::BlockMap",
                                                  "initial_block_size"
                                                |)
                                              |)
                                            ]
                                          |)
                                        ]
                                      |) in
                                    M.alloc (|
                                      Ty.apply
                                        (Ty.path "&")
                                        []
                                        [
                                          Ty.path
                                            "openvm_circuit::system::memory::offline::BlockData"
                                        ],
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "&")
                                              []
                                              [
                                                Ty.path
                                                  "openvm_circuit::system::memory::offline::BlockData"
                                              ],
                                            M.get_associated_function (|
                                              Ty.apply
                                                (Ty.path "core::option::Option")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "&")
                                                    []
                                                    [
                                                      Ty.path
                                                        "openvm_circuit::system::memory::offline::BlockData"
                                                    ]
                                                ],
                                              "unwrap",
                                              [],
                                              []
                                            |),
                                            [
                                              M.call_closure (|
                                                Ty.apply
                                                  (Ty.path "core::option::Option")
                                                  []
                                                  [
                                                    Ty.apply
                                                      (Ty.path "&")
                                                      []
                                                      [
                                                        Ty.path
                                                          "openvm_circuit::system::memory::offline::BlockData"
                                                      ]
                                                  ],
                                                M.get_associated_function (|
                                                  Ty.apply
                                                    (Ty.path "slice")
                                                    []
                                                    [
                                                      Ty.path
                                                        "openvm_circuit::system::memory::offline::BlockData"
                                                    ],
                                                  "last",
                                                  [],
                                                  []
                                                |),
                                                [
                                                  M.borrow (|
                                                    Pointer.Kind.Ref,
                                                    M.deref (|
                                                      M.call_closure (|
                                                        Ty.apply
                                                          (Ty.path "&")
                                                          []
                                                          [
                                                            Ty.apply
                                                              (Ty.path "slice")
                                                              []
                                                              [
                                                                Ty.path
                                                                  "openvm_circuit::system::memory::offline::BlockData"
                                                              ]
                                                          ],
                                                        M.get_trait_method (|
                                                          "core::ops::deref::Deref",
                                                          Ty.apply
                                                            (Ty.path "alloc::vec::Vec")
                                                            []
                                                            [
                                                              Ty.path
                                                                "openvm_circuit::system::memory::offline::BlockData";
                                                              Ty.path "alloc::alloc::Global"
                                                            ],
                                                          [],
                                                          [],
                                                          "deref",
                                                          [],
                                                          []
                                                        |),
                                                        [
                                                          M.borrow (|
                                                            Pointer.Kind.Ref,
                                                            M.SubPointer.get_struct_record_field (|
                                                              M.deref (| M.read (| self |) |),
                                                              "openvm_circuit::system::memory::offline::BlockMap",
                                                              "storage"
                                                            |)
                                                          |)
                                                        ]
                                                      |)
                                                    |)
                                                  |)
                                                ]
                                              |)
                                            ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "&")
                                              []
                                              [
                                                Ty.path
                                                  "openvm_circuit::system::memory::offline::BlockData"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::index::Index",
                                              Ty.apply
                                                (Ty.path "alloc::vec::Vec")
                                                []
                                                [
                                                  Ty.path
                                                    "openvm_circuit::system::memory::offline::BlockData";
                                                  Ty.path "alloc::alloc::Global"
                                                ],
                                              [],
                                              [ Ty.path "usize" ],
                                              "index",
                                              [],
                                              []
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.SubPointer.get_struct_record_field (|
                                                  M.deref (| M.read (| self |) |),
                                                  "openvm_circuit::system::memory::offline::BlockMap",
                                                  "storage"
                                                |)
                                              |);
                                              M.call_closure (|
                                                Ty.path "usize",
                                                M.get_trait_method (|
                                                  "core::ops::arith::Sub",
                                                  Ty.apply (Ty.path "&") [] [ Ty.path "usize" ],
                                                  [],
                                                  [ Ty.path "usize" ],
                                                  "sub",
                                                  [],
                                                  []
                                                |),
                                                [
                                                  M.read (| idx |);
                                                  Value.Integer IntegerKind.Usize 1
                                                ]
                                              |)
                                            ]
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)))
                            ]
                          |)
                        |)
                      |)))
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Global Instance AssociatedFunction_get : M.IsAssociatedFunction.C Self "get" get.
        Admitted.
        Global Typeclasses Opaque get.
        
        (*
            pub fn get_mut(&mut self, address: &(u32, u32)) -> &mut BlockData {
                let (address_space, pointer) = *address;
                let idx = self.id.get(&(address_space, pointer)).unwrap_or(&0);
                if idx == &0 {
                    let pointer = pointer - pointer % self.initial_block_size as u32;
                    self.set_range(
                        &(address_space, pointer),
                        self.initial_block_size,
                        Self::initial_block_data(pointer, self.initial_block_size),
                    );
                    self.storage.last_mut().unwrap()
                } else {
                    &mut self.storage[idx - 1]
                }
            }
        *)
        Definition get_mut (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          match ε, τ, α with
          | [], [], [ self; address ] =>
            ltac:(M.monadic
              (let self :=
                M.alloc (|
                  Ty.apply
                    (Ty.path "&mut")
                    []
                    [ Ty.path "openvm_circuit::system::memory::offline::BlockMap" ],
                  self
                |) in
              let address :=
                M.alloc (|
                  Ty.apply (Ty.path "&") [] [ Ty.tuple [ Ty.path "u32"; Ty.path "u32" ] ],
                  address
                |) in
              M.borrow (|
                Pointer.Kind.MutRef,
                M.deref (|
                  M.match_operator (|
                    Ty.apply
                      (Ty.path "&mut")
                      []
                      [ Ty.path "openvm_circuit::system::memory::offline::BlockData" ],
                    M.deref (| M.read (| address |) |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                          let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                          let address_space := M.copy (| Ty.path "u32", γ0_0 |) in
                          let pointer := M.copy (| Ty.path "u32", γ0_1 |) in
                          M.read (|
                            let~ idx : Ty.apply (Ty.path "&") [] [ Ty.path "usize" ] :=
                              M.call_closure (|
                                Ty.apply (Ty.path "&") [] [ Ty.path "usize" ],
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "core::option::Option")
                                    []
                                    [ Ty.apply (Ty.path "&") [] [ Ty.path "usize" ] ],
                                  "unwrap_or",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::option::Option")
                                      []
                                      [ Ty.apply (Ty.path "&") [] [ Ty.path "usize" ] ],
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path
                                          "openvm_circuit::system::memory::paged_vec::AddressMap")
                                        [ Value.Integer IntegerKind.Usize 4096 ]
                                        [ Ty.path "usize" ],
                                      "get",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.SubPointer.get_struct_record_field (|
                                          M.deref (| M.read (| self |) |),
                                          "openvm_circuit::system::memory::offline::BlockMap",
                                          "id"
                                        |)
                                      |);
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (|
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.alloc (|
                                              Ty.tuple [ Ty.path "u32"; Ty.path "u32" ],
                                              Value.Tuple
                                                [ M.read (| address_space |); M.read (| pointer |) ]
                                            |)
                                          |)
                                        |)
                                      |)
                                    ]
                                  |);
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.alloc (|
                                          Ty.path "usize",
                                          Value.Integer IntegerKind.Usize 0
                                        |)
                                      |)
                                    |)
                                  |)
                                ]
                              |) in
                            M.alloc (|
                              Ty.apply
                                (Ty.path "&mut")
                                []
                                [ Ty.path "openvm_circuit::system::memory::offline::BlockData" ],
                              M.borrow (|
                                Pointer.Kind.MutRef,
                                M.deref (|
                                  M.match_operator (|
                                    Ty.apply
                                      (Ty.path "&mut")
                                      []
                                      [ Ty.path "openvm_circuit::system::memory::offline::BlockData"
                                      ],
                                    M.alloc (| Ty.tuple [], Value.Tuple [] |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let γ :=
                                            M.use
                                              (M.alloc (|
                                                Ty.path "bool",
                                                M.call_closure (|
                                                  Ty.path "bool",
                                                  M.get_trait_method (|
                                                    "core::cmp::PartialEq",
                                                    Ty.apply (Ty.path "&") [] [ Ty.path "usize" ],
                                                    [],
                                                    [ Ty.apply (Ty.path "&") [] [ Ty.path "usize" ]
                                                    ],
                                                    "eq",
                                                    [],
                                                    []
                                                  |),
                                                  [
                                                    M.borrow (| Pointer.Kind.Ref, idx |);
                                                    M.borrow (|
                                                      Pointer.Kind.Ref,
                                                      M.alloc (|
                                                        Ty.apply
                                                          (Ty.path "&")
                                                          []
                                                          [ Ty.path "usize" ],
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.alloc (|
                                                            Ty.path "usize",
                                                            Value.Integer IntegerKind.Usize 0
                                                          |)
                                                        |)
                                                      |)
                                                    |)
                                                  ]
                                                |)
                                              |)) in
                                          let _ :=
                                            is_constant_or_break_match (|
                                              M.read (| γ |),
                                              Value.Bool true
                                            |) in
                                          M.borrow (|
                                            Pointer.Kind.MutRef,
                                            M.deref (|
                                              M.read (|
                                                let~ pointer : Ty.path "u32" :=
                                                  M.call_closure (|
                                                    Ty.path "u32",
                                                    BinOp.Wrap.sub,
                                                    [
                                                      M.read (| pointer |);
                                                      M.call_closure (|
                                                        Ty.path "u32",
                                                        BinOp.Wrap.rem,
                                                        [
                                                          M.read (| pointer |);
                                                          M.cast
                                                            (Ty.path "u32")
                                                            (M.read (|
                                                              M.SubPointer.get_struct_record_field (|
                                                                M.deref (| M.read (| self |) |),
                                                                "openvm_circuit::system::memory::offline::BlockMap",
                                                                "initial_block_size"
                                                              |)
                                                            |))
                                                        ]
                                                      |)
                                                    ]
                                                  |) in
                                                let~ _ : Ty.tuple [] :=
                                                  M.call_closure (|
                                                    Ty.tuple [],
                                                    M.get_associated_function (|
                                                      Ty.path
                                                        "openvm_circuit::system::memory::offline::BlockMap",
                                                      "set_range",
                                                      [],
                                                      []
                                                    |),
                                                    [
                                                      M.borrow (|
                                                        Pointer.Kind.MutRef,
                                                        M.deref (| M.read (| self |) |)
                                                      |);
                                                      M.borrow (|
                                                        Pointer.Kind.Ref,
                                                        M.deref (|
                                                          M.borrow (|
                                                            Pointer.Kind.Ref,
                                                            M.alloc (|
                                                              Ty.tuple
                                                                [ Ty.path "u32"; Ty.path "u32" ],
                                                              Value.Tuple
                                                                [
                                                                  M.read (| address_space |);
                                                                  M.read (| pointer |)
                                                                ]
                                                            |)
                                                          |)
                                                        |)
                                                      |);
                                                      M.read (|
                                                        M.SubPointer.get_struct_record_field (|
                                                          M.deref (| M.read (| self |) |),
                                                          "openvm_circuit::system::memory::offline::BlockMap",
                                                          "initial_block_size"
                                                        |)
                                                      |);
                                                      M.call_closure (|
                                                        Ty.path
                                                          "openvm_circuit::system::memory::offline::BlockData",
                                                        M.get_associated_function (|
                                                          Ty.path
                                                            "openvm_circuit::system::memory::offline::BlockMap",
                                                          "initial_block_data",
                                                          [],
                                                          []
                                                        |),
                                                        [
                                                          M.read (| pointer |);
                                                          M.read (|
                                                            M.SubPointer.get_struct_record_field (|
                                                              M.deref (| M.read (| self |) |),
                                                              "openvm_circuit::system::memory::offline::BlockMap",
                                                              "initial_block_size"
                                                            |)
                                                          |)
                                                        ]
                                                      |)
                                                    ]
                                                  |) in
                                                M.alloc (|
                                                  Ty.apply
                                                    (Ty.path "&mut")
                                                    []
                                                    [
                                                      Ty.path
                                                        "openvm_circuit::system::memory::offline::BlockData"
                                                    ],
                                                  M.borrow (|
                                                    Pointer.Kind.MutRef,
                                                    M.deref (|
                                                      M.call_closure (|
                                                        Ty.apply
                                                          (Ty.path "&mut")
                                                          []
                                                          [
                                                            Ty.path
                                                              "openvm_circuit::system::memory::offline::BlockData"
                                                          ],
                                                        M.get_associated_function (|
                                                          Ty.apply
                                                            (Ty.path "core::option::Option")
                                                            []
                                                            [
                                                              Ty.apply
                                                                (Ty.path "&mut")
                                                                []
                                                                [
                                                                  Ty.path
                                                                    "openvm_circuit::system::memory::offline::BlockData"
                                                                ]
                                                            ],
                                                          "unwrap",
                                                          [],
                                                          []
                                                        |),
                                                        [
                                                          M.call_closure (|
                                                            Ty.apply
                                                              (Ty.path "core::option::Option")
                                                              []
                                                              [
                                                                Ty.apply
                                                                  (Ty.path "&mut")
                                                                  []
                                                                  [
                                                                    Ty.path
                                                                      "openvm_circuit::system::memory::offline::BlockData"
                                                                  ]
                                                              ],
                                                            M.get_associated_function (|
                                                              Ty.apply
                                                                (Ty.path "slice")
                                                                []
                                                                [
                                                                  Ty.path
                                                                    "openvm_circuit::system::memory::offline::BlockData"
                                                                ],
                                                              "last_mut",
                                                              [],
                                                              []
                                                            |),
                                                            [
                                                              M.borrow (|
                                                                Pointer.Kind.MutRef,
                                                                M.deref (|
                                                                  M.call_closure (|
                                                                    Ty.apply
                                                                      (Ty.path "&mut")
                                                                      []
                                                                      [
                                                                        Ty.apply
                                                                          (Ty.path "slice")
                                                                          []
                                                                          [
                                                                            Ty.path
                                                                              "openvm_circuit::system::memory::offline::BlockData"
                                                                          ]
                                                                      ],
                                                                    M.get_trait_method (|
                                                                      "core::ops::deref::DerefMut",
                                                                      Ty.apply
                                                                        (Ty.path "alloc::vec::Vec")
                                                                        []
                                                                        [
                                                                          Ty.path
                                                                            "openvm_circuit::system::memory::offline::BlockData";
                                                                          Ty.path
                                                                            "alloc::alloc::Global"
                                                                        ],
                                                                      [],
                                                                      [],
                                                                      "deref_mut",
                                                                      [],
                                                                      []
                                                                    |),
                                                                    [
                                                                      M.borrow (|
                                                                        Pointer.Kind.MutRef,
                                                                        M.SubPointer.get_struct_record_field (|
                                                                          M.deref (|
                                                                            M.read (| self |)
                                                                          |),
                                                                          "openvm_circuit::system::memory::offline::BlockMap",
                                                                          "storage"
                                                                        |)
                                                                      |)
                                                                    ]
                                                                  |)
                                                                |)
                                                              |)
                                                            ]
                                                          |)
                                                        ]
                                                      |)
                                                    |)
                                                  |)
                                                |)
                                              |)
                                            |)
                                          |)));
                                      fun γ =>
                                        ltac:(M.monadic
                                          (M.borrow (|
                                            Pointer.Kind.MutRef,
                                            M.deref (|
                                              M.borrow (|
                                                Pointer.Kind.MutRef,
                                                M.deref (|
                                                  M.call_closure (|
                                                    Ty.apply
                                                      (Ty.path "&mut")
                                                      []
                                                      [
                                                        Ty.path
                                                          "openvm_circuit::system::memory::offline::BlockData"
                                                      ],
                                                    M.get_trait_method (|
                                                      "core::ops::index::IndexMut",
                                                      Ty.apply
                                                        (Ty.path "alloc::vec::Vec")
                                                        []
                                                        [
                                                          Ty.path
                                                            "openvm_circuit::system::memory::offline::BlockData";
                                                          Ty.path "alloc::alloc::Global"
                                                        ],
                                                      [],
                                                      [ Ty.path "usize" ],
                                                      "index_mut",
                                                      [],
                                                      []
                                                    |),
                                                    [
                                                      M.borrow (|
                                                        Pointer.Kind.MutRef,
                                                        M.SubPointer.get_struct_record_field (|
                                                          M.deref (| M.read (| self |) |),
                                                          "openvm_circuit::system::memory::offline::BlockMap",
                                                          "storage"
                                                        |)
                                                      |);
                                                      M.call_closure (|
                                                        Ty.path "usize",
                                                        M.get_trait_method (|
                                                          "core::ops::arith::Sub",
                                                          Ty.apply
                                                            (Ty.path "&")
                                                            []
                                                            [ Ty.path "usize" ],
                                                          [],
                                                          [ Ty.path "usize" ],
                                                          "sub",
                                                          [],
                                                          []
                                                        |),
                                                        [
                                                          M.read (| idx |);
                                                          Value.Integer IntegerKind.Usize 1
                                                        ]
                                                      |)
                                                    ]
                                                  |)
                                                |)
                                              |)
                                            |)
                                          |)))
                                    ]
                                  |)
                                |)
                              |)
                            |)
                          |)))
                    ]
                  |)
                |)
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Global Instance AssociatedFunction_get_mut :
          M.IsAssociatedFunction.C Self "get_mut" get_mut.
        Admitted.
        Global Typeclasses Opaque get_mut.
        
        (*
            pub fn set_range(&mut self, address: &(u32, u32), len: usize, block: BlockData) {
                let (address_space, pointer) = address;
                self.storage.push(block);
                for i in 0..len {
                    self.id
                        .insert(&( *address_space, pointer + i as u32), self.storage.len());
                }
            }
        *)
        Definition set_range (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          match ε, τ, α with
          | [], [], [ self; address; len; block ] =>
            ltac:(M.monadic
              (let self :=
                M.alloc (|
                  Ty.apply
                    (Ty.path "&mut")
                    []
                    [ Ty.path "openvm_circuit::system::memory::offline::BlockMap" ],
                  self
                |) in
              let address :=
                M.alloc (|
                  Ty.apply (Ty.path "&") [] [ Ty.tuple [ Ty.path "u32"; Ty.path "u32" ] ],
                  address
                |) in
              let len := M.alloc (| Ty.path "usize", len |) in
              let block :=
                M.alloc (| Ty.path "openvm_circuit::system::memory::offline::BlockData", block |) in
              M.match_operator (|
                Ty.tuple [],
                address,
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ := M.read (| γ |) in
                      let γ1_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ1_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let address_space :=
                        M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "u32" ], γ1_0 |) in
                      let pointer :=
                        M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "u32" ], γ1_1 |) in
                      M.read (|
                        let~ _ : Ty.tuple [] :=
                          M.call_closure (|
                            Ty.tuple [],
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                []
                                [
                                  Ty.path "openvm_circuit::system::memory::offline::BlockData";
                                  Ty.path "alloc::alloc::Global"
                                ],
                              "push",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.MutRef,
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "openvm_circuit::system::memory::offline::BlockMap",
                                  "storage"
                                |)
                              |);
                              M.read (| block |)
                            ]
                          |) in
                        M.use
                          (M.alloc (|
                            Ty.tuple [],
                            M.match_operator (|
                              Ty.tuple [],
                              M.alloc (|
                                Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "core::ops::range::Range")
                                    []
                                    [ Ty.path "usize" ],
                                  M.get_trait_method (|
                                    "core::iter::traits::collect::IntoIterator",
                                    Ty.apply
                                      (Ty.path "core::ops::range::Range")
                                      []
                                      [ Ty.path "usize" ],
                                    [],
                                    [],
                                    "into_iter",
                                    [],
                                    []
                                  |),
                                  [
                                    Value.mkStructRecord
                                      "core::ops::range::Range"
                                      []
                                      [ Ty.path "usize" ]
                                      [
                                        ("start", Value.Integer IntegerKind.Usize 0);
                                        ("end_", M.read (| len |))
                                      ]
                                  ]
                                |)
                              |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let iter :=
                                      M.copy (|
                                        Ty.apply
                                          (Ty.path "core::ops::range::Range")
                                          []
                                          [ Ty.path "usize" ],
                                        γ
                                      |) in
                                    M.read (|
                                      M.loop (|
                                        Ty.tuple [],
                                        ltac:(M.monadic
                                          (let~ _ : Ty.tuple [] :=
                                            M.match_operator (|
                                              Ty.tuple [],
                                              M.alloc (|
                                                Ty.apply
                                                  (Ty.path "core::option::Option")
                                                  []
                                                  [ Ty.path "usize" ],
                                                M.call_closure (|
                                                  Ty.apply
                                                    (Ty.path "core::option::Option")
                                                    []
                                                    [ Ty.path "usize" ],
                                                  M.get_trait_method (|
                                                    "core::iter::traits::iterator::Iterator",
                                                    Ty.apply
                                                      (Ty.path "core::ops::range::Range")
                                                      []
                                                      [ Ty.path "usize" ],
                                                    [],
                                                    [],
                                                    "next",
                                                    [],
                                                    []
                                                  |),
                                                  [
                                                    M.borrow (|
                                                      Pointer.Kind.MutRef,
                                                      M.deref (|
                                                        M.borrow (| Pointer.Kind.MutRef, iter |)
                                                      |)
                                                    |)
                                                  ]
                                                |)
                                              |),
                                              [
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (let _ :=
                                                      M.is_struct_tuple (|
                                                        γ,
                                                        "core::option::Option::None"
                                                      |) in
                                                    M.never_to_any (|
                                                      M.read (| M.break (||) |)
                                                    |)));
                                                fun γ =>
                                                  ltac:(M.monadic
                                                    (let γ0_0 :=
                                                      M.SubPointer.get_struct_tuple_field (|
                                                        γ,
                                                        "core::option::Option::Some",
                                                        0
                                                      |) in
                                                    let i := M.copy (| Ty.path "usize", γ0_0 |) in
                                                    M.read (|
                                                      let~ _ :
                                                          Ty.apply
                                                            (Ty.path "core::option::Option")
                                                            []
                                                            [ Ty.path "usize" ] :=
                                                        M.call_closure (|
                                                          Ty.apply
                                                            (Ty.path "core::option::Option")
                                                            []
                                                            [ Ty.path "usize" ],
                                                          M.get_associated_function (|
                                                            Ty.apply
                                                              (Ty.path
                                                                "openvm_circuit::system::memory::paged_vec::AddressMap")
                                                              [ Value.Integer IntegerKind.Usize 4096
                                                              ]
                                                              [ Ty.path "usize" ],
                                                            "insert",
                                                            [],
                                                            []
                                                          |),
                                                          [
                                                            M.borrow (|
                                                              Pointer.Kind.MutRef,
                                                              M.SubPointer.get_struct_record_field (|
                                                                M.deref (| M.read (| self |) |),
                                                                "openvm_circuit::system::memory::offline::BlockMap",
                                                                "id"
                                                              |)
                                                            |);
                                                            M.borrow (|
                                                              Pointer.Kind.Ref,
                                                              M.deref (|
                                                                M.borrow (|
                                                                  Pointer.Kind.Ref,
                                                                  M.alloc (|
                                                                    Ty.tuple
                                                                      [ Ty.path "u32"; Ty.path "u32"
                                                                      ],
                                                                    Value.Tuple
                                                                      [
                                                                        M.read (|
                                                                          M.deref (|
                                                                            M.read (|
                                                                              address_space
                                                                            |)
                                                                          |)
                                                                        |);
                                                                        M.call_closure (|
                                                                          Ty.path "u32",
                                                                          M.get_trait_method (|
                                                                            "core::ops::arith::Add",
                                                                            Ty.apply
                                                                              (Ty.path "&")
                                                                              []
                                                                              [ Ty.path "u32" ],
                                                                            [],
                                                                            [ Ty.path "u32" ],
                                                                            "add",
                                                                            [],
                                                                            []
                                                                          |),
                                                                          [
                                                                            M.read (| pointer |);
                                                                            M.cast
                                                                              (Ty.path "u32")
                                                                              (M.read (| i |))
                                                                          ]
                                                                        |)
                                                                      ]
                                                                  |)
                                                                |)
                                                              |)
                                                            |);
                                                            M.call_closure (|
                                                              Ty.path "usize",
                                                              M.get_associated_function (|
                                                                Ty.apply
                                                                  (Ty.path "alloc::vec::Vec")
                                                                  []
                                                                  [
                                                                    Ty.path
                                                                      "openvm_circuit::system::memory::offline::BlockData";
                                                                    Ty.path "alloc::alloc::Global"
                                                                  ],
                                                                "len",
                                                                [],
                                                                []
                                                              |),
                                                              [
                                                                M.borrow (|
                                                                  Pointer.Kind.Ref,
                                                                  M.SubPointer.get_struct_record_field (|
                                                                    M.deref (| M.read (| self |) |),
                                                                    "openvm_circuit::system::memory::offline::BlockMap",
                                                                    "storage"
                                                                  |)
                                                                |)
                                                              ]
                                                            |)
                                                          ]
                                                        |) in
                                                      M.alloc (| Ty.tuple [], Value.Tuple [] |)
                                                    |)))
                                              ]
                                            |) in
                                          M.alloc (| Ty.tuple [], Value.Tuple [] |)))
                                      |)
                                    |)))
                              ]
                            |)
                          |))
                      |)))
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Global Instance AssociatedFunction_set_range :
          M.IsAssociatedFunction.C Self "set_range" set_range.
        Admitted.
        Global Typeclasses Opaque set_range.
        
        (*
            pub fn items(&self) -> impl Iterator<Item = ((u32, u32), &BlockData)> + '_ {
                self.id
                    .items()
                    .filter(|(_, idx)| *idx > 0)
                    .map(|(address, idx)| (address, &self.storage[idx - 1]))
            }
        *)
        Definition items (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self :=
                M.alloc (|
                  Ty.apply
                    (Ty.path "&")
                    []
                    [ Ty.path "openvm_circuit::system::memory::offline::BlockMap" ],
                  self
                |) in
              M.call_closure (|
                Ty.apply
                  (Ty.path "core::iter::adapters::map::Map")
                  []
                  [
                    Ty.apply
                      (Ty.path "core::iter::adapters::filter::Filter")
                      []
                      [
                        Ty.associated_unknown;
                        Ty.function
                          [
                            Ty.apply
                              (Ty.path "&")
                              []
                              [
                                Ty.tuple
                                  [ Ty.tuple [ Ty.path "u32"; Ty.path "u32" ]; Ty.path "usize" ]
                              ]
                          ]
                          (Ty.path "bool")
                      ];
                    Ty.function
                      [ Ty.tuple [ Ty.tuple [ Ty.path "u32"; Ty.path "u32" ]; Ty.path "usize" ] ]
                      (Ty.tuple
                        [
                          Ty.tuple [ Ty.path "u32"; Ty.path "u32" ];
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.path "openvm_circuit::system::memory::offline::BlockData" ]
                        ])
                  ],
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  Ty.apply
                    (Ty.path "core::iter::adapters::filter::Filter")
                    []
                    [
                      Ty.associated_unknown;
                      Ty.function
                        [
                          Ty.apply
                            (Ty.path "&")
                            []
                            [
                              Ty.tuple
                                [ Ty.tuple [ Ty.path "u32"; Ty.path "u32" ]; Ty.path "usize" ]
                            ]
                        ]
                        (Ty.path "bool")
                    ],
                  [],
                  [],
                  "map",
                  [],
                  [
                    Ty.tuple
                      [
                        Ty.tuple [ Ty.path "u32"; Ty.path "u32" ];
                        Ty.apply
                          (Ty.path "&")
                          []
                          [ Ty.path "openvm_circuit::system::memory::offline::BlockData" ]
                      ];
                    Ty.function
                      [ Ty.tuple [ Ty.tuple [ Ty.path "u32"; Ty.path "u32" ]; Ty.path "usize" ] ]
                      (Ty.tuple
                        [
                          Ty.tuple [ Ty.path "u32"; Ty.path "u32" ];
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.path "openvm_circuit::system::memory::offline::BlockData" ]
                        ])
                  ]
                |),
                [
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::iter::adapters::filter::Filter")
                      []
                      [
                        Ty.associated_unknown;
                        Ty.function
                          [
                            Ty.apply
                              (Ty.path "&")
                              []
                              [
                                Ty.tuple
                                  [ Ty.tuple [ Ty.path "u32"; Ty.path "u32" ]; Ty.path "usize" ]
                              ]
                          ]
                          (Ty.path "bool")
                      ],
                    M.get_trait_method (|
                      "core::iter::traits::iterator::Iterator",
                      Ty.associated_unknown,
                      [],
                      [],
                      "filter",
                      [],
                      [
                        Ty.function
                          [
                            Ty.apply
                              (Ty.path "&")
                              []
                              [
                                Ty.tuple
                                  [ Ty.tuple [ Ty.path "u32"; Ty.path "u32" ]; Ty.path "usize" ]
                              ]
                          ]
                          (Ty.path "bool")
                      ]
                    |),
                    [
                      M.call_closure (|
                        Ty.associated_unknown,
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "openvm_circuit::system::memory::paged_vec::AddressMap")
                            [ Value.Integer IntegerKind.Usize 4096 ]
                            [ Ty.path "usize" ],
                          "items",
                          [],
                          []
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "openvm_circuit::system::memory::offline::BlockMap",
                              "id"
                            |)
                          |)
                        ]
                      |);
                      M.closure
                        (fun γ =>
                          ltac:(M.monadic
                            match γ with
                            | [ α0 ] =>
                              ltac:(M.monadic
                                (M.match_operator (|
                                  Ty.path "bool",
                                  M.alloc (|
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [
                                        Ty.tuple
                                          [
                                            Ty.tuple [ Ty.path "u32"; Ty.path "u32" ];
                                            Ty.path "usize"
                                          ]
                                      ],
                                    α0
                                  |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ := M.read (| γ |) in
                                        let γ1_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                        let γ1_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                        let idx :=
                                          M.alloc (|
                                            Ty.apply (Ty.path "&") [] [ Ty.path "usize" ],
                                            γ1_1
                                          |) in
                                        M.call_closure (|
                                          Ty.path "bool",
                                          BinOp.gt,
                                          [
                                            M.read (| M.deref (| M.read (| idx |) |) |);
                                            Value.Integer IntegerKind.Usize 0
                                          ]
                                        |)))
                                  ]
                                |)))
                            | _ => M.impossible "wrong number of arguments"
                            end))
                    ]
                  |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              Ty.tuple
                                [
                                  Ty.tuple [ Ty.path "u32"; Ty.path "u32" ];
                                  Ty.apply
                                    (Ty.path "&")
                                    []
                                    [ Ty.path "openvm_circuit::system::memory::offline::BlockData" ]
                                ],
                              M.alloc (|
                                Ty.tuple
                                  [ Ty.tuple [ Ty.path "u32"; Ty.path "u32" ]; Ty.path "usize" ],
                                α0
                              |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                    let address :=
                                      M.copy (|
                                        Ty.tuple [ Ty.path "u32"; Ty.path "u32" ],
                                        γ0_0
                                      |) in
                                    let idx := M.copy (| Ty.path "usize", γ0_1 |) in
                                    Value.Tuple
                                      [
                                        M.read (| address |);
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (|
                                            M.call_closure (|
                                              Ty.apply
                                                (Ty.path "&")
                                                []
                                                [
                                                  Ty.path
                                                    "openvm_circuit::system::memory::offline::BlockData"
                                                ],
                                              M.get_trait_method (|
                                                "core::ops::index::Index",
                                                Ty.apply
                                                  (Ty.path "alloc::vec::Vec")
                                                  []
                                                  [
                                                    Ty.path
                                                      "openvm_circuit::system::memory::offline::BlockData";
                                                    Ty.path "alloc::alloc::Global"
                                                  ],
                                                [],
                                                [ Ty.path "usize" ],
                                                "index",
                                                [],
                                                []
                                              |),
                                              [
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.SubPointer.get_struct_record_field (|
                                                    M.deref (| M.read (| self |) |),
                                                    "openvm_circuit::system::memory::offline::BlockMap",
                                                    "storage"
                                                  |)
                                                |);
                                                M.call_closure (|
                                                  Ty.path "usize",
                                                  BinOp.Wrap.sub,
                                                  [
                                                    M.read (| idx |);
                                                    Value.Integer IntegerKind.Usize 1
                                                  ]
                                                |)
                                              ]
                                            |)
                                          |)
                                        |)
                                      ]))
                              ]
                            |)))
                        | _ => M.impossible "wrong number of arguments"
                        end))
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Global Instance AssociatedFunction_items : M.IsAssociatedFunction.C Self "items" items.
        Admitted.
        Global Typeclasses Opaque items.
      End Impl_openvm_circuit_system_memory_offline_BlockMap.
      
      (* StructRecord
        {
          name := "MemoryRecord";
          const_params := [];
          ty_params := [ "T" ];
          fields :=
            [
              ("address_space", T);
              ("pointer", T);
              ("timestamp", Ty.path "u32");
              ("prev_timestamp", Ty.path "u32");
              ("data",
                Ty.apply (Ty.path "alloc::vec::Vec") [] [ T; Ty.path "alloc::alloc::Global" ]);
              ("prev_data",
                Ty.apply
                  (Ty.path "core::option::Option")
                  []
                  [ Ty.apply (Ty.path "alloc::vec::Vec") [] [ T; Ty.path "alloc::alloc::Global" ] ])
            ];
        } *)
      
      Module Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_openvm_circuit_system_memory_offline_MemoryRecord_T.
        Definition Self (T : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "openvm_circuit::system::memory::offline::MemoryRecord") [] [ T ].
        
        (* Debug *)
        Definition fmt (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T in
          match ε, τ, α with
          | [], [], [ self; f ] =>
            ltac:(M.monadic
              (let self :=
                M.alloc (|
                  Ty.apply
                    (Ty.path "&")
                    []
                    [
                      Ty.apply
                        (Ty.path "openvm_circuit::system::memory::offline::MemoryRecord")
                        []
                        [ T ]
                    ],
                  self
                |) in
              let f :=
                M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "core::fmt::Formatter" ], f |) in
              M.read (|
                let~ names :
                    Ty.apply
                      (Ty.path "&")
                      []
                      [
                        Ty.apply
                          (Ty.path "array")
                          [ Value.Integer IntegerKind.Usize 6 ]
                          [ Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ]
                      ] :=
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          Ty.apply
                            (Ty.path "array")
                            [ Value.Integer IntegerKind.Usize 6 ]
                            [ Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ],
                          Value.Array
                            [
                              mk_str (| "address_space" |);
                              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "pointer" |) |) |);
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (| mk_str (| "timestamp" |) |)
                              |);
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (| mk_str (| "prev_timestamp" |) |)
                              |);
                              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "data" |) |) |);
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (| mk_str (| "prev_data" |) |)
                              |)
                            ]
                        |)
                      |)
                    |)
                  |) in
                let~ values :
                    Ty.apply
                      (Ty.path "&")
                      []
                      [
                        Ty.apply
                          (Ty.path "slice")
                          []
                          [ Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ]
                          ]
                      ] :=
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "&")
                      []
                      [
                        Ty.apply
                          (Ty.path "slice")
                          []
                          [ Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ]
                          ]
                      ],
                    M.pointer_coercion
                      M.PointerCoercion.Unsize
                      (Ty.apply
                        (Ty.path "&")
                        []
                        [
                          Ty.apply
                            (Ty.path "array")
                            [ Value.Integer IntegerKind.Usize 6 ]
                            [
                              Ty.apply
                                (Ty.path "&")
                                []
                                [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ]
                            ]
                        ])
                      (Ty.apply
                        (Ty.path "&")
                        []
                        [
                          Ty.apply
                            (Ty.path "slice")
                            []
                            [
                              Ty.apply
                                (Ty.path "&")
                                []
                                [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ]
                            ]
                        ]),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.alloc (|
                              Ty.apply
                                (Ty.path "array")
                                [ Value.Integer IntegerKind.Usize 6 ]
                                [
                                  Ty.apply
                                    (Ty.path "&")
                                    []
                                    [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ]
                                ],
                              Value.Array
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ],
                                    M.pointer_coercion
                                      M.PointerCoercion.Unsize
                                      (Ty.apply (Ty.path "&") [] [ T ])
                                      (Ty.apply
                                        (Ty.path "&")
                                        []
                                        [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ]),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (|
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.SubPointer.get_struct_record_field (|
                                              M.deref (| M.read (| self |) |),
                                              "openvm_circuit::system::memory::offline::MemoryRecord",
                                              "address_space"
                                            |)
                                          |)
                                        |)
                                      |)
                                    ]
                                  |);
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ],
                                    M.pointer_coercion
                                      M.PointerCoercion.Unsize
                                      (Ty.apply (Ty.path "&") [] [ T ])
                                      (Ty.apply
                                        (Ty.path "&")
                                        []
                                        [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ]),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (|
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.SubPointer.get_struct_record_field (|
                                              M.deref (| M.read (| self |) |),
                                              "openvm_circuit::system::memory::offline::MemoryRecord",
                                              "pointer"
                                            |)
                                          |)
                                        |)
                                      |)
                                    ]
                                  |);
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ],
                                    M.pointer_coercion
                                      M.PointerCoercion.Unsize
                                      (Ty.apply (Ty.path "&") [] [ Ty.path "u32" ])
                                      (Ty.apply
                                        (Ty.path "&")
                                        []
                                        [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ]),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (|
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.SubPointer.get_struct_record_field (|
                                              M.deref (| M.read (| self |) |),
                                              "openvm_circuit::system::memory::offline::MemoryRecord",
                                              "timestamp"
                                            |)
                                          |)
                                        |)
                                      |)
                                    ]
                                  |);
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ],
                                    M.pointer_coercion
                                      M.PointerCoercion.Unsize
                                      (Ty.apply (Ty.path "&") [] [ Ty.path "u32" ])
                                      (Ty.apply
                                        (Ty.path "&")
                                        []
                                        [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ]),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (|
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.SubPointer.get_struct_record_field (|
                                              M.deref (| M.read (| self |) |),
                                              "openvm_circuit::system::memory::offline::MemoryRecord",
                                              "prev_timestamp"
                                            |)
                                          |)
                                        |)
                                      |)
                                    ]
                                  |);
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ],
                                    M.pointer_coercion
                                      M.PointerCoercion.Unsize
                                      (Ty.apply
                                        (Ty.path "&")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "alloc::vec::Vec")
                                            []
                                            [ T; Ty.path "alloc::alloc::Global" ]
                                        ])
                                      (Ty.apply
                                        (Ty.path "&")
                                        []
                                        [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ]),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (|
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.SubPointer.get_struct_record_field (|
                                              M.deref (| M.read (| self |) |),
                                              "openvm_circuit::system::memory::offline::MemoryRecord",
                                              "data"
                                            |)
                                          |)
                                        |)
                                      |)
                                    ]
                                  |);
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ],
                                    M.pointer_coercion
                                      M.PointerCoercion.Unsize
                                      (Ty.apply
                                        (Ty.path "&")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "&")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "core::option::Option")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "alloc::vec::Vec")
                                                    []
                                                    [ T; Ty.path "alloc::alloc::Global" ]
                                                ]
                                            ]
                                        ])
                                      (Ty.apply
                                        (Ty.path "&")
                                        []
                                        [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ]),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (|
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.alloc (|
                                              Ty.apply
                                                (Ty.path "&")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::option::Option")
                                                    []
                                                    [
                                                      Ty.apply
                                                        (Ty.path "alloc::vec::Vec")
                                                        []
                                                        [ T; Ty.path "alloc::alloc::Global" ]
                                                    ]
                                                ],
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.SubPointer.get_struct_record_field (|
                                                  M.deref (| M.read (| self |) |),
                                                  "openvm_circuit::system::memory::offline::MemoryRecord",
                                                  "prev_data"
                                                |)
                                              |)
                                            |)
                                          |)
                                        |)
                                      |)
                                    ]
                                  |)
                                ]
                            |)
                          |)
                        |)
                      |)
                    ]
                  |) in
                M.alloc (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                    M.get_associated_function (|
                      Ty.path "core::fmt::Formatter",
                      "debug_struct_fields_finish",
                      [],
                      []
                    |),
                    [
                      M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                      M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "MemoryRecord" |) |) |);
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "&")
                          []
                          [
                            Ty.apply
                              (Ty.path "slice")
                              []
                              [ Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ]
                          ],
                        M.pointer_coercion
                          M.PointerCoercion.Unsize
                          (Ty.apply
                            (Ty.path "&")
                            []
                            [
                              Ty.apply
                                (Ty.path "array")
                                [ Value.Integer IntegerKind.Usize 6 ]
                                [ Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ]
                            ])
                          (Ty.apply
                            (Ty.path "&")
                            []
                            [
                              Ty.apply
                                (Ty.path "slice")
                                []
                                [ Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ]
                            ]),
                        [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| names |) |) |) ]
                      |);
                      M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| values |) |) |)
                    ]
                  |)
                |)
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          forall (T : Ty.t),
          M.IsTraitInstance
            "core::fmt::Debug"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) []
            (Self T)
            (* Instance *) [ ("fmt", InstanceField.Method (fmt T)) ].
      End Impl_core_fmt_Debug_where_core_fmt_Debug_T_for_openvm_circuit_system_memory_offline_MemoryRecord_T.
      
      Module Impl_core_clone_Clone_where_core_clone_Clone_T_for_openvm_circuit_system_memory_offline_MemoryRecord_T.
        Definition Self (T : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "openvm_circuit::system::memory::offline::MemoryRecord") [] [ T ].
        
        (* Clone *)
        Definition clone (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self :=
                M.alloc (|
                  Ty.apply
                    (Ty.path "&")
                    []
                    [
                      Ty.apply
                        (Ty.path "openvm_circuit::system::memory::offline::MemoryRecord")
                        []
                        [ T ]
                    ],
                  self
                |) in
              Value.mkStructRecord
                "openvm_circuit::system::memory::offline::MemoryRecord"
                []
                [ T ]
                [
                  ("address_space",
                    M.call_closure (|
                      T,
                      M.get_trait_method (| "core::clone::Clone", T, [], [], "clone", [], [] |),
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (|
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "openvm_circuit::system::memory::offline::MemoryRecord",
                                "address_space"
                              |)
                            |)
                          |)
                        |)
                      ]
                    |));
                  ("pointer",
                    M.call_closure (|
                      T,
                      M.get_trait_method (| "core::clone::Clone", T, [], [], "clone", [], [] |),
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (|
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "openvm_circuit::system::memory::offline::MemoryRecord",
                                "pointer"
                              |)
                            |)
                          |)
                        |)
                      ]
                    |));
                  ("timestamp",
                    M.call_closure (|
                      Ty.path "u32",
                      M.get_trait_method (|
                        "core::clone::Clone",
                        Ty.path "u32",
                        [],
                        [],
                        "clone",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (|
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "openvm_circuit::system::memory::offline::MemoryRecord",
                                "timestamp"
                              |)
                            |)
                          |)
                        |)
                      ]
                    |));
                  ("prev_timestamp",
                    M.call_closure (|
                      Ty.path "u32",
                      M.get_trait_method (|
                        "core::clone::Clone",
                        Ty.path "u32",
                        [],
                        [],
                        "clone",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (|
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "openvm_circuit::system::memory::offline::MemoryRecord",
                                "prev_timestamp"
                              |)
                            |)
                          |)
                        |)
                      ]
                    |));
                  ("data",
                    M.call_closure (|
                      Ty.apply (Ty.path "alloc::vec::Vec") [] [ T; Ty.path "alloc::alloc::Global" ],
                      M.get_trait_method (|
                        "core::clone::Clone",
                        Ty.apply
                          (Ty.path "alloc::vec::Vec")
                          []
                          [ T; Ty.path "alloc::alloc::Global" ],
                        [],
                        [],
                        "clone",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (|
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "openvm_circuit::system::memory::offline::MemoryRecord",
                                "data"
                              |)
                            |)
                          |)
                        |)
                      ]
                    |));
                  ("prev_data",
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::option::Option")
                        []
                        [
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            []
                            [ T; Ty.path "alloc::alloc::Global" ]
                        ],
                      M.get_trait_method (|
                        "core::clone::Clone",
                        Ty.apply
                          (Ty.path "core::option::Option")
                          []
                          [
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              []
                              [ T; Ty.path "alloc::alloc::Global" ]
                          ],
                        [],
                        [],
                        "clone",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (|
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "openvm_circuit::system::memory::offline::MemoryRecord",
                                "prev_data"
                              |)
                            |)
                          |)
                        |)
                      ]
                    |))
                ]))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          forall (T : Ty.t),
          M.IsTraitInstance
            "core::clone::Clone"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) []
            (Self T)
            (* Instance *) [ ("clone", InstanceField.Method (clone T)) ].
      End Impl_core_clone_Clone_where_core_clone_Clone_T_for_openvm_circuit_system_memory_offline_MemoryRecord_T.
      
      Module Impl_core_marker_StructuralPartialEq_for_openvm_circuit_system_memory_offline_MemoryRecord_T.
        Definition Self (T : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "openvm_circuit::system::memory::offline::MemoryRecord") [] [ T ].
        
        Axiom Implements :
          forall (T : Ty.t),
          M.IsTraitInstance
            "core::marker::StructuralPartialEq"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) []
            (Self T)
            (* Instance *) [].
      End Impl_core_marker_StructuralPartialEq_for_openvm_circuit_system_memory_offline_MemoryRecord_T.
      
      Module Impl_core_cmp_PartialEq_where_core_cmp_PartialEq_T_openvm_circuit_system_memory_offline_MemoryRecord_T_for_openvm_circuit_system_memory_offline_MemoryRecord_T.
        Definition Self (T : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "openvm_circuit::system::memory::offline::MemoryRecord") [] [ T ].
        
        (* PartialEq *)
        Definition eq (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T in
          match ε, τ, α with
          | [], [], [ self; other ] =>
            ltac:(M.monadic
              (let self :=
                M.alloc (|
                  Ty.apply
                    (Ty.path "&")
                    []
                    [
                      Ty.apply
                        (Ty.path "openvm_circuit::system::memory::offline::MemoryRecord")
                        []
                        [ T ]
                    ],
                  self
                |) in
              let other :=
                M.alloc (|
                  Ty.apply
                    (Ty.path "&")
                    []
                    [
                      Ty.apply
                        (Ty.path "openvm_circuit::system::memory::offline::MemoryRecord")
                        []
                        [ T ]
                    ],
                  other
                |) in
              LogicalOp.and (|
                LogicalOp.and (|
                  LogicalOp.and (|
                    LogicalOp.and (|
                      LogicalOp.and (|
                        M.call_closure (|
                          Ty.path "bool",
                          M.get_trait_method (|
                            "core::cmp::PartialEq",
                            T,
                            [],
                            [ T ],
                            "eq",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "openvm_circuit::system::memory::offline::MemoryRecord",
                                "address_space"
                              |)
                            |);
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| other |) |),
                                "openvm_circuit::system::memory::offline::MemoryRecord",
                                "address_space"
                              |)
                            |)
                          ]
                        |),
                        ltac:(M.monadic
                          (M.call_closure (|
                            Ty.path "bool",
                            M.get_trait_method (|
                              "core::cmp::PartialEq",
                              T,
                              [],
                              [ T ],
                              "eq",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "openvm_circuit::system::memory::offline::MemoryRecord",
                                  "pointer"
                                |)
                              |);
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| other |) |),
                                  "openvm_circuit::system::memory::offline::MemoryRecord",
                                  "pointer"
                                |)
                              |)
                            ]
                          |)))
                      |),
                      ltac:(M.monadic
                        (M.call_closure (|
                          Ty.path "bool",
                          BinOp.eq,
                          [
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "openvm_circuit::system::memory::offline::MemoryRecord",
                                "timestamp"
                              |)
                            |);
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| other |) |),
                                "openvm_circuit::system::memory::offline::MemoryRecord",
                                "timestamp"
                              |)
                            |)
                          ]
                        |)))
                    |),
                    ltac:(M.monadic
                      (M.call_closure (|
                        Ty.path "bool",
                        BinOp.eq,
                        [
                          M.read (|
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "openvm_circuit::system::memory::offline::MemoryRecord",
                              "prev_timestamp"
                            |)
                          |);
                          M.read (|
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| other |) |),
                              "openvm_circuit::system::memory::offline::MemoryRecord",
                              "prev_timestamp"
                            |)
                          |)
                        ]
                      |)))
                  |),
                  ltac:(M.monadic
                    (M.call_closure (|
                      Ty.path "bool",
                      M.get_trait_method (|
                        "core::cmp::PartialEq",
                        Ty.apply
                          (Ty.path "alloc::vec::Vec")
                          []
                          [ T; Ty.path "alloc::alloc::Global" ],
                        [],
                        [
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            []
                            [ T; Ty.path "alloc::alloc::Global" ]
                        ],
                        "eq",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "openvm_circuit::system::memory::offline::MemoryRecord",
                            "data"
                          |)
                        |);
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| other |) |),
                            "openvm_circuit::system::memory::offline::MemoryRecord",
                            "data"
                          |)
                        |)
                      ]
                    |)))
                |),
                ltac:(M.monadic
                  (M.call_closure (|
                    Ty.path "bool",
                    M.get_trait_method (|
                      "core::cmp::PartialEq",
                      Ty.apply
                        (Ty.path "core::option::Option")
                        []
                        [
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            []
                            [ T; Ty.path "alloc::alloc::Global" ]
                        ],
                      [],
                      [
                        Ty.apply
                          (Ty.path "core::option::Option")
                          []
                          [
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              []
                              [ T; Ty.path "alloc::alloc::Global" ]
                          ]
                      ],
                      "eq",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "openvm_circuit::system::memory::offline::MemoryRecord",
                          "prev_data"
                        |)
                      |);
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| other |) |),
                          "openvm_circuit::system::memory::offline::MemoryRecord",
                          "prev_data"
                        |)
                      |)
                    ]
                  |)))
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          forall (T : Ty.t),
          M.IsTraitInstance
            "core::cmp::PartialEq"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *)
            [ Ty.apply (Ty.path "openvm_circuit::system::memory::offline::MemoryRecord") [] [ T ] ]
            (Self T)
            (* Instance *) [ ("eq", InstanceField.Method (eq T)) ].
      End Impl_core_cmp_PartialEq_where_core_cmp_PartialEq_T_openvm_circuit_system_memory_offline_MemoryRecord_T_for_openvm_circuit_system_memory_offline_MemoryRecord_T.
      
      Module Impl_openvm_circuit_system_memory_offline_MemoryRecord_T.
        Definition Self (T : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "openvm_circuit::system::memory::offline::MemoryRecord") [] [ T ].
        
        (*
            pub fn data_slice(&self) -> &[T] {
                self.data.as_slice()
            }
        *)
        Definition data_slice
            (T : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self T in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self :=
                M.alloc (|
                  Ty.apply
                    (Ty.path "&")
                    []
                    [
                      Ty.apply
                        (Ty.path "openvm_circuit::system::memory::offline::MemoryRecord")
                        []
                        [ T ]
                    ],
                  self
                |) in
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloc::vec::Vec") [] [ T; Ty.path "alloc::alloc::Global" ],
                      "as_slice",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "openvm_circuit::system::memory::offline::MemoryRecord",
                          "data"
                        |)
                      |)
                    ]
                  |)
                |)
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Global Instance AssociatedFunction_data_slice :
          forall (T : Ty.t),
          M.IsAssociatedFunction.C (Self T) "data_slice" (data_slice T).
        Admitted.
        Global Typeclasses Opaque data_slice.
        
        (*
            pub fn prev_data_slice(&self) -> Option<&[T]> {
                self.prev_data.as_deref()
            }
        *)
        Definition prev_data_slice
            (T : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self T in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self :=
                M.alloc (|
                  Ty.apply
                    (Ty.path "&")
                    []
                    [
                      Ty.apply
                        (Ty.path "openvm_circuit::system::memory::offline::MemoryRecord")
                        []
                        [ T ]
                    ],
                  self
                |) in
              M.call_closure (|
                Ty.apply
                  (Ty.path "core::option::Option")
                  []
                  [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ T ] ] ],
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [ Ty.apply (Ty.path "alloc::vec::Vec") [] [ T; Ty.path "alloc::alloc::Global" ]
                    ],
                  "as_deref",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "openvm_circuit::system::memory::offline::MemoryRecord",
                      "prev_data"
                    |)
                  |)
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Global Instance AssociatedFunction_prev_data_slice :
          forall (T : Ty.t),
          M.IsAssociatedFunction.C (Self T) "prev_data_slice" (prev_data_slice T).
        Admitted.
        Global Typeclasses Opaque prev_data_slice.
        (*
            pub fn data_at(&self, index: usize) -> T {
                self.data[index]
            }
        *)
        Definition data_at (T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self T in
          match ε, τ, α with
          | [], [], [ self; index ] =>
            ltac:(M.monadic
              (let self :=
                M.alloc (|
                  Ty.apply
                    (Ty.path "&")
                    []
                    [
                      Ty.apply
                        (Ty.path "openvm_circuit::system::memory::offline::MemoryRecord")
                        []
                        [ T ]
                    ],
                  self
                |) in
              let index := M.alloc (| Ty.path "usize", index |) in
              M.read (|
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ T ],
                    M.get_trait_method (|
                      "core::ops::index::Index",
                      Ty.apply (Ty.path "alloc::vec::Vec") [] [ T; Ty.path "alloc::alloc::Global" ],
                      [],
                      [ Ty.path "usize" ],
                      "index",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "openvm_circuit::system::memory::offline::MemoryRecord",
                          "data"
                        |)
                      |);
                      M.read (| index |)
                    ]
                  |)
                |)
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Global Instance AssociatedFunction_data_at :
          forall (T : Ty.t),
          M.IsAssociatedFunction.C (Self T) "data_at" (data_at T).
        Admitted.
        Global Typeclasses Opaque data_at.
      End Impl_openvm_circuit_system_memory_offline_MemoryRecord_T.
      
      
      (* StructRecord
        {
          name := "OfflineMemory";
          const_params := [];
          ty_params := [ "F" ];
          fields :=
            [
              ("block_data", Ty.path "openvm_circuit::system::memory::offline::BlockMap");
              ("data",
                Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  []
                  [
                    Ty.apply
                      (Ty.path "openvm_circuit::system::memory::paged_vec::PagedVec")
                      [
                        M.unevaluated_const
                          (mk_str (|
                            "openvm_circuit_system_memory_offline_OfflineMemory_discriminant"
                          |))
                      ]
                      [ F ];
                    Ty.path "alloc::alloc::Global"
                  ]);
              ("as_offset", Ty.path "u32");
              ("timestamp", Ty.path "u32");
              ("timestamp_max_bits", Ty.path "usize");
              ("memory_bus",
                Ty.path "openvm_circuit::system::memory::offline_checker::bus::MemoryBus");
              ("range_checker",
                Ty.path "openvm_circuit_primitives::var_range::SharedVariableRangeCheckerChip");
              ("log",
                Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  []
                  [
                    Ty.apply
                      (Ty.path "core::option::Option")
                      []
                      [
                        Ty.apply
                          (Ty.path "openvm_circuit::system::memory::offline::MemoryRecord")
                          []
                          [ F ]
                      ];
                    Ty.path "alloc::alloc::Global"
                  ])
            ];
        } *)
      
      Module Impl_openvm_circuit_system_memory_offline_OfflineMemory_F.
        Definition Self (F : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "openvm_circuit::system::memory::offline::OfflineMemory") [] [ F ].
        
        (*
            pub fn new(
                initial_memory: MemoryImage<F>,
                initial_block_size: usize,
                memory_bus: MemoryBus,
                range_checker: SharedVariableRangeCheckerChip,
                config: MemoryConfig,
            ) -> Self {
                assert_eq!(initial_memory.as_offset, config.as_offset);
                Self {
                    block_data: BlockMap::from_mem_config(&config, initial_block_size),
                    data: initial_memory.paged_vecs,
                    as_offset: config.as_offset,
                    timestamp: INITIAL_TIMESTAMP + 1,
                    timestamp_max_bits: config.clk_max_bits,
                    memory_bus,
                    range_checker,
                    log: vec![],
                }
            }
        *)
        Definition new (F : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self F in
          match ε, τ, α with
          | [], [], [ initial_memory; initial_block_size; memory_bus; range_checker; config ] =>
            ltac:(M.monadic
              (let initial_memory :=
                M.alloc (|
                  Ty.apply
                    (Ty.path "openvm_circuit::system::memory::paged_vec::AddressMap")
                    [
                      M.unevaluated_const
                        (mk_str (|
                          "openvm_circuit_system_memory_controller_MemoryImage_discriminant"
                        |))
                    ]
                    [ F ],
                  initial_memory
                |) in
              let initial_block_size := M.alloc (| Ty.path "usize", initial_block_size |) in
              let memory_bus :=
                M.alloc (|
                  Ty.path "openvm_circuit::system::memory::offline_checker::bus::MemoryBus",
                  memory_bus
                |) in
              let range_checker :=
                M.alloc (|
                  Ty.path "openvm_circuit_primitives::var_range::SharedVariableRangeCheckerChip",
                  range_checker
                |) in
              let config :=
                M.alloc (| Ty.path "openvm_circuit::arch::config::MemoryConfig", config |) in
              M.read (|
                let~ _ : Ty.tuple [] :=
                  M.match_operator (|
                    Ty.tuple [],
                    M.alloc (|
                      Ty.tuple
                        [
                          Ty.apply (Ty.path "&") [] [ Ty.path "u32" ];
                          Ty.apply (Ty.path "&") [] [ Ty.path "u32" ]
                        ],
                      Value.Tuple
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              initial_memory,
                              "openvm_circuit::system::memory::paged_vec::AddressMap",
                              "as_offset"
                            |)
                          |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              config,
                              "openvm_circuit::arch::config::MemoryConfig",
                              "as_offset"
                            |)
                          |)
                        ]
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                          let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                          let left_val :=
                            M.copy (| Ty.apply (Ty.path "&") [] [ Ty.path "u32" ], γ0_0 |) in
                          let right_val :=
                            M.copy (| Ty.apply (Ty.path "&") [] [ Ty.path "u32" ], γ0_1 |) in
                          M.match_operator (|
                            Ty.tuple [],
                            M.alloc (| Ty.tuple [], Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ :=
                                    M.use
                                      (M.alloc (|
                                        Ty.path "bool",
                                        UnOp.not (|
                                          M.call_closure (|
                                            Ty.path "bool",
                                            BinOp.eq,
                                            [
                                              M.read (| M.deref (| M.read (| left_val |) |) |);
                                              M.read (| M.deref (| M.read (| right_val |) |) |)
                                            ]
                                          |)
                                        |)
                                      |)) in
                                  let _ :=
                                    is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  M.never_to_any (|
                                    M.read (|
                                      let~ kind : Ty.path "core::panicking::AssertKind" :=
                                        Value.StructTuple
                                          "core::panicking::AssertKind::Eq"
                                          []
                                          []
                                          [] in
                                      M.alloc (|
                                        Ty.path "never",
                                        M.call_closure (|
                                          Ty.path "never",
                                          M.get_function (|
                                            "core::panicking::assert_failed",
                                            [],
                                            [ Ty.path "u32"; Ty.path "u32" ]
                                          |),
                                          [
                                            M.read (| kind |);
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (| M.read (| left_val |) |)
                                                |)
                                              |)
                                            |);
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (| M.read (| right_val |) |)
                                                |)
                                              |)
                                            |);
                                            Value.StructTuple
                                              "core::option::Option::None"
                                              []
                                              [ Ty.path "core::fmt::Arguments" ]
                                              []
                                          ]
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ => ltac:(M.monadic (Value.Tuple []))
                            ]
                          |)))
                    ]
                  |) in
                M.alloc (|
                  Ty.apply
                    (Ty.path "openvm_circuit::system::memory::offline::OfflineMemory")
                    []
                    [ F ],
                  Value.mkStructRecord
                    "openvm_circuit::system::memory::offline::OfflineMemory"
                    []
                    [ F ]
                    [
                      ("block_data",
                        M.call_closure (|
                          Ty.path "openvm_circuit::system::memory::offline::BlockMap",
                          M.get_associated_function (|
                            Ty.path "openvm_circuit::system::memory::offline::BlockMap",
                            "from_mem_config",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (| M.borrow (| Pointer.Kind.Ref, config |) |)
                            |);
                            M.read (| initial_block_size |)
                          ]
                        |));
                      ("data",
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            initial_memory,
                            "openvm_circuit::system::memory::paged_vec::AddressMap",
                            "paged_vecs"
                          |)
                        |));
                      ("as_offset",
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            config,
                            "openvm_circuit::arch::config::MemoryConfig",
                            "as_offset"
                          |)
                        |));
                      ("timestamp",
                        M.call_closure (|
                          Ty.path "u32",
                          BinOp.Wrap.add,
                          [
                            M.read (|
                              get_constant (|
                                "openvm_circuit::system::memory::offline::INITIAL_TIMESTAMP",
                                Ty.path "u32"
                              |)
                            |);
                            Value.Integer IntegerKind.U32 1
                          ]
                        |));
                      ("timestamp_max_bits",
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            config,
                            "openvm_circuit::arch::config::MemoryConfig",
                            "clk_max_bits"
                          |)
                        |));
                      ("memory_bus", M.read (| memory_bus |));
                      ("range_checker", M.read (| range_checker |));
                      ("log",
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            []
                            [
                              Ty.apply
                                (Ty.path "core::option::Option")
                                []
                                [
                                  Ty.apply
                                    (Ty.path
                                      "openvm_circuit::system::memory::offline::MemoryRecord")
                                    []
                                    [ F ]
                                ];
                              Ty.path "alloc::alloc::Global"
                            ],
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              []
                              [
                                Ty.apply
                                  (Ty.path "core::option::Option")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path
                                        "openvm_circuit::system::memory::offline::MemoryRecord")
                                      []
                                      [ F ]
                                  ];
                                Ty.path "alloc::alloc::Global"
                              ],
                            "new",
                            [],
                            []
                          |),
                          []
                        |))
                    ]
                |)
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Global Instance AssociatedFunction_new :
          forall (F : Ty.t),
          M.IsAssociatedFunction.C (Self F) "new" (new F).
        Admitted.
        Global Typeclasses Opaque new.
        
        (*
            pub fn set_initial_memory(&mut self, initial_memory: MemoryImage<F>, config: MemoryConfig) {
                assert_eq!(self.timestamp, INITIAL_TIMESTAMP + 1);
                assert_eq!(initial_memory.as_offset, config.as_offset);
                self.as_offset = config.as_offset;
                self.data = initial_memory.paged_vecs;
            }
        *)
        Definition set_initial_memory
            (F : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self F in
          match ε, τ, α with
          | [], [], [ self; initial_memory; config ] =>
            ltac:(M.monadic
              (let self :=
                M.alloc (|
                  Ty.apply
                    (Ty.path "&mut")
                    []
                    [
                      Ty.apply
                        (Ty.path "openvm_circuit::system::memory::offline::OfflineMemory")
                        []
                        [ F ]
                    ],
                  self
                |) in
              let initial_memory :=
                M.alloc (|
                  Ty.apply
                    (Ty.path "openvm_circuit::system::memory::paged_vec::AddressMap")
                    [
                      M.unevaluated_const
                        (mk_str (|
                          "openvm_circuit_system_memory_controller_MemoryImage_discriminant"
                        |))
                    ]
                    [ F ],
                  initial_memory
                |) in
              let config :=
                M.alloc (| Ty.path "openvm_circuit::arch::config::MemoryConfig", config |) in
              M.read (|
                let~ _ : Ty.tuple [] :=
                  M.match_operator (|
                    Ty.tuple [],
                    M.alloc (|
                      Ty.tuple
                        [
                          Ty.apply (Ty.path "&") [] [ Ty.path "u32" ];
                          Ty.apply (Ty.path "&") [] [ Ty.path "u32" ]
                        ],
                      Value.Tuple
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "openvm_circuit::system::memory::offline::OfflineMemory",
                              "timestamp"
                            |)
                          |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.alloc (|
                              Ty.path "u32",
                              M.call_closure (|
                                Ty.path "u32",
                                BinOp.Wrap.add,
                                [
                                  M.read (|
                                    get_constant (|
                                      "openvm_circuit::system::memory::offline::INITIAL_TIMESTAMP",
                                      Ty.path "u32"
                                    |)
                                  |);
                                  Value.Integer IntegerKind.U32 1
                                ]
                              |)
                            |)
                          |)
                        ]
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                          let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                          let left_val :=
                            M.copy (| Ty.apply (Ty.path "&") [] [ Ty.path "u32" ], γ0_0 |) in
                          let right_val :=
                            M.copy (| Ty.apply (Ty.path "&") [] [ Ty.path "u32" ], γ0_1 |) in
                          M.match_operator (|
                            Ty.tuple [],
                            M.alloc (| Ty.tuple [], Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ :=
                                    M.use
                                      (M.alloc (|
                                        Ty.path "bool",
                                        UnOp.not (|
                                          M.call_closure (|
                                            Ty.path "bool",
                                            BinOp.eq,
                                            [
                                              M.read (| M.deref (| M.read (| left_val |) |) |);
                                              M.read (| M.deref (| M.read (| right_val |) |) |)
                                            ]
                                          |)
                                        |)
                                      |)) in
                                  let _ :=
                                    is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  M.never_to_any (|
                                    M.read (|
                                      let~ kind : Ty.path "core::panicking::AssertKind" :=
                                        Value.StructTuple
                                          "core::panicking::AssertKind::Eq"
                                          []
                                          []
                                          [] in
                                      M.alloc (|
                                        Ty.path "never",
                                        M.call_closure (|
                                          Ty.path "never",
                                          M.get_function (|
                                            "core::panicking::assert_failed",
                                            [],
                                            [ Ty.path "u32"; Ty.path "u32" ]
                                          |),
                                          [
                                            M.read (| kind |);
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (| M.read (| left_val |) |)
                                                |)
                                              |)
                                            |);
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (| M.read (| right_val |) |)
                                                |)
                                              |)
                                            |);
                                            Value.StructTuple
                                              "core::option::Option::None"
                                              []
                                              [ Ty.path "core::fmt::Arguments" ]
                                              []
                                          ]
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ => ltac:(M.monadic (Value.Tuple []))
                            ]
                          |)))
                    ]
                  |) in
                let~ _ : Ty.tuple [] :=
                  M.match_operator (|
                    Ty.tuple [],
                    M.alloc (|
                      Ty.tuple
                        [
                          Ty.apply (Ty.path "&") [] [ Ty.path "u32" ];
                          Ty.apply (Ty.path "&") [] [ Ty.path "u32" ]
                        ],
                      Value.Tuple
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              initial_memory,
                              "openvm_circuit::system::memory::paged_vec::AddressMap",
                              "as_offset"
                            |)
                          |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              config,
                              "openvm_circuit::arch::config::MemoryConfig",
                              "as_offset"
                            |)
                          |)
                        ]
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                          let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                          let left_val :=
                            M.copy (| Ty.apply (Ty.path "&") [] [ Ty.path "u32" ], γ0_0 |) in
                          let right_val :=
                            M.copy (| Ty.apply (Ty.path "&") [] [ Ty.path "u32" ], γ0_1 |) in
                          M.match_operator (|
                            Ty.tuple [],
                            M.alloc (| Ty.tuple [], Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ :=
                                    M.use
                                      (M.alloc (|
                                        Ty.path "bool",
                                        UnOp.not (|
                                          M.call_closure (|
                                            Ty.path "bool",
                                            BinOp.eq,
                                            [
                                              M.read (| M.deref (| M.read (| left_val |) |) |);
                                              M.read (| M.deref (| M.read (| right_val |) |) |)
                                            ]
                                          |)
                                        |)
                                      |)) in
                                  let _ :=
                                    is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  M.never_to_any (|
                                    M.read (|
                                      let~ kind : Ty.path "core::panicking::AssertKind" :=
                                        Value.StructTuple
                                          "core::panicking::AssertKind::Eq"
                                          []
                                          []
                                          [] in
                                      M.alloc (|
                                        Ty.path "never",
                                        M.call_closure (|
                                          Ty.path "never",
                                          M.get_function (|
                                            "core::panicking::assert_failed",
                                            [],
                                            [ Ty.path "u32"; Ty.path "u32" ]
                                          |),
                                          [
                                            M.read (| kind |);
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (| M.read (| left_val |) |)
                                                |)
                                              |)
                                            |);
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (| M.read (| right_val |) |)
                                                |)
                                              |)
                                            |);
                                            Value.StructTuple
                                              "core::option::Option::None"
                                              []
                                              [ Ty.path "core::fmt::Arguments" ]
                                              []
                                          ]
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ => ltac:(M.monadic (Value.Tuple []))
                            ]
                          |)))
                    ]
                  |) in
                let~ _ : Ty.tuple [] :=
                  M.write (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "openvm_circuit::system::memory::offline::OfflineMemory",
                      "as_offset"
                    |),
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        config,
                        "openvm_circuit::arch::config::MemoryConfig",
                        "as_offset"
                      |)
                    |)
                  |) in
                let~ _ : Ty.tuple [] :=
                  M.write (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "openvm_circuit::system::memory::offline::OfflineMemory",
                      "data"
                    |),
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        initial_memory,
                        "openvm_circuit::system::memory::paged_vec::AddressMap",
                        "paged_vecs"
                      |)
                    |)
                  |) in
                M.alloc (| Ty.tuple [], Value.Tuple [] |)
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Global Instance AssociatedFunction_set_initial_memory :
          forall (F : Ty.t),
          M.IsAssociatedFunction.C (Self F) "set_initial_memory" (set_initial_memory F).
        Admitted.
        Global Typeclasses Opaque set_initial_memory.
        
        (*
            pub(super) fn set_log_capacity(&mut self, access_capacity: usize) {
                assert!(self.log.is_empty());
                self.log = Vec::with_capacity(access_capacity);
            }
        *)
        Definition set_log_capacity
            (F : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self F in
          match ε, τ, α with
          | [], [], [ self; access_capacity ] =>
            ltac:(M.monadic
              (let self :=
                M.alloc (|
                  Ty.apply
                    (Ty.path "&mut")
                    []
                    [
                      Ty.apply
                        (Ty.path "openvm_circuit::system::memory::offline::OfflineMemory")
                        []
                        [ F ]
                    ],
                  self
                |) in
              let access_capacity := M.alloc (| Ty.path "usize", access_capacity |) in
              M.read (|
                let~ _ : Ty.tuple [] :=
                  M.match_operator (|
                    Ty.tuple [],
                    M.alloc (| Ty.tuple [], Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                Ty.path "bool",
                                UnOp.not (|
                                  M.call_closure (|
                                    Ty.path "bool",
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "alloc::vec::Vec")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "core::option::Option")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path
                                                  "openvm_circuit::system::memory::offline::MemoryRecord")
                                                []
                                                [ F ]
                                            ];
                                          Ty.path "alloc::alloc::Global"
                                        ],
                                      "is_empty",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.SubPointer.get_struct_record_field (|
                                          M.deref (| M.read (| self |) |),
                                          "openvm_circuit::system::memory::offline::OfflineMemory",
                                          "log"
                                        |)
                                      |)
                                    ]
                                  |)
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.never_to_any (|
                            M.call_closure (|
                              Ty.path "never",
                              M.get_function (| "core::panicking::panic", [], [] |),
                              [ mk_str (| "assertion failed: self.log.is_empty()" |) ]
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (Value.Tuple []))
                    ]
                  |) in
                let~ _ : Ty.tuple [] :=
                  M.write (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "openvm_circuit::system::memory::offline::OfflineMemory",
                      "log"
                    |),
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        []
                        [
                          Ty.apply
                            (Ty.path "core::option::Option")
                            []
                            [
                              Ty.apply
                                (Ty.path "openvm_circuit::system::memory::offline::MemoryRecord")
                                []
                                [ F ]
                            ];
                          Ty.path "alloc::alloc::Global"
                        ],
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::vec::Vec")
                          []
                          [
                            Ty.apply
                              (Ty.path "core::option::Option")
                              []
                              [
                                Ty.apply
                                  (Ty.path "openvm_circuit::system::memory::offline::MemoryRecord")
                                  []
                                  [ F ]
                              ];
                            Ty.path "alloc::alloc::Global"
                          ],
                        "with_capacity",
                        [],
                        []
                      |),
                      [ M.read (| access_capacity |) ]
                    |)
                  |) in
                M.alloc (| Ty.tuple [], Value.Tuple [] |)
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Global Instance AssociatedFunction_set_log_capacity :
          forall (F : Ty.t),
          M.IsAssociatedFunction.C (Self F) "set_log_capacity" (set_log_capacity F).
        Admitted.
        Global Typeclasses Opaque set_log_capacity.
        
        (*
            pub fn memory_bridge(&self) -> MemoryBridge {
                MemoryBridge::new(
                    self.memory_bus,
                    self.timestamp_max_bits,
                    self.range_checker.bus(),
                )
            }
        *)
        Definition memory_bridge
            (F : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self F in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self :=
                M.alloc (|
                  Ty.apply
                    (Ty.path "&")
                    []
                    [
                      Ty.apply
                        (Ty.path "openvm_circuit::system::memory::offline::OfflineMemory")
                        []
                        [ F ]
                    ],
                  self
                |) in
              M.call_closure (|
                Ty.path "openvm_circuit::system::memory::offline_checker::bridge::MemoryBridge",
                M.get_associated_function (|
                  Ty.path "openvm_circuit::system::memory::offline_checker::bridge::MemoryBridge",
                  "new",
                  [],
                  []
                |),
                [
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "openvm_circuit::system::memory::offline::OfflineMemory",
                      "memory_bus"
                    |)
                  |);
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "openvm_circuit::system::memory::offline::OfflineMemory",
                      "timestamp_max_bits"
                    |)
                  |);
                  M.call_closure (|
                    Ty.path "openvm_circuit_primitives::var_range::bus::VariableRangeCheckerBus",
                    M.get_associated_function (|
                      Ty.path
                        "openvm_circuit_primitives::var_range::SharedVariableRangeCheckerChip",
                      "bus",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "openvm_circuit::system::memory::offline::OfflineMemory",
                          "range_checker"
                        |)
                      |)
                    ]
                  |)
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Global Instance AssociatedFunction_memory_bridge :
          forall (F : Ty.t),
          M.IsAssociatedFunction.C (Self F) "memory_bridge" (memory_bridge F).
        Admitted.
        Global Typeclasses Opaque memory_bridge.
        
        (*
            pub fn timestamp(&self) -> u32 {
                self.timestamp
            }
        *)
        Definition timestamp (F : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self F in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self :=
                M.alloc (|
                  Ty.apply
                    (Ty.path "&")
                    []
                    [
                      Ty.apply
                        (Ty.path "openvm_circuit::system::memory::offline::OfflineMemory")
                        []
                        [ F ]
                    ],
                  self
                |) in
              M.read (|
                M.SubPointer.get_struct_record_field (|
                  M.deref (| M.read (| self |) |),
                  "openvm_circuit::system::memory::offline::OfflineMemory",
                  "timestamp"
                |)
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Global Instance AssociatedFunction_timestamp :
          forall (F : Ty.t),
          M.IsAssociatedFunction.C (Self F) "timestamp" (timestamp F).
        Admitted.
        Global Typeclasses Opaque timestamp.
        
        (*
            pub fn increment_timestamp(&mut self) {
                self.increment_timestamp_by(1)
            }
        *)
        Definition increment_timestamp
            (F : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self F in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self :=
                M.alloc (|
                  Ty.apply
                    (Ty.path "&mut")
                    []
                    [
                      Ty.apply
                        (Ty.path "openvm_circuit::system::memory::offline::OfflineMemory")
                        []
                        [ F ]
                    ],
                  self
                |) in
              M.call_closure (|
                Ty.tuple [],
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "openvm_circuit::system::memory::offline::OfflineMemory")
                    []
                    [ F ],
                  "increment_timestamp_by",
                  [],
                  []
                |),
                [
                  M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                  Value.Integer IntegerKind.U32 1
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Global Instance AssociatedFunction_increment_timestamp :
          forall (F : Ty.t),
          M.IsAssociatedFunction.C (Self F) "increment_timestamp" (increment_timestamp F).
        Admitted.
        Global Typeclasses Opaque increment_timestamp.
        
        (*
            pub fn increment_timestamp_by(&mut self, delta: u32) {
                self.log.push(None);
                self.timestamp += delta;
            }
        *)
        Definition increment_timestamp_by
            (F : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self F in
          match ε, τ, α with
          | [], [], [ self; delta ] =>
            ltac:(M.monadic
              (let self :=
                M.alloc (|
                  Ty.apply
                    (Ty.path "&mut")
                    []
                    [
                      Ty.apply
                        (Ty.path "openvm_circuit::system::memory::offline::OfflineMemory")
                        []
                        [ F ]
                    ],
                  self
                |) in
              let delta := M.alloc (| Ty.path "u32", delta |) in
              M.read (|
                let~ _ : Ty.tuple [] :=
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        []
                        [
                          Ty.apply
                            (Ty.path "core::option::Option")
                            []
                            [
                              Ty.apply
                                (Ty.path "openvm_circuit::system::memory::offline::MemoryRecord")
                                []
                                [ F ]
                            ];
                          Ty.path "alloc::alloc::Global"
                        ],
                      "push",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "openvm_circuit::system::memory::offline::OfflineMemory",
                          "log"
                        |)
                      |);
                      Value.StructTuple
                        "core::option::Option::None"
                        []
                        [
                          Ty.apply
                            (Ty.path "openvm_circuit::system::memory::offline::MemoryRecord")
                            []
                            [ F ]
                        ]
                        []
                    ]
                  |) in
                let~ _ : Ty.tuple [] :=
                  let β :=
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "openvm_circuit::system::memory::offline::OfflineMemory",
                      "timestamp"
                    |) in
                  M.write (|
                    β,
                    M.call_closure (|
                      Ty.path "u32",
                      BinOp.Wrap.add,
                      [ M.read (| β |); M.read (| delta |) ]
                    |)
                  |) in
                M.alloc (| Ty.tuple [], Value.Tuple [] |)
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Global Instance AssociatedFunction_increment_timestamp_by :
          forall (F : Ty.t),
          M.IsAssociatedFunction.C (Self F) "increment_timestamp_by" (increment_timestamp_by F).
        Admitted.
        Global Typeclasses Opaque increment_timestamp_by.
        
        (*
            pub fn write(
                &mut self,
                address_space: u32,
                pointer: u32,
                values: Vec<F>,
                records: &mut AccessAdapterInventory<F>,
            ) {
                let len = values.len();
                assert!(len.is_power_of_two());
                assert_ne!(address_space, 0);
        
                let prev_timestamp = self.access_updating_timestamp(address_space, pointer, len, records);
        
                debug_assert!(prev_timestamp < self.timestamp);
        
                let pointer = pointer as usize;
                let prev_data = self.data[(address_space - self.as_offset) as usize]
                    .set_range(pointer..pointer + len, &values);
        
                let record = MemoryRecord {
                    address_space: F::from_canonical_u32(address_space),
                    pointer: F::from_canonical_usize(pointer),
                    timestamp: self.timestamp,
                    prev_timestamp,
                    data: values,
                    prev_data: Some(prev_data),
                };
                self.log.push(Some(record));
                self.timestamp += 1;
            }
        *)
        Definition write (F : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self F in
          match ε, τ, α with
          | [], [], [ self; address_space; pointer; values; records ] =>
            ltac:(M.monadic
              (let self :=
                M.alloc (|
                  Ty.apply
                    (Ty.path "&mut")
                    []
                    [
                      Ty.apply
                        (Ty.path "openvm_circuit::system::memory::offline::OfflineMemory")
                        []
                        [ F ]
                    ],
                  self
                |) in
              let address_space := M.alloc (| Ty.path "u32", address_space |) in
              let pointer := M.alloc (| Ty.path "u32", pointer |) in
              let values :=
                M.alloc (|
                  Ty.apply (Ty.path "alloc::vec::Vec") [] [ F; Ty.path "alloc::alloc::Global" ],
                  values
                |) in
              let records :=
                M.alloc (|
                  Ty.apply
                    (Ty.path "&mut")
                    []
                    [
                      Ty.apply
                        (Ty.path "openvm_circuit::system::memory::adapter::AccessAdapterInventory")
                        []
                        [ F ]
                    ],
                  records
                |) in
              M.read (|
                let~ len : Ty.path "usize" :=
                  M.call_closure (|
                    Ty.path "usize",
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloc::vec::Vec") [] [ F; Ty.path "alloc::alloc::Global" ],
                      "len",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, values |) ]
                  |) in
                let~ _ : Ty.tuple [] :=
                  M.match_operator (|
                    Ty.tuple [],
                    M.alloc (| Ty.tuple [], Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                Ty.path "bool",
                                UnOp.not (|
                                  M.call_closure (|
                                    Ty.path "bool",
                                    M.get_associated_function (|
                                      Ty.path "usize",
                                      "is_power_of_two",
                                      [],
                                      []
                                    |),
                                    [ M.read (| len |) ]
                                  |)
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.never_to_any (|
                            M.call_closure (|
                              Ty.path "never",
                              M.get_function (| "core::panicking::panic", [], [] |),
                              [ mk_str (| "assertion failed: len.is_power_of_two()" |) ]
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (Value.Tuple []))
                    ]
                  |) in
                let~ _ : Ty.tuple [] :=
                  M.match_operator (|
                    Ty.tuple [],
                    M.alloc (|
                      Ty.tuple
                        [
                          Ty.apply (Ty.path "&") [] [ Ty.path "u32" ];
                          Ty.apply (Ty.path "&") [] [ Ty.path "u32" ]
                        ],
                      Value.Tuple
                        [
                          M.borrow (| Pointer.Kind.Ref, address_space |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.alloc (| Ty.path "u32", Value.Integer IntegerKind.U32 0 |)
                          |)
                        ]
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                          let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                          let left_val :=
                            M.copy (| Ty.apply (Ty.path "&") [] [ Ty.path "u32" ], γ0_0 |) in
                          let right_val :=
                            M.copy (| Ty.apply (Ty.path "&") [] [ Ty.path "u32" ], γ0_1 |) in
                          M.match_operator (|
                            Ty.tuple [],
                            M.alloc (| Ty.tuple [], Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ :=
                                    M.use
                                      (M.alloc (|
                                        Ty.path "bool",
                                        M.call_closure (|
                                          Ty.path "bool",
                                          BinOp.eq,
                                          [
                                            M.read (| M.deref (| M.read (| left_val |) |) |);
                                            M.read (| M.deref (| M.read (| right_val |) |) |)
                                          ]
                                        |)
                                      |)) in
                                  let _ :=
                                    is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  M.never_to_any (|
                                    M.read (|
                                      let~ kind : Ty.path "core::panicking::AssertKind" :=
                                        Value.StructTuple
                                          "core::panicking::AssertKind::Ne"
                                          []
                                          []
                                          [] in
                                      M.alloc (|
                                        Ty.path "never",
                                        M.call_closure (|
                                          Ty.path "never",
                                          M.get_function (|
                                            "core::panicking::assert_failed",
                                            [],
                                            [ Ty.path "u32"; Ty.path "u32" ]
                                          |),
                                          [
                                            M.read (| kind |);
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (| M.read (| left_val |) |)
                                                |)
                                              |)
                                            |);
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (| M.read (| right_val |) |)
                                                |)
                                              |)
                                            |);
                                            Value.StructTuple
                                              "core::option::Option::None"
                                              []
                                              [ Ty.path "core::fmt::Arguments" ]
                                              []
                                          ]
                                        |)
                                      |)
                                    |)
                                  |)));
                              fun γ => ltac:(M.monadic (Value.Tuple []))
                            ]
                          |)))
                    ]
                  |) in
                let~ prev_timestamp : Ty.path "u32" :=
                  M.call_closure (|
                    Ty.path "u32",
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "openvm_circuit::system::memory::offline::OfflineMemory")
                        []
                        [ F ],
                      "access_updating_timestamp",
                      [],
                      []
                    |),
                    [
                      M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                      M.read (| address_space |);
                      M.read (| pointer |);
                      M.read (| len |);
                      M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| records |) |) |)
                    ]
                  |) in
                let~ _ : Ty.tuple [] :=
                  M.match_operator (|
                    Ty.tuple [],
                    M.alloc (| Ty.tuple [], Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ := M.use (M.alloc (| Ty.path "bool", Value.Bool true |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.read (|
                            let~ _ : Ty.tuple [] :=
                              M.match_operator (|
                                Ty.tuple [],
                                M.alloc (| Ty.tuple [], Value.Tuple [] |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ :=
                                        M.use
                                          (M.alloc (|
                                            Ty.path "bool",
                                            UnOp.not (|
                                              M.call_closure (|
                                                Ty.path "bool",
                                                BinOp.lt,
                                                [
                                                  M.read (| prev_timestamp |);
                                                  M.read (|
                                                    M.SubPointer.get_struct_record_field (|
                                                      M.deref (| M.read (| self |) |),
                                                      "openvm_circuit::system::memory::offline::OfflineMemory",
                                                      "timestamp"
                                                    |)
                                                  |)
                                                ]
                                              |)
                                            |)
                                          |)) in
                                      let _ :=
                                        is_constant_or_break_match (|
                                          M.read (| γ |),
                                          Value.Bool true
                                        |) in
                                      M.never_to_any (|
                                        M.call_closure (|
                                          Ty.path "never",
                                          M.get_function (| "core::panicking::panic", [], [] |),
                                          [
                                            mk_str (|
                                              "assertion failed: prev_timestamp < self.timestamp"
                                            |)
                                          ]
                                        |)
                                      |)));
                                  fun γ => ltac:(M.monadic (Value.Tuple []))
                                ]
                              |) in
                            M.alloc (| Ty.tuple [], Value.Tuple [] |)
                          |)));
                      fun γ => ltac:(M.monadic (Value.Tuple []))
                    ]
                  |) in
                let~ pointer : Ty.path "usize" := M.cast (Ty.path "usize") (M.read (| pointer |)) in
                let~ prev_data :
                    Ty.apply (Ty.path "alloc::vec::Vec") [] [ F; Ty.path "alloc::alloc::Global" ] :=
                  M.call_closure (|
                    Ty.apply (Ty.path "alloc::vec::Vec") [] [ F; Ty.path "alloc::alloc::Global" ],
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "openvm_circuit::system::memory::paged_vec::PagedVec")
                        [ Value.Integer IntegerKind.Usize 4096 ]
                        [ F ],
                      "set_range",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.deref (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "&mut")
                              []
                              [
                                Ty.apply
                                  (Ty.path "openvm_circuit::system::memory::paged_vec::PagedVec")
                                  [ Value.Integer IntegerKind.Usize 4096 ]
                                  [ F ]
                              ],
                            M.get_trait_method (|
                              "core::ops::index::IndexMut",
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "openvm_circuit::system::memory::paged_vec::PagedVec")
                                    [ Value.Integer IntegerKind.Usize 4096 ]
                                    [ F ];
                                  Ty.path "alloc::alloc::Global"
                                ],
                              [],
                              [ Ty.path "usize" ],
                              "index_mut",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.MutRef,
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "openvm_circuit::system::memory::offline::OfflineMemory",
                                  "data"
                                |)
                              |);
                              M.cast
                                (Ty.path "usize")
                                (M.call_closure (|
                                  Ty.path "u32",
                                  BinOp.Wrap.sub,
                                  [
                                    M.read (| address_space |);
                                    M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        M.deref (| M.read (| self |) |),
                                        "openvm_circuit::system::memory::offline::OfflineMemory",
                                        "as_offset"
                                      |)
                                    |)
                                  ]
                                |))
                            ]
                          |)
                        |)
                      |);
                      Value.mkStructRecord
                        "core::ops::range::Range"
                        []
                        [ Ty.path "usize" ]
                        [
                          ("start", M.read (| pointer |));
                          ("end_",
                            M.call_closure (|
                              Ty.path "usize",
                              BinOp.Wrap.add,
                              [ M.read (| pointer |); M.read (| len |) ]
                            |))
                        ];
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.call_closure (|
                            Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ F ] ],
                            M.get_trait_method (|
                              "core::ops::deref::Deref",
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                []
                                [ F; Ty.path "alloc::alloc::Global" ],
                              [],
                              [],
                              "deref",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.deref (| M.borrow (| Pointer.Kind.Ref, values |) |)
                              |)
                            ]
                          |)
                        |)
                      |)
                    ]
                  |) in
                let~ record :
                    Ty.apply
                      (Ty.path "openvm_circuit::system::memory::offline::MemoryRecord")
                      []
                      [ F ] :=
                  Value.mkStructRecord
                    "openvm_circuit::system::memory::offline::MemoryRecord"
                    []
                    [ F ]
                    [
                      ("address_space",
                        M.call_closure (|
                          F,
                          M.get_trait_method (|
                            "p3_field::field::FieldAlgebra",
                            F,
                            [],
                            [],
                            "from_canonical_u32",
                            [],
                            []
                          |),
                          [ M.read (| address_space |) ]
                        |));
                      ("pointer",
                        M.call_closure (|
                          F,
                          M.get_trait_method (|
                            "p3_field::field::FieldAlgebra",
                            F,
                            [],
                            [],
                            "from_canonical_usize",
                            [],
                            []
                          |),
                          [ M.read (| pointer |) ]
                        |));
                      ("timestamp",
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "openvm_circuit::system::memory::offline::OfflineMemory",
                            "timestamp"
                          |)
                        |));
                      ("prev_timestamp", M.read (| prev_timestamp |));
                      ("data", M.read (| values |));
                      ("prev_data",
                        Value.StructTuple
                          "core::option::Option::Some"
                          []
                          [
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              []
                              [ F; Ty.path "alloc::alloc::Global" ]
                          ]
                          [ M.read (| prev_data |) ])
                    ] in
                let~ _ : Ty.tuple [] :=
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        []
                        [
                          Ty.apply
                            (Ty.path "core::option::Option")
                            []
                            [
                              Ty.apply
                                (Ty.path "openvm_circuit::system::memory::offline::MemoryRecord")
                                []
                                [ F ]
                            ];
                          Ty.path "alloc::alloc::Global"
                        ],
                      "push",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "openvm_circuit::system::memory::offline::OfflineMemory",
                          "log"
                        |)
                      |);
                      Value.StructTuple
                        "core::option::Option::Some"
                        []
                        [
                          Ty.apply
                            (Ty.path "openvm_circuit::system::memory::offline::MemoryRecord")
                            []
                            [ F ]
                        ]
                        [ M.read (| record |) ]
                    ]
                  |) in
                let~ _ : Ty.tuple [] :=
                  let β :=
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "openvm_circuit::system::memory::offline::OfflineMemory",
                      "timestamp"
                    |) in
                  M.write (|
                    β,
                    M.call_closure (|
                      Ty.path "u32",
                      BinOp.Wrap.add,
                      [ M.read (| β |); Value.Integer IntegerKind.U32 1 ]
                    |)
                  |) in
                M.alloc (| Ty.tuple [], Value.Tuple [] |)
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Global Instance AssociatedFunction_write :
          forall (F : Ty.t),
          M.IsAssociatedFunction.C (Self F) "write" (write F).
        Admitted.
        Global Typeclasses Opaque write.
        
        (*
            pub fn read(
                &mut self,
                address_space: u32,
                pointer: u32,
                len: usize,
                adapter_records: &mut AccessAdapterInventory<F>,
            ) {
                assert!(len.is_power_of_two());
                if address_space == 0 {
                    let pointer = F::from_canonical_u32(pointer);
                    self.log.push(Some(MemoryRecord {
                        address_space: F::ZERO,
                        pointer,
                        timestamp: self.timestamp,
                        prev_timestamp: 0,
                        data: vec![pointer],
                        prev_data: None,
                    }));
                    self.timestamp += 1;
                    return;
                }
        
                let prev_timestamp =
                    self.access_updating_timestamp(address_space, pointer, len, adapter_records);
        
                debug_assert!(prev_timestamp < self.timestamp);
        
                let values = self.range_vec(address_space, pointer, len);
        
                self.log.push(Some(MemoryRecord {
                    address_space: F::from_canonical_u32(address_space),
                    pointer: F::from_canonical_u32(pointer),
                    timestamp: self.timestamp,
                    prev_timestamp,
                    data: values,
                    prev_data: None,
                }));
                self.timestamp += 1;
            }
        *)
        Definition read (F : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self F in
          match ε, τ, α with
          | [], [], [ self; address_space; pointer; len; adapter_records ] =>
            ltac:(M.monadic
              (let self :=
                M.alloc (|
                  Ty.apply
                    (Ty.path "&mut")
                    []
                    [
                      Ty.apply
                        (Ty.path "openvm_circuit::system::memory::offline::OfflineMemory")
                        []
                        [ F ]
                    ],
                  self
                |) in
              let address_space := M.alloc (| Ty.path "u32", address_space |) in
              let pointer := M.alloc (| Ty.path "u32", pointer |) in
              let len := M.alloc (| Ty.path "usize", len |) in
              let adapter_records :=
                M.alloc (|
                  Ty.apply
                    (Ty.path "&mut")
                    []
                    [
                      Ty.apply
                        (Ty.path "openvm_circuit::system::memory::adapter::AccessAdapterInventory")
                        []
                        [ F ]
                    ],
                  adapter_records
                |) in
              M.catch_return (Ty.tuple []) (|
                ltac:(M.monadic
                  (M.read (|
                    let~ _ : Ty.tuple [] :=
                      M.match_operator (|
                        Ty.tuple [],
                        M.alloc (| Ty.tuple [], Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    Ty.path "bool",
                                    UnOp.not (|
                                      M.call_closure (|
                                        Ty.path "bool",
                                        M.get_associated_function (|
                                          Ty.path "usize",
                                          "is_power_of_two",
                                          [],
                                          []
                                        |),
                                        [ M.read (| len |) ]
                                      |)
                                    |)
                                  |)) in
                              let _ :=
                                is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                              M.never_to_any (|
                                M.call_closure (|
                                  Ty.path "never",
                                  M.get_function (| "core::panicking::panic", [], [] |),
                                  [ mk_str (| "assertion failed: len.is_power_of_two()" |) ]
                                |)
                              |)));
                          fun γ => ltac:(M.monadic (Value.Tuple []))
                        ]
                      |) in
                    let~ _ : Ty.tuple [] :=
                      M.match_operator (|
                        Ty.tuple [],
                        M.alloc (| Ty.tuple [], Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    Ty.path "bool",
                                    M.call_closure (|
                                      Ty.path "bool",
                                      BinOp.eq,
                                      [ M.read (| address_space |); Value.Integer IntegerKind.U32 0
                                      ]
                                    |)
                                  |)) in
                              let _ :=
                                is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                              M.never_to_any (|
                                M.read (|
                                  let~ pointer : F :=
                                    M.call_closure (|
                                      F,
                                      M.get_trait_method (|
                                        "p3_field::field::FieldAlgebra",
                                        F,
                                        [],
                                        [],
                                        "from_canonical_u32",
                                        [],
                                        []
                                      |),
                                      [ M.read (| pointer |) ]
                                    |) in
                                  let~ _ : Ty.tuple [] :=
                                    M.call_closure (|
                                      Ty.tuple [],
                                      M.get_associated_function (|
                                        Ty.apply
                                          (Ty.path "alloc::vec::Vec")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "core::option::Option")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path
                                                    "openvm_circuit::system::memory::offline::MemoryRecord")
                                                  []
                                                  [ F ]
                                              ];
                                            Ty.path "alloc::alloc::Global"
                                          ],
                                        "push",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.MutRef,
                                          M.SubPointer.get_struct_record_field (|
                                            M.deref (| M.read (| self |) |),
                                            "openvm_circuit::system::memory::offline::OfflineMemory",
                                            "log"
                                          |)
                                        |);
                                        Value.StructTuple
                                          "core::option::Option::Some"
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path
                                                "openvm_circuit::system::memory::offline::MemoryRecord")
                                              []
                                              [ F ]
                                          ]
                                          [
                                            Value.mkStructRecord
                                              "openvm_circuit::system::memory::offline::MemoryRecord"
                                              []
                                              [ F ]
                                              [
                                                ("address_space",
                                                  M.read (|
                                                    get_constant (|
                                                      "p3_field::field::FieldAlgebra::ZERO",
                                                      F
                                                    |)
                                                  |));
                                                ("pointer", M.read (| pointer |));
                                                ("timestamp",
                                                  M.read (|
                                                    M.SubPointer.get_struct_record_field (|
                                                      M.deref (| M.read (| self |) |),
                                                      "openvm_circuit::system::memory::offline::OfflineMemory",
                                                      "timestamp"
                                                    |)
                                                  |));
                                                ("prev_timestamp", Value.Integer IntegerKind.U32 0);
                                                ("data",
                                                  M.call_closure (|
                                                    Ty.apply
                                                      (Ty.path "alloc::vec::Vec")
                                                      []
                                                      [ F; Ty.path "alloc::alloc::Global" ],
                                                    M.get_associated_function (|
                                                      Ty.apply (Ty.path "slice") [] [ F ],
                                                      "into_vec",
                                                      [],
                                                      [ Ty.path "alloc::alloc::Global" ]
                                                    |),
                                                    [
                                                      M.call_closure (|
                                                        Ty.apply
                                                          (Ty.path "alloc::boxed::Box")
                                                          []
                                                          [
                                                            Ty.apply (Ty.path "slice") [] [ F ];
                                                            Ty.path "alloc::alloc::Global"
                                                          ],
                                                        M.pointer_coercion
                                                          M.PointerCoercion.Unsize
                                                          (Ty.apply
                                                            (Ty.path "alloc::boxed::Box")
                                                            []
                                                            [
                                                              Ty.apply
                                                                (Ty.path "array")
                                                                [ Value.Integer IntegerKind.Usize 1
                                                                ]
                                                                [ F ];
                                                              Ty.path "alloc::alloc::Global"
                                                            ])
                                                          (Ty.apply
                                                            (Ty.path "alloc::boxed::Box")
                                                            []
                                                            [
                                                              Ty.apply (Ty.path "slice") [] [ F ];
                                                              Ty.path "alloc::alloc::Global"
                                                            ]),
                                                        [
                                                          M.read (|
                                                            M.call_closure (|
                                                              Ty.apply
                                                                (Ty.path "alloc::boxed::Box")
                                                                []
                                                                [
                                                                  Ty.apply
                                                                    (Ty.path "array")
                                                                    [
                                                                      Value.Integer
                                                                        IntegerKind.Usize
                                                                        1
                                                                    ]
                                                                    [ F ];
                                                                  Ty.path "alloc::alloc::Global"
                                                                ],
                                                              M.get_associated_function (|
                                                                Ty.apply
                                                                  (Ty.path "alloc::boxed::Box")
                                                                  []
                                                                  [
                                                                    Ty.apply
                                                                      (Ty.path "array")
                                                                      [
                                                                        Value.Integer
                                                                          IntegerKind.Usize
                                                                          1
                                                                      ]
                                                                      [ F ];
                                                                    Ty.path "alloc::alloc::Global"
                                                                  ],
                                                                "new",
                                                                [],
                                                                []
                                                              |),
                                                              [
                                                                M.alloc (|
                                                                  Ty.apply
                                                                    (Ty.path "array")
                                                                    [
                                                                      Value.Integer
                                                                        IntegerKind.Usize
                                                                        1
                                                                    ]
                                                                    [ F ],
                                                                  Value.Array
                                                                    [ M.read (| pointer |) ]
                                                                |)
                                                              ]
                                                            |)
                                                          |)
                                                        ]
                                                      |)
                                                    ]
                                                  |));
                                                ("prev_data",
                                                  Value.StructTuple
                                                    "core::option::Option::None"
                                                    []
                                                    [
                                                      Ty.apply
                                                        (Ty.path "alloc::vec::Vec")
                                                        []
                                                        [ F; Ty.path "alloc::alloc::Global" ]
                                                    ]
                                                    [])
                                              ]
                                          ]
                                      ]
                                    |) in
                                  let~ _ : Ty.tuple [] :=
                                    let β :=
                                      M.SubPointer.get_struct_record_field (|
                                        M.deref (| M.read (| self |) |),
                                        "openvm_circuit::system::memory::offline::OfflineMemory",
                                        "timestamp"
                                      |) in
                                    M.write (|
                                      β,
                                      M.call_closure (|
                                        Ty.path "u32",
                                        BinOp.Wrap.add,
                                        [ M.read (| β |); Value.Integer IntegerKind.U32 1 ]
                                      |)
                                    |) in
                                  M.return_ (| Value.Tuple [] |)
                                |)
                              |)));
                          fun γ => ltac:(M.monadic (Value.Tuple []))
                        ]
                      |) in
                    let~ prev_timestamp : Ty.path "u32" :=
                      M.call_closure (|
                        Ty.path "u32",
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "openvm_circuit::system::memory::offline::OfflineMemory")
                            []
                            [ F ],
                          "access_updating_timestamp",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                          M.read (| address_space |);
                          M.read (| pointer |);
                          M.read (| len |);
                          M.borrow (|
                            Pointer.Kind.MutRef,
                            M.deref (| M.read (| adapter_records |) |)
                          |)
                        ]
                      |) in
                    let~ _ : Ty.tuple [] :=
                      M.match_operator (|
                        Ty.tuple [],
                        M.alloc (| Ty.tuple [], Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ := M.use (M.alloc (| Ty.path "bool", Value.Bool true |)) in
                              let _ :=
                                is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                              M.read (|
                                let~ _ : Ty.tuple [] :=
                                  M.match_operator (|
                                    Ty.tuple [],
                                    M.alloc (| Ty.tuple [], Value.Tuple [] |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let γ :=
                                            M.use
                                              (M.alloc (|
                                                Ty.path "bool",
                                                UnOp.not (|
                                                  M.call_closure (|
                                                    Ty.path "bool",
                                                    BinOp.lt,
                                                    [
                                                      M.read (| prev_timestamp |);
                                                      M.read (|
                                                        M.SubPointer.get_struct_record_field (|
                                                          M.deref (| M.read (| self |) |),
                                                          "openvm_circuit::system::memory::offline::OfflineMemory",
                                                          "timestamp"
                                                        |)
                                                      |)
                                                    ]
                                                  |)
                                                |)
                                              |)) in
                                          let _ :=
                                            is_constant_or_break_match (|
                                              M.read (| γ |),
                                              Value.Bool true
                                            |) in
                                          M.never_to_any (|
                                            M.call_closure (|
                                              Ty.path "never",
                                              M.get_function (| "core::panicking::panic", [], [] |),
                                              [
                                                mk_str (|
                                                  "assertion failed: prev_timestamp < self.timestamp"
                                                |)
                                              ]
                                            |)
                                          |)));
                                      fun γ => ltac:(M.monadic (Value.Tuple []))
                                    ]
                                  |) in
                                M.alloc (| Ty.tuple [], Value.Tuple [] |)
                              |)));
                          fun γ => ltac:(M.monadic (Value.Tuple []))
                        ]
                      |) in
                    let~ values :
                        Ty.apply
                          (Ty.path "alloc::vec::Vec")
                          []
                          [ F; Ty.path "alloc::alloc::Global" ] :=
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "alloc::vec::Vec")
                          []
                          [ F; Ty.path "alloc::alloc::Global" ],
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "openvm_circuit::system::memory::offline::OfflineMemory")
                            []
                            [ F ],
                          "range_vec",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                          M.read (| address_space |);
                          M.read (| pointer |);
                          M.read (| len |)
                        ]
                      |) in
                    let~ _ : Ty.tuple [] :=
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            []
                            [
                              Ty.apply
                                (Ty.path "core::option::Option")
                                []
                                [
                                  Ty.apply
                                    (Ty.path
                                      "openvm_circuit::system::memory::offline::MemoryRecord")
                                    []
                                    [ F ]
                                ];
                              Ty.path "alloc::alloc::Global"
                            ],
                          "push",
                          [],
                          []
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.MutRef,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "openvm_circuit::system::memory::offline::OfflineMemory",
                              "log"
                            |)
                          |);
                          Value.StructTuple
                            "core::option::Option::Some"
                            []
                            [
                              Ty.apply
                                (Ty.path "openvm_circuit::system::memory::offline::MemoryRecord")
                                []
                                [ F ]
                            ]
                            [
                              Value.mkStructRecord
                                "openvm_circuit::system::memory::offline::MemoryRecord"
                                []
                                [ F ]
                                [
                                  ("address_space",
                                    M.call_closure (|
                                      F,
                                      M.get_trait_method (|
                                        "p3_field::field::FieldAlgebra",
                                        F,
                                        [],
                                        [],
                                        "from_canonical_u32",
                                        [],
                                        []
                                      |),
                                      [ M.read (| address_space |) ]
                                    |));
                                  ("pointer",
                                    M.call_closure (|
                                      F,
                                      M.get_trait_method (|
                                        "p3_field::field::FieldAlgebra",
                                        F,
                                        [],
                                        [],
                                        "from_canonical_u32",
                                        [],
                                        []
                                      |),
                                      [ M.read (| pointer |) ]
                                    |));
                                  ("timestamp",
                                    M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        M.deref (| M.read (| self |) |),
                                        "openvm_circuit::system::memory::offline::OfflineMemory",
                                        "timestamp"
                                      |)
                                    |));
                                  ("prev_timestamp", M.read (| prev_timestamp |));
                                  ("data", M.read (| values |));
                                  ("prev_data",
                                    Value.StructTuple
                                      "core::option::Option::None"
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "alloc::vec::Vec")
                                          []
                                          [ F; Ty.path "alloc::alloc::Global" ]
                                      ]
                                      [])
                                ]
                            ]
                        ]
                      |) in
                    let~ _ : Ty.tuple [] :=
                      let β :=
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "openvm_circuit::system::memory::offline::OfflineMemory",
                          "timestamp"
                        |) in
                      M.write (|
                        β,
                        M.call_closure (|
                          Ty.path "u32",
                          BinOp.Wrap.add,
                          [ M.read (| β |); Value.Integer IntegerKind.U32 1 ]
                        |)
                      |) in
                    M.alloc (| Ty.tuple [], Value.Tuple [] |)
                  |)))
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Global Instance AssociatedFunction_read :
          forall (F : Ty.t),
          M.IsAssociatedFunction.C (Self F) "read" (read F).
        Admitted.
        Global Typeclasses Opaque read.
        
        (*
            pub fn record_by_id(&self, id: RecordId) -> &MemoryRecord<F> {
                self.log[id.0].as_ref().unwrap()
            }
        *)
        Definition record_by_id
            (F : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self F in
          match ε, τ, α with
          | [], [], [ self; id ] =>
            ltac:(M.monadic
              (let self :=
                M.alloc (|
                  Ty.apply
                    (Ty.path "&")
                    []
                    [
                      Ty.apply
                        (Ty.path "openvm_circuit::system::memory::offline::OfflineMemory")
                        []
                        [ F ]
                    ],
                  self
                |) in
              let id :=
                M.alloc (| Ty.path "openvm_circuit::system::memory::controller::RecordId", id |) in
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "&")
                      []
                      [
                        Ty.apply
                          (Ty.path "openvm_circuit::system::memory::offline::MemoryRecord")
                          []
                          [ F ]
                      ],
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "core::option::Option")
                        []
                        [
                          Ty.apply
                            (Ty.path "&")
                            []
                            [
                              Ty.apply
                                (Ty.path "openvm_circuit::system::memory::offline::MemoryRecord")
                                []
                                [ F ]
                            ]
                        ],
                      "unwrap",
                      [],
                      []
                    |),
                    [
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::option::Option")
                          []
                          [
                            Ty.apply
                              (Ty.path "&")
                              []
                              [
                                Ty.apply
                                  (Ty.path "openvm_circuit::system::memory::offline::MemoryRecord")
                                  []
                                  [ F ]
                              ]
                          ],
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "core::option::Option")
                            []
                            [
                              Ty.apply
                                (Ty.path "openvm_circuit::system::memory::offline::MemoryRecord")
                                []
                                [ F ]
                            ],
                          "as_ref",
                          [],
                          []
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::option::Option")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path
                                            "openvm_circuit::system::memory::offline::MemoryRecord")
                                          []
                                          [ F ]
                                      ]
                                  ],
                                M.get_trait_method (|
                                  "core::ops::index::Index",
                                  Ty.apply
                                    (Ty.path "alloc::vec::Vec")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "core::option::Option")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path
                                              "openvm_circuit::system::memory::offline::MemoryRecord")
                                            []
                                            [ F ]
                                        ];
                                      Ty.path "alloc::alloc::Global"
                                    ],
                                  [],
                                  [ Ty.path "usize" ],
                                  "index",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "openvm_circuit::system::memory::offline::OfflineMemory",
                                      "log"
                                    |)
                                  |);
                                  M.read (|
                                    M.SubPointer.get_struct_tuple_field (|
                                      id,
                                      "openvm_circuit::system::memory::controller::RecordId",
                                      0
                                    |)
                                  |)
                                ]
                              |)
                            |)
                          |)
                        ]
                      |)
                    ]
                  |)
                |)
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Global Instance AssociatedFunction_record_by_id :
          forall (F : Ty.t),
          M.IsAssociatedFunction.C (Self F) "record_by_id" (record_by_id F).
        Admitted.
        Global Typeclasses Opaque record_by_id.
        
        (*
            pub fn finalize<const N: usize>(
                &mut self,
                adapter_records: &mut AccessAdapterInventory<F>,
            ) -> TimestampedEquipartition<F, N> {
                // First make sure the partition we maintain in self.block_data is an equipartition.
                // Grab all aligned pointers that need to be re-accessed.
                let to_access: FxHashSet<_> = self
                    .block_data
                    .items()
                    .map(|((address_space, pointer), _)| (address_space, (pointer / N as u32) * N as u32))
                    .collect();
        
                for &(address_space, pointer) in to_access.iter() {
                    let block = self.block_data.get(&(address_space, pointer));
                    if block.pointer != pointer || block.size != N {
                        self.access(address_space, pointer, N, adapter_records);
                    }
                }
        
                let mut equipartition = TimestampedEquipartition::<F, N>::new();
                for (address_space, pointer) in to_access {
                    let block = self.block_data.get(&(address_space, pointer));
        
                    debug_assert_eq!(block.pointer % N as u32, 0);
                    debug_assert_eq!(block.size, N);
        
                    equipartition.insert(
                        (address_space, pointer / N as u32),
                        TimestampedValues {
                            timestamp: block.timestamp,
                            values: self.range_array::<N>(address_space, pointer),
                        },
                    );
                }
                equipartition
            }
        *)
        Definition finalize (F : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self F in
          match ε, τ, α with
          | [ N ], [], [ self; adapter_records ] =>
            ltac:(M.monadic
              (let self :=
                M.alloc (|
                  Ty.apply
                    (Ty.path "&mut")
                    []
                    [
                      Ty.apply
                        (Ty.path "openvm_circuit::system::memory::offline::OfflineMemory")
                        []
                        [ F ]
                    ],
                  self
                |) in
              let adapter_records :=
                M.alloc (|
                  Ty.apply
                    (Ty.path "&mut")
                    []
                    [
                      Ty.apply
                        (Ty.path "openvm_circuit::system::memory::adapter::AccessAdapterInventory")
                        []
                        [ F ]
                    ],
                  adapter_records
                |) in
              M.read (|
                let~ to_access :
                    Ty.apply
                      (Ty.path "std::collections::hash::set::HashSet")
                      []
                      [
                        Ty.tuple [ Ty.path "u32"; Ty.path "u32" ];
                        Ty.path "rustc_hash::FxBuildHasher"
                      ] :=
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "std::collections::hash::set::HashSet")
                      []
                      [
                        Ty.tuple [ Ty.path "u32"; Ty.path "u32" ];
                        Ty.path "rustc_hash::FxBuildHasher"
                      ],
                    M.get_trait_method (|
                      "core::iter::traits::iterator::Iterator",
                      Ty.apply
                        (Ty.path "core::iter::adapters::map::Map")
                        []
                        [
                          Ty.associated_unknown;
                          Ty.function
                            [
                              Ty.tuple
                                [
                                  Ty.tuple [ Ty.path "u32"; Ty.path "u32" ];
                                  Ty.apply
                                    (Ty.path "&")
                                    []
                                    [ Ty.path "openvm_circuit::system::memory::offline::BlockData" ]
                                ]
                            ]
                            (Ty.tuple [ Ty.path "u32"; Ty.path "u32" ])
                        ],
                      [],
                      [],
                      "collect",
                      [],
                      [
                        Ty.apply
                          (Ty.path "std::collections::hash::set::HashSet")
                          []
                          [
                            Ty.tuple [ Ty.path "u32"; Ty.path "u32" ];
                            Ty.path "rustc_hash::FxBuildHasher"
                          ]
                      ]
                    |),
                    [
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::iter::adapters::map::Map")
                          []
                          [
                            Ty.associated_unknown;
                            Ty.function
                              [
                                Ty.tuple
                                  [
                                    Ty.tuple [ Ty.path "u32"; Ty.path "u32" ];
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [ Ty.path "openvm_circuit::system::memory::offline::BlockData"
                                      ]
                                  ]
                              ]
                              (Ty.tuple [ Ty.path "u32"; Ty.path "u32" ])
                          ],
                        M.get_trait_method (|
                          "core::iter::traits::iterator::Iterator",
                          Ty.associated_unknown,
                          [],
                          [],
                          "map",
                          [],
                          [
                            Ty.tuple [ Ty.path "u32"; Ty.path "u32" ];
                            Ty.function
                              [
                                Ty.tuple
                                  [
                                    Ty.tuple [ Ty.path "u32"; Ty.path "u32" ];
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [ Ty.path "openvm_circuit::system::memory::offline::BlockData"
                                      ]
                                  ]
                              ]
                              (Ty.tuple [ Ty.path "u32"; Ty.path "u32" ])
                          ]
                        |),
                        [
                          M.call_closure (|
                            Ty.associated_unknown,
                            M.get_associated_function (|
                              Ty.path "openvm_circuit::system::memory::offline::BlockMap",
                              "items",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "openvm_circuit::system::memory::offline::OfflineMemory",
                                  "block_data"
                                |)
                              |)
                            ]
                          |);
                          M.closure
                            (fun γ =>
                              ltac:(M.monadic
                                match γ with
                                | [ α0 ] =>
                                  ltac:(M.monadic
                                    (M.match_operator (|
                                      Ty.tuple [ Ty.path "u32"; Ty.path "u32" ],
                                      M.alloc (|
                                        Ty.tuple
                                          [
                                            Ty.tuple [ Ty.path "u32"; Ty.path "u32" ];
                                            Ty.apply
                                              (Ty.path "&")
                                              []
                                              [
                                                Ty.path
                                                  "openvm_circuit::system::memory::offline::BlockData"
                                              ]
                                          ],
                                        α0
                                      |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                            let γ1_0 :=
                                              M.SubPointer.get_tuple_field (| γ0_0, 0 |) in
                                            let γ1_1 :=
                                              M.SubPointer.get_tuple_field (| γ0_0, 1 |) in
                                            let address_space := M.copy (| Ty.path "u32", γ1_0 |) in
                                            let pointer := M.copy (| Ty.path "u32", γ1_1 |) in
                                            Value.Tuple
                                              [
                                                M.read (| address_space |);
                                                M.call_closure (|
                                                  Ty.path "u32",
                                                  BinOp.Wrap.mul,
                                                  [
                                                    M.call_closure (|
                                                      Ty.path "u32",
                                                      BinOp.Wrap.div,
                                                      [
                                                        M.read (| pointer |);
                                                        M.cast (Ty.path "u32") N
                                                      ]
                                                    |);
                                                    M.cast (Ty.path "u32") N
                                                  ]
                                                |)
                                              ]))
                                      ]
                                    |)))
                                | _ => M.impossible "wrong number of arguments"
                                end))
                        ]
                      |)
                    ]
                  |) in
                let~ _ : Ty.tuple [] :=
                  M.read (|
                    M.use
                      (M.alloc (|
                        Ty.tuple [],
                        M.match_operator (|
                          Ty.tuple [],
                          M.alloc (|
                            Ty.apply
                              (Ty.path "std::collections::hash::set::Iter")
                              []
                              [ Ty.tuple [ Ty.path "u32"; Ty.path "u32" ] ],
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "std::collections::hash::set::Iter")
                                []
                                [ Ty.tuple [ Ty.path "u32"; Ty.path "u32" ] ],
                              M.get_trait_method (|
                                "core::iter::traits::collect::IntoIterator",
                                Ty.apply
                                  (Ty.path "std::collections::hash::set::Iter")
                                  []
                                  [ Ty.tuple [ Ty.path "u32"; Ty.path "u32" ] ],
                                [],
                                [],
                                "into_iter",
                                [],
                                []
                              |),
                              [
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "std::collections::hash::set::Iter")
                                    []
                                    [ Ty.tuple [ Ty.path "u32"; Ty.path "u32" ] ],
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "std::collections::hash::set::HashSet")
                                      []
                                      [
                                        Ty.tuple [ Ty.path "u32"; Ty.path "u32" ];
                                        Ty.path "rustc_hash::FxBuildHasher"
                                      ],
                                    "iter",
                                    [],
                                    []
                                  |),
                                  [ M.borrow (| Pointer.Kind.Ref, to_access |) ]
                                |)
                              ]
                            |)
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let iter :=
                                  M.copy (|
                                    Ty.apply
                                      (Ty.path "std::collections::hash::set::Iter")
                                      []
                                      [ Ty.tuple [ Ty.path "u32"; Ty.path "u32" ] ],
                                    γ
                                  |) in
                                M.read (|
                                  M.loop (|
                                    Ty.tuple [],
                                    ltac:(M.monadic
                                      (let~ _ : Ty.tuple [] :=
                                        M.match_operator (|
                                          Ty.tuple [],
                                          M.alloc (|
                                            Ty.apply
                                              (Ty.path "core::option::Option")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "&")
                                                  []
                                                  [ Ty.tuple [ Ty.path "u32"; Ty.path "u32" ] ]
                                              ],
                                            M.call_closure (|
                                              Ty.apply
                                                (Ty.path "core::option::Option")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "&")
                                                    []
                                                    [ Ty.tuple [ Ty.path "u32"; Ty.path "u32" ] ]
                                                ],
                                              M.get_trait_method (|
                                                "core::iter::traits::iterator::Iterator",
                                                Ty.apply
                                                  (Ty.path "std::collections::hash::set::Iter")
                                                  []
                                                  [ Ty.tuple [ Ty.path "u32"; Ty.path "u32" ] ],
                                                [],
                                                [],
                                                "next",
                                                [],
                                                []
                                              |),
                                              [
                                                M.borrow (|
                                                  Pointer.Kind.MutRef,
                                                  M.deref (|
                                                    M.borrow (| Pointer.Kind.MutRef, iter |)
                                                  |)
                                                |)
                                              ]
                                            |)
                                          |),
                                          [
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let _ :=
                                                  M.is_struct_tuple (|
                                                    γ,
                                                    "core::option::Option::None"
                                                  |) in
                                                M.never_to_any (| M.read (| M.break (||) |) |)));
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let γ0_0 :=
                                                  M.SubPointer.get_struct_tuple_field (|
                                                    γ,
                                                    "core::option::Option::Some",
                                                    0
                                                  |) in
                                                let γ0_0 := M.read (| γ0_0 |) in
                                                let γ2_0 :=
                                                  M.SubPointer.get_tuple_field (| γ0_0, 0 |) in
                                                let γ2_1 :=
                                                  M.SubPointer.get_tuple_field (| γ0_0, 1 |) in
                                                let address_space :=
                                                  M.copy (| Ty.path "u32", γ2_0 |) in
                                                let pointer := M.copy (| Ty.path "u32", γ2_1 |) in
                                                M.read (|
                                                  let~ block :
                                                      Ty.apply
                                                        (Ty.path "&")
                                                        []
                                                        [
                                                          Ty.path
                                                            "openvm_circuit::system::memory::offline::BlockData"
                                                        ] :=
                                                    M.call_closure (|
                                                      Ty.apply
                                                        (Ty.path "&")
                                                        []
                                                        [
                                                          Ty.path
                                                            "openvm_circuit::system::memory::offline::BlockData"
                                                        ],
                                                      M.get_associated_function (|
                                                        Ty.path
                                                          "openvm_circuit::system::memory::offline::BlockMap",
                                                        "get",
                                                        [],
                                                        []
                                                      |),
                                                      [
                                                        M.borrow (|
                                                          Pointer.Kind.MutRef,
                                                          M.SubPointer.get_struct_record_field (|
                                                            M.deref (| M.read (| self |) |),
                                                            "openvm_circuit::system::memory::offline::OfflineMemory",
                                                            "block_data"
                                                          |)
                                                        |);
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.deref (|
                                                            M.borrow (|
                                                              Pointer.Kind.Ref,
                                                              M.alloc (|
                                                                Ty.tuple
                                                                  [ Ty.path "u32"; Ty.path "u32" ],
                                                                Value.Tuple
                                                                  [
                                                                    M.read (| address_space |);
                                                                    M.read (| pointer |)
                                                                  ]
                                                              |)
                                                            |)
                                                          |)
                                                        |)
                                                      ]
                                                    |) in
                                                  M.alloc (|
                                                    Ty.tuple [],
                                                    M.match_operator (|
                                                      Ty.tuple [],
                                                      M.alloc (| Ty.tuple [], Value.Tuple [] |),
                                                      [
                                                        fun γ =>
                                                          ltac:(M.monadic
                                                            (let γ :=
                                                              M.use
                                                                (M.alloc (|
                                                                  Ty.path "bool",
                                                                  LogicalOp.or (|
                                                                    M.call_closure (|
                                                                      Ty.path "bool",
                                                                      BinOp.ne,
                                                                      [
                                                                        M.read (|
                                                                          M.SubPointer.get_struct_record_field (|
                                                                            M.deref (|
                                                                              M.read (| block |)
                                                                            |),
                                                                            "openvm_circuit::system::memory::offline::BlockData",
                                                                            "pointer"
                                                                          |)
                                                                        |);
                                                                        M.read (| pointer |)
                                                                      ]
                                                                    |),
                                                                    ltac:(M.monadic
                                                                      (M.call_closure (|
                                                                        Ty.path "bool",
                                                                        BinOp.ne,
                                                                        [
                                                                          M.read (|
                                                                            M.SubPointer.get_struct_record_field (|
                                                                              M.deref (|
                                                                                M.read (| block |)
                                                                              |),
                                                                              "openvm_circuit::system::memory::offline::BlockData",
                                                                              "size"
                                                                            |)
                                                                          |);
                                                                          N
                                                                        ]
                                                                      |)))
                                                                  |)
                                                                |)) in
                                                            let _ :=
                                                              is_constant_or_break_match (|
                                                                M.read (| γ |),
                                                                Value.Bool true
                                                              |) in
                                                            M.read (|
                                                              let~ _ : Ty.tuple [] :=
                                                                M.call_closure (|
                                                                  Ty.tuple [],
                                                                  M.get_associated_function (|
                                                                    Ty.apply
                                                                      (Ty.path
                                                                        "openvm_circuit::system::memory::offline::OfflineMemory")
                                                                      []
                                                                      [ F ],
                                                                    "access",
                                                                    [],
                                                                    []
                                                                  |),
                                                                  [
                                                                    M.borrow (|
                                                                      Pointer.Kind.MutRef,
                                                                      M.deref (|
                                                                        M.read (| self |)
                                                                      |)
                                                                    |);
                                                                    M.read (| address_space |);
                                                                    M.read (| pointer |);
                                                                    N;
                                                                    M.borrow (|
                                                                      Pointer.Kind.MutRef,
                                                                      M.deref (|
                                                                        M.read (| adapter_records |)
                                                                      |)
                                                                    |)
                                                                  ]
                                                                |) in
                                                              M.alloc (|
                                                                Ty.tuple [],
                                                                Value.Tuple []
                                                              |)
                                                            |)));
                                                        fun γ => ltac:(M.monadic (Value.Tuple []))
                                                      ]
                                                    |)
                                                  |)
                                                |)))
                                          ]
                                        |) in
                                      M.alloc (| Ty.tuple [], Value.Tuple [] |)))
                                  |)
                                |)))
                          ]
                        |)
                      |))
                  |) in
                let~ equipartition :
                    Ty.apply
                      (Ty.path "alloc::collections::btree::map::BTreeMap")
                      []
                      [
                        Ty.tuple [ Ty.path "u32"; Ty.path "u32" ];
                        Ty.apply
                          (Ty.path "openvm_circuit::system::memory::controller::TimestampedValues")
                          [ N ]
                          [ F ];
                        Ty.path "alloc::alloc::Global"
                      ] :=
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "alloc::collections::btree::map::BTreeMap")
                      []
                      [
                        Ty.tuple [ Ty.path "u32"; Ty.path "u32" ];
                        Ty.apply
                          (Ty.path "openvm_circuit::system::memory::controller::TimestampedValues")
                          [ N ]
                          [ F ];
                        Ty.path "alloc::alloc::Global"
                      ],
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::collections::btree::map::BTreeMap")
                        []
                        [
                          Ty.tuple [ Ty.path "u32"; Ty.path "u32" ];
                          Ty.apply
                            (Ty.path
                              "openvm_circuit::system::memory::controller::TimestampedValues")
                            [ N ]
                            [ F ];
                          Ty.path "alloc::alloc::Global"
                        ],
                      "new",
                      [],
                      []
                    |),
                    []
                  |) in
                let~ _ : Ty.tuple [] :=
                  M.read (|
                    M.use
                      (M.alloc (|
                        Ty.tuple [],
                        M.match_operator (|
                          Ty.tuple [],
                          M.alloc (|
                            Ty.apply
                              (Ty.path "std::collections::hash::set::IntoIter")
                              []
                              [ Ty.tuple [ Ty.path "u32"; Ty.path "u32" ] ],
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "std::collections::hash::set::IntoIter")
                                []
                                [ Ty.tuple [ Ty.path "u32"; Ty.path "u32" ] ],
                              M.get_trait_method (|
                                "core::iter::traits::collect::IntoIterator",
                                Ty.apply
                                  (Ty.path "std::collections::hash::set::HashSet")
                                  []
                                  [
                                    Ty.tuple [ Ty.path "u32"; Ty.path "u32" ];
                                    Ty.path "rustc_hash::FxBuildHasher"
                                  ],
                                [],
                                [],
                                "into_iter",
                                [],
                                []
                              |),
                              [ M.read (| to_access |) ]
                            |)
                          |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let iter :=
                                  M.copy (|
                                    Ty.apply
                                      (Ty.path "std::collections::hash::set::IntoIter")
                                      []
                                      [ Ty.tuple [ Ty.path "u32"; Ty.path "u32" ] ],
                                    γ
                                  |) in
                                M.read (|
                                  M.loop (|
                                    Ty.tuple [],
                                    ltac:(M.monadic
                                      (let~ _ : Ty.tuple [] :=
                                        M.match_operator (|
                                          Ty.tuple [],
                                          M.alloc (|
                                            Ty.apply
                                              (Ty.path "core::option::Option")
                                              []
                                              [ Ty.tuple [ Ty.path "u32"; Ty.path "u32" ] ],
                                            M.call_closure (|
                                              Ty.apply
                                                (Ty.path "core::option::Option")
                                                []
                                                [ Ty.tuple [ Ty.path "u32"; Ty.path "u32" ] ],
                                              M.get_trait_method (|
                                                "core::iter::traits::iterator::Iterator",
                                                Ty.apply
                                                  (Ty.path "std::collections::hash::set::IntoIter")
                                                  []
                                                  [ Ty.tuple [ Ty.path "u32"; Ty.path "u32" ] ],
                                                [],
                                                [],
                                                "next",
                                                [],
                                                []
                                              |),
                                              [
                                                M.borrow (|
                                                  Pointer.Kind.MutRef,
                                                  M.deref (|
                                                    M.borrow (| Pointer.Kind.MutRef, iter |)
                                                  |)
                                                |)
                                              ]
                                            |)
                                          |),
                                          [
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let _ :=
                                                  M.is_struct_tuple (|
                                                    γ,
                                                    "core::option::Option::None"
                                                  |) in
                                                M.never_to_any (| M.read (| M.break (||) |) |)));
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let γ0_0 :=
                                                  M.SubPointer.get_struct_tuple_field (|
                                                    γ,
                                                    "core::option::Option::Some",
                                                    0
                                                  |) in
                                                let γ1_0 :=
                                                  M.SubPointer.get_tuple_field (| γ0_0, 0 |) in
                                                let γ1_1 :=
                                                  M.SubPointer.get_tuple_field (| γ0_0, 1 |) in
                                                let address_space :=
                                                  M.copy (| Ty.path "u32", γ1_0 |) in
                                                let pointer := M.copy (| Ty.path "u32", γ1_1 |) in
                                                M.read (|
                                                  let~ block :
                                                      Ty.apply
                                                        (Ty.path "&")
                                                        []
                                                        [
                                                          Ty.path
                                                            "openvm_circuit::system::memory::offline::BlockData"
                                                        ] :=
                                                    M.call_closure (|
                                                      Ty.apply
                                                        (Ty.path "&")
                                                        []
                                                        [
                                                          Ty.path
                                                            "openvm_circuit::system::memory::offline::BlockData"
                                                        ],
                                                      M.get_associated_function (|
                                                        Ty.path
                                                          "openvm_circuit::system::memory::offline::BlockMap",
                                                        "get",
                                                        [],
                                                        []
                                                      |),
                                                      [
                                                        M.borrow (|
                                                          Pointer.Kind.MutRef,
                                                          M.SubPointer.get_struct_record_field (|
                                                            M.deref (| M.read (| self |) |),
                                                            "openvm_circuit::system::memory::offline::OfflineMemory",
                                                            "block_data"
                                                          |)
                                                        |);
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.deref (|
                                                            M.borrow (|
                                                              Pointer.Kind.Ref,
                                                              M.alloc (|
                                                                Ty.tuple
                                                                  [ Ty.path "u32"; Ty.path "u32" ],
                                                                Value.Tuple
                                                                  [
                                                                    M.read (| address_space |);
                                                                    M.read (| pointer |)
                                                                  ]
                                                              |)
                                                            |)
                                                          |)
                                                        |)
                                                      ]
                                                    |) in
                                                  let~ _ : Ty.tuple [] :=
                                                    M.match_operator (|
                                                      Ty.tuple [],
                                                      M.alloc (| Ty.tuple [], Value.Tuple [] |),
                                                      [
                                                        fun γ =>
                                                          ltac:(M.monadic
                                                            (let γ :=
                                                              M.use
                                                                (M.alloc (|
                                                                  Ty.path "bool",
                                                                  Value.Bool true
                                                                |)) in
                                                            let _ :=
                                                              is_constant_or_break_match (|
                                                                M.read (| γ |),
                                                                Value.Bool true
                                                              |) in
                                                            M.read (|
                                                              let~ _ : Ty.tuple [] :=
                                                                M.match_operator (|
                                                                  Ty.tuple [],
                                                                  M.alloc (|
                                                                    Ty.tuple
                                                                      [
                                                                        Ty.apply
                                                                          (Ty.path "&")
                                                                          []
                                                                          [ Ty.path "u32" ];
                                                                        Ty.apply
                                                                          (Ty.path "&")
                                                                          []
                                                                          [ Ty.path "u32" ]
                                                                      ],
                                                                    Value.Tuple
                                                                      [
                                                                        M.borrow (|
                                                                          Pointer.Kind.Ref,
                                                                          M.alloc (|
                                                                            Ty.path "u32",
                                                                            M.call_closure (|
                                                                              Ty.path "u32",
                                                                              BinOp.Wrap.rem,
                                                                              [
                                                                                M.read (|
                                                                                  M.SubPointer.get_struct_record_field (|
                                                                                    M.deref (|
                                                                                      M.read (|
                                                                                        block
                                                                                      |)
                                                                                    |),
                                                                                    "openvm_circuit::system::memory::offline::BlockData",
                                                                                    "pointer"
                                                                                  |)
                                                                                |);
                                                                                M.cast
                                                                                  (Ty.path "u32")
                                                                                  N
                                                                              ]
                                                                            |)
                                                                          |)
                                                                        |);
                                                                        M.borrow (|
                                                                          Pointer.Kind.Ref,
                                                                          M.alloc (|
                                                                            Ty.path "u32",
                                                                            Value.Integer
                                                                              IntegerKind.U32
                                                                              0
                                                                          |)
                                                                        |)
                                                                      ]
                                                                  |),
                                                                  [
                                                                    fun γ =>
                                                                      ltac:(M.monadic
                                                                        (let γ0_0 :=
                                                                          M.SubPointer.get_tuple_field (|
                                                                            γ,
                                                                            0
                                                                          |) in
                                                                        let γ0_1 :=
                                                                          M.SubPointer.get_tuple_field (|
                                                                            γ,
                                                                            1
                                                                          |) in
                                                                        let left_val :=
                                                                          M.copy (|
                                                                            Ty.apply
                                                                              (Ty.path "&")
                                                                              []
                                                                              [ Ty.path "u32" ],
                                                                            γ0_0
                                                                          |) in
                                                                        let right_val :=
                                                                          M.copy (|
                                                                            Ty.apply
                                                                              (Ty.path "&")
                                                                              []
                                                                              [ Ty.path "u32" ],
                                                                            γ0_1
                                                                          |) in
                                                                        M.match_operator (|
                                                                          Ty.tuple [],
                                                                          M.alloc (|
                                                                            Ty.tuple [],
                                                                            Value.Tuple []
                                                                          |),
                                                                          [
                                                                            fun γ =>
                                                                              ltac:(M.monadic
                                                                                (let γ :=
                                                                                  M.use
                                                                                    (M.alloc (|
                                                                                      Ty.path
                                                                                        "bool",
                                                                                      UnOp.not (|
                                                                                        M.call_closure (|
                                                                                          Ty.path
                                                                                            "bool",
                                                                                          BinOp.eq,
                                                                                          [
                                                                                            M.read (|
                                                                                              M.deref (|
                                                                                                M.read (|
                                                                                                  left_val
                                                                                                |)
                                                                                              |)
                                                                                            |);
                                                                                            M.read (|
                                                                                              M.deref (|
                                                                                                M.read (|
                                                                                                  right_val
                                                                                                |)
                                                                                              |)
                                                                                            |)
                                                                                          ]
                                                                                        |)
                                                                                      |)
                                                                                    |)) in
                                                                                let _ :=
                                                                                  is_constant_or_break_match (|
                                                                                    M.read (| γ |),
                                                                                    Value.Bool true
                                                                                  |) in
                                                                                M.never_to_any (|
                                                                                  M.read (|
                                                                                    let~ kind :
                                                                                        Ty.path
                                                                                          "core::panicking::AssertKind" :=
                                                                                      Value.StructTuple
                                                                                        "core::panicking::AssertKind::Eq"
                                                                                        []
                                                                                        []
                                                                                        [] in
                                                                                    M.alloc (|
                                                                                      Ty.path
                                                                                        "never",
                                                                                      M.call_closure (|
                                                                                        Ty.path
                                                                                          "never",
                                                                                        M.get_function (|
                                                                                          "core::panicking::assert_failed",
                                                                                          [],
                                                                                          [
                                                                                            Ty.path
                                                                                              "u32";
                                                                                            Ty.path
                                                                                              "u32"
                                                                                          ]
                                                                                        |),
                                                                                        [
                                                                                          M.read (|
                                                                                            kind
                                                                                          |);
                                                                                          M.borrow (|
                                                                                            Pointer.Kind.Ref,
                                                                                            M.deref (|
                                                                                              M.borrow (|
                                                                                                Pointer.Kind.Ref,
                                                                                                M.deref (|
                                                                                                  M.read (|
                                                                                                    left_val
                                                                                                  |)
                                                                                                |)
                                                                                              |)
                                                                                            |)
                                                                                          |);
                                                                                          M.borrow (|
                                                                                            Pointer.Kind.Ref,
                                                                                            M.deref (|
                                                                                              M.borrow (|
                                                                                                Pointer.Kind.Ref,
                                                                                                M.deref (|
                                                                                                  M.read (|
                                                                                                    right_val
                                                                                                  |)
                                                                                                |)
                                                                                              |)
                                                                                            |)
                                                                                          |);
                                                                                          Value.StructTuple
                                                                                            "core::option::Option::None"
                                                                                            []
                                                                                            [
                                                                                              Ty.path
                                                                                                "core::fmt::Arguments"
                                                                                            ]
                                                                                            []
                                                                                        ]
                                                                                      |)
                                                                                    |)
                                                                                  |)
                                                                                |)));
                                                                            fun γ =>
                                                                              ltac:(M.monadic
                                                                                (Value.Tuple []))
                                                                          ]
                                                                        |)))
                                                                  ]
                                                                |) in
                                                              M.alloc (|
                                                                Ty.tuple [],
                                                                Value.Tuple []
                                                              |)
                                                            |)));
                                                        fun γ => ltac:(M.monadic (Value.Tuple []))
                                                      ]
                                                    |) in
                                                  let~ _ : Ty.tuple [] :=
                                                    M.match_operator (|
                                                      Ty.tuple [],
                                                      M.alloc (| Ty.tuple [], Value.Tuple [] |),
                                                      [
                                                        fun γ =>
                                                          ltac:(M.monadic
                                                            (let γ :=
                                                              M.use
                                                                (M.alloc (|
                                                                  Ty.path "bool",
                                                                  Value.Bool true
                                                                |)) in
                                                            let _ :=
                                                              is_constant_or_break_match (|
                                                                M.read (| γ |),
                                                                Value.Bool true
                                                              |) in
                                                            M.read (|
                                                              let~ _ : Ty.tuple [] :=
                                                                M.match_operator (|
                                                                  Ty.tuple [],
                                                                  M.alloc (|
                                                                    Ty.tuple
                                                                      [
                                                                        Ty.apply
                                                                          (Ty.path "&")
                                                                          []
                                                                          [ Ty.path "usize" ];
                                                                        Ty.apply
                                                                          (Ty.path "&")
                                                                          []
                                                                          [ Ty.path "usize" ]
                                                                      ],
                                                                    Value.Tuple
                                                                      [
                                                                        M.borrow (|
                                                                          Pointer.Kind.Ref,
                                                                          M.SubPointer.get_struct_record_field (|
                                                                            M.deref (|
                                                                              M.read (| block |)
                                                                            |),
                                                                            "openvm_circuit::system::memory::offline::BlockData",
                                                                            "size"
                                                                          |)
                                                                        |);
                                                                        M.borrow (|
                                                                          Pointer.Kind.Ref,
                                                                          M.alloc (|
                                                                            Ty.path "usize",
                                                                            N
                                                                          |)
                                                                        |)
                                                                      ]
                                                                  |),
                                                                  [
                                                                    fun γ =>
                                                                      ltac:(M.monadic
                                                                        (let γ0_0 :=
                                                                          M.SubPointer.get_tuple_field (|
                                                                            γ,
                                                                            0
                                                                          |) in
                                                                        let γ0_1 :=
                                                                          M.SubPointer.get_tuple_field (|
                                                                            γ,
                                                                            1
                                                                          |) in
                                                                        let left_val :=
                                                                          M.copy (|
                                                                            Ty.apply
                                                                              (Ty.path "&")
                                                                              []
                                                                              [ Ty.path "usize" ],
                                                                            γ0_0
                                                                          |) in
                                                                        let right_val :=
                                                                          M.copy (|
                                                                            Ty.apply
                                                                              (Ty.path "&")
                                                                              []
                                                                              [ Ty.path "usize" ],
                                                                            γ0_1
                                                                          |) in
                                                                        M.match_operator (|
                                                                          Ty.tuple [],
                                                                          M.alloc (|
                                                                            Ty.tuple [],
                                                                            Value.Tuple []
                                                                          |),
                                                                          [
                                                                            fun γ =>
                                                                              ltac:(M.monadic
                                                                                (let γ :=
                                                                                  M.use
                                                                                    (M.alloc (|
                                                                                      Ty.path
                                                                                        "bool",
                                                                                      UnOp.not (|
                                                                                        M.call_closure (|
                                                                                          Ty.path
                                                                                            "bool",
                                                                                          BinOp.eq,
                                                                                          [
                                                                                            M.read (|
                                                                                              M.deref (|
                                                                                                M.read (|
                                                                                                  left_val
                                                                                                |)
                                                                                              |)
                                                                                            |);
                                                                                            M.read (|
                                                                                              M.deref (|
                                                                                                M.read (|
                                                                                                  right_val
                                                                                                |)
                                                                                              |)
                                                                                            |)
                                                                                          ]
                                                                                        |)
                                                                                      |)
                                                                                    |)) in
                                                                                let _ :=
                                                                                  is_constant_or_break_match (|
                                                                                    M.read (| γ |),
                                                                                    Value.Bool true
                                                                                  |) in
                                                                                M.never_to_any (|
                                                                                  M.read (|
                                                                                    let~ kind :
                                                                                        Ty.path
                                                                                          "core::panicking::AssertKind" :=
                                                                                      Value.StructTuple
                                                                                        "core::panicking::AssertKind::Eq"
                                                                                        []
                                                                                        []
                                                                                        [] in
                                                                                    M.alloc (|
                                                                                      Ty.path
                                                                                        "never",
                                                                                      M.call_closure (|
                                                                                        Ty.path
                                                                                          "never",
                                                                                        M.get_function (|
                                                                                          "core::panicking::assert_failed",
                                                                                          [],
                                                                                          [
                                                                                            Ty.path
                                                                                              "usize";
                                                                                            Ty.path
                                                                                              "usize"
                                                                                          ]
                                                                                        |),
                                                                                        [
                                                                                          M.read (|
                                                                                            kind
                                                                                          |);
                                                                                          M.borrow (|
                                                                                            Pointer.Kind.Ref,
                                                                                            M.deref (|
                                                                                              M.borrow (|
                                                                                                Pointer.Kind.Ref,
                                                                                                M.deref (|
                                                                                                  M.read (|
                                                                                                    left_val
                                                                                                  |)
                                                                                                |)
                                                                                              |)
                                                                                            |)
                                                                                          |);
                                                                                          M.borrow (|
                                                                                            Pointer.Kind.Ref,
                                                                                            M.deref (|
                                                                                              M.borrow (|
                                                                                                Pointer.Kind.Ref,
                                                                                                M.deref (|
                                                                                                  M.read (|
                                                                                                    right_val
                                                                                                  |)
                                                                                                |)
                                                                                              |)
                                                                                            |)
                                                                                          |);
                                                                                          Value.StructTuple
                                                                                            "core::option::Option::None"
                                                                                            []
                                                                                            [
                                                                                              Ty.path
                                                                                                "core::fmt::Arguments"
                                                                                            ]
                                                                                            []
                                                                                        ]
                                                                                      |)
                                                                                    |)
                                                                                  |)
                                                                                |)));
                                                                            fun γ =>
                                                                              ltac:(M.monadic
                                                                                (Value.Tuple []))
                                                                          ]
                                                                        |)))
                                                                  ]
                                                                |) in
                                                              M.alloc (|
                                                                Ty.tuple [],
                                                                Value.Tuple []
                                                              |)
                                                            |)));
                                                        fun γ => ltac:(M.monadic (Value.Tuple []))
                                                      ]
                                                    |) in
                                                  let~ _ :
                                                      Ty.apply
                                                        (Ty.path "core::option::Option")
                                                        []
                                                        [
                                                          Ty.apply
                                                            (Ty.path
                                                              "openvm_circuit::system::memory::controller::TimestampedValues")
                                                            [ N ]
                                                            [ F ]
                                                        ] :=
                                                    M.call_closure (|
                                                      Ty.apply
                                                        (Ty.path "core::option::Option")
                                                        []
                                                        [
                                                          Ty.apply
                                                            (Ty.path
                                                              "openvm_circuit::system::memory::controller::TimestampedValues")
                                                            [ N ]
                                                            [ F ]
                                                        ],
                                                      M.get_associated_function (|
                                                        Ty.apply
                                                          (Ty.path
                                                            "alloc::collections::btree::map::BTreeMap")
                                                          []
                                                          [
                                                            Ty.tuple
                                                              [ Ty.path "u32"; Ty.path "u32" ];
                                                            Ty.apply
                                                              (Ty.path
                                                                "openvm_circuit::system::memory::controller::TimestampedValues")
                                                              [ N ]
                                                              [ F ];
                                                            Ty.path "alloc::alloc::Global"
                                                          ],
                                                        "insert",
                                                        [],
                                                        []
                                                      |),
                                                      [
                                                        M.borrow (|
                                                          Pointer.Kind.MutRef,
                                                          equipartition
                                                        |);
                                                        Value.Tuple
                                                          [
                                                            M.read (| address_space |);
                                                            M.call_closure (|
                                                              Ty.path "u32",
                                                              BinOp.Wrap.div,
                                                              [
                                                                M.read (| pointer |);
                                                                M.cast (Ty.path "u32") N
                                                              ]
                                                            |)
                                                          ];
                                                        Value.mkStructRecord
                                                          "openvm_circuit::system::memory::controller::TimestampedValues"
                                                          [ N ]
                                                          [ F ]
                                                          [
                                                            ("timestamp",
                                                              M.read (|
                                                                M.SubPointer.get_struct_record_field (|
                                                                  M.deref (| M.read (| block |) |),
                                                                  "openvm_circuit::system::memory::offline::BlockData",
                                                                  "timestamp"
                                                                |)
                                                              |));
                                                            ("values",
                                                              M.call_closure (|
                                                                Ty.apply
                                                                  (Ty.path "array")
                                                                  [ N ]
                                                                  [ F ],
                                                                M.get_associated_function (|
                                                                  Ty.apply
                                                                    (Ty.path
                                                                      "openvm_circuit::system::memory::offline::OfflineMemory")
                                                                    []
                                                                    [ F ],
                                                                  "range_array",
                                                                  [ N ],
                                                                  []
                                                                |),
                                                                [
                                                                  M.borrow (|
                                                                    Pointer.Kind.Ref,
                                                                    M.deref (| M.read (| self |) |)
                                                                  |);
                                                                  M.read (| address_space |);
                                                                  M.read (| pointer |)
                                                                ]
                                                              |))
                                                          ]
                                                      ]
                                                    |) in
                                                  M.alloc (| Ty.tuple [], Value.Tuple [] |)
                                                |)))
                                          ]
                                        |) in
                                      M.alloc (| Ty.tuple [], Value.Tuple [] |)))
                                  |)
                                |)))
                          ]
                        |)
                      |))
                  |) in
                equipartition
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Global Instance AssociatedFunction_finalize :
          forall (F : Ty.t),
          M.IsAssociatedFunction.C (Self F) "finalize" (finalize F).
        Admitted.
        Global Typeclasses Opaque finalize.
        
        (*
            fn split_to_make_boundary(
                &mut self,
                address_space: u32,
                query: u32,
                records: &mut AccessAdapterInventory<F>,
            ) {
                let lim = (self.data[(address_space - self.as_offset) as usize].memory_size()) as u32;
                if query == lim {
                    return;
                }
                assert!(query < lim);
                let original_block = self.block_containing(address_space, query);
                if original_block.pointer == query {
                    return;
                }
        
                let data = self.range_vec(address_space, original_block.pointer, original_block.size);
        
                let timestamp = original_block.timestamp;
        
                let mut cur_ptr = original_block.pointer;
                let mut cur_size = original_block.size;
                while cur_size > 0 {
                    // Split.
                    records.add_record(AccessAdapterRecord {
                        timestamp,
                        address_space: F::from_canonical_u32(address_space),
                        start_index: F::from_canonical_u32(cur_ptr),
                        data: data[(cur_ptr - original_block.pointer) as usize
                            ..(cur_ptr - original_block.pointer) as usize + cur_size]
                            .to_vec(),
                        kind: AccessAdapterRecordKind::Split,
                    });
        
                    let half_size = cur_size / 2;
                    let half_size_u32 = half_size as u32;
                    let mid_ptr = cur_ptr + half_size_u32;
        
                    if query <= mid_ptr {
                        // The right is finalized; add it to the partition.
                        let block = BlockData {
                            pointer: mid_ptr,
                            size: half_size,
                            timestamp,
                        };
                        self.block_data
                            .set_range(&(address_space, mid_ptr), half_size, block);
                    }
                    if query >= cur_ptr + half_size_u32 {
                        // The left is finalized; add it to the partition.
                        let block = BlockData {
                            pointer: cur_ptr,
                            size: half_size,
                            timestamp,
                        };
                        self.block_data
                            .set_range(&(address_space, cur_ptr), half_size, block);
                    }
                    if mid_ptr <= query {
                        cur_ptr = mid_ptr;
                    }
                    if cur_ptr == query {
                        break;
                    }
                    cur_size = half_size;
                }
            }
        *)
        Definition split_to_make_boundary
            (F : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self F in
          match ε, τ, α with
          | [], [], [ self; address_space; query; records ] =>
            ltac:(M.monadic
              (let self :=
                M.alloc (|
                  Ty.apply
                    (Ty.path "&mut")
                    []
                    [
                      Ty.apply
                        (Ty.path "openvm_circuit::system::memory::offline::OfflineMemory")
                        []
                        [ F ]
                    ],
                  self
                |) in
              let address_space := M.alloc (| Ty.path "u32", address_space |) in
              let query := M.alloc (| Ty.path "u32", query |) in
              let records :=
                M.alloc (|
                  Ty.apply
                    (Ty.path "&mut")
                    []
                    [
                      Ty.apply
                        (Ty.path "openvm_circuit::system::memory::adapter::AccessAdapterInventory")
                        []
                        [ F ]
                    ],
                  records
                |) in
              M.catch_return (Ty.tuple []) (|
                ltac:(M.monadic
                  (M.read (|
                    let~ lim : Ty.path "u32" :=
                      M.cast
                        (Ty.path "u32")
                        (M.call_closure (|
                          Ty.path "usize",
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "openvm_circuit::system::memory::paged_vec::PagedVec")
                              [ Value.Integer IntegerKind.Usize 4096 ]
                              [ F ],
                            "memory_size",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "&")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path
                                          "openvm_circuit::system::memory::paged_vec::PagedVec")
                                        [ Value.Integer IntegerKind.Usize 4096 ]
                                        [ F ]
                                    ],
                                  M.get_trait_method (|
                                    "core::ops::index::Index",
                                    Ty.apply
                                      (Ty.path "alloc::vec::Vec")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path
                                            "openvm_circuit::system::memory::paged_vec::PagedVec")
                                          [ Value.Integer IntegerKind.Usize 4096 ]
                                          [ F ];
                                        Ty.path "alloc::alloc::Global"
                                      ],
                                    [],
                                    [ Ty.path "usize" ],
                                    "index",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.SubPointer.get_struct_record_field (|
                                        M.deref (| M.read (| self |) |),
                                        "openvm_circuit::system::memory::offline::OfflineMemory",
                                        "data"
                                      |)
                                    |);
                                    M.cast
                                      (Ty.path "usize")
                                      (M.call_closure (|
                                        Ty.path "u32",
                                        BinOp.Wrap.sub,
                                        [
                                          M.read (| address_space |);
                                          M.read (|
                                            M.SubPointer.get_struct_record_field (|
                                              M.deref (| M.read (| self |) |),
                                              "openvm_circuit::system::memory::offline::OfflineMemory",
                                              "as_offset"
                                            |)
                                          |)
                                        ]
                                      |))
                                  ]
                                |)
                              |)
                            |)
                          ]
                        |)) in
                    let~ _ : Ty.tuple [] :=
                      M.match_operator (|
                        Ty.tuple [],
                        M.alloc (| Ty.tuple [], Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    Ty.path "bool",
                                    M.call_closure (|
                                      Ty.path "bool",
                                      BinOp.eq,
                                      [ M.read (| query |); M.read (| lim |) ]
                                    |)
                                  |)) in
                              let _ :=
                                is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                              M.never_to_any (| M.read (| M.return_ (| Value.Tuple [] |) |) |)));
                          fun γ => ltac:(M.monadic (Value.Tuple []))
                        ]
                      |) in
                    let~ _ : Ty.tuple [] :=
                      M.match_operator (|
                        Ty.tuple [],
                        M.alloc (| Ty.tuple [], Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    Ty.path "bool",
                                    UnOp.not (|
                                      M.call_closure (|
                                        Ty.path "bool",
                                        BinOp.lt,
                                        [ M.read (| query |); M.read (| lim |) ]
                                      |)
                                    |)
                                  |)) in
                              let _ :=
                                is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                              M.never_to_any (|
                                M.call_closure (|
                                  Ty.path "never",
                                  M.get_function (| "core::panicking::panic", [], [] |),
                                  [ mk_str (| "assertion failed: query < lim" |) ]
                                |)
                              |)));
                          fun γ => ltac:(M.monadic (Value.Tuple []))
                        ]
                      |) in
                    let~ original_block :
                        Ty.path "openvm_circuit::system::memory::offline::BlockData" :=
                      M.call_closure (|
                        Ty.path "openvm_circuit::system::memory::offline::BlockData",
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "openvm_circuit::system::memory::offline::OfflineMemory")
                            []
                            [ F ],
                          "block_containing",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                          M.read (| address_space |);
                          M.read (| query |)
                        ]
                      |) in
                    let~ _ : Ty.tuple [] :=
                      M.match_operator (|
                        Ty.tuple [],
                        M.alloc (| Ty.tuple [], Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    Ty.path "bool",
                                    M.call_closure (|
                                      Ty.path "bool",
                                      BinOp.eq,
                                      [
                                        M.read (|
                                          M.SubPointer.get_struct_record_field (|
                                            original_block,
                                            "openvm_circuit::system::memory::offline::BlockData",
                                            "pointer"
                                          |)
                                        |);
                                        M.read (| query |)
                                      ]
                                    |)
                                  |)) in
                              let _ :=
                                is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                              M.never_to_any (| M.read (| M.return_ (| Value.Tuple [] |) |) |)));
                          fun γ => ltac:(M.monadic (Value.Tuple []))
                        ]
                      |) in
                    let~ data :
                        Ty.apply
                          (Ty.path "alloc::vec::Vec")
                          []
                          [ F; Ty.path "alloc::alloc::Global" ] :=
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "alloc::vec::Vec")
                          []
                          [ F; Ty.path "alloc::alloc::Global" ],
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "openvm_circuit::system::memory::offline::OfflineMemory")
                            []
                            [ F ],
                          "range_vec",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                          M.read (| address_space |);
                          M.read (|
                            M.SubPointer.get_struct_record_field (|
                              original_block,
                              "openvm_circuit::system::memory::offline::BlockData",
                              "pointer"
                            |)
                          |);
                          M.read (|
                            M.SubPointer.get_struct_record_field (|
                              original_block,
                              "openvm_circuit::system::memory::offline::BlockData",
                              "size"
                            |)
                          |)
                        ]
                      |) in
                    let~ timestamp : Ty.path "u32" :=
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          original_block,
                          "openvm_circuit::system::memory::offline::BlockData",
                          "timestamp"
                        |)
                      |) in
                    let~ cur_ptr : Ty.path "u32" :=
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          original_block,
                          "openvm_circuit::system::memory::offline::BlockData",
                          "pointer"
                        |)
                      |) in
                    let~ cur_size : Ty.path "usize" :=
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          original_block,
                          "openvm_circuit::system::memory::offline::BlockData",
                          "size"
                        |)
                      |) in
                    M.loop (|
                      Ty.tuple [],
                      ltac:(M.monadic
                        (M.alloc (|
                          Ty.tuple [],
                          M.match_operator (|
                            Ty.tuple [],
                            M.alloc (| Ty.tuple [], Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ :=
                                    M.use
                                      (M.alloc (|
                                        Ty.path "bool",
                                        M.call_closure (|
                                          Ty.path "bool",
                                          BinOp.gt,
                                          [ M.read (| cur_size |); Value.Integer IntegerKind.Usize 0
                                          ]
                                        |)
                                      |)) in
                                  let _ :=
                                    is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  M.read (|
                                    let~ _ : Ty.tuple [] :=
                                      M.call_closure (|
                                        Ty.tuple [],
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path
                                              "openvm_circuit::system::memory::adapter::AccessAdapterInventory")
                                            []
                                            [ F ],
                                          "add_record",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.MutRef,
                                            M.deref (| M.read (| records |) |)
                                          |);
                                          Value.mkStructRecord
                                            "openvm_circuit::system::memory::adapter::AccessAdapterRecord"
                                            []
                                            [ F ]
                                            [
                                              ("timestamp", M.read (| timestamp |));
                                              ("address_space",
                                                M.call_closure (|
                                                  F,
                                                  M.get_trait_method (|
                                                    "p3_field::field::FieldAlgebra",
                                                    F,
                                                    [],
                                                    [],
                                                    "from_canonical_u32",
                                                    [],
                                                    []
                                                  |),
                                                  [ M.read (| address_space |) ]
                                                |));
                                              ("start_index",
                                                M.call_closure (|
                                                  F,
                                                  M.get_trait_method (|
                                                    "p3_field::field::FieldAlgebra",
                                                    F,
                                                    [],
                                                    [],
                                                    "from_canonical_u32",
                                                    [],
                                                    []
                                                  |),
                                                  [ M.read (| cur_ptr |) ]
                                                |));
                                              ("data",
                                                M.call_closure (|
                                                  Ty.apply
                                                    (Ty.path "alloc::vec::Vec")
                                                    []
                                                    [ F; Ty.path "alloc::alloc::Global" ],
                                                  M.get_associated_function (|
                                                    Ty.apply (Ty.path "slice") [] [ F ],
                                                    "to_vec",
                                                    [],
                                                    []
                                                  |),
                                                  [
                                                    M.borrow (|
                                                      Pointer.Kind.Ref,
                                                      M.deref (|
                                                        M.call_closure (|
                                                          Ty.apply
                                                            (Ty.path "&")
                                                            []
                                                            [ Ty.apply (Ty.path "slice") [] [ F ] ],
                                                          M.get_trait_method (|
                                                            "core::ops::index::Index",
                                                            Ty.apply
                                                              (Ty.path "alloc::vec::Vec")
                                                              []
                                                              [ F; Ty.path "alloc::alloc::Global" ],
                                                            [],
                                                            [
                                                              Ty.apply
                                                                (Ty.path "core::ops::range::Range")
                                                                []
                                                                [ Ty.path "usize" ]
                                                            ],
                                                            "index",
                                                            [],
                                                            []
                                                          |),
                                                          [
                                                            M.borrow (| Pointer.Kind.Ref, data |);
                                                            Value.mkStructRecord
                                                              "core::ops::range::Range"
                                                              []
                                                              [ Ty.path "usize" ]
                                                              [
                                                                ("start",
                                                                  M.cast
                                                                    (Ty.path "usize")
                                                                    (M.call_closure (|
                                                                      Ty.path "u32",
                                                                      BinOp.Wrap.sub,
                                                                      [
                                                                        M.read (| cur_ptr |);
                                                                        M.read (|
                                                                          M.SubPointer.get_struct_record_field (|
                                                                            original_block,
                                                                            "openvm_circuit::system::memory::offline::BlockData",
                                                                            "pointer"
                                                                          |)
                                                                        |)
                                                                      ]
                                                                    |)));
                                                                ("end_",
                                                                  M.call_closure (|
                                                                    Ty.path "usize",
                                                                    BinOp.Wrap.add,
                                                                    [
                                                                      M.cast
                                                                        (Ty.path "usize")
                                                                        (M.call_closure (|
                                                                          Ty.path "u32",
                                                                          BinOp.Wrap.sub,
                                                                          [
                                                                            M.read (| cur_ptr |);
                                                                            M.read (|
                                                                              M.SubPointer.get_struct_record_field (|
                                                                                original_block,
                                                                                "openvm_circuit::system::memory::offline::BlockData",
                                                                                "pointer"
                                                                              |)
                                                                            |)
                                                                          ]
                                                                        |));
                                                                      M.read (| cur_size |)
                                                                    ]
                                                                  |))
                                                              ]
                                                          ]
                                                        |)
                                                      |)
                                                    |)
                                                  ]
                                                |));
                                              ("kind",
                                                Value.StructTuple
                                                  "openvm_circuit::system::memory::adapter::AccessAdapterRecordKind::Split"
                                                  []
                                                  []
                                                  [])
                                            ]
                                        ]
                                      |) in
                                    let~ half_size : Ty.path "usize" :=
                                      M.call_closure (|
                                        Ty.path "usize",
                                        BinOp.Wrap.div,
                                        [ M.read (| cur_size |); Value.Integer IntegerKind.Usize 2 ]
                                      |) in
                                    let~ half_size_u32 : Ty.path "u32" :=
                                      M.cast (Ty.path "u32") (M.read (| half_size |)) in
                                    let~ mid_ptr : Ty.path "u32" :=
                                      M.call_closure (|
                                        Ty.path "u32",
                                        BinOp.Wrap.add,
                                        [ M.read (| cur_ptr |); M.read (| half_size_u32 |) ]
                                      |) in
                                    let~ _ : Ty.tuple [] :=
                                      M.match_operator (|
                                        Ty.tuple [],
                                        M.alloc (| Ty.tuple [], Value.Tuple [] |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let γ :=
                                                M.use
                                                  (M.alloc (|
                                                    Ty.path "bool",
                                                    M.call_closure (|
                                                      Ty.path "bool",
                                                      BinOp.le,
                                                      [ M.read (| query |); M.read (| mid_ptr |) ]
                                                    |)
                                                  |)) in
                                              let _ :=
                                                is_constant_or_break_match (|
                                                  M.read (| γ |),
                                                  Value.Bool true
                                                |) in
                                              M.read (|
                                                let~ block :
                                                    Ty.path
                                                      "openvm_circuit::system::memory::offline::BlockData" :=
                                                  Value.mkStructRecord
                                                    "openvm_circuit::system::memory::offline::BlockData"
                                                    []
                                                    []
                                                    [
                                                      ("pointer", M.read (| mid_ptr |));
                                                      ("size", M.read (| half_size |));
                                                      ("timestamp", M.read (| timestamp |))
                                                    ] in
                                                let~ _ : Ty.tuple [] :=
                                                  M.call_closure (|
                                                    Ty.tuple [],
                                                    M.get_associated_function (|
                                                      Ty.path
                                                        "openvm_circuit::system::memory::offline::BlockMap",
                                                      "set_range",
                                                      [],
                                                      []
                                                    |),
                                                    [
                                                      M.borrow (|
                                                        Pointer.Kind.MutRef,
                                                        M.SubPointer.get_struct_record_field (|
                                                          M.deref (| M.read (| self |) |),
                                                          "openvm_circuit::system::memory::offline::OfflineMemory",
                                                          "block_data"
                                                        |)
                                                      |);
                                                      M.borrow (|
                                                        Pointer.Kind.Ref,
                                                        M.deref (|
                                                          M.borrow (|
                                                            Pointer.Kind.Ref,
                                                            M.alloc (|
                                                              Ty.tuple
                                                                [ Ty.path "u32"; Ty.path "u32" ],
                                                              Value.Tuple
                                                                [
                                                                  M.read (| address_space |);
                                                                  M.read (| mid_ptr |)
                                                                ]
                                                            |)
                                                          |)
                                                        |)
                                                      |);
                                                      M.read (| half_size |);
                                                      M.read (| block |)
                                                    ]
                                                  |) in
                                                M.alloc (| Ty.tuple [], Value.Tuple [] |)
                                              |)));
                                          fun γ => ltac:(M.monadic (Value.Tuple []))
                                        ]
                                      |) in
                                    let~ _ : Ty.tuple [] :=
                                      M.match_operator (|
                                        Ty.tuple [],
                                        M.alloc (| Ty.tuple [], Value.Tuple [] |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let γ :=
                                                M.use
                                                  (M.alloc (|
                                                    Ty.path "bool",
                                                    M.call_closure (|
                                                      Ty.path "bool",
                                                      BinOp.ge,
                                                      [
                                                        M.read (| query |);
                                                        M.call_closure (|
                                                          Ty.path "u32",
                                                          BinOp.Wrap.add,
                                                          [
                                                            M.read (| cur_ptr |);
                                                            M.read (| half_size_u32 |)
                                                          ]
                                                        |)
                                                      ]
                                                    |)
                                                  |)) in
                                              let _ :=
                                                is_constant_or_break_match (|
                                                  M.read (| γ |),
                                                  Value.Bool true
                                                |) in
                                              M.read (|
                                                let~ block :
                                                    Ty.path
                                                      "openvm_circuit::system::memory::offline::BlockData" :=
                                                  Value.mkStructRecord
                                                    "openvm_circuit::system::memory::offline::BlockData"
                                                    []
                                                    []
                                                    [
                                                      ("pointer", M.read (| cur_ptr |));
                                                      ("size", M.read (| half_size |));
                                                      ("timestamp", M.read (| timestamp |))
                                                    ] in
                                                let~ _ : Ty.tuple [] :=
                                                  M.call_closure (|
                                                    Ty.tuple [],
                                                    M.get_associated_function (|
                                                      Ty.path
                                                        "openvm_circuit::system::memory::offline::BlockMap",
                                                      "set_range",
                                                      [],
                                                      []
                                                    |),
                                                    [
                                                      M.borrow (|
                                                        Pointer.Kind.MutRef,
                                                        M.SubPointer.get_struct_record_field (|
                                                          M.deref (| M.read (| self |) |),
                                                          "openvm_circuit::system::memory::offline::OfflineMemory",
                                                          "block_data"
                                                        |)
                                                      |);
                                                      M.borrow (|
                                                        Pointer.Kind.Ref,
                                                        M.deref (|
                                                          M.borrow (|
                                                            Pointer.Kind.Ref,
                                                            M.alloc (|
                                                              Ty.tuple
                                                                [ Ty.path "u32"; Ty.path "u32" ],
                                                              Value.Tuple
                                                                [
                                                                  M.read (| address_space |);
                                                                  M.read (| cur_ptr |)
                                                                ]
                                                            |)
                                                          |)
                                                        |)
                                                      |);
                                                      M.read (| half_size |);
                                                      M.read (| block |)
                                                    ]
                                                  |) in
                                                M.alloc (| Ty.tuple [], Value.Tuple [] |)
                                              |)));
                                          fun γ => ltac:(M.monadic (Value.Tuple []))
                                        ]
                                      |) in
                                    let~ _ : Ty.tuple [] :=
                                      M.match_operator (|
                                        Ty.tuple [],
                                        M.alloc (| Ty.tuple [], Value.Tuple [] |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let γ :=
                                                M.use
                                                  (M.alloc (|
                                                    Ty.path "bool",
                                                    M.call_closure (|
                                                      Ty.path "bool",
                                                      BinOp.le,
                                                      [ M.read (| mid_ptr |); M.read (| query |) ]
                                                    |)
                                                  |)) in
                                              let _ :=
                                                is_constant_or_break_match (|
                                                  M.read (| γ |),
                                                  Value.Bool true
                                                |) in
                                              M.read (|
                                                let~ _ : Ty.tuple [] :=
                                                  M.write (| cur_ptr, M.read (| mid_ptr |) |) in
                                                M.alloc (| Ty.tuple [], Value.Tuple [] |)
                                              |)));
                                          fun γ => ltac:(M.monadic (Value.Tuple []))
                                        ]
                                      |) in
                                    let~ _ : Ty.tuple [] :=
                                      M.match_operator (|
                                        Ty.tuple [],
                                        M.alloc (| Ty.tuple [], Value.Tuple [] |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let γ :=
                                                M.use
                                                  (M.alloc (|
                                                    Ty.path "bool",
                                                    M.call_closure (|
                                                      Ty.path "bool",
                                                      BinOp.eq,
                                                      [ M.read (| cur_ptr |); M.read (| query |) ]
                                                    |)
                                                  |)) in
                                              let _ :=
                                                is_constant_or_break_match (|
                                                  M.read (| γ |),
                                                  Value.Bool true
                                                |) in
                                              M.never_to_any (| M.read (| M.break (||) |) |)));
                                          fun γ => ltac:(M.monadic (Value.Tuple []))
                                        ]
                                      |) in
                                    let~ _ : Ty.tuple [] :=
                                      M.write (| cur_size, M.read (| half_size |) |) in
                                    M.alloc (| Ty.tuple [], Value.Tuple [] |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (M.never_to_any (|
                                    M.read (|
                                      let~ _ : Ty.tuple [] :=
                                        M.never_to_any (| M.read (| M.break (||) |) |) in
                                      M.alloc (| Ty.tuple [], Value.Tuple [] |)
                                    |)
                                  |)))
                            ]
                          |)
                        |)))
                    |)
                  |)))
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Global Instance AssociatedFunction_split_to_make_boundary :
          forall (F : Ty.t),
          M.IsAssociatedFunction.C (Self F) "split_to_make_boundary" (split_to_make_boundary F).
        Admitted.
        Global Typeclasses Opaque split_to_make_boundary.
        
        (*
            fn access_updating_timestamp(
                &mut self,
                address_space: u32,
                pointer: u32,
                size: usize,
                records: &mut AccessAdapterInventory<F>,
            ) -> u32 {
                self.access(address_space, pointer, size, records);
        
                let mut prev_timestamp = None;
        
                let mut i = 0;
                while i < size as u32 {
                    let block = self.block_data.get_mut(&(address_space, pointer + i));
                    debug_assert!(i == 0 || prev_timestamp == Some(block.timestamp));
                    prev_timestamp = Some(block.timestamp);
                    block.timestamp = self.timestamp;
                    i = block.pointer + block.size as u32;
                }
                prev_timestamp.unwrap()
            }
        *)
        Definition access_updating_timestamp
            (F : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self F in
          match ε, τ, α with
          | [], [], [ self; address_space; pointer; size; records ] =>
            ltac:(M.monadic
              (let self :=
                M.alloc (|
                  Ty.apply
                    (Ty.path "&mut")
                    []
                    [
                      Ty.apply
                        (Ty.path "openvm_circuit::system::memory::offline::OfflineMemory")
                        []
                        [ F ]
                    ],
                  self
                |) in
              let address_space := M.alloc (| Ty.path "u32", address_space |) in
              let pointer := M.alloc (| Ty.path "u32", pointer |) in
              let size := M.alloc (| Ty.path "usize", size |) in
              let records :=
                M.alloc (|
                  Ty.apply
                    (Ty.path "&mut")
                    []
                    [
                      Ty.apply
                        (Ty.path "openvm_circuit::system::memory::adapter::AccessAdapterInventory")
                        []
                        [ F ]
                    ],
                  records
                |) in
              M.read (|
                let~ _ : Ty.tuple [] :=
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "openvm_circuit::system::memory::offline::OfflineMemory")
                        []
                        [ F ],
                      "access",
                      [],
                      []
                    |),
                    [
                      M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                      M.read (| address_space |);
                      M.read (| pointer |);
                      M.read (| size |);
                      M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| records |) |) |)
                    ]
                  |) in
                let~ prev_timestamp :
                    Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "u32" ] :=
                  Value.StructTuple "core::option::Option::None" [] [ Ty.path "u32" ] [] in
                let~ i : Ty.path "u32" := Value.Integer IntegerKind.U32 0 in
                let~ _ : Ty.tuple [] :=
                  M.read (|
                    M.loop (|
                      Ty.tuple [],
                      ltac:(M.monadic
                        (M.alloc (|
                          Ty.tuple [],
                          M.match_operator (|
                            Ty.tuple [],
                            M.alloc (| Ty.tuple [], Value.Tuple [] |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ :=
                                    M.use
                                      (M.alloc (|
                                        Ty.path "bool",
                                        M.call_closure (|
                                          Ty.path "bool",
                                          BinOp.lt,
                                          [
                                            M.read (| i |);
                                            M.cast (Ty.path "u32") (M.read (| size |))
                                          ]
                                        |)
                                      |)) in
                                  let _ :=
                                    is_constant_or_break_match (|
                                      M.read (| γ |),
                                      Value.Bool true
                                    |) in
                                  M.read (|
                                    let~ block :
                                        Ty.apply
                                          (Ty.path "&mut")
                                          []
                                          [
                                            Ty.path
                                              "openvm_circuit::system::memory::offline::BlockData"
                                          ] :=
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "&mut")
                                          []
                                          [
                                            Ty.path
                                              "openvm_circuit::system::memory::offline::BlockData"
                                          ],
                                        M.get_associated_function (|
                                          Ty.path
                                            "openvm_circuit::system::memory::offline::BlockMap",
                                          "get_mut",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.MutRef,
                                            M.SubPointer.get_struct_record_field (|
                                              M.deref (| M.read (| self |) |),
                                              "openvm_circuit::system::memory::offline::OfflineMemory",
                                              "block_data"
                                            |)
                                          |);
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (|
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.alloc (|
                                                  Ty.tuple [ Ty.path "u32"; Ty.path "u32" ],
                                                  Value.Tuple
                                                    [
                                                      M.read (| address_space |);
                                                      M.call_closure (|
                                                        Ty.path "u32",
                                                        BinOp.Wrap.add,
                                                        [ M.read (| pointer |); M.read (| i |) ]
                                                      |)
                                                    ]
                                                |)
                                              |)
                                            |)
                                          |)
                                        ]
                                      |) in
                                    let~ _ : Ty.tuple [] :=
                                      M.match_operator (|
                                        Ty.tuple [],
                                        M.alloc (| Ty.tuple [], Value.Tuple [] |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let γ :=
                                                M.use
                                                  (M.alloc (| Ty.path "bool", Value.Bool true |)) in
                                              let _ :=
                                                is_constant_or_break_match (|
                                                  M.read (| γ |),
                                                  Value.Bool true
                                                |) in
                                              M.read (|
                                                let~ _ : Ty.tuple [] :=
                                                  M.match_operator (|
                                                    Ty.tuple [],
                                                    M.alloc (| Ty.tuple [], Value.Tuple [] |),
                                                    [
                                                      fun γ =>
                                                        ltac:(M.monadic
                                                          (let γ :=
                                                            M.use
                                                              (M.alloc (|
                                                                Ty.path "bool",
                                                                UnOp.not (|
                                                                  LogicalOp.or (|
                                                                    M.call_closure (|
                                                                      Ty.path "bool",
                                                                      BinOp.eq,
                                                                      [
                                                                        M.read (| i |);
                                                                        Value.Integer
                                                                          IntegerKind.U32
                                                                          0
                                                                      ]
                                                                    |),
                                                                    ltac:(M.monadic
                                                                      (M.call_closure (|
                                                                        Ty.path "bool",
                                                                        M.get_trait_method (|
                                                                          "core::cmp::PartialEq",
                                                                          Ty.apply
                                                                            (Ty.path
                                                                              "core::option::Option")
                                                                            []
                                                                            [ Ty.path "u32" ],
                                                                          [],
                                                                          [
                                                                            Ty.apply
                                                                              (Ty.path
                                                                                "core::option::Option")
                                                                              []
                                                                              [ Ty.path "u32" ]
                                                                          ],
                                                                          "eq",
                                                                          [],
                                                                          []
                                                                        |),
                                                                        [
                                                                          M.borrow (|
                                                                            Pointer.Kind.Ref,
                                                                            prev_timestamp
                                                                          |);
                                                                          M.borrow (|
                                                                            Pointer.Kind.Ref,
                                                                            M.alloc (|
                                                                              Ty.apply
                                                                                (Ty.path
                                                                                  "core::option::Option")
                                                                                []
                                                                                [ Ty.path "u32" ],
                                                                              Value.StructTuple
                                                                                "core::option::Option::Some"
                                                                                []
                                                                                [ Ty.path "u32" ]
                                                                                [
                                                                                  M.read (|
                                                                                    M.SubPointer.get_struct_record_field (|
                                                                                      M.deref (|
                                                                                        M.read (|
                                                                                          block
                                                                                        |)
                                                                                      |),
                                                                                      "openvm_circuit::system::memory::offline::BlockData",
                                                                                      "timestamp"
                                                                                    |)
                                                                                  |)
                                                                                ]
                                                                            |)
                                                                          |)
                                                                        ]
                                                                      |)))
                                                                  |)
                                                                |)
                                                              |)) in
                                                          let _ :=
                                                            is_constant_or_break_match (|
                                                              M.read (| γ |),
                                                              Value.Bool true
                                                            |) in
                                                          M.never_to_any (|
                                                            M.call_closure (|
                                                              Ty.path "never",
                                                              M.get_function (|
                                                                "core::panicking::panic",
                                                                [],
                                                                []
                                                              |),
                                                              [
                                                                mk_str (|
                                                                  "assertion failed: i == 0 || prev_timestamp == Some(block.timestamp)"
                                                                |)
                                                              ]
                                                            |)
                                                          |)));
                                                      fun γ => ltac:(M.monadic (Value.Tuple []))
                                                    ]
                                                  |) in
                                                M.alloc (| Ty.tuple [], Value.Tuple [] |)
                                              |)));
                                          fun γ => ltac:(M.monadic (Value.Tuple []))
                                        ]
                                      |) in
                                    let~ _ : Ty.tuple [] :=
                                      M.write (|
                                        prev_timestamp,
                                        Value.StructTuple
                                          "core::option::Option::Some"
                                          []
                                          [ Ty.path "u32" ]
                                          [
                                            M.read (|
                                              M.SubPointer.get_struct_record_field (|
                                                M.deref (| M.read (| block |) |),
                                                "openvm_circuit::system::memory::offline::BlockData",
                                                "timestamp"
                                              |)
                                            |)
                                          ]
                                      |) in
                                    let~ _ : Ty.tuple [] :=
                                      M.write (|
                                        M.SubPointer.get_struct_record_field (|
                                          M.deref (| M.read (| block |) |),
                                          "openvm_circuit::system::memory::offline::BlockData",
                                          "timestamp"
                                        |),
                                        M.read (|
                                          M.SubPointer.get_struct_record_field (|
                                            M.deref (| M.read (| self |) |),
                                            "openvm_circuit::system::memory::offline::OfflineMemory",
                                            "timestamp"
                                          |)
                                        |)
                                      |) in
                                    let~ _ : Ty.tuple [] :=
                                      M.write (|
                                        i,
                                        M.call_closure (|
                                          Ty.path "u32",
                                          BinOp.Wrap.add,
                                          [
                                            M.read (|
                                              M.SubPointer.get_struct_record_field (|
                                                M.deref (| M.read (| block |) |),
                                                "openvm_circuit::system::memory::offline::BlockData",
                                                "pointer"
                                              |)
                                            |);
                                            M.cast
                                              (Ty.path "u32")
                                              (M.read (|
                                                M.SubPointer.get_struct_record_field (|
                                                  M.deref (| M.read (| block |) |),
                                                  "openvm_circuit::system::memory::offline::BlockData",
                                                  "size"
                                                |)
                                              |))
                                          ]
                                        |)
                                      |) in
                                    M.alloc (| Ty.tuple [], Value.Tuple [] |)
                                  |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (M.never_to_any (|
                                    M.read (|
                                      let~ _ : Ty.tuple [] :=
                                        M.never_to_any (| M.read (| M.break (||) |) |) in
                                      M.alloc (| Ty.tuple [], Value.Tuple [] |)
                                    |)
                                  |)))
                            ]
                          |)
                        |)))
                    |)
                  |) in
                M.alloc (|
                  Ty.path "u32",
                  M.call_closure (|
                    Ty.path "u32",
                    M.get_associated_function (|
                      Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "u32" ],
                      "unwrap",
                      [],
                      []
                    |),
                    [ M.read (| prev_timestamp |) ]
                  |)
                |)
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Global Instance AssociatedFunction_access_updating_timestamp :
          forall (F : Ty.t),
          M.IsAssociatedFunction.C
            (Self F)
            "access_updating_timestamp"
            (access_updating_timestamp F).
        Admitted.
        Global Typeclasses Opaque access_updating_timestamp.
        
        (*
            fn access(
                &mut self,
                address_space: u32,
                pointer: u32,
                size: usize,
                records: &mut AccessAdapterInventory<F>,
            ) {
                self.split_to_make_boundary(address_space, pointer, records);
                self.split_to_make_boundary(address_space, pointer + size as u32, records);
        
                let block_data = self.block_containing(address_space, pointer);
        
                if block_data.pointer == pointer && block_data.size == size {
                    return;
                }
                assert!(size > 1);
        
                // Now recursively access left and right blocks to ensure they are in the partition.
                let half_size = size / 2;
                self.access(address_space, pointer, half_size, records);
                self.access(
                    address_space,
                    pointer + half_size as u32,
                    half_size,
                    records,
                );
        
                self.merge_block_with_next(address_space, pointer, records);
            }
        *)
        Definition access (F : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self F in
          match ε, τ, α with
          | [], [], [ self; address_space; pointer; size; records ] =>
            ltac:(M.monadic
              (let self :=
                M.alloc (|
                  Ty.apply
                    (Ty.path "&mut")
                    []
                    [
                      Ty.apply
                        (Ty.path "openvm_circuit::system::memory::offline::OfflineMemory")
                        []
                        [ F ]
                    ],
                  self
                |) in
              let address_space := M.alloc (| Ty.path "u32", address_space |) in
              let pointer := M.alloc (| Ty.path "u32", pointer |) in
              let size := M.alloc (| Ty.path "usize", size |) in
              let records :=
                M.alloc (|
                  Ty.apply
                    (Ty.path "&mut")
                    []
                    [
                      Ty.apply
                        (Ty.path "openvm_circuit::system::memory::adapter::AccessAdapterInventory")
                        []
                        [ F ]
                    ],
                  records
                |) in
              M.catch_return (Ty.tuple []) (|
                ltac:(M.monadic
                  (M.read (|
                    let~ _ : Ty.tuple [] :=
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "openvm_circuit::system::memory::offline::OfflineMemory")
                            []
                            [ F ],
                          "split_to_make_boundary",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                          M.read (| address_space |);
                          M.read (| pointer |);
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| records |) |) |)
                        ]
                      |) in
                    let~ _ : Ty.tuple [] :=
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "openvm_circuit::system::memory::offline::OfflineMemory")
                            []
                            [ F ],
                          "split_to_make_boundary",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                          M.read (| address_space |);
                          M.call_closure (|
                            Ty.path "u32",
                            BinOp.Wrap.add,
                            [ M.read (| pointer |); M.cast (Ty.path "u32") (M.read (| size |)) ]
                          |);
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| records |) |) |)
                        ]
                      |) in
                    let~ block_data :
                        Ty.path "openvm_circuit::system::memory::offline::BlockData" :=
                      M.call_closure (|
                        Ty.path "openvm_circuit::system::memory::offline::BlockData",
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "openvm_circuit::system::memory::offline::OfflineMemory")
                            []
                            [ F ],
                          "block_containing",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                          M.read (| address_space |);
                          M.read (| pointer |)
                        ]
                      |) in
                    let~ _ : Ty.tuple [] :=
                      M.match_operator (|
                        Ty.tuple [],
                        M.alloc (| Ty.tuple [], Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    Ty.path "bool",
                                    LogicalOp.and (|
                                      M.call_closure (|
                                        Ty.path "bool",
                                        BinOp.eq,
                                        [
                                          M.read (|
                                            M.SubPointer.get_struct_record_field (|
                                              block_data,
                                              "openvm_circuit::system::memory::offline::BlockData",
                                              "pointer"
                                            |)
                                          |);
                                          M.read (| pointer |)
                                        ]
                                      |),
                                      ltac:(M.monadic
                                        (M.call_closure (|
                                          Ty.path "bool",
                                          BinOp.eq,
                                          [
                                            M.read (|
                                              M.SubPointer.get_struct_record_field (|
                                                block_data,
                                                "openvm_circuit::system::memory::offline::BlockData",
                                                "size"
                                              |)
                                            |);
                                            M.read (| size |)
                                          ]
                                        |)))
                                    |)
                                  |)) in
                              let _ :=
                                is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                              M.never_to_any (| M.read (| M.return_ (| Value.Tuple [] |) |) |)));
                          fun γ => ltac:(M.monadic (Value.Tuple []))
                        ]
                      |) in
                    let~ _ : Ty.tuple [] :=
                      M.match_operator (|
                        Ty.tuple [],
                        M.alloc (| Ty.tuple [], Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    Ty.path "bool",
                                    UnOp.not (|
                                      M.call_closure (|
                                        Ty.path "bool",
                                        BinOp.gt,
                                        [ M.read (| size |); Value.Integer IntegerKind.Usize 1 ]
                                      |)
                                    |)
                                  |)) in
                              let _ :=
                                is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                              M.never_to_any (|
                                M.call_closure (|
                                  Ty.path "never",
                                  M.get_function (| "core::panicking::panic", [], [] |),
                                  [ mk_str (| "assertion failed: size > 1" |) ]
                                |)
                              |)));
                          fun γ => ltac:(M.monadic (Value.Tuple []))
                        ]
                      |) in
                    let~ half_size : Ty.path "usize" :=
                      M.call_closure (|
                        Ty.path "usize",
                        BinOp.Wrap.div,
                        [ M.read (| size |); Value.Integer IntegerKind.Usize 2 ]
                      |) in
                    let~ _ : Ty.tuple [] :=
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "openvm_circuit::system::memory::offline::OfflineMemory")
                            []
                            [ F ],
                          "access",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                          M.read (| address_space |);
                          M.read (| pointer |);
                          M.read (| half_size |);
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| records |) |) |)
                        ]
                      |) in
                    let~ _ : Ty.tuple [] :=
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "openvm_circuit::system::memory::offline::OfflineMemory")
                            []
                            [ F ],
                          "access",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                          M.read (| address_space |);
                          M.call_closure (|
                            Ty.path "u32",
                            BinOp.Wrap.add,
                            [ M.read (| pointer |); M.cast (Ty.path "u32") (M.read (| half_size |))
                            ]
                          |);
                          M.read (| half_size |);
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| records |) |) |)
                        ]
                      |) in
                    let~ _ : Ty.tuple [] :=
                      M.call_closure (|
                        Ty.tuple [],
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "openvm_circuit::system::memory::offline::OfflineMemory")
                            []
                            [ F ],
                          "merge_block_with_next",
                          [],
                          []
                        |),
                        [
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                          M.read (| address_space |);
                          M.read (| pointer |);
                          M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| records |) |) |)
                        ]
                      |) in
                    M.alloc (| Ty.tuple [], Value.Tuple [] |)
                  |)))
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Global Instance AssociatedFunction_access :
          forall (F : Ty.t),
          M.IsAssociatedFunction.C (Self F) "access" (access F).
        Admitted.
        Global Typeclasses Opaque access.
        
        (*
            fn merge_block_with_next(
                &mut self,
                address_space: u32,
                pointer: u32,
                records: &mut AccessAdapterInventory<F>,
            ) {
                let left_block = self.block_data.get(&(address_space, pointer));
        
                let left_timestamp = left_block.timestamp;
                let size = left_block.size;
        
                let right_timestamp = self
                    .block_data
                    .get(&(address_space, pointer + size as u32))
                    .timestamp;
        
                let timestamp = max(left_timestamp, right_timestamp);
                self.block_data.set_range(
                    &(address_space, pointer),
                    2 * size,
                    BlockData {
                        pointer,
                        size: 2 * size,
                        timestamp,
                    },
                );
                records.add_record(AccessAdapterRecord {
                    timestamp,
                    address_space: F::from_canonical_u32(address_space),
                    start_index: F::from_canonical_u32(pointer),
                    data: self.range_vec(address_space, pointer, 2 * size),
                    kind: AccessAdapterRecordKind::Merge {
                        left_timestamp,
                        right_timestamp,
                    },
                });
            }
        *)
        Definition merge_block_with_next
            (F : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self F in
          match ε, τ, α with
          | [], [], [ self; address_space; pointer; records ] =>
            ltac:(M.monadic
              (let self :=
                M.alloc (|
                  Ty.apply
                    (Ty.path "&mut")
                    []
                    [
                      Ty.apply
                        (Ty.path "openvm_circuit::system::memory::offline::OfflineMemory")
                        []
                        [ F ]
                    ],
                  self
                |) in
              let address_space := M.alloc (| Ty.path "u32", address_space |) in
              let pointer := M.alloc (| Ty.path "u32", pointer |) in
              let records :=
                M.alloc (|
                  Ty.apply
                    (Ty.path "&mut")
                    []
                    [
                      Ty.apply
                        (Ty.path "openvm_circuit::system::memory::adapter::AccessAdapterInventory")
                        []
                        [ F ]
                    ],
                  records
                |) in
              M.read (|
                let~ left_block :
                    Ty.apply
                      (Ty.path "&")
                      []
                      [ Ty.path "openvm_circuit::system::memory::offline::BlockData" ] :=
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "&")
                      []
                      [ Ty.path "openvm_circuit::system::memory::offline::BlockData" ],
                    M.get_associated_function (|
                      Ty.path "openvm_circuit::system::memory::offline::BlockMap",
                      "get",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "openvm_circuit::system::memory::offline::OfflineMemory",
                          "block_data"
                        |)
                      |);
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.alloc (|
                              Ty.tuple [ Ty.path "u32"; Ty.path "u32" ],
                              Value.Tuple [ M.read (| address_space |); M.read (| pointer |) ]
                            |)
                          |)
                        |)
                      |)
                    ]
                  |) in
                let~ left_timestamp : Ty.path "u32" :=
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| left_block |) |),
                      "openvm_circuit::system::memory::offline::BlockData",
                      "timestamp"
                    |)
                  |) in
                let~ size : Ty.path "usize" :=
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| left_block |) |),
                      "openvm_circuit::system::memory::offline::BlockData",
                      "size"
                    |)
                  |) in
                let~ right_timestamp : Ty.path "u32" :=
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.path "openvm_circuit::system::memory::offline::BlockData" ],
                          M.get_associated_function (|
                            Ty.path "openvm_circuit::system::memory::offline::BlockMap",
                            "get",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.MutRef,
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "openvm_circuit::system::memory::offline::OfflineMemory",
                                "block_data"
                              |)
                            |);
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.alloc (|
                                    Ty.tuple [ Ty.path "u32"; Ty.path "u32" ],
                                    Value.Tuple
                                      [
                                        M.read (| address_space |);
                                        M.call_closure (|
                                          Ty.path "u32",
                                          BinOp.Wrap.add,
                                          [
                                            M.read (| pointer |);
                                            M.cast (Ty.path "u32") (M.read (| size |))
                                          ]
                                        |)
                                      ]
                                  |)
                                |)
                              |)
                            |)
                          ]
                        |)
                      |),
                      "openvm_circuit::system::memory::offline::BlockData",
                      "timestamp"
                    |)
                  |) in
                let~ timestamp : Ty.path "u32" :=
                  M.call_closure (|
                    Ty.path "u32",
                    M.get_function (| "core::cmp::max", [], [ Ty.path "u32" ] |),
                    [ M.read (| left_timestamp |); M.read (| right_timestamp |) ]
                  |) in
                let~ _ : Ty.tuple [] :=
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_associated_function (|
                      Ty.path "openvm_circuit::system::memory::offline::BlockMap",
                      "set_range",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "openvm_circuit::system::memory::offline::OfflineMemory",
                          "block_data"
                        |)
                      |);
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.alloc (|
                              Ty.tuple [ Ty.path "u32"; Ty.path "u32" ],
                              Value.Tuple [ M.read (| address_space |); M.read (| pointer |) ]
                            |)
                          |)
                        |)
                      |);
                      M.call_closure (|
                        Ty.path "usize",
                        BinOp.Wrap.mul,
                        [ Value.Integer IntegerKind.Usize 2; M.read (| size |) ]
                      |);
                      Value.mkStructRecord
                        "openvm_circuit::system::memory::offline::BlockData"
                        []
                        []
                        [
                          ("pointer", M.read (| pointer |));
                          ("size",
                            M.call_closure (|
                              Ty.path "usize",
                              BinOp.Wrap.mul,
                              [ Value.Integer IntegerKind.Usize 2; M.read (| size |) ]
                            |));
                          ("timestamp", M.read (| timestamp |))
                        ]
                    ]
                  |) in
                let~ _ : Ty.tuple [] :=
                  M.call_closure (|
                    Ty.tuple [],
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "openvm_circuit::system::memory::adapter::AccessAdapterInventory")
                        []
                        [ F ],
                      "add_record",
                      [],
                      []
                    |),
                    [
                      M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| records |) |) |);
                      Value.mkStructRecord
                        "openvm_circuit::system::memory::adapter::AccessAdapterRecord"
                        []
                        [ F ]
                        [
                          ("timestamp", M.read (| timestamp |));
                          ("address_space",
                            M.call_closure (|
                              F,
                              M.get_trait_method (|
                                "p3_field::field::FieldAlgebra",
                                F,
                                [],
                                [],
                                "from_canonical_u32",
                                [],
                                []
                              |),
                              [ M.read (| address_space |) ]
                            |));
                          ("start_index",
                            M.call_closure (|
                              F,
                              M.get_trait_method (|
                                "p3_field::field::FieldAlgebra",
                                F,
                                [],
                                [],
                                "from_canonical_u32",
                                [],
                                []
                              |),
                              [ M.read (| pointer |) ]
                            |));
                          ("data",
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                []
                                [ F; Ty.path "alloc::alloc::Global" ],
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "openvm_circuit::system::memory::offline::OfflineMemory")
                                  []
                                  [ F ],
                                "range_vec",
                                [],
                                []
                              |),
                              [
                                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                                M.read (| address_space |);
                                M.read (| pointer |);
                                M.call_closure (|
                                  Ty.path "usize",
                                  BinOp.Wrap.mul,
                                  [ Value.Integer IntegerKind.Usize 2; M.read (| size |) ]
                                |)
                              ]
                            |));
                          ("kind",
                            Value.mkStructRecord
                              "openvm_circuit::system::memory::adapter::AccessAdapterRecordKind::Merge"
                              []
                              []
                              [
                                ("left_timestamp", M.read (| left_timestamp |));
                                ("right_timestamp", M.read (| right_timestamp |))
                              ])
                        ]
                    ]
                  |) in
                M.alloc (| Ty.tuple [], Value.Tuple [] |)
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Global Instance AssociatedFunction_merge_block_with_next :
          forall (F : Ty.t),
          M.IsAssociatedFunction.C (Self F) "merge_block_with_next" (merge_block_with_next F).
        Admitted.
        Global Typeclasses Opaque merge_block_with_next.
        
        (*
            fn block_containing(&mut self, address_space: u32, pointer: u32) -> BlockData {
                self.block_data
                    .get_without_adding(&(address_space, pointer))
            }
        *)
        Definition block_containing
            (F : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self F in
          match ε, τ, α with
          | [], [], [ self; address_space; pointer ] =>
            ltac:(M.monadic
              (let self :=
                M.alloc (|
                  Ty.apply
                    (Ty.path "&mut")
                    []
                    [
                      Ty.apply
                        (Ty.path "openvm_circuit::system::memory::offline::OfflineMemory")
                        []
                        [ F ]
                    ],
                  self
                |) in
              let address_space := M.alloc (| Ty.path "u32", address_space |) in
              let pointer := M.alloc (| Ty.path "u32", pointer |) in
              M.call_closure (|
                Ty.path "openvm_circuit::system::memory::offline::BlockData",
                M.get_associated_function (|
                  Ty.path "openvm_circuit::system::memory::offline::BlockMap",
                  "get_without_adding",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "openvm_circuit::system::memory::offline::OfflineMemory",
                      "block_data"
                    |)
                  |);
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          Ty.tuple [ Ty.path "u32"; Ty.path "u32" ],
                          Value.Tuple [ M.read (| address_space |); M.read (| pointer |) ]
                        |)
                      |)
                    |)
                  |)
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Global Instance AssociatedFunction_block_containing :
          forall (F : Ty.t),
          M.IsAssociatedFunction.C (Self F) "block_containing" (block_containing F).
        Admitted.
        Global Typeclasses Opaque block_containing.
        
        (*
            pub fn get(&self, address_space: u32, pointer: u32) -> F {
                self.data[(address_space - self.as_offset) as usize]
                    .get(pointer as usize)
                    .cloned()
                    .unwrap_or_default()
            }
        *)
        Definition get (F : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self F in
          match ε, τ, α with
          | [], [], [ self; address_space; pointer ] =>
            ltac:(M.monadic
              (let self :=
                M.alloc (|
                  Ty.apply
                    (Ty.path "&")
                    []
                    [
                      Ty.apply
                        (Ty.path "openvm_circuit::system::memory::offline::OfflineMemory")
                        []
                        [ F ]
                    ],
                  self
                |) in
              let address_space := M.alloc (| Ty.path "u32", address_space |) in
              let pointer := M.alloc (| Ty.path "u32", pointer |) in
              M.call_closure (|
                F,
                M.get_associated_function (|
                  Ty.apply (Ty.path "core::option::Option") [] [ F ],
                  "unwrap_or_default",
                  [],
                  []
                |),
                [
                  M.call_closure (|
                    Ty.apply (Ty.path "core::option::Option") [] [ F ],
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "core::option::Option")
                        []
                        [ Ty.apply (Ty.path "&") [] [ F ] ],
                      "cloned",
                      [],
                      []
                    |),
                    [
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::option::Option")
                          []
                          [ Ty.apply (Ty.path "&") [] [ F ] ],
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "openvm_circuit::system::memory::paged_vec::PagedVec")
                            [ Value.Integer IntegerKind.Usize 4096 ]
                            [ F ],
                          "get",
                          [],
                          []
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path
                                        "openvm_circuit::system::memory::paged_vec::PagedVec")
                                      [ Value.Integer IntegerKind.Usize 4096 ]
                                      [ F ]
                                  ],
                                M.get_trait_method (|
                                  "core::ops::index::Index",
                                  Ty.apply
                                    (Ty.path "alloc::vec::Vec")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path
                                          "openvm_circuit::system::memory::paged_vec::PagedVec")
                                        [ Value.Integer IntegerKind.Usize 4096 ]
                                        [ F ];
                                      Ty.path "alloc::alloc::Global"
                                    ],
                                  [],
                                  [ Ty.path "usize" ],
                                  "index",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "openvm_circuit::system::memory::offline::OfflineMemory",
                                      "data"
                                    |)
                                  |);
                                  M.cast
                                    (Ty.path "usize")
                                    (M.call_closure (|
                                      Ty.path "u32",
                                      BinOp.Wrap.sub,
                                      [
                                        M.read (| address_space |);
                                        M.read (|
                                          M.SubPointer.get_struct_record_field (|
                                            M.deref (| M.read (| self |) |),
                                            "openvm_circuit::system::memory::offline::OfflineMemory",
                                            "as_offset"
                                          |)
                                        |)
                                      ]
                                    |))
                                ]
                              |)
                            |)
                          |);
                          M.cast (Ty.path "usize") (M.read (| pointer |))
                        ]
                      |)
                    ]
                  |)
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Global Instance AssociatedFunction_get :
          forall (F : Ty.t),
          M.IsAssociatedFunction.C (Self F) "get" (get F).
        Admitted.
        Global Typeclasses Opaque get.
        
        (*
            fn range_array<const N: usize>(&self, address_space: u32, pointer: u32) -> [F; N] {
                array::from_fn(|i| self.get(address_space, pointer + i as u32))
            }
        *)
        Definition range_array
            (F : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self F in
          match ε, τ, α with
          | [ N ], [], [ self; address_space; pointer ] =>
            ltac:(M.monadic
              (let self :=
                M.alloc (|
                  Ty.apply
                    (Ty.path "&")
                    []
                    [
                      Ty.apply
                        (Ty.path "openvm_circuit::system::memory::offline::OfflineMemory")
                        []
                        [ F ]
                    ],
                  self
                |) in
              let address_space := M.alloc (| Ty.path "u32", address_space |) in
              let pointer := M.alloc (| Ty.path "u32", pointer |) in
              M.call_closure (|
                Ty.apply (Ty.path "array") [ N ] [ F ],
                M.get_function (|
                  "core::array::from_fn",
                  [ N ],
                  [ F; Ty.function [ Ty.path "usize" ] F ]
                |),
                [
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              F,
                              M.alloc (| Ty.path "usize", α0 |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let i := M.copy (| Ty.path "usize", γ |) in
                                    M.call_closure (|
                                      F,
                                      M.get_associated_function (|
                                        Ty.apply
                                          (Ty.path
                                            "openvm_circuit::system::memory::offline::OfflineMemory")
                                          []
                                          [ F ],
                                        "get",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| self |) |)
                                        |);
                                        M.read (| address_space |);
                                        M.call_closure (|
                                          Ty.path "u32",
                                          BinOp.Wrap.add,
                                          [
                                            M.read (| pointer |);
                                            M.cast (Ty.path "u32") (M.read (| i |))
                                          ]
                                        |)
                                      ]
                                    |)))
                              ]
                            |)))
                        | _ => M.impossible "wrong number of arguments"
                        end))
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Global Instance AssociatedFunction_range_array :
          forall (F : Ty.t),
          M.IsAssociatedFunction.C (Self F) "range_array" (range_array F).
        Admitted.
        Global Typeclasses Opaque range_array.
        
        (*
            fn range_vec(&self, address_space: u32, pointer: u32, len: usize) -> Vec<F> {
                let pointer = pointer as usize;
                self.data[(address_space - self.as_offset) as usize].range_vec(pointer..pointer + len)
            }
        *)
        Definition range_vec (F : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
          let Self : Ty.t := Self F in
          match ε, τ, α with
          | [], [], [ self; address_space; pointer; len ] =>
            ltac:(M.monadic
              (let self :=
                M.alloc (|
                  Ty.apply
                    (Ty.path "&")
                    []
                    [
                      Ty.apply
                        (Ty.path "openvm_circuit::system::memory::offline::OfflineMemory")
                        []
                        [ F ]
                    ],
                  self
                |) in
              let address_space := M.alloc (| Ty.path "u32", address_space |) in
              let pointer := M.alloc (| Ty.path "u32", pointer |) in
              let len := M.alloc (| Ty.path "usize", len |) in
              M.read (|
                let~ pointer : Ty.path "usize" := M.cast (Ty.path "usize") (M.read (| pointer |)) in
                M.alloc (|
                  Ty.apply (Ty.path "alloc::vec::Vec") [] [ F; Ty.path "alloc::alloc::Global" ],
                  M.call_closure (|
                    Ty.apply (Ty.path "alloc::vec::Vec") [] [ F; Ty.path "alloc::alloc::Global" ],
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "openvm_circuit::system::memory::paged_vec::PagedVec")
                        [ Value.Integer IntegerKind.Usize 4096 ]
                        [ F ],
                      "range_vec",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "&")
                              []
                              [
                                Ty.apply
                                  (Ty.path "openvm_circuit::system::memory::paged_vec::PagedVec")
                                  [ Value.Integer IntegerKind.Usize 4096 ]
                                  [ F ]
                              ],
                            M.get_trait_method (|
                              "core::ops::index::Index",
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "openvm_circuit::system::memory::paged_vec::PagedVec")
                                    [ Value.Integer IntegerKind.Usize 4096 ]
                                    [ F ];
                                  Ty.path "alloc::alloc::Global"
                                ],
                              [],
                              [ Ty.path "usize" ],
                              "index",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "openvm_circuit::system::memory::offline::OfflineMemory",
                                  "data"
                                |)
                              |);
                              M.cast
                                (Ty.path "usize")
                                (M.call_closure (|
                                  Ty.path "u32",
                                  BinOp.Wrap.sub,
                                  [
                                    M.read (| address_space |);
                                    M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        M.deref (| M.read (| self |) |),
                                        "openvm_circuit::system::memory::offline::OfflineMemory",
                                        "as_offset"
                                      |)
                                    |)
                                  ]
                                |))
                            ]
                          |)
                        |)
                      |);
                      Value.mkStructRecord
                        "core::ops::range::Range"
                        []
                        [ Ty.path "usize" ]
                        [
                          ("start", M.read (| pointer |));
                          ("end_",
                            M.call_closure (|
                              Ty.path "usize",
                              BinOp.Wrap.add,
                              [ M.read (| pointer |); M.read (| len |) ]
                            |))
                        ]
                    ]
                  |)
                |)
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Global Instance AssociatedFunction_range_vec :
          forall (F : Ty.t),
          M.IsAssociatedFunction.C (Self F) "range_vec" (range_vec F).
        Admitted.
        Global Typeclasses Opaque range_vec.
        
        (*
            pub fn aux_cols_factory(&self) -> MemoryAuxColsFactory<F> {
                let range_bus = self.range_checker.bus();
                MemoryAuxColsFactory {
                    range_checker: self.range_checker.clone(),
                    timestamp_lt_air: AssertLtSubAir::new(range_bus, self.timestamp_max_bits),
                    _marker: Default::default(),
                }
            }
        *)
        Definition aux_cols_factory
            (F : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self F in
          match ε, τ, α with
          | [], [], [ self ] =>
            ltac:(M.monadic
              (let self :=
                M.alloc (|
                  Ty.apply
                    (Ty.path "&")
                    []
                    [
                      Ty.apply
                        (Ty.path "openvm_circuit::system::memory::offline::OfflineMemory")
                        []
                        [ F ]
                    ],
                  self
                |) in
              M.read (|
                let~ range_bus :
                    Ty.path "openvm_circuit_primitives::var_range::bus::VariableRangeCheckerBus" :=
                  M.call_closure (|
                    Ty.path "openvm_circuit_primitives::var_range::bus::VariableRangeCheckerBus",
                    M.get_associated_function (|
                      Ty.path
                        "openvm_circuit_primitives::var_range::SharedVariableRangeCheckerChip",
                      "bus",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "openvm_circuit::system::memory::offline::OfflineMemory",
                          "range_checker"
                        |)
                      |)
                    ]
                  |) in
                M.alloc (|
                  Ty.apply
                    (Ty.path "openvm_circuit::system::memory::controller::MemoryAuxColsFactory")
                    []
                    [ F ],
                  Value.mkStructRecord
                    "openvm_circuit::system::memory::controller::MemoryAuxColsFactory"
                    []
                    [ F ]
                    [
                      ("range_checker",
                        M.call_closure (|
                          Ty.path
                            "openvm_circuit_primitives::var_range::SharedVariableRangeCheckerChip",
                          M.get_trait_method (|
                            "core::clone::Clone",
                            Ty.path
                              "openvm_circuit_primitives::var_range::SharedVariableRangeCheckerChip",
                            [],
                            [],
                            "clone",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "openvm_circuit::system::memory::offline::OfflineMemory",
                                "range_checker"
                              |)
                            |)
                          ]
                        |));
                      ("timestamp_lt_air",
                        M.call_closure (|
                          Ty.path "openvm_circuit_primitives::assert_less_than::AssertLtSubAir",
                          M.get_associated_function (|
                            Ty.path "openvm_circuit_primitives::assert_less_than::AssertLtSubAir",
                            "new",
                            [],
                            []
                          |),
                          [
                            M.read (| range_bus |);
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "openvm_circuit::system::memory::offline::OfflineMemory",
                                "timestamp_max_bits"
                              |)
                            |)
                          ]
                        |));
                      ("_marker",
                        M.call_closure (|
                          Ty.apply (Ty.path "core::marker::PhantomData") [] [ F ],
                          M.get_trait_method (|
                            "core::default::Default",
                            Ty.apply (Ty.path "core::marker::PhantomData") [] [ F ],
                            [],
                            [],
                            "default",
                            [],
                            []
                          |),
                          []
                        |))
                    ]
                |)
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Global Instance AssociatedFunction_aux_cols_factory :
          forall (F : Ty.t),
          M.IsAssociatedFunction.C (Self F) "aux_cols_factory" (aux_cols_factory F).
        Admitted.
        Global Typeclasses Opaque aux_cols_factory.
      End Impl_openvm_circuit_system_memory_offline_OfflineMemory_F.
    End offline.
  End memory.
End system.
