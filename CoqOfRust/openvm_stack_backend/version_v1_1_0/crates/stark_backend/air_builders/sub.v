(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module air_builders.
  Module sub.
    (* StructRecord
      {
        name := "SubMatrixRowSlices";
        const_params := [];
        ty_params := [ "M_"; "T" ];
        fields :=
          [
            ("inner", M_);
            ("column_range", Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ]);
            ("_phantom", Ty.apply (Ty.path "core::marker::PhantomData") [] [ T ])
          ];
      } *)
    
    Module Impl_openvm_stark_backend_air_builders_sub_SubMatrixRowSlices_M__T.
      Definition Self (M_ T : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "openvm_stark_backend::air_builders::sub::SubMatrixRowSlices")
          []
          [ M_; T ].
      
      (*
          pub const fn new(inner: M, column_range: Range<usize>) -> Self {
              Self {
                  inner,
                  column_range,
                  _phantom: std::marker::PhantomData,
              }
          }
      *)
      Definition new (M_ T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self M_ T in
        match ε, τ, α with
        | [], [], [ inner; column_range ] =>
          ltac:(M.monadic
            (let inner := M.alloc (| M_, inner |) in
            let column_range :=
              M.alloc (|
                Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                column_range
              |) in
            Value.mkStructRecord
              "openvm_stark_backend::air_builders::sub::SubMatrixRowSlices"
              []
              [ M_; T ]
              [
                ("inner", M.read (| inner |));
                ("column_range", M.read (| column_range |));
                ("_phantom", Value.StructTuple "core::marker::PhantomData" [] [ T ] [])
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_new :
        forall (M_ T : Ty.t),
        M.IsAssociatedFunction.C (Self M_ T) "new" (new M_ T).
      Admitted.
      Global Typeclasses Opaque new.
    End Impl_openvm_stark_backend_air_builders_sub_SubMatrixRowSlices_M__T.
    
    Module Impl_p3_matrix_Matrix_where_p3_matrix_Matrix_M__T_where_core_marker_Send_T_where_core_marker_Sync_T_T_for_openvm_stark_backend_air_builders_sub_SubMatrixRowSlices_M__T.
      Definition Self (M_ T : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "openvm_stark_backend::air_builders::sub::SubMatrixRowSlices")
          []
          [ M_; T ].
      
      (*
          type Row<'a>
              = Skip<Take<M::Row<'a>>>
          where
              Self: 'a;
      *)
      Definition _Row (M_ T : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "core::iter::adapters::skip::Skip")
          []
          [
            Ty.apply
              (Ty.path "core::iter::adapters::take::Take")
              []
              [ Ty.associated_in_trait "p3_matrix::Matrix" [] [ T ] M_ "Row" ]
          ].
      
      (*
          fn row(&self, r: usize) -> Self::Row<'_> {
              self.inner
                  .row(r)
                  .take(self.column_range.end)
                  .skip(self.column_range.start)
          }
      *)
      Definition row (M_ T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self M_ T in
        match ε, τ, α with
        | [], [], [ self; r ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path "openvm_stark_backend::air_builders::sub::SubMatrixRowSlices")
                      []
                      [ M_; T ]
                  ],
                self
              |) in
            let r := M.alloc (| Ty.path "usize", r |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::iter::adapters::skip::Skip")
                []
                [
                  Ty.apply
                    (Ty.path "core::iter::adapters::take::Take")
                    []
                    [ Ty.associated_in_trait "p3_matrix::Matrix" [] [ T ] M_ "Row" ]
                ],
              M.get_trait_method (|
                "core::iter::traits::iterator::Iterator",
                Ty.apply
                  (Ty.path "core::iter::adapters::take::Take")
                  []
                  [ Ty.associated_in_trait "p3_matrix::Matrix" [] [ T ] M_ "Row" ],
                [],
                [],
                "skip",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::iter::adapters::take::Take")
                    []
                    [ Ty.associated_in_trait "p3_matrix::Matrix" [] [ T ] M_ "Row" ],
                  M.get_trait_method (|
                    "core::iter::traits::iterator::Iterator",
                    Ty.associated_in_trait "p3_matrix::Matrix" [] [ T ] M_ "Row",
                    [],
                    [],
                    "take",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.associated_in_trait "p3_matrix::Matrix" [] [ T ] M_ "Row",
                      M.get_trait_method (| "p3_matrix::Matrix", M_, [], [ T ], "row", [], [] |),
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "openvm_stark_backend::air_builders::sub::SubMatrixRowSlices",
                            "inner"
                          |)
                        |);
                        M.read (| r |)
                      ]
                    |);
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "openvm_stark_backend::air_builders::sub::SubMatrixRowSlices",
                          "column_range"
                        |),
                        "core::ops::range::Range",
                        "end"
                      |)
                    |)
                  ]
                |);
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "openvm_stark_backend::air_builders::sub::SubMatrixRowSlices",
                      "column_range"
                    |),
                    "core::ops::range::Range",
                    "start"
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn row_slice(&self, r: usize) -> impl Deref<Target = [T]> {
              self.row(r).collect::<Vec<_>>()
          }
      *)
      Definition row_slice
          (M_ T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self M_ T in
        match ε, τ, α with
        | [], [], [ self; r ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path "openvm_stark_backend::air_builders::sub::SubMatrixRowSlices")
                      []
                      [ M_; T ]
                  ],
                self
              |) in
            let r := M.alloc (| Ty.path "usize", r |) in
            M.call_closure (|
              Ty.apply (Ty.path "alloc::vec::Vec") [] [ T; Ty.path "alloc::alloc::Global" ],
              M.get_trait_method (|
                "core::iter::traits::iterator::Iterator",
                Ty.apply
                  (Ty.path "core::iter::adapters::skip::Skip")
                  []
                  [
                    Ty.apply
                      (Ty.path "core::iter::adapters::take::Take")
                      []
                      [ Ty.associated_in_trait "p3_matrix::Matrix" [] [ T ] M_ "Row" ]
                  ],
                [],
                [],
                "collect",
                [],
                [ Ty.apply (Ty.path "alloc::vec::Vec") [] [ T; Ty.path "alloc::alloc::Global" ] ]
              |),
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::iter::adapters::skip::Skip")
                    []
                    [
                      Ty.apply
                        (Ty.path "core::iter::adapters::take::Take")
                        []
                        [ Ty.associated_in_trait "p3_matrix::Matrix" [] [ T ] M_ "Row" ]
                    ],
                  M.get_trait_method (|
                    "p3_matrix::Matrix",
                    Ty.apply
                      (Ty.path "openvm_stark_backend::air_builders::sub::SubMatrixRowSlices")
                      []
                      [ M_; T ],
                    [],
                    [ T ],
                    "row",
                    [],
                    []
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |); M.read (| r |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn width(&self) -> usize {
              self.column_range.len()
          }
      *)
      Definition width (M_ T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self M_ T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path "openvm_stark_backend::air_builders::sub::SubMatrixRowSlices")
                      []
                      [ M_; T ]
                  ],
                self
              |) in
            M.call_closure (|
              Ty.path "usize",
              M.get_trait_method (|
                "core::iter::traits::exact_size::ExactSizeIterator",
                Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                [],
                [],
                "len",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "openvm_stark_backend::air_builders::sub::SubMatrixRowSlices",
                    "column_range"
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn height(&self) -> usize {
              self.inner.height()
          }
      *)
      Definition height (M_ T : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self M_ T in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path "openvm_stark_backend::air_builders::sub::SubMatrixRowSlices")
                      []
                      [ M_; T ]
                  ],
                self
              |) in
            M.call_closure (|
              Ty.path "usize",
              M.get_trait_method (| "p3_matrix::Matrix", M_, [], [ T ], "height", [], [] |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "openvm_stark_backend::air_builders::sub::SubMatrixRowSlices",
                    "inner"
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (M_ T : Ty.t),
        M.IsTraitInstance
          "p3_matrix::Matrix"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ T ]
          (Self M_ T)
          (* Instance *)
          [
            ("Row", InstanceField.Ty (_Row M_ T));
            ("row", InstanceField.Method (row M_ T));
            ("row_slice", InstanceField.Method (row_slice M_ T));
            ("width", InstanceField.Method (width M_ T));
            ("height", InstanceField.Method (height M_ T))
          ].
    End Impl_p3_matrix_Matrix_where_p3_matrix_Matrix_M__T_where_core_marker_Send_T_where_core_marker_Sync_T_T_for_openvm_stark_backend_air_builders_sub_SubMatrixRowSlices_M__T.
    
    (* StructRecord
      {
        name := "SubAirBuilder";
        const_params := [];
        ty_params := [ "AB"; "SubAir"; "T" ];
        fields :=
          [
            ("inner", Ty.apply (Ty.path "&mut") [] [ AB ]);
            ("column_range", Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ]);
            ("_phantom",
              Ty.apply (Ty.path "core::marker::PhantomData") [] [ Ty.tuple [ SubAir; T ] ])
          ];
      } *)
    
    Module Impl_openvm_stark_backend_air_builders_sub_SubAirBuilder_AB_SubAir_T.
      Definition Self (AB SubAir T : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "openvm_stark_backend::air_builders::sub::SubAirBuilder")
          []
          [ AB; SubAir; T ].
      
      (*
          pub fn new(inner: &'a mut AB, column_range: Range<usize>) -> Self {
              Self {
                  inner,
                  column_range,
                  _phantom: std::marker::PhantomData,
              }
          }
      *)
      Definition new
          (AB SubAir T : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self AB SubAir T in
        match ε, τ, α with
        | [], [], [ inner; column_range ] =>
          ltac:(M.monadic
            (let inner := M.alloc (| Ty.apply (Ty.path "&mut") [] [ AB ], inner |) in
            let column_range :=
              M.alloc (|
                Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                column_range
              |) in
            Value.mkStructRecord
              "openvm_stark_backend::air_builders::sub::SubAirBuilder"
              []
              [ AB; SubAir; T ]
              [
                ("inner", M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| inner |) |) |));
                ("column_range", M.read (| column_range |));
                ("_phantom",
                  Value.StructTuple "core::marker::PhantomData" [] [ Ty.tuple [ SubAir; T ] ] [])
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_new :
        forall (AB SubAir T : Ty.t),
        M.IsAssociatedFunction.C (Self AB SubAir T) "new" (new AB SubAir T).
      Admitted.
      Global Typeclasses Opaque new.
    End Impl_openvm_stark_backend_air_builders_sub_SubAirBuilder_AB_SubAir_T.
    
    Module Impl_p3_air_air_AirBuilder_where_p3_air_air_AirBuilder_AB_where_p3_air_air_BaseAir_SubAir_F_for_openvm_stark_backend_air_builders_sub_SubAirBuilder_AB_SubAir_F.
      Definition Self (AB SubAir F : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "openvm_stark_backend::air_builders::sub::SubAirBuilder")
          []
          [ AB; SubAir; F ].
      
      (*     type F = AB::F; *)
      Definition _F (AB SubAir F : Ty.t) : Ty.t :=
        Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "F".
      
      (*     type Expr = AB::Expr; *)
      Definition _Expr (AB SubAir F : Ty.t) : Ty.t :=
        Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr".
      
      (*     type Var = AB::Var; *)
      Definition _Var (AB SubAir F : Ty.t) : Ty.t :=
        Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Var".
      
      (*     type M = SubMatrixRowSlices<AB::M, Self::Var>; *)
      Definition _M_ (AB SubAir F : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "openvm_stark_backend::air_builders::sub::SubMatrixRowSlices")
          []
          [
            Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "M";
            Ty.associated_in_trait
              "p3_air::air::AirBuilder"
              []
              []
              (Ty.apply
                (Ty.path "openvm_stark_backend::air_builders::sub::SubAirBuilder")
                []
                [ AB; SubAir; F ])
              "Var"
          ].
      
      (*
          fn main(&self) -> Self::M {
              let matrix = self.inner.main();
      
              SubMatrixRowSlices::new(matrix, self.column_range.clone())
          }
      *)
      Definition main
          (AB SubAir F : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self AB SubAir F in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path "openvm_stark_backend::air_builders::sub::SubAirBuilder")
                      []
                      [ AB; SubAir; F ]
                  ],
                self
              |) in
            M.read (|
              let~ matrix : Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "M" :=
                M.call_closure (|
                  Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "M",
                  M.get_trait_method (| "p3_air::air::AirBuilder", AB, [], [], "main", [], [] |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "openvm_stark_backend::air_builders::sub::SubAirBuilder",
                            "inner"
                          |)
                        |)
                      |)
                    |)
                  ]
                |) in
              M.alloc (|
                Ty.apply
                  (Ty.path "openvm_stark_backend::air_builders::sub::SubMatrixRowSlices")
                  []
                  [
                    Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "M";
                    Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Var"
                  ],
                M.call_closure (|
                  Ty.apply
                    (Ty.path "openvm_stark_backend::air_builders::sub::SubMatrixRowSlices")
                    []
                    [
                      Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "M";
                      Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Var"
                    ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "openvm_stark_backend::air_builders::sub::SubMatrixRowSlices")
                      []
                      [
                        Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "M";
                        Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Var"
                      ],
                    "new",
                    [],
                    []
                  |),
                  [
                    M.read (| matrix |);
                    M.call_closure (|
                      Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                      M.get_trait_method (|
                        "core::clone::Clone",
                        Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                        [],
                        [],
                        "clone",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "openvm_stark_backend::air_builders::sub::SubAirBuilder",
                            "column_range"
                          |)
                        |)
                      ]
                    |)
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn is_first_row(&self) -> Self::Expr {
              self.inner.is_first_row()
          }
      *)
      Definition is_first_row
          (AB SubAir F : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self AB SubAir F in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path "openvm_stark_backend::air_builders::sub::SubAirBuilder")
                      []
                      [ AB; SubAir; F ]
                  ],
                self
              |) in
            M.call_closure (|
              Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr",
              M.get_trait_method (|
                "p3_air::air::AirBuilder",
                AB,
                [],
                [],
                "is_first_row",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "openvm_stark_backend::air_builders::sub::SubAirBuilder",
                        "inner"
                      |)
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn is_last_row(&self) -> Self::Expr {
              self.inner.is_last_row()
          }
      *)
      Definition is_last_row
          (AB SubAir F : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self AB SubAir F in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path "openvm_stark_backend::air_builders::sub::SubAirBuilder")
                      []
                      [ AB; SubAir; F ]
                  ],
                self
              |) in
            M.call_closure (|
              Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr",
              M.get_trait_method (| "p3_air::air::AirBuilder", AB, [], [], "is_last_row", [], [] |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "openvm_stark_backend::air_builders::sub::SubAirBuilder",
                        "inner"
                      |)
                    |)
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn is_transition_window(&self, size: usize) -> Self::Expr {
              self.inner.is_transition_window(size)
          }
      *)
      Definition is_transition_window
          (AB SubAir F : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self AB SubAir F in
        match ε, τ, α with
        | [], [], [ self; size ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path "openvm_stark_backend::air_builders::sub::SubAirBuilder")
                      []
                      [ AB; SubAir; F ]
                  ],
                self
              |) in
            let size := M.alloc (| Ty.path "usize", size |) in
            M.call_closure (|
              Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr",
              M.get_trait_method (|
                "p3_air::air::AirBuilder",
                AB,
                [],
                [],
                "is_transition_window",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "openvm_stark_backend::air_builders::sub::SubAirBuilder",
                        "inner"
                      |)
                    |)
                  |)
                |);
                M.read (| size |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn assert_zero<I: Into<Self::Expr>>(&mut self, x: I) {
              self.inner.assert_zero(x.into());
          }
      *)
      Definition assert_zero
          (AB SubAir F : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self AB SubAir F in
        match ε, τ, α with
        | [], [ _ as I ], [ self; x ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&mut")
                  []
                  [
                    Ty.apply
                      (Ty.path "openvm_stark_backend::air_builders::sub::SubAirBuilder")
                      []
                      [ AB; SubAir; F ]
                  ],
                self
              |) in
            let x := M.alloc (| I, x |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "p3_air::air::AirBuilder",
                    AB,
                    [],
                    [],
                    "assert_zero",
                    [],
                    [ Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr" ]
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.deref (|
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "openvm_stark_backend::air_builders::sub::SubAirBuilder",
                            "inner"
                          |)
                        |)
                      |)
                    |);
                    M.call_closure (|
                      Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr",
                      M.get_trait_method (|
                        "core::convert::Into",
                        I,
                        [],
                        [ Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr" ],
                        "into",
                        [],
                        []
                      |),
                      [ M.read (| x |) ]
                    |)
                  ]
                |) in
              M.alloc (| Ty.tuple [], Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (AB SubAir F : Ty.t),
        M.IsTraitInstance
          "p3_air::air::AirBuilder"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self AB SubAir F)
          (* Instance *)
          [
            ("F", InstanceField.Ty (_F AB SubAir F));
            ("Expr", InstanceField.Ty (_Expr AB SubAir F));
            ("Var", InstanceField.Ty (_Var AB SubAir F));
            ("M_", InstanceField.Ty (_M_ AB SubAir F));
            ("main", InstanceField.Method (main AB SubAir F));
            ("is_first_row", InstanceField.Method (is_first_row AB SubAir F));
            ("is_last_row", InstanceField.Method (is_last_row AB SubAir F));
            ("is_transition_window", InstanceField.Method (is_transition_window AB SubAir F));
            ("assert_zero", InstanceField.Method (assert_zero AB SubAir F))
          ].
    End Impl_p3_air_air_AirBuilder_where_p3_air_air_AirBuilder_AB_where_p3_air_air_BaseAir_SubAir_F_for_openvm_stark_backend_air_builders_sub_SubAirBuilder_AB_SubAir_F.
  End sub.
End air_builders.
