(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module chip.
  (* Trait *)
  Module Chip.
    Definition generate_air_proof_input_with_id
        (SC Self : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self; air_id ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Self, self |) in
          let air_id := M.alloc (| Ty.path "usize", air_id |) in
          Value.Tuple
            [
              M.read (| air_id |);
              M.call_closure (|
                Ty.apply (Ty.path "openvm_stark_backend::prover::types::AirProofInput") [] [ SC ],
                M.get_trait_method (|
                  "openvm_stark_backend::chip::Chip",
                  Self,
                  [],
                  [ SC ],
                  "generate_air_proof_input",
                  [],
                  []
                |),
                [ M.read (| self |) ]
              |)
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_generate_air_proof_input_with_id :
      forall (SC : Ty.t),
      M.IsProvidedMethod
        "openvm_stark_backend::chip::Chip"
        "generate_air_proof_input_with_id"
        (generate_air_proof_input_with_id SC).
  End Chip.
  
  (* Trait *)
  Module ChipUsageGetter.
    Definition constant_trace_height
        (Self : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.apply (Ty.path "&") [] [ Self ], self |) in
          Value.StructTuple "core::option::Option::None" [] [ Ty.path "usize" ] []))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_constant_trace_height :
      M.IsProvidedMethod
        "openvm_stark_backend::chip::ChipUsageGetter"
        "constant_trace_height"
        constant_trace_height.
    Definition current_trace_cells
        (Self : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.apply (Ty.path "&") [] [ Self ], self |) in
          M.call_closure (|
            Ty.path "usize",
            BinOp.Wrap.mul,
            [
              M.call_closure (|
                Ty.path "usize",
                M.get_trait_method (|
                  "openvm_stark_backend::chip::ChipUsageGetter",
                  Self,
                  [],
                  [],
                  "trace_width",
                  [],
                  []
                |),
                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
              |);
              M.call_closure (|
                Ty.path "usize",
                M.get_trait_method (|
                  "openvm_stark_backend::chip::ChipUsageGetter",
                  Self,
                  [],
                  [],
                  "current_trace_height",
                  [],
                  []
                |),
                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_current_trace_cells :
      M.IsProvidedMethod
        "openvm_stark_backend::chip::ChipUsageGetter"
        "current_trace_cells"
        current_trace_cells.
  End ChipUsageGetter.
  
  Module Impl_openvm_stark_backend_chip_Chip_where_openvm_stark_backend_config_StarkGenericConfig_SC_where_openvm_stark_backend_chip_Chip_C_SC_SC_for_core_cell_RefCell_C.
    Definition Self (SC C : Ty.t) : Ty.t := Ty.apply (Ty.path "core::cell::RefCell") [] [ C ].
    
    (*
        fn air(&self) -> Arc<dyn AnyRap<SC>> {
            self.borrow().air()
        }
    *)
    Definition air (SC C : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self SC C in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "core::cell::RefCell") [] [ C ] ],
              self
            |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "alloc::sync::Arc")
              []
              [
                Ty.dyn [ ("openvm_stark_backend::rap::AnyRap::Trait", []) ];
                Ty.path "alloc::alloc::Global"
              ],
            M.pointer_coercion
              M.PointerCoercion.Unsize
              (Ty.apply
                (Ty.path "alloc::sync::Arc")
                []
                [
                  Ty.dyn [ ("openvm_stark_backend::rap::AnyRap::Trait", []) ];
                  Ty.path "alloc::alloc::Global"
                ])
              (Ty.apply
                (Ty.path "alloc::sync::Arc")
                []
                [
                  Ty.dyn [ ("openvm_stark_backend::rap::AnyRap::Trait", []) ];
                  Ty.path "alloc::alloc::Global"
                ]),
            [
              M.call_closure (|
                Ty.apply
                  (Ty.path "alloc::sync::Arc")
                  []
                  [
                    Ty.dyn [ ("openvm_stark_backend::rap::AnyRap::Trait", []) ];
                    Ty.path "alloc::alloc::Global"
                  ],
                M.pointer_coercion
                  M.PointerCoercion.Unsize
                  (Ty.apply
                    (Ty.path "alloc::sync::Arc")
                    []
                    [
                      Ty.dyn [ ("openvm_stark_backend::rap::AnyRap::Trait", []) ];
                      Ty.path "alloc::alloc::Global"
                    ])
                  (Ty.apply
                    (Ty.path "alloc::sync::Arc")
                    []
                    [
                      Ty.dyn [ ("openvm_stark_backend::rap::AnyRap::Trait", []) ];
                      Ty.path "alloc::alloc::Global"
                    ]),
                [
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "alloc::sync::Arc")
                      []
                      [
                        Ty.dyn [ ("openvm_stark_backend::rap::AnyRap::Trait", []) ];
                        Ty.path "alloc::alloc::Global"
                      ],
                    M.get_trait_method (|
                      "openvm_stark_backend::chip::Chip",
                      C,
                      [],
                      [ SC ],
                      "air",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.call_closure (|
                            Ty.apply (Ty.path "&") [] [ C ],
                            M.get_trait_method (|
                              "core::ops::deref::Deref",
                              Ty.apply (Ty.path "core::cell::Ref") [] [ C ],
                              [],
                              [],
                              "deref",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.alloc (|
                                  Ty.apply (Ty.path "core::cell::Ref") [] [ C ],
                                  M.call_closure (|
                                    Ty.apply (Ty.path "core::cell::Ref") [] [ C ],
                                    M.get_associated_function (|
                                      Ty.apply (Ty.path "core::cell::RefCell") [] [ C ],
                                      "borrow",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (| M.read (| self |) |)
                                      |)
                                    ]
                                  |)
                                |)
                              |)
                            ]
                          |)
                        |)
                      |)
                    ]
                  |)
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn generate_air_proof_input(self) -> AirProofInput<SC> {
            self.into_inner().generate_air_proof_input()
        }
    *)
    Definition generate_air_proof_input
        (SC C : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self SC C in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.apply (Ty.path "core::cell::RefCell") [] [ C ], self |) in
          M.call_closure (|
            Ty.apply (Ty.path "openvm_stark_backend::prover::types::AirProofInput") [] [ SC ],
            M.get_trait_method (|
              "openvm_stark_backend::chip::Chip",
              C,
              [],
              [ SC ],
              "generate_air_proof_input",
              [],
              []
            |),
            [
              M.call_closure (|
                C,
                M.get_associated_function (|
                  Ty.apply (Ty.path "core::cell::RefCell") [] [ C ],
                  "into_inner",
                  [],
                  []
                |),
                [ M.read (| self |) ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (SC C : Ty.t),
      M.IsTraitInstance
        "openvm_stark_backend::chip::Chip"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ SC ]
        (Self SC C)
        (* Instance *)
        [
          ("air", InstanceField.Method (air SC C));
          ("generate_air_proof_input", InstanceField.Method (generate_air_proof_input SC C))
        ].
  End Impl_openvm_stark_backend_chip_Chip_where_openvm_stark_backend_config_StarkGenericConfig_SC_where_openvm_stark_backend_chip_Chip_C_SC_SC_for_core_cell_RefCell_C.
  
  Module Impl_openvm_stark_backend_chip_Chip_where_openvm_stark_backend_config_StarkGenericConfig_SC_where_openvm_stark_backend_chip_Chip_C_SC_SC_for_alloc_rc_Rc_C_alloc_alloc_Global.
    Definition Self (SC C : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloc::rc::Rc") [] [ C; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn air(&self) -> Arc<dyn AnyRap<SC>> {
            self.as_ref().air()
        }
    *)
    Definition air (SC C : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self SC C in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply
                (Ty.path "&")
                []
                [ Ty.apply (Ty.path "alloc::rc::Rc") [] [ C; Ty.path "alloc::alloc::Global" ] ],
              self
            |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "alloc::sync::Arc")
              []
              [
                Ty.dyn [ ("openvm_stark_backend::rap::AnyRap::Trait", []) ];
                Ty.path "alloc::alloc::Global"
              ],
            M.pointer_coercion
              M.PointerCoercion.Unsize
              (Ty.apply
                (Ty.path "alloc::sync::Arc")
                []
                [
                  Ty.dyn [ ("openvm_stark_backend::rap::AnyRap::Trait", []) ];
                  Ty.path "alloc::alloc::Global"
                ])
              (Ty.apply
                (Ty.path "alloc::sync::Arc")
                []
                [
                  Ty.dyn [ ("openvm_stark_backend::rap::AnyRap::Trait", []) ];
                  Ty.path "alloc::alloc::Global"
                ]),
            [
              M.call_closure (|
                Ty.apply
                  (Ty.path "alloc::sync::Arc")
                  []
                  [
                    Ty.dyn [ ("openvm_stark_backend::rap::AnyRap::Trait", []) ];
                    Ty.path "alloc::alloc::Global"
                  ],
                M.pointer_coercion
                  M.PointerCoercion.Unsize
                  (Ty.apply
                    (Ty.path "alloc::sync::Arc")
                    []
                    [
                      Ty.dyn [ ("openvm_stark_backend::rap::AnyRap::Trait", []) ];
                      Ty.path "alloc::alloc::Global"
                    ])
                  (Ty.apply
                    (Ty.path "alloc::sync::Arc")
                    []
                    [
                      Ty.dyn [ ("openvm_stark_backend::rap::AnyRap::Trait", []) ];
                      Ty.path "alloc::alloc::Global"
                    ]),
                [
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "alloc::sync::Arc")
                      []
                      [
                        Ty.dyn [ ("openvm_stark_backend::rap::AnyRap::Trait", []) ];
                        Ty.path "alloc::alloc::Global"
                      ],
                    M.get_trait_method (|
                      "openvm_stark_backend::chip::Chip",
                      C,
                      [],
                      [ SC ],
                      "air",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.call_closure (|
                            Ty.apply (Ty.path "&") [] [ C ],
                            M.get_trait_method (|
                              "core::convert::AsRef",
                              Ty.apply
                                (Ty.path "alloc::rc::Rc")
                                []
                                [ C; Ty.path "alloc::alloc::Global" ],
                              [],
                              [ C ],
                              "as_ref",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                          |)
                        |)
                      |)
                    ]
                  |)
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn generate_air_proof_input(self) -> AirProofInput<SC> {
            if let Some(c) = Rc::into_inner(self) {
                c.generate_air_proof_input()
            } else {
                panic!("Cannot generate AirProofInput while other chips still hold a reference");
            }
        }
    *)
    Definition generate_air_proof_input
        (SC C : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self SC C in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply (Ty.path "alloc::rc::Rc") [] [ C; Ty.path "alloc::alloc::Global" ],
              self
            |) in
          M.match_operator (|
            Ty.apply (Ty.path "openvm_stark_backend::prover::types::AirProofInput") [] [ SC ],
            M.alloc (| Ty.tuple [], Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.alloc (|
                      Ty.apply (Ty.path "core::option::Option") [] [ C ],
                      M.call_closure (|
                        Ty.apply (Ty.path "core::option::Option") [] [ C ],
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::rc::Rc")
                            []
                            [ C; Ty.path "alloc::alloc::Global" ],
                          "into_inner",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    |) in
                  let γ0_0 :=
                    M.SubPointer.get_struct_tuple_field (| γ, "core::option::Option::Some", 0 |) in
                  let c := M.copy (| C, γ0_0 |) in
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "openvm_stark_backend::prover::types::AirProofInput")
                      []
                      [ SC ],
                    M.get_trait_method (|
                      "openvm_stark_backend::chip::Chip",
                      C,
                      [],
                      [ SC ],
                      "generate_air_proof_input",
                      [],
                      []
                    |),
                    [ M.read (| c |) ]
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (M.never_to_any (|
                    M.call_closure (|
                      Ty.path "never",
                      M.get_function (| "core::panicking::panic_fmt", [], [] |),
                      [
                        M.call_closure (|
                          Ty.path "core::fmt::Arguments",
                          M.get_associated_function (|
                            Ty.path "core::fmt::Arguments",
                            "new_const",
                            [ Value.Integer IntegerKind.Usize 1 ],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.alloc (|
                                    Ty.apply
                                      (Ty.path "array")
                                      [ Value.Integer IntegerKind.Usize 1 ]
                                      [ Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ],
                                    Value.Array
                                      [
                                        mk_str (|
                                          "Cannot generate AirProofInput while other chips still hold a reference"
                                        |)
                                      ]
                                  |)
                                |)
                              |)
                            |)
                          ]
                        |)
                      ]
                    |)
                  |)))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (SC C : Ty.t),
      M.IsTraitInstance
        "openvm_stark_backend::chip::Chip"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ SC ]
        (Self SC C)
        (* Instance *)
        [
          ("air", InstanceField.Method (air SC C));
          ("generate_air_proof_input", InstanceField.Method (generate_air_proof_input SC C))
        ].
  End Impl_openvm_stark_backend_chip_Chip_where_openvm_stark_backend_config_StarkGenericConfig_SC_where_openvm_stark_backend_chip_Chip_C_SC_SC_for_alloc_rc_Rc_C_alloc_alloc_Global.
  
  Module Impl_openvm_stark_backend_chip_ChipUsageGetter_where_openvm_stark_backend_chip_ChipUsageGetter_C_for_alloc_rc_Rc_C_alloc_alloc_Global.
    Definition Self (C : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloc::rc::Rc") [] [ C; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn air_name(&self) -> String {
            self.as_ref().air_name()
        }
    *)
    Definition air_name (C : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self C in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply
                (Ty.path "&")
                []
                [ Ty.apply (Ty.path "alloc::rc::Rc") [] [ C; Ty.path "alloc::alloc::Global" ] ],
              self
            |) in
          M.call_closure (|
            Ty.path "alloc::string::String",
            M.get_trait_method (|
              "openvm_stark_backend::chip::ChipUsageGetter",
              C,
              [],
              [],
              "air_name",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ C ],
                    M.get_trait_method (|
                      "core::convert::AsRef",
                      Ty.apply (Ty.path "alloc::rc::Rc") [] [ C; Ty.path "alloc::alloc::Global" ],
                      [],
                      [ C ],
                      "as_ref",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn constant_trace_height(&self) -> Option<usize> {
            self.as_ref().constant_trace_height()
        }
    *)
    Definition constant_trace_height
        (C : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self C in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply
                (Ty.path "&")
                []
                [ Ty.apply (Ty.path "alloc::rc::Rc") [] [ C; Ty.path "alloc::alloc::Global" ] ],
              self
            |) in
          M.call_closure (|
            Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
            M.get_trait_method (|
              "openvm_stark_backend::chip::ChipUsageGetter",
              C,
              [],
              [],
              "constant_trace_height",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ C ],
                    M.get_trait_method (|
                      "core::convert::AsRef",
                      Ty.apply (Ty.path "alloc::rc::Rc") [] [ C; Ty.path "alloc::alloc::Global" ],
                      [],
                      [ C ],
                      "as_ref",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn current_trace_height(&self) -> usize {
            self.as_ref().current_trace_height()
        }
    *)
    Definition current_trace_height
        (C : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self C in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply
                (Ty.path "&")
                []
                [ Ty.apply (Ty.path "alloc::rc::Rc") [] [ C; Ty.path "alloc::alloc::Global" ] ],
              self
            |) in
          M.call_closure (|
            Ty.path "usize",
            M.get_trait_method (|
              "openvm_stark_backend::chip::ChipUsageGetter",
              C,
              [],
              [],
              "current_trace_height",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ C ],
                    M.get_trait_method (|
                      "core::convert::AsRef",
                      Ty.apply (Ty.path "alloc::rc::Rc") [] [ C; Ty.path "alloc::alloc::Global" ],
                      [],
                      [ C ],
                      "as_ref",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn trace_width(&self) -> usize {
            self.as_ref().trace_width()
        }
    *)
    Definition trace_width (C : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self C in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply
                (Ty.path "&")
                []
                [ Ty.apply (Ty.path "alloc::rc::Rc") [] [ C; Ty.path "alloc::alloc::Global" ] ],
              self
            |) in
          M.call_closure (|
            Ty.path "usize",
            M.get_trait_method (|
              "openvm_stark_backend::chip::ChipUsageGetter",
              C,
              [],
              [],
              "trace_width",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ C ],
                    M.get_trait_method (|
                      "core::convert::AsRef",
                      Ty.apply (Ty.path "alloc::rc::Rc") [] [ C; Ty.path "alloc::alloc::Global" ],
                      [],
                      [ C ],
                      "as_ref",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (C : Ty.t),
      M.IsTraitInstance
        "openvm_stark_backend::chip::ChipUsageGetter"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self C)
        (* Instance *)
        [
          ("air_name", InstanceField.Method (air_name C));
          ("constant_trace_height", InstanceField.Method (constant_trace_height C));
          ("current_trace_height", InstanceField.Method (current_trace_height C));
          ("trace_width", InstanceField.Method (trace_width C))
        ].
  End Impl_openvm_stark_backend_chip_ChipUsageGetter_where_openvm_stark_backend_chip_ChipUsageGetter_C_for_alloc_rc_Rc_C_alloc_alloc_Global.
  
  Module Impl_openvm_stark_backend_chip_ChipUsageGetter_where_openvm_stark_backend_chip_ChipUsageGetter_C_for_core_cell_RefCell_C.
    Definition Self (C : Ty.t) : Ty.t := Ty.apply (Ty.path "core::cell::RefCell") [] [ C ].
    
    (*
        fn air_name(&self) -> String {
            self.borrow().air_name()
        }
    *)
    Definition air_name (C : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self C in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "core::cell::RefCell") [] [ C ] ],
              self
            |) in
          M.call_closure (|
            Ty.path "alloc::string::String",
            M.get_trait_method (|
              "openvm_stark_backend::chip::ChipUsageGetter",
              C,
              [],
              [],
              "air_name",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ C ],
                    M.get_trait_method (|
                      "core::ops::deref::Deref",
                      Ty.apply (Ty.path "core::cell::Ref") [] [ C ],
                      [],
                      [],
                      "deref",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          Ty.apply (Ty.path "core::cell::Ref") [] [ C ],
                          M.call_closure (|
                            Ty.apply (Ty.path "core::cell::Ref") [] [ C ],
                            M.get_associated_function (|
                              Ty.apply (Ty.path "core::cell::RefCell") [] [ C ],
                              "borrow",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                          |)
                        |)
                      |)
                    ]
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn constant_trace_height(&self) -> Option<usize> {
            self.borrow().constant_trace_height()
        }
    *)
    Definition constant_trace_height
        (C : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self C in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "core::cell::RefCell") [] [ C ] ],
              self
            |) in
          M.call_closure (|
            Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
            M.get_trait_method (|
              "openvm_stark_backend::chip::ChipUsageGetter",
              C,
              [],
              [],
              "constant_trace_height",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ C ],
                    M.get_trait_method (|
                      "core::ops::deref::Deref",
                      Ty.apply (Ty.path "core::cell::Ref") [] [ C ],
                      [],
                      [],
                      "deref",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          Ty.apply (Ty.path "core::cell::Ref") [] [ C ],
                          M.call_closure (|
                            Ty.apply (Ty.path "core::cell::Ref") [] [ C ],
                            M.get_associated_function (|
                              Ty.apply (Ty.path "core::cell::RefCell") [] [ C ],
                              "borrow",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                          |)
                        |)
                      |)
                    ]
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn current_trace_height(&self) -> usize {
            self.borrow().current_trace_height()
        }
    *)
    Definition current_trace_height
        (C : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self C in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "core::cell::RefCell") [] [ C ] ],
              self
            |) in
          M.call_closure (|
            Ty.path "usize",
            M.get_trait_method (|
              "openvm_stark_backend::chip::ChipUsageGetter",
              C,
              [],
              [],
              "current_trace_height",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ C ],
                    M.get_trait_method (|
                      "core::ops::deref::Deref",
                      Ty.apply (Ty.path "core::cell::Ref") [] [ C ],
                      [],
                      [],
                      "deref",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          Ty.apply (Ty.path "core::cell::Ref") [] [ C ],
                          M.call_closure (|
                            Ty.apply (Ty.path "core::cell::Ref") [] [ C ],
                            M.get_associated_function (|
                              Ty.apply (Ty.path "core::cell::RefCell") [] [ C ],
                              "borrow",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                          |)
                        |)
                      |)
                    ]
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn trace_width(&self) -> usize {
            self.borrow().trace_width()
        }
    *)
    Definition trace_width (C : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self C in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "core::cell::RefCell") [] [ C ] ],
              self
            |) in
          M.call_closure (|
            Ty.path "usize",
            M.get_trait_method (|
              "openvm_stark_backend::chip::ChipUsageGetter",
              C,
              [],
              [],
              "trace_width",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ C ],
                    M.get_trait_method (|
                      "core::ops::deref::Deref",
                      Ty.apply (Ty.path "core::cell::Ref") [] [ C ],
                      [],
                      [],
                      "deref",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          Ty.apply (Ty.path "core::cell::Ref") [] [ C ],
                          M.call_closure (|
                            Ty.apply (Ty.path "core::cell::Ref") [] [ C ],
                            M.get_associated_function (|
                              Ty.apply (Ty.path "core::cell::RefCell") [] [ C ],
                              "borrow",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                          |)
                        |)
                      |)
                    ]
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (C : Ty.t),
      M.IsTraitInstance
        "openvm_stark_backend::chip::ChipUsageGetter"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self C)
        (* Instance *)
        [
          ("air_name", InstanceField.Method (air_name C));
          ("constant_trace_height", InstanceField.Method (constant_trace_height C));
          ("current_trace_height", InstanceField.Method (current_trace_height C));
          ("trace_width", InstanceField.Method (trace_width C))
        ].
  End Impl_openvm_stark_backend_chip_ChipUsageGetter_where_openvm_stark_backend_chip_ChipUsageGetter_C_for_core_cell_RefCell_C.
  
  Module Impl_openvm_stark_backend_chip_Chip_where_openvm_stark_backend_config_StarkGenericConfig_SC_where_openvm_stark_backend_chip_Chip_C_SC_SC_for_alloc_sync_Arc_C_alloc_alloc_Global.
    Definition Self (SC C : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloc::sync::Arc") [] [ C; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn air(&self) -> Arc<dyn AnyRap<SC>> {
            self.as_ref().air()
        }
    *)
    Definition air (SC C : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self SC C in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply
                (Ty.path "&")
                []
                [ Ty.apply (Ty.path "alloc::sync::Arc") [] [ C; Ty.path "alloc::alloc::Global" ] ],
              self
            |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "alloc::sync::Arc")
              []
              [
                Ty.dyn [ ("openvm_stark_backend::rap::AnyRap::Trait", []) ];
                Ty.path "alloc::alloc::Global"
              ],
            M.pointer_coercion
              M.PointerCoercion.Unsize
              (Ty.apply
                (Ty.path "alloc::sync::Arc")
                []
                [
                  Ty.dyn [ ("openvm_stark_backend::rap::AnyRap::Trait", []) ];
                  Ty.path "alloc::alloc::Global"
                ])
              (Ty.apply
                (Ty.path "alloc::sync::Arc")
                []
                [
                  Ty.dyn [ ("openvm_stark_backend::rap::AnyRap::Trait", []) ];
                  Ty.path "alloc::alloc::Global"
                ]),
            [
              M.call_closure (|
                Ty.apply
                  (Ty.path "alloc::sync::Arc")
                  []
                  [
                    Ty.dyn [ ("openvm_stark_backend::rap::AnyRap::Trait", []) ];
                    Ty.path "alloc::alloc::Global"
                  ],
                M.pointer_coercion
                  M.PointerCoercion.Unsize
                  (Ty.apply
                    (Ty.path "alloc::sync::Arc")
                    []
                    [
                      Ty.dyn [ ("openvm_stark_backend::rap::AnyRap::Trait", []) ];
                      Ty.path "alloc::alloc::Global"
                    ])
                  (Ty.apply
                    (Ty.path "alloc::sync::Arc")
                    []
                    [
                      Ty.dyn [ ("openvm_stark_backend::rap::AnyRap::Trait", []) ];
                      Ty.path "alloc::alloc::Global"
                    ]),
                [
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "alloc::sync::Arc")
                      []
                      [
                        Ty.dyn [ ("openvm_stark_backend::rap::AnyRap::Trait", []) ];
                        Ty.path "alloc::alloc::Global"
                      ],
                    M.get_trait_method (|
                      "openvm_stark_backend::chip::Chip",
                      C,
                      [],
                      [ SC ],
                      "air",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.call_closure (|
                            Ty.apply (Ty.path "&") [] [ C ],
                            M.get_trait_method (|
                              "core::convert::AsRef",
                              Ty.apply
                                (Ty.path "alloc::sync::Arc")
                                []
                                [ C; Ty.path "alloc::alloc::Global" ],
                              [],
                              [ C ],
                              "as_ref",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                          |)
                        |)
                      |)
                    ]
                  |)
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn generate_air_proof_input(self) -> AirProofInput<SC> {
            if let Some(c) = Arc::into_inner(self) {
                c.generate_air_proof_input()
            } else {
                panic!("Cannot generate AirProofInput while other chips still hold a reference");
            }
        }
    *)
    Definition generate_air_proof_input
        (SC C : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self SC C in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply (Ty.path "alloc::sync::Arc") [] [ C; Ty.path "alloc::alloc::Global" ],
              self
            |) in
          M.match_operator (|
            Ty.apply (Ty.path "openvm_stark_backend::prover::types::AirProofInput") [] [ SC ],
            M.alloc (| Ty.tuple [], Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.alloc (|
                      Ty.apply (Ty.path "core::option::Option") [] [ C ],
                      M.call_closure (|
                        Ty.apply (Ty.path "core::option::Option") [] [ C ],
                        M.get_associated_function (|
                          Ty.apply
                            (Ty.path "alloc::sync::Arc")
                            []
                            [ C; Ty.path "alloc::alloc::Global" ],
                          "into_inner",
                          [],
                          []
                        |),
                        [ M.read (| self |) ]
                      |)
                    |) in
                  let γ0_0 :=
                    M.SubPointer.get_struct_tuple_field (| γ, "core::option::Option::Some", 0 |) in
                  let c := M.copy (| C, γ0_0 |) in
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "openvm_stark_backend::prover::types::AirProofInput")
                      []
                      [ SC ],
                    M.get_trait_method (|
                      "openvm_stark_backend::chip::Chip",
                      C,
                      [],
                      [ SC ],
                      "generate_air_proof_input",
                      [],
                      []
                    |),
                    [ M.read (| c |) ]
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (M.never_to_any (|
                    M.call_closure (|
                      Ty.path "never",
                      M.get_function (| "core::panicking::panic_fmt", [], [] |),
                      [
                        M.call_closure (|
                          Ty.path "core::fmt::Arguments",
                          M.get_associated_function (|
                            Ty.path "core::fmt::Arguments",
                            "new_const",
                            [ Value.Integer IntegerKind.Usize 1 ],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.alloc (|
                                    Ty.apply
                                      (Ty.path "array")
                                      [ Value.Integer IntegerKind.Usize 1 ]
                                      [ Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ],
                                    Value.Array
                                      [
                                        mk_str (|
                                          "Cannot generate AirProofInput while other chips still hold a reference"
                                        |)
                                      ]
                                  |)
                                |)
                              |)
                            |)
                          ]
                        |)
                      ]
                    |)
                  |)))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (SC C : Ty.t),
      M.IsTraitInstance
        "openvm_stark_backend::chip::Chip"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ SC ]
        (Self SC C)
        (* Instance *)
        [
          ("air", InstanceField.Method (air SC C));
          ("generate_air_proof_input", InstanceField.Method (generate_air_proof_input SC C))
        ].
  End Impl_openvm_stark_backend_chip_Chip_where_openvm_stark_backend_config_StarkGenericConfig_SC_where_openvm_stark_backend_chip_Chip_C_SC_SC_for_alloc_sync_Arc_C_alloc_alloc_Global.
  
  Module Impl_openvm_stark_backend_chip_ChipUsageGetter_where_openvm_stark_backend_chip_ChipUsageGetter_C_for_alloc_sync_Arc_C_alloc_alloc_Global.
    Definition Self (C : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "alloc::sync::Arc") [] [ C; Ty.path "alloc::alloc::Global" ].
    
    (*
        fn air_name(&self) -> String {
            self.as_ref().air_name()
        }
    *)
    Definition air_name (C : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self C in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply
                (Ty.path "&")
                []
                [ Ty.apply (Ty.path "alloc::sync::Arc") [] [ C; Ty.path "alloc::alloc::Global" ] ],
              self
            |) in
          M.call_closure (|
            Ty.path "alloc::string::String",
            M.get_trait_method (|
              "openvm_stark_backend::chip::ChipUsageGetter",
              C,
              [],
              [],
              "air_name",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ C ],
                    M.get_trait_method (|
                      "core::convert::AsRef",
                      Ty.apply
                        (Ty.path "alloc::sync::Arc")
                        []
                        [ C; Ty.path "alloc::alloc::Global" ],
                      [],
                      [ C ],
                      "as_ref",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn constant_trace_height(&self) -> Option<usize> {
            self.as_ref().constant_trace_height()
        }
    *)
    Definition constant_trace_height
        (C : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self C in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply
                (Ty.path "&")
                []
                [ Ty.apply (Ty.path "alloc::sync::Arc") [] [ C; Ty.path "alloc::alloc::Global" ] ],
              self
            |) in
          M.call_closure (|
            Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
            M.get_trait_method (|
              "openvm_stark_backend::chip::ChipUsageGetter",
              C,
              [],
              [],
              "constant_trace_height",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ C ],
                    M.get_trait_method (|
                      "core::convert::AsRef",
                      Ty.apply
                        (Ty.path "alloc::sync::Arc")
                        []
                        [ C; Ty.path "alloc::alloc::Global" ],
                      [],
                      [ C ],
                      "as_ref",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn current_trace_height(&self) -> usize {
            self.as_ref().current_trace_height()
        }
    *)
    Definition current_trace_height
        (C : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self C in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply
                (Ty.path "&")
                []
                [ Ty.apply (Ty.path "alloc::sync::Arc") [] [ C; Ty.path "alloc::alloc::Global" ] ],
              self
            |) in
          M.call_closure (|
            Ty.path "usize",
            M.get_trait_method (|
              "openvm_stark_backend::chip::ChipUsageGetter",
              C,
              [],
              [],
              "current_trace_height",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ C ],
                    M.get_trait_method (|
                      "core::convert::AsRef",
                      Ty.apply
                        (Ty.path "alloc::sync::Arc")
                        []
                        [ C; Ty.path "alloc::alloc::Global" ],
                      [],
                      [ C ],
                      "as_ref",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn trace_width(&self) -> usize {
            self.as_ref().trace_width()
        }
    *)
    Definition trace_width (C : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self C in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply
                (Ty.path "&")
                []
                [ Ty.apply (Ty.path "alloc::sync::Arc") [] [ C; Ty.path "alloc::alloc::Global" ] ],
              self
            |) in
          M.call_closure (|
            Ty.path "usize",
            M.get_trait_method (|
              "openvm_stark_backend::chip::ChipUsageGetter",
              C,
              [],
              [],
              "trace_width",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ C ],
                    M.get_trait_method (|
                      "core::convert::AsRef",
                      Ty.apply
                        (Ty.path "alloc::sync::Arc")
                        []
                        [ C; Ty.path "alloc::alloc::Global" ],
                      [],
                      [ C ],
                      "as_ref",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (C : Ty.t),
      M.IsTraitInstance
        "openvm_stark_backend::chip::ChipUsageGetter"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self C)
        (* Instance *)
        [
          ("air_name", InstanceField.Method (air_name C));
          ("constant_trace_height", InstanceField.Method (constant_trace_height C));
          ("current_trace_height", InstanceField.Method (current_trace_height C));
          ("trace_width", InstanceField.Method (trace_width C))
        ].
  End Impl_openvm_stark_backend_chip_ChipUsageGetter_where_openvm_stark_backend_chip_ChipUsageGetter_C_for_alloc_sync_Arc_C_alloc_alloc_Global.
  
  Module Impl_openvm_stark_backend_chip_Chip_where_openvm_stark_backend_config_StarkGenericConfig_SC_where_openvm_stark_backend_chip_Chip_C_SC_SC_for_std_sync_mutex_Mutex_C.
    Definition Self (SC C : Ty.t) : Ty.t := Ty.apply (Ty.path "std::sync::mutex::Mutex") [] [ C ].
    
    (*
        fn air(&self) -> Arc<dyn AnyRap<SC>> {
            self.lock().unwrap().air()
        }
    *)
    Definition air (SC C : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self SC C in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "std::sync::mutex::Mutex") [] [ C ] ],
              self
            |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "alloc::sync::Arc")
              []
              [
                Ty.dyn [ ("openvm_stark_backend::rap::AnyRap::Trait", []) ];
                Ty.path "alloc::alloc::Global"
              ],
            M.pointer_coercion
              M.PointerCoercion.Unsize
              (Ty.apply
                (Ty.path "alloc::sync::Arc")
                []
                [
                  Ty.dyn [ ("openvm_stark_backend::rap::AnyRap::Trait", []) ];
                  Ty.path "alloc::alloc::Global"
                ])
              (Ty.apply
                (Ty.path "alloc::sync::Arc")
                []
                [
                  Ty.dyn [ ("openvm_stark_backend::rap::AnyRap::Trait", []) ];
                  Ty.path "alloc::alloc::Global"
                ]),
            [
              M.call_closure (|
                Ty.apply
                  (Ty.path "alloc::sync::Arc")
                  []
                  [
                    Ty.dyn [ ("openvm_stark_backend::rap::AnyRap::Trait", []) ];
                    Ty.path "alloc::alloc::Global"
                  ],
                M.pointer_coercion
                  M.PointerCoercion.Unsize
                  (Ty.apply
                    (Ty.path "alloc::sync::Arc")
                    []
                    [
                      Ty.dyn [ ("openvm_stark_backend::rap::AnyRap::Trait", []) ];
                      Ty.path "alloc::alloc::Global"
                    ])
                  (Ty.apply
                    (Ty.path "alloc::sync::Arc")
                    []
                    [
                      Ty.dyn [ ("openvm_stark_backend::rap::AnyRap::Trait", []) ];
                      Ty.path "alloc::alloc::Global"
                    ]),
                [
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "alloc::sync::Arc")
                      []
                      [
                        Ty.dyn [ ("openvm_stark_backend::rap::AnyRap::Trait", []) ];
                        Ty.path "alloc::alloc::Global"
                      ],
                    M.get_trait_method (|
                      "openvm_stark_backend::chip::Chip",
                      C,
                      [],
                      [ SC ],
                      "air",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.call_closure (|
                            Ty.apply (Ty.path "&") [] [ C ],
                            M.get_trait_method (|
                              "core::ops::deref::Deref",
                              Ty.apply (Ty.path "std::sync::mutex::MutexGuard") [] [ C ],
                              [],
                              [],
                              "deref",
                              [],
                              []
                            |),
                            [
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.alloc (|
                                  Ty.apply (Ty.path "std::sync::mutex::MutexGuard") [] [ C ],
                                  M.call_closure (|
                                    Ty.apply (Ty.path "std::sync::mutex::MutexGuard") [] [ C ],
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "std::sync::mutex::MutexGuard")
                                            []
                                            [ C ];
                                          Ty.apply
                                            (Ty.path "std::sync::poison::PoisonError")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "std::sync::mutex::MutexGuard")
                                                []
                                                [ C ]
                                            ]
                                        ],
                                      "unwrap",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "std::sync::mutex::MutexGuard")
                                              []
                                              [ C ];
                                            Ty.apply
                                              (Ty.path "std::sync::poison::PoisonError")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "std::sync::mutex::MutexGuard")
                                                  []
                                                  [ C ]
                                              ]
                                          ],
                                        M.get_associated_function (|
                                          Ty.apply (Ty.path "std::sync::mutex::Mutex") [] [ C ],
                                          "lock",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (| M.read (| self |) |)
                                          |)
                                        ]
                                      |)
                                    ]
                                  |)
                                |)
                              |)
                            ]
                          |)
                        |)
                      |)
                    ]
                  |)
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn generate_air_proof_input(self) -> AirProofInput<SC> {
            self.into_inner().unwrap().generate_air_proof_input()
        }
    *)
    Definition generate_air_proof_input
        (SC C : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self SC C in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| Ty.apply (Ty.path "std::sync::mutex::Mutex") [] [ C ], self |) in
          M.call_closure (|
            Ty.apply (Ty.path "openvm_stark_backend::prover::types::AirProofInput") [] [ SC ],
            M.get_trait_method (|
              "openvm_stark_backend::chip::Chip",
              C,
              [],
              [ SC ],
              "generate_air_proof_input",
              [],
              []
            |),
            [
              M.call_closure (|
                C,
                M.get_associated_function (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [ C; Ty.apply (Ty.path "std::sync::poison::PoisonError") [] [ C ] ],
                  "unwrap",
                  [],
                  []
                |),
                [
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ C; Ty.apply (Ty.path "std::sync::poison::PoisonError") [] [ C ] ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "std::sync::mutex::Mutex") [] [ C ],
                      "into_inner",
                      [],
                      []
                    |),
                    [ M.read (| self |) ]
                  |)
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (SC C : Ty.t),
      M.IsTraitInstance
        "openvm_stark_backend::chip::Chip"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ SC ]
        (Self SC C)
        (* Instance *)
        [
          ("air", InstanceField.Method (air SC C));
          ("generate_air_proof_input", InstanceField.Method (generate_air_proof_input SC C))
        ].
  End Impl_openvm_stark_backend_chip_Chip_where_openvm_stark_backend_config_StarkGenericConfig_SC_where_openvm_stark_backend_chip_Chip_C_SC_SC_for_std_sync_mutex_Mutex_C.
  
  Module Impl_openvm_stark_backend_chip_ChipUsageGetter_where_openvm_stark_backend_chip_ChipUsageGetter_C_for_std_sync_mutex_Mutex_C.
    Definition Self (C : Ty.t) : Ty.t := Ty.apply (Ty.path "std::sync::mutex::Mutex") [] [ C ].
    
    (*
        fn air_name(&self) -> String {
            self.lock().unwrap().air_name()
        }
    *)
    Definition air_name (C : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self C in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "std::sync::mutex::Mutex") [] [ C ] ],
              self
            |) in
          M.call_closure (|
            Ty.path "alloc::string::String",
            M.get_trait_method (|
              "openvm_stark_backend::chip::ChipUsageGetter",
              C,
              [],
              [],
              "air_name",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ C ],
                    M.get_trait_method (|
                      "core::ops::deref::Deref",
                      Ty.apply (Ty.path "std::sync::mutex::MutexGuard") [] [ C ],
                      [],
                      [],
                      "deref",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          Ty.apply (Ty.path "std::sync::mutex::MutexGuard") [] [ C ],
                          M.call_closure (|
                            Ty.apply (Ty.path "std::sync::mutex::MutexGuard") [] [ C ],
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "core::result::Result")
                                []
                                [
                                  Ty.apply (Ty.path "std::sync::mutex::MutexGuard") [] [ C ];
                                  Ty.apply
                                    (Ty.path "std::sync::poison::PoisonError")
                                    []
                                    [ Ty.apply (Ty.path "std::sync::mutex::MutexGuard") [] [ C ] ]
                                ],
                              "unwrap",
                              [],
                              []
                            |),
                            [
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  []
                                  [
                                    Ty.apply (Ty.path "std::sync::mutex::MutexGuard") [] [ C ];
                                    Ty.apply
                                      (Ty.path "std::sync::poison::PoisonError")
                                      []
                                      [ Ty.apply (Ty.path "std::sync::mutex::MutexGuard") [] [ C ] ]
                                  ],
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "std::sync::mutex::Mutex") [] [ C ],
                                  "lock",
                                  [],
                                  []
                                |),
                                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                              |)
                            ]
                          |)
                        |)
                      |)
                    ]
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn constant_trace_height(&self) -> Option<usize> {
            self.lock().unwrap().constant_trace_height()
        }
    *)
    Definition constant_trace_height
        (C : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self C in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "std::sync::mutex::Mutex") [] [ C ] ],
              self
            |) in
          M.call_closure (|
            Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
            M.get_trait_method (|
              "openvm_stark_backend::chip::ChipUsageGetter",
              C,
              [],
              [],
              "constant_trace_height",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ C ],
                    M.get_trait_method (|
                      "core::ops::deref::Deref",
                      Ty.apply (Ty.path "std::sync::mutex::MutexGuard") [] [ C ],
                      [],
                      [],
                      "deref",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          Ty.apply (Ty.path "std::sync::mutex::MutexGuard") [] [ C ],
                          M.call_closure (|
                            Ty.apply (Ty.path "std::sync::mutex::MutexGuard") [] [ C ],
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "core::result::Result")
                                []
                                [
                                  Ty.apply (Ty.path "std::sync::mutex::MutexGuard") [] [ C ];
                                  Ty.apply
                                    (Ty.path "std::sync::poison::PoisonError")
                                    []
                                    [ Ty.apply (Ty.path "std::sync::mutex::MutexGuard") [] [ C ] ]
                                ],
                              "unwrap",
                              [],
                              []
                            |),
                            [
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  []
                                  [
                                    Ty.apply (Ty.path "std::sync::mutex::MutexGuard") [] [ C ];
                                    Ty.apply
                                      (Ty.path "std::sync::poison::PoisonError")
                                      []
                                      [ Ty.apply (Ty.path "std::sync::mutex::MutexGuard") [] [ C ] ]
                                  ],
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "std::sync::mutex::Mutex") [] [ C ],
                                  "lock",
                                  [],
                                  []
                                |),
                                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                              |)
                            ]
                          |)
                        |)
                      |)
                    ]
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn current_trace_height(&self) -> usize {
            self.lock().unwrap().current_trace_height()
        }
    *)
    Definition current_trace_height
        (C : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self C in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "std::sync::mutex::Mutex") [] [ C ] ],
              self
            |) in
          M.call_closure (|
            Ty.path "usize",
            M.get_trait_method (|
              "openvm_stark_backend::chip::ChipUsageGetter",
              C,
              [],
              [],
              "current_trace_height",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ C ],
                    M.get_trait_method (|
                      "core::ops::deref::Deref",
                      Ty.apply (Ty.path "std::sync::mutex::MutexGuard") [] [ C ],
                      [],
                      [],
                      "deref",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          Ty.apply (Ty.path "std::sync::mutex::MutexGuard") [] [ C ],
                          M.call_closure (|
                            Ty.apply (Ty.path "std::sync::mutex::MutexGuard") [] [ C ],
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "core::result::Result")
                                []
                                [
                                  Ty.apply (Ty.path "std::sync::mutex::MutexGuard") [] [ C ];
                                  Ty.apply
                                    (Ty.path "std::sync::poison::PoisonError")
                                    []
                                    [ Ty.apply (Ty.path "std::sync::mutex::MutexGuard") [] [ C ] ]
                                ],
                              "unwrap",
                              [],
                              []
                            |),
                            [
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  []
                                  [
                                    Ty.apply (Ty.path "std::sync::mutex::MutexGuard") [] [ C ];
                                    Ty.apply
                                      (Ty.path "std::sync::poison::PoisonError")
                                      []
                                      [ Ty.apply (Ty.path "std::sync::mutex::MutexGuard") [] [ C ] ]
                                  ],
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "std::sync::mutex::Mutex") [] [ C ],
                                  "lock",
                                  [],
                                  []
                                |),
                                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                              |)
                            ]
                          |)
                        |)
                      |)
                    ]
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn trace_width(&self) -> usize {
            self.lock().unwrap().trace_width()
        }
    *)
    Definition trace_width (C : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self C in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "std::sync::mutex::Mutex") [] [ C ] ],
              self
            |) in
          M.call_closure (|
            Ty.path "usize",
            M.get_trait_method (|
              "openvm_stark_backend::chip::ChipUsageGetter",
              C,
              [],
              [],
              "trace_width",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.call_closure (|
                    Ty.apply (Ty.path "&") [] [ C ],
                    M.get_trait_method (|
                      "core::ops::deref::Deref",
                      Ty.apply (Ty.path "std::sync::mutex::MutexGuard") [] [ C ],
                      [],
                      [],
                      "deref",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          Ty.apply (Ty.path "std::sync::mutex::MutexGuard") [] [ C ],
                          M.call_closure (|
                            Ty.apply (Ty.path "std::sync::mutex::MutexGuard") [] [ C ],
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "core::result::Result")
                                []
                                [
                                  Ty.apply (Ty.path "std::sync::mutex::MutexGuard") [] [ C ];
                                  Ty.apply
                                    (Ty.path "std::sync::poison::PoisonError")
                                    []
                                    [ Ty.apply (Ty.path "std::sync::mutex::MutexGuard") [] [ C ] ]
                                ],
                              "unwrap",
                              [],
                              []
                            |),
                            [
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  []
                                  [
                                    Ty.apply (Ty.path "std::sync::mutex::MutexGuard") [] [ C ];
                                    Ty.apply
                                      (Ty.path "std::sync::poison::PoisonError")
                                      []
                                      [ Ty.apply (Ty.path "std::sync::mutex::MutexGuard") [] [ C ] ]
                                  ],
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "std::sync::mutex::Mutex") [] [ C ],
                                  "lock",
                                  [],
                                  []
                                |),
                                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                              |)
                            ]
                          |)
                        |)
                      |)
                    ]
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (C : Ty.t),
      M.IsTraitInstance
        "openvm_stark_backend::chip::ChipUsageGetter"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self C)
        (* Instance *)
        [
          ("air_name", InstanceField.Method (air_name C));
          ("constant_trace_height", InstanceField.Method (constant_trace_height C));
          ("current_trace_height", InstanceField.Method (current_trace_height C));
          ("trace_width", InstanceField.Method (trace_width C))
        ].
  End Impl_openvm_stark_backend_chip_ChipUsageGetter_where_openvm_stark_backend_chip_ChipUsageGetter_C_for_std_sync_mutex_Mutex_C.
End chip.
