(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module gkr.
  Module types.
    (* StructRecord
      {
        name := "GkrBatchProof";
        const_params := [];
        ty_params := [ "F" ];
        fields :=
          [
            ("sumcheck_proofs",
              Ty.apply
                (Ty.path "alloc::vec::Vec")
                []
                [
                  Ty.apply (Ty.path "openvm_stark_backend::sumcheck::SumcheckProof") [] [ F ];
                  Ty.path "alloc::alloc::Global"
                ]);
            ("layer_masks_by_instance",
              Ty.apply
                (Ty.path "alloc::vec::Vec")
                []
                [
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [
                      Ty.apply (Ty.path "openvm_stark_backend::gkr::types::GkrMask") [] [ F ];
                      Ty.path "alloc::alloc::Global"
                    ];
                  Ty.path "alloc::alloc::Global"
                ]);
            ("output_claims_by_instance",
              Ty.apply
                (Ty.path "alloc::vec::Vec")
                []
                [
                  Ty.apply (Ty.path "alloc::vec::Vec") [] [ F; Ty.path "alloc::alloc::Global" ];
                  Ty.path "alloc::alloc::Global"
                ])
          ];
      } *)
    
    (* StructRecord
      {
        name := "GkrArtifact";
        const_params := [];
        ty_params := [ "F" ];
        fields :=
          [
            ("ood_point",
              Ty.apply (Ty.path "alloc::vec::Vec") [] [ F; Ty.path "alloc::alloc::Global" ]);
            ("claims_to_verify_by_instance",
              Ty.apply
                (Ty.path "alloc::vec::Vec")
                []
                [
                  Ty.apply (Ty.path "alloc::vec::Vec") [] [ F; Ty.path "alloc::alloc::Global" ];
                  Ty.path "alloc::alloc::Global"
                ]);
            ("n_variables_by_instance",
              Ty.apply
                (Ty.path "alloc::vec::Vec")
                []
                [ Ty.path "usize"; Ty.path "alloc::alloc::Global" ])
          ];
      } *)
    
    (* StructRecord
      {
        name := "GkrMask";
        const_params := [];
        ty_params := [ "F" ];
        fields :=
          [
            ("columns",
              Ty.apply
                (Ty.path "alloc::vec::Vec")
                []
                [
                  Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 2 ] [ F ];
                  Ty.path "alloc::alloc::Global"
                ])
          ];
      } *)
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_F_for_openvm_stark_backend_gkr_types_GkrMask_F.
      Definition Self (F : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "openvm_stark_backend::gkr::types::GkrMask") [] [ F ].
      
      (* Debug *)
      Definition fmt (F : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.apply (Ty.path "openvm_stark_backend::gkr::types::GkrMask") [] [ F ] ],
                self
              |) in
            let f :=
              M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "core::fmt::Formatter" ], f |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
              M.get_associated_function (|
                Ty.path "core::fmt::Formatter",
                "debug_struct_field1_finish",
                [],
                []
              |),
              [
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "GkrMask" |) |) |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "columns" |) |) |);
                M.call_closure (|
                  Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ],
                  M.pointer_coercion
                    M.PointerCoercion.Unsize
                    (Ty.apply
                      (Ty.path "&")
                      []
                      [
                        Ty.apply
                          (Ty.path "&")
                          []
                          [
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              []
                              [
                                Ty.apply
                                  (Ty.path "array")
                                  [ Value.Integer IntegerKind.Usize 2 ]
                                  [ F ];
                                Ty.path "alloc::alloc::Global"
                              ]
                          ]
                      ])
                    (Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ]),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.alloc (|
                            Ty.apply
                              (Ty.path "&")
                              []
                              [
                                Ty.apply
                                  (Ty.path "alloc::vec::Vec")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "array")
                                      [ Value.Integer IntegerKind.Usize 2 ]
                                      [ F ];
                                    Ty.path "alloc::alloc::Global"
                                  ]
                              ],
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "openvm_stark_backend::gkr::types::GkrMask",
                                "columns"
                              |)
                            |)
                          |)
                        |)
                      |)
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (F : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self F)
          (* Instance *) [ ("fmt", InstanceField.Method (fmt F)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_F_for_openvm_stark_backend_gkr_types_GkrMask_F.
    
    Module Impl_core_clone_Clone_where_core_clone_Clone_F_for_openvm_stark_backend_gkr_types_GkrMask_F.
      Definition Self (F : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "openvm_stark_backend::gkr::types::GkrMask") [] [ F ].
      
      (* Clone *)
      Definition clone (F : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.apply (Ty.path "openvm_stark_backend::gkr::types::GkrMask") [] [ F ] ],
                self
              |) in
            Value.mkStructRecord
              "openvm_stark_backend::gkr::types::GkrMask"
              []
              [ F ]
              [
                ("columns",
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      []
                      [
                        Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 2 ] [ F ];
                        Ty.path "alloc::alloc::Global"
                      ],
                    M.get_trait_method (|
                      "core::clone::Clone",
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        []
                        [
                          Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 2 ] [ F ];
                          Ty.path "alloc::alloc::Global"
                        ],
                      [],
                      [],
                      "clone",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "openvm_stark_backend::gkr::types::GkrMask",
                              "columns"
                            |)
                          |)
                        |)
                      |)
                    ]
                  |))
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (F : Ty.t),
        M.IsTraitInstance
          "core::clone::Clone"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self F)
          (* Instance *) [ ("clone", InstanceField.Method (clone F)) ].
    End Impl_core_clone_Clone_where_core_clone_Clone_F_for_openvm_stark_backend_gkr_types_GkrMask_F.
    
    Module Impl_openvm_stark_backend_gkr_types_GkrMask_F.
      Definition Self (F : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "openvm_stark_backend::gkr::types::GkrMask") [] [ F ].
      
      (*
          pub fn new(columns: Vec<[F; 2]>) -> Self {
              Self { columns }
          }
      *)
      Definition new (F : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match ε, τ, α with
        | [], [], [ columns ] =>
          ltac:(M.monadic
            (let columns :=
              M.alloc (|
                Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  []
                  [
                    Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 2 ] [ F ];
                    Ty.path "alloc::alloc::Global"
                  ],
                columns
              |) in
            Value.mkStructRecord
              "openvm_stark_backend::gkr::types::GkrMask"
              []
              [ F ]
              [ ("columns", M.read (| columns |)) ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_new :
        forall (F : Ty.t),
        M.IsAssociatedFunction.C (Self F) "new" (new F).
      Admitted.
      Global Typeclasses Opaque new.
      
      (*
          pub fn columns(&self) -> &[[F; 2]] {
              &self.columns
          }
      *)
      Definition columns (F : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.apply (Ty.path "openvm_stark_backend::gkr::types::GkrMask") [] [ F ] ],
                self
              |) in
            M.borrow (|
              Pointer.Kind.Ref,
              M.deref (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "&")
                    []
                    [
                      Ty.apply
                        (Ty.path "slice")
                        []
                        [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 2 ] [ F ] ]
                    ],
                  M.get_trait_method (|
                    "core::ops::deref::Deref",
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      []
                      [
                        Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 2 ] [ F ];
                        Ty.path "alloc::alloc::Global"
                      ],
                    [],
                    [],
                    "deref",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "openvm_stark_backend::gkr::types::GkrMask",
                            "columns"
                          |)
                        |)
                      |)
                    |)
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_columns :
        forall (F : Ty.t),
        M.IsAssociatedFunction.C (Self F) "columns" (columns F).
      Admitted.
      Global Typeclasses Opaque columns.
      (*
          pub fn to_rows(&self) -> [Vec<F>; 2] {
              self.columns.iter().map(|[a, b]| (a, b)).unzip().into()
          }
      *)
      Definition to_rows (F : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.apply (Ty.path "openvm_stark_backend::gkr::types::GkrMask") [] [ F ] ],
                self
              |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "array")
                [ Value.Integer IntegerKind.Usize 2 ]
                [ Ty.apply (Ty.path "alloc::vec::Vec") [] [ F; Ty.path "alloc::alloc::Global" ] ],
              M.get_trait_method (|
                "core::convert::Into",
                Ty.tuple
                  [
                    Ty.apply (Ty.path "alloc::vec::Vec") [] [ F; Ty.path "alloc::alloc::Global" ];
                    Ty.apply (Ty.path "alloc::vec::Vec") [] [ F; Ty.path "alloc::alloc::Global" ]
                  ],
                [],
                [
                  Ty.apply
                    (Ty.path "array")
                    [ Value.Integer IntegerKind.Usize 2 ]
                    [ Ty.apply (Ty.path "alloc::vec::Vec") [] [ F; Ty.path "alloc::alloc::Global" ]
                    ]
                ],
                "into",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.tuple
                    [
                      Ty.apply (Ty.path "alloc::vec::Vec") [] [ F; Ty.path "alloc::alloc::Global" ];
                      Ty.apply (Ty.path "alloc::vec::Vec") [] [ F; Ty.path "alloc::alloc::Global" ]
                    ],
                  M.get_trait_method (|
                    "core::iter::traits::iterator::Iterator",
                    Ty.apply
                      (Ty.path "core::iter::adapters::map::Map")
                      []
                      [
                        Ty.apply
                          (Ty.path "core::slice::iter::Iter")
                          []
                          [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 2 ] [ F ]
                          ];
                        Ty.function
                          [
                            Ty.apply
                              (Ty.path "&")
                              []
                              [
                                Ty.apply
                                  (Ty.path "array")
                                  [ Value.Integer IntegerKind.Usize 2 ]
                                  [ F ]
                              ]
                          ]
                          (Ty.tuple
                            [ Ty.apply (Ty.path "&") [] [ F ]; Ty.apply (Ty.path "&") [] [ F ] ])
                      ],
                    [],
                    [],
                    "unzip",
                    [],
                    [
                      Ty.apply (Ty.path "&") [] [ F ];
                      Ty.apply (Ty.path "&") [] [ F ];
                      Ty.apply (Ty.path "alloc::vec::Vec") [] [ F; Ty.path "alloc::alloc::Global" ];
                      Ty.apply (Ty.path "alloc::vec::Vec") [] [ F; Ty.path "alloc::alloc::Global" ]
                    ]
                  |),
                  [
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::iter::adapters::map::Map")
                        []
                        [
                          Ty.apply
                            (Ty.path "core::slice::iter::Iter")
                            []
                            [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 2 ] [ F ]
                            ];
                          Ty.function
                            [
                              Ty.apply
                                (Ty.path "&")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "array")
                                    [ Value.Integer IntegerKind.Usize 2 ]
                                    [ F ]
                                ]
                            ]
                            (Ty.tuple
                              [ Ty.apply (Ty.path "&") [] [ F ]; Ty.apply (Ty.path "&") [] [ F ] ])
                        ],
                      M.get_trait_method (|
                        "core::iter::traits::iterator::Iterator",
                        Ty.apply
                          (Ty.path "core::slice::iter::Iter")
                          []
                          [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 2 ] [ F ]
                          ],
                        [],
                        [],
                        "map",
                        [],
                        [
                          Ty.tuple
                            [ Ty.apply (Ty.path "&") [] [ F ]; Ty.apply (Ty.path "&") [] [ F ] ];
                          Ty.function
                            [
                              Ty.apply
                                (Ty.path "&")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "array")
                                    [ Value.Integer IntegerKind.Usize 2 ]
                                    [ F ]
                                ]
                            ]
                            (Ty.tuple
                              [ Ty.apply (Ty.path "&") [] [ F ]; Ty.apply (Ty.path "&") [] [ F ] ])
                        ]
                      |),
                      [
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::slice::iter::Iter")
                            []
                            [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 2 ] [ F ]
                            ],
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "slice")
                              []
                              [
                                Ty.apply
                                  (Ty.path "array")
                                  [ Value.Integer IntegerKind.Usize 2 ]
                                  [ F ]
                              ],
                            "iter",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "&")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "slice")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "array")
                                            [ Value.Integer IntegerKind.Usize 2 ]
                                            [ F ]
                                        ]
                                    ],
                                  M.get_trait_method (|
                                    "core::ops::deref::Deref",
                                    Ty.apply
                                      (Ty.path "alloc::vec::Vec")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "array")
                                          [ Value.Integer IntegerKind.Usize 2 ]
                                          [ F ];
                                        Ty.path "alloc::alloc::Global"
                                      ],
                                    [],
                                    [],
                                    "deref",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.SubPointer.get_struct_record_field (|
                                        M.deref (| M.read (| self |) |),
                                        "openvm_stark_backend::gkr::types::GkrMask",
                                        "columns"
                                      |)
                                    |)
                                  ]
                                |)
                              |)
                            |)
                          ]
                        |);
                        M.closure
                          (fun γ =>
                            ltac:(M.monadic
                              match γ with
                              | [ α0 ] =>
                                ltac:(M.monadic
                                  (M.match_operator (|
                                    Ty.tuple
                                      [
                                        Ty.apply (Ty.path "&") [] [ F ];
                                        Ty.apply (Ty.path "&") [] [ F ]
                                      ],
                                    M.alloc (|
                                      Ty.apply
                                        (Ty.path "&")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "array")
                                            [ Value.Integer IntegerKind.Usize 2 ]
                                            [ F ]
                                        ],
                                      α0
                                    |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let γ := M.read (| γ |) in
                                          let γ1_0 := M.SubPointer.get_slice_index (| γ, 0 |) in
                                          let γ1_1 := M.SubPointer.get_slice_index (| γ, 1 |) in
                                          let a :=
                                            M.alloc (| Ty.apply (Ty.path "&") [] [ F ], γ1_0 |) in
                                          let b :=
                                            M.alloc (| Ty.apply (Ty.path "&") [] [ F ], γ1_1 |) in
                                          Value.Tuple [ M.read (| a |); M.read (| b |) ]))
                                    ]
                                  |)))
                              | _ => M.impossible "wrong number of arguments"
                              end))
                      ]
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_to_rows :
        forall (F : Ty.t),
        M.IsAssociatedFunction.C (Self F) "to_rows" (to_rows F).
      Admitted.
      Global Typeclasses Opaque to_rows.
      
      (*
          pub fn reduce_at_point(&self, x: F) -> Vec<F> {
              self.columns
                  .iter()
                  .map(|&[v0, v1]| fold_mle_evals(x, v0, v1))
                  .collect()
          }
      *)
      Definition reduce_at_point
          (F : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self F in
        match ε, τ, α with
        | [], [], [ self; x ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.apply (Ty.path "openvm_stark_backend::gkr::types::GkrMask") [] [ F ] ],
                self
              |) in
            let x := M.alloc (| F, x |) in
            M.call_closure (|
              Ty.apply (Ty.path "alloc::vec::Vec") [] [ F; Ty.path "alloc::alloc::Global" ],
              M.get_trait_method (|
                "core::iter::traits::iterator::Iterator",
                Ty.apply
                  (Ty.path "core::iter::adapters::map::Map")
                  []
                  [
                    Ty.apply
                      (Ty.path "core::slice::iter::Iter")
                      []
                      [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 2 ] [ F ] ];
                    Ty.function
                      [
                        Ty.apply
                          (Ty.path "&")
                          []
                          [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 2 ] [ F ] ]
                      ]
                      F
                  ],
                [],
                [],
                "collect",
                [],
                [ Ty.apply (Ty.path "alloc::vec::Vec") [] [ F; Ty.path "alloc::alloc::Global" ] ]
              |),
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::iter::adapters::map::Map")
                    []
                    [
                      Ty.apply
                        (Ty.path "core::slice::iter::Iter")
                        []
                        [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 2 ] [ F ] ];
                      Ty.function
                        [
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 2 ] [ F ]
                            ]
                        ]
                        F
                    ],
                  M.get_trait_method (|
                    "core::iter::traits::iterator::Iterator",
                    Ty.apply
                      (Ty.path "core::slice::iter::Iter")
                      []
                      [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 2 ] [ F ] ],
                    [],
                    [],
                    "map",
                    [],
                    [
                      F;
                      Ty.function
                        [
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 2 ] [ F ]
                            ]
                        ]
                        F
                    ]
                  |),
                  [
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::slice::iter::Iter")
                        []
                        [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 2 ] [ F ] ],
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "slice")
                          []
                          [ Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 2 ] [ F ]
                          ],
                        "iter",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (|
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "&")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "slice")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "array")
                                        [ Value.Integer IntegerKind.Usize 2 ]
                                        [ F ]
                                    ]
                                ],
                              M.get_trait_method (|
                                "core::ops::deref::Deref",
                                Ty.apply
                                  (Ty.path "alloc::vec::Vec")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "array")
                                      [ Value.Integer IntegerKind.Usize 2 ]
                                      [ F ];
                                    Ty.path "alloc::alloc::Global"
                                  ],
                                [],
                                [],
                                "deref",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "openvm_stark_backend::gkr::types::GkrMask",
                                    "columns"
                                  |)
                                |)
                              ]
                            |)
                          |)
                        |)
                      ]
                    |);
                    M.closure
                      (fun γ =>
                        ltac:(M.monadic
                          match γ with
                          | [ α0 ] =>
                            ltac:(M.monadic
                              (M.match_operator (|
                                F,
                                M.alloc (|
                                  Ty.apply
                                    (Ty.path "&")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "array")
                                        [ Value.Integer IntegerKind.Usize 2 ]
                                        [ F ]
                                    ],
                                  α0
                                |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ := M.read (| γ |) in
                                      let γ1_0 := M.SubPointer.get_slice_index (| γ, 0 |) in
                                      let γ1_1 := M.SubPointer.get_slice_index (| γ, 1 |) in
                                      let v0 := M.copy (| F, γ1_0 |) in
                                      let v1 := M.copy (| F, γ1_1 |) in
                                      M.call_closure (|
                                        F,
                                        M.get_function (|
                                          "openvm_stark_backend::poly::multi::fold_mle_evals",
                                          [],
                                          [ F; F ]
                                        |),
                                        [ M.read (| x |); M.read (| v0 |); M.read (| v1 |) ]
                                      |)))
                                ]
                              |)))
                          | _ => M.impossible "wrong number of arguments"
                          end))
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_reduce_at_point :
        forall (F : Ty.t),
        M.IsAssociatedFunction.C (Self F) "reduce_at_point" (reduce_at_point F).
      Admitted.
      Global Typeclasses Opaque reduce_at_point.
    End Impl_openvm_stark_backend_gkr_types_GkrMask_F.
    
    
    (*
    Enum GkrError
    {
      const_params := [];
      ty_params := [ "F" ];
      variants :=
        [
          {
            name := "MalformedProof";
            item := StructTuple [];
          };
          {
            name := "InvalidMask";
            item :=
              StructRecord [ ("instance", Ty.path "usize"); ("instance_layer", Ty.path "usize") ];
          };
          {
            name := "NumInstancesMismatch";
            item := StructRecord [ ("given", Ty.path "usize"); ("proof", Ty.path "usize") ];
          };
          {
            name := "InvalidSumcheck";
            item :=
              StructRecord
                [
                  ("layer", Ty.path "usize");
                  ("source",
                    Ty.apply (Ty.path "openvm_stark_backend::sumcheck::SumcheckError") [] [ F ])
                ];
          };
          {
            name := "CircuitCheckFailure";
            item := StructRecord [ ("claim", F); ("output", F); ("layer", Ty.path "usize") ];
          }
        ];
    }
    *)
    
    Axiom IsDiscriminant_GkrError_MalformedProof :
      M.IsDiscriminant "openvm_stark_backend::gkr::types::GkrError::MalformedProof" 0.
    Axiom IsDiscriminant_GkrError_InvalidMask :
      M.IsDiscriminant "openvm_stark_backend::gkr::types::GkrError::InvalidMask" 1.
    Axiom IsDiscriminant_GkrError_NumInstancesMismatch :
      M.IsDiscriminant "openvm_stark_backend::gkr::types::GkrError::NumInstancesMismatch" 2.
    Axiom IsDiscriminant_GkrError_InvalidSumcheck :
      M.IsDiscriminant "openvm_stark_backend::gkr::types::GkrError::InvalidSumcheck" 3.
    Axiom IsDiscriminant_GkrError_CircuitCheckFailure :
      M.IsDiscriminant "openvm_stark_backend::gkr::types::GkrError::CircuitCheckFailure" 4.
    
    Module Impl_core_error_Error_where_core_error_Error_openvm_stark_backend_sumcheck_SumcheckError_F_where_core_fmt_Debug_openvm_stark_backend_gkr_types_GkrError_F_where_core_fmt_Display_openvm_stark_backend_gkr_types_GkrError_F_for_openvm_stark_backend_gkr_types_GkrError_F.
      Definition Self (F : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "openvm_stark_backend::gkr::types::GkrError") [] [ F ].
      
      (* Error *)
      Definition source (F : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.apply (Ty.path "openvm_stark_backend::gkr::types::GkrError") [] [ F ] ],
                self
              |) in
            M.match_operator (|
              Ty.apply
                (Ty.path "core::option::Option")
                []
                [ Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::error::Error::Trait", []) ] ] ],
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "openvm_stark_backend::gkr::types::GkrError::MalformedProof"
                      |) in
                    Value.StructTuple
                      "core::option::Option::None"
                      []
                      [ Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::error::Error::Trait", []) ] ] ]
                      []));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "openvm_stark_backend::gkr::types::GkrError::InvalidMask"
                      |) in
                    Value.StructTuple
                      "core::option::Option::None"
                      []
                      [ Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::error::Error::Trait", []) ] ] ]
                      []));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "openvm_stark_backend::gkr::types::GkrError::NumInstancesMismatch"
                      |) in
                    Value.StructTuple
                      "core::option::Option::None"
                      []
                      [ Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::error::Error::Trait", []) ] ] ]
                      []));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "openvm_stark_backend::gkr::types::GkrError::InvalidSumcheck",
                        "source"
                      |) in
                    let source :=
                      M.alloc (|
                        Ty.apply
                          (Ty.path "&")
                          []
                          [
                            Ty.apply
                              (Ty.path "openvm_stark_backend::sumcheck::SumcheckError")
                              []
                              [ F ]
                          ],
                        γ1_0
                      |) in
                    Value.StructTuple
                      "core::option::Option::Some"
                      []
                      [ Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::error::Error::Trait", []) ] ] ]
                      [
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.dyn [ ("core::error::Error::Trait", []) ] ],
                          M.pointer_coercion
                            M.PointerCoercion.Unsize
                            (Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.dyn [ ("core::error::Error::Trait", []) ] ])
                            (Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.dyn [ ("core::error::Error::Trait", []) ] ]),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "&")
                                    []
                                    [ Ty.dyn [ ("core::error::Error::Trait", []) ] ],
                                  M.get_trait_method (|
                                    "thiserror::aserror::AsDynError",
                                    Ty.apply
                                      (Ty.path "openvm_stark_backend::sumcheck::SumcheckError")
                                      []
                                      [ F ],
                                    [],
                                    [],
                                    "as_dyn_error",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (| M.read (| source |) |)
                                    |)
                                  ]
                                |)
                              |)
                            |)
                          ]
                        |)
                      ]));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "openvm_stark_backend::gkr::types::GkrError::CircuitCheckFailure"
                      |) in
                    Value.StructTuple
                      "core::option::Option::None"
                      []
                      [ Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::error::Error::Trait", []) ] ] ]
                      []))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (F : Ty.t),
        M.IsTraitInstance
          "core::error::Error"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self F)
          (* Instance *) [ ("source", InstanceField.Method (source F)) ].
    End Impl_core_error_Error_where_core_error_Error_openvm_stark_backend_sumcheck_SumcheckError_F_where_core_fmt_Debug_openvm_stark_backend_gkr_types_GkrError_F_where_core_fmt_Display_openvm_stark_backend_gkr_types_GkrError_F_for_openvm_stark_backend_gkr_types_GkrError_F.
    
    Module Impl_core_fmt_Display_where_core_fmt_Display_openvm_stark_backend_sumcheck_SumcheckError_F_where_core_fmt_Display_F_for_openvm_stark_backend_gkr_types_GkrError_F.
      Definition Self (F : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "openvm_stark_backend::gkr::types::GkrError") [] [ F ].
      
      (* Error *)
      Definition fmt (F : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match ε, τ, α with
        | [], [], [ self; __formatter ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.apply (Ty.path "openvm_stark_backend::gkr::types::GkrError") [] [ F ] ],
                self
              |) in
            let __formatter :=
              M.alloc (|
                Ty.apply (Ty.path "&mut") [] [ Ty.path "core::fmt::Formatter" ],
                __formatter
              |) in
            M.match_operator (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "openvm_stark_backend::gkr::types::GkrError::MalformedProof"
                      |) in
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                      M.get_associated_function (|
                        Ty.path "core::fmt::Formatter",
                        "write_str",
                        [],
                        []
                      |),
                      [
                        M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| __formatter |) |) |);
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (| mk_str (| "proof data is invalid" |) |)
                        |)
                      ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "openvm_stark_backend::gkr::types::GkrError::InvalidMask",
                        "instance"
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "openvm_stark_backend::gkr::types::GkrError::InvalidMask",
                        "instance_layer"
                      |) in
                    let instance :=
                      M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "usize" ], γ1_0 |) in
                    let instance_layer :=
                      M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "usize" ], γ1_1 |) in
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                      M.get_associated_function (|
                        Ty.path "core::fmt::Formatter",
                        "write_fmt",
                        [],
                        []
                      |),
                      [
                        M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| __formatter |) |) |);
                        M.call_closure (|
                          Ty.path "core::fmt::Arguments",
                          M.get_associated_function (|
                            Ty.path "core::fmt::Arguments",
                            "new_v1",
                            [ Value.Integer IntegerKind.Usize 3; Value.Integer IntegerKind.Usize 2
                            ],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.alloc (|
                                    Ty.apply
                                      (Ty.path "array")
                                      [ Value.Integer IntegerKind.Usize 3 ]
                                      [ Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ],
                                    Value.Array
                                      [
                                        mk_str (| "mask in layer " |);
                                        mk_str (| " of instance " |);
                                        mk_str (| " is invalid" |)
                                      ]
                                  |)
                                |)
                              |)
                            |);
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.alloc (|
                                    Ty.apply
                                      (Ty.path "array")
                                      [ Value.Integer IntegerKind.Usize 2 ]
                                      [ Ty.path "core::fmt::rt::Argument" ],
                                    Value.Array
                                      [
                                        M.call_closure (|
                                          Ty.path "core::fmt::rt::Argument",
                                          M.get_associated_function (|
                                            Ty.path "core::fmt::rt::Argument",
                                            "new_display",
                                            [],
                                            [ Ty.apply (Ty.path "&") [] [ Ty.path "usize" ] ]
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.alloc (|
                                                    Ty.apply (Ty.path "&") [] [ Ty.path "usize" ],
                                                    M.call_closure (|
                                                      Ty.apply (Ty.path "&") [] [ Ty.path "usize" ],
                                                      M.get_trait_method (|
                                                        "thiserror::display::AsDisplay",
                                                        Ty.apply
                                                          (Ty.path "&")
                                                          []
                                                          [ Ty.path "usize" ],
                                                        [],
                                                        [],
                                                        "as_display",
                                                        [],
                                                        []
                                                      |),
                                                      [
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          instance_layer
                                                        |)
                                                      ]
                                                    |)
                                                  |)
                                                |)
                                              |)
                                            |)
                                          ]
                                        |);
                                        M.call_closure (|
                                          Ty.path "core::fmt::rt::Argument",
                                          M.get_associated_function (|
                                            Ty.path "core::fmt::rt::Argument",
                                            "new_display",
                                            [],
                                            [ Ty.apply (Ty.path "&") [] [ Ty.path "usize" ] ]
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.alloc (|
                                                    Ty.apply (Ty.path "&") [] [ Ty.path "usize" ],
                                                    M.call_closure (|
                                                      Ty.apply (Ty.path "&") [] [ Ty.path "usize" ],
                                                      M.get_trait_method (|
                                                        "thiserror::display::AsDisplay",
                                                        Ty.apply
                                                          (Ty.path "&")
                                                          []
                                                          [ Ty.path "usize" ],
                                                        [],
                                                        [],
                                                        "as_display",
                                                        [],
                                                        []
                                                      |),
                                                      [ M.borrow (| Pointer.Kind.Ref, instance |) ]
                                                    |)
                                                  |)
                                                |)
                                              |)
                                            |)
                                          ]
                                        |)
                                      ]
                                  |)
                                |)
                              |)
                            |)
                          ]
                        |)
                      ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "openvm_stark_backend::gkr::types::GkrError::NumInstancesMismatch",
                        "given"
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "openvm_stark_backend::gkr::types::GkrError::NumInstancesMismatch",
                        "proof"
                      |) in
                    let given :=
                      M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "usize" ], γ1_0 |) in
                    let proof :=
                      M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "usize" ], γ1_1 |) in
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                      M.get_associated_function (|
                        Ty.path "core::fmt::Formatter",
                        "write_fmt",
                        [],
                        []
                      |),
                      [
                        M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| __formatter |) |) |);
                        M.call_closure (|
                          Ty.path "core::fmt::Arguments",
                          M.get_associated_function (|
                            Ty.path "core::fmt::Arguments",
                            "new_v1",
                            [ Value.Integer IntegerKind.Usize 3; Value.Integer IntegerKind.Usize 2
                            ],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.alloc (|
                                    Ty.apply
                                      (Ty.path "array")
                                      [ Value.Integer IntegerKind.Usize 3 ]
                                      [ Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ],
                                    Value.Array
                                      [
                                        mk_str (|
                                          "provided an invalid number of instances (given "
                                        |);
                                        mk_str (| ", proof expects " |);
                                        mk_str (| ")" |)
                                      ]
                                  |)
                                |)
                              |)
                            |);
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.alloc (|
                                    Ty.apply
                                      (Ty.path "array")
                                      [ Value.Integer IntegerKind.Usize 2 ]
                                      [ Ty.path "core::fmt::rt::Argument" ],
                                    Value.Array
                                      [
                                        M.call_closure (|
                                          Ty.path "core::fmt::rt::Argument",
                                          M.get_associated_function (|
                                            Ty.path "core::fmt::rt::Argument",
                                            "new_display",
                                            [],
                                            [ Ty.apply (Ty.path "&") [] [ Ty.path "usize" ] ]
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.alloc (|
                                                    Ty.apply (Ty.path "&") [] [ Ty.path "usize" ],
                                                    M.call_closure (|
                                                      Ty.apply (Ty.path "&") [] [ Ty.path "usize" ],
                                                      M.get_trait_method (|
                                                        "thiserror::display::AsDisplay",
                                                        Ty.apply
                                                          (Ty.path "&")
                                                          []
                                                          [ Ty.path "usize" ],
                                                        [],
                                                        [],
                                                        "as_display",
                                                        [],
                                                        []
                                                      |),
                                                      [ M.borrow (| Pointer.Kind.Ref, given |) ]
                                                    |)
                                                  |)
                                                |)
                                              |)
                                            |)
                                          ]
                                        |);
                                        M.call_closure (|
                                          Ty.path "core::fmt::rt::Argument",
                                          M.get_associated_function (|
                                            Ty.path "core::fmt::rt::Argument",
                                            "new_display",
                                            [],
                                            [ Ty.apply (Ty.path "&") [] [ Ty.path "usize" ] ]
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.alloc (|
                                                    Ty.apply (Ty.path "&") [] [ Ty.path "usize" ],
                                                    M.call_closure (|
                                                      Ty.apply (Ty.path "&") [] [ Ty.path "usize" ],
                                                      M.get_trait_method (|
                                                        "thiserror::display::AsDisplay",
                                                        Ty.apply
                                                          (Ty.path "&")
                                                          []
                                                          [ Ty.path "usize" ],
                                                        [],
                                                        [],
                                                        "as_display",
                                                        [],
                                                        []
                                                      |),
                                                      [ M.borrow (| Pointer.Kind.Ref, proof |) ]
                                                    |)
                                                  |)
                                                |)
                                              |)
                                            |)
                                          ]
                                        |)
                                      ]
                                  |)
                                |)
                              |)
                            |)
                          ]
                        |)
                      ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "openvm_stark_backend::gkr::types::GkrError::InvalidSumcheck",
                        "layer"
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "openvm_stark_backend::gkr::types::GkrError::InvalidSumcheck",
                        "source"
                      |) in
                    let layer :=
                      M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "usize" ], γ1_0 |) in
                    let source :=
                      M.alloc (|
                        Ty.apply
                          (Ty.path "&")
                          []
                          [
                            Ty.apply
                              (Ty.path "openvm_stark_backend::sumcheck::SumcheckError")
                              []
                              [ F ]
                          ],
                        γ1_1
                      |) in
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                      M.get_associated_function (|
                        Ty.path "core::fmt::Formatter",
                        "write_fmt",
                        [],
                        []
                      |),
                      [
                        M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| __formatter |) |) |);
                        M.call_closure (|
                          Ty.path "core::fmt::Arguments",
                          M.get_associated_function (|
                            Ty.path "core::fmt::Arguments",
                            "new_v1",
                            [ Value.Integer IntegerKind.Usize 2; Value.Integer IntegerKind.Usize 2
                            ],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.alloc (|
                                    Ty.apply
                                      (Ty.path "array")
                                      [ Value.Integer IntegerKind.Usize 2 ]
                                      [ Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ],
                                    Value.Array
                                      [
                                        mk_str (| "sum-check invalid in layer " |);
                                        mk_str (| ": " |)
                                      ]
                                  |)
                                |)
                              |)
                            |);
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.alloc (|
                                    Ty.apply
                                      (Ty.path "array")
                                      [ Value.Integer IntegerKind.Usize 2 ]
                                      [ Ty.path "core::fmt::rt::Argument" ],
                                    Value.Array
                                      [
                                        M.call_closure (|
                                          Ty.path "core::fmt::rt::Argument",
                                          M.get_associated_function (|
                                            Ty.path "core::fmt::rt::Argument",
                                            "new_display",
                                            [],
                                            [ Ty.apply (Ty.path "&") [] [ Ty.path "usize" ] ]
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.alloc (|
                                                    Ty.apply (Ty.path "&") [] [ Ty.path "usize" ],
                                                    M.call_closure (|
                                                      Ty.apply (Ty.path "&") [] [ Ty.path "usize" ],
                                                      M.get_trait_method (|
                                                        "thiserror::display::AsDisplay",
                                                        Ty.apply
                                                          (Ty.path "&")
                                                          []
                                                          [ Ty.path "usize" ],
                                                        [],
                                                        [],
                                                        "as_display",
                                                        [],
                                                        []
                                                      |),
                                                      [ M.borrow (| Pointer.Kind.Ref, layer |) ]
                                                    |)
                                                  |)
                                                |)
                                              |)
                                            |)
                                          ]
                                        |);
                                        M.call_closure (|
                                          Ty.path "core::fmt::rt::Argument",
                                          M.get_associated_function (|
                                            Ty.path "core::fmt::rt::Argument",
                                            "new_display",
                                            [],
                                            [
                                              Ty.apply
                                                (Ty.path "&")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path
                                                      "openvm_stark_backend::sumcheck::SumcheckError")
                                                    []
                                                    [ F ]
                                                ]
                                            ]
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.alloc (|
                                                    Ty.apply
                                                      (Ty.path "&")
                                                      []
                                                      [
                                                        Ty.apply
                                                          (Ty.path
                                                            "openvm_stark_backend::sumcheck::SumcheckError")
                                                          []
                                                          [ F ]
                                                      ],
                                                    M.call_closure (|
                                                      Ty.apply
                                                        (Ty.path "&")
                                                        []
                                                        [
                                                          Ty.apply
                                                            (Ty.path
                                                              "openvm_stark_backend::sumcheck::SumcheckError")
                                                            []
                                                            [ F ]
                                                        ],
                                                      M.get_trait_method (|
                                                        "thiserror::display::AsDisplay",
                                                        Ty.apply
                                                          (Ty.path "&")
                                                          []
                                                          [
                                                            Ty.apply
                                                              (Ty.path
                                                                "openvm_stark_backend::sumcheck::SumcheckError")
                                                              []
                                                              [ F ]
                                                          ],
                                                        [],
                                                        [],
                                                        "as_display",
                                                        [],
                                                        []
                                                      |),
                                                      [ M.borrow (| Pointer.Kind.Ref, source |) ]
                                                    |)
                                                  |)
                                                |)
                                              |)
                                            |)
                                          ]
                                        |)
                                      ]
                                  |)
                                |)
                              |)
                            |)
                          ]
                        |)
                      ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "openvm_stark_backend::gkr::types::GkrError::CircuitCheckFailure",
                        "claim"
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "openvm_stark_backend::gkr::types::GkrError::CircuitCheckFailure",
                        "output"
                      |) in
                    let γ1_2 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "openvm_stark_backend::gkr::types::GkrError::CircuitCheckFailure",
                        "layer"
                      |) in
                    let claim := M.alloc (| Ty.apply (Ty.path "&") [] [ F ], γ1_0 |) in
                    let output := M.alloc (| Ty.apply (Ty.path "&") [] [ F ], γ1_1 |) in
                    let layer :=
                      M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "usize" ], γ1_2 |) in
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                      M.get_associated_function (|
                        Ty.path "core::fmt::Formatter",
                        "write_fmt",
                        [],
                        []
                      |),
                      [
                        M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| __formatter |) |) |);
                        M.call_closure (|
                          Ty.path "core::fmt::Arguments",
                          M.get_associated_function (|
                            Ty.path "core::fmt::Arguments",
                            "new_v1",
                            [ Value.Integer IntegerKind.Usize 4; Value.Integer IntegerKind.Usize 3
                            ],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.alloc (|
                                    Ty.apply
                                      (Ty.path "array")
                                      [ Value.Integer IntegerKind.Usize 4 ]
                                      [ Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ],
                                    Value.Array
                                      [
                                        mk_str (| "circuit check failed in layer " |);
                                        mk_str (| " (calculated " |);
                                        mk_str (| ", claim " |);
                                        mk_str (| ")" |)
                                      ]
                                  |)
                                |)
                              |)
                            |);
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.alloc (|
                                    Ty.apply
                                      (Ty.path "array")
                                      [ Value.Integer IntegerKind.Usize 3 ]
                                      [ Ty.path "core::fmt::rt::Argument" ],
                                    Value.Array
                                      [
                                        M.call_closure (|
                                          Ty.path "core::fmt::rt::Argument",
                                          M.get_associated_function (|
                                            Ty.path "core::fmt::rt::Argument",
                                            "new_display",
                                            [],
                                            [ Ty.apply (Ty.path "&") [] [ Ty.path "usize" ] ]
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.alloc (|
                                                    Ty.apply (Ty.path "&") [] [ Ty.path "usize" ],
                                                    M.call_closure (|
                                                      Ty.apply (Ty.path "&") [] [ Ty.path "usize" ],
                                                      M.get_trait_method (|
                                                        "thiserror::display::AsDisplay",
                                                        Ty.apply
                                                          (Ty.path "&")
                                                          []
                                                          [ Ty.path "usize" ],
                                                        [],
                                                        [],
                                                        "as_display",
                                                        [],
                                                        []
                                                      |),
                                                      [ M.borrow (| Pointer.Kind.Ref, layer |) ]
                                                    |)
                                                  |)
                                                |)
                                              |)
                                            |)
                                          ]
                                        |);
                                        M.call_closure (|
                                          Ty.path "core::fmt::rt::Argument",
                                          M.get_associated_function (|
                                            Ty.path "core::fmt::rt::Argument",
                                            "new_display",
                                            [],
                                            [ Ty.apply (Ty.path "&") [] [ F ] ]
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.alloc (|
                                                    Ty.apply (Ty.path "&") [] [ F ],
                                                    M.call_closure (|
                                                      Ty.apply (Ty.path "&") [] [ F ],
                                                      M.get_trait_method (|
                                                        "thiserror::display::AsDisplay",
                                                        Ty.apply (Ty.path "&") [] [ F ],
                                                        [],
                                                        [],
                                                        "as_display",
                                                        [],
                                                        []
                                                      |),
                                                      [ M.borrow (| Pointer.Kind.Ref, output |) ]
                                                    |)
                                                  |)
                                                |)
                                              |)
                                            |)
                                          ]
                                        |);
                                        M.call_closure (|
                                          Ty.path "core::fmt::rt::Argument",
                                          M.get_associated_function (|
                                            Ty.path "core::fmt::rt::Argument",
                                            "new_display",
                                            [],
                                            [ Ty.apply (Ty.path "&") [] [ F ] ]
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.alloc (|
                                                    Ty.apply (Ty.path "&") [] [ F ],
                                                    M.call_closure (|
                                                      Ty.apply (Ty.path "&") [] [ F ],
                                                      M.get_trait_method (|
                                                        "thiserror::display::AsDisplay",
                                                        Ty.apply (Ty.path "&") [] [ F ],
                                                        [],
                                                        [],
                                                        "as_display",
                                                        [],
                                                        []
                                                      |),
                                                      [ M.borrow (| Pointer.Kind.Ref, claim |) ]
                                                    |)
                                                  |)
                                                |)
                                              |)
                                            |)
                                          ]
                                        |)
                                      ]
                                  |)
                                |)
                              |)
                            |)
                          ]
                        |)
                      ]
                    |)))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (F : Ty.t),
        M.IsTraitInstance
          "core::fmt::Display"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self F)
          (* Instance *) [ ("fmt", InstanceField.Method (fmt F)) ].
    End Impl_core_fmt_Display_where_core_fmt_Display_openvm_stark_backend_sumcheck_SumcheckError_F_where_core_fmt_Display_F_for_openvm_stark_backend_gkr_types_GkrError_F.
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_F_for_openvm_stark_backend_gkr_types_GkrError_F.
      Definition Self (F : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "openvm_stark_backend::gkr::types::GkrError") [] [ F ].
      
      (* Debug *)
      Definition fmt (F : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.apply (Ty.path "openvm_stark_backend::gkr::types::GkrError") [] [ F ] ],
                self
              |) in
            let f :=
              M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "core::fmt::Formatter" ], f |) in
            M.match_operator (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (|
                        γ,
                        "openvm_stark_backend::gkr::types::GkrError::MalformedProof"
                      |) in
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                      M.get_associated_function (|
                        Ty.path "core::fmt::Formatter",
                        "write_str",
                        [],
                        []
                      |),
                      [
                        M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                        M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "MalformedProof" |) |) |)
                      ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "openvm_stark_backend::gkr::types::GkrError::InvalidMask",
                        "instance"
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "openvm_stark_backend::gkr::types::GkrError::InvalidMask",
                        "instance_layer"
                      |) in
                    let __self_0 :=
                      M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "usize" ], γ1_0 |) in
                    let __self_1 :=
                      M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "usize" ], γ1_1 |) in
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                      M.get_associated_function (|
                        Ty.path "core::fmt::Formatter",
                        "debug_struct_field2_finish",
                        [],
                        []
                      |),
                      [
                        M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                        M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "InvalidMask" |) |) |);
                        M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "instance" |) |) |);
                        M.call_closure (|
                          Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ],
                          M.pointer_coercion
                            M.PointerCoercion.Unsize
                            (Ty.apply (Ty.path "&") [] [ Ty.path "usize" ])
                            (Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ]),
                          [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |) ]
                        |);
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (| mk_str (| "instance_layer" |) |)
                        |);
                        M.call_closure (|
                          Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ],
                          M.pointer_coercion
                            M.PointerCoercion.Unsize
                            (Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.apply (Ty.path "&") [] [ Ty.path "usize" ] ])
                            (Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ]),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (| M.borrow (| Pointer.Kind.Ref, __self_1 |) |)
                            |)
                          ]
                        |)
                      ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "openvm_stark_backend::gkr::types::GkrError::NumInstancesMismatch",
                        "given"
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "openvm_stark_backend::gkr::types::GkrError::NumInstancesMismatch",
                        "proof"
                      |) in
                    let __self_0 :=
                      M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "usize" ], γ1_0 |) in
                    let __self_1 :=
                      M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "usize" ], γ1_1 |) in
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                      M.get_associated_function (|
                        Ty.path "core::fmt::Formatter",
                        "debug_struct_field2_finish",
                        [],
                        []
                      |),
                      [
                        M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (| mk_str (| "NumInstancesMismatch" |) |)
                        |);
                        M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "given" |) |) |);
                        M.call_closure (|
                          Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ],
                          M.pointer_coercion
                            M.PointerCoercion.Unsize
                            (Ty.apply (Ty.path "&") [] [ Ty.path "usize" ])
                            (Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ]),
                          [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |) ]
                        |);
                        M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "proof" |) |) |);
                        M.call_closure (|
                          Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ],
                          M.pointer_coercion
                            M.PointerCoercion.Unsize
                            (Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.apply (Ty.path "&") [] [ Ty.path "usize" ] ])
                            (Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ]),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (| M.borrow (| Pointer.Kind.Ref, __self_1 |) |)
                            |)
                          ]
                        |)
                      ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "openvm_stark_backend::gkr::types::GkrError::InvalidSumcheck",
                        "layer"
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "openvm_stark_backend::gkr::types::GkrError::InvalidSumcheck",
                        "source"
                      |) in
                    let __self_0 :=
                      M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "usize" ], γ1_0 |) in
                    let __self_1 :=
                      M.alloc (|
                        Ty.apply
                          (Ty.path "&")
                          []
                          [
                            Ty.apply
                              (Ty.path "openvm_stark_backend::sumcheck::SumcheckError")
                              []
                              [ F ]
                          ],
                        γ1_1
                      |) in
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                      M.get_associated_function (|
                        Ty.path "core::fmt::Formatter",
                        "debug_struct_field2_finish",
                        [],
                        []
                      |),
                      [
                        M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (| mk_str (| "InvalidSumcheck" |) |)
                        |);
                        M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "layer" |) |) |);
                        M.call_closure (|
                          Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ],
                          M.pointer_coercion
                            M.PointerCoercion.Unsize
                            (Ty.apply (Ty.path "&") [] [ Ty.path "usize" ])
                            (Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ]),
                          [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |) ]
                        |);
                        M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "source" |) |) |);
                        M.call_closure (|
                          Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ],
                          M.pointer_coercion
                            M.PointerCoercion.Unsize
                            (Ty.apply
                              (Ty.path "&")
                              []
                              [
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "openvm_stark_backend::sumcheck::SumcheckError")
                                      []
                                      [ F ]
                                  ]
                              ])
                            (Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ]),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (| M.borrow (| Pointer.Kind.Ref, __self_1 |) |)
                            |)
                          ]
                        |)
                      ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "openvm_stark_backend::gkr::types::GkrError::CircuitCheckFailure",
                        "claim"
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "openvm_stark_backend::gkr::types::GkrError::CircuitCheckFailure",
                        "output"
                      |) in
                    let γ1_2 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "openvm_stark_backend::gkr::types::GkrError::CircuitCheckFailure",
                        "layer"
                      |) in
                    let __self_0 := M.alloc (| Ty.apply (Ty.path "&") [] [ F ], γ1_0 |) in
                    let __self_1 := M.alloc (| Ty.apply (Ty.path "&") [] [ F ], γ1_1 |) in
                    let __self_2 :=
                      M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "usize" ], γ1_2 |) in
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                      M.get_associated_function (|
                        Ty.path "core::fmt::Formatter",
                        "debug_struct_field3_finish",
                        [],
                        []
                      |),
                      [
                        M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (| mk_str (| "CircuitCheckFailure" |) |)
                        |);
                        M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "claim" |) |) |);
                        M.call_closure (|
                          Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ],
                          M.pointer_coercion
                            M.PointerCoercion.Unsize
                            (Ty.apply (Ty.path "&") [] [ F ])
                            (Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ]),
                          [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |) ]
                        |);
                        M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "output" |) |) |);
                        M.call_closure (|
                          Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ],
                          M.pointer_coercion
                            M.PointerCoercion.Unsize
                            (Ty.apply (Ty.path "&") [] [ F ])
                            (Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ]),
                          [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_1 |) |) |) ]
                        |);
                        M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "layer" |) |) |);
                        M.call_closure (|
                          Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ],
                          M.pointer_coercion
                            M.PointerCoercion.Unsize
                            (Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.apply (Ty.path "&") [] [ Ty.path "usize" ] ])
                            (Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ]),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (| M.borrow (| Pointer.Kind.Ref, __self_2 |) |)
                            |)
                          ]
                        |)
                      ]
                    |)))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (F : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self F)
          (* Instance *) [ ("fmt", InstanceField.Method (fmt F)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_F_for_openvm_stark_backend_gkr_types_GkrError_F.
    
    Axiom LayerIndex : (Ty.path "openvm_stark_backend::gkr::types::LayerIndex") = (Ty.path "usize").
    
    (*
    Enum Layer
    {
      const_params := [];
      ty_params := [ "F" ];
      variants :=
        [
          {
            name := "GrandProduct";
            item :=
              StructTuple [ Ty.apply (Ty.path "openvm_stark_backend::poly::multi::Mle") [] [ F ] ];
          };
          {
            name := "LogUpGeneric";
            item :=
              StructRecord
                [
                  ("numerators",
                    Ty.apply (Ty.path "openvm_stark_backend::poly::multi::Mle") [] [ F ]);
                  ("denominators",
                    Ty.apply (Ty.path "openvm_stark_backend::poly::multi::Mle") [] [ F ])
                ];
          };
          {
            name := "LogUpMultiplicities";
            item :=
              StructRecord
                [
                  ("numerators",
                    Ty.apply (Ty.path "openvm_stark_backend::poly::multi::Mle") [] [ F ]);
                  ("denominators",
                    Ty.apply (Ty.path "openvm_stark_backend::poly::multi::Mle") [] [ F ])
                ];
          };
          {
            name := "LogUpSingles";
            item :=
              StructRecord
                [
                  ("denominators",
                    Ty.apply (Ty.path "openvm_stark_backend::poly::multi::Mle") [] [ F ])
                ];
          }
        ];
    }
    *)
    
    Axiom IsDiscriminant_Layer_GrandProduct :
      M.IsDiscriminant "openvm_stark_backend::gkr::types::Layer::GrandProduct" 0.
    Axiom IsDiscriminant_Layer_LogUpGeneric :
      M.IsDiscriminant "openvm_stark_backend::gkr::types::Layer::LogUpGeneric" 1.
    Axiom IsDiscriminant_Layer_LogUpMultiplicities :
      M.IsDiscriminant "openvm_stark_backend::gkr::types::Layer::LogUpMultiplicities" 2.
    Axiom IsDiscriminant_Layer_LogUpSingles :
      M.IsDiscriminant "openvm_stark_backend::gkr::types::Layer::LogUpSingles" 3.
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_F_for_openvm_stark_backend_gkr_types_Layer_F.
      Definition Self (F : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "openvm_stark_backend::gkr::types::Layer") [] [ F ].
      
      (* Debug *)
      Definition fmt (F : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.apply (Ty.path "openvm_stark_backend::gkr::types::Layer") [] [ F ] ],
                self
              |) in
            let f :=
              M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "core::fmt::Formatter" ], f |) in
            M.match_operator (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "openvm_stark_backend::gkr::types::Layer::GrandProduct",
                        0
                      |) in
                    let __self_0 :=
                      M.alloc (|
                        Ty.apply
                          (Ty.path "&")
                          []
                          [ Ty.apply (Ty.path "openvm_stark_backend::poly::multi::Mle") [] [ F ] ],
                        γ1_0
                      |) in
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                      M.get_associated_function (|
                        Ty.path "core::fmt::Formatter",
                        "debug_tuple_field1_finish",
                        [],
                        []
                      |),
                      [
                        M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                        M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "GrandProduct" |) |) |);
                        M.call_closure (|
                          Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ],
                          M.pointer_coercion
                            M.PointerCoercion.Unsize
                            (Ty.apply
                              (Ty.path "&")
                              []
                              [
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "openvm_stark_backend::poly::multi::Mle")
                                      []
                                      [ F ]
                                  ]
                              ])
                            (Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ]),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (| M.borrow (| Pointer.Kind.Ref, __self_0 |) |)
                            |)
                          ]
                        |)
                      ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "openvm_stark_backend::gkr::types::Layer::LogUpGeneric",
                        "numerators"
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "openvm_stark_backend::gkr::types::Layer::LogUpGeneric",
                        "denominators"
                      |) in
                    let __self_0 :=
                      M.alloc (|
                        Ty.apply
                          (Ty.path "&")
                          []
                          [ Ty.apply (Ty.path "openvm_stark_backend::poly::multi::Mle") [] [ F ] ],
                        γ1_0
                      |) in
                    let __self_1 :=
                      M.alloc (|
                        Ty.apply
                          (Ty.path "&")
                          []
                          [ Ty.apply (Ty.path "openvm_stark_backend::poly::multi::Mle") [] [ F ] ],
                        γ1_1
                      |) in
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                      M.get_associated_function (|
                        Ty.path "core::fmt::Formatter",
                        "debug_struct_field2_finish",
                        [],
                        []
                      |),
                      [
                        M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                        M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "LogUpGeneric" |) |) |);
                        M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "numerators" |) |) |);
                        M.call_closure (|
                          Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ],
                          M.pointer_coercion
                            M.PointerCoercion.Unsize
                            (Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.apply (Ty.path "openvm_stark_backend::poly::multi::Mle") [] [ F ]
                              ])
                            (Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ]),
                          [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |) ]
                        |);
                        M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "denominators" |) |) |);
                        M.call_closure (|
                          Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ],
                          M.pointer_coercion
                            M.PointerCoercion.Unsize
                            (Ty.apply
                              (Ty.path "&")
                              []
                              [
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "openvm_stark_backend::poly::multi::Mle")
                                      []
                                      [ F ]
                                  ]
                              ])
                            (Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ]),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (| M.borrow (| Pointer.Kind.Ref, __self_1 |) |)
                            |)
                          ]
                        |)
                      ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "openvm_stark_backend::gkr::types::Layer::LogUpMultiplicities",
                        "numerators"
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "openvm_stark_backend::gkr::types::Layer::LogUpMultiplicities",
                        "denominators"
                      |) in
                    let __self_0 :=
                      M.alloc (|
                        Ty.apply
                          (Ty.path "&")
                          []
                          [ Ty.apply (Ty.path "openvm_stark_backend::poly::multi::Mle") [] [ F ] ],
                        γ1_0
                      |) in
                    let __self_1 :=
                      M.alloc (|
                        Ty.apply
                          (Ty.path "&")
                          []
                          [ Ty.apply (Ty.path "openvm_stark_backend::poly::multi::Mle") [] [ F ] ],
                        γ1_1
                      |) in
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                      M.get_associated_function (|
                        Ty.path "core::fmt::Formatter",
                        "debug_struct_field2_finish",
                        [],
                        []
                      |),
                      [
                        M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (| mk_str (| "LogUpMultiplicities" |) |)
                        |);
                        M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "numerators" |) |) |);
                        M.call_closure (|
                          Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ],
                          M.pointer_coercion
                            M.PointerCoercion.Unsize
                            (Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.apply (Ty.path "openvm_stark_backend::poly::multi::Mle") [] [ F ]
                              ])
                            (Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ]),
                          [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |) ]
                        |);
                        M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "denominators" |) |) |);
                        M.call_closure (|
                          Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ],
                          M.pointer_coercion
                            M.PointerCoercion.Unsize
                            (Ty.apply
                              (Ty.path "&")
                              []
                              [
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "openvm_stark_backend::poly::multi::Mle")
                                      []
                                      [ F ]
                                  ]
                              ])
                            (Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ]),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (| M.borrow (| Pointer.Kind.Ref, __self_1 |) |)
                            |)
                          ]
                        |)
                      ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "openvm_stark_backend::gkr::types::Layer::LogUpSingles",
                        "denominators"
                      |) in
                    let __self_0 :=
                      M.alloc (|
                        Ty.apply
                          (Ty.path "&")
                          []
                          [ Ty.apply (Ty.path "openvm_stark_backend::poly::multi::Mle") [] [ F ] ],
                        γ1_0
                      |) in
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                      M.get_associated_function (|
                        Ty.path "core::fmt::Formatter",
                        "debug_struct_field1_finish",
                        [],
                        []
                      |),
                      [
                        M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                        M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "LogUpSingles" |) |) |);
                        M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "denominators" |) |) |);
                        M.call_closure (|
                          Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ],
                          M.pointer_coercion
                            M.PointerCoercion.Unsize
                            (Ty.apply
                              (Ty.path "&")
                              []
                              [
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "openvm_stark_backend::poly::multi::Mle")
                                      []
                                      [ F ]
                                  ]
                              ])
                            (Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ]),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (| M.borrow (| Pointer.Kind.Ref, __self_0 |) |)
                            |)
                          ]
                        |)
                      ]
                    |)))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (F : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self F)
          (* Instance *) [ ("fmt", InstanceField.Method (fmt F)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_F_for_openvm_stark_backend_gkr_types_Layer_F.
    
    Module Impl_core_clone_Clone_where_core_clone_Clone_F_for_openvm_stark_backend_gkr_types_Layer_F.
      Definition Self (F : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "openvm_stark_backend::gkr::types::Layer") [] [ F ].
      
      (* Clone *)
      Definition clone (F : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.apply (Ty.path "openvm_stark_backend::gkr::types::Layer") [] [ F ] ],
                self
              |) in
            M.match_operator (|
              Ty.apply (Ty.path "openvm_stark_backend::gkr::types::Layer") [] [ F ],
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "openvm_stark_backend::gkr::types::Layer::GrandProduct",
                        0
                      |) in
                    let __self_0 :=
                      M.alloc (|
                        Ty.apply
                          (Ty.path "&")
                          []
                          [ Ty.apply (Ty.path "openvm_stark_backend::poly::multi::Mle") [] [ F ] ],
                        γ1_0
                      |) in
                    Value.StructTuple
                      "openvm_stark_backend::gkr::types::Layer::GrandProduct"
                      []
                      [ F ]
                      [
                        M.call_closure (|
                          Ty.apply (Ty.path "openvm_stark_backend::poly::multi::Mle") [] [ F ],
                          M.get_trait_method (|
                            "core::clone::Clone",
                            Ty.apply (Ty.path "openvm_stark_backend::poly::multi::Mle") [] [ F ],
                            [],
                            [],
                            "clone",
                            [],
                            []
                          |),
                          [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |) ]
                        |)
                      ]));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "openvm_stark_backend::gkr::types::Layer::LogUpGeneric",
                        "numerators"
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "openvm_stark_backend::gkr::types::Layer::LogUpGeneric",
                        "denominators"
                      |) in
                    let __self_0 :=
                      M.alloc (|
                        Ty.apply
                          (Ty.path "&")
                          []
                          [ Ty.apply (Ty.path "openvm_stark_backend::poly::multi::Mle") [] [ F ] ],
                        γ1_0
                      |) in
                    let __self_1 :=
                      M.alloc (|
                        Ty.apply
                          (Ty.path "&")
                          []
                          [ Ty.apply (Ty.path "openvm_stark_backend::poly::multi::Mle") [] [ F ] ],
                        γ1_1
                      |) in
                    Value.mkStructRecord
                      "openvm_stark_backend::gkr::types::Layer::LogUpGeneric"
                      []
                      [ F ]
                      [
                        ("numerators",
                          M.call_closure (|
                            Ty.apply (Ty.path "openvm_stark_backend::poly::multi::Mle") [] [ F ],
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.apply (Ty.path "openvm_stark_backend::poly::multi::Mle") [] [ F ],
                              [],
                              [],
                              "clone",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |) ]
                          |));
                        ("denominators",
                          M.call_closure (|
                            Ty.apply (Ty.path "openvm_stark_backend::poly::multi::Mle") [] [ F ],
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.apply (Ty.path "openvm_stark_backend::poly::multi::Mle") [] [ F ],
                              [],
                              [],
                              "clone",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_1 |) |) |) ]
                          |))
                      ]));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "openvm_stark_backend::gkr::types::Layer::LogUpMultiplicities",
                        "numerators"
                      |) in
                    let γ1_1 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "openvm_stark_backend::gkr::types::Layer::LogUpMultiplicities",
                        "denominators"
                      |) in
                    let __self_0 :=
                      M.alloc (|
                        Ty.apply
                          (Ty.path "&")
                          []
                          [ Ty.apply (Ty.path "openvm_stark_backend::poly::multi::Mle") [] [ F ] ],
                        γ1_0
                      |) in
                    let __self_1 :=
                      M.alloc (|
                        Ty.apply
                          (Ty.path "&")
                          []
                          [ Ty.apply (Ty.path "openvm_stark_backend::poly::multi::Mle") [] [ F ] ],
                        γ1_1
                      |) in
                    Value.mkStructRecord
                      "openvm_stark_backend::gkr::types::Layer::LogUpMultiplicities"
                      []
                      [ F ]
                      [
                        ("numerators",
                          M.call_closure (|
                            Ty.apply (Ty.path "openvm_stark_backend::poly::multi::Mle") [] [ F ],
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.apply (Ty.path "openvm_stark_backend::poly::multi::Mle") [] [ F ],
                              [],
                              [],
                              "clone",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |) ]
                          |));
                        ("denominators",
                          M.call_closure (|
                            Ty.apply (Ty.path "openvm_stark_backend::poly::multi::Mle") [] [ F ],
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.apply (Ty.path "openvm_stark_backend::poly::multi::Mle") [] [ F ],
                              [],
                              [],
                              "clone",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_1 |) |) |) ]
                          |))
                      ]));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "openvm_stark_backend::gkr::types::Layer::LogUpSingles",
                        "denominators"
                      |) in
                    let __self_0 :=
                      M.alloc (|
                        Ty.apply
                          (Ty.path "&")
                          []
                          [ Ty.apply (Ty.path "openvm_stark_backend::poly::multi::Mle") [] [ F ] ],
                        γ1_0
                      |) in
                    Value.mkStructRecord
                      "openvm_stark_backend::gkr::types::Layer::LogUpSingles"
                      []
                      [ F ]
                      [
                        ("denominators",
                          M.call_closure (|
                            Ty.apply (Ty.path "openvm_stark_backend::poly::multi::Mle") [] [ F ],
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.apply (Ty.path "openvm_stark_backend::poly::multi::Mle") [] [ F ],
                              [],
                              [],
                              "clone",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |) ]
                          |))
                      ]))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (F : Ty.t),
        M.IsTraitInstance
          "core::clone::Clone"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self F)
          (* Instance *) [ ("clone", InstanceField.Method (clone F)) ].
    End Impl_core_clone_Clone_where_core_clone_Clone_F_for_openvm_stark_backend_gkr_types_Layer_F.
    
    Module Impl_openvm_stark_backend_gkr_types_Layer_F.
      Definition Self (F : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "openvm_stark_backend::gkr::types::Layer") [] [ F ].
      
      (*
          pub fn n_variables(&self) -> usize {
              match self {
                  Self::GrandProduct(mle)
                  | Self::LogUpSingles { denominators: mle }
                  | Self::LogUpMultiplicities {
                      denominators: mle, ..
                  }
                  | Self::LogUpGeneric {
                      denominators: mle, ..
                  } => mle.arity(),
              }
          }
      *)
      Definition n_variables (F : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.apply (Ty.path "openvm_stark_backend::gkr::types::Layer") [] [ F ] ],
                self
              |) in
            M.match_operator (|
              Ty.path "usize",
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.find_or_pattern
                      (Ty.tuple
                        [
                          Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.apply (Ty.path "openvm_stark_backend::poly::multi::Mle") [] [ F ] ]
                        ]) (|
                      γ,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.read (| γ |) in
                            let γ1_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "openvm_stark_backend::gkr::types::Layer::GrandProduct",
                                0
                              |) in
                            let mle :=
                              M.alloc (|
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "openvm_stark_backend::poly::multi::Mle")
                                      []
                                      [ F ]
                                  ],
                                γ1_0
                              |) in
                            Value.Tuple [ mle ]));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.read (| γ |) in
                            let γ1_0 :=
                              M.SubPointer.get_struct_record_field (|
                                γ,
                                "openvm_stark_backend::gkr::types::Layer::LogUpSingles",
                                "denominators"
                              |) in
                            let mle :=
                              M.alloc (|
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "openvm_stark_backend::poly::multi::Mle")
                                      []
                                      [ F ]
                                  ],
                                γ1_0
                              |) in
                            Value.Tuple [ mle ]));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.read (| γ |) in
                            let γ1_0 :=
                              M.SubPointer.get_struct_record_field (|
                                γ,
                                "openvm_stark_backend::gkr::types::Layer::LogUpMultiplicities",
                                "denominators"
                              |) in
                            let mle :=
                              M.alloc (|
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "openvm_stark_backend::poly::multi::Mle")
                                      []
                                      [ F ]
                                  ],
                                γ1_0
                              |) in
                            Value.Tuple [ mle ]));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.read (| γ |) in
                            let γ1_0 :=
                              M.SubPointer.get_struct_record_field (|
                                γ,
                                "openvm_stark_backend::gkr::types::Layer::LogUpGeneric",
                                "denominators"
                              |) in
                            let mle :=
                              M.alloc (|
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "openvm_stark_backend::poly::multi::Mle")
                                      []
                                      [ F ]
                                  ],
                                γ1_0
                              |) in
                            Value.Tuple [ mle ]))
                      ],
                      fun γ =>
                        ltac:(M.monadic
                          match γ with
                          | [ mle ] =>
                            ltac:(M.monadic
                              (M.call_closure (|
                                Ty.path "usize",
                                M.get_trait_method (|
                                  "openvm_stark_backend::poly::multi::MultivariatePolyOracle",
                                  Ty.apply
                                    (Ty.path "openvm_stark_backend::poly::multi::Mle")
                                    []
                                    [ F ],
                                  [],
                                  [ F ],
                                  "arity",
                                  [],
                                  []
                                |),
                                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| mle |) |) |) ]
                              |)))
                          | _ => M.impossible "wrong number of arguments"
                          end)
                    |)))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_n_variables :
        forall (F : Ty.t),
        M.IsAssociatedFunction.C (Self F) "n_variables" (n_variables F).
      Admitted.
      Global Typeclasses Opaque n_variables.
      
      (*
          fn is_output_layer(&self) -> bool {
              self.n_variables() == 0
          }
      *)
      Definition is_output_layer
          (F : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self F in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.apply (Ty.path "openvm_stark_backend::gkr::types::Layer") [] [ F ] ],
                self
              |) in
            M.call_closure (|
              Ty.path "bool",
              BinOp.eq,
              [
                M.call_closure (|
                  Ty.path "usize",
                  M.get_associated_function (|
                    Ty.apply (Ty.path "openvm_stark_backend::gkr::types::Layer") [] [ F ],
                    "n_variables",
                    [],
                    []
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                |);
                Value.Integer IntegerKind.Usize 0
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_is_output_layer :
        forall (F : Ty.t),
        M.IsAssociatedFunction.C (Self F) "is_output_layer" (is_output_layer F).
      Admitted.
      Global Typeclasses Opaque is_output_layer.
      
      (*
          pub fn next_layer(&self) -> Option<Self> {
              if self.is_output_layer() {
                  return None;
              }
      
              let next_layer = match self {
                  Layer::GrandProduct(layer) => Self::next_grand_product_layer(layer),
                  Layer::LogUpGeneric {
                      numerators,
                      denominators,
                  }
                  | Layer::LogUpMultiplicities {
                      numerators,
                      denominators,
                  } => Self::next_logup_layer(MleExpr::Mle(numerators), denominators),
                  Layer::LogUpSingles { denominators } => {
                      Self::next_logup_layer(MleExpr::Constant(F::ONE), denominators)
                  }
              };
              Some(next_layer)
          }
      *)
      Definition next_layer (F : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.apply (Ty.path "openvm_stark_backend::gkr::types::Layer") [] [ F ] ],
                self
              |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::option::Option")
                []
                [ Ty.apply (Ty.path "openvm_stark_backend::gkr::types::Layer") [] [ F ] ]) (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      Ty.tuple [],
                      M.alloc (| Ty.tuple [], Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  Ty.path "bool",
                                  M.call_closure (|
                                    Ty.path "bool",
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "openvm_stark_backend::gkr::types::Layer")
                                        []
                                        [ F ],
                                      "is_output_layer",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (| M.read (| self |) |)
                                      |)
                                    ]
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  Value.StructTuple
                                    "core::option::Option::None"
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "openvm_stark_backend::gkr::types::Layer")
                                        []
                                        [ F ]
                                    ]
                                    []
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (Value.Tuple []))
                      ]
                    |) in
                  let~ next_layer :
                      Ty.apply (Ty.path "openvm_stark_backend::gkr::types::Layer") [] [ F ] :=
                    M.match_operator (|
                      Ty.apply (Ty.path "openvm_stark_backend::gkr::types::Layer") [] [ F ],
                      self,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.read (| γ |) in
                            let γ1_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "openvm_stark_backend::gkr::types::Layer::GrandProduct",
                                0
                              |) in
                            let layer :=
                              M.alloc (|
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "openvm_stark_backend::poly::multi::Mle")
                                      []
                                      [ F ]
                                  ],
                                γ1_0
                              |) in
                            M.call_closure (|
                              Ty.apply (Ty.path "openvm_stark_backend::gkr::types::Layer") [] [ F ],
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "openvm_stark_backend::gkr::types::Layer")
                                  []
                                  [ F ],
                                "next_grand_product_layer",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| layer |) |) |) ]
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.find_or_pattern
                              (Ty.tuple
                                [
                                  Ty.apply
                                    (Ty.path "&")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "openvm_stark_backend::poly::multi::Mle")
                                        []
                                        [ F ]
                                    ];
                                  Ty.apply
                                    (Ty.path "&")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "openvm_stark_backend::poly::multi::Mle")
                                        []
                                        [ F ]
                                    ]
                                ]) (|
                              γ,
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ := M.read (| γ |) in
                                    let γ1_0 :=
                                      M.SubPointer.get_struct_record_field (|
                                        γ,
                                        "openvm_stark_backend::gkr::types::Layer::LogUpGeneric",
                                        "numerators"
                                      |) in
                                    let γ1_1 :=
                                      M.SubPointer.get_struct_record_field (|
                                        γ,
                                        "openvm_stark_backend::gkr::types::Layer::LogUpGeneric",
                                        "denominators"
                                      |) in
                                    let numerators :=
                                      M.alloc (|
                                        Ty.apply
                                          (Ty.path "&")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "openvm_stark_backend::poly::multi::Mle")
                                              []
                                              [ F ]
                                          ],
                                        γ1_0
                                      |) in
                                    let denominators :=
                                      M.alloc (|
                                        Ty.apply
                                          (Ty.path "&")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "openvm_stark_backend::poly::multi::Mle")
                                              []
                                              [ F ]
                                          ],
                                        γ1_1
                                      |) in
                                    Value.Tuple [ numerators; denominators ]));
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ := M.read (| γ |) in
                                    let γ1_0 :=
                                      M.SubPointer.get_struct_record_field (|
                                        γ,
                                        "openvm_stark_backend::gkr::types::Layer::LogUpMultiplicities",
                                        "numerators"
                                      |) in
                                    let γ1_1 :=
                                      M.SubPointer.get_struct_record_field (|
                                        γ,
                                        "openvm_stark_backend::gkr::types::Layer::LogUpMultiplicities",
                                        "denominators"
                                      |) in
                                    let numerators :=
                                      M.alloc (|
                                        Ty.apply
                                          (Ty.path "&")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "openvm_stark_backend::poly::multi::Mle")
                                              []
                                              [ F ]
                                          ],
                                        γ1_0
                                      |) in
                                    let denominators :=
                                      M.alloc (|
                                        Ty.apply
                                          (Ty.path "&")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "openvm_stark_backend::poly::multi::Mle")
                                              []
                                              [ F ]
                                          ],
                                        γ1_1
                                      |) in
                                    Value.Tuple [ numerators; denominators ]))
                              ],
                              fun γ =>
                                ltac:(M.monadic
                                  match γ with
                                  | [ numerators; denominators ] =>
                                    ltac:(M.monadic
                                      (M.call_closure (|
                                        Ty.apply
                                          (Ty.path "openvm_stark_backend::gkr::types::Layer")
                                          []
                                          [ F ],
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "openvm_stark_backend::gkr::types::Layer")
                                            []
                                            [ F ],
                                          "next_logup_layer",
                                          [],
                                          []
                                        |),
                                        [
                                          Value.StructTuple
                                            "openvm_stark_backend::gkr::types::MleExpr::Mle"
                                            []
                                            [ F ]
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.read (| numerators |) |)
                                              |)
                                            ];
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (| M.read (| denominators |) |)
                                          |)
                                        ]
                                      |)))
                                  | _ => M.impossible "wrong number of arguments"
                                  end)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ := M.read (| γ |) in
                            let γ1_0 :=
                              M.SubPointer.get_struct_record_field (|
                                γ,
                                "openvm_stark_backend::gkr::types::Layer::LogUpSingles",
                                "denominators"
                              |) in
                            let denominators :=
                              M.alloc (|
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "openvm_stark_backend::poly::multi::Mle")
                                      []
                                      [ F ]
                                  ],
                                γ1_0
                              |) in
                            M.call_closure (|
                              Ty.apply (Ty.path "openvm_stark_backend::gkr::types::Layer") [] [ F ],
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "openvm_stark_backend::gkr::types::Layer")
                                  []
                                  [ F ],
                                "next_logup_layer",
                                [],
                                []
                              |),
                              [
                                Value.StructTuple
                                  "openvm_stark_backend::gkr::types::MleExpr::Constant"
                                  []
                                  [ F ]
                                  [
                                    M.read (|
                                      get_constant (| "p3_field::field::FieldAlgebra::ONE", F |)
                                    |)
                                  ];
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (| M.read (| denominators |) |)
                                |)
                              ]
                            |)))
                      ]
                    |) in
                  M.alloc (|
                    Ty.apply
                      (Ty.path "core::option::Option")
                      []
                      [ Ty.apply (Ty.path "openvm_stark_backend::gkr::types::Layer") [] [ F ] ],
                    Value.StructTuple
                      "core::option::Option::Some"
                      []
                      [ Ty.apply (Ty.path "openvm_stark_backend::gkr::types::Layer") [] [ F ] ]
                      [ M.read (| next_layer |) ]
                  |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_next_layer :
        forall (F : Ty.t),
        M.IsAssociatedFunction.C (Self F) "next_layer" (next_layer F).
      Admitted.
      Global Typeclasses Opaque next_layer.
      
      (*
          fn next_grand_product_layer(layer: &Mle<F>) -> Layer<F> {
              let res = layer
                  .chunks_exact(2) // Process in chunks of 2 elements
                  .map(|chunk| chunk[0] * chunk[1]) // Multiply each pair
                  .collect();
              Layer::GrandProduct(Mle::new(res))
          }
      *)
      Definition next_grand_product_layer
          (F : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self F in
        match ε, τ, α with
        | [], [], [ layer ] =>
          ltac:(M.monadic
            (let layer :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.apply (Ty.path "openvm_stark_backend::poly::multi::Mle") [] [ F ] ],
                layer
              |) in
            M.read (|
              let~ res :
                  Ty.apply (Ty.path "alloc::vec::Vec") [] [ F; Ty.path "alloc::alloc::Global" ] :=
                M.call_closure (|
                  Ty.apply (Ty.path "alloc::vec::Vec") [] [ F; Ty.path "alloc::alloc::Global" ],
                  M.get_trait_method (|
                    "core::iter::traits::iterator::Iterator",
                    Ty.apply
                      (Ty.path "core::iter::adapters::map::Map")
                      []
                      [
                        Ty.apply (Ty.path "core::slice::iter::ChunksExact") [] [ F ];
                        Ty.function
                          [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ F ] ] ]
                          F
                      ],
                    [],
                    [],
                    "collect",
                    [],
                    [ Ty.apply (Ty.path "alloc::vec::Vec") [] [ F; Ty.path "alloc::alloc::Global" ]
                    ]
                  |),
                  [
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::iter::adapters::map::Map")
                        []
                        [
                          Ty.apply (Ty.path "core::slice::iter::ChunksExact") [] [ F ];
                          Ty.function
                            [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ F ] ] ]
                            F
                        ],
                      M.get_trait_method (|
                        "core::iter::traits::iterator::Iterator",
                        Ty.apply (Ty.path "core::slice::iter::ChunksExact") [] [ F ],
                        [],
                        [],
                        "map",
                        [],
                        [
                          F;
                          Ty.function
                            [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ F ] ] ]
                            F
                        ]
                      |),
                      [
                        M.call_closure (|
                          Ty.apply (Ty.path "core::slice::iter::ChunksExact") [] [ F ],
                          M.get_associated_function (|
                            Ty.apply (Ty.path "slice") [] [ F ],
                            "chunks_exact",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.call_closure (|
                                  Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ F ] ],
                                  M.get_trait_method (|
                                    "core::ops::deref::Deref",
                                    Ty.apply
                                      (Ty.path "openvm_stark_backend::poly::multi::Mle")
                                      []
                                      [ F ],
                                    [],
                                    [],
                                    "deref",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (| M.read (| layer |) |)
                                    |)
                                  ]
                                |)
                              |)
                            |);
                            Value.Integer IntegerKind.Usize 2
                          ]
                        |);
                        M.closure
                          (fun γ =>
                            ltac:(M.monadic
                              match γ with
                              | [ α0 ] =>
                                ltac:(M.monadic
                                  (M.match_operator (|
                                    F,
                                    M.alloc (|
                                      Ty.apply
                                        (Ty.path "&")
                                        []
                                        [ Ty.apply (Ty.path "slice") [] [ F ] ],
                                      α0
                                    |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let chunk :=
                                            M.copy (|
                                              Ty.apply
                                                (Ty.path "&")
                                                []
                                                [ Ty.apply (Ty.path "slice") [] [ F ] ],
                                              γ
                                            |) in
                                          M.call_closure (|
                                            F,
                                            M.get_trait_method (|
                                              "core::ops::arith::Mul",
                                              F,
                                              [],
                                              [ F ],
                                              "mul",
                                              [],
                                              []
                                            |),
                                            [
                                              M.read (|
                                                M.SubPointer.get_array_field (|
                                                  M.deref (| M.read (| chunk |) |),
                                                  Value.Integer IntegerKind.Usize 0
                                                |)
                                              |);
                                              M.read (|
                                                M.SubPointer.get_array_field (|
                                                  M.deref (| M.read (| chunk |) |),
                                                  Value.Integer IntegerKind.Usize 1
                                                |)
                                              |)
                                            ]
                                          |)))
                                    ]
                                  |)))
                              | _ => M.impossible "wrong number of arguments"
                              end))
                      ]
                    |)
                  ]
                |) in
              M.alloc (|
                Ty.apply (Ty.path "openvm_stark_backend::gkr::types::Layer") [] [ F ],
                Value.StructTuple
                  "openvm_stark_backend::gkr::types::Layer::GrandProduct"
                  []
                  [ F ]
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "openvm_stark_backend::poly::multi::Mle") [] [ F ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "openvm_stark_backend::poly::multi::Mle") [] [ F ],
                        "new",
                        [],
                        []
                      |),
                      [ M.read (| res |) ]
                    |)
                  ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_next_grand_product_layer :
        forall (F : Ty.t),
        M.IsAssociatedFunction.C (Self F) "next_grand_product_layer" (next_grand_product_layer F).
      Admitted.
      Global Typeclasses Opaque next_grand_product_layer.
      
      (*
          fn next_logup_layer(numerators: MleExpr<'_, F>, denominators: &Mle<F>) -> Layer<F> {
              let half_n = 1 << (denominators.arity() - 1);
              let mut next_numerators = Vec::with_capacity(half_n);
              let mut next_denominators = Vec::with_capacity(half_n);
      
              for i in 0..half_n {
                  let a = Fraction::new(numerators[i * 2], denominators[i * 2]);
                  let b = Fraction::new(numerators[i * 2 + 1], denominators[i * 2 + 1]);
                  let res = a + b;
                  next_numerators.push(res.numerator);
                  next_denominators.push(res.denominator);
              }
      
              Layer::LogUpGeneric {
                  numerators: Mle::new(next_numerators),
                  denominators: Mle::new(next_denominators),
              }
          }
      *)
      Definition next_logup_layer
          (F : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self F in
        match ε, τ, α with
        | [], [], [ numerators; denominators ] =>
          ltac:(M.monadic
            (let numerators :=
              M.alloc (|
                Ty.apply (Ty.path "openvm_stark_backend::gkr::types::MleExpr") [] [ F ],
                numerators
              |) in
            let denominators :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.apply (Ty.path "openvm_stark_backend::poly::multi::Mle") [] [ F ] ],
                denominators
              |) in
            M.read (|
              let~ half_n : Ty.path "usize" :=
                M.call_closure (|
                  Ty.path "usize",
                  BinOp.Wrap.shl,
                  [
                    Value.Integer IntegerKind.Usize 1;
                    M.call_closure (|
                      Ty.path "usize",
                      BinOp.Wrap.sub,
                      [
                        M.call_closure (|
                          Ty.path "usize",
                          M.get_trait_method (|
                            "openvm_stark_backend::poly::multi::MultivariatePolyOracle",
                            Ty.apply (Ty.path "openvm_stark_backend::poly::multi::Mle") [] [ F ],
                            [],
                            [ F ],
                            "arity",
                            [],
                            []
                          |),
                          [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| denominators |) |) |)
                          ]
                        |);
                        Value.Integer IntegerKind.Usize 1
                      ]
                    |)
                  ]
                |) in
              let~ next_numerators :
                  Ty.apply (Ty.path "alloc::vec::Vec") [] [ F; Ty.path "alloc::alloc::Global" ] :=
                M.call_closure (|
                  Ty.apply (Ty.path "alloc::vec::Vec") [] [ F; Ty.path "alloc::alloc::Global" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloc::vec::Vec") [] [ F; Ty.path "alloc::alloc::Global" ],
                    "with_capacity",
                    [],
                    []
                  |),
                  [ M.read (| half_n |) ]
                |) in
              let~ next_denominators :
                  Ty.apply (Ty.path "alloc::vec::Vec") [] [ F; Ty.path "alloc::alloc::Global" ] :=
                M.call_closure (|
                  Ty.apply (Ty.path "alloc::vec::Vec") [] [ F; Ty.path "alloc::alloc::Global" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloc::vec::Vec") [] [ F; Ty.path "alloc::alloc::Global" ],
                    "with_capacity",
                    [],
                    []
                  |),
                  [ M.read (| half_n |) ]
                |) in
              let~ _ : Ty.tuple [] :=
                M.read (|
                  M.use
                    (M.alloc (|
                      Ty.tuple [],
                      M.match_operator (|
                        Ty.tuple [],
                        M.alloc (|
                          Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                          M.call_closure (|
                            Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                            M.get_trait_method (|
                              "core::iter::traits::collect::IntoIterator",
                              Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                              [],
                              [],
                              "into_iter",
                              [],
                              []
                            |),
                            [
                              Value.mkStructRecord
                                "core::ops::range::Range"
                                []
                                [ Ty.path "usize" ]
                                [
                                  ("start", Value.Integer IntegerKind.Usize 0);
                                  ("end_", M.read (| half_n |))
                                ]
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let iter :=
                                M.copy (|
                                  Ty.apply
                                    (Ty.path "core::ops::range::Range")
                                    []
                                    [ Ty.path "usize" ],
                                  γ
                                |) in
                              M.read (|
                                M.loop (|
                                  Ty.tuple [],
                                  ltac:(M.monadic
                                    (let~ _ : Ty.tuple [] :=
                                      M.match_operator (|
                                        Ty.tuple [],
                                        M.alloc (|
                                          Ty.apply
                                            (Ty.path "core::option::Option")
                                            []
                                            [ Ty.path "usize" ],
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::option::Option")
                                              []
                                              [ Ty.path "usize" ],
                                            M.get_trait_method (|
                                              "core::iter::traits::iterator::Iterator",
                                              Ty.apply
                                                (Ty.path "core::ops::range::Range")
                                                []
                                                [ Ty.path "usize" ],
                                              [],
                                              [],
                                              "next",
                                              [],
                                              []
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.MutRef,
                                                M.deref (|
                                                  M.borrow (| Pointer.Kind.MutRef, iter |)
                                                |)
                                              |)
                                            ]
                                          |)
                                        |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let _ :=
                                                M.is_struct_tuple (|
                                                  γ,
                                                  "core::option::Option::None"
                                                |) in
                                              M.never_to_any (| M.read (| M.break (||) |) |)));
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let γ0_0 :=
                                                M.SubPointer.get_struct_tuple_field (|
                                                  γ,
                                                  "core::option::Option::Some",
                                                  0
                                                |) in
                                              let i := M.copy (| Ty.path "usize", γ0_0 |) in
                                              M.read (|
                                                let~ a :
                                                    Ty.apply
                                                      (Ty.path
                                                        "openvm_stark_backend::poly::uni::Fraction")
                                                      []
                                                      [ F ] :=
                                                  M.call_closure (|
                                                    Ty.apply
                                                      (Ty.path
                                                        "openvm_stark_backend::poly::uni::Fraction")
                                                      []
                                                      [ F ],
                                                    M.get_associated_function (|
                                                      Ty.apply
                                                        (Ty.path
                                                          "openvm_stark_backend::poly::uni::Fraction")
                                                        []
                                                        [ F ],
                                                      "new",
                                                      [],
                                                      []
                                                    |),
                                                    [
                                                      M.read (|
                                                        M.deref (|
                                                          M.call_closure (|
                                                            Ty.apply (Ty.path "&") [] [ F ],
                                                            M.get_trait_method (|
                                                              "core::ops::index::Index",
                                                              Ty.apply
                                                                (Ty.path
                                                                  "openvm_stark_backend::gkr::types::MleExpr")
                                                                []
                                                                [ F ],
                                                              [],
                                                              [ Ty.path "usize" ],
                                                              "index",
                                                              [],
                                                              []
                                                            |),
                                                            [
                                                              M.borrow (|
                                                                Pointer.Kind.Ref,
                                                                numerators
                                                              |);
                                                              M.call_closure (|
                                                                Ty.path "usize",
                                                                BinOp.Wrap.mul,
                                                                [
                                                                  M.read (| i |);
                                                                  Value.Integer IntegerKind.Usize 2
                                                                ]
                                                              |)
                                                            ]
                                                          |)
                                                        |)
                                                      |);
                                                      M.read (|
                                                        M.SubPointer.get_array_field (|
                                                          M.deref (|
                                                            M.call_closure (|
                                                              Ty.apply
                                                                (Ty.path "&")
                                                                []
                                                                [
                                                                  Ty.apply
                                                                    (Ty.path "slice")
                                                                    []
                                                                    [ F ]
                                                                ],
                                                              M.get_trait_method (|
                                                                "core::ops::deref::Deref",
                                                                Ty.apply
                                                                  (Ty.path
                                                                    "openvm_stark_backend::poly::multi::Mle")
                                                                  []
                                                                  [ F ],
                                                                [],
                                                                [],
                                                                "deref",
                                                                [],
                                                                []
                                                              |),
                                                              [
                                                                M.borrow (|
                                                                  Pointer.Kind.Ref,
                                                                  M.deref (|
                                                                    M.read (| denominators |)
                                                                  |)
                                                                |)
                                                              ]
                                                            |)
                                                          |),
                                                          M.call_closure (|
                                                            Ty.path "usize",
                                                            BinOp.Wrap.mul,
                                                            [
                                                              M.read (| i |);
                                                              Value.Integer IntegerKind.Usize 2
                                                            ]
                                                          |)
                                                        |)
                                                      |)
                                                    ]
                                                  |) in
                                                let~ b :
                                                    Ty.apply
                                                      (Ty.path
                                                        "openvm_stark_backend::poly::uni::Fraction")
                                                      []
                                                      [ F ] :=
                                                  M.call_closure (|
                                                    Ty.apply
                                                      (Ty.path
                                                        "openvm_stark_backend::poly::uni::Fraction")
                                                      []
                                                      [ F ],
                                                    M.get_associated_function (|
                                                      Ty.apply
                                                        (Ty.path
                                                          "openvm_stark_backend::poly::uni::Fraction")
                                                        []
                                                        [ F ],
                                                      "new",
                                                      [],
                                                      []
                                                    |),
                                                    [
                                                      M.read (|
                                                        M.deref (|
                                                          M.call_closure (|
                                                            Ty.apply (Ty.path "&") [] [ F ],
                                                            M.get_trait_method (|
                                                              "core::ops::index::Index",
                                                              Ty.apply
                                                                (Ty.path
                                                                  "openvm_stark_backend::gkr::types::MleExpr")
                                                                []
                                                                [ F ],
                                                              [],
                                                              [ Ty.path "usize" ],
                                                              "index",
                                                              [],
                                                              []
                                                            |),
                                                            [
                                                              M.borrow (|
                                                                Pointer.Kind.Ref,
                                                                numerators
                                                              |);
                                                              M.call_closure (|
                                                                Ty.path "usize",
                                                                BinOp.Wrap.add,
                                                                [
                                                                  M.call_closure (|
                                                                    Ty.path "usize",
                                                                    BinOp.Wrap.mul,
                                                                    [
                                                                      M.read (| i |);
                                                                      Value.Integer
                                                                        IntegerKind.Usize
                                                                        2
                                                                    ]
                                                                  |);
                                                                  Value.Integer IntegerKind.Usize 1
                                                                ]
                                                              |)
                                                            ]
                                                          |)
                                                        |)
                                                      |);
                                                      M.read (|
                                                        M.SubPointer.get_array_field (|
                                                          M.deref (|
                                                            M.call_closure (|
                                                              Ty.apply
                                                                (Ty.path "&")
                                                                []
                                                                [
                                                                  Ty.apply
                                                                    (Ty.path "slice")
                                                                    []
                                                                    [ F ]
                                                                ],
                                                              M.get_trait_method (|
                                                                "core::ops::deref::Deref",
                                                                Ty.apply
                                                                  (Ty.path
                                                                    "openvm_stark_backend::poly::multi::Mle")
                                                                  []
                                                                  [ F ],
                                                                [],
                                                                [],
                                                                "deref",
                                                                [],
                                                                []
                                                              |),
                                                              [
                                                                M.borrow (|
                                                                  Pointer.Kind.Ref,
                                                                  M.deref (|
                                                                    M.read (| denominators |)
                                                                  |)
                                                                |)
                                                              ]
                                                            |)
                                                          |),
                                                          M.call_closure (|
                                                            Ty.path "usize",
                                                            BinOp.Wrap.add,
                                                            [
                                                              M.call_closure (|
                                                                Ty.path "usize",
                                                                BinOp.Wrap.mul,
                                                                [
                                                                  M.read (| i |);
                                                                  Value.Integer IntegerKind.Usize 2
                                                                ]
                                                              |);
                                                              Value.Integer IntegerKind.Usize 1
                                                            ]
                                                          |)
                                                        |)
                                                      |)
                                                    ]
                                                  |) in
                                                let~ res :
                                                    Ty.apply
                                                      (Ty.path
                                                        "openvm_stark_backend::poly::uni::Fraction")
                                                      []
                                                      [ F ] :=
                                                  M.call_closure (|
                                                    Ty.apply
                                                      (Ty.path
                                                        "openvm_stark_backend::poly::uni::Fraction")
                                                      []
                                                      [ F ],
                                                    M.get_trait_method (|
                                                      "core::ops::arith::Add",
                                                      Ty.apply
                                                        (Ty.path
                                                          "openvm_stark_backend::poly::uni::Fraction")
                                                        []
                                                        [ F ],
                                                      [],
                                                      [
                                                        Ty.apply
                                                          (Ty.path
                                                            "openvm_stark_backend::poly::uni::Fraction")
                                                          []
                                                          [ F ]
                                                      ],
                                                      "add",
                                                      [],
                                                      []
                                                    |),
                                                    [ M.read (| a |); M.read (| b |) ]
                                                  |) in
                                                let~ _ : Ty.tuple [] :=
                                                  M.call_closure (|
                                                    Ty.tuple [],
                                                    M.get_associated_function (|
                                                      Ty.apply
                                                        (Ty.path "alloc::vec::Vec")
                                                        []
                                                        [ F; Ty.path "alloc::alloc::Global" ],
                                                      "push",
                                                      [],
                                                      []
                                                    |),
                                                    [
                                                      M.borrow (|
                                                        Pointer.Kind.MutRef,
                                                        next_numerators
                                                      |);
                                                      M.read (|
                                                        M.SubPointer.get_struct_record_field (|
                                                          res,
                                                          "openvm_stark_backend::poly::uni::Fraction",
                                                          "numerator"
                                                        |)
                                                      |)
                                                    ]
                                                  |) in
                                                let~ _ : Ty.tuple [] :=
                                                  M.call_closure (|
                                                    Ty.tuple [],
                                                    M.get_associated_function (|
                                                      Ty.apply
                                                        (Ty.path "alloc::vec::Vec")
                                                        []
                                                        [ F; Ty.path "alloc::alloc::Global" ],
                                                      "push",
                                                      [],
                                                      []
                                                    |),
                                                    [
                                                      M.borrow (|
                                                        Pointer.Kind.MutRef,
                                                        next_denominators
                                                      |);
                                                      M.read (|
                                                        M.SubPointer.get_struct_record_field (|
                                                          res,
                                                          "openvm_stark_backend::poly::uni::Fraction",
                                                          "denominator"
                                                        |)
                                                      |)
                                                    ]
                                                  |) in
                                                M.alloc (| Ty.tuple [], Value.Tuple [] |)
                                              |)))
                                        ]
                                      |) in
                                    M.alloc (| Ty.tuple [], Value.Tuple [] |)))
                                |)
                              |)))
                        ]
                      |)
                    |))
                |) in
              M.alloc (|
                Ty.apply (Ty.path "openvm_stark_backend::gkr::types::Layer") [] [ F ],
                Value.mkStructRecord
                  "openvm_stark_backend::gkr::types::Layer::LogUpGeneric"
                  []
                  [ F ]
                  [
                    ("numerators",
                      M.call_closure (|
                        Ty.apply (Ty.path "openvm_stark_backend::poly::multi::Mle") [] [ F ],
                        M.get_associated_function (|
                          Ty.apply (Ty.path "openvm_stark_backend::poly::multi::Mle") [] [ F ],
                          "new",
                          [],
                          []
                        |),
                        [ M.read (| next_numerators |) ]
                      |));
                    ("denominators",
                      M.call_closure (|
                        Ty.apply (Ty.path "openvm_stark_backend::poly::multi::Mle") [] [ F ],
                        M.get_associated_function (|
                          Ty.apply (Ty.path "openvm_stark_backend::poly::multi::Mle") [] [ F ],
                          "new",
                          [],
                          []
                        |),
                        [ M.read (| next_denominators |) ]
                      |))
                  ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_next_logup_layer :
        forall (F : Ty.t),
        M.IsAssociatedFunction.C (Self F) "next_logup_layer" (next_logup_layer F).
      Admitted.
      Global Typeclasses Opaque next_logup_layer.
      
      (*
          pub fn try_into_output_layer_values(self) -> Result<Vec<F>, NotOutputLayerError> {
              if !self.is_output_layer() {
                  return Err(NotOutputLayerError);
              }
      
              Ok(match self {
                  Layer::LogUpSingles { denominators } => {
                      let numerator = F::ONE;
                      let denominator = denominators[0];
                      vec![numerator, denominator]
                  }
                  Layer::LogUpGeneric {
                      numerators,
                      denominators,
                  }
                  | Layer::LogUpMultiplicities {
                      numerators,
                      denominators,
                  } => {
                      let numerator = numerators[0];
                      let denominator = denominators[0];
                      vec![numerator, denominator]
                  }
                  Layer::GrandProduct(col) => {
                      vec![col[0]]
                  }
              })
          }
      *)
      Definition try_into_output_layer_values
          (F : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self F in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "openvm_stark_backend::gkr::types::Layer") [] [ F ],
                self
              |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "alloc::vec::Vec") [] [ F; Ty.path "alloc::alloc::Global" ];
                  Ty.path "openvm_stark_backend::gkr::types::NotOutputLayerError"
                ]) (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      Ty.tuple [],
                      M.alloc (| Ty.tuple [], Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  Ty.path "bool",
                                  UnOp.not (|
                                    M.call_closure (|
                                      Ty.path "bool",
                                      M.get_associated_function (|
                                        Ty.apply
                                          (Ty.path "openvm_stark_backend::gkr::types::Layer")
                                          []
                                          [ F ],
                                        "is_output_layer",
                                        [],
                                        []
                                      |),
                                      [ M.borrow (| Pointer.Kind.Ref, self |) ]
                                    |)
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  Value.StructTuple
                                    "core::result::Result::Err"
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "alloc::vec::Vec")
                                        []
                                        [ F; Ty.path "alloc::alloc::Global" ];
                                      Ty.path
                                        "openvm_stark_backend::gkr::types::NotOutputLayerError"
                                    ]
                                    [
                                      Value.StructTuple
                                        "openvm_stark_backend::gkr::types::NotOutputLayerError"
                                        []
                                        []
                                        []
                                    ]
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (Value.Tuple []))
                      ]
                    |) in
                  M.alloc (|
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [
                        Ty.apply
                          (Ty.path "alloc::vec::Vec")
                          []
                          [ F; Ty.path "alloc::alloc::Global" ];
                        Ty.path "openvm_stark_backend::gkr::types::NotOutputLayerError"
                      ],
                    Value.StructTuple
                      "core::result::Result::Ok"
                      []
                      [
                        Ty.apply
                          (Ty.path "alloc::vec::Vec")
                          []
                          [ F; Ty.path "alloc::alloc::Global" ];
                        Ty.path "openvm_stark_backend::gkr::types::NotOutputLayerError"
                      ]
                      [
                        M.match_operator (|
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            []
                            [ F; Ty.path "alloc::alloc::Global" ],
                          self,
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.SubPointer.get_struct_record_field (|
                                    γ,
                                    "openvm_stark_backend::gkr::types::Layer::LogUpSingles",
                                    "denominators"
                                  |) in
                                let denominators :=
                                  M.copy (|
                                    Ty.apply
                                      (Ty.path "openvm_stark_backend::poly::multi::Mle")
                                      []
                                      [ F ],
                                    γ0_0
                                  |) in
                                M.read (|
                                  let~ numerator : F :=
                                    M.read (|
                                      get_constant (| "p3_field::field::FieldAlgebra::ONE", F |)
                                    |) in
                                  let~ denominator : F :=
                                    M.read (|
                                      M.SubPointer.get_array_field (|
                                        M.deref (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "&")
                                              []
                                              [ Ty.apply (Ty.path "slice") [] [ F ] ],
                                            M.get_trait_method (|
                                              "core::ops::deref::Deref",
                                              Ty.apply
                                                (Ty.path "openvm_stark_backend::poly::multi::Mle")
                                                []
                                                [ F ],
                                              [],
                                              [],
                                              "deref",
                                              [],
                                              []
                                            |),
                                            [ M.borrow (| Pointer.Kind.Ref, denominators |) ]
                                          |)
                                        |),
                                        Value.Integer IntegerKind.Usize 0
                                      |)
                                    |) in
                                  M.alloc (|
                                    Ty.apply
                                      (Ty.path "alloc::vec::Vec")
                                      []
                                      [ F; Ty.path "alloc::alloc::Global" ],
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "alloc::vec::Vec")
                                        []
                                        [ F; Ty.path "alloc::alloc::Global" ],
                                      M.get_associated_function (|
                                        Ty.apply (Ty.path "slice") [] [ F ],
                                        "into_vec",
                                        [],
                                        [ Ty.path "alloc::alloc::Global" ]
                                      |),
                                      [
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "alloc::boxed::Box")
                                            []
                                            [
                                              Ty.apply (Ty.path "slice") [] [ F ];
                                              Ty.path "alloc::alloc::Global"
                                            ],
                                          M.pointer_coercion
                                            M.PointerCoercion.Unsize
                                            (Ty.apply
                                              (Ty.path "alloc::boxed::Box")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "array")
                                                  [ Value.Integer IntegerKind.Usize 2 ]
                                                  [ F ];
                                                Ty.path "alloc::alloc::Global"
                                              ])
                                            (Ty.apply
                                              (Ty.path "alloc::boxed::Box")
                                              []
                                              [
                                                Ty.apply (Ty.path "slice") [] [ F ];
                                                Ty.path "alloc::alloc::Global"
                                              ]),
                                          [
                                            M.read (|
                                              M.call_closure (|
                                                Ty.apply
                                                  (Ty.path "alloc::boxed::Box")
                                                  []
                                                  [
                                                    Ty.apply
                                                      (Ty.path "array")
                                                      [ Value.Integer IntegerKind.Usize 2 ]
                                                      [ F ];
                                                    Ty.path "alloc::alloc::Global"
                                                  ],
                                                M.get_associated_function (|
                                                  Ty.apply
                                                    (Ty.path "alloc::boxed::Box")
                                                    []
                                                    [
                                                      Ty.apply
                                                        (Ty.path "array")
                                                        [ Value.Integer IntegerKind.Usize 2 ]
                                                        [ F ];
                                                      Ty.path "alloc::alloc::Global"
                                                    ],
                                                  "new",
                                                  [],
                                                  []
                                                |),
                                                [
                                                  M.alloc (|
                                                    Ty.apply
                                                      (Ty.path "array")
                                                      [ Value.Integer IntegerKind.Usize 2 ]
                                                      [ F ],
                                                    Value.Array
                                                      [
                                                        M.read (| numerator |);
                                                        M.read (| denominator |)
                                                      ]
                                                  |)
                                                ]
                                              |)
                                            |)
                                          ]
                                        |)
                                      ]
                                    |)
                                  |)
                                |)));
                            fun γ =>
                              ltac:(M.monadic
                                (M.find_or_pattern
                                  (Ty.tuple
                                    [
                                      Ty.apply
                                        (Ty.path "openvm_stark_backend::poly::multi::Mle")
                                        []
                                        [ F ];
                                      Ty.apply
                                        (Ty.path "openvm_stark_backend::poly::multi::Mle")
                                        []
                                        [ F ]
                                    ]) (|
                                  γ,
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 :=
                                          M.SubPointer.get_struct_record_field (|
                                            γ,
                                            "openvm_stark_backend::gkr::types::Layer::LogUpGeneric",
                                            "numerators"
                                          |) in
                                        let γ0_1 :=
                                          M.SubPointer.get_struct_record_field (|
                                            γ,
                                            "openvm_stark_backend::gkr::types::Layer::LogUpGeneric",
                                            "denominators"
                                          |) in
                                        let numerators :=
                                          M.copy (|
                                            Ty.apply
                                              (Ty.path "openvm_stark_backend::poly::multi::Mle")
                                              []
                                              [ F ],
                                            γ0_0
                                          |) in
                                        let denominators :=
                                          M.copy (|
                                            Ty.apply
                                              (Ty.path "openvm_stark_backend::poly::multi::Mle")
                                              []
                                              [ F ],
                                            γ0_1
                                          |) in
                                        Value.Tuple [ numerators; denominators ]));
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 :=
                                          M.SubPointer.get_struct_record_field (|
                                            γ,
                                            "openvm_stark_backend::gkr::types::Layer::LogUpMultiplicities",
                                            "numerators"
                                          |) in
                                        let γ0_1 :=
                                          M.SubPointer.get_struct_record_field (|
                                            γ,
                                            "openvm_stark_backend::gkr::types::Layer::LogUpMultiplicities",
                                            "denominators"
                                          |) in
                                        let numerators :=
                                          M.copy (|
                                            Ty.apply
                                              (Ty.path "openvm_stark_backend::poly::multi::Mle")
                                              []
                                              [ F ],
                                            γ0_0
                                          |) in
                                        let denominators :=
                                          M.copy (|
                                            Ty.apply
                                              (Ty.path "openvm_stark_backend::poly::multi::Mle")
                                              []
                                              [ F ],
                                            γ0_1
                                          |) in
                                        Value.Tuple [ numerators; denominators ]))
                                  ],
                                  fun γ =>
                                    ltac:(M.monadic
                                      match γ with
                                      | [ numerators; denominators ] =>
                                        ltac:(M.monadic
                                          (M.read (|
                                            let~ numerator : F :=
                                              M.read (|
                                                M.SubPointer.get_array_field (|
                                                  M.deref (|
                                                    M.call_closure (|
                                                      Ty.apply
                                                        (Ty.path "&")
                                                        []
                                                        [ Ty.apply (Ty.path "slice") [] [ F ] ],
                                                      M.get_trait_method (|
                                                        "core::ops::deref::Deref",
                                                        Ty.apply
                                                          (Ty.path
                                                            "openvm_stark_backend::poly::multi::Mle")
                                                          []
                                                          [ F ],
                                                        [],
                                                        [],
                                                        "deref",
                                                        [],
                                                        []
                                                      |),
                                                      [ M.borrow (| Pointer.Kind.Ref, numerators |)
                                                      ]
                                                    |)
                                                  |),
                                                  Value.Integer IntegerKind.Usize 0
                                                |)
                                              |) in
                                            let~ denominator : F :=
                                              M.read (|
                                                M.SubPointer.get_array_field (|
                                                  M.deref (|
                                                    M.call_closure (|
                                                      Ty.apply
                                                        (Ty.path "&")
                                                        []
                                                        [ Ty.apply (Ty.path "slice") [] [ F ] ],
                                                      M.get_trait_method (|
                                                        "core::ops::deref::Deref",
                                                        Ty.apply
                                                          (Ty.path
                                                            "openvm_stark_backend::poly::multi::Mle")
                                                          []
                                                          [ F ],
                                                        [],
                                                        [],
                                                        "deref",
                                                        [],
                                                        []
                                                      |),
                                                      [
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          denominators
                                                        |)
                                                      ]
                                                    |)
                                                  |),
                                                  Value.Integer IntegerKind.Usize 0
                                                |)
                                              |) in
                                            M.alloc (|
                                              Ty.apply
                                                (Ty.path "alloc::vec::Vec")
                                                []
                                                [ F; Ty.path "alloc::alloc::Global" ],
                                              M.call_closure (|
                                                Ty.apply
                                                  (Ty.path "alloc::vec::Vec")
                                                  []
                                                  [ F; Ty.path "alloc::alloc::Global" ],
                                                M.get_associated_function (|
                                                  Ty.apply (Ty.path "slice") [] [ F ],
                                                  "into_vec",
                                                  [],
                                                  [ Ty.path "alloc::alloc::Global" ]
                                                |),
                                                [
                                                  M.call_closure (|
                                                    Ty.apply
                                                      (Ty.path "alloc::boxed::Box")
                                                      []
                                                      [
                                                        Ty.apply (Ty.path "slice") [] [ F ];
                                                        Ty.path "alloc::alloc::Global"
                                                      ],
                                                    M.pointer_coercion
                                                      M.PointerCoercion.Unsize
                                                      (Ty.apply
                                                        (Ty.path "alloc::boxed::Box")
                                                        []
                                                        [
                                                          Ty.apply
                                                            (Ty.path "array")
                                                            [ Value.Integer IntegerKind.Usize 2 ]
                                                            [ F ];
                                                          Ty.path "alloc::alloc::Global"
                                                        ])
                                                      (Ty.apply
                                                        (Ty.path "alloc::boxed::Box")
                                                        []
                                                        [
                                                          Ty.apply (Ty.path "slice") [] [ F ];
                                                          Ty.path "alloc::alloc::Global"
                                                        ]),
                                                    [
                                                      M.read (|
                                                        M.call_closure (|
                                                          Ty.apply
                                                            (Ty.path "alloc::boxed::Box")
                                                            []
                                                            [
                                                              Ty.apply
                                                                (Ty.path "array")
                                                                [ Value.Integer IntegerKind.Usize 2
                                                                ]
                                                                [ F ];
                                                              Ty.path "alloc::alloc::Global"
                                                            ],
                                                          M.get_associated_function (|
                                                            Ty.apply
                                                              (Ty.path "alloc::boxed::Box")
                                                              []
                                                              [
                                                                Ty.apply
                                                                  (Ty.path "array")
                                                                  [
                                                                    Value.Integer
                                                                      IntegerKind.Usize
                                                                      2
                                                                  ]
                                                                  [ F ];
                                                                Ty.path "alloc::alloc::Global"
                                                              ],
                                                            "new",
                                                            [],
                                                            []
                                                          |),
                                                          [
                                                            M.alloc (|
                                                              Ty.apply
                                                                (Ty.path "array")
                                                                [ Value.Integer IntegerKind.Usize 2
                                                                ]
                                                                [ F ],
                                                              Value.Array
                                                                [
                                                                  M.read (| numerator |);
                                                                  M.read (| denominator |)
                                                                ]
                                                            |)
                                                          ]
                                                        |)
                                                      |)
                                                    ]
                                                  |)
                                                ]
                                              |)
                                            |)
                                          |)))
                                      | _ => M.impossible "wrong number of arguments"
                                      end)
                                |)));
                            fun γ =>
                              ltac:(M.monadic
                                (let γ0_0 :=
                                  M.SubPointer.get_struct_tuple_field (|
                                    γ,
                                    "openvm_stark_backend::gkr::types::Layer::GrandProduct",
                                    0
                                  |) in
                                let col :=
                                  M.copy (|
                                    Ty.apply
                                      (Ty.path "openvm_stark_backend::poly::multi::Mle")
                                      []
                                      [ F ],
                                    γ0_0
                                  |) in
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "alloc::vec::Vec")
                                    []
                                    [ F; Ty.path "alloc::alloc::Global" ],
                                  M.get_associated_function (|
                                    Ty.apply (Ty.path "slice") [] [ F ],
                                    "into_vec",
                                    [],
                                    [ Ty.path "alloc::alloc::Global" ]
                                  |),
                                  [
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "alloc::boxed::Box")
                                        []
                                        [
                                          Ty.apply (Ty.path "slice") [] [ F ];
                                          Ty.path "alloc::alloc::Global"
                                        ],
                                      M.pointer_coercion
                                        M.PointerCoercion.Unsize
                                        (Ty.apply
                                          (Ty.path "alloc::boxed::Box")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "array")
                                              [ Value.Integer IntegerKind.Usize 1 ]
                                              [ F ];
                                            Ty.path "alloc::alloc::Global"
                                          ])
                                        (Ty.apply
                                          (Ty.path "alloc::boxed::Box")
                                          []
                                          [
                                            Ty.apply (Ty.path "slice") [] [ F ];
                                            Ty.path "alloc::alloc::Global"
                                          ]),
                                      [
                                        M.read (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "alloc::boxed::Box")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "array")
                                                  [ Value.Integer IntegerKind.Usize 1 ]
                                                  [ F ];
                                                Ty.path "alloc::alloc::Global"
                                              ],
                                            M.get_associated_function (|
                                              Ty.apply
                                                (Ty.path "alloc::boxed::Box")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "array")
                                                    [ Value.Integer IntegerKind.Usize 1 ]
                                                    [ F ];
                                                  Ty.path "alloc::alloc::Global"
                                                ],
                                              "new",
                                              [],
                                              []
                                            |),
                                            [
                                              M.alloc (|
                                                Ty.apply
                                                  (Ty.path "array")
                                                  [ Value.Integer IntegerKind.Usize 1 ]
                                                  [ F ],
                                                Value.Array
                                                  [
                                                    M.read (|
                                                      M.SubPointer.get_array_field (|
                                                        M.deref (|
                                                          M.call_closure (|
                                                            Ty.apply
                                                              (Ty.path "&")
                                                              []
                                                              [ Ty.apply (Ty.path "slice") [] [ F ]
                                                              ],
                                                            M.get_trait_method (|
                                                              "core::ops::deref::Deref",
                                                              Ty.apply
                                                                (Ty.path
                                                                  "openvm_stark_backend::poly::multi::Mle")
                                                                []
                                                                [ F ],
                                                              [],
                                                              [],
                                                              "deref",
                                                              [],
                                                              []
                                                            |),
                                                            [ M.borrow (| Pointer.Kind.Ref, col |) ]
                                                          |)
                                                        |),
                                                        Value.Integer IntegerKind.Usize 0
                                                      |)
                                                    |)
                                                  ]
                                              |)
                                            ]
                                          |)
                                        |)
                                      ]
                                    |)
                                  ]
                                |)))
                          ]
                        |)
                      ]
                  |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_try_into_output_layer_values :
        forall (F : Ty.t),
        M.IsAssociatedFunction.C
          (Self F)
          "try_into_output_layer_values"
          (try_into_output_layer_values F).
      Admitted.
      Global Typeclasses Opaque try_into_output_layer_values.
      
      (*
          pub fn fix_first_variable(self, x0: F) -> Self {
              if self.n_variables() == 0 {
                  return self;
              }
      
              match self {
                  Self::GrandProduct(mle) => Self::GrandProduct(mle.partial_evaluation(x0)),
                  Self::LogUpGeneric {
                      numerators,
                      denominators,
                  }
                  | Self::LogUpMultiplicities {
                      numerators,
                      denominators,
                  } => Self::LogUpGeneric {
                      numerators: numerators.partial_evaluation(x0),
                      denominators: denominators.partial_evaluation(x0),
                  },
                  Self::LogUpSingles { denominators } => Self::LogUpSingles {
                      denominators: denominators.partial_evaluation(x0),
                  },
              }
          }
      *)
      Definition fix_first_variable
          (F : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self F in
        match ε, τ, α with
        | [], [], [ self; x0 ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "openvm_stark_backend::gkr::types::Layer") [] [ F ],
                self
              |) in
            let x0 := M.alloc (| F, x0 |) in
            M.catch_return
              (Ty.apply (Ty.path "openvm_stark_backend::gkr::types::Layer") [] [ F ]) (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      Ty.tuple [],
                      M.alloc (| Ty.tuple [], Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  Ty.path "bool",
                                  M.call_closure (|
                                    Ty.path "bool",
                                    BinOp.eq,
                                    [
                                      M.call_closure (|
                                        Ty.path "usize",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "openvm_stark_backend::gkr::types::Layer")
                                            []
                                            [ F ],
                                          "n_variables",
                                          [],
                                          []
                                        |),
                                        [ M.borrow (| Pointer.Kind.Ref, self |) ]
                                      |);
                                      Value.Integer IntegerKind.Usize 0
                                    ]
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.never_to_any (| M.read (| M.return_ (| M.read (| self |) |) |) |)));
                        fun γ => ltac:(M.monadic (Value.Tuple []))
                      ]
                    |) in
                  M.alloc (|
                    Ty.apply (Ty.path "openvm_stark_backend::gkr::types::Layer") [] [ F ],
                    M.match_operator (|
                      Ty.apply (Ty.path "openvm_stark_backend::gkr::types::Layer") [] [ F ],
                      self,
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ,
                                "openvm_stark_backend::gkr::types::Layer::GrandProduct",
                                0
                              |) in
                            let mle :=
                              M.copy (|
                                Ty.apply
                                  (Ty.path "openvm_stark_backend::poly::multi::Mle")
                                  []
                                  [ F ],
                                γ0_0
                              |) in
                            Value.StructTuple
                              "openvm_stark_backend::gkr::types::Layer::GrandProduct"
                              []
                              [ F ]
                              [
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "openvm_stark_backend::poly::multi::Mle")
                                    []
                                    [ F ],
                                  M.get_trait_method (|
                                    "openvm_stark_backend::poly::multi::MultivariatePolyOracle",
                                    Ty.apply
                                      (Ty.path "openvm_stark_backend::poly::multi::Mle")
                                      []
                                      [ F ],
                                    [],
                                    [ F ],
                                    "partial_evaluation",
                                    [],
                                    []
                                  |),
                                  [ M.read (| mle |); M.read (| x0 |) ]
                                |)
                              ]));
                        fun γ =>
                          ltac:(M.monadic
                            (M.find_or_pattern
                              (Ty.tuple
                                [
                                  Ty.apply
                                    (Ty.path "openvm_stark_backend::poly::multi::Mle")
                                    []
                                    [ F ];
                                  Ty.apply
                                    (Ty.path "openvm_stark_backend::poly::multi::Mle")
                                    []
                                    [ F ]
                                ]) (|
                              γ,
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ0_0 :=
                                      M.SubPointer.get_struct_record_field (|
                                        γ,
                                        "openvm_stark_backend::gkr::types::Layer::LogUpGeneric",
                                        "numerators"
                                      |) in
                                    let γ0_1 :=
                                      M.SubPointer.get_struct_record_field (|
                                        γ,
                                        "openvm_stark_backend::gkr::types::Layer::LogUpGeneric",
                                        "denominators"
                                      |) in
                                    let numerators :=
                                      M.copy (|
                                        Ty.apply
                                          (Ty.path "openvm_stark_backend::poly::multi::Mle")
                                          []
                                          [ F ],
                                        γ0_0
                                      |) in
                                    let denominators :=
                                      M.copy (|
                                        Ty.apply
                                          (Ty.path "openvm_stark_backend::poly::multi::Mle")
                                          []
                                          [ F ],
                                        γ0_1
                                      |) in
                                    Value.Tuple [ numerators; denominators ]));
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ0_0 :=
                                      M.SubPointer.get_struct_record_field (|
                                        γ,
                                        "openvm_stark_backend::gkr::types::Layer::LogUpMultiplicities",
                                        "numerators"
                                      |) in
                                    let γ0_1 :=
                                      M.SubPointer.get_struct_record_field (|
                                        γ,
                                        "openvm_stark_backend::gkr::types::Layer::LogUpMultiplicities",
                                        "denominators"
                                      |) in
                                    let numerators :=
                                      M.copy (|
                                        Ty.apply
                                          (Ty.path "openvm_stark_backend::poly::multi::Mle")
                                          []
                                          [ F ],
                                        γ0_0
                                      |) in
                                    let denominators :=
                                      M.copy (|
                                        Ty.apply
                                          (Ty.path "openvm_stark_backend::poly::multi::Mle")
                                          []
                                          [ F ],
                                        γ0_1
                                      |) in
                                    Value.Tuple [ numerators; denominators ]))
                              ],
                              fun γ =>
                                ltac:(M.monadic
                                  match γ with
                                  | [ numerators; denominators ] =>
                                    ltac:(M.monadic
                                      (Value.mkStructRecord
                                        "openvm_stark_backend::gkr::types::Layer::LogUpGeneric"
                                        []
                                        [ F ]
                                        [
                                          ("numerators",
                                            M.call_closure (|
                                              Ty.apply
                                                (Ty.path "openvm_stark_backend::poly::multi::Mle")
                                                []
                                                [ F ],
                                              M.get_trait_method (|
                                                "openvm_stark_backend::poly::multi::MultivariatePolyOracle",
                                                Ty.apply
                                                  (Ty.path "openvm_stark_backend::poly::multi::Mle")
                                                  []
                                                  [ F ],
                                                [],
                                                [ F ],
                                                "partial_evaluation",
                                                [],
                                                []
                                              |),
                                              [ M.read (| numerators |); M.read (| x0 |) ]
                                            |));
                                          ("denominators",
                                            M.call_closure (|
                                              Ty.apply
                                                (Ty.path "openvm_stark_backend::poly::multi::Mle")
                                                []
                                                [ F ],
                                              M.get_trait_method (|
                                                "openvm_stark_backend::poly::multi::MultivariatePolyOracle",
                                                Ty.apply
                                                  (Ty.path "openvm_stark_backend::poly::multi::Mle")
                                                  []
                                                  [ F ],
                                                [],
                                                [ F ],
                                                "partial_evaluation",
                                                [],
                                                []
                                              |),
                                              [ M.read (| denominators |); M.read (| x0 |) ]
                                            |))
                                        ]))
                                  | _ => M.impossible "wrong number of arguments"
                                  end)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 :=
                              M.SubPointer.get_struct_record_field (|
                                γ,
                                "openvm_stark_backend::gkr::types::Layer::LogUpSingles",
                                "denominators"
                              |) in
                            let denominators :=
                              M.copy (|
                                Ty.apply
                                  (Ty.path "openvm_stark_backend::poly::multi::Mle")
                                  []
                                  [ F ],
                                γ0_0
                              |) in
                            Value.mkStructRecord
                              "openvm_stark_backend::gkr::types::Layer::LogUpSingles"
                              []
                              [ F ]
                              [
                                ("denominators",
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "openvm_stark_backend::poly::multi::Mle")
                                      []
                                      [ F ],
                                    M.get_trait_method (|
                                      "openvm_stark_backend::poly::multi::MultivariatePolyOracle",
                                      Ty.apply
                                        (Ty.path "openvm_stark_backend::poly::multi::Mle")
                                        []
                                        [ F ],
                                      [],
                                      [ F ],
                                      "partial_evaluation",
                                      [],
                                      []
                                    |),
                                    [ M.read (| denominators |); M.read (| x0 |) ]
                                  |))
                              ]))
                      ]
                    |)
                  |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_fix_first_variable :
        forall (F : Ty.t),
        M.IsAssociatedFunction.C (Self F) "fix_first_variable" (fix_first_variable F).
      Admitted.
      Global Typeclasses Opaque fix_first_variable.
    End Impl_openvm_stark_backend_gkr_types_Layer_F.
    
    (* StructTuple
      {
        name := "NotOutputLayerError";
        const_params := [];
        ty_params := [];
        fields := [];
      } *)
    
    Module Impl_core_fmt_Debug_for_openvm_stark_backend_gkr_types_NotOutputLayerError.
      Definition Self : Ty.t := Ty.path "openvm_stark_backend::gkr::types::NotOutputLayerError".
      
      (* Debug *)
      Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.path "openvm_stark_backend::gkr::types::NotOutputLayerError" ],
                self
              |) in
            let f :=
              M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "core::fmt::Formatter" ], f |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
              M.get_associated_function (| Ty.path "core::fmt::Formatter", "write_str", [], [] |),
              [
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "NotOutputLayerError" |) |) |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Debug"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Debug_for_openvm_stark_backend_gkr_types_NotOutputLayerError.
    
    (*
    Enum MleExpr
    {
      const_params := [];
      ty_params := [ "F" ];
      variants :=
        [
          {
            name := "Constant";
            item := StructTuple [ F ];
          };
          {
            name := "Mle";
            item :=
              StructTuple
                [
                  Ty.apply
                    (Ty.path "&")
                    []
                    [ Ty.apply (Ty.path "openvm_stark_backend::poly::multi::Mle") [] [ F ] ]
                ];
          }
        ];
    }
    *)
    
    Axiom IsDiscriminant_MleExpr_Constant :
      M.IsDiscriminant "openvm_stark_backend::gkr::types::MleExpr::Constant" 0.
    Axiom IsDiscriminant_MleExpr_Mle :
      M.IsDiscriminant "openvm_stark_backend::gkr::types::MleExpr::Mle" 1.
    
    Module Impl_core_ops_index_Index_where_p3_field_field_Field_F_usize_for_openvm_stark_backend_gkr_types_MleExpr_F.
      Definition Self (F : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "openvm_stark_backend::gkr::types::MleExpr") [] [ F ].
      
      (*     type Output = F; *)
      Definition _Output (F : Ty.t) : Ty.t := F.
      
      (*
          fn index(&self, index: usize) -> &F {
              match self {
                  Self::Constant(v) => v,
                  Self::Mle(mle) => &mle[index],
              }
          }
      *)
      Definition index (F : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match ε, τ, α with
        | [], [], [ self; index ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.apply (Ty.path "openvm_stark_backend::gkr::types::MleExpr") [] [ F ] ],
                self
              |) in
            let index := M.alloc (| Ty.path "usize", index |) in
            M.borrow (|
              Pointer.Kind.Ref,
              M.deref (|
                M.match_operator (|
                  Ty.apply (Ty.path "&") [] [ F ],
                  self,
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let γ1_0 :=
                          M.SubPointer.get_struct_tuple_field (|
                            γ,
                            "openvm_stark_backend::gkr::types::MleExpr::Constant",
                            0
                          |) in
                        let v := M.alloc (| Ty.apply (Ty.path "&") [] [ F ], γ1_0 |) in
                        M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| v |) |) |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := M.read (| γ |) in
                        let γ1_0 :=
                          M.SubPointer.get_struct_tuple_field (|
                            γ,
                            "openvm_stark_backend::gkr::types::MleExpr::Mle",
                            0
                          |) in
                        let mle :=
                          M.alloc (|
                            Ty.apply
                              (Ty.path "&")
                              []
                              [
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "openvm_stark_backend::poly::multi::Mle")
                                      []
                                      [ F ]
                                  ]
                              ],
                            γ1_0
                          |) in
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (|
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.SubPointer.get_array_field (|
                                M.deref (|
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [ Ty.apply (Ty.path "slice") [] [ F ] ],
                                    M.get_trait_method (|
                                      "core::ops::deref::Deref",
                                      Ty.apply
                                        (Ty.path "openvm_stark_backend::poly::multi::Mle")
                                        []
                                        [ F ],
                                      [],
                                      [],
                                      "deref",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (| M.read (| M.deref (| M.read (| mle |) |) |) |)
                                      |)
                                    ]
                                  |)
                                |),
                                M.read (| index |)
                              |)
                            |)
                          |)
                        |)))
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (F : Ty.t),
        M.IsTraitInstance
          "core::ops::index::Index"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "usize" ]
          (Self F)
          (* Instance *)
          [ ("Output", InstanceField.Ty (_Output F)); ("index", InstanceField.Method (index F)) ].
    End Impl_core_ops_index_Index_where_p3_field_field_Field_F_usize_for_openvm_stark_backend_gkr_types_MleExpr_F.
  End types.
End gkr.
