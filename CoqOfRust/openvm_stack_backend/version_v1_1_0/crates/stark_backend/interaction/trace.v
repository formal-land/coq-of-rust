(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module interaction.
  Module trace.
    (* StructRecord
      {
        name := "Evaluator";
        const_params := [];
        ty_params := [ "F" ];
        fields :=
          [
            ("preprocessed",
              Ty.apply
                (Ty.path "&")
                []
                [
                  Ty.apply
                    (Ty.path "core::option::Option")
                    []
                    [
                      Ty.apply
                        (Ty.path "p3_matrix::dense::DenseMatrix")
                        []
                        [ F; Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ F ] ] ]
                    ]
                ]);
            ("partitioned_main",
              Ty.apply
                (Ty.path "&")
                []
                [
                  Ty.apply
                    (Ty.path "slice")
                    []
                    [
                      Ty.apply
                        (Ty.path "p3_matrix::dense::DenseMatrix")
                        []
                        [ F; Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ F ] ] ]
                    ]
                ]);
            ("public_values", Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ F ] ]);
            ("height", Ty.path "usize");
            ("local_index", Ty.path "usize")
          ];
      } *)
    
    Module Impl_openvm_stark_backend_air_builders_symbolic_symbolic_expression_SymbolicEvaluator_where_p3_field_field_Field_F_F_F_for_openvm_stark_backend_interaction_trace_Evaluator_F.
      Definition Self (F : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "openvm_stark_backend::interaction::trace::Evaluator") [] [ F ].
      
      (*
          fn eval_const(&self, c: F) -> F {
              c
          }
      *)
      Definition eval_const (F : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match ε, τ, α with
        | [], [], [ self; c ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path "openvm_stark_backend::interaction::trace::Evaluator")
                      []
                      [ F ]
                  ],
                self
              |) in
            let c := M.alloc (| F, c |) in
            M.read (| c |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn eval_var(&self, symbolic_var: SymbolicVariable<F>) -> F {
              let n = self.local_index;
              let height = self.height;
              let index = symbolic_var.index;
              match symbolic_var.entry {
                  Entry::Preprocessed { offset } => {
                      self.preprocessed.unwrap().get((n + offset) % height, index)
                  }
                  Entry::Main { part_index, offset } => {
                      self.partitioned_main[part_index].get((n + offset) % height, index)
                  }
                  Entry::Public => self.public_values[index],
                  _ => unreachable!("There should be no after challenge variables"),
              }
          }
      *)
      Definition eval_var (F : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match ε, τ, α with
        | [], [], [ self; symbolic_var ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path "openvm_stark_backend::interaction::trace::Evaluator")
                      []
                      [ F ]
                  ],
                self
              |) in
            let symbolic_var :=
              M.alloc (|
                Ty.apply
                  (Ty.path
                    "openvm_stark_backend::air_builders::symbolic::symbolic_variable::SymbolicVariable")
                  []
                  [ F ],
                symbolic_var
              |) in
            M.read (|
              let~ n : Ty.path "usize" :=
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "openvm_stark_backend::interaction::trace::Evaluator",
                    "local_index"
                  |)
                |) in
              let~ height : Ty.path "usize" :=
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "openvm_stark_backend::interaction::trace::Evaluator",
                    "height"
                  |)
                |) in
              let~ index : Ty.path "usize" :=
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    symbolic_var,
                    "openvm_stark_backend::air_builders::symbolic::symbolic_variable::SymbolicVariable",
                    "index"
                  |)
                |) in
              M.alloc (|
                F,
                M.match_operator (|
                  F,
                  M.SubPointer.get_struct_record_field (|
                    symbolic_var,
                    "openvm_stark_backend::air_builders::symbolic::symbolic_variable::SymbolicVariable",
                    "entry"
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.SubPointer.get_struct_record_field (|
                            γ,
                            "openvm_stark_backend::air_builders::symbolic::symbolic_variable::Entry::Preprocessed",
                            "offset"
                          |) in
                        let offset := M.copy (| Ty.path "usize", γ0_0 |) in
                        M.call_closure (|
                          F,
                          M.get_trait_method (|
                            "p3_matrix::Matrix",
                            Ty.apply
                              (Ty.path "p3_matrix::dense::DenseMatrix")
                              []
                              [ F; Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ F ] ]
                              ],
                            [],
                            [ F ],
                            "get",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.alloc (|
                                Ty.apply
                                  (Ty.path "p3_matrix::dense::DenseMatrix")
                                  []
                                  [
                                    F;
                                    Ty.apply
                                      (Ty.path "&")
                                      []
                                      [ Ty.apply (Ty.path "slice") [] [ F ] ]
                                  ],
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "p3_matrix::dense::DenseMatrix")
                                    []
                                    [
                                      F;
                                      Ty.apply
                                        (Ty.path "&")
                                        []
                                        [ Ty.apply (Ty.path "slice") [] [ F ] ]
                                    ],
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "core::option::Option")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "p3_matrix::dense::DenseMatrix")
                                          []
                                          [
                                            F;
                                            Ty.apply
                                              (Ty.path "&")
                                              []
                                              [ Ty.apply (Ty.path "slice") [] [ F ] ]
                                          ]
                                      ],
                                    "unwrap",
                                    [],
                                    []
                                  |),
                                  [
                                    M.read (|
                                      M.deref (|
                                        M.read (|
                                          M.SubPointer.get_struct_record_field (|
                                            M.deref (| M.read (| self |) |),
                                            "openvm_stark_backend::interaction::trace::Evaluator",
                                            "preprocessed"
                                          |)
                                        |)
                                      |)
                                    |)
                                  ]
                                |)
                              |)
                            |);
                            M.call_closure (|
                              Ty.path "usize",
                              BinOp.Wrap.rem,
                              [
                                M.call_closure (|
                                  Ty.path "usize",
                                  BinOp.Wrap.add,
                                  [ M.read (| n |); M.read (| offset |) ]
                                |);
                                M.read (| height |)
                              ]
                            |);
                            M.read (| index |)
                          ]
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.SubPointer.get_struct_record_field (|
                            γ,
                            "openvm_stark_backend::air_builders::symbolic::symbolic_variable::Entry::Main",
                            "part_index"
                          |) in
                        let γ0_1 :=
                          M.SubPointer.get_struct_record_field (|
                            γ,
                            "openvm_stark_backend::air_builders::symbolic::symbolic_variable::Entry::Main",
                            "offset"
                          |) in
                        let part_index := M.copy (| Ty.path "usize", γ0_0 |) in
                        let offset := M.copy (| Ty.path "usize", γ0_1 |) in
                        M.call_closure (|
                          F,
                          M.get_trait_method (|
                            "p3_matrix::Matrix",
                            Ty.apply
                              (Ty.path "p3_matrix::dense::DenseMatrix")
                              []
                              [ F; Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ F ] ]
                              ],
                            [],
                            [ F ],
                            "get",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.SubPointer.get_array_field (|
                                M.deref (|
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "openvm_stark_backend::interaction::trace::Evaluator",
                                      "partitioned_main"
                                    |)
                                  |)
                                |),
                                M.read (| part_index |)
                              |)
                            |);
                            M.call_closure (|
                              Ty.path "usize",
                              BinOp.Wrap.rem,
                              [
                                M.call_closure (|
                                  Ty.path "usize",
                                  BinOp.Wrap.add,
                                  [ M.read (| n |); M.read (| offset |) ]
                                |);
                                M.read (| height |)
                              ]
                            |);
                            M.read (| index |)
                          ]
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "openvm_stark_backend::air_builders::symbolic::symbolic_variable::Entry::Public"
                          |) in
                        M.read (|
                          M.SubPointer.get_array_field (|
                            M.deref (|
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "openvm_stark_backend::interaction::trace::Evaluator",
                                  "public_values"
                                |)
                              |)
                            |),
                            M.read (| index |)
                          |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (M.never_to_any (|
                          M.call_closure (|
                            Ty.path "never",
                            M.get_function (| "core::panicking::panic_fmt", [], [] |),
                            [
                              M.call_closure (|
                                Ty.path "core::fmt::Arguments",
                                M.get_associated_function (|
                                  Ty.path "core::fmt::Arguments",
                                  "new_v1",
                                  [
                                    Value.Integer IntegerKind.Usize 1;
                                    Value.Integer IntegerKind.Usize 0
                                  ],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.alloc (|
                                          Ty.apply
                                            (Ty.path "array")
                                            [ Value.Integer IntegerKind.Usize 1 ]
                                            [ Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ],
                                          Value.Array
                                            [
                                              mk_str (|
                                                "internal error: entered unreachable code: There should be no after challenge variables"
                                              |)
                                            ]
                                        |)
                                      |)
                                    |)
                                  |);
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.alloc (|
                                          Ty.apply
                                            (Ty.path "array")
                                            [ Value.Integer IntegerKind.Usize 0 ]
                                            [ Ty.path "core::fmt::rt::Argument" ],
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "array")
                                              [ Value.Integer IntegerKind.Usize 0 ]
                                              [ Ty.path "core::fmt::rt::Argument" ],
                                            M.get_associated_function (|
                                              Ty.path "core::fmt::rt::Argument",
                                              "none",
                                              [],
                                              []
                                            |),
                                            []
                                          |)
                                        |)
                                      |)
                                    |)
                                  |)
                                ]
                              |)
                            ]
                          |)
                        |)))
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn eval_is_first_row(&self) -> F {
              unreachable!()
          }
      *)
      Definition eval_is_first_row
          (F : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self F in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path "openvm_stark_backend::interaction::trace::Evaluator")
                      []
                      [ F ]
                  ],
                self
              |) in
            M.never_to_any (|
              M.call_closure (|
                Ty.path "never",
                M.get_function (| "core::panicking::panic", [], [] |),
                [ mk_str (| "internal error: entered unreachable code" |) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn eval_is_last_row(&self) -> F {
              unreachable!()
          }
      *)
      Definition eval_is_last_row
          (F : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self F in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path "openvm_stark_backend::interaction::trace::Evaluator")
                      []
                      [ F ]
                  ],
                self
              |) in
            M.never_to_any (|
              M.call_closure (|
                Ty.path "never",
                M.get_function (| "core::panicking::panic", [], [] |),
                [ mk_str (| "internal error: entered unreachable code" |) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn eval_is_transition(&self) -> F {
              unreachable!()
          }
      *)
      Definition eval_is_transition
          (F : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self F in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path "openvm_stark_backend::interaction::trace::Evaluator")
                      []
                      [ F ]
                  ],
                self
              |) in
            M.never_to_any (|
              M.call_closure (|
                Ty.path "never",
                M.get_function (| "core::panicking::panic", [], [] |),
                [ mk_str (| "internal error: entered unreachable code" |) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (F : Ty.t),
        M.IsTraitInstance
          "openvm_stark_backend::air_builders::symbolic::symbolic_expression::SymbolicEvaluator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ F; F ]
          (Self F)
          (* Instance *)
          [
            ("eval_const", InstanceField.Method (eval_const F));
            ("eval_var", InstanceField.Method (eval_var F));
            ("eval_is_first_row", InstanceField.Method (eval_is_first_row F));
            ("eval_is_last_row", InstanceField.Method (eval_is_last_row F));
            ("eval_is_transition", InstanceField.Method (eval_is_transition F))
          ].
    End Impl_openvm_stark_backend_air_builders_symbolic_symbolic_expression_SymbolicEvaluator_where_p3_field_field_Field_F_F_F_for_openvm_stark_backend_interaction_trace_Evaluator_F.
  End trace.
End interaction.
