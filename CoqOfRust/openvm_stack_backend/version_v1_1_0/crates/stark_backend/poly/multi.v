(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module poly.
  Module multi.
    (* Trait *)
    (* Empty module 'MultivariatePolyOracle' *)
    
    (* StructRecord
      {
        name := "Mle";
        const_params := [];
        ty_params := [ "F" ];
        fields :=
          [ ("evals", Ty.apply (Ty.path "alloc::vec::Vec") [] [ F; Ty.path "alloc::alloc::Global" ])
          ];
      } *)
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_F_for_openvm_stark_backend_poly_multi_Mle_F.
      Definition Self (F : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "openvm_stark_backend::poly::multi::Mle") [] [ F ].
      
      (* Debug *)
      Definition fmt (F : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.apply (Ty.path "openvm_stark_backend::poly::multi::Mle") [] [ F ] ],
                self
              |) in
            let f :=
              M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "core::fmt::Formatter" ], f |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
              M.get_associated_function (|
                Ty.path "core::fmt::Formatter",
                "debug_struct_field1_finish",
                [],
                []
              |),
              [
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "Mle" |) |) |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "evals" |) |) |);
                M.call_closure (|
                  Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ],
                  M.pointer_coercion
                    M.PointerCoercion.Unsize
                    (Ty.apply
                      (Ty.path "&")
                      []
                      [
                        Ty.apply
                          (Ty.path "&")
                          []
                          [
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              []
                              [ F; Ty.path "alloc::alloc::Global" ]
                          ]
                      ])
                    (Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ]),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.alloc (|
                            Ty.apply
                              (Ty.path "&")
                              []
                              [
                                Ty.apply
                                  (Ty.path "alloc::vec::Vec")
                                  []
                                  [ F; Ty.path "alloc::alloc::Global" ]
                              ],
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "openvm_stark_backend::poly::multi::Mle",
                                "evals"
                              |)
                            |)
                          |)
                        |)
                      |)
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (F : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self F)
          (* Instance *) [ ("fmt", InstanceField.Method (fmt F)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_F_for_openvm_stark_backend_poly_multi_Mle_F.
    
    Module Impl_core_clone_Clone_where_core_clone_Clone_F_for_openvm_stark_backend_poly_multi_Mle_F.
      Definition Self (F : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "openvm_stark_backend::poly::multi::Mle") [] [ F ].
      
      (* Clone *)
      Definition clone (F : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.apply (Ty.path "openvm_stark_backend::poly::multi::Mle") [] [ F ] ],
                self
              |) in
            Value.mkStructRecord
              "openvm_stark_backend::poly::multi::Mle"
              []
              [ F ]
              [
                ("evals",
                  M.call_closure (|
                    Ty.apply (Ty.path "alloc::vec::Vec") [] [ F; Ty.path "alloc::alloc::Global" ],
                    M.get_trait_method (|
                      "core::clone::Clone",
                      Ty.apply (Ty.path "alloc::vec::Vec") [] [ F; Ty.path "alloc::alloc::Global" ],
                      [],
                      [],
                      "clone",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "openvm_stark_backend::poly::multi::Mle",
                              "evals"
                            |)
                          |)
                        |)
                      |)
                    ]
                  |))
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (F : Ty.t),
        M.IsTraitInstance
          "core::clone::Clone"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self F)
          (* Instance *) [ ("clone", InstanceField.Method (clone F)) ].
    End Impl_core_clone_Clone_where_core_clone_Clone_F_for_openvm_stark_backend_poly_multi_Mle_F.
    
    Module Impl_openvm_stark_backend_poly_multi_Mle_F.
      Definition Self (F : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "openvm_stark_backend::poly::multi::Mle") [] [ F ].
      
      (*
          pub fn new(evals: Vec<F>) -> Self {
              assert!(evals.len().is_power_of_two());
              Self { evals }
          }
      *)
      Definition new (F : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match ε, τ, α with
        | [], [], [ evals ] =>
          ltac:(M.monadic
            (let evals :=
              M.alloc (|
                Ty.apply (Ty.path "alloc::vec::Vec") [] [ F; Ty.path "alloc::alloc::Global" ],
                evals
              |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.match_operator (|
                  Ty.tuple [],
                  M.alloc (| Ty.tuple [], Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              Ty.path "bool",
                              UnOp.not (|
                                M.call_closure (|
                                  Ty.path "bool",
                                  M.get_associated_function (|
                                    Ty.path "usize",
                                    "is_power_of_two",
                                    [],
                                    []
                                  |),
                                  [
                                    M.call_closure (|
                                      Ty.path "usize",
                                      M.get_associated_function (|
                                        Ty.apply
                                          (Ty.path "alloc::vec::Vec")
                                          []
                                          [ F; Ty.path "alloc::alloc::Global" ],
                                        "len",
                                        [],
                                        []
                                      |),
                                      [ M.borrow (| Pointer.Kind.Ref, evals |) ]
                                    |)
                                  ]
                                |)
                              |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.never_to_any (|
                          M.call_closure (|
                            Ty.path "never",
                            M.get_function (| "core::panicking::panic", [], [] |),
                            [ mk_str (| "assertion failed: evals.len().is_power_of_two()" |) ]
                          |)
                        |)));
                    fun γ => ltac:(M.monadic (Value.Tuple []))
                  ]
                |) in
              M.alloc (|
                Ty.apply (Ty.path "openvm_stark_backend::poly::multi::Mle") [] [ F ],
                Value.mkStructRecord
                  "openvm_stark_backend::poly::multi::Mle"
                  []
                  [ F ]
                  [ ("evals", M.read (| evals |)) ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_new :
        forall (F : Ty.t),
        M.IsAssociatedFunction.C (Self F) "new" (new F).
      Admitted.
      Global Typeclasses Opaque new.
      
      (*
          pub fn into_evals(self) -> Vec<F> {
              self.evals
          }
      *)
      Definition into_evals (F : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "openvm_stark_backend::poly::multi::Mle") [] [ F ],
                self
              |) in
            M.read (|
              M.SubPointer.get_struct_record_field (|
                self,
                "openvm_stark_backend::poly::multi::Mle",
                "evals"
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_into_evals :
        forall (F : Ty.t),
        M.IsAssociatedFunction.C (Self F) "into_evals" (into_evals F).
      Admitted.
      Global Typeclasses Opaque into_evals.
    End Impl_openvm_stark_backend_poly_multi_Mle_F.
    
    Module Impl_openvm_stark_backend_poly_multi_MultivariatePolyOracle_where_p3_field_field_Field_F_F_for_openvm_stark_backend_poly_multi_Mle_F.
      Definition Self (F : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "openvm_stark_backend::poly::multi::Mle") [] [ F ].
      
      (*
          fn arity(&self) -> usize {
              self.evals.len().ilog2() as usize
          }
      *)
      Definition arity (F : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.apply (Ty.path "openvm_stark_backend::poly::multi::Mle") [] [ F ] ],
                self
              |) in
            M.cast
              (Ty.path "usize")
              (M.call_closure (|
                Ty.path "u32",
                M.get_associated_function (| Ty.path "usize", "ilog2", [], [] |),
                [
                  M.call_closure (|
                    Ty.path "usize",
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloc::vec::Vec") [] [ F; Ty.path "alloc::alloc::Global" ],
                      "len",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "openvm_stark_backend::poly::multi::Mle",
                          "evals"
                        |)
                      |)
                    ]
                  |)
                ]
              |))))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn marginalize_first(&self, claim: F) -> UnivariatePolynomial<F> {
              let x0 = F::ZERO;
              let x1 = F::ONE;
      
              let y0 = self[0..self.len() / 2]
                  .iter()
                  .fold(F::ZERO, |acc, x| acc + *x);
              let y1 = claim - y0;
      
              UnivariatePolynomial::from_interpolation(&[(x0, y0), (x1, y1)])
          }
      *)
      Definition marginalize_first
          (F : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self F in
        match ε, τ, α with
        | [], [], [ self; claim ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.apply (Ty.path "openvm_stark_backend::poly::multi::Mle") [] [ F ] ],
                self
              |) in
            let claim := M.alloc (| F, claim |) in
            M.read (|
              let~ x0 : F :=
                M.read (| get_constant (| "p3_field::field::FieldAlgebra::ZERO", F |) |) in
              let~ x1 : F :=
                M.read (| get_constant (| "p3_field::field::FieldAlgebra::ONE", F |) |) in
              let~ y0 : F :=
                M.call_closure (|
                  F,
                  M.get_trait_method (|
                    "core::iter::traits::iterator::Iterator",
                    Ty.apply (Ty.path "core::slice::iter::Iter") [] [ F ],
                    [],
                    [],
                    "fold",
                    [],
                    [ F; Ty.function [ F; Ty.apply (Ty.path "&") [] [ F ] ] F ]
                  |),
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "core::slice::iter::Iter") [] [ F ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "slice") [] [ F ],
                        "iter",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (|
                            M.call_closure (|
                              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ F ] ],
                              M.get_trait_method (|
                                "core::ops::index::Index",
                                Ty.apply (Ty.path "slice") [] [ F ],
                                [],
                                [
                                  Ty.apply
                                    (Ty.path "core::ops::range::Range")
                                    []
                                    [ Ty.path "usize" ]
                                ],
                                "index",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "&")
                                        []
                                        [ Ty.apply (Ty.path "slice") [] [ F ] ],
                                      M.get_trait_method (|
                                        "core::ops::deref::Deref",
                                        Ty.apply
                                          (Ty.path "openvm_stark_backend::poly::multi::Mle")
                                          []
                                          [ F ],
                                        [],
                                        [],
                                        "deref",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| self |) |)
                                        |)
                                      ]
                                    |)
                                  |)
                                |);
                                Value.mkStructRecord
                                  "core::ops::range::Range"
                                  []
                                  [ Ty.path "usize" ]
                                  [
                                    ("start", Value.Integer IntegerKind.Usize 0);
                                    ("end_",
                                      M.call_closure (|
                                        Ty.path "usize",
                                        BinOp.Wrap.div,
                                        [
                                          M.call_closure (|
                                            Ty.path "usize",
                                            M.get_associated_function (|
                                              Ty.apply (Ty.path "slice") [] [ F ],
                                              "len",
                                              [],
                                              []
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (|
                                                  M.call_closure (|
                                                    Ty.apply
                                                      (Ty.path "&")
                                                      []
                                                      [ Ty.apply (Ty.path "slice") [] [ F ] ],
                                                    M.get_trait_method (|
                                                      "core::ops::deref::Deref",
                                                      Ty.apply
                                                        (Ty.path
                                                          "openvm_stark_backend::poly::multi::Mle")
                                                        []
                                                        [ F ],
                                                      [],
                                                      [],
                                                      "deref",
                                                      [],
                                                      []
                                                    |),
                                                    [
                                                      M.borrow (|
                                                        Pointer.Kind.Ref,
                                                        M.deref (| M.read (| self |) |)
                                                      |)
                                                    ]
                                                  |)
                                                |)
                                              |)
                                            ]
                                          |);
                                          Value.Integer IntegerKind.Usize 2
                                        ]
                                      |))
                                  ]
                              ]
                            |)
                          |)
                        |)
                      ]
                    |);
                    M.read (| get_constant (| "p3_field::field::FieldAlgebra::ZERO", F |) |);
                    M.closure
                      (fun γ =>
                        ltac:(M.monadic
                          match γ with
                          | [ α0; α1 ] =>
                            ltac:(M.monadic
                              (M.match_operator (|
                                F,
                                M.alloc (| F, α0 |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let acc := M.copy (| F, γ |) in
                                      M.match_operator (|
                                        F,
                                        M.alloc (| Ty.apply (Ty.path "&") [] [ F ], α1 |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let x :=
                                                M.copy (| Ty.apply (Ty.path "&") [] [ F ], γ |) in
                                              M.call_closure (|
                                                F,
                                                M.get_trait_method (|
                                                  "core::ops::arith::Add",
                                                  F,
                                                  [],
                                                  [ F ],
                                                  "add",
                                                  [],
                                                  []
                                                |),
                                                [
                                                  M.read (| acc |);
                                                  M.read (| M.deref (| M.read (| x |) |) |)
                                                ]
                                              |)))
                                        ]
                                      |)))
                                ]
                              |)))
                          | _ => M.impossible "wrong number of arguments"
                          end))
                  ]
                |) in
              let~ y1 : F :=
                M.call_closure (|
                  F,
                  M.get_trait_method (| "core::ops::arith::Sub", F, [], [ F ], "sub", [], [] |),
                  [ M.read (| claim |); M.read (| y0 |) ]
                |) in
              M.alloc (|
                Ty.apply (Ty.path "openvm_stark_backend::poly::uni::UnivariatePolynomial") [] [ F ],
                M.call_closure (|
                  Ty.apply
                    (Ty.path "openvm_stark_backend::poly::uni::UnivariatePolynomial")
                    []
                    [ F ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "openvm_stark_backend::poly::uni::UnivariatePolynomial")
                      []
                      [ F ],
                    "from_interpolation",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "&")
                        []
                        [ Ty.apply (Ty.path "slice") [] [ Ty.tuple [ F; F ] ] ],
                      M.pointer_coercion
                        M.PointerCoercion.Unsize
                        (Ty.apply
                          (Ty.path "&")
                          []
                          [
                            Ty.apply
                              (Ty.path "array")
                              [ Value.Integer IntegerKind.Usize 2 ]
                              [ Ty.tuple [ F; F ] ]
                          ])
                        (Ty.apply
                          (Ty.path "&")
                          []
                          [ Ty.apply (Ty.path "slice") [] [ Ty.tuple [ F; F ] ] ]),
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (|
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.alloc (|
                                Ty.apply
                                  (Ty.path "array")
                                  [ Value.Integer IntegerKind.Usize 2 ]
                                  [ Ty.tuple [ F; F ] ],
                                Value.Array
                                  [
                                    Value.Tuple [ M.read (| x0 |); M.read (| y0 |) ];
                                    Value.Tuple [ M.read (| x1 |); M.read (| y1 |) ]
                                  ]
                              |)
                            |)
                          |)
                        |)
                      ]
                    |)
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn partial_evaluation(self, alpha: F) -> Self {
              let midpoint = self.len() / 2;
              let (lhs_evals, rhs_evals) = self.split_at(midpoint);
      
              let res = zip(lhs_evals, rhs_evals)
                  .map(|(&lhs_eval, &rhs_eval)| alpha * (rhs_eval - lhs_eval) + lhs_eval)
                  .collect();
      
              Mle::new(res)
          }
      *)
      Definition partial_evaluation
          (F : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self F in
        match ε, τ, α with
        | [], [], [ self; alpha ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "openvm_stark_backend::poly::multi::Mle") [] [ F ],
                self
              |) in
            let alpha := M.alloc (| F, alpha |) in
            M.read (|
              let~ midpoint : Ty.path "usize" :=
                M.call_closure (|
                  Ty.path "usize",
                  BinOp.Wrap.div,
                  [
                    M.call_closure (|
                      Ty.path "usize",
                      M.get_associated_function (|
                        Ty.apply (Ty.path "slice") [] [ F ],
                        "len",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (|
                            M.call_closure (|
                              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ F ] ],
                              M.get_trait_method (|
                                "core::ops::deref::Deref",
                                Ty.apply
                                  (Ty.path "openvm_stark_backend::poly::multi::Mle")
                                  []
                                  [ F ],
                                [],
                                [],
                                "deref",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.Ref, self |) ]
                            |)
                          |)
                        |)
                      ]
                    |);
                    Value.Integer IntegerKind.Usize 2
                  ]
                |) in
              M.alloc (|
                Ty.apply (Ty.path "openvm_stark_backend::poly::multi::Mle") [] [ F ],
                M.match_operator (|
                  Ty.apply (Ty.path "openvm_stark_backend::poly::multi::Mle") [] [ F ],
                  M.alloc (|
                    Ty.tuple
                      [
                        Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ F ] ];
                        Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ F ] ]
                      ],
                    M.call_closure (|
                      Ty.tuple
                        [
                          Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ F ] ];
                          Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ F ] ]
                        ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "slice") [] [ F ],
                        "split_at",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (|
                            M.call_closure (|
                              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ F ] ],
                              M.get_trait_method (|
                                "core::ops::deref::Deref",
                                Ty.apply
                                  (Ty.path "openvm_stark_backend::poly::multi::Mle")
                                  []
                                  [ F ],
                                [],
                                [],
                                "deref",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.Ref, self |) ]
                            |)
                          |)
                        |);
                        M.read (| midpoint |)
                      ]
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                        let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                        let lhs_evals :=
                          M.copy (|
                            Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ F ] ],
                            γ0_0
                          |) in
                        let rhs_evals :=
                          M.copy (|
                            Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ F ] ],
                            γ0_1
                          |) in
                        M.read (|
                          let~ res :
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                []
                                [ F; Ty.path "alloc::alloc::Global" ] :=
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                []
                                [ F; Ty.path "alloc::alloc::Global" ],
                              M.get_trait_method (|
                                "core::iter::traits::iterator::Iterator",
                                Ty.apply
                                  (Ty.path "core::iter::adapters::map::Map")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::iter::adapters::zip::Zip")
                                      []
                                      [
                                        Ty.apply (Ty.path "core::slice::iter::Iter") [] [ F ];
                                        Ty.apply (Ty.path "core::slice::iter::Iter") [] [ F ]
                                      ];
                                    Ty.function
                                      [
                                        Ty.tuple
                                          [
                                            Ty.apply (Ty.path "&") [] [ F ];
                                            Ty.apply (Ty.path "&") [] [ F ]
                                          ]
                                      ]
                                      F
                                  ],
                                [],
                                [],
                                "collect",
                                [],
                                [
                                  Ty.apply
                                    (Ty.path "alloc::vec::Vec")
                                    []
                                    [ F; Ty.path "alloc::alloc::Global" ]
                                ]
                              |),
                              [
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "core::iter::adapters::map::Map")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "core::iter::adapters::zip::Zip")
                                        []
                                        [
                                          Ty.apply (Ty.path "core::slice::iter::Iter") [] [ F ];
                                          Ty.apply (Ty.path "core::slice::iter::Iter") [] [ F ]
                                        ];
                                      Ty.function
                                        [
                                          Ty.tuple
                                            [
                                              Ty.apply (Ty.path "&") [] [ F ];
                                              Ty.apply (Ty.path "&") [] [ F ]
                                            ]
                                        ]
                                        F
                                    ],
                                  M.get_trait_method (|
                                    "core::iter::traits::iterator::Iterator",
                                    Ty.apply
                                      (Ty.path "core::iter::adapters::zip::Zip")
                                      []
                                      [
                                        Ty.apply (Ty.path "core::slice::iter::Iter") [] [ F ];
                                        Ty.apply (Ty.path "core::slice::iter::Iter") [] [ F ]
                                      ],
                                    [],
                                    [],
                                    "map",
                                    [],
                                    [
                                      F;
                                      Ty.function
                                        [
                                          Ty.tuple
                                            [
                                              Ty.apply (Ty.path "&") [] [ F ];
                                              Ty.apply (Ty.path "&") [] [ F ]
                                            ]
                                        ]
                                        F
                                    ]
                                  |),
                                  [
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::iter::adapters::zip::Zip")
                                        []
                                        [
                                          Ty.apply (Ty.path "core::slice::iter::Iter") [] [ F ];
                                          Ty.apply (Ty.path "core::slice::iter::Iter") [] [ F ]
                                        ],
                                      M.get_function (|
                                        "core::iter::adapters::zip::zip",
                                        [],
                                        [
                                          Ty.apply
                                            (Ty.path "&")
                                            []
                                            [ Ty.apply (Ty.path "slice") [] [ F ] ];
                                          Ty.apply
                                            (Ty.path "&")
                                            []
                                            [ Ty.apply (Ty.path "slice") [] [ F ] ]
                                        ]
                                      |),
                                      [ M.read (| lhs_evals |); M.read (| rhs_evals |) ]
                                    |);
                                    M.closure
                                      (fun γ =>
                                        ltac:(M.monadic
                                          match γ with
                                          | [ α0 ] =>
                                            ltac:(M.monadic
                                              (M.match_operator (|
                                                F,
                                                M.alloc (|
                                                  Ty.tuple
                                                    [
                                                      Ty.apply (Ty.path "&") [] [ F ];
                                                      Ty.apply (Ty.path "&") [] [ F ]
                                                    ],
                                                  α0
                                                |),
                                                [
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (let γ0_0 :=
                                                        M.SubPointer.get_tuple_field (| γ, 0 |) in
                                                      let γ0_1 :=
                                                        M.SubPointer.get_tuple_field (| γ, 1 |) in
                                                      let γ0_0 := M.read (| γ0_0 |) in
                                                      let lhs_eval := M.copy (| F, γ0_0 |) in
                                                      let γ0_1 := M.read (| γ0_1 |) in
                                                      let rhs_eval := M.copy (| F, γ0_1 |) in
                                                      M.call_closure (|
                                                        F,
                                                        M.get_trait_method (|
                                                          "core::ops::arith::Add",
                                                          F,
                                                          [],
                                                          [ F ],
                                                          "add",
                                                          [],
                                                          []
                                                        |),
                                                        [
                                                          M.call_closure (|
                                                            F,
                                                            M.get_trait_method (|
                                                              "core::ops::arith::Mul",
                                                              F,
                                                              [],
                                                              [ F ],
                                                              "mul",
                                                              [],
                                                              []
                                                            |),
                                                            [
                                                              M.read (| alpha |);
                                                              M.call_closure (|
                                                                F,
                                                                M.get_trait_method (|
                                                                  "core::ops::arith::Sub",
                                                                  F,
                                                                  [],
                                                                  [ F ],
                                                                  "sub",
                                                                  [],
                                                                  []
                                                                |),
                                                                [
                                                                  M.read (| rhs_eval |);
                                                                  M.read (| lhs_eval |)
                                                                ]
                                                              |)
                                                            ]
                                                          |);
                                                          M.read (| lhs_eval |)
                                                        ]
                                                      |)))
                                                ]
                                              |)))
                                          | _ => M.impossible "wrong number of arguments"
                                          end))
                                  ]
                                |)
                              ]
                            |) in
                          M.alloc (|
                            Ty.apply (Ty.path "openvm_stark_backend::poly::multi::Mle") [] [ F ],
                            M.call_closure (|
                              Ty.apply (Ty.path "openvm_stark_backend::poly::multi::Mle") [] [ F ],
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "openvm_stark_backend::poly::multi::Mle")
                                  []
                                  [ F ],
                                "new",
                                [],
                                []
                              |),
                              [ M.read (| res |) ]
                            |)
                          |)
                        |)))
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (F : Ty.t),
        M.IsTraitInstance
          "openvm_stark_backend::poly::multi::MultivariatePolyOracle"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ F ]
          (Self F)
          (* Instance *)
          [
            ("arity", InstanceField.Method (arity F));
            ("marginalize_first", InstanceField.Method (marginalize_first F));
            ("partial_evaluation", InstanceField.Method (partial_evaluation F))
          ].
    End Impl_openvm_stark_backend_poly_multi_MultivariatePolyOracle_where_p3_field_field_Field_F_F_for_openvm_stark_backend_poly_multi_Mle_F.
    
    Module Impl_core_ops_deref_Deref_for_openvm_stark_backend_poly_multi_Mle_F.
      Definition Self (F : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "openvm_stark_backend::poly::multi::Mle") [] [ F ].
      
      (*     type Target = [F]; *)
      Definition _Target (F : Ty.t) : Ty.t := Ty.apply (Ty.path "slice") [] [ F ].
      
      (*
          fn deref(&self) -> &Self::Target {
              &self.evals
          }
      *)
      Definition deref (F : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.apply (Ty.path "openvm_stark_backend::poly::multi::Mle") [] [ F ] ],
                self
              |) in
            M.borrow (|
              Pointer.Kind.Ref,
              M.deref (|
                M.call_closure (|
                  Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ F ] ],
                  M.get_trait_method (|
                    "core::ops::deref::Deref",
                    Ty.apply (Ty.path "alloc::vec::Vec") [] [ F; Ty.path "alloc::alloc::Global" ],
                    [],
                    [],
                    "deref",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "openvm_stark_backend::poly::multi::Mle",
                            "evals"
                          |)
                        |)
                      |)
                    |)
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (F : Ty.t),
        M.IsTraitInstance
          "core::ops::deref::Deref"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self F)
          (* Instance *)
          [ ("Target", InstanceField.Ty (_Target F)); ("deref", InstanceField.Method (deref F)) ].
    End Impl_core_ops_deref_Deref_for_openvm_stark_backend_poly_multi_Mle_F.
    
    Module Impl_core_ops_deref_DerefMut_where_p3_field_field_Field_F_for_openvm_stark_backend_poly_multi_Mle_F.
      Definition Self (F : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "openvm_stark_backend::poly::multi::Mle") [] [ F ].
      
      (*
          fn deref_mut(&mut self) -> &mut Self::Target {
              &mut self.evals
          }
      *)
      Definition deref_mut (F : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&mut")
                  []
                  [ Ty.apply (Ty.path "openvm_stark_backend::poly::multi::Mle") [] [ F ] ],
                self
              |) in
            M.borrow (|
              Pointer.Kind.MutRef,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.MutRef,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ F ] ],
                      M.get_trait_method (|
                        "core::ops::deref::DerefMut",
                        Ty.apply
                          (Ty.path "alloc::vec::Vec")
                          []
                          [ F; Ty.path "alloc::alloc::Global" ],
                        [],
                        [],
                        "deref_mut",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.MutRef,
                          M.deref (|
                            M.borrow (|
                              Pointer.Kind.MutRef,
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "openvm_stark_backend::poly::multi::Mle",
                                "evals"
                              |)
                            |)
                          |)
                        |)
                      ]
                    |)
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (F : Ty.t),
        M.IsTraitInstance
          "core::ops::deref::DerefMut"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self F)
          (* Instance *) [ ("deref_mut", InstanceField.Method (deref_mut F)) ].
    End Impl_core_ops_deref_DerefMut_where_p3_field_field_Field_F_for_openvm_stark_backend_poly_multi_Mle_F.
    
    (*
    pub fn hypercube_eq<F: Field>(x: &[F], y: &[F]) -> F {
        assert_eq!(x.len(), y.len());
        zip(x, y)
            .map(|(&xi, &yi)| xi * yi + (xi - F::ONE) * (yi - F::ONE))
            .product()
    }
    *)
    Definition hypercube_eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ F ], [ x; y ] =>
        ltac:(M.monadic
          (let x :=
            M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ F ] ], x |) in
          let y :=
            M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ F ] ], y |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.match_operator (|
                Ty.tuple [],
                M.alloc (|
                  Ty.tuple
                    [
                      Ty.apply (Ty.path "&") [] [ Ty.path "usize" ];
                      Ty.apply (Ty.path "&") [] [ Ty.path "usize" ]
                    ],
                  Value.Tuple
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          Ty.path "usize",
                          M.call_closure (|
                            Ty.path "usize",
                            M.get_associated_function (|
                              Ty.apply (Ty.path "slice") [] [ F ],
                              "len",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| x |) |) |) ]
                          |)
                        |)
                      |);
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          Ty.path "usize",
                          M.call_closure (|
                            Ty.path "usize",
                            M.get_associated_function (|
                              Ty.apply (Ty.path "slice") [] [ F ],
                              "len",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| y |) |) |) ]
                          |)
                        |)
                      |)
                    ]
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                      let left_val :=
                        M.copy (| Ty.apply (Ty.path "&") [] [ Ty.path "usize" ], γ0_0 |) in
                      let right_val :=
                        M.copy (| Ty.apply (Ty.path "&") [] [ Ty.path "usize" ], γ0_1 |) in
                      M.match_operator (|
                        Ty.tuple [],
                        M.alloc (| Ty.tuple [], Value.Tuple [] |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ :=
                                M.use
                                  (M.alloc (|
                                    Ty.path "bool",
                                    UnOp.not (|
                                      M.call_closure (|
                                        Ty.path "bool",
                                        BinOp.eq,
                                        [
                                          M.read (| M.deref (| M.read (| left_val |) |) |);
                                          M.read (| M.deref (| M.read (| right_val |) |) |)
                                        ]
                                      |)
                                    |)
                                  |)) in
                              let _ :=
                                is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                              M.never_to_any (|
                                M.read (|
                                  let~ kind : Ty.path "core::panicking::AssertKind" :=
                                    Value.StructTuple "core::panicking::AssertKind::Eq" [] [] [] in
                                  M.alloc (|
                                    Ty.path "never",
                                    M.call_closure (|
                                      Ty.path "never",
                                      M.get_function (|
                                        "core::panicking::assert_failed",
                                        [],
                                        [ Ty.path "usize"; Ty.path "usize" ]
                                      |),
                                      [
                                        M.read (| kind |);
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (|
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (| M.read (| left_val |) |)
                                            |)
                                          |)
                                        |);
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (|
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (| M.read (| right_val |) |)
                                            |)
                                          |)
                                        |);
                                        Value.StructTuple
                                          "core::option::Option::None"
                                          []
                                          [ Ty.path "core::fmt::Arguments" ]
                                          []
                                      ]
                                    |)
                                  |)
                                |)
                              |)));
                          fun γ => ltac:(M.monadic (Value.Tuple []))
                        ]
                      |)))
                ]
              |) in
            M.alloc (|
              F,
              M.call_closure (|
                F,
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  Ty.apply
                    (Ty.path "core::iter::adapters::map::Map")
                    []
                    [
                      Ty.apply
                        (Ty.path "core::iter::adapters::zip::Zip")
                        []
                        [
                          Ty.apply (Ty.path "core::slice::iter::Iter") [] [ F ];
                          Ty.apply (Ty.path "core::slice::iter::Iter") [] [ F ]
                        ];
                      Ty.function
                        [
                          Ty.tuple
                            [ Ty.apply (Ty.path "&") [] [ F ]; Ty.apply (Ty.path "&") [] [ F ] ]
                        ]
                        F
                    ],
                  [],
                  [],
                  "product",
                  [],
                  [ F ]
                |),
                [
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::iter::adapters::map::Map")
                      []
                      [
                        Ty.apply
                          (Ty.path "core::iter::adapters::zip::Zip")
                          []
                          [
                            Ty.apply (Ty.path "core::slice::iter::Iter") [] [ F ];
                            Ty.apply (Ty.path "core::slice::iter::Iter") [] [ F ]
                          ];
                        Ty.function
                          [
                            Ty.tuple
                              [ Ty.apply (Ty.path "&") [] [ F ]; Ty.apply (Ty.path "&") [] [ F ] ]
                          ]
                          F
                      ],
                    M.get_trait_method (|
                      "core::iter::traits::iterator::Iterator",
                      Ty.apply
                        (Ty.path "core::iter::adapters::zip::Zip")
                        []
                        [
                          Ty.apply (Ty.path "core::slice::iter::Iter") [] [ F ];
                          Ty.apply (Ty.path "core::slice::iter::Iter") [] [ F ]
                        ],
                      [],
                      [],
                      "map",
                      [],
                      [
                        F;
                        Ty.function
                          [
                            Ty.tuple
                              [ Ty.apply (Ty.path "&") [] [ F ]; Ty.apply (Ty.path "&") [] [ F ] ]
                          ]
                          F
                      ]
                    |),
                    [
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::iter::adapters::zip::Zip")
                          []
                          [
                            Ty.apply (Ty.path "core::slice::iter::Iter") [] [ F ];
                            Ty.apply (Ty.path "core::slice::iter::Iter") [] [ F ]
                          ],
                        M.get_function (|
                          "core::iter::adapters::zip::zip",
                          [],
                          [
                            Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ F ] ];
                            Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ F ] ]
                          ]
                        |),
                        [ M.read (| x |); M.read (| y |) ]
                      |);
                      M.closure
                        (fun γ =>
                          ltac:(M.monadic
                            match γ with
                            | [ α0 ] =>
                              ltac:(M.monadic
                                (M.match_operator (|
                                  F,
                                  M.alloc (|
                                    Ty.tuple
                                      [
                                        Ty.apply (Ty.path "&") [] [ F ];
                                        Ty.apply (Ty.path "&") [] [ F ]
                                      ],
                                    α0
                                  |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                        let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                        let γ0_0 := M.read (| γ0_0 |) in
                                        let xi := M.copy (| F, γ0_0 |) in
                                        let γ0_1 := M.read (| γ0_1 |) in
                                        let yi := M.copy (| F, γ0_1 |) in
                                        M.call_closure (|
                                          F,
                                          M.get_trait_method (|
                                            "core::ops::arith::Add",
                                            F,
                                            [],
                                            [ F ],
                                            "add",
                                            [],
                                            []
                                          |),
                                          [
                                            M.call_closure (|
                                              F,
                                              M.get_trait_method (|
                                                "core::ops::arith::Mul",
                                                F,
                                                [],
                                                [ F ],
                                                "mul",
                                                [],
                                                []
                                              |),
                                              [ M.read (| xi |); M.read (| yi |) ]
                                            |);
                                            M.call_closure (|
                                              F,
                                              M.get_trait_method (|
                                                "core::ops::arith::Mul",
                                                F,
                                                [],
                                                [ F ],
                                                "mul",
                                                [],
                                                []
                                              |),
                                              [
                                                M.call_closure (|
                                                  F,
                                                  M.get_trait_method (|
                                                    "core::ops::arith::Sub",
                                                    F,
                                                    [],
                                                    [ F ],
                                                    "sub",
                                                    [],
                                                    []
                                                  |),
                                                  [
                                                    M.read (| xi |);
                                                    M.read (|
                                                      get_constant (|
                                                        "p3_field::field::FieldAlgebra::ONE",
                                                        F
                                                      |)
                                                    |)
                                                  ]
                                                |);
                                                M.call_closure (|
                                                  F,
                                                  M.get_trait_method (|
                                                    "core::ops::arith::Sub",
                                                    F,
                                                    [],
                                                    [ F ],
                                                    "sub",
                                                    [],
                                                    []
                                                  |),
                                                  [
                                                    M.read (| yi |);
                                                    M.read (|
                                                      get_constant (|
                                                        "p3_field::field::FieldAlgebra::ONE",
                                                        F
                                                      |)
                                                    |)
                                                  ]
                                                |)
                                              ]
                                            |)
                                          ]
                                        |)))
                                  ]
                                |)))
                            | _ => M.impossible "wrong number of arguments"
                            end))
                    ]
                  |)
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_hypercube_eq :
      M.IsFunction.C "openvm_stark_backend::poly::multi::hypercube_eq" hypercube_eq.
    Admitted.
    Global Typeclasses Opaque hypercube_eq.
    
    (*
    pub fn fold_mle_evals<F, EF>(assignment: EF, eval0: F, eval1: F) -> EF
    where
        F: Field,
        EF: ExtensionField<F>,
    {
        assignment * (eval1 - eval0) + eval0
    }
    *)
    Definition fold_mle_evals (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ F; EF ], [ assignment; eval0; eval1 ] =>
        ltac:(M.monadic
          (let assignment := M.alloc (| EF, assignment |) in
          let eval0 := M.alloc (| F, eval0 |) in
          let eval1 := M.alloc (| F, eval1 |) in
          M.call_closure (|
            EF,
            M.get_trait_method (| "core::ops::arith::Add", EF, [], [ F ], "add", [], [] |),
            [
              M.call_closure (|
                EF,
                M.get_trait_method (| "core::ops::arith::Mul", EF, [], [ F ], "mul", [], [] |),
                [
                  M.read (| assignment |);
                  M.call_closure (|
                    F,
                    M.get_trait_method (| "core::ops::arith::Sub", F, [], [ F ], "sub", [], [] |),
                    [ M.read (| eval1 |); M.read (| eval0 |) ]
                  |)
                ]
              |);
              M.read (| eval0 |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance Instance_IsFunction_fold_mle_evals :
      M.IsFunction.C "openvm_stark_backend::poly::multi::fold_mle_evals" fold_mle_evals.
    Admitted.
    Global Typeclasses Opaque fold_mle_evals.
  End multi.
End poly.
