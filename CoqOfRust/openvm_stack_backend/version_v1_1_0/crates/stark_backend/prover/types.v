(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module prover.
  Module types.
    (* StructRecord
      {
        name := "DeviceMultiStarkProvingKey";
        const_params := [];
        ty_params := [ "PB" ];
        fields :=
          [
            ("air_ids",
              Ty.apply
                (Ty.path "alloc::vec::Vec")
                []
                [ Ty.path "usize"; Ty.path "alloc::alloc::Global" ]);
            ("per_air",
              Ty.apply
                (Ty.path "alloc::vec::Vec")
                []
                [
                  Ty.apply
                    (Ty.path "openvm_stark_backend::prover::types::DeviceStarkProvingKey")
                    []
                    [ PB ];
                  Ty.path "alloc::alloc::Global"
                ]);
            ("trace_height_constraints",
              Ty.apply
                (Ty.path "alloc::vec::Vec")
                []
                [
                  Ty.path "openvm_stark_backend::keygen::types::LinearConstraint";
                  Ty.path "alloc::alloc::Global"
                ]);
            ("vk_pre_hash",
              Ty.associated_in_trait
                "openvm_stark_backend::prover::hal::ProverBackend"
                []
                []
                PB
                "Commitment")
          ];
      } *)
    
    Module Impl_openvm_stark_backend_prover_types_DeviceMultiStarkProvingKey_PB.
      Definition Self (PB : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "openvm_stark_backend::prover::types::DeviceMultiStarkProvingKey")
          []
          [ PB ].
      
      (*
          pub fn new(
              air_ids: Vec<usize>,
              per_air: Vec<DeviceStarkProvingKey<'a, PB>>,
              trace_height_constraints: Vec<LinearConstraint>,
              vk_pre_hash: PB::Commitment,
          ) -> Self {
              assert_eq!(air_ids.len(), per_air.len());
              Self {
                  air_ids,
                  per_air,
                  trace_height_constraints,
                  vk_pre_hash,
              }
          }
      *)
      Definition new (PB : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self PB in
        match ε, τ, α with
        | [], [], [ air_ids; per_air; trace_height_constraints; vk_pre_hash ] =>
          ltac:(M.monadic
            (let air_ids :=
              M.alloc (|
                Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  []
                  [ Ty.path "usize"; Ty.path "alloc::alloc::Global" ],
                air_ids
              |) in
            let per_air :=
              M.alloc (|
                Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  []
                  [
                    Ty.apply
                      (Ty.path "openvm_stark_backend::prover::types::DeviceStarkProvingKey")
                      []
                      [ PB ];
                    Ty.path "alloc::alloc::Global"
                  ],
                per_air
              |) in
            let trace_height_constraints :=
              M.alloc (|
                Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  []
                  [
                    Ty.path "openvm_stark_backend::keygen::types::LinearConstraint";
                    Ty.path "alloc::alloc::Global"
                  ],
                trace_height_constraints
              |) in
            let vk_pre_hash :=
              M.alloc (|
                Ty.associated_in_trait
                  "openvm_stark_backend::prover::hal::ProverBackend"
                  []
                  []
                  PB
                  "Commitment",
                vk_pre_hash
              |) in
            M.read (|
              let~ _ : Ty.tuple [] :=
                M.match_operator (|
                  Ty.tuple [],
                  M.alloc (|
                    Ty.tuple
                      [
                        Ty.apply (Ty.path "&") [] [ Ty.path "usize" ];
                        Ty.apply (Ty.path "&") [] [ Ty.path "usize" ]
                      ],
                    Value.Tuple
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.alloc (|
                            Ty.path "usize",
                            M.call_closure (|
                              Ty.path "usize",
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "alloc::vec::Vec")
                                  []
                                  [ Ty.path "usize"; Ty.path "alloc::alloc::Global" ],
                                "len",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.Ref, air_ids |) ]
                            |)
                          |)
                        |);
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.alloc (|
                            Ty.path "usize",
                            M.call_closure (|
                              Ty.path "usize",
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "alloc::vec::Vec")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path
                                        "openvm_stark_backend::prover::types::DeviceStarkProvingKey")
                                      []
                                      [ PB ];
                                    Ty.path "alloc::alloc::Global"
                                  ],
                                "len",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.Ref, per_air |) ]
                            |)
                          |)
                        |)
                      ]
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                        let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                        let left_val :=
                          M.copy (| Ty.apply (Ty.path "&") [] [ Ty.path "usize" ], γ0_0 |) in
                        let right_val :=
                          M.copy (| Ty.apply (Ty.path "&") [] [ Ty.path "usize" ], γ0_1 |) in
                        M.match_operator (|
                          Ty.tuple [],
                          M.alloc (| Ty.tuple [], Value.Tuple [] |),
                          [
                            fun γ =>
                              ltac:(M.monadic
                                (let γ :=
                                  M.use
                                    (M.alloc (|
                                      Ty.path "bool",
                                      UnOp.not (|
                                        M.call_closure (|
                                          Ty.path "bool",
                                          BinOp.eq,
                                          [
                                            M.read (| M.deref (| M.read (| left_val |) |) |);
                                            M.read (| M.deref (| M.read (| right_val |) |) |)
                                          ]
                                        |)
                                      |)
                                    |)) in
                                let _ :=
                                  is_constant_or_break_match (|
                                    M.read (| γ |),
                                    Value.Bool true
                                  |) in
                                M.never_to_any (|
                                  M.read (|
                                    let~ kind : Ty.path "core::panicking::AssertKind" :=
                                      Value.StructTuple
                                        "core::panicking::AssertKind::Eq"
                                        []
                                        []
                                        [] in
                                    M.alloc (|
                                      Ty.path "never",
                                      M.call_closure (|
                                        Ty.path "never",
                                        M.get_function (|
                                          "core::panicking::assert_failed",
                                          [],
                                          [ Ty.path "usize"; Ty.path "usize" ]
                                        |),
                                        [
                                          M.read (| kind |);
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (|
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.read (| left_val |) |)
                                              |)
                                            |)
                                          |);
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (|
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.read (| right_val |) |)
                                              |)
                                            |)
                                          |);
                                          Value.StructTuple
                                            "core::option::Option::None"
                                            []
                                            [ Ty.path "core::fmt::Arguments" ]
                                            []
                                        ]
                                      |)
                                    |)
                                  |)
                                |)));
                            fun γ => ltac:(M.monadic (Value.Tuple []))
                          ]
                        |)))
                  ]
                |) in
              M.alloc (|
                Ty.apply
                  (Ty.path "openvm_stark_backend::prover::types::DeviceMultiStarkProvingKey")
                  []
                  [ PB ],
                Value.mkStructRecord
                  "openvm_stark_backend::prover::types::DeviceMultiStarkProvingKey"
                  []
                  [ PB ]
                  [
                    ("air_ids", M.read (| air_ids |));
                    ("per_air", M.read (| per_air |));
                    ("trace_height_constraints", M.read (| trace_height_constraints |));
                    ("vk_pre_hash", M.read (| vk_pre_hash |))
                  ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_new :
        forall (PB : Ty.t),
        M.IsAssociatedFunction.C (Self PB) "new" (new PB).
      Admitted.
      Global Typeclasses Opaque new.
    End Impl_openvm_stark_backend_prover_types_DeviceMultiStarkProvingKey_PB.
    
    (* StructRecord
      {
        name := "DeviceStarkProvingKey";
        const_params := [];
        ty_params := [ "PB" ];
        fields :=
          [
            ("air_name", Ty.apply (Ty.path "&") [] [ Ty.path "str" ]);
            ("vk",
              Ty.apply
                (Ty.path "&")
                []
                [
                  Ty.apply
                    (Ty.path "openvm_stark_backend::keygen::types::StarkVerifyingKey")
                    []
                    [
                      Ty.associated_in_trait
                        "openvm_stark_backend::prover::hal::ProverBackend"
                        []
                        []
                        PB
                        "Val";
                      Ty.associated_in_trait
                        "openvm_stark_backend::prover::hal::ProverBackend"
                        []
                        []
                        PB
                        "Commitment"
                    ]
                ]);
            ("preprocessed_data",
              Ty.apply
                (Ty.path "core::option::Option")
                []
                [
                  Ty.apply
                    (Ty.path "openvm_stark_backend::prover::types::SingleCommitPreimage")
                    []
                    [
                      Ty.associated_in_trait
                        "openvm_stark_backend::prover::hal::ProverBackend"
                        []
                        []
                        PB
                        "Matrix";
                      Ty.associated_in_trait
                        "openvm_stark_backend::prover::hal::ProverBackend"
                        []
                        []
                        PB
                        "PcsData"
                    ]
                ]);
            ("rap_partial_pk",
              Ty.associated_in_trait
                "openvm_stark_backend::prover::hal::ProverBackend"
                []
                []
                PB
                "RapPartialProvingKey")
          ];
      } *)
    
    (* StructRecord
      {
        name := "SingleCommitPreimage";
        const_params := [];
        ty_params := [ "Matrix"; "PcsData" ];
        fields := [ ("trace", Matrix); ("data", PcsData); ("matrix_idx", Ty.path "u32") ];
      } *)
    
    Module Impl_core_clone_Clone_where_core_clone_Clone_Matrix_where_core_clone_Clone_PcsData_for_openvm_stark_backend_prover_types_SingleCommitPreimage_Matrix_PcsData.
      Definition Self (Matrix PcsData : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "openvm_stark_backend::prover::types::SingleCommitPreimage")
          []
          [ Matrix; PcsData ].
      
      (* Clone *)
      Definition clone
          (Matrix PcsData : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self Matrix PcsData in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path "openvm_stark_backend::prover::types::SingleCommitPreimage")
                      []
                      [ Matrix; PcsData ]
                  ],
                self
              |) in
            Value.mkStructRecord
              "openvm_stark_backend::prover::types::SingleCommitPreimage"
              []
              [ Matrix; PcsData ]
              [
                ("trace",
                  M.call_closure (|
                    Matrix,
                    M.get_trait_method (| "core::clone::Clone", Matrix, [], [], "clone", [], [] |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "openvm_stark_backend::prover::types::SingleCommitPreimage",
                              "trace"
                            |)
                          |)
                        |)
                      |)
                    ]
                  |));
                ("data",
                  M.call_closure (|
                    PcsData,
                    M.get_trait_method (| "core::clone::Clone", PcsData, [], [], "clone", [], [] |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "openvm_stark_backend::prover::types::SingleCommitPreimage",
                              "data"
                            |)
                          |)
                        |)
                      |)
                    ]
                  |));
                ("matrix_idx",
                  M.call_closure (|
                    Ty.path "u32",
                    M.get_trait_method (|
                      "core::clone::Clone",
                      Ty.path "u32",
                      [],
                      [],
                      "clone",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "openvm_stark_backend::prover::types::SingleCommitPreimage",
                              "matrix_idx"
                            |)
                          |)
                        |)
                      |)
                    ]
                  |))
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (Matrix PcsData : Ty.t),
        M.IsTraitInstance
          "core::clone::Clone"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self Matrix PcsData)
          (* Instance *) [ ("clone", InstanceField.Method (clone Matrix PcsData)) ].
    End Impl_core_clone_Clone_where_core_clone_Clone_Matrix_where_core_clone_Clone_PcsData_for_openvm_stark_backend_prover_types_SingleCommitPreimage_Matrix_PcsData.
    
    (* StructRecord
      {
        name := "ProvingContext";
        const_params := [];
        ty_params := [ "PB" ];
        fields :=
          [
            ("per_air",
              Ty.apply
                (Ty.path "alloc::vec::Vec")
                []
                [
                  Ty.tuple
                    [
                      Ty.path "usize";
                      Ty.apply
                        (Ty.path "openvm_stark_backend::prover::types::AirProvingContext")
                        []
                        [ PB ]
                    ];
                  Ty.path "alloc::alloc::Global"
                ])
          ];
      } *)
    
    Module Impl_openvm_stark_backend_prover_types_ProvingContext_PB.
      Definition Self (PB : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "openvm_stark_backend::prover::types::ProvingContext") [] [ PB ].
      
      (* derive_new::new *)
      Definition new (PB : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self PB in
        match ε, τ, α with
        | [], [], [ per_air ] =>
          ltac:(M.monadic
            (let per_air :=
              M.alloc (|
                Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  []
                  [
                    Ty.tuple
                      [
                        Ty.path "usize";
                        Ty.apply
                          (Ty.path "openvm_stark_backend::prover::types::AirProvingContext")
                          []
                          [ PB ]
                      ];
                    Ty.path "alloc::alloc::Global"
                  ],
                per_air
              |) in
            Value.mkStructRecord
              "openvm_stark_backend::prover::types::ProvingContext"
              []
              [ PB ]
              [ ("per_air", M.read (| per_air |)) ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_new :
        forall (PB : Ty.t),
        M.IsAssociatedFunction.C (Self PB) "new" (new PB).
      Admitted.
      Global Typeclasses Opaque new.
      (*
          pub fn into_air_proving_ctx_vec(self) -> Vec<AirProvingContext<'a, PB>> {
              self.per_air.into_iter().map(|(_, x)| x).collect()
          }
      *)
      Definition into_air_proving_ctx_vec
          (PB : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self PB in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "openvm_stark_backend::prover::types::ProvingContext") [] [ PB ],
                self
              |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "alloc::vec::Vec")
                []
                [
                  Ty.apply
                    (Ty.path "openvm_stark_backend::prover::types::AirProvingContext")
                    []
                    [ PB ];
                  Ty.path "alloc::alloc::Global"
                ],
              M.get_trait_method (|
                "core::iter::traits::iterator::Iterator",
                Ty.apply
                  (Ty.path "core::iter::adapters::map::Map")
                  []
                  [
                    Ty.apply
                      (Ty.path "alloc::vec::into_iter::IntoIter")
                      []
                      [
                        Ty.tuple
                          [
                            Ty.path "usize";
                            Ty.apply
                              (Ty.path "openvm_stark_backend::prover::types::AirProvingContext")
                              []
                              [ PB ]
                          ];
                        Ty.path "alloc::alloc::Global"
                      ];
                    Ty.function
                      [
                        Ty.tuple
                          [
                            Ty.path "usize";
                            Ty.apply
                              (Ty.path "openvm_stark_backend::prover::types::AirProvingContext")
                              []
                              [ PB ]
                          ]
                      ]
                      (Ty.apply
                        (Ty.path "openvm_stark_backend::prover::types::AirProvingContext")
                        []
                        [ PB ])
                  ],
                [],
                [],
                "collect",
                [],
                [
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [
                      Ty.apply
                        (Ty.path "openvm_stark_backend::prover::types::AirProvingContext")
                        []
                        [ PB ];
                      Ty.path "alloc::alloc::Global"
                    ]
                ]
              |),
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::iter::adapters::map::Map")
                    []
                    [
                      Ty.apply
                        (Ty.path "alloc::vec::into_iter::IntoIter")
                        []
                        [
                          Ty.tuple
                            [
                              Ty.path "usize";
                              Ty.apply
                                (Ty.path "openvm_stark_backend::prover::types::AirProvingContext")
                                []
                                [ PB ]
                            ];
                          Ty.path "alloc::alloc::Global"
                        ];
                      Ty.function
                        [
                          Ty.tuple
                            [
                              Ty.path "usize";
                              Ty.apply
                                (Ty.path "openvm_stark_backend::prover::types::AirProvingContext")
                                []
                                [ PB ]
                            ]
                        ]
                        (Ty.apply
                          (Ty.path "openvm_stark_backend::prover::types::AirProvingContext")
                          []
                          [ PB ])
                    ],
                  M.get_trait_method (|
                    "core::iter::traits::iterator::Iterator",
                    Ty.apply
                      (Ty.path "alloc::vec::into_iter::IntoIter")
                      []
                      [
                        Ty.tuple
                          [
                            Ty.path "usize";
                            Ty.apply
                              (Ty.path "openvm_stark_backend::prover::types::AirProvingContext")
                              []
                              [ PB ]
                          ];
                        Ty.path "alloc::alloc::Global"
                      ],
                    [],
                    [],
                    "map",
                    [],
                    [
                      Ty.apply
                        (Ty.path "openvm_stark_backend::prover::types::AirProvingContext")
                        []
                        [ PB ];
                      Ty.function
                        [
                          Ty.tuple
                            [
                              Ty.path "usize";
                              Ty.apply
                                (Ty.path "openvm_stark_backend::prover::types::AirProvingContext")
                                []
                                [ PB ]
                            ]
                        ]
                        (Ty.apply
                          (Ty.path "openvm_stark_backend::prover::types::AirProvingContext")
                          []
                          [ PB ])
                    ]
                  |),
                  [
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "alloc::vec::into_iter::IntoIter")
                        []
                        [
                          Ty.tuple
                            [
                              Ty.path "usize";
                              Ty.apply
                                (Ty.path "openvm_stark_backend::prover::types::AirProvingContext")
                                []
                                [ PB ]
                            ];
                          Ty.path "alloc::alloc::Global"
                        ],
                      M.get_trait_method (|
                        "core::iter::traits::collect::IntoIterator",
                        Ty.apply
                          (Ty.path "alloc::vec::Vec")
                          []
                          [
                            Ty.tuple
                              [
                                Ty.path "usize";
                                Ty.apply
                                  (Ty.path "openvm_stark_backend::prover::types::AirProvingContext")
                                  []
                                  [ PB ]
                              ];
                            Ty.path "alloc::alloc::Global"
                          ],
                        [],
                        [],
                        "into_iter",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            self,
                            "openvm_stark_backend::prover::types::ProvingContext",
                            "per_air"
                          |)
                        |)
                      ]
                    |);
                    M.closure
                      (fun γ =>
                        ltac:(M.monadic
                          match γ with
                          | [ α0 ] =>
                            ltac:(M.monadic
                              (M.match_operator (|
                                Ty.apply
                                  (Ty.path "openvm_stark_backend::prover::types::AirProvingContext")
                                  []
                                  [ PB ],
                                M.alloc (|
                                  Ty.tuple
                                    [
                                      Ty.path "usize";
                                      Ty.apply
                                        (Ty.path
                                          "openvm_stark_backend::prover::types::AirProvingContext")
                                        []
                                        [ PB ]
                                    ],
                                  α0
                                |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                      let x :=
                                        M.copy (|
                                          Ty.apply
                                            (Ty.path
                                              "openvm_stark_backend::prover::types::AirProvingContext")
                                            []
                                            [ PB ],
                                          γ0_1
                                        |) in
                                      M.read (| x |)))
                                ]
                              |)))
                          | _ => M.impossible "wrong number of arguments"
                          end))
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_into_air_proving_ctx_vec :
        forall (PB : Ty.t),
        M.IsAssociatedFunction.C (Self PB) "into_air_proving_ctx_vec" (into_air_proving_ctx_vec PB).
      Admitted.
      Global Typeclasses Opaque into_air_proving_ctx_vec.
    End Impl_openvm_stark_backend_prover_types_ProvingContext_PB.
    
    
    Module Impl_core_iter_traits_collect_IntoIterator_where_openvm_stark_backend_prover_hal_ProverBackend_PB_for_openvm_stark_backend_prover_types_ProvingContext_PB.
      Definition Self (PB : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "openvm_stark_backend::prover::types::ProvingContext") [] [ PB ].
      
      (*     type Item = (usize, AirProvingContext<'a, PB>); *)
      Definition _Item (PB : Ty.t) : Ty.t :=
        Ty.tuple
          [
            Ty.path "usize";
            Ty.apply (Ty.path "openvm_stark_backend::prover::types::AirProvingContext") [] [ PB ]
          ].
      
      (*     type IntoIter = std::vec::IntoIter<Self::Item>; *)
      Definition _IntoIter (PB : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "alloc::vec::into_iter::IntoIter")
          []
          [
            Ty.associated_in_trait
              "core::iter::traits::collect::IntoIterator"
              []
              []
              (Ty.apply (Ty.path "openvm_stark_backend::prover::types::ProvingContext") [] [ PB ])
              "Item";
            Ty.path "alloc::alloc::Global"
          ].
      
      (*
          fn into_iter(self) -> Self::IntoIter {
              self.per_air.into_iter()
          }
      *)
      Definition into_iter (PB : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self PB in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "openvm_stark_backend::prover::types::ProvingContext") [] [ PB ],
                self
              |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "alloc::vec::into_iter::IntoIter")
                []
                [
                  Ty.tuple
                    [
                      Ty.path "usize";
                      Ty.apply
                        (Ty.path "openvm_stark_backend::prover::types::AirProvingContext")
                        []
                        [ PB ]
                    ];
                  Ty.path "alloc::alloc::Global"
                ],
              M.get_trait_method (|
                "core::iter::traits::collect::IntoIterator",
                Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  []
                  [
                    Ty.tuple
                      [
                        Ty.path "usize";
                        Ty.apply
                          (Ty.path "openvm_stark_backend::prover::types::AirProvingContext")
                          []
                          [ PB ]
                      ];
                    Ty.path "alloc::alloc::Global"
                  ],
                [],
                [],
                "into_iter",
                [],
                []
              |),
              [
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    self,
                    "openvm_stark_backend::prover::types::ProvingContext",
                    "per_air"
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (PB : Ty.t),
        M.IsTraitInstance
          "core::iter::traits::collect::IntoIterator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self PB)
          (* Instance *)
          [
            ("Item", InstanceField.Ty (_Item PB));
            ("IntoIter", InstanceField.Ty (_IntoIter PB));
            ("into_iter", InstanceField.Method (into_iter PB))
          ].
    End Impl_core_iter_traits_collect_IntoIterator_where_openvm_stark_backend_prover_hal_ProverBackend_PB_for_openvm_stark_backend_prover_types_ProvingContext_PB.
    
    (* StructRecord
      {
        name := "AirProvingContext";
        const_params := [];
        ty_params := [ "PB" ];
        fields :=
          [
            ("cached_mains",
              Ty.apply
                (Ty.path "alloc::vec::Vec")
                []
                [
                  Ty.tuple
                    [
                      Ty.associated_in_trait
                        "openvm_stark_backend::prover::hal::ProverBackend"
                        []
                        []
                        PB
                        "Commitment";
                      Ty.apply
                        (Ty.path "openvm_stark_backend::prover::types::SingleCommitPreimage")
                        []
                        [
                          Ty.associated_in_trait
                            "openvm_stark_backend::prover::hal::ProverBackend"
                            []
                            []
                            PB
                            "Matrix";
                          Ty.associated_in_trait
                            "openvm_stark_backend::prover::hal::ProverBackend"
                            []
                            []
                            PB
                            "PcsData"
                        ]
                    ];
                  Ty.path "alloc::alloc::Global"
                ]);
            ("common_main",
              Ty.apply
                (Ty.path "core::option::Option")
                []
                [
                  Ty.associated_in_trait
                    "openvm_stark_backend::prover::hal::ProverBackend"
                    []
                    []
                    PB
                    "Matrix"
                ]);
            ("public_values",
              Ty.apply
                (Ty.path "alloc::vec::Vec")
                []
                [
                  Ty.associated_in_trait
                    "openvm_stark_backend::prover::hal::ProverBackend"
                    []
                    []
                    PB
                    "Val";
                  Ty.path "alloc::alloc::Global"
                ]);
            ("cached_lifetime",
              Ty.apply
                (Ty.path "core::marker::PhantomData")
                []
                [
                  Ty.apply
                    (Ty.path "&")
                    []
                    [
                      Ty.associated_in_trait
                        "openvm_stark_backend::prover::hal::ProverBackend"
                        []
                        []
                        PB
                        "PcsData"
                    ]
                ])
          ];
      } *)
    
    (* StructRecord
      {
        name := "AirView";
        const_params := [];
        ty_params := [ "T"; "Val" ];
        fields :=
          [
            ("partitioned_main",
              Ty.apply (Ty.path "alloc::vec::Vec") [] [ T; Ty.path "alloc::alloc::Global" ]);
            ("public_values",
              Ty.apply (Ty.path "alloc::vec::Vec") [] [ Val; Ty.path "alloc::alloc::Global" ])
          ];
      } *)
    
    (* StructRecord
      {
        name := "PairView";
        const_params := [];
        ty_params := [ "T"; "Val" ];
        fields :=
          [
            ("log_trace_height", Ty.path "u8");
            ("preprocessed", Ty.apply (Ty.path "core::option::Option") [] [ T ]);
            ("partitioned_main",
              Ty.apply (Ty.path "alloc::vec::Vec") [] [ T; Ty.path "alloc::alloc::Global" ]);
            ("public_values",
              Ty.apply (Ty.path "alloc::vec::Vec") [] [ Val; Ty.path "alloc::alloc::Global" ])
          ];
      } *)
    
    (* StructRecord
      {
        name := "RapView";
        const_params := [];
        ty_params := [ "T"; "Val"; "Challenge" ];
        fields :=
          [
            ("log_trace_height", Ty.path "u8");
            ("preprocessed", Ty.apply (Ty.path "core::option::Option") [] [ T ]);
            ("partitioned_main",
              Ty.apply (Ty.path "alloc::vec::Vec") [] [ T; Ty.path "alloc::alloc::Global" ]);
            ("public_values",
              Ty.apply (Ty.path "alloc::vec::Vec") [] [ Val; Ty.path "alloc::alloc::Global" ]);
            ("per_phase",
              Ty.apply
                (Ty.path "alloc::vec::Vec")
                []
                [
                  Ty.apply
                    (Ty.path "openvm_stark_backend::prover::types::RapSinglePhaseView")
                    []
                    [ T; Challenge ];
                  Ty.path "alloc::alloc::Global"
                ])
          ];
      } *)
    
    (* StructRecord
      {
        name := "RapSinglePhaseView";
        const_params := [];
        ty_params := [ "T"; "Challenge" ];
        fields :=
          [
            ("inner", Ty.apply (Ty.path "core::option::Option") [] [ T ]);
            ("challenges",
              Ty.apply
                (Ty.path "alloc::vec::Vec")
                []
                [ Challenge; Ty.path "alloc::alloc::Global" ]);
            ("exposed_values",
              Ty.apply (Ty.path "alloc::vec::Vec") [] [ Challenge; Ty.path "alloc::alloc::Global" ])
          ];
      } *)
    
    Module Impl_core_clone_Clone_where_core_clone_Clone_T_where_core_clone_Clone_Challenge_for_openvm_stark_backend_prover_types_RapSinglePhaseView_T_Challenge.
      Definition Self (T Challenge : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "openvm_stark_backend::prover::types::RapSinglePhaseView")
          []
          [ T; Challenge ].
      
      (* Clone *)
      Definition clone
          (T Challenge : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T Challenge in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path "openvm_stark_backend::prover::types::RapSinglePhaseView")
                      []
                      [ T; Challenge ]
                  ],
                self
              |) in
            Value.mkStructRecord
              "openvm_stark_backend::prover::types::RapSinglePhaseView"
              []
              [ T; Challenge ]
              [
                ("inner",
                  M.call_closure (|
                    Ty.apply (Ty.path "core::option::Option") [] [ T ],
                    M.get_trait_method (|
                      "core::clone::Clone",
                      Ty.apply (Ty.path "core::option::Option") [] [ T ],
                      [],
                      [],
                      "clone",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "openvm_stark_backend::prover::types::RapSinglePhaseView",
                              "inner"
                            |)
                          |)
                        |)
                      |)
                    ]
                  |));
                ("challenges",
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      []
                      [ Challenge; Ty.path "alloc::alloc::Global" ],
                    M.get_trait_method (|
                      "core::clone::Clone",
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        []
                        [ Challenge; Ty.path "alloc::alloc::Global" ],
                      [],
                      [],
                      "clone",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "openvm_stark_backend::prover::types::RapSinglePhaseView",
                              "challenges"
                            |)
                          |)
                        |)
                      |)
                    ]
                  |));
                ("exposed_values",
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      []
                      [ Challenge; Ty.path "alloc::alloc::Global" ],
                    M.get_trait_method (|
                      "core::clone::Clone",
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        []
                        [ Challenge; Ty.path "alloc::alloc::Global" ],
                      [],
                      [],
                      "clone",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "openvm_stark_backend::prover::types::RapSinglePhaseView",
                              "exposed_values"
                            |)
                          |)
                        |)
                      |)
                    ]
                  |))
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T Challenge : Ty.t),
        M.IsTraitInstance
          "core::clone::Clone"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T Challenge)
          (* Instance *) [ ("clone", InstanceField.Method (clone T Challenge)) ].
    End Impl_core_clone_Clone_where_core_clone_Clone_T_where_core_clone_Clone_Challenge_for_openvm_stark_backend_prover_types_RapSinglePhaseView_T_Challenge.
    
    Module Impl_core_default_Default_for_openvm_stark_backend_prover_types_RapSinglePhaseView_T_Challenge.
      Definition Self (T Challenge : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "openvm_stark_backend::prover::types::RapSinglePhaseView")
          []
          [ T; Challenge ].
      
      (*
          fn default() -> Self {
              Self {
                  inner: None,
                  challenges: Vec::new(),
                  exposed_values: Vec::new(),
              }
          }
      *)
      Definition default
          (T Challenge : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self T Challenge in
        match ε, τ, α with
        | [], [], [] =>
          ltac:(M.monadic
            (Value.mkStructRecord
              "openvm_stark_backend::prover::types::RapSinglePhaseView"
              []
              [ T; Challenge ]
              [
                ("inner", Value.StructTuple "core::option::Option::None" [] [ T ] []);
                ("challenges",
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      []
                      [ Challenge; Ty.path "alloc::alloc::Global" ],
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        []
                        [ Challenge; Ty.path "alloc::alloc::Global" ],
                      "new",
                      [],
                      []
                    |),
                    []
                  |));
                ("exposed_values",
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      []
                      [ Challenge; Ty.path "alloc::alloc::Global" ],
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        []
                        [ Challenge; Ty.path "alloc::alloc::Global" ],
                      "new",
                      [],
                      []
                    |),
                    []
                  |))
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (T Challenge : Ty.t),
        M.IsTraitInstance
          "core::default::Default"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self T Challenge)
          (* Instance *) [ ("default", InstanceField.Method (default T Challenge)) ].
    End Impl_core_default_Default_for_openvm_stark_backend_prover_types_RapSinglePhaseView_T_Challenge.
    
    (* StructRecord
      {
        name := "ProverDataAfterRapPhases";
        const_params := [];
        ty_params := [ "PB" ];
        fields :=
          [
            ("committed_pcs_data_per_phase",
              Ty.apply
                (Ty.path "alloc::vec::Vec")
                []
                [
                  Ty.tuple
                    [
                      Ty.associated_in_trait
                        "openvm_stark_backend::prover::hal::ProverBackend"
                        []
                        []
                        PB
                        "Commitment";
                      Ty.associated_in_trait
                        "openvm_stark_backend::prover::hal::ProverBackend"
                        []
                        []
                        PB
                        "PcsData"
                    ];
                  Ty.path "alloc::alloc::Global"
                ]);
            ("rap_views_per_phase",
              Ty.apply
                (Ty.path "alloc::vec::Vec")
                []
                [
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [
                      Ty.apply
                        (Ty.path "openvm_stark_backend::prover::types::RapSinglePhaseView")
                        []
                        [
                          Ty.path "usize";
                          Ty.associated_in_trait
                            "openvm_stark_backend::prover::hal::ProverBackend"
                            []
                            []
                            PB
                            "Challenge"
                        ];
                      Ty.path "alloc::alloc::Global"
                    ];
                  Ty.path "alloc::alloc::Global"
                ])
          ];
      } *)
    
    Module Impl_openvm_stark_backend_prover_types_ProverDataAfterRapPhases_PB.
      Definition Self (PB : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "openvm_stark_backend::prover::types::ProverDataAfterRapPhases")
          []
          [ PB ].
      
      (* derive_new::new *)
      Definition new (PB : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self PB in
        match ε, τ, α with
        | [], [], [ committed_pcs_data_per_phase; rap_views_per_phase ] =>
          ltac:(M.monadic
            (let committed_pcs_data_per_phase :=
              M.alloc (|
                Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  []
                  [
                    Ty.tuple
                      [
                        Ty.associated_in_trait
                          "openvm_stark_backend::prover::hal::ProverBackend"
                          []
                          []
                          PB
                          "Commitment";
                        Ty.associated_in_trait
                          "openvm_stark_backend::prover::hal::ProverBackend"
                          []
                          []
                          PB
                          "PcsData"
                      ];
                    Ty.path "alloc::alloc::Global"
                  ],
                committed_pcs_data_per_phase
              |) in
            let rap_views_per_phase :=
              M.alloc (|
                Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  []
                  [
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      []
                      [
                        Ty.apply
                          (Ty.path "openvm_stark_backend::prover::types::RapSinglePhaseView")
                          []
                          [
                            Ty.path "usize";
                            Ty.associated_in_trait
                              "openvm_stark_backend::prover::hal::ProverBackend"
                              []
                              []
                              PB
                              "Challenge"
                          ];
                        Ty.path "alloc::alloc::Global"
                      ];
                    Ty.path "alloc::alloc::Global"
                  ],
                rap_views_per_phase
              |) in
            Value.mkStructRecord
              "openvm_stark_backend::prover::types::ProverDataAfterRapPhases"
              []
              [ PB ]
              [
                ("committed_pcs_data_per_phase", M.read (| committed_pcs_data_per_phase |));
                ("rap_views_per_phase", M.read (| rap_views_per_phase |))
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_new :
        forall (PB : Ty.t),
        M.IsAssociatedFunction.C (Self PB) "new" (new PB).
      Admitted.
      Global Typeclasses Opaque new.
    End Impl_openvm_stark_backend_prover_types_ProverDataAfterRapPhases_PB.
    
    (* StructRecord
      {
        name := "HalProof";
        const_params := [];
        ty_params := [ "PB" ];
        fields :=
          [
            ("commitments",
              Ty.apply
                (Ty.path "openvm_stark_backend::proof::Commitments")
                []
                [
                  Ty.associated_in_trait
                    "openvm_stark_backend::prover::hal::ProverBackend"
                    []
                    []
                    PB
                    "Commitment"
                ]);
            ("opening",
              Ty.associated_in_trait
                "openvm_stark_backend::prover::hal::ProverBackend"
                []
                []
                PB
                "OpeningProof");
            ("per_air",
              Ty.apply
                (Ty.path "alloc::vec::Vec")
                []
                [
                  Ty.apply
                    (Ty.path "openvm_stark_backend::proof::AirProofData")
                    []
                    [
                      Ty.associated_in_trait
                        "openvm_stark_backend::prover::hal::ProverBackend"
                        []
                        []
                        PB
                        "Val";
                      Ty.associated_in_trait
                        "openvm_stark_backend::prover::hal::ProverBackend"
                        []
                        []
                        PB
                        "Challenge"
                    ];
                  Ty.path "alloc::alloc::Global"
                ]);
            ("rap_partial_proof",
              Ty.associated_in_trait
                "openvm_stark_backend::prover::hal::ProverBackend"
                []
                []
                PB
                "RapPartialProof")
          ];
      } *)
    
    Module underscore.
      Module Impl_serde_ser_Serialize_where_openvm_stark_backend_prover_hal_ProverBackend_PB_for_openvm_stark_backend_prover_types_HalProof_PB.
        Definition Self (PB : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "openvm_stark_backend::prover::types::HalProof") [] [ PB ].
        
        (* Serialize *)
        Definition serialize
            (PB : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self PB in
          match ε, τ, α with
          | [], [ __S ], [ self; __serializer ] =>
            ltac:(M.monadic
              (let self :=
                M.alloc (|
                  Ty.apply
                    (Ty.path "&")
                    []
                    [ Ty.apply (Ty.path "openvm_stark_backend::prover::types::HalProof") [] [ PB ]
                    ],
                  self
                |) in
              let __serializer := M.alloc (| __S, __serializer |) in
              M.catch_return
                (Ty.apply
                  (Ty.path "core::result::Result")
                  []
                  [
                    Ty.associated_in_trait "serde::ser::Serializer" [] [] __S "Ok";
                    Ty.associated_in_trait "serde::ser::Serializer" [] [] __S "Error"
                  ]) (|
                ltac:(M.monadic
                  (M.read (|
                    let~ __serde_state :
                        Ty.associated_in_trait
                          "serde::ser::Serializer"
                          []
                          []
                          __S
                          "SerializeStruct" :=
                      M.match_operator (|
                        Ty.associated_in_trait "serde::ser::Serializer" [] [] __S "SerializeStruct",
                        M.alloc (|
                          Ty.apply
                            (Ty.path "core::ops::control_flow::ControlFlow")
                            []
                            [
                              Ty.apply
                                (Ty.path "core::result::Result")
                                []
                                [
                                  Ty.path "core::convert::Infallible";
                                  Ty.associated_in_trait "serde::ser::Serializer" [] [] __S "Error"
                                ];
                              Ty.associated_in_trait
                                "serde::ser::Serializer"
                                []
                                []
                                __S
                                "SerializeStruct"
                            ],
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "core::ops::control_flow::ControlFlow")
                              []
                              [
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  []
                                  [
                                    Ty.path "core::convert::Infallible";
                                    Ty.associated_in_trait
                                      "serde::ser::Serializer"
                                      []
                                      []
                                      __S
                                      "Error"
                                  ];
                                Ty.associated_in_trait
                                  "serde::ser::Serializer"
                                  []
                                  []
                                  __S
                                  "SerializeStruct"
                              ],
                            M.get_trait_method (|
                              "core::ops::try_trait::Try",
                              Ty.apply
                                (Ty.path "core::result::Result")
                                []
                                [
                                  Ty.associated_in_trait
                                    "serde::ser::Serializer"
                                    []
                                    []
                                    __S
                                    "SerializeStruct";
                                  Ty.associated_in_trait "serde::ser::Serializer" [] [] __S "Error"
                                ],
                              [],
                              [],
                              "branch",
                              [],
                              []
                            |),
                            [
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  []
                                  [
                                    Ty.associated_in_trait
                                      "serde::ser::Serializer"
                                      []
                                      []
                                      __S
                                      "SerializeStruct";
                                    Ty.associated_in_trait
                                      "serde::ser::Serializer"
                                      []
                                      []
                                      __S
                                      "Error"
                                  ],
                                M.get_trait_method (|
                                  "serde::ser::Serializer",
                                  __S,
                                  [],
                                  [],
                                  "serialize_struct",
                                  [],
                                  []
                                |),
                                [
                                  M.read (| __serializer |);
                                  mk_str (| "HalProof" |);
                                  M.call_closure (|
                                    Ty.path "usize",
                                    BinOp.Wrap.add,
                                    [
                                      M.call_closure (|
                                        Ty.path "usize",
                                        BinOp.Wrap.add,
                                        [
                                          M.call_closure (|
                                            Ty.path "usize",
                                            BinOp.Wrap.add,
                                            [
                                              M.call_closure (|
                                                Ty.path "usize",
                                                BinOp.Wrap.add,
                                                [
                                                  M.cast (Ty.path "usize") (Value.Bool false);
                                                  Value.Integer IntegerKind.Usize 1
                                                ]
                                              |);
                                              Value.Integer IntegerKind.Usize 1
                                            ]
                                          |);
                                          Value.Integer IntegerKind.Usize 1
                                        ]
                                      |);
                                      Value.Integer IntegerKind.Usize 1
                                    ]
                                  |)
                                ]
                              |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Break",
                                  0
                                |) in
                              let residual :=
                                M.copy (|
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [
                                      Ty.path "core::convert::Infallible";
                                      Ty.associated_in_trait
                                        "serde::ser::Serializer"
                                        []
                                        []
                                        __S
                                        "Error"
                                    ],
                                  γ0_0
                                |) in
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        []
                                        [
                                          Ty.associated_in_trait
                                            "serde::ser::Serializer"
                                            []
                                            []
                                            __S
                                            "Ok";
                                          Ty.associated_in_trait
                                            "serde::ser::Serializer"
                                            []
                                            []
                                            __S
                                            "Error"
                                        ],
                                      M.get_trait_method (|
                                        "core::ops::try_trait::FromResidual",
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          []
                                          [
                                            Ty.associated_in_trait
                                              "serde::ser::Serializer"
                                              []
                                              []
                                              __S
                                              "Ok";
                                            Ty.associated_in_trait
                                              "serde::ser::Serializer"
                                              []
                                              []
                                              __S
                                              "Error"
                                          ],
                                        [],
                                        [
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            []
                                            [
                                              Ty.path "core::convert::Infallible";
                                              Ty.associated_in_trait
                                                "serde::ser::Serializer"
                                                []
                                                []
                                                __S
                                                "Error"
                                            ]
                                        ],
                                        "from_residual",
                                        [],
                                        []
                                      |),
                                      [ M.read (| residual |) ]
                                    |)
                                  |)
                                |)
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Continue",
                                  0
                                |) in
                              let val :=
                                M.copy (|
                                  Ty.associated_in_trait
                                    "serde::ser::Serializer"
                                    []
                                    []
                                    __S
                                    "SerializeStruct",
                                  γ0_0
                                |) in
                              M.read (| val |)))
                        ]
                      |) in
                    let~ _ : Ty.tuple [] :=
                      M.match_operator (|
                        Ty.tuple [],
                        M.alloc (|
                          Ty.apply
                            (Ty.path "core::ops::control_flow::ControlFlow")
                            []
                            [
                              Ty.apply
                                (Ty.path "core::result::Result")
                                []
                                [
                                  Ty.path "core::convert::Infallible";
                                  Ty.associated_in_trait "serde::ser::Serializer" [] [] __S "Error"
                                ];
                              Ty.tuple []
                            ],
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "core::ops::control_flow::ControlFlow")
                              []
                              [
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  []
                                  [
                                    Ty.path "core::convert::Infallible";
                                    Ty.associated_in_trait
                                      "serde::ser::Serializer"
                                      []
                                      []
                                      __S
                                      "Error"
                                  ];
                                Ty.tuple []
                              ],
                            M.get_trait_method (|
                              "core::ops::try_trait::Try",
                              Ty.apply
                                (Ty.path "core::result::Result")
                                []
                                [
                                  Ty.tuple [];
                                  Ty.associated_in_trait "serde::ser::Serializer" [] [] __S "Error"
                                ],
                              [],
                              [],
                              "branch",
                              [],
                              []
                            |),
                            [
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  []
                                  [
                                    Ty.tuple [];
                                    Ty.associated_in_trait
                                      "serde::ser::Serializer"
                                      []
                                      []
                                      __S
                                      "Error"
                                  ],
                                M.get_trait_method (|
                                  "serde::ser::SerializeStruct",
                                  Ty.associated_in_trait
                                    "serde::ser::Serializer"
                                    []
                                    []
                                    __S
                                    "SerializeStruct",
                                  [],
                                  [],
                                  "serialize_field",
                                  [],
                                  [
                                    Ty.apply
                                      (Ty.path "openvm_stark_backend::proof::Commitments")
                                      []
                                      [
                                        Ty.associated_in_trait
                                          "openvm_stark_backend::prover::hal::ProverBackend"
                                          []
                                          []
                                          PB
                                          "Commitment"
                                      ]
                                  ]
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.MutRef,
                                    M.deref (| M.borrow (| Pointer.Kind.MutRef, __serde_state |) |)
                                  |);
                                  mk_str (| "commitments" |);
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.SubPointer.get_struct_record_field (|
                                          M.deref (| M.read (| self |) |),
                                          "openvm_stark_backend::prover::types::HalProof",
                                          "commitments"
                                        |)
                                      |)
                                    |)
                                  |)
                                ]
                              |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Break",
                                  0
                                |) in
                              let residual :=
                                M.copy (|
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [
                                      Ty.path "core::convert::Infallible";
                                      Ty.associated_in_trait
                                        "serde::ser::Serializer"
                                        []
                                        []
                                        __S
                                        "Error"
                                    ],
                                  γ0_0
                                |) in
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        []
                                        [
                                          Ty.associated_in_trait
                                            "serde::ser::Serializer"
                                            []
                                            []
                                            __S
                                            "Ok";
                                          Ty.associated_in_trait
                                            "serde::ser::Serializer"
                                            []
                                            []
                                            __S
                                            "Error"
                                        ],
                                      M.get_trait_method (|
                                        "core::ops::try_trait::FromResidual",
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          []
                                          [
                                            Ty.associated_in_trait
                                              "serde::ser::Serializer"
                                              []
                                              []
                                              __S
                                              "Ok";
                                            Ty.associated_in_trait
                                              "serde::ser::Serializer"
                                              []
                                              []
                                              __S
                                              "Error"
                                          ],
                                        [],
                                        [
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            []
                                            [
                                              Ty.path "core::convert::Infallible";
                                              Ty.associated_in_trait
                                                "serde::ser::Serializer"
                                                []
                                                []
                                                __S
                                                "Error"
                                            ]
                                        ],
                                        "from_residual",
                                        [],
                                        []
                                      |),
                                      [ M.read (| residual |) ]
                                    |)
                                  |)
                                |)
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Continue",
                                  0
                                |) in
                              let val := M.copy (| Ty.tuple [], γ0_0 |) in
                              M.read (| val |)))
                        ]
                      |) in
                    let~ _ : Ty.tuple [] :=
                      M.match_operator (|
                        Ty.tuple [],
                        M.alloc (|
                          Ty.apply
                            (Ty.path "core::ops::control_flow::ControlFlow")
                            []
                            [
                              Ty.apply
                                (Ty.path "core::result::Result")
                                []
                                [
                                  Ty.path "core::convert::Infallible";
                                  Ty.associated_in_trait "serde::ser::Serializer" [] [] __S "Error"
                                ];
                              Ty.tuple []
                            ],
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "core::ops::control_flow::ControlFlow")
                              []
                              [
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  []
                                  [
                                    Ty.path "core::convert::Infallible";
                                    Ty.associated_in_trait
                                      "serde::ser::Serializer"
                                      []
                                      []
                                      __S
                                      "Error"
                                  ];
                                Ty.tuple []
                              ],
                            M.get_trait_method (|
                              "core::ops::try_trait::Try",
                              Ty.apply
                                (Ty.path "core::result::Result")
                                []
                                [
                                  Ty.tuple [];
                                  Ty.associated_in_trait "serde::ser::Serializer" [] [] __S "Error"
                                ],
                              [],
                              [],
                              "branch",
                              [],
                              []
                            |),
                            [
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  []
                                  [
                                    Ty.tuple [];
                                    Ty.associated_in_trait
                                      "serde::ser::Serializer"
                                      []
                                      []
                                      __S
                                      "Error"
                                  ],
                                M.get_trait_method (|
                                  "serde::ser::SerializeStruct",
                                  Ty.associated_in_trait
                                    "serde::ser::Serializer"
                                    []
                                    []
                                    __S
                                    "SerializeStruct",
                                  [],
                                  [],
                                  "serialize_field",
                                  [],
                                  [
                                    Ty.associated_in_trait
                                      "openvm_stark_backend::prover::hal::ProverBackend"
                                      []
                                      []
                                      PB
                                      "OpeningProof"
                                  ]
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.MutRef,
                                    M.deref (| M.borrow (| Pointer.Kind.MutRef, __serde_state |) |)
                                  |);
                                  mk_str (| "opening" |);
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.SubPointer.get_struct_record_field (|
                                          M.deref (| M.read (| self |) |),
                                          "openvm_stark_backend::prover::types::HalProof",
                                          "opening"
                                        |)
                                      |)
                                    |)
                                  |)
                                ]
                              |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Break",
                                  0
                                |) in
                              let residual :=
                                M.copy (|
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [
                                      Ty.path "core::convert::Infallible";
                                      Ty.associated_in_trait
                                        "serde::ser::Serializer"
                                        []
                                        []
                                        __S
                                        "Error"
                                    ],
                                  γ0_0
                                |) in
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        []
                                        [
                                          Ty.associated_in_trait
                                            "serde::ser::Serializer"
                                            []
                                            []
                                            __S
                                            "Ok";
                                          Ty.associated_in_trait
                                            "serde::ser::Serializer"
                                            []
                                            []
                                            __S
                                            "Error"
                                        ],
                                      M.get_trait_method (|
                                        "core::ops::try_trait::FromResidual",
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          []
                                          [
                                            Ty.associated_in_trait
                                              "serde::ser::Serializer"
                                              []
                                              []
                                              __S
                                              "Ok";
                                            Ty.associated_in_trait
                                              "serde::ser::Serializer"
                                              []
                                              []
                                              __S
                                              "Error"
                                          ],
                                        [],
                                        [
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            []
                                            [
                                              Ty.path "core::convert::Infallible";
                                              Ty.associated_in_trait
                                                "serde::ser::Serializer"
                                                []
                                                []
                                                __S
                                                "Error"
                                            ]
                                        ],
                                        "from_residual",
                                        [],
                                        []
                                      |),
                                      [ M.read (| residual |) ]
                                    |)
                                  |)
                                |)
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Continue",
                                  0
                                |) in
                              let val := M.copy (| Ty.tuple [], γ0_0 |) in
                              M.read (| val |)))
                        ]
                      |) in
                    let~ _ : Ty.tuple [] :=
                      M.match_operator (|
                        Ty.tuple [],
                        M.alloc (|
                          Ty.apply
                            (Ty.path "core::ops::control_flow::ControlFlow")
                            []
                            [
                              Ty.apply
                                (Ty.path "core::result::Result")
                                []
                                [
                                  Ty.path "core::convert::Infallible";
                                  Ty.associated_in_trait "serde::ser::Serializer" [] [] __S "Error"
                                ];
                              Ty.tuple []
                            ],
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "core::ops::control_flow::ControlFlow")
                              []
                              [
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  []
                                  [
                                    Ty.path "core::convert::Infallible";
                                    Ty.associated_in_trait
                                      "serde::ser::Serializer"
                                      []
                                      []
                                      __S
                                      "Error"
                                  ];
                                Ty.tuple []
                              ],
                            M.get_trait_method (|
                              "core::ops::try_trait::Try",
                              Ty.apply
                                (Ty.path "core::result::Result")
                                []
                                [
                                  Ty.tuple [];
                                  Ty.associated_in_trait "serde::ser::Serializer" [] [] __S "Error"
                                ],
                              [],
                              [],
                              "branch",
                              [],
                              []
                            |),
                            [
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  []
                                  [
                                    Ty.tuple [];
                                    Ty.associated_in_trait
                                      "serde::ser::Serializer"
                                      []
                                      []
                                      __S
                                      "Error"
                                  ],
                                M.get_trait_method (|
                                  "serde::ser::SerializeStruct",
                                  Ty.associated_in_trait
                                    "serde::ser::Serializer"
                                    []
                                    []
                                    __S
                                    "SerializeStruct",
                                  [],
                                  [],
                                  "serialize_field",
                                  [],
                                  [
                                    Ty.apply
                                      (Ty.path "alloc::vec::Vec")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "openvm_stark_backend::proof::AirProofData")
                                          []
                                          [
                                            Ty.associated_in_trait
                                              "openvm_stark_backend::prover::hal::ProverBackend"
                                              []
                                              []
                                              PB
                                              "Val";
                                            Ty.associated_in_trait
                                              "openvm_stark_backend::prover::hal::ProverBackend"
                                              []
                                              []
                                              PB
                                              "Challenge"
                                          ];
                                        Ty.path "alloc::alloc::Global"
                                      ]
                                  ]
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.MutRef,
                                    M.deref (| M.borrow (| Pointer.Kind.MutRef, __serde_state |) |)
                                  |);
                                  mk_str (| "per_air" |);
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.SubPointer.get_struct_record_field (|
                                          M.deref (| M.read (| self |) |),
                                          "openvm_stark_backend::prover::types::HalProof",
                                          "per_air"
                                        |)
                                      |)
                                    |)
                                  |)
                                ]
                              |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Break",
                                  0
                                |) in
                              let residual :=
                                M.copy (|
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [
                                      Ty.path "core::convert::Infallible";
                                      Ty.associated_in_trait
                                        "serde::ser::Serializer"
                                        []
                                        []
                                        __S
                                        "Error"
                                    ],
                                  γ0_0
                                |) in
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        []
                                        [
                                          Ty.associated_in_trait
                                            "serde::ser::Serializer"
                                            []
                                            []
                                            __S
                                            "Ok";
                                          Ty.associated_in_trait
                                            "serde::ser::Serializer"
                                            []
                                            []
                                            __S
                                            "Error"
                                        ],
                                      M.get_trait_method (|
                                        "core::ops::try_trait::FromResidual",
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          []
                                          [
                                            Ty.associated_in_trait
                                              "serde::ser::Serializer"
                                              []
                                              []
                                              __S
                                              "Ok";
                                            Ty.associated_in_trait
                                              "serde::ser::Serializer"
                                              []
                                              []
                                              __S
                                              "Error"
                                          ],
                                        [],
                                        [
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            []
                                            [
                                              Ty.path "core::convert::Infallible";
                                              Ty.associated_in_trait
                                                "serde::ser::Serializer"
                                                []
                                                []
                                                __S
                                                "Error"
                                            ]
                                        ],
                                        "from_residual",
                                        [],
                                        []
                                      |),
                                      [ M.read (| residual |) ]
                                    |)
                                  |)
                                |)
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Continue",
                                  0
                                |) in
                              let val := M.copy (| Ty.tuple [], γ0_0 |) in
                              M.read (| val |)))
                        ]
                      |) in
                    let~ _ : Ty.tuple [] :=
                      M.match_operator (|
                        Ty.tuple [],
                        M.alloc (|
                          Ty.apply
                            (Ty.path "core::ops::control_flow::ControlFlow")
                            []
                            [
                              Ty.apply
                                (Ty.path "core::result::Result")
                                []
                                [
                                  Ty.path "core::convert::Infallible";
                                  Ty.associated_in_trait "serde::ser::Serializer" [] [] __S "Error"
                                ];
                              Ty.tuple []
                            ],
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "core::ops::control_flow::ControlFlow")
                              []
                              [
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  []
                                  [
                                    Ty.path "core::convert::Infallible";
                                    Ty.associated_in_trait
                                      "serde::ser::Serializer"
                                      []
                                      []
                                      __S
                                      "Error"
                                  ];
                                Ty.tuple []
                              ],
                            M.get_trait_method (|
                              "core::ops::try_trait::Try",
                              Ty.apply
                                (Ty.path "core::result::Result")
                                []
                                [
                                  Ty.tuple [];
                                  Ty.associated_in_trait "serde::ser::Serializer" [] [] __S "Error"
                                ],
                              [],
                              [],
                              "branch",
                              [],
                              []
                            |),
                            [
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  []
                                  [
                                    Ty.tuple [];
                                    Ty.associated_in_trait
                                      "serde::ser::Serializer"
                                      []
                                      []
                                      __S
                                      "Error"
                                  ],
                                M.get_trait_method (|
                                  "serde::ser::SerializeStruct",
                                  Ty.associated_in_trait
                                    "serde::ser::Serializer"
                                    []
                                    []
                                    __S
                                    "SerializeStruct",
                                  [],
                                  [],
                                  "serialize_field",
                                  [],
                                  [
                                    Ty.associated_in_trait
                                      "openvm_stark_backend::prover::hal::ProverBackend"
                                      []
                                      []
                                      PB
                                      "RapPartialProof"
                                  ]
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.MutRef,
                                    M.deref (| M.borrow (| Pointer.Kind.MutRef, __serde_state |) |)
                                  |);
                                  mk_str (| "rap_partial_proof" |);
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.SubPointer.get_struct_record_field (|
                                          M.deref (| M.read (| self |) |),
                                          "openvm_stark_backend::prover::types::HalProof",
                                          "rap_partial_proof"
                                        |)
                                      |)
                                    |)
                                  |)
                                ]
                              |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Break",
                                  0
                                |) in
                              let residual :=
                                M.copy (|
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [
                                      Ty.path "core::convert::Infallible";
                                      Ty.associated_in_trait
                                        "serde::ser::Serializer"
                                        []
                                        []
                                        __S
                                        "Error"
                                    ],
                                  γ0_0
                                |) in
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        []
                                        [
                                          Ty.associated_in_trait
                                            "serde::ser::Serializer"
                                            []
                                            []
                                            __S
                                            "Ok";
                                          Ty.associated_in_trait
                                            "serde::ser::Serializer"
                                            []
                                            []
                                            __S
                                            "Error"
                                        ],
                                      M.get_trait_method (|
                                        "core::ops::try_trait::FromResidual",
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          []
                                          [
                                            Ty.associated_in_trait
                                              "serde::ser::Serializer"
                                              []
                                              []
                                              __S
                                              "Ok";
                                            Ty.associated_in_trait
                                              "serde::ser::Serializer"
                                              []
                                              []
                                              __S
                                              "Error"
                                          ],
                                        [],
                                        [
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            []
                                            [
                                              Ty.path "core::convert::Infallible";
                                              Ty.associated_in_trait
                                                "serde::ser::Serializer"
                                                []
                                                []
                                                __S
                                                "Error"
                                            ]
                                        ],
                                        "from_residual",
                                        [],
                                        []
                                      |),
                                      [ M.read (| residual |) ]
                                    |)
                                  |)
                                |)
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Continue",
                                  0
                                |) in
                              let val := M.copy (| Ty.tuple [], γ0_0 |) in
                              M.read (| val |)))
                        ]
                      |) in
                    M.alloc (|
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [
                          Ty.associated_in_trait "serde::ser::Serializer" [] [] __S "Ok";
                          Ty.associated_in_trait "serde::ser::Serializer" [] [] __S "Error"
                        ],
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [
                            Ty.associated_in_trait "serde::ser::Serializer" [] [] __S "Ok";
                            Ty.associated_in_trait "serde::ser::Serializer" [] [] __S "Error"
                          ],
                        M.get_trait_method (|
                          "serde::ser::SerializeStruct",
                          Ty.associated_in_trait
                            "serde::ser::Serializer"
                            []
                            []
                            __S
                            "SerializeStruct",
                          [],
                          [],
                          "end",
                          [],
                          []
                        |),
                        [ M.read (| __serde_state |) ]
                      |)
                    |)
                  |)))
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          forall (PB : Ty.t),
          M.IsTraitInstance
            "serde::ser::Serialize"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) []
            (Self PB)
            (* Instance *) [ ("serialize", InstanceField.Method (serialize PB)) ].
      End Impl_serde_ser_Serialize_where_openvm_stark_backend_prover_hal_ProverBackend_PB_for_openvm_stark_backend_prover_types_HalProof_PB.
      Module Impl_serde_de_Deserialize_where_openvm_stark_backend_prover_hal_ProverBackend_PB_for_openvm_stark_backend_prover_types_HalProof_PB.
        Definition Self (PB : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "openvm_stark_backend::prover::types::HalProof") [] [ PB ].
        
        (* Deserialize *)
        Definition deserialize
            (PB : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self PB in
          match ε, τ, α with
          | [], [ __D ], [ __deserializer ] =>
            ltac:(M.monadic
              (let __deserializer := M.alloc (| __D, __deserializer |) in
              M.call_closure (|
                Ty.apply
                  (Ty.path "core::result::Result")
                  []
                  [
                    Ty.apply (Ty.path "openvm_stark_backend::prover::types::HalProof") [] [ PB ];
                    Ty.associated_in_trait "serde::de::Deserializer" [] [] __D "Error"
                  ],
                M.get_trait_method (|
                  "serde::de::Deserializer",
                  __D,
                  [],
                  [],
                  "deserialize_struct",
                  [],
                  [
                    Ty.apply
                      (Ty.path "openvm_stark_backend::prover::types::_'1::deserialize::__Visitor")
                      []
                      [ PB ]
                  ]
                |),
                [
                  M.read (| __deserializer |);
                  mk_str (| "HalProof" |);
                  M.read (|
                    get_constant (|
                      "openvm_stark_backend::prover::types::_'1::deserialize::FIELDS",
                      Ty.apply
                        (Ty.path "&")
                        []
                        [
                          Ty.apply
                            (Ty.path "slice")
                            []
                            [ Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ]
                        ]
                    |)
                  |);
                  Value.mkStructRecord
                    "openvm_stark_backend::prover::types::_'1::deserialize::__Visitor"
                    []
                    [ PB ]
                    [
                      ("marker",
                        Value.StructTuple
                          "core::marker::PhantomData"
                          []
                          [
                            Ty.apply
                              (Ty.path "openvm_stark_backend::prover::types::HalProof")
                              []
                              [ PB ]
                          ]
                          []);
                      ("lifetime",
                        Value.StructTuple
                          "core::marker::PhantomData"
                          []
                          [ Ty.apply (Ty.path "&") [] [ Ty.tuple [] ] ]
                          [])
                    ]
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          forall (PB : Ty.t),
          M.IsTraitInstance
            "serde::de::Deserialize"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) []
            (Self PB)
            (* Instance *) [ ("deserialize", InstanceField.Method (deserialize PB)) ].
      End Impl_serde_de_Deserialize_where_openvm_stark_backend_prover_hal_ProverBackend_PB_for_openvm_stark_backend_prover_types_HalProof_PB.
      Module Impl_serde_ser_Serialize_where_openvm_stark_backend_config_StarkGenericConfig_SC_where_serde_ser_Serialize_associated_in_trait_p3_commit_pcs_Pcs__associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenge_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenger_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Pcs_ProverData_for_openvm_stark_backend_prover_types_CommittedTraceData_SC.
        Definition Self (SC : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "openvm_stark_backend::prover::types::CommittedTraceData") [] [ SC ].
        
        (* Serialize *)
        Definition serialize
            (SC : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self SC in
          match ε, τ, α with
          | [], [ __S ], [ self; __serializer ] =>
            ltac:(M.monadic
              (let self :=
                M.alloc (|
                  Ty.apply
                    (Ty.path "&")
                    []
                    [
                      Ty.apply
                        (Ty.path "openvm_stark_backend::prover::types::CommittedTraceData")
                        []
                        [ SC ]
                    ],
                  self
                |) in
              let __serializer := M.alloc (| __S, __serializer |) in
              M.catch_return
                (Ty.apply
                  (Ty.path "core::result::Result")
                  []
                  [
                    Ty.associated_in_trait "serde::ser::Serializer" [] [] __S "Ok";
                    Ty.associated_in_trait "serde::ser::Serializer" [] [] __S "Error"
                  ]) (|
                ltac:(M.monadic
                  (M.read (|
                    let~ __serde_state :
                        Ty.associated_in_trait
                          "serde::ser::Serializer"
                          []
                          []
                          __S
                          "SerializeStruct" :=
                      M.match_operator (|
                        Ty.associated_in_trait "serde::ser::Serializer" [] [] __S "SerializeStruct",
                        M.alloc (|
                          Ty.apply
                            (Ty.path "core::ops::control_flow::ControlFlow")
                            []
                            [
                              Ty.apply
                                (Ty.path "core::result::Result")
                                []
                                [
                                  Ty.path "core::convert::Infallible";
                                  Ty.associated_in_trait "serde::ser::Serializer" [] [] __S "Error"
                                ];
                              Ty.associated_in_trait
                                "serde::ser::Serializer"
                                []
                                []
                                __S
                                "SerializeStruct"
                            ],
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "core::ops::control_flow::ControlFlow")
                              []
                              [
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  []
                                  [
                                    Ty.path "core::convert::Infallible";
                                    Ty.associated_in_trait
                                      "serde::ser::Serializer"
                                      []
                                      []
                                      __S
                                      "Error"
                                  ];
                                Ty.associated_in_trait
                                  "serde::ser::Serializer"
                                  []
                                  []
                                  __S
                                  "SerializeStruct"
                              ],
                            M.get_trait_method (|
                              "core::ops::try_trait::Try",
                              Ty.apply
                                (Ty.path "core::result::Result")
                                []
                                [
                                  Ty.associated_in_trait
                                    "serde::ser::Serializer"
                                    []
                                    []
                                    __S
                                    "SerializeStruct";
                                  Ty.associated_in_trait "serde::ser::Serializer" [] [] __S "Error"
                                ],
                              [],
                              [],
                              "branch",
                              [],
                              []
                            |),
                            [
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  []
                                  [
                                    Ty.associated_in_trait
                                      "serde::ser::Serializer"
                                      []
                                      []
                                      __S
                                      "SerializeStruct";
                                    Ty.associated_in_trait
                                      "serde::ser::Serializer"
                                      []
                                      []
                                      __S
                                      "Error"
                                  ],
                                M.get_trait_method (|
                                  "serde::ser::Serializer",
                                  __S,
                                  [],
                                  [],
                                  "serialize_struct",
                                  [],
                                  []
                                |),
                                [
                                  M.read (| __serializer |);
                                  mk_str (| "CommittedTraceData" |);
                                  M.call_closure (|
                                    Ty.path "usize",
                                    BinOp.Wrap.add,
                                    [
                                      M.call_closure (|
                                        Ty.path "usize",
                                        BinOp.Wrap.add,
                                        [
                                          M.call_closure (|
                                            Ty.path "usize",
                                            BinOp.Wrap.add,
                                            [
                                              M.cast (Ty.path "usize") (Value.Bool false);
                                              Value.Integer IntegerKind.Usize 1
                                            ]
                                          |);
                                          Value.Integer IntegerKind.Usize 1
                                        ]
                                      |);
                                      Value.Integer IntegerKind.Usize 1
                                    ]
                                  |)
                                ]
                              |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Break",
                                  0
                                |) in
                              let residual :=
                                M.copy (|
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [
                                      Ty.path "core::convert::Infallible";
                                      Ty.associated_in_trait
                                        "serde::ser::Serializer"
                                        []
                                        []
                                        __S
                                        "Error"
                                    ],
                                  γ0_0
                                |) in
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        []
                                        [
                                          Ty.associated_in_trait
                                            "serde::ser::Serializer"
                                            []
                                            []
                                            __S
                                            "Ok";
                                          Ty.associated_in_trait
                                            "serde::ser::Serializer"
                                            []
                                            []
                                            __S
                                            "Error"
                                        ],
                                      M.get_trait_method (|
                                        "core::ops::try_trait::FromResidual",
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          []
                                          [
                                            Ty.associated_in_trait
                                              "serde::ser::Serializer"
                                              []
                                              []
                                              __S
                                              "Ok";
                                            Ty.associated_in_trait
                                              "serde::ser::Serializer"
                                              []
                                              []
                                              __S
                                              "Error"
                                          ],
                                        [],
                                        [
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            []
                                            [
                                              Ty.path "core::convert::Infallible";
                                              Ty.associated_in_trait
                                                "serde::ser::Serializer"
                                                []
                                                []
                                                __S
                                                "Error"
                                            ]
                                        ],
                                        "from_residual",
                                        [],
                                        []
                                      |),
                                      [ M.read (| residual |) ]
                                    |)
                                  |)
                                |)
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Continue",
                                  0
                                |) in
                              let val :=
                                M.copy (|
                                  Ty.associated_in_trait
                                    "serde::ser::Serializer"
                                    []
                                    []
                                    __S
                                    "SerializeStruct",
                                  γ0_0
                                |) in
                              M.read (| val |)))
                        ]
                      |) in
                    let~ _ : Ty.tuple [] :=
                      M.match_operator (|
                        Ty.tuple [],
                        M.alloc (|
                          Ty.apply
                            (Ty.path "core::ops::control_flow::ControlFlow")
                            []
                            [
                              Ty.apply
                                (Ty.path "core::result::Result")
                                []
                                [
                                  Ty.path "core::convert::Infallible";
                                  Ty.associated_in_trait "serde::ser::Serializer" [] [] __S "Error"
                                ];
                              Ty.tuple []
                            ],
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "core::ops::control_flow::ControlFlow")
                              []
                              [
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  []
                                  [
                                    Ty.path "core::convert::Infallible";
                                    Ty.associated_in_trait
                                      "serde::ser::Serializer"
                                      []
                                      []
                                      __S
                                      "Error"
                                  ];
                                Ty.tuple []
                              ],
                            M.get_trait_method (|
                              "core::ops::try_trait::Try",
                              Ty.apply
                                (Ty.path "core::result::Result")
                                []
                                [
                                  Ty.tuple [];
                                  Ty.associated_in_trait "serde::ser::Serializer" [] [] __S "Error"
                                ],
                              [],
                              [],
                              "branch",
                              [],
                              []
                            |),
                            [
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  []
                                  [
                                    Ty.tuple [];
                                    Ty.associated_in_trait
                                      "serde::ser::Serializer"
                                      []
                                      []
                                      __S
                                      "Error"
                                  ],
                                M.get_trait_method (|
                                  "serde::ser::SerializeStruct",
                                  Ty.associated_in_trait
                                    "serde::ser::Serializer"
                                    []
                                    []
                                    __S
                                    "SerializeStruct",
                                  [],
                                  [],
                                  "serialize_field",
                                  [],
                                  [
                                    Ty.apply
                                      (Ty.path "alloc::sync::Arc")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "p3_matrix::dense::DenseMatrix")
                                          []
                                          [
                                            Ty.associated_in_trait
                                              "p3_commit::domain::PolynomialSpace"
                                              []
                                              []
                                              (Ty.associated_in_trait
                                                "p3_commit::pcs::Pcs"
                                                []
                                                [
                                                  Ty.associated_in_trait
                                                    "openvm_stark_backend::config::StarkGenericConfig"
                                                    []
                                                    []
                                                    SC
                                                    "Challenge";
                                                  Ty.associated_in_trait
                                                    "openvm_stark_backend::config::StarkGenericConfig"
                                                    []
                                                    []
                                                    SC
                                                    "Challenger"
                                                ]
                                                (Ty.associated_in_trait
                                                  "openvm_stark_backend::config::StarkGenericConfig"
                                                  []
                                                  []
                                                  SC
                                                  "Pcs")
                                                "Domain")
                                              "Val";
                                            Ty.apply
                                              (Ty.path "alloc::vec::Vec")
                                              []
                                              [
                                                Ty.associated_in_trait
                                                  "p3_commit::domain::PolynomialSpace"
                                                  []
                                                  []
                                                  (Ty.associated_in_trait
                                                    "p3_commit::pcs::Pcs"
                                                    []
                                                    [
                                                      Ty.associated_in_trait
                                                        "openvm_stark_backend::config::StarkGenericConfig"
                                                        []
                                                        []
                                                        SC
                                                        "Challenge";
                                                      Ty.associated_in_trait
                                                        "openvm_stark_backend::config::StarkGenericConfig"
                                                        []
                                                        []
                                                        SC
                                                        "Challenger"
                                                    ]
                                                    (Ty.associated_in_trait
                                                      "openvm_stark_backend::config::StarkGenericConfig"
                                                      []
                                                      []
                                                      SC
                                                      "Pcs")
                                                    "Domain")
                                                  "Val";
                                                Ty.path "alloc::alloc::Global"
                                              ]
                                          ];
                                        Ty.path "alloc::alloc::Global"
                                      ]
                                  ]
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.MutRef,
                                    M.deref (| M.borrow (| Pointer.Kind.MutRef, __serde_state |) |)
                                  |);
                                  mk_str (| "trace" |);
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.SubPointer.get_struct_record_field (|
                                          M.deref (| M.read (| self |) |),
                                          "openvm_stark_backend::prover::types::CommittedTraceData",
                                          "trace"
                                        |)
                                      |)
                                    |)
                                  |)
                                ]
                              |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Break",
                                  0
                                |) in
                              let residual :=
                                M.copy (|
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [
                                      Ty.path "core::convert::Infallible";
                                      Ty.associated_in_trait
                                        "serde::ser::Serializer"
                                        []
                                        []
                                        __S
                                        "Error"
                                    ],
                                  γ0_0
                                |) in
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        []
                                        [
                                          Ty.associated_in_trait
                                            "serde::ser::Serializer"
                                            []
                                            []
                                            __S
                                            "Ok";
                                          Ty.associated_in_trait
                                            "serde::ser::Serializer"
                                            []
                                            []
                                            __S
                                            "Error"
                                        ],
                                      M.get_trait_method (|
                                        "core::ops::try_trait::FromResidual",
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          []
                                          [
                                            Ty.associated_in_trait
                                              "serde::ser::Serializer"
                                              []
                                              []
                                              __S
                                              "Ok";
                                            Ty.associated_in_trait
                                              "serde::ser::Serializer"
                                              []
                                              []
                                              __S
                                              "Error"
                                          ],
                                        [],
                                        [
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            []
                                            [
                                              Ty.path "core::convert::Infallible";
                                              Ty.associated_in_trait
                                                "serde::ser::Serializer"
                                                []
                                                []
                                                __S
                                                "Error"
                                            ]
                                        ],
                                        "from_residual",
                                        [],
                                        []
                                      |),
                                      [ M.read (| residual |) ]
                                    |)
                                  |)
                                |)
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Continue",
                                  0
                                |) in
                              let val := M.copy (| Ty.tuple [], γ0_0 |) in
                              M.read (| val |)))
                        ]
                      |) in
                    let~ _ : Ty.tuple [] :=
                      M.match_operator (|
                        Ty.tuple [],
                        M.alloc (|
                          Ty.apply
                            (Ty.path "core::ops::control_flow::ControlFlow")
                            []
                            [
                              Ty.apply
                                (Ty.path "core::result::Result")
                                []
                                [
                                  Ty.path "core::convert::Infallible";
                                  Ty.associated_in_trait "serde::ser::Serializer" [] [] __S "Error"
                                ];
                              Ty.tuple []
                            ],
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "core::ops::control_flow::ControlFlow")
                              []
                              [
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  []
                                  [
                                    Ty.path "core::convert::Infallible";
                                    Ty.associated_in_trait
                                      "serde::ser::Serializer"
                                      []
                                      []
                                      __S
                                      "Error"
                                  ];
                                Ty.tuple []
                              ],
                            M.get_trait_method (|
                              "core::ops::try_trait::Try",
                              Ty.apply
                                (Ty.path "core::result::Result")
                                []
                                [
                                  Ty.tuple [];
                                  Ty.associated_in_trait "serde::ser::Serializer" [] [] __S "Error"
                                ],
                              [],
                              [],
                              "branch",
                              [],
                              []
                            |),
                            [
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  []
                                  [
                                    Ty.tuple [];
                                    Ty.associated_in_trait
                                      "serde::ser::Serializer"
                                      []
                                      []
                                      __S
                                      "Error"
                                  ],
                                M.get_trait_method (|
                                  "serde::ser::SerializeStruct",
                                  Ty.associated_in_trait
                                    "serde::ser::Serializer"
                                    []
                                    []
                                    __S
                                    "SerializeStruct",
                                  [],
                                  [],
                                  "serialize_field",
                                  [],
                                  [
                                    Ty.associated_in_trait
                                      "p3_commit::pcs::Pcs"
                                      []
                                      [
                                        Ty.associated_in_trait
                                          "openvm_stark_backend::config::StarkGenericConfig"
                                          []
                                          []
                                          SC
                                          "Challenge";
                                        Ty.associated_in_trait
                                          "openvm_stark_backend::config::StarkGenericConfig"
                                          []
                                          []
                                          SC
                                          "Challenger"
                                      ]
                                      (Ty.associated_in_trait
                                        "openvm_stark_backend::config::StarkGenericConfig"
                                        []
                                        []
                                        SC
                                        "Pcs")
                                      "Commitment"
                                  ]
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.MutRef,
                                    M.deref (| M.borrow (| Pointer.Kind.MutRef, __serde_state |) |)
                                  |);
                                  mk_str (| "commitment" |);
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.SubPointer.get_struct_record_field (|
                                          M.deref (| M.read (| self |) |),
                                          "openvm_stark_backend::prover::types::CommittedTraceData",
                                          "commitment"
                                        |)
                                      |)
                                    |)
                                  |)
                                ]
                              |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Break",
                                  0
                                |) in
                              let residual :=
                                M.copy (|
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [
                                      Ty.path "core::convert::Infallible";
                                      Ty.associated_in_trait
                                        "serde::ser::Serializer"
                                        []
                                        []
                                        __S
                                        "Error"
                                    ],
                                  γ0_0
                                |) in
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        []
                                        [
                                          Ty.associated_in_trait
                                            "serde::ser::Serializer"
                                            []
                                            []
                                            __S
                                            "Ok";
                                          Ty.associated_in_trait
                                            "serde::ser::Serializer"
                                            []
                                            []
                                            __S
                                            "Error"
                                        ],
                                      M.get_trait_method (|
                                        "core::ops::try_trait::FromResidual",
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          []
                                          [
                                            Ty.associated_in_trait
                                              "serde::ser::Serializer"
                                              []
                                              []
                                              __S
                                              "Ok";
                                            Ty.associated_in_trait
                                              "serde::ser::Serializer"
                                              []
                                              []
                                              __S
                                              "Error"
                                          ],
                                        [],
                                        [
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            []
                                            [
                                              Ty.path "core::convert::Infallible";
                                              Ty.associated_in_trait
                                                "serde::ser::Serializer"
                                                []
                                                []
                                                __S
                                                "Error"
                                            ]
                                        ],
                                        "from_residual",
                                        [],
                                        []
                                      |),
                                      [ M.read (| residual |) ]
                                    |)
                                  |)
                                |)
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Continue",
                                  0
                                |) in
                              let val := M.copy (| Ty.tuple [], γ0_0 |) in
                              M.read (| val |)))
                        ]
                      |) in
                    let~ _ : Ty.tuple [] :=
                      M.match_operator (|
                        Ty.tuple [],
                        M.alloc (|
                          Ty.apply
                            (Ty.path "core::ops::control_flow::ControlFlow")
                            []
                            [
                              Ty.apply
                                (Ty.path "core::result::Result")
                                []
                                [
                                  Ty.path "core::convert::Infallible";
                                  Ty.associated_in_trait "serde::ser::Serializer" [] [] __S "Error"
                                ];
                              Ty.tuple []
                            ],
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "core::ops::control_flow::ControlFlow")
                              []
                              [
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  []
                                  [
                                    Ty.path "core::convert::Infallible";
                                    Ty.associated_in_trait
                                      "serde::ser::Serializer"
                                      []
                                      []
                                      __S
                                      "Error"
                                  ];
                                Ty.tuple []
                              ],
                            M.get_trait_method (|
                              "core::ops::try_trait::Try",
                              Ty.apply
                                (Ty.path "core::result::Result")
                                []
                                [
                                  Ty.tuple [];
                                  Ty.associated_in_trait "serde::ser::Serializer" [] [] __S "Error"
                                ],
                              [],
                              [],
                              "branch",
                              [],
                              []
                            |),
                            [
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  []
                                  [
                                    Ty.tuple [];
                                    Ty.associated_in_trait
                                      "serde::ser::Serializer"
                                      []
                                      []
                                      __S
                                      "Error"
                                  ],
                                M.get_trait_method (|
                                  "serde::ser::SerializeStruct",
                                  Ty.associated_in_trait
                                    "serde::ser::Serializer"
                                    []
                                    []
                                    __S
                                    "SerializeStruct",
                                  [],
                                  [],
                                  "serialize_field",
                                  [],
                                  [
                                    Ty.apply
                                      (Ty.path "alloc::sync::Arc")
                                      []
                                      [
                                        Ty.associated_in_trait
                                          "p3_commit::pcs::Pcs"
                                          []
                                          [
                                            Ty.associated_in_trait
                                              "openvm_stark_backend::config::StarkGenericConfig"
                                              []
                                              []
                                              SC
                                              "Challenge";
                                            Ty.associated_in_trait
                                              "openvm_stark_backend::config::StarkGenericConfig"
                                              []
                                              []
                                              SC
                                              "Challenger"
                                          ]
                                          (Ty.associated_in_trait
                                            "openvm_stark_backend::config::StarkGenericConfig"
                                            []
                                            []
                                            SC
                                            "Pcs")
                                          "ProverData";
                                        Ty.path "alloc::alloc::Global"
                                      ]
                                  ]
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.MutRef,
                                    M.deref (| M.borrow (| Pointer.Kind.MutRef, __serde_state |) |)
                                  |);
                                  mk_str (| "pcs_data" |);
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.SubPointer.get_struct_record_field (|
                                          M.deref (| M.read (| self |) |),
                                          "openvm_stark_backend::prover::types::CommittedTraceData",
                                          "pcs_data"
                                        |)
                                      |)
                                    |)
                                  |)
                                ]
                              |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Break",
                                  0
                                |) in
                              let residual :=
                                M.copy (|
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [
                                      Ty.path "core::convert::Infallible";
                                      Ty.associated_in_trait
                                        "serde::ser::Serializer"
                                        []
                                        []
                                        __S
                                        "Error"
                                    ],
                                  γ0_0
                                |) in
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        []
                                        [
                                          Ty.associated_in_trait
                                            "serde::ser::Serializer"
                                            []
                                            []
                                            __S
                                            "Ok";
                                          Ty.associated_in_trait
                                            "serde::ser::Serializer"
                                            []
                                            []
                                            __S
                                            "Error"
                                        ],
                                      M.get_trait_method (|
                                        "core::ops::try_trait::FromResidual",
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          []
                                          [
                                            Ty.associated_in_trait
                                              "serde::ser::Serializer"
                                              []
                                              []
                                              __S
                                              "Ok";
                                            Ty.associated_in_trait
                                              "serde::ser::Serializer"
                                              []
                                              []
                                              __S
                                              "Error"
                                          ],
                                        [],
                                        [
                                          Ty.apply
                                            (Ty.path "core::result::Result")
                                            []
                                            [
                                              Ty.path "core::convert::Infallible";
                                              Ty.associated_in_trait
                                                "serde::ser::Serializer"
                                                []
                                                []
                                                __S
                                                "Error"
                                            ]
                                        ],
                                        "from_residual",
                                        [],
                                        []
                                      |),
                                      [ M.read (| residual |) ]
                                    |)
                                  |)
                                |)
                              |)));
                          fun γ =>
                            ltac:(M.monadic
                              (let γ0_0 :=
                                M.SubPointer.get_struct_tuple_field (|
                                  γ,
                                  "core::ops::control_flow::ControlFlow::Continue",
                                  0
                                |) in
                              let val := M.copy (| Ty.tuple [], γ0_0 |) in
                              M.read (| val |)))
                        ]
                      |) in
                    M.alloc (|
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [
                          Ty.associated_in_trait "serde::ser::Serializer" [] [] __S "Ok";
                          Ty.associated_in_trait "serde::ser::Serializer" [] [] __S "Error"
                        ],
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [
                            Ty.associated_in_trait "serde::ser::Serializer" [] [] __S "Ok";
                            Ty.associated_in_trait "serde::ser::Serializer" [] [] __S "Error"
                          ],
                        M.get_trait_method (|
                          "serde::ser::SerializeStruct",
                          Ty.associated_in_trait
                            "serde::ser::Serializer"
                            []
                            []
                            __S
                            "SerializeStruct",
                          [],
                          [],
                          "end",
                          [],
                          []
                        |),
                        [ M.read (| __serde_state |) ]
                      |)
                    |)
                  |)))
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          forall (SC : Ty.t),
          M.IsTraitInstance
            "serde::ser::Serialize"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) []
            (Self SC)
            (* Instance *) [ ("serialize", InstanceField.Method (serialize SC)) ].
      End Impl_serde_ser_Serialize_where_openvm_stark_backend_config_StarkGenericConfig_SC_where_serde_ser_Serialize_associated_in_trait_p3_commit_pcs_Pcs__associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenge_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenger_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Pcs_ProverData_for_openvm_stark_backend_prover_types_CommittedTraceData_SC.
      Module Impl_serde_de_Deserialize_where_openvm_stark_backend_config_StarkGenericConfig_SC_where_serde_de_Deserialize_associated_in_trait_p3_commit_pcs_Pcs__associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenge_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenger_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Pcs_ProverData_for_openvm_stark_backend_prover_types_CommittedTraceData_SC.
        Definition Self (SC : Ty.t) : Ty.t :=
          Ty.apply (Ty.path "openvm_stark_backend::prover::types::CommittedTraceData") [] [ SC ].
        
        (* Deserialize *)
        Definition deserialize
            (SC : Ty.t)
            (ε : list Value.t)
            (τ : list Ty.t)
            (α : list Value.t)
            : M :=
          let Self : Ty.t := Self SC in
          match ε, τ, α with
          | [], [ __D ], [ __deserializer ] =>
            ltac:(M.monadic
              (let __deserializer := M.alloc (| __D, __deserializer |) in
              M.call_closure (|
                Ty.apply
                  (Ty.path "core::result::Result")
                  []
                  [
                    Ty.apply
                      (Ty.path "openvm_stark_backend::prover::types::CommittedTraceData")
                      []
                      [ SC ];
                    Ty.associated_in_trait "serde::de::Deserializer" [] [] __D "Error"
                  ],
                M.get_trait_method (|
                  "serde::de::Deserializer",
                  __D,
                  [],
                  [],
                  "deserialize_struct",
                  [],
                  [
                    Ty.apply
                      (Ty.path "openvm_stark_backend::prover::types::_'3::deserialize::__Visitor")
                      []
                      [ SC ]
                  ]
                |),
                [
                  M.read (| __deserializer |);
                  mk_str (| "CommittedTraceData" |);
                  M.read (|
                    get_constant (|
                      "openvm_stark_backend::prover::types::_'3::deserialize::FIELDS",
                      Ty.apply
                        (Ty.path "&")
                        []
                        [
                          Ty.apply
                            (Ty.path "slice")
                            []
                            [ Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ]
                        ]
                    |)
                  |);
                  Value.mkStructRecord
                    "openvm_stark_backend::prover::types::_'3::deserialize::__Visitor"
                    []
                    [ SC ]
                    [
                      ("marker",
                        Value.StructTuple
                          "core::marker::PhantomData"
                          []
                          [
                            Ty.apply
                              (Ty.path "openvm_stark_backend::prover::types::CommittedTraceData")
                              []
                              [ SC ]
                          ]
                          []);
                      ("lifetime",
                        Value.StructTuple
                          "core::marker::PhantomData"
                          []
                          [ Ty.apply (Ty.path "&") [] [ Ty.tuple [] ] ]
                          [])
                    ]
                ]
              |)))
          | _, _, _ => M.impossible "wrong number of arguments"
          end.
        
        Axiom Implements :
          forall (SC : Ty.t),
          M.IsTraitInstance
            "serde::de::Deserialize"
            (* Trait polymorphic consts *) []
            (* Trait polymorphic types *) []
            (Self SC)
            (* Instance *) [ ("deserialize", InstanceField.Method (deserialize SC)) ].
      End Impl_serde_de_Deserialize_where_openvm_stark_backend_config_StarkGenericConfig_SC_where_serde_de_Deserialize_associated_in_trait_p3_commit_pcs_Pcs__associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenge_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenger_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Pcs_ProverData_for_openvm_stark_backend_prover_types_CommittedTraceData_SC.
    End underscore.
    
    
    Module Impl_core_clone_Clone_where_openvm_stark_backend_prover_hal_ProverBackend_PB_for_openvm_stark_backend_prover_types_HalProof_PB.
      Definition Self (PB : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "openvm_stark_backend::prover::types::HalProof") [] [ PB ].
      
      (* Derivative *)
      Definition clone (PB : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self PB in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.apply (Ty.path "openvm_stark_backend::prover::types::HalProof") [] [ PB ] ],
                self
              |) in
            M.match_operator (|
              Ty.apply (Ty.path "openvm_stark_backend::prover::types::HalProof") [] [ PB ],
              M.deref (| M.read (| self |) |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "openvm_stark_backend::prover::types::HalProof",
                        "commitments"
                      |) in
                    let γ0_1 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "openvm_stark_backend::prover::types::HalProof",
                        "opening"
                      |) in
                    let γ0_2 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "openvm_stark_backend::prover::types::HalProof",
                        "per_air"
                      |) in
                    let γ0_3 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "openvm_stark_backend::prover::types::HalProof",
                        "rap_partial_proof"
                      |) in
                    let __arg_0 :=
                      M.alloc (|
                        Ty.apply
                          (Ty.path "&")
                          []
                          [
                            Ty.apply
                              (Ty.path "openvm_stark_backend::proof::Commitments")
                              []
                              [
                                Ty.associated_in_trait
                                  "openvm_stark_backend::prover::hal::ProverBackend"
                                  []
                                  []
                                  PB
                                  "Commitment"
                              ]
                          ],
                        γ0_0
                      |) in
                    let __arg_1 :=
                      M.alloc (|
                        Ty.apply
                          (Ty.path "&")
                          []
                          [
                            Ty.associated_in_trait
                              "openvm_stark_backend::prover::hal::ProverBackend"
                              []
                              []
                              PB
                              "OpeningProof"
                          ],
                        γ0_1
                      |) in
                    let __arg_2 :=
                      M.alloc (|
                        Ty.apply
                          (Ty.path "&")
                          []
                          [
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              []
                              [
                                Ty.apply
                                  (Ty.path "openvm_stark_backend::proof::AirProofData")
                                  []
                                  [
                                    Ty.associated_in_trait
                                      "openvm_stark_backend::prover::hal::ProverBackend"
                                      []
                                      []
                                      PB
                                      "Val";
                                    Ty.associated_in_trait
                                      "openvm_stark_backend::prover::hal::ProverBackend"
                                      []
                                      []
                                      PB
                                      "Challenge"
                                  ];
                                Ty.path "alloc::alloc::Global"
                              ]
                          ],
                        γ0_2
                      |) in
                    let __arg_3 :=
                      M.alloc (|
                        Ty.apply
                          (Ty.path "&")
                          []
                          [
                            Ty.associated_in_trait
                              "openvm_stark_backend::prover::hal::ProverBackend"
                              []
                              []
                              PB
                              "RapPartialProof"
                          ],
                        γ0_3
                      |) in
                    Value.mkStructRecord
                      "openvm_stark_backend::prover::types::HalProof"
                      []
                      [ PB ]
                      [
                        ("commitments",
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "openvm_stark_backend::proof::Commitments")
                              []
                              [
                                Ty.associated_in_trait
                                  "openvm_stark_backend::prover::hal::ProverBackend"
                                  []
                                  []
                                  PB
                                  "Commitment"
                              ],
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.apply
                                (Ty.path "openvm_stark_backend::proof::Commitments")
                                []
                                [
                                  Ty.associated_in_trait
                                    "openvm_stark_backend::prover::hal::ProverBackend"
                                    []
                                    []
                                    PB
                                    "Commitment"
                                ],
                              [],
                              [],
                              "clone",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __arg_0 |) |) |) ]
                          |));
                        ("opening",
                          M.call_closure (|
                            Ty.associated_in_trait
                              "openvm_stark_backend::prover::hal::ProverBackend"
                              []
                              []
                              PB
                              "OpeningProof",
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.associated_in_trait
                                "openvm_stark_backend::prover::hal::ProverBackend"
                                []
                                []
                                PB
                                "OpeningProof",
                              [],
                              [],
                              "clone",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __arg_1 |) |) |) ]
                          |));
                        ("per_air",
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              []
                              [
                                Ty.apply
                                  (Ty.path "openvm_stark_backend::proof::AirProofData")
                                  []
                                  [
                                    Ty.associated_in_trait
                                      "openvm_stark_backend::prover::hal::ProverBackend"
                                      []
                                      []
                                      PB
                                      "Val";
                                    Ty.associated_in_trait
                                      "openvm_stark_backend::prover::hal::ProverBackend"
                                      []
                                      []
                                      PB
                                      "Challenge"
                                  ];
                                Ty.path "alloc::alloc::Global"
                              ],
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "openvm_stark_backend::proof::AirProofData")
                                    []
                                    [
                                      Ty.associated_in_trait
                                        "openvm_stark_backend::prover::hal::ProverBackend"
                                        []
                                        []
                                        PB
                                        "Val";
                                      Ty.associated_in_trait
                                        "openvm_stark_backend::prover::hal::ProverBackend"
                                        []
                                        []
                                        PB
                                        "Challenge"
                                    ];
                                  Ty.path "alloc::alloc::Global"
                                ],
                              [],
                              [],
                              "clone",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __arg_2 |) |) |) ]
                          |));
                        ("rap_partial_proof",
                          M.call_closure (|
                            Ty.associated_in_trait
                              "openvm_stark_backend::prover::hal::ProverBackend"
                              []
                              []
                              PB
                              "RapPartialProof",
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.associated_in_trait
                                "openvm_stark_backend::prover::hal::ProverBackend"
                                []
                                []
                                PB
                                "RapPartialProof",
                              [],
                              [],
                              "clone",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __arg_3 |) |) |) ]
                          |))
                      ]))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (PB : Ty.t),
        M.IsTraitInstance
          "core::clone::Clone"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self PB)
          (* Instance *) [ ("clone", InstanceField.Method (clone PB)) ].
    End Impl_core_clone_Clone_where_openvm_stark_backend_prover_hal_ProverBackend_PB_for_openvm_stark_backend_prover_types_HalProof_PB.
    
    Module Impl_core_convert_From_where_openvm_stark_backend_config_StarkGenericConfig_SC_where_openvm_stark_backend_prover_hal_ProverBackend_PB_where_core_convert_Into_associated_in_trait_openvm_stark_backend_prover_hal_ProverBackend___PB_OpeningProof_openvm_stark_backend_proof_OpeningProof_associated_in_trait_p3_commit_pcs_Pcs__associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenge_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenger_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Pcs_Proof_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenge_where_core_convert_Into_associated_in_trait_openvm_stark_backend_prover_hal_ProverBackend___PB_RapPartialProof_core_option_Option_associated_in_trait_openvm_stark_backend_interaction_RapPhaseSeq__associated_in_trait_p3_commit_domain_PolynomialSpace___associated_in_trait_p3_commit_pcs_Pcs__associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenge_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenger_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Pcs_Domain_Val_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenge_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenger_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_RapPhaseSeq_PartialProof_openvm_stark_backend_prover_types_HalProof_PB_for_openvm_stark_backend_proof_Proof_SC.
      Definition Self (PB SC : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "openvm_stark_backend::proof::Proof") [] [ SC ].
      
      (*
          fn from(proof: HalProof<PB>) -> Self {
              Proof {
                  commitments: proof.commitments,
                  opening: proof.opening.into(),
                  per_air: proof.per_air,
                  rap_phase_seq_proof: proof.rap_partial_proof.into(),
              }
          }
      *)
      Definition from (PB SC : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self PB SC in
        match ε, τ, α with
        | [], [], [ proof ] =>
          ltac:(M.monadic
            (let proof :=
              M.alloc (|
                Ty.apply (Ty.path "openvm_stark_backend::prover::types::HalProof") [] [ PB ],
                proof
              |) in
            Value.mkStructRecord
              "openvm_stark_backend::proof::Proof"
              []
              [ SC ]
              [
                ("commitments",
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      proof,
                      "openvm_stark_backend::prover::types::HalProof",
                      "commitments"
                    |)
                  |));
                ("opening",
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "openvm_stark_backend::proof::OpeningProof")
                      []
                      [
                        Ty.associated_in_trait
                          "p3_commit::pcs::Pcs"
                          []
                          [
                            Ty.associated_in_trait
                              "openvm_stark_backend::config::StarkGenericConfig"
                              []
                              []
                              SC
                              "Challenge";
                            Ty.associated_in_trait
                              "openvm_stark_backend::config::StarkGenericConfig"
                              []
                              []
                              SC
                              "Challenger"
                          ]
                          (Ty.associated_in_trait
                            "openvm_stark_backend::config::StarkGenericConfig"
                            []
                            []
                            SC
                            "Pcs")
                          "Proof";
                        Ty.associated_in_trait
                          "openvm_stark_backend::config::StarkGenericConfig"
                          []
                          []
                          SC
                          "Challenge"
                      ],
                    M.get_trait_method (|
                      "core::convert::Into",
                      Ty.associated_in_trait
                        "openvm_stark_backend::prover::hal::ProverBackend"
                        []
                        []
                        PB
                        "OpeningProof",
                      [],
                      [
                        Ty.apply
                          (Ty.path "openvm_stark_backend::proof::OpeningProof")
                          []
                          [
                            Ty.associated_in_trait
                              "p3_commit::pcs::Pcs"
                              []
                              [
                                Ty.associated_in_trait
                                  "openvm_stark_backend::config::StarkGenericConfig"
                                  []
                                  []
                                  SC
                                  "Challenge";
                                Ty.associated_in_trait
                                  "openvm_stark_backend::config::StarkGenericConfig"
                                  []
                                  []
                                  SC
                                  "Challenger"
                              ]
                              (Ty.associated_in_trait
                                "openvm_stark_backend::config::StarkGenericConfig"
                                []
                                []
                                SC
                                "Pcs")
                              "Proof";
                            Ty.associated_in_trait
                              "openvm_stark_backend::config::StarkGenericConfig"
                              []
                              []
                              SC
                              "Challenge"
                          ]
                      ],
                      "into",
                      [],
                      []
                    |),
                    [
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          proof,
                          "openvm_stark_backend::prover::types::HalProof",
                          "opening"
                        |)
                      |)
                    ]
                  |));
                ("per_air",
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      proof,
                      "openvm_stark_backend::prover::types::HalProof",
                      "per_air"
                    |)
                  |));
                ("rap_phase_seq_proof",
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::option::Option")
                      []
                      [
                        Ty.associated_in_trait
                          "openvm_stark_backend::interaction::RapPhaseSeq"
                          []
                          [
                            Ty.associated_in_trait
                              "p3_commit::domain::PolynomialSpace"
                              []
                              []
                              (Ty.associated_in_trait
                                "p3_commit::pcs::Pcs"
                                []
                                [
                                  Ty.associated_in_trait
                                    "openvm_stark_backend::config::StarkGenericConfig"
                                    []
                                    []
                                    SC
                                    "Challenge";
                                  Ty.associated_in_trait
                                    "openvm_stark_backend::config::StarkGenericConfig"
                                    []
                                    []
                                    SC
                                    "Challenger"
                                ]
                                (Ty.associated_in_trait
                                  "openvm_stark_backend::config::StarkGenericConfig"
                                  []
                                  []
                                  SC
                                  "Pcs")
                                "Domain")
                              "Val";
                            Ty.associated_in_trait
                              "openvm_stark_backend::config::StarkGenericConfig"
                              []
                              []
                              SC
                              "Challenge";
                            Ty.associated_in_trait
                              "openvm_stark_backend::config::StarkGenericConfig"
                              []
                              []
                              SC
                              "Challenger"
                          ]
                          (Ty.associated_in_trait
                            "openvm_stark_backend::config::StarkGenericConfig"
                            []
                            []
                            SC
                            "RapPhaseSeq")
                          "PartialProof"
                      ],
                    M.get_trait_method (|
                      "core::convert::Into",
                      Ty.associated_in_trait
                        "openvm_stark_backend::prover::hal::ProverBackend"
                        []
                        []
                        PB
                        "RapPartialProof",
                      [],
                      [
                        Ty.apply
                          (Ty.path "core::option::Option")
                          []
                          [
                            Ty.associated_in_trait
                              "openvm_stark_backend::interaction::RapPhaseSeq"
                              []
                              [
                                Ty.associated_in_trait
                                  "p3_commit::domain::PolynomialSpace"
                                  []
                                  []
                                  (Ty.associated_in_trait
                                    "p3_commit::pcs::Pcs"
                                    []
                                    [
                                      Ty.associated_in_trait
                                        "openvm_stark_backend::config::StarkGenericConfig"
                                        []
                                        []
                                        SC
                                        "Challenge";
                                      Ty.associated_in_trait
                                        "openvm_stark_backend::config::StarkGenericConfig"
                                        []
                                        []
                                        SC
                                        "Challenger"
                                    ]
                                    (Ty.associated_in_trait
                                      "openvm_stark_backend::config::StarkGenericConfig"
                                      []
                                      []
                                      SC
                                      "Pcs")
                                    "Domain")
                                  "Val";
                                Ty.associated_in_trait
                                  "openvm_stark_backend::config::StarkGenericConfig"
                                  []
                                  []
                                  SC
                                  "Challenge";
                                Ty.associated_in_trait
                                  "openvm_stark_backend::config::StarkGenericConfig"
                                  []
                                  []
                                  SC
                                  "Challenger"
                              ]
                              (Ty.associated_in_trait
                                "openvm_stark_backend::config::StarkGenericConfig"
                                []
                                []
                                SC
                                "RapPhaseSeq")
                              "PartialProof"
                          ]
                      ],
                      "into",
                      [],
                      []
                    |),
                    [
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          proof,
                          "openvm_stark_backend::prover::types::HalProof",
                          "rap_partial_proof"
                        |)
                      |)
                    ]
                  |))
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (PB SC : Ty.t),
        M.IsTraitInstance
          "core::convert::From"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *)
          [ Ty.apply (Ty.path "openvm_stark_backend::prover::types::HalProof") [] [ PB ] ]
          (Self PB SC)
          (* Instance *) [ ("from", InstanceField.Method (from PB SC)) ].
    End Impl_core_convert_From_where_openvm_stark_backend_config_StarkGenericConfig_SC_where_openvm_stark_backend_prover_hal_ProverBackend_PB_where_core_convert_Into_associated_in_trait_openvm_stark_backend_prover_hal_ProverBackend___PB_OpeningProof_openvm_stark_backend_proof_OpeningProof_associated_in_trait_p3_commit_pcs_Pcs__associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenge_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenger_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Pcs_Proof_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenge_where_core_convert_Into_associated_in_trait_openvm_stark_backend_prover_hal_ProverBackend___PB_RapPartialProof_core_option_Option_associated_in_trait_openvm_stark_backend_interaction_RapPhaseSeq__associated_in_trait_p3_commit_domain_PolynomialSpace___associated_in_trait_p3_commit_pcs_Pcs__associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenge_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenger_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Pcs_Domain_Val_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenge_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenger_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_RapPhaseSeq_PartialProof_openvm_stark_backend_prover_types_HalProof_PB_for_openvm_stark_backend_proof_Proof_SC.
    
    (* StructRecord
      {
        name := "ProofInput";
        const_params := [];
        ty_params := [ "SC" ];
        fields :=
          [
            ("per_air",
              Ty.apply
                (Ty.path "alloc::vec::Vec")
                []
                [
                  Ty.tuple
                    [
                      Ty.path "usize";
                      Ty.apply
                        (Ty.path "openvm_stark_backend::prover::types::AirProofInput")
                        []
                        [ SC ]
                    ];
                  Ty.path "alloc::alloc::Global"
                ])
          ];
      } *)
    
    Module Impl_core_clone_Clone_where_openvm_stark_backend_config_StarkGenericConfig_SC_where_core_clone_Clone_associated_in_trait_p3_commit_pcs_Pcs__associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenge_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenger_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Pcs_Commitment_for_openvm_stark_backend_prover_types_ProofInput_SC.
      Definition Self (SC : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "openvm_stark_backend::prover::types::ProofInput") [] [ SC ].
      
      (* Derivative *)
      Definition clone (SC : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self SC in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.apply (Ty.path "openvm_stark_backend::prover::types::ProofInput") [] [ SC ]
                  ],
                self
              |) in
            M.match_operator (|
              Ty.apply (Ty.path "openvm_stark_backend::prover::types::ProofInput") [] [ SC ],
              M.deref (| M.read (| self |) |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "openvm_stark_backend::prover::types::ProofInput",
                        "per_air"
                      |) in
                    let __arg_0 :=
                      M.alloc (|
                        Ty.apply
                          (Ty.path "&")
                          []
                          [
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              []
                              [
                                Ty.tuple
                                  [
                                    Ty.path "usize";
                                    Ty.apply
                                      (Ty.path "openvm_stark_backend::prover::types::AirProofInput")
                                      []
                                      [ SC ]
                                  ];
                                Ty.path "alloc::alloc::Global"
                              ]
                          ],
                        γ0_0
                      |) in
                    Value.mkStructRecord
                      "openvm_stark_backend::prover::types::ProofInput"
                      []
                      [ SC ]
                      [
                        ("per_air",
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              []
                              [
                                Ty.tuple
                                  [
                                    Ty.path "usize";
                                    Ty.apply
                                      (Ty.path "openvm_stark_backend::prover::types::AirProofInput")
                                      []
                                      [ SC ]
                                  ];
                                Ty.path "alloc::alloc::Global"
                              ],
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                []
                                [
                                  Ty.tuple
                                    [
                                      Ty.path "usize";
                                      Ty.apply
                                        (Ty.path
                                          "openvm_stark_backend::prover::types::AirProofInput")
                                        []
                                        [ SC ]
                                    ];
                                  Ty.path "alloc::alloc::Global"
                                ],
                              [],
                              [],
                              "clone",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __arg_0 |) |) |) ]
                          |))
                      ]))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (SC : Ty.t),
        M.IsTraitInstance
          "core::clone::Clone"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self SC)
          (* Instance *) [ ("clone", InstanceField.Method (clone SC)) ].
    End Impl_core_clone_Clone_where_openvm_stark_backend_config_StarkGenericConfig_SC_where_core_clone_Clone_associated_in_trait_p3_commit_pcs_Pcs__associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenge_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenger_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Pcs_Commitment_for_openvm_stark_backend_prover_types_ProofInput_SC.
    
    Module Impl_openvm_stark_backend_prover_types_ProofInput_SC.
      Definition Self (SC : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "openvm_stark_backend::prover::types::ProofInput") [] [ SC ].
      
      (* derive_new::new *)
      Definition new (SC : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self SC in
        match ε, τ, α with
        | [], [], [ per_air ] =>
          ltac:(M.monadic
            (let per_air :=
              M.alloc (|
                Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  []
                  [
                    Ty.tuple
                      [
                        Ty.path "usize";
                        Ty.apply
                          (Ty.path "openvm_stark_backend::prover::types::AirProofInput")
                          []
                          [ SC ]
                      ];
                    Ty.path "alloc::alloc::Global"
                  ],
                per_air
              |) in
            Value.mkStructRecord
              "openvm_stark_backend::prover::types::ProofInput"
              []
              [ SC ]
              [ ("per_air", M.read (| per_air |)) ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_new :
        forall (SC : Ty.t),
        M.IsAssociatedFunction.C (Self SC) "new" (new SC).
      Admitted.
      Global Typeclasses Opaque new.
    End Impl_openvm_stark_backend_prover_types_ProofInput_SC.
    
    (* StructRecord
      {
        name := "CommittedTraceData";
        const_params := [];
        ty_params := [ "SC" ];
        fields :=
          [
            ("trace",
              Ty.apply
                (Ty.path "alloc::sync::Arc")
                []
                [
                  Ty.apply
                    (Ty.path "p3_matrix::dense::DenseMatrix")
                    []
                    [
                      Ty.associated_in_trait
                        "p3_commit::domain::PolynomialSpace"
                        []
                        []
                        (Ty.associated_in_trait
                          "p3_commit::pcs::Pcs"
                          []
                          [
                            Ty.associated_in_trait
                              "openvm_stark_backend::config::StarkGenericConfig"
                              []
                              []
                              SC
                              "Challenge";
                            Ty.associated_in_trait
                              "openvm_stark_backend::config::StarkGenericConfig"
                              []
                              []
                              SC
                              "Challenger"
                          ]
                          (Ty.associated_in_trait
                            "openvm_stark_backend::config::StarkGenericConfig"
                            []
                            []
                            SC
                            "Pcs")
                          "Domain")
                        "Val";
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        []
                        [
                          Ty.associated_in_trait
                            "p3_commit::domain::PolynomialSpace"
                            []
                            []
                            (Ty.associated_in_trait
                              "p3_commit::pcs::Pcs"
                              []
                              [
                                Ty.associated_in_trait
                                  "openvm_stark_backend::config::StarkGenericConfig"
                                  []
                                  []
                                  SC
                                  "Challenge";
                                Ty.associated_in_trait
                                  "openvm_stark_backend::config::StarkGenericConfig"
                                  []
                                  []
                                  SC
                                  "Challenger"
                              ]
                              (Ty.associated_in_trait
                                "openvm_stark_backend::config::StarkGenericConfig"
                                []
                                []
                                SC
                                "Pcs")
                              "Domain")
                            "Val";
                          Ty.path "alloc::alloc::Global"
                        ]
                    ];
                  Ty.path "alloc::alloc::Global"
                ]);
            ("commitment",
              Ty.associated_in_trait
                "p3_commit::pcs::Pcs"
                []
                [
                  Ty.associated_in_trait
                    "openvm_stark_backend::config::StarkGenericConfig"
                    []
                    []
                    SC
                    "Challenge";
                  Ty.associated_in_trait
                    "openvm_stark_backend::config::StarkGenericConfig"
                    []
                    []
                    SC
                    "Challenger"
                ]
                (Ty.associated_in_trait
                  "openvm_stark_backend::config::StarkGenericConfig"
                  []
                  []
                  SC
                  "Pcs")
                "Commitment");
            ("pcs_data",
              Ty.apply
                (Ty.path "alloc::sync::Arc")
                []
                [
                  Ty.associated_in_trait
                    "p3_commit::pcs::Pcs"
                    []
                    [
                      Ty.associated_in_trait
                        "openvm_stark_backend::config::StarkGenericConfig"
                        []
                        []
                        SC
                        "Challenge";
                      Ty.associated_in_trait
                        "openvm_stark_backend::config::StarkGenericConfig"
                        []
                        []
                        SC
                        "Challenger"
                    ]
                    (Ty.associated_in_trait
                      "openvm_stark_backend::config::StarkGenericConfig"
                      []
                      []
                      SC
                      "Pcs")
                    "ProverData";
                  Ty.path "alloc::alloc::Global"
                ])
          ];
      } *)
    
    
    
    Module Impl_core_clone_Clone_where_openvm_stark_backend_config_StarkGenericConfig_SC_where_core_clone_Clone_associated_in_trait_p3_commit_pcs_Pcs__associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenge_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenger_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Pcs_Commitment_for_openvm_stark_backend_prover_types_CommittedTraceData_SC.
      Definition Self (SC : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "openvm_stark_backend::prover::types::CommittedTraceData") [] [ SC ].
      
      (* Derivative *)
      Definition clone (SC : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self SC in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path "openvm_stark_backend::prover::types::CommittedTraceData")
                      []
                      [ SC ]
                  ],
                self
              |) in
            M.match_operator (|
              Ty.apply
                (Ty.path "openvm_stark_backend::prover::types::CommittedTraceData")
                []
                [ SC ],
              M.deref (| M.read (| self |) |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "openvm_stark_backend::prover::types::CommittedTraceData",
                        "trace"
                      |) in
                    let γ0_1 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "openvm_stark_backend::prover::types::CommittedTraceData",
                        "commitment"
                      |) in
                    let γ0_2 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "openvm_stark_backend::prover::types::CommittedTraceData",
                        "pcs_data"
                      |) in
                    let __arg_0 :=
                      M.alloc (|
                        Ty.apply
                          (Ty.path "&")
                          []
                          [
                            Ty.apply
                              (Ty.path "alloc::sync::Arc")
                              []
                              [
                                Ty.apply
                                  (Ty.path "p3_matrix::dense::DenseMatrix")
                                  []
                                  [
                                    Ty.associated_in_trait
                                      "p3_commit::domain::PolynomialSpace"
                                      []
                                      []
                                      (Ty.associated_in_trait
                                        "p3_commit::pcs::Pcs"
                                        []
                                        [
                                          Ty.associated_in_trait
                                            "openvm_stark_backend::config::StarkGenericConfig"
                                            []
                                            []
                                            SC
                                            "Challenge";
                                          Ty.associated_in_trait
                                            "openvm_stark_backend::config::StarkGenericConfig"
                                            []
                                            []
                                            SC
                                            "Challenger"
                                        ]
                                        (Ty.associated_in_trait
                                          "openvm_stark_backend::config::StarkGenericConfig"
                                          []
                                          []
                                          SC
                                          "Pcs")
                                        "Domain")
                                      "Val";
                                    Ty.apply
                                      (Ty.path "alloc::vec::Vec")
                                      []
                                      [
                                        Ty.associated_in_trait
                                          "p3_commit::domain::PolynomialSpace"
                                          []
                                          []
                                          (Ty.associated_in_trait
                                            "p3_commit::pcs::Pcs"
                                            []
                                            [
                                              Ty.associated_in_trait
                                                "openvm_stark_backend::config::StarkGenericConfig"
                                                []
                                                []
                                                SC
                                                "Challenge";
                                              Ty.associated_in_trait
                                                "openvm_stark_backend::config::StarkGenericConfig"
                                                []
                                                []
                                                SC
                                                "Challenger"
                                            ]
                                            (Ty.associated_in_trait
                                              "openvm_stark_backend::config::StarkGenericConfig"
                                              []
                                              []
                                              SC
                                              "Pcs")
                                            "Domain")
                                          "Val";
                                        Ty.path "alloc::alloc::Global"
                                      ]
                                  ];
                                Ty.path "alloc::alloc::Global"
                              ]
                          ],
                        γ0_0
                      |) in
                    let __arg_1 :=
                      M.alloc (|
                        Ty.apply
                          (Ty.path "&")
                          []
                          [
                            Ty.associated_in_trait
                              "p3_commit::pcs::Pcs"
                              []
                              [
                                Ty.associated_in_trait
                                  "openvm_stark_backend::config::StarkGenericConfig"
                                  []
                                  []
                                  SC
                                  "Challenge";
                                Ty.associated_in_trait
                                  "openvm_stark_backend::config::StarkGenericConfig"
                                  []
                                  []
                                  SC
                                  "Challenger"
                              ]
                              (Ty.associated_in_trait
                                "openvm_stark_backend::config::StarkGenericConfig"
                                []
                                []
                                SC
                                "Pcs")
                              "Commitment"
                          ],
                        γ0_1
                      |) in
                    let __arg_2 :=
                      M.alloc (|
                        Ty.apply
                          (Ty.path "&")
                          []
                          [
                            Ty.apply
                              (Ty.path "alloc::sync::Arc")
                              []
                              [
                                Ty.associated_in_trait
                                  "p3_commit::pcs::Pcs"
                                  []
                                  [
                                    Ty.associated_in_trait
                                      "openvm_stark_backend::config::StarkGenericConfig"
                                      []
                                      []
                                      SC
                                      "Challenge";
                                    Ty.associated_in_trait
                                      "openvm_stark_backend::config::StarkGenericConfig"
                                      []
                                      []
                                      SC
                                      "Challenger"
                                  ]
                                  (Ty.associated_in_trait
                                    "openvm_stark_backend::config::StarkGenericConfig"
                                    []
                                    []
                                    SC
                                    "Pcs")
                                  "ProverData";
                                Ty.path "alloc::alloc::Global"
                              ]
                          ],
                        γ0_2
                      |) in
                    Value.mkStructRecord
                      "openvm_stark_backend::prover::types::CommittedTraceData"
                      []
                      [ SC ]
                      [
                        ("trace",
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "alloc::sync::Arc")
                              []
                              [
                                Ty.apply
                                  (Ty.path "p3_matrix::dense::DenseMatrix")
                                  []
                                  [
                                    Ty.associated_in_trait
                                      "p3_commit::domain::PolynomialSpace"
                                      []
                                      []
                                      (Ty.associated_in_trait
                                        "p3_commit::pcs::Pcs"
                                        []
                                        [
                                          Ty.associated_in_trait
                                            "openvm_stark_backend::config::StarkGenericConfig"
                                            []
                                            []
                                            SC
                                            "Challenge";
                                          Ty.associated_in_trait
                                            "openvm_stark_backend::config::StarkGenericConfig"
                                            []
                                            []
                                            SC
                                            "Challenger"
                                        ]
                                        (Ty.associated_in_trait
                                          "openvm_stark_backend::config::StarkGenericConfig"
                                          []
                                          []
                                          SC
                                          "Pcs")
                                        "Domain")
                                      "Val";
                                    Ty.apply
                                      (Ty.path "alloc::vec::Vec")
                                      []
                                      [
                                        Ty.associated_in_trait
                                          "p3_commit::domain::PolynomialSpace"
                                          []
                                          []
                                          (Ty.associated_in_trait
                                            "p3_commit::pcs::Pcs"
                                            []
                                            [
                                              Ty.associated_in_trait
                                                "openvm_stark_backend::config::StarkGenericConfig"
                                                []
                                                []
                                                SC
                                                "Challenge";
                                              Ty.associated_in_trait
                                                "openvm_stark_backend::config::StarkGenericConfig"
                                                []
                                                []
                                                SC
                                                "Challenger"
                                            ]
                                            (Ty.associated_in_trait
                                              "openvm_stark_backend::config::StarkGenericConfig"
                                              []
                                              []
                                              SC
                                              "Pcs")
                                            "Domain")
                                          "Val";
                                        Ty.path "alloc::alloc::Global"
                                      ]
                                  ];
                                Ty.path "alloc::alloc::Global"
                              ],
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.apply
                                (Ty.path "alloc::sync::Arc")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "p3_matrix::dense::DenseMatrix")
                                    []
                                    [
                                      Ty.associated_in_trait
                                        "p3_commit::domain::PolynomialSpace"
                                        []
                                        []
                                        (Ty.associated_in_trait
                                          "p3_commit::pcs::Pcs"
                                          []
                                          [
                                            Ty.associated_in_trait
                                              "openvm_stark_backend::config::StarkGenericConfig"
                                              []
                                              []
                                              SC
                                              "Challenge";
                                            Ty.associated_in_trait
                                              "openvm_stark_backend::config::StarkGenericConfig"
                                              []
                                              []
                                              SC
                                              "Challenger"
                                          ]
                                          (Ty.associated_in_trait
                                            "openvm_stark_backend::config::StarkGenericConfig"
                                            []
                                            []
                                            SC
                                            "Pcs")
                                          "Domain")
                                        "Val";
                                      Ty.apply
                                        (Ty.path "alloc::vec::Vec")
                                        []
                                        [
                                          Ty.associated_in_trait
                                            "p3_commit::domain::PolynomialSpace"
                                            []
                                            []
                                            (Ty.associated_in_trait
                                              "p3_commit::pcs::Pcs"
                                              []
                                              [
                                                Ty.associated_in_trait
                                                  "openvm_stark_backend::config::StarkGenericConfig"
                                                  []
                                                  []
                                                  SC
                                                  "Challenge";
                                                Ty.associated_in_trait
                                                  "openvm_stark_backend::config::StarkGenericConfig"
                                                  []
                                                  []
                                                  SC
                                                  "Challenger"
                                              ]
                                              (Ty.associated_in_trait
                                                "openvm_stark_backend::config::StarkGenericConfig"
                                                []
                                                []
                                                SC
                                                "Pcs")
                                              "Domain")
                                            "Val";
                                          Ty.path "alloc::alloc::Global"
                                        ]
                                    ];
                                  Ty.path "alloc::alloc::Global"
                                ],
                              [],
                              [],
                              "clone",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __arg_0 |) |) |) ]
                          |));
                        ("commitment",
                          M.call_closure (|
                            Ty.associated_in_trait
                              "p3_commit::pcs::Pcs"
                              []
                              [
                                Ty.associated_in_trait
                                  "openvm_stark_backend::config::StarkGenericConfig"
                                  []
                                  []
                                  SC
                                  "Challenge";
                                Ty.associated_in_trait
                                  "openvm_stark_backend::config::StarkGenericConfig"
                                  []
                                  []
                                  SC
                                  "Challenger"
                              ]
                              (Ty.associated_in_trait
                                "openvm_stark_backend::config::StarkGenericConfig"
                                []
                                []
                                SC
                                "Pcs")
                              "Commitment",
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.associated_in_trait
                                "p3_commit::pcs::Pcs"
                                []
                                [
                                  Ty.associated_in_trait
                                    "openvm_stark_backend::config::StarkGenericConfig"
                                    []
                                    []
                                    SC
                                    "Challenge";
                                  Ty.associated_in_trait
                                    "openvm_stark_backend::config::StarkGenericConfig"
                                    []
                                    []
                                    SC
                                    "Challenger"
                                ]
                                (Ty.associated_in_trait
                                  "openvm_stark_backend::config::StarkGenericConfig"
                                  []
                                  []
                                  SC
                                  "Pcs")
                                "Commitment",
                              [],
                              [],
                              "clone",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __arg_1 |) |) |) ]
                          |));
                        ("pcs_data",
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "alloc::sync::Arc")
                              []
                              [
                                Ty.associated_in_trait
                                  "p3_commit::pcs::Pcs"
                                  []
                                  [
                                    Ty.associated_in_trait
                                      "openvm_stark_backend::config::StarkGenericConfig"
                                      []
                                      []
                                      SC
                                      "Challenge";
                                    Ty.associated_in_trait
                                      "openvm_stark_backend::config::StarkGenericConfig"
                                      []
                                      []
                                      SC
                                      "Challenger"
                                  ]
                                  (Ty.associated_in_trait
                                    "openvm_stark_backend::config::StarkGenericConfig"
                                    []
                                    []
                                    SC
                                    "Pcs")
                                  "ProverData";
                                Ty.path "alloc::alloc::Global"
                              ],
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.apply
                                (Ty.path "alloc::sync::Arc")
                                []
                                [
                                  Ty.associated_in_trait
                                    "p3_commit::pcs::Pcs"
                                    []
                                    [
                                      Ty.associated_in_trait
                                        "openvm_stark_backend::config::StarkGenericConfig"
                                        []
                                        []
                                        SC
                                        "Challenge";
                                      Ty.associated_in_trait
                                        "openvm_stark_backend::config::StarkGenericConfig"
                                        []
                                        []
                                        SC
                                        "Challenger"
                                    ]
                                    (Ty.associated_in_trait
                                      "openvm_stark_backend::config::StarkGenericConfig"
                                      []
                                      []
                                      SC
                                      "Pcs")
                                    "ProverData";
                                  Ty.path "alloc::alloc::Global"
                                ],
                              [],
                              [],
                              "clone",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __arg_2 |) |) |) ]
                          |))
                      ]))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (SC : Ty.t),
        M.IsTraitInstance
          "core::clone::Clone"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self SC)
          (* Instance *) [ ("clone", InstanceField.Method (clone SC)) ].
    End Impl_core_clone_Clone_where_openvm_stark_backend_config_StarkGenericConfig_SC_where_core_clone_Clone_associated_in_trait_p3_commit_pcs_Pcs__associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenge_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenger_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Pcs_Commitment_for_openvm_stark_backend_prover_types_CommittedTraceData_SC.
    
    (* StructRecord
      {
        name := "AirProofInput";
        const_params := [];
        ty_params := [ "SC" ];
        fields :=
          [
            ("cached_mains_pdata",
              Ty.apply
                (Ty.path "alloc::vec::Vec")
                []
                [
                  Ty.tuple
                    [
                      Ty.associated_in_trait
                        "p3_commit::pcs::Pcs"
                        []
                        [
                          Ty.associated_in_trait
                            "openvm_stark_backend::config::StarkGenericConfig"
                            []
                            []
                            SC
                            "Challenge";
                          Ty.associated_in_trait
                            "openvm_stark_backend::config::StarkGenericConfig"
                            []
                            []
                            SC
                            "Challenger"
                        ]
                        (Ty.associated_in_trait
                          "openvm_stark_backend::config::StarkGenericConfig"
                          []
                          []
                          SC
                          "Pcs")
                        "Commitment";
                      Ty.apply
                        (Ty.path "alloc::sync::Arc")
                        []
                        [
                          Ty.associated_in_trait
                            "p3_commit::pcs::Pcs"
                            []
                            [
                              Ty.associated_in_trait
                                "openvm_stark_backend::config::StarkGenericConfig"
                                []
                                []
                                SC
                                "Challenge";
                              Ty.associated_in_trait
                                "openvm_stark_backend::config::StarkGenericConfig"
                                []
                                []
                                SC
                                "Challenger"
                            ]
                            (Ty.associated_in_trait
                              "openvm_stark_backend::config::StarkGenericConfig"
                              []
                              []
                              SC
                              "Pcs")
                            "ProverData";
                          Ty.path "alloc::alloc::Global"
                        ]
                    ];
                  Ty.path "alloc::alloc::Global"
                ]);
            ("raw",
              Ty.apply
                (Ty.path "openvm_stark_backend::prover::types::AirProofRawInput")
                []
                [
                  Ty.associated_in_trait
                    "p3_commit::domain::PolynomialSpace"
                    []
                    []
                    (Ty.associated_in_trait
                      "p3_commit::pcs::Pcs"
                      []
                      [
                        Ty.associated_in_trait
                          "openvm_stark_backend::config::StarkGenericConfig"
                          []
                          []
                          SC
                          "Challenge";
                        Ty.associated_in_trait
                          "openvm_stark_backend::config::StarkGenericConfig"
                          []
                          []
                          SC
                          "Challenger"
                      ]
                      (Ty.associated_in_trait
                        "openvm_stark_backend::config::StarkGenericConfig"
                        []
                        []
                        SC
                        "Pcs")
                      "Domain")
                    "Val"
                ])
          ];
      } *)
    
    Module Impl_core_clone_Clone_where_openvm_stark_backend_config_StarkGenericConfig_SC_where_core_clone_Clone_associated_in_trait_p3_commit_pcs_Pcs__associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenge_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenger_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Pcs_Commitment_for_openvm_stark_backend_prover_types_AirProofInput_SC.
      Definition Self (SC : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "openvm_stark_backend::prover::types::AirProofInput") [] [ SC ].
      
      (* Derivative *)
      Definition clone (SC : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self SC in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path "openvm_stark_backend::prover::types::AirProofInput")
                      []
                      [ SC ]
                  ],
                self
              |) in
            M.match_operator (|
              Ty.apply (Ty.path "openvm_stark_backend::prover::types::AirProofInput") [] [ SC ],
              M.deref (| M.read (| self |) |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "openvm_stark_backend::prover::types::AirProofInput",
                        "cached_mains_pdata"
                      |) in
                    let γ0_1 :=
                      M.SubPointer.get_struct_record_field (|
                        γ,
                        "openvm_stark_backend::prover::types::AirProofInput",
                        "raw"
                      |) in
                    let __arg_0 :=
                      M.alloc (|
                        Ty.apply
                          (Ty.path "&")
                          []
                          [
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              []
                              [
                                Ty.tuple
                                  [
                                    Ty.associated_in_trait
                                      "p3_commit::pcs::Pcs"
                                      []
                                      [
                                        Ty.associated_in_trait
                                          "openvm_stark_backend::config::StarkGenericConfig"
                                          []
                                          []
                                          SC
                                          "Challenge";
                                        Ty.associated_in_trait
                                          "openvm_stark_backend::config::StarkGenericConfig"
                                          []
                                          []
                                          SC
                                          "Challenger"
                                      ]
                                      (Ty.associated_in_trait
                                        "openvm_stark_backend::config::StarkGenericConfig"
                                        []
                                        []
                                        SC
                                        "Pcs")
                                      "Commitment";
                                    Ty.apply
                                      (Ty.path "alloc::sync::Arc")
                                      []
                                      [
                                        Ty.associated_in_trait
                                          "p3_commit::pcs::Pcs"
                                          []
                                          [
                                            Ty.associated_in_trait
                                              "openvm_stark_backend::config::StarkGenericConfig"
                                              []
                                              []
                                              SC
                                              "Challenge";
                                            Ty.associated_in_trait
                                              "openvm_stark_backend::config::StarkGenericConfig"
                                              []
                                              []
                                              SC
                                              "Challenger"
                                          ]
                                          (Ty.associated_in_trait
                                            "openvm_stark_backend::config::StarkGenericConfig"
                                            []
                                            []
                                            SC
                                            "Pcs")
                                          "ProverData";
                                        Ty.path "alloc::alloc::Global"
                                      ]
                                  ];
                                Ty.path "alloc::alloc::Global"
                              ]
                          ],
                        γ0_0
                      |) in
                    let __arg_1 :=
                      M.alloc (|
                        Ty.apply
                          (Ty.path "&")
                          []
                          [
                            Ty.apply
                              (Ty.path "openvm_stark_backend::prover::types::AirProofRawInput")
                              []
                              [
                                Ty.associated_in_trait
                                  "p3_commit::domain::PolynomialSpace"
                                  []
                                  []
                                  (Ty.associated_in_trait
                                    "p3_commit::pcs::Pcs"
                                    []
                                    [
                                      Ty.associated_in_trait
                                        "openvm_stark_backend::config::StarkGenericConfig"
                                        []
                                        []
                                        SC
                                        "Challenge";
                                      Ty.associated_in_trait
                                        "openvm_stark_backend::config::StarkGenericConfig"
                                        []
                                        []
                                        SC
                                        "Challenger"
                                    ]
                                    (Ty.associated_in_trait
                                      "openvm_stark_backend::config::StarkGenericConfig"
                                      []
                                      []
                                      SC
                                      "Pcs")
                                    "Domain")
                                  "Val"
                              ]
                          ],
                        γ0_1
                      |) in
                    Value.mkStructRecord
                      "openvm_stark_backend::prover::types::AirProofInput"
                      []
                      [ SC ]
                      [
                        ("cached_mains_pdata",
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              []
                              [
                                Ty.tuple
                                  [
                                    Ty.associated_in_trait
                                      "p3_commit::pcs::Pcs"
                                      []
                                      [
                                        Ty.associated_in_trait
                                          "openvm_stark_backend::config::StarkGenericConfig"
                                          []
                                          []
                                          SC
                                          "Challenge";
                                        Ty.associated_in_trait
                                          "openvm_stark_backend::config::StarkGenericConfig"
                                          []
                                          []
                                          SC
                                          "Challenger"
                                      ]
                                      (Ty.associated_in_trait
                                        "openvm_stark_backend::config::StarkGenericConfig"
                                        []
                                        []
                                        SC
                                        "Pcs")
                                      "Commitment";
                                    Ty.apply
                                      (Ty.path "alloc::sync::Arc")
                                      []
                                      [
                                        Ty.associated_in_trait
                                          "p3_commit::pcs::Pcs"
                                          []
                                          [
                                            Ty.associated_in_trait
                                              "openvm_stark_backend::config::StarkGenericConfig"
                                              []
                                              []
                                              SC
                                              "Challenge";
                                            Ty.associated_in_trait
                                              "openvm_stark_backend::config::StarkGenericConfig"
                                              []
                                              []
                                              SC
                                              "Challenger"
                                          ]
                                          (Ty.associated_in_trait
                                            "openvm_stark_backend::config::StarkGenericConfig"
                                            []
                                            []
                                            SC
                                            "Pcs")
                                          "ProverData";
                                        Ty.path "alloc::alloc::Global"
                                      ]
                                  ];
                                Ty.path "alloc::alloc::Global"
                              ],
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                []
                                [
                                  Ty.tuple
                                    [
                                      Ty.associated_in_trait
                                        "p3_commit::pcs::Pcs"
                                        []
                                        [
                                          Ty.associated_in_trait
                                            "openvm_stark_backend::config::StarkGenericConfig"
                                            []
                                            []
                                            SC
                                            "Challenge";
                                          Ty.associated_in_trait
                                            "openvm_stark_backend::config::StarkGenericConfig"
                                            []
                                            []
                                            SC
                                            "Challenger"
                                        ]
                                        (Ty.associated_in_trait
                                          "openvm_stark_backend::config::StarkGenericConfig"
                                          []
                                          []
                                          SC
                                          "Pcs")
                                        "Commitment";
                                      Ty.apply
                                        (Ty.path "alloc::sync::Arc")
                                        []
                                        [
                                          Ty.associated_in_trait
                                            "p3_commit::pcs::Pcs"
                                            []
                                            [
                                              Ty.associated_in_trait
                                                "openvm_stark_backend::config::StarkGenericConfig"
                                                []
                                                []
                                                SC
                                                "Challenge";
                                              Ty.associated_in_trait
                                                "openvm_stark_backend::config::StarkGenericConfig"
                                                []
                                                []
                                                SC
                                                "Challenger"
                                            ]
                                            (Ty.associated_in_trait
                                              "openvm_stark_backend::config::StarkGenericConfig"
                                              []
                                              []
                                              SC
                                              "Pcs")
                                            "ProverData";
                                          Ty.path "alloc::alloc::Global"
                                        ]
                                    ];
                                  Ty.path "alloc::alloc::Global"
                                ],
                              [],
                              [],
                              "clone",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __arg_0 |) |) |) ]
                          |));
                        ("raw",
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "openvm_stark_backend::prover::types::AirProofRawInput")
                              []
                              [
                                Ty.associated_in_trait
                                  "p3_commit::domain::PolynomialSpace"
                                  []
                                  []
                                  (Ty.associated_in_trait
                                    "p3_commit::pcs::Pcs"
                                    []
                                    [
                                      Ty.associated_in_trait
                                        "openvm_stark_backend::config::StarkGenericConfig"
                                        []
                                        []
                                        SC
                                        "Challenge";
                                      Ty.associated_in_trait
                                        "openvm_stark_backend::config::StarkGenericConfig"
                                        []
                                        []
                                        SC
                                        "Challenger"
                                    ]
                                    (Ty.associated_in_trait
                                      "openvm_stark_backend::config::StarkGenericConfig"
                                      []
                                      []
                                      SC
                                      "Pcs")
                                    "Domain")
                                  "Val"
                              ],
                            M.get_trait_method (|
                              "core::clone::Clone",
                              Ty.apply
                                (Ty.path "openvm_stark_backend::prover::types::AirProofRawInput")
                                []
                                [
                                  Ty.associated_in_trait
                                    "p3_commit::domain::PolynomialSpace"
                                    []
                                    []
                                    (Ty.associated_in_trait
                                      "p3_commit::pcs::Pcs"
                                      []
                                      [
                                        Ty.associated_in_trait
                                          "openvm_stark_backend::config::StarkGenericConfig"
                                          []
                                          []
                                          SC
                                          "Challenge";
                                        Ty.associated_in_trait
                                          "openvm_stark_backend::config::StarkGenericConfig"
                                          []
                                          []
                                          SC
                                          "Challenger"
                                      ]
                                      (Ty.associated_in_trait
                                        "openvm_stark_backend::config::StarkGenericConfig"
                                        []
                                        []
                                        SC
                                        "Pcs")
                                      "Domain")
                                    "Val"
                                ],
                              [],
                              [],
                              "clone",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __arg_1 |) |) |) ]
                          |))
                      ]))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (SC : Ty.t),
        M.IsTraitInstance
          "core::clone::Clone"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self SC)
          (* Instance *) [ ("clone", InstanceField.Method (clone SC)) ].
    End Impl_core_clone_Clone_where_openvm_stark_backend_config_StarkGenericConfig_SC_where_core_clone_Clone_associated_in_trait_p3_commit_pcs_Pcs__associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenge_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Challenger_associated_in_trait_openvm_stark_backend_config_StarkGenericConfig___SC_Pcs_Commitment_for_openvm_stark_backend_prover_types_AirProofInput_SC.
    
    (* StructRecord
      {
        name := "AirProofRawInput";
        const_params := [];
        ty_params := [ "F" ];
        fields :=
          [
            ("cached_mains",
              Ty.apply
                (Ty.path "alloc::vec::Vec")
                []
                [
                  Ty.apply
                    (Ty.path "alloc::sync::Arc")
                    []
                    [
                      Ty.apply
                        (Ty.path "p3_matrix::dense::DenseMatrix")
                        []
                        [
                          F;
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            []
                            [ F; Ty.path "alloc::alloc::Global" ]
                        ];
                      Ty.path "alloc::alloc::Global"
                    ];
                  Ty.path "alloc::alloc::Global"
                ]);
            ("common_main",
              Ty.apply
                (Ty.path "core::option::Option")
                []
                [
                  Ty.apply
                    (Ty.path "p3_matrix::dense::DenseMatrix")
                    []
                    [
                      F;
                      Ty.apply (Ty.path "alloc::vec::Vec") [] [ F; Ty.path "alloc::alloc::Global" ]
                    ]
                ]);
            ("public_values",
              Ty.apply (Ty.path "alloc::vec::Vec") [] [ F; Ty.path "alloc::alloc::Global" ])
          ];
      } *)
    
    Module Impl_core_clone_Clone_where_core_clone_Clone_F_where_p3_field_field_Field_F_for_openvm_stark_backend_prover_types_AirProofRawInput_F.
      Definition Self (F : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "openvm_stark_backend::prover::types::AirProofRawInput") [] [ F ].
      
      (* Clone *)
      Definition clone (F : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path "openvm_stark_backend::prover::types::AirProofRawInput")
                      []
                      [ F ]
                  ],
                self
              |) in
            Value.mkStructRecord
              "openvm_stark_backend::prover::types::AirProofRawInput"
              []
              [ F ]
              [
                ("cached_mains",
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      []
                      [
                        Ty.apply
                          (Ty.path "alloc::sync::Arc")
                          []
                          [
                            Ty.apply
                              (Ty.path "p3_matrix::dense::DenseMatrix")
                              []
                              [
                                F;
                                Ty.apply
                                  (Ty.path "alloc::vec::Vec")
                                  []
                                  [ F; Ty.path "alloc::alloc::Global" ]
                              ];
                            Ty.path "alloc::alloc::Global"
                          ];
                        Ty.path "alloc::alloc::Global"
                      ],
                    M.get_trait_method (|
                      "core::clone::Clone",
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        []
                        [
                          Ty.apply
                            (Ty.path "alloc::sync::Arc")
                            []
                            [
                              Ty.apply
                                (Ty.path "p3_matrix::dense::DenseMatrix")
                                []
                                [
                                  F;
                                  Ty.apply
                                    (Ty.path "alloc::vec::Vec")
                                    []
                                    [ F; Ty.path "alloc::alloc::Global" ]
                                ];
                              Ty.path "alloc::alloc::Global"
                            ];
                          Ty.path "alloc::alloc::Global"
                        ],
                      [],
                      [],
                      "clone",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "openvm_stark_backend::prover::types::AirProofRawInput",
                              "cached_mains"
                            |)
                          |)
                        |)
                      |)
                    ]
                  |));
                ("common_main",
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::option::Option")
                      []
                      [
                        Ty.apply
                          (Ty.path "p3_matrix::dense::DenseMatrix")
                          []
                          [
                            F;
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              []
                              [ F; Ty.path "alloc::alloc::Global" ]
                          ]
                      ],
                    M.get_trait_method (|
                      "core::clone::Clone",
                      Ty.apply
                        (Ty.path "core::option::Option")
                        []
                        [
                          Ty.apply
                            (Ty.path "p3_matrix::dense::DenseMatrix")
                            []
                            [
                              F;
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                []
                                [ F; Ty.path "alloc::alloc::Global" ]
                            ]
                        ],
                      [],
                      [],
                      "clone",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "openvm_stark_backend::prover::types::AirProofRawInput",
                              "common_main"
                            |)
                          |)
                        |)
                      |)
                    ]
                  |));
                ("public_values",
                  M.call_closure (|
                    Ty.apply (Ty.path "alloc::vec::Vec") [] [ F; Ty.path "alloc::alloc::Global" ],
                    M.get_trait_method (|
                      "core::clone::Clone",
                      Ty.apply (Ty.path "alloc::vec::Vec") [] [ F; Ty.path "alloc::alloc::Global" ],
                      [],
                      [],
                      "clone",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "openvm_stark_backend::prover::types::AirProofRawInput",
                              "public_values"
                            |)
                          |)
                        |)
                      |)
                    ]
                  |))
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (F : Ty.t),
        M.IsTraitInstance
          "core::clone::Clone"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self F)
          (* Instance *) [ ("clone", InstanceField.Method (clone F)) ].
    End Impl_core_clone_Clone_where_core_clone_Clone_F_where_p3_field_field_Field_F_for_openvm_stark_backend_prover_types_AirProofRawInput_F.
    
    Module Impl_core_fmt_Debug_where_core_fmt_Debug_F_where_p3_field_field_Field_F_for_openvm_stark_backend_prover_types_AirProofRawInput_F.
      Definition Self (F : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "openvm_stark_backend::prover::types::AirProofRawInput") [] [ F ].
      
      (* Debug *)
      Definition fmt (F : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path "openvm_stark_backend::prover::types::AirProofRawInput")
                      []
                      [ F ]
                  ],
                self
              |) in
            let f :=
              M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "core::fmt::Formatter" ], f |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
              M.get_associated_function (|
                Ty.path "core::fmt::Formatter",
                "debug_struct_field3_finish",
                [],
                []
              |),
              [
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "AirProofRawInput" |) |) |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "cached_mains" |) |) |);
                M.call_closure (|
                  Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ],
                  M.pointer_coercion
                    M.PointerCoercion.Unsize
                    (Ty.apply
                      (Ty.path "&")
                      []
                      [
                        Ty.apply
                          (Ty.path "alloc::vec::Vec")
                          []
                          [
                            Ty.apply
                              (Ty.path "alloc::sync::Arc")
                              []
                              [
                                Ty.apply
                                  (Ty.path "p3_matrix::dense::DenseMatrix")
                                  []
                                  [
                                    F;
                                    Ty.apply
                                      (Ty.path "alloc::vec::Vec")
                                      []
                                      [ F; Ty.path "alloc::alloc::Global" ]
                                  ];
                                Ty.path "alloc::alloc::Global"
                              ];
                            Ty.path "alloc::alloc::Global"
                          ]
                      ])
                    (Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ]),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "openvm_stark_backend::prover::types::AirProofRawInput",
                            "cached_mains"
                          |)
                        |)
                      |)
                    |)
                  ]
                |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "common_main" |) |) |);
                M.call_closure (|
                  Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ],
                  M.pointer_coercion
                    M.PointerCoercion.Unsize
                    (Ty.apply
                      (Ty.path "&")
                      []
                      [
                        Ty.apply
                          (Ty.path "core::option::Option")
                          []
                          [
                            Ty.apply
                              (Ty.path "p3_matrix::dense::DenseMatrix")
                              []
                              [
                                F;
                                Ty.apply
                                  (Ty.path "alloc::vec::Vec")
                                  []
                                  [ F; Ty.path "alloc::alloc::Global" ]
                              ]
                          ]
                      ])
                    (Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ]),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "openvm_stark_backend::prover::types::AirProofRawInput",
                            "common_main"
                          |)
                        |)
                      |)
                    |)
                  ]
                |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "public_values" |) |) |);
                M.call_closure (|
                  Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ],
                  M.pointer_coercion
                    M.PointerCoercion.Unsize
                    (Ty.apply
                      (Ty.path "&")
                      []
                      [
                        Ty.apply
                          (Ty.path "&")
                          []
                          [
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              []
                              [ F; Ty.path "alloc::alloc::Global" ]
                          ]
                      ])
                    (Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ]),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.alloc (|
                            Ty.apply
                              (Ty.path "&")
                              []
                              [
                                Ty.apply
                                  (Ty.path "alloc::vec::Vec")
                                  []
                                  [ F; Ty.path "alloc::alloc::Global" ]
                              ],
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "openvm_stark_backend::prover::types::AirProofRawInput",
                                "public_values"
                              |)
                            |)
                          |)
                        |)
                      |)
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (F : Ty.t),
        M.IsTraitInstance
          "core::fmt::Debug"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          (Self F)
          (* Instance *) [ ("fmt", InstanceField.Method (fmt F)) ].
    End Impl_core_fmt_Debug_where_core_fmt_Debug_F_where_p3_field_field_Field_F_for_openvm_stark_backend_prover_types_AirProofRawInput_F.
    
    Module Impl_openvm_stark_backend_prover_types_AirProofRawInput_F.
      Definition Self (F : Ty.t) : Ty.t :=
        Ty.apply (Ty.path "openvm_stark_backend::prover::types::AirProofRawInput") [] [ F ].
      
      (*
          pub fn height(&self) -> usize {
              let mut height = None;
              for m in self.cached_mains.iter() {
                  if let Some(h) = height {
                      assert_eq!(h, m.height());
                  } else {
                      height = Some(m.height());
                  }
              }
              let common_h = self.common_main.as_ref().map(|trace| trace.height());
              if let Some(h) = height {
                  if let Some(common_h) = common_h {
                      assert_eq!(h, common_h);
                  }
                  h
              } else {
                  common_h.unwrap_or(0)
              }
          }
      *)
      Definition height (F : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        let Self : Ty.t := Self F in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path "openvm_stark_backend::prover::types::AirProofRawInput")
                      []
                      [ F ]
                  ],
                self
              |) in
            M.read (|
              let~ height : Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ] :=
                Value.StructTuple "core::option::Option::None" [] [ Ty.path "usize" ] [] in
              let~ _ : Ty.tuple [] :=
                M.read (|
                  M.use
                    (M.alloc (|
                      Ty.tuple [],
                      M.match_operator (|
                        Ty.tuple [],
                        M.alloc (|
                          Ty.apply
                            (Ty.path "core::slice::iter::Iter")
                            []
                            [
                              Ty.apply
                                (Ty.path "alloc::sync::Arc")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "p3_matrix::dense::DenseMatrix")
                                    []
                                    [
                                      F;
                                      Ty.apply
                                        (Ty.path "alloc::vec::Vec")
                                        []
                                        [ F; Ty.path "alloc::alloc::Global" ]
                                    ];
                                  Ty.path "alloc::alloc::Global"
                                ]
                            ],
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "core::slice::iter::Iter")
                              []
                              [
                                Ty.apply
                                  (Ty.path "alloc::sync::Arc")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "p3_matrix::dense::DenseMatrix")
                                      []
                                      [
                                        F;
                                        Ty.apply
                                          (Ty.path "alloc::vec::Vec")
                                          []
                                          [ F; Ty.path "alloc::alloc::Global" ]
                                      ];
                                    Ty.path "alloc::alloc::Global"
                                  ]
                              ],
                            M.get_trait_method (|
                              "core::iter::traits::collect::IntoIterator",
                              Ty.apply
                                (Ty.path "core::slice::iter::Iter")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "alloc::sync::Arc")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "p3_matrix::dense::DenseMatrix")
                                        []
                                        [
                                          F;
                                          Ty.apply
                                            (Ty.path "alloc::vec::Vec")
                                            []
                                            [ F; Ty.path "alloc::alloc::Global" ]
                                        ];
                                      Ty.path "alloc::alloc::Global"
                                    ]
                                ],
                              [],
                              [],
                              "into_iter",
                              [],
                              []
                            |),
                            [
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::slice::iter::Iter")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "alloc::sync::Arc")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "p3_matrix::dense::DenseMatrix")
                                          []
                                          [
                                            F;
                                            Ty.apply
                                              (Ty.path "alloc::vec::Vec")
                                              []
                                              [ F; Ty.path "alloc::alloc::Global" ]
                                          ];
                                        Ty.path "alloc::alloc::Global"
                                      ]
                                  ],
                                M.get_associated_function (|
                                  Ty.apply
                                    (Ty.path "slice")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "alloc::sync::Arc")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "p3_matrix::dense::DenseMatrix")
                                            []
                                            [
                                              F;
                                              Ty.apply
                                                (Ty.path "alloc::vec::Vec")
                                                []
                                                [ F; Ty.path "alloc::alloc::Global" ]
                                            ];
                                          Ty.path "alloc::alloc::Global"
                                        ]
                                    ],
                                  "iter",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "&")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "slice")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "alloc::sync::Arc")
                                                  []
                                                  [
                                                    Ty.apply
                                                      (Ty.path "p3_matrix::dense::DenseMatrix")
                                                      []
                                                      [
                                                        F;
                                                        Ty.apply
                                                          (Ty.path "alloc::vec::Vec")
                                                          []
                                                          [ F; Ty.path "alloc::alloc::Global" ]
                                                      ];
                                                    Ty.path "alloc::alloc::Global"
                                                  ]
                                              ]
                                          ],
                                        M.get_trait_method (|
                                          "core::ops::deref::Deref",
                                          Ty.apply
                                            (Ty.path "alloc::vec::Vec")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "alloc::sync::Arc")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "p3_matrix::dense::DenseMatrix")
                                                    []
                                                    [
                                                      F;
                                                      Ty.apply
                                                        (Ty.path "alloc::vec::Vec")
                                                        []
                                                        [ F; Ty.path "alloc::alloc::Global" ]
                                                    ];
                                                  Ty.path "alloc::alloc::Global"
                                                ];
                                              Ty.path "alloc::alloc::Global"
                                            ],
                                          [],
                                          [],
                                          "deref",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.SubPointer.get_struct_record_field (|
                                              M.deref (| M.read (| self |) |),
                                              "openvm_stark_backend::prover::types::AirProofRawInput",
                                              "cached_mains"
                                            |)
                                          |)
                                        ]
                                      |)
                                    |)
                                  |)
                                ]
                              |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let iter :=
                                M.copy (|
                                  Ty.apply
                                    (Ty.path "core::slice::iter::Iter")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "alloc::sync::Arc")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "p3_matrix::dense::DenseMatrix")
                                            []
                                            [
                                              F;
                                              Ty.apply
                                                (Ty.path "alloc::vec::Vec")
                                                []
                                                [ F; Ty.path "alloc::alloc::Global" ]
                                            ];
                                          Ty.path "alloc::alloc::Global"
                                        ]
                                    ],
                                  γ
                                |) in
                              M.read (|
                                M.loop (|
                                  Ty.tuple [],
                                  ltac:(M.monadic
                                    (let~ _ : Ty.tuple [] :=
                                      M.match_operator (|
                                        Ty.tuple [],
                                        M.alloc (|
                                          Ty.apply
                                            (Ty.path "core::option::Option")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "&")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "alloc::sync::Arc")
                                                    []
                                                    [
                                                      Ty.apply
                                                        (Ty.path "p3_matrix::dense::DenseMatrix")
                                                        []
                                                        [
                                                          F;
                                                          Ty.apply
                                                            (Ty.path "alloc::vec::Vec")
                                                            []
                                                            [ F; Ty.path "alloc::alloc::Global" ]
                                                        ];
                                                      Ty.path "alloc::alloc::Global"
                                                    ]
                                                ]
                                            ],
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::option::Option")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "&")
                                                  []
                                                  [
                                                    Ty.apply
                                                      (Ty.path "alloc::sync::Arc")
                                                      []
                                                      [
                                                        Ty.apply
                                                          (Ty.path "p3_matrix::dense::DenseMatrix")
                                                          []
                                                          [
                                                            F;
                                                            Ty.apply
                                                              (Ty.path "alloc::vec::Vec")
                                                              []
                                                              [ F; Ty.path "alloc::alloc::Global" ]
                                                          ];
                                                        Ty.path "alloc::alloc::Global"
                                                      ]
                                                  ]
                                              ],
                                            M.get_trait_method (|
                                              "core::iter::traits::iterator::Iterator",
                                              Ty.apply
                                                (Ty.path "core::slice::iter::Iter")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "alloc::sync::Arc")
                                                    []
                                                    [
                                                      Ty.apply
                                                        (Ty.path "p3_matrix::dense::DenseMatrix")
                                                        []
                                                        [
                                                          F;
                                                          Ty.apply
                                                            (Ty.path "alloc::vec::Vec")
                                                            []
                                                            [ F; Ty.path "alloc::alloc::Global" ]
                                                        ];
                                                      Ty.path "alloc::alloc::Global"
                                                    ]
                                                ],
                                              [],
                                              [],
                                              "next",
                                              [],
                                              []
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.MutRef,
                                                M.deref (|
                                                  M.borrow (| Pointer.Kind.MutRef, iter |)
                                                |)
                                              |)
                                            ]
                                          |)
                                        |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let _ :=
                                                M.is_struct_tuple (|
                                                  γ,
                                                  "core::option::Option::None"
                                                |) in
                                              M.never_to_any (| M.read (| M.break (||) |) |)));
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let γ0_0 :=
                                                M.SubPointer.get_struct_tuple_field (|
                                                  γ,
                                                  "core::option::Option::Some",
                                                  0
                                                |) in
                                              let m :=
                                                M.copy (|
                                                  Ty.apply
                                                    (Ty.path "&")
                                                    []
                                                    [
                                                      Ty.apply
                                                        (Ty.path "alloc::sync::Arc")
                                                        []
                                                        [
                                                          Ty.apply
                                                            (Ty.path
                                                              "p3_matrix::dense::DenseMatrix")
                                                            []
                                                            [
                                                              F;
                                                              Ty.apply
                                                                (Ty.path "alloc::vec::Vec")
                                                                []
                                                                [ F; Ty.path "alloc::alloc::Global"
                                                                ]
                                                            ];
                                                          Ty.path "alloc::alloc::Global"
                                                        ]
                                                    ],
                                                  γ0_0
                                                |) in
                                              M.match_operator (|
                                                Ty.tuple [],
                                                M.alloc (| Ty.tuple [], Value.Tuple [] |),
                                                [
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (let γ := height in
                                                      let γ0_0 :=
                                                        M.SubPointer.get_struct_tuple_field (|
                                                          γ,
                                                          "core::option::Option::Some",
                                                          0
                                                        |) in
                                                      let h := M.copy (| Ty.path "usize", γ0_0 |) in
                                                      M.read (|
                                                        let~ _ : Ty.tuple [] :=
                                                          M.match_operator (|
                                                            Ty.tuple [],
                                                            M.alloc (|
                                                              Ty.tuple
                                                                [
                                                                  Ty.apply
                                                                    (Ty.path "&")
                                                                    []
                                                                    [ Ty.path "usize" ];
                                                                  Ty.apply
                                                                    (Ty.path "&")
                                                                    []
                                                                    [ Ty.path "usize" ]
                                                                ],
                                                              Value.Tuple
                                                                [
                                                                  M.borrow (|
                                                                    Pointer.Kind.Ref,
                                                                    h
                                                                  |);
                                                                  M.borrow (|
                                                                    Pointer.Kind.Ref,
                                                                    M.alloc (|
                                                                      Ty.path "usize",
                                                                      M.call_closure (|
                                                                        Ty.path "usize",
                                                                        M.get_trait_method (|
                                                                          "p3_matrix::Matrix",
                                                                          Ty.apply
                                                                            (Ty.path
                                                                              "p3_matrix::dense::DenseMatrix")
                                                                            []
                                                                            [
                                                                              F;
                                                                              Ty.apply
                                                                                (Ty.path
                                                                                  "alloc::vec::Vec")
                                                                                []
                                                                                [
                                                                                  F;
                                                                                  Ty.path
                                                                                    "alloc::alloc::Global"
                                                                                ]
                                                                            ],
                                                                          [],
                                                                          [ F ],
                                                                          "height",
                                                                          [],
                                                                          []
                                                                        |),
                                                                        [
                                                                          M.borrow (|
                                                                            Pointer.Kind.Ref,
                                                                            M.deref (|
                                                                              M.call_closure (|
                                                                                Ty.apply
                                                                                  (Ty.path "&")
                                                                                  []
                                                                                  [
                                                                                    Ty.apply
                                                                                      (Ty.path
                                                                                        "p3_matrix::dense::DenseMatrix")
                                                                                      []
                                                                                      [
                                                                                        F;
                                                                                        Ty.apply
                                                                                          (Ty.path
                                                                                            "alloc::vec::Vec")
                                                                                          []
                                                                                          [
                                                                                            F;
                                                                                            Ty.path
                                                                                              "alloc::alloc::Global"
                                                                                          ]
                                                                                      ]
                                                                                  ],
                                                                                M.get_trait_method (|
                                                                                  "core::ops::deref::Deref",
                                                                                  Ty.apply
                                                                                    (Ty.path
                                                                                      "alloc::sync::Arc")
                                                                                    []
                                                                                    [
                                                                                      Ty.apply
                                                                                        (Ty.path
                                                                                          "p3_matrix::dense::DenseMatrix")
                                                                                        []
                                                                                        [
                                                                                          F;
                                                                                          Ty.apply
                                                                                            (Ty.path
                                                                                              "alloc::vec::Vec")
                                                                                            []
                                                                                            [
                                                                                              F;
                                                                                              Ty.path
                                                                                                "alloc::alloc::Global"
                                                                                            ]
                                                                                        ];
                                                                                      Ty.path
                                                                                        "alloc::alloc::Global"
                                                                                    ],
                                                                                  [],
                                                                                  [],
                                                                                  "deref",
                                                                                  [],
                                                                                  []
                                                                                |),
                                                                                [
                                                                                  M.borrow (|
                                                                                    Pointer.Kind.Ref,
                                                                                    M.deref (|
                                                                                      M.read (| m |)
                                                                                    |)
                                                                                  |)
                                                                                ]
                                                                              |)
                                                                            |)
                                                                          |)
                                                                        ]
                                                                      |)
                                                                    |)
                                                                  |)
                                                                ]
                                                            |),
                                                            [
                                                              fun γ =>
                                                                ltac:(M.monadic
                                                                  (let γ0_0 :=
                                                                    M.SubPointer.get_tuple_field (|
                                                                      γ,
                                                                      0
                                                                    |) in
                                                                  let γ0_1 :=
                                                                    M.SubPointer.get_tuple_field (|
                                                                      γ,
                                                                      1
                                                                    |) in
                                                                  let left_val :=
                                                                    M.copy (|
                                                                      Ty.apply
                                                                        (Ty.path "&")
                                                                        []
                                                                        [ Ty.path "usize" ],
                                                                      γ0_0
                                                                    |) in
                                                                  let right_val :=
                                                                    M.copy (|
                                                                      Ty.apply
                                                                        (Ty.path "&")
                                                                        []
                                                                        [ Ty.path "usize" ],
                                                                      γ0_1
                                                                    |) in
                                                                  M.match_operator (|
                                                                    Ty.tuple [],
                                                                    M.alloc (|
                                                                      Ty.tuple [],
                                                                      Value.Tuple []
                                                                    |),
                                                                    [
                                                                      fun γ =>
                                                                        ltac:(M.monadic
                                                                          (let γ :=
                                                                            M.use
                                                                              (M.alloc (|
                                                                                Ty.path "bool",
                                                                                UnOp.not (|
                                                                                  M.call_closure (|
                                                                                    Ty.path "bool",
                                                                                    BinOp.eq,
                                                                                    [
                                                                                      M.read (|
                                                                                        M.deref (|
                                                                                          M.read (|
                                                                                            left_val
                                                                                          |)
                                                                                        |)
                                                                                      |);
                                                                                      M.read (|
                                                                                        M.deref (|
                                                                                          M.read (|
                                                                                            right_val
                                                                                          |)
                                                                                        |)
                                                                                      |)
                                                                                    ]
                                                                                  |)
                                                                                |)
                                                                              |)) in
                                                                          let _ :=
                                                                            is_constant_or_break_match (|
                                                                              M.read (| γ |),
                                                                              Value.Bool true
                                                                            |) in
                                                                          M.never_to_any (|
                                                                            M.read (|
                                                                              let~ kind :
                                                                                  Ty.path
                                                                                    "core::panicking::AssertKind" :=
                                                                                Value.StructTuple
                                                                                  "core::panicking::AssertKind::Eq"
                                                                                  []
                                                                                  []
                                                                                  [] in
                                                                              M.alloc (|
                                                                                Ty.path "never",
                                                                                M.call_closure (|
                                                                                  Ty.path "never",
                                                                                  M.get_function (|
                                                                                    "core::panicking::assert_failed",
                                                                                    [],
                                                                                    [
                                                                                      Ty.path
                                                                                        "usize";
                                                                                      Ty.path
                                                                                        "usize"
                                                                                    ]
                                                                                  |),
                                                                                  [
                                                                                    M.read (|
                                                                                      kind
                                                                                    |);
                                                                                    M.borrow (|
                                                                                      Pointer.Kind.Ref,
                                                                                      M.deref (|
                                                                                        M.borrow (|
                                                                                          Pointer.Kind.Ref,
                                                                                          M.deref (|
                                                                                            M.read (|
                                                                                              left_val
                                                                                            |)
                                                                                          |)
                                                                                        |)
                                                                                      |)
                                                                                    |);
                                                                                    M.borrow (|
                                                                                      Pointer.Kind.Ref,
                                                                                      M.deref (|
                                                                                        M.borrow (|
                                                                                          Pointer.Kind.Ref,
                                                                                          M.deref (|
                                                                                            M.read (|
                                                                                              right_val
                                                                                            |)
                                                                                          |)
                                                                                        |)
                                                                                      |)
                                                                                    |);
                                                                                    Value.StructTuple
                                                                                      "core::option::Option::None"
                                                                                      []
                                                                                      [
                                                                                        Ty.path
                                                                                          "core::fmt::Arguments"
                                                                                      ]
                                                                                      []
                                                                                  ]
                                                                                |)
                                                                              |)
                                                                            |)
                                                                          |)));
                                                                      fun γ =>
                                                                        ltac:(M.monadic
                                                                          (Value.Tuple []))
                                                                    ]
                                                                  |)))
                                                            ]
                                                          |) in
                                                        M.alloc (| Ty.tuple [], Value.Tuple [] |)
                                                      |)));
                                                  fun γ =>
                                                    ltac:(M.monadic
                                                      (M.read (|
                                                        let~ _ : Ty.tuple [] :=
                                                          M.write (|
                                                            height,
                                                            Value.StructTuple
                                                              "core::option::Option::Some"
                                                              []
                                                              [ Ty.path "usize" ]
                                                              [
                                                                M.call_closure (|
                                                                  Ty.path "usize",
                                                                  M.get_trait_method (|
                                                                    "p3_matrix::Matrix",
                                                                    Ty.apply
                                                                      (Ty.path
                                                                        "p3_matrix::dense::DenseMatrix")
                                                                      []
                                                                      [
                                                                        F;
                                                                        Ty.apply
                                                                          (Ty.path
                                                                            "alloc::vec::Vec")
                                                                          []
                                                                          [
                                                                            F;
                                                                            Ty.path
                                                                              "alloc::alloc::Global"
                                                                          ]
                                                                      ],
                                                                    [],
                                                                    [ F ],
                                                                    "height",
                                                                    [],
                                                                    []
                                                                  |),
                                                                  [
                                                                    M.borrow (|
                                                                      Pointer.Kind.Ref,
                                                                      M.deref (|
                                                                        M.call_closure (|
                                                                          Ty.apply
                                                                            (Ty.path "&")
                                                                            []
                                                                            [
                                                                              Ty.apply
                                                                                (Ty.path
                                                                                  "p3_matrix::dense::DenseMatrix")
                                                                                []
                                                                                [
                                                                                  F;
                                                                                  Ty.apply
                                                                                    (Ty.path
                                                                                      "alloc::vec::Vec")
                                                                                    []
                                                                                    [
                                                                                      F;
                                                                                      Ty.path
                                                                                        "alloc::alloc::Global"
                                                                                    ]
                                                                                ]
                                                                            ],
                                                                          M.get_trait_method (|
                                                                            "core::ops::deref::Deref",
                                                                            Ty.apply
                                                                              (Ty.path
                                                                                "alloc::sync::Arc")
                                                                              []
                                                                              [
                                                                                Ty.apply
                                                                                  (Ty.path
                                                                                    "p3_matrix::dense::DenseMatrix")
                                                                                  []
                                                                                  [
                                                                                    F;
                                                                                    Ty.apply
                                                                                      (Ty.path
                                                                                        "alloc::vec::Vec")
                                                                                      []
                                                                                      [
                                                                                        F;
                                                                                        Ty.path
                                                                                          "alloc::alloc::Global"
                                                                                      ]
                                                                                  ];
                                                                                Ty.path
                                                                                  "alloc::alloc::Global"
                                                                              ],
                                                                            [],
                                                                            [],
                                                                            "deref",
                                                                            [],
                                                                            []
                                                                          |),
                                                                          [
                                                                            M.borrow (|
                                                                              Pointer.Kind.Ref,
                                                                              M.deref (|
                                                                                M.read (| m |)
                                                                              |)
                                                                            |)
                                                                          ]
                                                                        |)
                                                                      |)
                                                                    |)
                                                                  ]
                                                                |)
                                                              ]
                                                          |) in
                                                        M.alloc (| Ty.tuple [], Value.Tuple [] |)
                                                      |)))
                                                ]
                                              |)))
                                        ]
                                      |) in
                                    M.alloc (| Ty.tuple [], Value.Tuple [] |)))
                                |)
                              |)))
                        ]
                      |)
                    |))
                |) in
              let~ common_h : Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ] :=
                M.call_closure (|
                  Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::option::Option")
                      []
                      [
                        Ty.apply
                          (Ty.path "&")
                          []
                          [
                            Ty.apply
                              (Ty.path "p3_matrix::dense::DenseMatrix")
                              []
                              [
                                F;
                                Ty.apply
                                  (Ty.path "alloc::vec::Vec")
                                  []
                                  [ F; Ty.path "alloc::alloc::Global" ]
                              ]
                          ]
                      ],
                    "map",
                    [],
                    [
                      Ty.path "usize";
                      Ty.function
                        [
                          Ty.apply
                            (Ty.path "&")
                            []
                            [
                              Ty.apply
                                (Ty.path "p3_matrix::dense::DenseMatrix")
                                []
                                [
                                  F;
                                  Ty.apply
                                    (Ty.path "alloc::vec::Vec")
                                    []
                                    [ F; Ty.path "alloc::alloc::Global" ]
                                ]
                            ]
                        ]
                        (Ty.path "usize")
                    ]
                  |),
                  [
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::option::Option")
                        []
                        [
                          Ty.apply
                            (Ty.path "&")
                            []
                            [
                              Ty.apply
                                (Ty.path "p3_matrix::dense::DenseMatrix")
                                []
                                [
                                  F;
                                  Ty.apply
                                    (Ty.path "alloc::vec::Vec")
                                    []
                                    [ F; Ty.path "alloc::alloc::Global" ]
                                ]
                            ]
                        ],
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "core::option::Option")
                          []
                          [
                            Ty.apply
                              (Ty.path "p3_matrix::dense::DenseMatrix")
                              []
                              [
                                F;
                                Ty.apply
                                  (Ty.path "alloc::vec::Vec")
                                  []
                                  [ F; Ty.path "alloc::alloc::Global" ]
                              ]
                          ],
                        "as_ref",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "openvm_stark_backend::prover::types::AirProofRawInput",
                            "common_main"
                          |)
                        |)
                      ]
                    |);
                    M.closure
                      (fun γ =>
                        ltac:(M.monadic
                          match γ with
                          | [ α0 ] =>
                            ltac:(M.monadic
                              (M.match_operator (|
                                Ty.path "usize",
                                M.alloc (|
                                  Ty.apply
                                    (Ty.path "&")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "p3_matrix::dense::DenseMatrix")
                                        []
                                        [
                                          F;
                                          Ty.apply
                                            (Ty.path "alloc::vec::Vec")
                                            []
                                            [ F; Ty.path "alloc::alloc::Global" ]
                                        ]
                                    ],
                                  α0
                                |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let trace :=
                                        M.copy (|
                                          Ty.apply
                                            (Ty.path "&")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "p3_matrix::dense::DenseMatrix")
                                                []
                                                [
                                                  F;
                                                  Ty.apply
                                                    (Ty.path "alloc::vec::Vec")
                                                    []
                                                    [ F; Ty.path "alloc::alloc::Global" ]
                                                ]
                                            ],
                                          γ
                                        |) in
                                      M.call_closure (|
                                        Ty.path "usize",
                                        M.get_trait_method (|
                                          "p3_matrix::Matrix",
                                          Ty.apply
                                            (Ty.path "p3_matrix::dense::DenseMatrix")
                                            []
                                            [
                                              F;
                                              Ty.apply
                                                (Ty.path "alloc::vec::Vec")
                                                []
                                                [ F; Ty.path "alloc::alloc::Global" ]
                                            ],
                                          [],
                                          [ F ],
                                          "height",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (| M.read (| trace |) |)
                                          |)
                                        ]
                                      |)))
                                ]
                              |)))
                          | _ => M.impossible "wrong number of arguments"
                          end))
                  ]
                |) in
              M.alloc (|
                Ty.path "usize",
                M.match_operator (|
                  Ty.path "usize",
                  M.alloc (| Ty.tuple [], Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ := height in
                        let γ0_0 :=
                          M.SubPointer.get_struct_tuple_field (|
                            γ,
                            "core::option::Option::Some",
                            0
                          |) in
                        let h := M.copy (| Ty.path "usize", γ0_0 |) in
                        M.read (|
                          let~ _ : Ty.tuple [] :=
                            M.match_operator (|
                              Ty.tuple [],
                              M.alloc (| Ty.tuple [], Value.Tuple [] |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ := common_h in
                                    let γ0_0 :=
                                      M.SubPointer.get_struct_tuple_field (|
                                        γ,
                                        "core::option::Option::Some",
                                        0
                                      |) in
                                    let common_h := M.copy (| Ty.path "usize", γ0_0 |) in
                                    M.read (|
                                      let~ _ : Ty.tuple [] :=
                                        M.match_operator (|
                                          Ty.tuple [],
                                          M.alloc (|
                                            Ty.tuple
                                              [
                                                Ty.apply (Ty.path "&") [] [ Ty.path "usize" ];
                                                Ty.apply (Ty.path "&") [] [ Ty.path "usize" ]
                                              ],
                                            Value.Tuple
                                              [
                                                M.borrow (| Pointer.Kind.Ref, h |);
                                                M.borrow (| Pointer.Kind.Ref, common_h |)
                                              ]
                                          |),
                                          [
                                            fun γ =>
                                              ltac:(M.monadic
                                                (let γ0_0 :=
                                                  M.SubPointer.get_tuple_field (| γ, 0 |) in
                                                let γ0_1 :=
                                                  M.SubPointer.get_tuple_field (| γ, 1 |) in
                                                let left_val :=
                                                  M.copy (|
                                                    Ty.apply (Ty.path "&") [] [ Ty.path "usize" ],
                                                    γ0_0
                                                  |) in
                                                let right_val :=
                                                  M.copy (|
                                                    Ty.apply (Ty.path "&") [] [ Ty.path "usize" ],
                                                    γ0_1
                                                  |) in
                                                M.match_operator (|
                                                  Ty.tuple [],
                                                  M.alloc (| Ty.tuple [], Value.Tuple [] |),
                                                  [
                                                    fun γ =>
                                                      ltac:(M.monadic
                                                        (let γ :=
                                                          M.use
                                                            (M.alloc (|
                                                              Ty.path "bool",
                                                              UnOp.not (|
                                                                M.call_closure (|
                                                                  Ty.path "bool",
                                                                  BinOp.eq,
                                                                  [
                                                                    M.read (|
                                                                      M.deref (|
                                                                        M.read (| left_val |)
                                                                      |)
                                                                    |);
                                                                    M.read (|
                                                                      M.deref (|
                                                                        M.read (| right_val |)
                                                                      |)
                                                                    |)
                                                                  ]
                                                                |)
                                                              |)
                                                            |)) in
                                                        let _ :=
                                                          is_constant_or_break_match (|
                                                            M.read (| γ |),
                                                            Value.Bool true
                                                          |) in
                                                        M.never_to_any (|
                                                          M.read (|
                                                            let~ kind :
                                                                Ty.path
                                                                  "core::panicking::AssertKind" :=
                                                              Value.StructTuple
                                                                "core::panicking::AssertKind::Eq"
                                                                []
                                                                []
                                                                [] in
                                                            M.alloc (|
                                                              Ty.path "never",
                                                              M.call_closure (|
                                                                Ty.path "never",
                                                                M.get_function (|
                                                                  "core::panicking::assert_failed",
                                                                  [],
                                                                  [ Ty.path "usize"; Ty.path "usize"
                                                                  ]
                                                                |),
                                                                [
                                                                  M.read (| kind |);
                                                                  M.borrow (|
                                                                    Pointer.Kind.Ref,
                                                                    M.deref (|
                                                                      M.borrow (|
                                                                        Pointer.Kind.Ref,
                                                                        M.deref (|
                                                                          M.read (| left_val |)
                                                                        |)
                                                                      |)
                                                                    |)
                                                                  |);
                                                                  M.borrow (|
                                                                    Pointer.Kind.Ref,
                                                                    M.deref (|
                                                                      M.borrow (|
                                                                        Pointer.Kind.Ref,
                                                                        M.deref (|
                                                                          M.read (| right_val |)
                                                                        |)
                                                                      |)
                                                                    |)
                                                                  |);
                                                                  Value.StructTuple
                                                                    "core::option::Option::None"
                                                                    []
                                                                    [ Ty.path "core::fmt::Arguments"
                                                                    ]
                                                                    []
                                                                ]
                                                              |)
                                                            |)
                                                          |)
                                                        |)));
                                                    fun γ => ltac:(M.monadic (Value.Tuple []))
                                                  ]
                                                |)))
                                          ]
                                        |) in
                                      M.alloc (| Ty.tuple [], Value.Tuple [] |)
                                    |)));
                                fun γ => ltac:(M.monadic (Value.Tuple []))
                              ]
                            |) in
                          h
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (M.call_closure (|
                          Ty.path "usize",
                          M.get_associated_function (|
                            Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
                            "unwrap_or",
                            [],
                            []
                          |),
                          [ M.read (| common_h |); Value.Integer IntegerKind.Usize 0 ]
                        |)))
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_height :
        forall (F : Ty.t),
        M.IsAssociatedFunction.C (Self F) "height" (height F).
      Admitted.
      Global Typeclasses Opaque height.
    End Impl_openvm_stark_backend_prover_types_AirProofRawInput_F.
  End types.
End prover.
