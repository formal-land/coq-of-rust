(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module sumcheck.
  (* StructRecord
    {
      name := "SumcheckArtifacts";
      const_params := [];
      ty_params := [ "F"; "O" ];
      fields :=
        [
          ("evaluation_point",
            Ty.apply (Ty.path "alloc::vec::Vec") [] [ F; Ty.path "alloc::alloc::Global" ]);
          ("constant_poly_oracles",
            Ty.apply (Ty.path "alloc::vec::Vec") [] [ O; Ty.path "alloc::alloc::Global" ]);
          ("claimed_evals",
            Ty.apply (Ty.path "alloc::vec::Vec") [] [ F; Ty.path "alloc::alloc::Global" ])
        ];
    } *)
  
  (*
  pub fn prove_batch<F: Field, O: MultivariatePolyOracle<F>>(
      mut claims: Vec<F>,
      mut polys: Vec<O>,
      lambda: F,
      challenger: &mut impl FieldChallenger<F>,
  ) -> (SumcheckProof<F>, SumcheckArtifacts<F, O>) {
      let n_variables = polys.iter().map(O::arity).max().unwrap();
      assert_eq!(claims.len(), polys.len());
  
      let mut round_polys = vec![];
      let mut evaluation_point = vec![];
  
      // Update the claims for the sum over `h`'s hypercube.
      for (claim, multivariate_poly) in zip(&mut claims, &polys) {
          let n_unused_variables = n_variables - multivariate_poly.arity();
          *claim *= F::from_canonical_u32(1 << n_unused_variables);
      }
  
      // Prove sum-check rounds
      for round in 0..n_variables {
          let n_remaining_rounds = n_variables - round;
  
          let this_round_polys = zip(&polys, &claims)
              .enumerate()
              .map(|(i, (multivariate_poly, &claim))| {
                  let round_poly = if n_remaining_rounds == multivariate_poly.arity() {
                      multivariate_poly.marginalize_first(claim)
                  } else {
                      claim.halve().into()
                  };
  
                  let eval_at_0 = round_poly.evaluate(F::ZERO);
                  let eval_at_1 = round_poly.evaluate(F::ONE);
  
                  assert_eq!(
                      eval_at_0 + eval_at_1,
                      claim,
                      "Round {round}, poly {i}: eval(0) + eval(1) != claim ({} != {claim})",
                      eval_at_0 + eval_at_1,
                  );
                  assert!(
                      round_poly.degree() <= MAX_DEGREE,
                      "Round {round}, poly {i}: degree {} > max {MAX_DEGREE}",
                      round_poly.degree(),
                  );
  
                  round_poly
              })
              .collect_vec();
  
          let round_poly = random_linear_combination(&this_round_polys, lambda);
  
          challenger.observe_slice(&round_poly);
  
          let challenge = challenger.sample_ext_element();
  
          claims = this_round_polys
              .iter()
              .map(|round_poly| round_poly.evaluate(challenge))
              .collect();
  
          polys = polys
              .into_iter()
              .map(|multivariate_poly| {
                  if n_remaining_rounds != multivariate_poly.arity() {
                      multivariate_poly
                  } else {
                      multivariate_poly.partial_evaluation(challenge)
                  }
              })
              .collect();
  
          round_polys.push(round_poly);
          evaluation_point.push(challenge);
      }
  
      let proof = SumcheckProof { round_polys };
      let artifacts = SumcheckArtifacts {
          evaluation_point,
          constant_poly_oracles: polys,
          claimed_evals: claims,
      };
  
      (proof, artifacts)
  }
  *)
  Definition prove_batch (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ F; _ as O; impl_FieldChallenger_F_ ], [ claims; polys; lambda; challenger ] =>
      ltac:(M.monadic
        (let claims :=
          M.alloc (|
            Ty.apply (Ty.path "alloc::vec::Vec") [] [ F; Ty.path "alloc::alloc::Global" ],
            claims
          |) in
        let polys :=
          M.alloc (|
            Ty.apply (Ty.path "alloc::vec::Vec") [] [ O; Ty.path "alloc::alloc::Global" ],
            polys
          |) in
        let lambda := M.alloc (| F, lambda |) in
        let challenger :=
          M.alloc (| Ty.apply (Ty.path "&mut") [] [ impl_FieldChallenger_F_ ], challenger |) in
        M.read (|
          let~ n_variables : Ty.path "usize" :=
            M.call_closure (|
              Ty.path "usize",
              M.get_associated_function (|
                Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
                "unwrap",
                [],
                []
              |),
              [
                M.call_closure (|
                  Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
                  M.get_trait_method (|
                    "core::iter::traits::iterator::Iterator",
                    Ty.apply
                      (Ty.path "core::iter::adapters::map::Map")
                      []
                      [
                        Ty.apply (Ty.path "core::slice::iter::Iter") [] [ O ];
                        Ty.function [ Ty.apply (Ty.path "&") [] [ O ] ] (Ty.path "usize")
                      ],
                    [],
                    [],
                    "max",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::iter::adapters::map::Map")
                        []
                        [
                          Ty.apply (Ty.path "core::slice::iter::Iter") [] [ O ];
                          Ty.function [ Ty.apply (Ty.path "&") [] [ O ] ] (Ty.path "usize")
                        ],
                      M.get_trait_method (|
                        "core::iter::traits::iterator::Iterator",
                        Ty.apply (Ty.path "core::slice::iter::Iter") [] [ O ],
                        [],
                        [],
                        "map",
                        [],
                        [
                          Ty.path "usize";
                          Ty.function [ Ty.apply (Ty.path "&") [] [ O ] ] (Ty.path "usize")
                        ]
                      |),
                      [
                        M.call_closure (|
                          Ty.apply (Ty.path "core::slice::iter::Iter") [] [ O ],
                          M.get_associated_function (|
                            Ty.apply (Ty.path "slice") [] [ O ],
                            "iter",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.call_closure (|
                                  Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ O ] ],
                                  M.get_trait_method (|
                                    "core::ops::deref::Deref",
                                    Ty.apply
                                      (Ty.path "alloc::vec::Vec")
                                      []
                                      [ O; Ty.path "alloc::alloc::Global" ],
                                    [],
                                    [],
                                    "deref",
                                    [],
                                    []
                                  |),
                                  [ M.borrow (| Pointer.Kind.Ref, polys |) ]
                                |)
                              |)
                            |)
                          ]
                        |);
                        M.get_trait_method (|
                          "openvm_stark_backend::poly::multi::MultivariatePolyOracle",
                          O,
                          [],
                          [ F ],
                          "arity",
                          [],
                          []
                        |)
                      ]
                    |)
                  ]
                |)
              ]
            |) in
          let~ _ : Ty.tuple [] :=
            M.match_operator (|
              Ty.tuple [],
              M.alloc (|
                Ty.tuple
                  [
                    Ty.apply (Ty.path "&") [] [ Ty.path "usize" ];
                    Ty.apply (Ty.path "&") [] [ Ty.path "usize" ]
                  ],
                Value.Tuple
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.alloc (|
                        Ty.path "usize",
                        M.call_closure (|
                          Ty.path "usize",
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              []
                              [ F; Ty.path "alloc::alloc::Global" ],
                            "len",
                            [],
                            []
                          |),
                          [ M.borrow (| Pointer.Kind.Ref, claims |) ]
                        |)
                      |)
                    |);
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.alloc (|
                        Ty.path "usize",
                        M.call_closure (|
                          Ty.path "usize",
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              []
                              [ O; Ty.path "alloc::alloc::Global" ],
                            "len",
                            [],
                            []
                          |),
                          [ M.borrow (| Pointer.Kind.Ref, polys |) ]
                        |)
                      |)
                    |)
                  ]
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let left_val :=
                      M.copy (| Ty.apply (Ty.path "&") [] [ Ty.path "usize" ], γ0_0 |) in
                    let right_val :=
                      M.copy (| Ty.apply (Ty.path "&") [] [ Ty.path "usize" ], γ0_1 |) in
                    M.match_operator (|
                      Ty.tuple [],
                      M.alloc (| Ty.tuple [], Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  Ty.path "bool",
                                  UnOp.not (|
                                    M.call_closure (|
                                      Ty.path "bool",
                                      BinOp.eq,
                                      [
                                        M.read (| M.deref (| M.read (| left_val |) |) |);
                                        M.read (| M.deref (| M.read (| right_val |) |) |)
                                      ]
                                    |)
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.never_to_any (|
                              M.read (|
                                let~ kind : Ty.path "core::panicking::AssertKind" :=
                                  Value.StructTuple "core::panicking::AssertKind::Eq" [] [] [] in
                                M.alloc (|
                                  Ty.path "never",
                                  M.call_closure (|
                                    Ty.path "never",
                                    M.get_function (|
                                      "core::panicking::assert_failed",
                                      [],
                                      [ Ty.path "usize"; Ty.path "usize" ]
                                    |),
                                    [
                                      M.read (| kind |);
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (|
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (| M.read (| left_val |) |)
                                          |)
                                        |)
                                      |);
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (|
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (| M.read (| right_val |) |)
                                          |)
                                        |)
                                      |);
                                      Value.StructTuple
                                        "core::option::Option::None"
                                        []
                                        [ Ty.path "core::fmt::Arguments" ]
                                        []
                                    ]
                                  |)
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (Value.Tuple []))
                      ]
                    |)))
              ]
            |) in
          let~ round_polys :
              Ty.apply
                (Ty.path "alloc::vec::Vec")
                []
                [
                  Ty.apply
                    (Ty.path "openvm_stark_backend::poly::uni::UnivariatePolynomial")
                    []
                    [ F ];
                  Ty.path "alloc::alloc::Global"
                ] :=
            M.call_closure (|
              Ty.apply
                (Ty.path "alloc::vec::Vec")
                []
                [
                  Ty.apply
                    (Ty.path "openvm_stark_backend::poly::uni::UnivariatePolynomial")
                    []
                    [ F ];
                  Ty.path "alloc::alloc::Global"
                ],
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  []
                  [
                    Ty.apply
                      (Ty.path "openvm_stark_backend::poly::uni::UnivariatePolynomial")
                      []
                      [ F ];
                    Ty.path "alloc::alloc::Global"
                  ],
                "new",
                [],
                []
              |),
              []
            |) in
          let~ evaluation_point :
              Ty.apply (Ty.path "alloc::vec::Vec") [] [ F; Ty.path "alloc::alloc::Global" ] :=
            M.call_closure (|
              Ty.apply (Ty.path "alloc::vec::Vec") [] [ F; Ty.path "alloc::alloc::Global" ],
              M.get_associated_function (|
                Ty.apply (Ty.path "alloc::vec::Vec") [] [ F; Ty.path "alloc::alloc::Global" ],
                "new",
                [],
                []
              |),
              []
            |) in
          let~ _ : Ty.tuple [] :=
            M.read (|
              M.use
                (M.alloc (|
                  Ty.tuple [],
                  M.match_operator (|
                    Ty.tuple [],
                    M.alloc (|
                      Ty.apply
                        (Ty.path "core::iter::adapters::zip::Zip")
                        []
                        [
                          Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ F ];
                          Ty.apply (Ty.path "core::slice::iter::Iter") [] [ O ]
                        ],
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::iter::adapters::zip::Zip")
                          []
                          [
                            Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ F ];
                            Ty.apply (Ty.path "core::slice::iter::Iter") [] [ O ]
                          ],
                        M.get_trait_method (|
                          "core::iter::traits::collect::IntoIterator",
                          Ty.apply
                            (Ty.path "core::iter::adapters::zip::Zip")
                            []
                            [
                              Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ F ];
                              Ty.apply (Ty.path "core::slice::iter::Iter") [] [ O ]
                            ],
                          [],
                          [],
                          "into_iter",
                          [],
                          []
                        |),
                        [
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "core::iter::adapters::zip::Zip")
                              []
                              [
                                Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ F ];
                                Ty.apply (Ty.path "core::slice::iter::Iter") [] [ O ]
                              ],
                            M.get_function (|
                              "core::iter::adapters::zip::zip",
                              [],
                              [
                                Ty.apply
                                  (Ty.path "&mut")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "alloc::vec::Vec")
                                      []
                                      [ F; Ty.path "alloc::alloc::Global" ]
                                  ];
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "alloc::vec::Vec")
                                      []
                                      [ O; Ty.path "alloc::alloc::Global" ]
                                  ]
                              ]
                            |),
                            [
                              M.borrow (| Pointer.Kind.MutRef, claims |);
                              M.borrow (| Pointer.Kind.Ref, polys |)
                            ]
                          |)
                        ]
                      |)
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let iter :=
                            M.copy (|
                              Ty.apply
                                (Ty.path "core::iter::adapters::zip::Zip")
                                []
                                [
                                  Ty.apply (Ty.path "core::slice::iter::IterMut") [] [ F ];
                                  Ty.apply (Ty.path "core::slice::iter::Iter") [] [ O ]
                                ],
                              γ
                            |) in
                          M.read (|
                            M.loop (|
                              Ty.tuple [],
                              ltac:(M.monadic
                                (let~ _ : Ty.tuple [] :=
                                  M.match_operator (|
                                    Ty.tuple [],
                                    M.alloc (|
                                      Ty.apply
                                        (Ty.path "core::option::Option")
                                        []
                                        [
                                          Ty.tuple
                                            [
                                              Ty.apply (Ty.path "&mut") [] [ F ];
                                              Ty.apply (Ty.path "&") [] [ O ]
                                            ]
                                        ],
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "core::option::Option")
                                          []
                                          [
                                            Ty.tuple
                                              [
                                                Ty.apply (Ty.path "&mut") [] [ F ];
                                                Ty.apply (Ty.path "&") [] [ O ]
                                              ]
                                          ],
                                        M.get_trait_method (|
                                          "core::iter::traits::iterator::Iterator",
                                          Ty.apply
                                            (Ty.path "core::iter::adapters::zip::Zip")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "core::slice::iter::IterMut")
                                                []
                                                [ F ];
                                              Ty.apply (Ty.path "core::slice::iter::Iter") [] [ O ]
                                            ],
                                          [],
                                          [],
                                          "next",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.MutRef,
                                            M.deref (| M.borrow (| Pointer.Kind.MutRef, iter |) |)
                                          |)
                                        ]
                                      |)
                                    |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let _ :=
                                            M.is_struct_tuple (|
                                              γ,
                                              "core::option::Option::None"
                                            |) in
                                          M.never_to_any (| M.read (| M.break (||) |) |)));
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let γ0_0 :=
                                            M.SubPointer.get_struct_tuple_field (|
                                              γ,
                                              "core::option::Option::Some",
                                              0
                                            |) in
                                          let γ1_0 := M.SubPointer.get_tuple_field (| γ0_0, 0 |) in
                                          let γ1_1 := M.SubPointer.get_tuple_field (| γ0_0, 1 |) in
                                          let claim :=
                                            M.copy (| Ty.apply (Ty.path "&mut") [] [ F ], γ1_0 |) in
                                          let multivariate_poly :=
                                            M.copy (| Ty.apply (Ty.path "&") [] [ O ], γ1_1 |) in
                                          M.read (|
                                            let~ n_unused_variables : Ty.path "usize" :=
                                              M.call_closure (|
                                                Ty.path "usize",
                                                BinOp.Wrap.sub,
                                                [
                                                  M.read (| n_variables |);
                                                  M.call_closure (|
                                                    Ty.path "usize",
                                                    M.get_trait_method (|
                                                      "openvm_stark_backend::poly::multi::MultivariatePolyOracle",
                                                      O,
                                                      [],
                                                      [ F ],
                                                      "arity",
                                                      [],
                                                      []
                                                    |),
                                                    [
                                                      M.borrow (|
                                                        Pointer.Kind.Ref,
                                                        M.deref (| M.read (| multivariate_poly |) |)
                                                      |)
                                                    ]
                                                  |)
                                                ]
                                              |) in
                                            let~ _ : Ty.tuple [] :=
                                              M.call_closure (|
                                                Ty.tuple [],
                                                M.get_trait_method (|
                                                  "core::ops::arith::MulAssign",
                                                  F,
                                                  [],
                                                  [ F ],
                                                  "mul_assign",
                                                  [],
                                                  []
                                                |),
                                                [
                                                  M.borrow (|
                                                    Pointer.Kind.MutRef,
                                                    M.deref (| M.read (| claim |) |)
                                                  |);
                                                  M.call_closure (|
                                                    F,
                                                    M.get_trait_method (|
                                                      "p3_field::field::FieldAlgebra",
                                                      F,
                                                      [],
                                                      [],
                                                      "from_canonical_u32",
                                                      [],
                                                      []
                                                    |),
                                                    [
                                                      M.call_closure (|
                                                        Ty.path "u32",
                                                        BinOp.Wrap.shl,
                                                        [
                                                          Value.Integer IntegerKind.U32 1;
                                                          M.read (| n_unused_variables |)
                                                        ]
                                                      |)
                                                    ]
                                                  |)
                                                ]
                                              |) in
                                            M.alloc (| Ty.tuple [], Value.Tuple [] |)
                                          |)))
                                    ]
                                  |) in
                                M.alloc (| Ty.tuple [], Value.Tuple [] |)))
                            |)
                          |)))
                    ]
                  |)
                |))
            |) in
          let~ _ : Ty.tuple [] :=
            M.read (|
              M.use
                (M.alloc (|
                  Ty.tuple [],
                  M.match_operator (|
                    Ty.tuple [],
                    M.alloc (|
                      Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                      M.call_closure (|
                        Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                        M.get_trait_method (|
                          "core::iter::traits::collect::IntoIterator",
                          Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                          [],
                          [],
                          "into_iter",
                          [],
                          []
                        |),
                        [
                          Value.mkStructRecord
                            "core::ops::range::Range"
                            []
                            [ Ty.path "usize" ]
                            [
                              ("start", Value.Integer IntegerKind.Usize 0);
                              ("end_", M.read (| n_variables |))
                            ]
                        ]
                      |)
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let iter :=
                            M.copy (|
                              Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                              γ
                            |) in
                          M.read (|
                            M.loop (|
                              Ty.tuple [],
                              ltac:(M.monadic
                                (let~ _ : Ty.tuple [] :=
                                  M.match_operator (|
                                    Ty.tuple [],
                                    M.alloc (|
                                      Ty.apply
                                        (Ty.path "core::option::Option")
                                        []
                                        [ Ty.path "usize" ],
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "core::option::Option")
                                          []
                                          [ Ty.path "usize" ],
                                        M.get_trait_method (|
                                          "core::iter::traits::iterator::Iterator",
                                          Ty.apply
                                            (Ty.path "core::ops::range::Range")
                                            []
                                            [ Ty.path "usize" ],
                                          [],
                                          [],
                                          "next",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.MutRef,
                                            M.deref (| M.borrow (| Pointer.Kind.MutRef, iter |) |)
                                          |)
                                        ]
                                      |)
                                    |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let _ :=
                                            M.is_struct_tuple (|
                                              γ,
                                              "core::option::Option::None"
                                            |) in
                                          M.never_to_any (| M.read (| M.break (||) |) |)));
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let γ0_0 :=
                                            M.SubPointer.get_struct_tuple_field (|
                                              γ,
                                              "core::option::Option::Some",
                                              0
                                            |) in
                                          let round := M.copy (| Ty.path "usize", γ0_0 |) in
                                          M.read (|
                                            let~ n_remaining_rounds : Ty.path "usize" :=
                                              M.call_closure (|
                                                Ty.path "usize",
                                                BinOp.Wrap.sub,
                                                [ M.read (| n_variables |); M.read (| round |) ]
                                              |) in
                                            let~ this_round_polys :
                                                Ty.apply
                                                  (Ty.path "alloc::vec::Vec")
                                                  []
                                                  [
                                                    Ty.apply
                                                      (Ty.path
                                                        "openvm_stark_backend::poly::uni::UnivariatePolynomial")
                                                      []
                                                      [ F ];
                                                    Ty.path "alloc::alloc::Global"
                                                  ] :=
                                              M.call_closure (|
                                                Ty.apply
                                                  (Ty.path "alloc::vec::Vec")
                                                  []
                                                  [
                                                    Ty.apply
                                                      (Ty.path
                                                        "openvm_stark_backend::poly::uni::UnivariatePolynomial")
                                                      []
                                                      [ F ];
                                                    Ty.path "alloc::alloc::Global"
                                                  ],
                                                M.get_trait_method (|
                                                  "itertools::Itertools",
                                                  Ty.apply
                                                    (Ty.path "core::iter::adapters::map::Map")
                                                    []
                                                    [
                                                      Ty.apply
                                                        (Ty.path
                                                          "core::iter::adapters::enumerate::Enumerate")
                                                        []
                                                        [
                                                          Ty.apply
                                                            (Ty.path
                                                              "core::iter::adapters::zip::Zip")
                                                            []
                                                            [
                                                              Ty.apply
                                                                (Ty.path "core::slice::iter::Iter")
                                                                []
                                                                [ O ];
                                                              Ty.apply
                                                                (Ty.path "core::slice::iter::Iter")
                                                                []
                                                                [ F ]
                                                            ]
                                                        ];
                                                      Ty.function
                                                        [
                                                          Ty.tuple
                                                            [
                                                              Ty.path "usize";
                                                              Ty.tuple
                                                                [
                                                                  Ty.apply (Ty.path "&") [] [ O ];
                                                                  Ty.apply (Ty.path "&") [] [ F ]
                                                                ]
                                                            ]
                                                        ]
                                                        (Ty.apply
                                                          (Ty.path
                                                            "openvm_stark_backend::poly::uni::UnivariatePolynomial")
                                                          []
                                                          [ F ])
                                                    ],
                                                  [],
                                                  [],
                                                  "collect_vec",
                                                  [],
                                                  []
                                                |),
                                                [
                                                  M.call_closure (|
                                                    Ty.apply
                                                      (Ty.path "core::iter::adapters::map::Map")
                                                      []
                                                      [
                                                        Ty.apply
                                                          (Ty.path
                                                            "core::iter::adapters::enumerate::Enumerate")
                                                          []
                                                          [
                                                            Ty.apply
                                                              (Ty.path
                                                                "core::iter::adapters::zip::Zip")
                                                              []
                                                              [
                                                                Ty.apply
                                                                  (Ty.path
                                                                    "core::slice::iter::Iter")
                                                                  []
                                                                  [ O ];
                                                                Ty.apply
                                                                  (Ty.path
                                                                    "core::slice::iter::Iter")
                                                                  []
                                                                  [ F ]
                                                              ]
                                                          ];
                                                        Ty.function
                                                          [
                                                            Ty.tuple
                                                              [
                                                                Ty.path "usize";
                                                                Ty.tuple
                                                                  [
                                                                    Ty.apply (Ty.path "&") [] [ O ];
                                                                    Ty.apply (Ty.path "&") [] [ F ]
                                                                  ]
                                                              ]
                                                          ]
                                                          (Ty.apply
                                                            (Ty.path
                                                              "openvm_stark_backend::poly::uni::UnivariatePolynomial")
                                                            []
                                                            [ F ])
                                                      ],
                                                    M.get_trait_method (|
                                                      "core::iter::traits::iterator::Iterator",
                                                      Ty.apply
                                                        (Ty.path
                                                          "core::iter::adapters::enumerate::Enumerate")
                                                        []
                                                        [
                                                          Ty.apply
                                                            (Ty.path
                                                              "core::iter::adapters::zip::Zip")
                                                            []
                                                            [
                                                              Ty.apply
                                                                (Ty.path "core::slice::iter::Iter")
                                                                []
                                                                [ O ];
                                                              Ty.apply
                                                                (Ty.path "core::slice::iter::Iter")
                                                                []
                                                                [ F ]
                                                            ]
                                                        ],
                                                      [],
                                                      [],
                                                      "map",
                                                      [],
                                                      [
                                                        Ty.apply
                                                          (Ty.path
                                                            "openvm_stark_backend::poly::uni::UnivariatePolynomial")
                                                          []
                                                          [ F ];
                                                        Ty.function
                                                          [
                                                            Ty.tuple
                                                              [
                                                                Ty.path "usize";
                                                                Ty.tuple
                                                                  [
                                                                    Ty.apply (Ty.path "&") [] [ O ];
                                                                    Ty.apply (Ty.path "&") [] [ F ]
                                                                  ]
                                                              ]
                                                          ]
                                                          (Ty.apply
                                                            (Ty.path
                                                              "openvm_stark_backend::poly::uni::UnivariatePolynomial")
                                                            []
                                                            [ F ])
                                                      ]
                                                    |),
                                                    [
                                                      M.call_closure (|
                                                        Ty.apply
                                                          (Ty.path
                                                            "core::iter::adapters::enumerate::Enumerate")
                                                          []
                                                          [
                                                            Ty.apply
                                                              (Ty.path
                                                                "core::iter::adapters::zip::Zip")
                                                              []
                                                              [
                                                                Ty.apply
                                                                  (Ty.path
                                                                    "core::slice::iter::Iter")
                                                                  []
                                                                  [ O ];
                                                                Ty.apply
                                                                  (Ty.path
                                                                    "core::slice::iter::Iter")
                                                                  []
                                                                  [ F ]
                                                              ]
                                                          ],
                                                        M.get_trait_method (|
                                                          "core::iter::traits::iterator::Iterator",
                                                          Ty.apply
                                                            (Ty.path
                                                              "core::iter::adapters::zip::Zip")
                                                            []
                                                            [
                                                              Ty.apply
                                                                (Ty.path "core::slice::iter::Iter")
                                                                []
                                                                [ O ];
                                                              Ty.apply
                                                                (Ty.path "core::slice::iter::Iter")
                                                                []
                                                                [ F ]
                                                            ],
                                                          [],
                                                          [],
                                                          "enumerate",
                                                          [],
                                                          []
                                                        |),
                                                        [
                                                          M.call_closure (|
                                                            Ty.apply
                                                              (Ty.path
                                                                "core::iter::adapters::zip::Zip")
                                                              []
                                                              [
                                                                Ty.apply
                                                                  (Ty.path
                                                                    "core::slice::iter::Iter")
                                                                  []
                                                                  [ O ];
                                                                Ty.apply
                                                                  (Ty.path
                                                                    "core::slice::iter::Iter")
                                                                  []
                                                                  [ F ]
                                                              ],
                                                            M.get_function (|
                                                              "core::iter::adapters::zip::zip",
                                                              [],
                                                              [
                                                                Ty.apply
                                                                  (Ty.path "&")
                                                                  []
                                                                  [
                                                                    Ty.apply
                                                                      (Ty.path "alloc::vec::Vec")
                                                                      []
                                                                      [
                                                                        O;
                                                                        Ty.path
                                                                          "alloc::alloc::Global"
                                                                      ]
                                                                  ];
                                                                Ty.apply
                                                                  (Ty.path "&")
                                                                  []
                                                                  [
                                                                    Ty.apply
                                                                      (Ty.path "alloc::vec::Vec")
                                                                      []
                                                                      [
                                                                        F;
                                                                        Ty.path
                                                                          "alloc::alloc::Global"
                                                                      ]
                                                                  ]
                                                              ]
                                                            |),
                                                            [
                                                              M.borrow (|
                                                                Pointer.Kind.Ref,
                                                                polys
                                                              |);
                                                              M.borrow (|
                                                                Pointer.Kind.Ref,
                                                                claims
                                                              |)
                                                            ]
                                                          |)
                                                        ]
                                                      |);
                                                      M.closure
                                                        (fun γ =>
                                                          ltac:(M.monadic
                                                            match γ with
                                                            | [ α0 ] =>
                                                              ltac:(M.monadic
                                                                (M.match_operator (|
                                                                  Ty.apply
                                                                    (Ty.path
                                                                      "openvm_stark_backend::poly::uni::UnivariatePolynomial")
                                                                    []
                                                                    [ F ],
                                                                  M.alloc (|
                                                                    Ty.tuple
                                                                      [
                                                                        Ty.path "usize";
                                                                        Ty.tuple
                                                                          [
                                                                            Ty.apply
                                                                              (Ty.path "&")
                                                                              []
                                                                              [ O ];
                                                                            Ty.apply
                                                                              (Ty.path "&")
                                                                              []
                                                                              [ F ]
                                                                          ]
                                                                      ],
                                                                    α0
                                                                  |),
                                                                  [
                                                                    fun γ =>
                                                                      ltac:(M.monadic
                                                                        (let γ0_0 :=
                                                                          M.SubPointer.get_tuple_field (|
                                                                            γ,
                                                                            0
                                                                          |) in
                                                                        let γ0_1 :=
                                                                          M.SubPointer.get_tuple_field (|
                                                                            γ,
                                                                            1
                                                                          |) in
                                                                        let i :=
                                                                          M.copy (|
                                                                            Ty.path "usize",
                                                                            γ0_0
                                                                          |) in
                                                                        let γ1_0 :=
                                                                          M.SubPointer.get_tuple_field (|
                                                                            γ0_1,
                                                                            0
                                                                          |) in
                                                                        let γ1_1 :=
                                                                          M.SubPointer.get_tuple_field (|
                                                                            γ0_1,
                                                                            1
                                                                          |) in
                                                                        let multivariate_poly :=
                                                                          M.copy (|
                                                                            Ty.apply
                                                                              (Ty.path "&")
                                                                              []
                                                                              [ O ],
                                                                            γ1_0
                                                                          |) in
                                                                        let γ1_1 :=
                                                                          M.deref (|
                                                                            M.read (| γ1_1 |)
                                                                          |) in
                                                                        let claim :=
                                                                          M.copy (| F, γ1_1 |) in
                                                                        M.read (|
                                                                          let~ round_poly :
                                                                              Ty.apply
                                                                                (Ty.path
                                                                                  "openvm_stark_backend::poly::uni::UnivariatePolynomial")
                                                                                []
                                                                                [ F ] :=
                                                                            M.match_operator (|
                                                                              Ty.apply
                                                                                (Ty.path
                                                                                  "openvm_stark_backend::poly::uni::UnivariatePolynomial")
                                                                                []
                                                                                [ F ],
                                                                              M.alloc (|
                                                                                Ty.tuple [],
                                                                                Value.Tuple []
                                                                              |),
                                                                              [
                                                                                fun γ =>
                                                                                  ltac:(M.monadic
                                                                                    (let γ :=
                                                                                      M.use
                                                                                        (M.alloc (|
                                                                                          Ty.path
                                                                                            "bool",
                                                                                          M.call_closure (|
                                                                                            Ty.path
                                                                                              "bool",
                                                                                            BinOp.eq,
                                                                                            [
                                                                                              M.read (|
                                                                                                n_remaining_rounds
                                                                                              |);
                                                                                              M.call_closure (|
                                                                                                Ty.path
                                                                                                  "usize",
                                                                                                M.get_trait_method (|
                                                                                                  "openvm_stark_backend::poly::multi::MultivariatePolyOracle",
                                                                                                  O,
                                                                                                  [],
                                                                                                  [
                                                                                                    F
                                                                                                  ],
                                                                                                  "arity",
                                                                                                  [],
                                                                                                  []
                                                                                                |),
                                                                                                [
                                                                                                  M.borrow (|
                                                                                                    Pointer.Kind.Ref,
                                                                                                    M.deref (|
                                                                                                      M.read (|
                                                                                                        multivariate_poly
                                                                                                      |)
                                                                                                    |)
                                                                                                  |)
                                                                                                ]
                                                                                              |)
                                                                                            ]
                                                                                          |)
                                                                                        |)) in
                                                                                    let _ :=
                                                                                      is_constant_or_break_match (|
                                                                                        M.read (|
                                                                                          γ
                                                                                        |),
                                                                                        Value.Bool
                                                                                          true
                                                                                      |) in
                                                                                    M.call_closure (|
                                                                                      Ty.apply
                                                                                        (Ty.path
                                                                                          "openvm_stark_backend::poly::uni::UnivariatePolynomial")
                                                                                        []
                                                                                        [ F ],
                                                                                      M.get_trait_method (|
                                                                                        "openvm_stark_backend::poly::multi::MultivariatePolyOracle",
                                                                                        O,
                                                                                        [],
                                                                                        [ F ],
                                                                                        "marginalize_first",
                                                                                        [],
                                                                                        []
                                                                                      |),
                                                                                      [
                                                                                        M.borrow (|
                                                                                          Pointer.Kind.Ref,
                                                                                          M.deref (|
                                                                                            M.read (|
                                                                                              multivariate_poly
                                                                                            |)
                                                                                          |)
                                                                                        |);
                                                                                        M.read (|
                                                                                          claim
                                                                                        |)
                                                                                      ]
                                                                                    |)));
                                                                                fun γ =>
                                                                                  ltac:(M.monadic
                                                                                    (M.call_closure (|
                                                                                      Ty.apply
                                                                                        (Ty.path
                                                                                          "openvm_stark_backend::poly::uni::UnivariatePolynomial")
                                                                                        []
                                                                                        [ F ],
                                                                                      M.get_trait_method (|
                                                                                        "core::convert::Into",
                                                                                        F,
                                                                                        [],
                                                                                        [
                                                                                          Ty.apply
                                                                                            (Ty.path
                                                                                              "openvm_stark_backend::poly::uni::UnivariatePolynomial")
                                                                                            []
                                                                                            [ F ]
                                                                                        ],
                                                                                        "into",
                                                                                        [],
                                                                                        []
                                                                                      |),
                                                                                      [
                                                                                        M.call_closure (|
                                                                                          F,
                                                                                          M.get_trait_method (|
                                                                                            "p3_field::field::Field",
                                                                                            F,
                                                                                            [],
                                                                                            [],
                                                                                            "halve",
                                                                                            [],
                                                                                            []
                                                                                          |),
                                                                                          [
                                                                                            M.borrow (|
                                                                                              Pointer.Kind.Ref,
                                                                                              claim
                                                                                            |)
                                                                                          ]
                                                                                        |)
                                                                                      ]
                                                                                    |)))
                                                                              ]
                                                                            |) in
                                                                          let~ eval_at_0 : F :=
                                                                            M.call_closure (|
                                                                              F,
                                                                              M.get_associated_function (|
                                                                                Ty.apply
                                                                                  (Ty.path
                                                                                    "openvm_stark_backend::poly::uni::UnivariatePolynomial")
                                                                                  []
                                                                                  [ F ],
                                                                                "evaluate",
                                                                                [],
                                                                                []
                                                                              |),
                                                                              [
                                                                                M.borrow (|
                                                                                  Pointer.Kind.Ref,
                                                                                  round_poly
                                                                                |);
                                                                                M.read (|
                                                                                  get_constant (|
                                                                                    "p3_field::field::FieldAlgebra::ZERO",
                                                                                    F
                                                                                  |)
                                                                                |)
                                                                              ]
                                                                            |) in
                                                                          let~ eval_at_1 : F :=
                                                                            M.call_closure (|
                                                                              F,
                                                                              M.get_associated_function (|
                                                                                Ty.apply
                                                                                  (Ty.path
                                                                                    "openvm_stark_backend::poly::uni::UnivariatePolynomial")
                                                                                  []
                                                                                  [ F ],
                                                                                "evaluate",
                                                                                [],
                                                                                []
                                                                              |),
                                                                              [
                                                                                M.borrow (|
                                                                                  Pointer.Kind.Ref,
                                                                                  round_poly
                                                                                |);
                                                                                M.read (|
                                                                                  get_constant (|
                                                                                    "p3_field::field::FieldAlgebra::ONE",
                                                                                    F
                                                                                  |)
                                                                                |)
                                                                              ]
                                                                            |) in
                                                                          let~ _ : Ty.tuple [] :=
                                                                            M.match_operator (|
                                                                              Ty.tuple [],
                                                                              M.alloc (|
                                                                                Ty.tuple
                                                                                  [
                                                                                    Ty.apply
                                                                                      (Ty.path "&")
                                                                                      []
                                                                                      [ F ];
                                                                                    Ty.apply
                                                                                      (Ty.path "&")
                                                                                      []
                                                                                      [ F ]
                                                                                  ],
                                                                                Value.Tuple
                                                                                  [
                                                                                    M.borrow (|
                                                                                      Pointer.Kind.Ref,
                                                                                      M.alloc (|
                                                                                        F,
                                                                                        M.call_closure (|
                                                                                          F,
                                                                                          M.get_trait_method (|
                                                                                            "core::ops::arith::Add",
                                                                                            F,
                                                                                            [],
                                                                                            [ F ],
                                                                                            "add",
                                                                                            [],
                                                                                            []
                                                                                          |),
                                                                                          [
                                                                                            M.read (|
                                                                                              eval_at_0
                                                                                            |);
                                                                                            M.read (|
                                                                                              eval_at_1
                                                                                            |)
                                                                                          ]
                                                                                        |)
                                                                                      |)
                                                                                    |);
                                                                                    M.borrow (|
                                                                                      Pointer.Kind.Ref,
                                                                                      claim
                                                                                    |)
                                                                                  ]
                                                                              |),
                                                                              [
                                                                                fun γ =>
                                                                                  ltac:(M.monadic
                                                                                    (let γ0_0 :=
                                                                                      M.SubPointer.get_tuple_field (|
                                                                                        γ,
                                                                                        0
                                                                                      |) in
                                                                                    let γ0_1 :=
                                                                                      M.SubPointer.get_tuple_field (|
                                                                                        γ,
                                                                                        1
                                                                                      |) in
                                                                                    let left_val :=
                                                                                      M.copy (|
                                                                                        Ty.apply
                                                                                          (Ty.path
                                                                                            "&")
                                                                                          []
                                                                                          [ F ],
                                                                                        γ0_0
                                                                                      |) in
                                                                                    let right_val :=
                                                                                      M.copy (|
                                                                                        Ty.apply
                                                                                          (Ty.path
                                                                                            "&")
                                                                                          []
                                                                                          [ F ],
                                                                                        γ0_1
                                                                                      |) in
                                                                                    M.match_operator (|
                                                                                      Ty.tuple [],
                                                                                      M.alloc (|
                                                                                        Ty.tuple [],
                                                                                        Value.Tuple
                                                                                          []
                                                                                      |),
                                                                                      [
                                                                                        fun γ =>
                                                                                          ltac:(M.monadic
                                                                                            (let
                                                                                                  γ :=
                                                                                              M.use
                                                                                                (M.alloc (|
                                                                                                  Ty.path
                                                                                                    "bool",
                                                                                                  UnOp.not (|
                                                                                                    M.call_closure (|
                                                                                                      Ty.path
                                                                                                        "bool",
                                                                                                      M.get_trait_method (|
                                                                                                        "core::cmp::PartialEq",
                                                                                                        F,
                                                                                                        [],
                                                                                                        [
                                                                                                          F
                                                                                                        ],
                                                                                                        "eq",
                                                                                                        [],
                                                                                                        []
                                                                                                      |),
                                                                                                      [
                                                                                                        M.borrow (|
                                                                                                          Pointer.Kind.Ref,
                                                                                                          M.deref (|
                                                                                                            M.read (|
                                                                                                              left_val
                                                                                                            |)
                                                                                                          |)
                                                                                                        |);
                                                                                                        M.borrow (|
                                                                                                          Pointer.Kind.Ref,
                                                                                                          M.deref (|
                                                                                                            M.read (|
                                                                                                              right_val
                                                                                                            |)
                                                                                                          |)
                                                                                                        |)
                                                                                                      ]
                                                                                                    |)
                                                                                                  |)
                                                                                                |)) in
                                                                                            let _ :=
                                                                                              is_constant_or_break_match (|
                                                                                                M.read (|
                                                                                                  γ
                                                                                                |),
                                                                                                Value.Bool
                                                                                                  true
                                                                                              |) in
                                                                                            M.never_to_any (|
                                                                                              M.read (|
                                                                                                let~
                                                                                                      kind :
                                                                                                    Ty.path
                                                                                                      "core::panicking::AssertKind" :=
                                                                                                  Value.StructTuple
                                                                                                    "core::panicking::AssertKind::Eq"
                                                                                                    []
                                                                                                    []
                                                                                                    [] in
                                                                                                M.alloc (|
                                                                                                  Ty.path
                                                                                                    "never",
                                                                                                  M.call_closure (|
                                                                                                    Ty.path
                                                                                                      "never",
                                                                                                    M.get_function (|
                                                                                                      "core::panicking::assert_failed",
                                                                                                      [],
                                                                                                      [
                                                                                                        F;
                                                                                                        F
                                                                                                      ]
                                                                                                    |),
                                                                                                    [
                                                                                                      M.read (|
                                                                                                        kind
                                                                                                      |);
                                                                                                      M.borrow (|
                                                                                                        Pointer.Kind.Ref,
                                                                                                        M.deref (|
                                                                                                          M.borrow (|
                                                                                                            Pointer.Kind.Ref,
                                                                                                            M.deref (|
                                                                                                              M.read (|
                                                                                                                left_val
                                                                                                              |)
                                                                                                            |)
                                                                                                          |)
                                                                                                        |)
                                                                                                      |);
                                                                                                      M.borrow (|
                                                                                                        Pointer.Kind.Ref,
                                                                                                        M.deref (|
                                                                                                          M.borrow (|
                                                                                                            Pointer.Kind.Ref,
                                                                                                            M.deref (|
                                                                                                              M.read (|
                                                                                                                right_val
                                                                                                              |)
                                                                                                            |)
                                                                                                          |)
                                                                                                        |)
                                                                                                      |);
                                                                                                      Value.StructTuple
                                                                                                        "core::option::Option::Some"
                                                                                                        []
                                                                                                        [
                                                                                                          Ty.path
                                                                                                            "core::fmt::Arguments"
                                                                                                        ]
                                                                                                        [
                                                                                                          M.call_closure (|
                                                                                                            Ty.path
                                                                                                              "core::fmt::Arguments",
                                                                                                            M.get_associated_function (|
                                                                                                              Ty.path
                                                                                                                "core::fmt::Arguments",
                                                                                                              "new_v1",
                                                                                                              [
                                                                                                                Value.Integer
                                                                                                                  IntegerKind.Usize
                                                                                                                  5;
                                                                                                                Value.Integer
                                                                                                                  IntegerKind.Usize
                                                                                                                  4
                                                                                                              ],
                                                                                                              []
                                                                                                            |),
                                                                                                            [
                                                                                                              M.borrow (|
                                                                                                                Pointer.Kind.Ref,
                                                                                                                M.deref (|
                                                                                                                  M.borrow (|
                                                                                                                    Pointer.Kind.Ref,
                                                                                                                    M.alloc (|
                                                                                                                      Ty.apply
                                                                                                                        (Ty.path
                                                                                                                          "array")
                                                                                                                        [
                                                                                                                          Value.Integer
                                                                                                                            IntegerKind.Usize
                                                                                                                            5
                                                                                                                        ]
                                                                                                                        [
                                                                                                                          Ty.apply
                                                                                                                            (Ty.path
                                                                                                                              "&")
                                                                                                                            []
                                                                                                                            [
                                                                                                                              Ty.path
                                                                                                                                "str"
                                                                                                                            ]
                                                                                                                        ],
                                                                                                                      Value.Array
                                                                                                                        [
                                                                                                                          mk_str (|
                                                                                                                            "Round "
                                                                                                                          |);
                                                                                                                          mk_str (|
                                                                                                                            ", poly "
                                                                                                                          |);
                                                                                                                          mk_str (|
                                                                                                                            ": eval(0) + eval(1) != claim ("
                                                                                                                          |);
                                                                                                                          mk_str (|
                                                                                                                            " != "
                                                                                                                          |);
                                                                                                                          mk_str (|
                                                                                                                            ")"
                                                                                                                          |)
                                                                                                                        ]
                                                                                                                    |)
                                                                                                                  |)
                                                                                                                |)
                                                                                                              |);
                                                                                                              M.borrow (|
                                                                                                                Pointer.Kind.Ref,
                                                                                                                M.deref (|
                                                                                                                  M.borrow (|
                                                                                                                    Pointer.Kind.Ref,
                                                                                                                    M.alloc (|
                                                                                                                      Ty.apply
                                                                                                                        (Ty.path
                                                                                                                          "array")
                                                                                                                        [
                                                                                                                          Value.Integer
                                                                                                                            IntegerKind.Usize
                                                                                                                            4
                                                                                                                        ]
                                                                                                                        [
                                                                                                                          Ty.path
                                                                                                                            "core::fmt::rt::Argument"
                                                                                                                        ],
                                                                                                                      M.match_operator (|
                                                                                                                        Ty.apply
                                                                                                                          (Ty.path
                                                                                                                            "array")
                                                                                                                          [
                                                                                                                            Value.Integer
                                                                                                                              IntegerKind.Usize
                                                                                                                              4
                                                                                                                          ]
                                                                                                                          [
                                                                                                                            Ty.path
                                                                                                                              "core::fmt::rt::Argument"
                                                                                                                          ],
                                                                                                                        M.alloc (|
                                                                                                                          Ty.tuple
                                                                                                                            [
                                                                                                                              Ty.apply
                                                                                                                                (Ty.path
                                                                                                                                  "&")
                                                                                                                                []
                                                                                                                                [
                                                                                                                                  F
                                                                                                                                ];
                                                                                                                              Ty.apply
                                                                                                                                (Ty.path
                                                                                                                                  "&")
                                                                                                                                []
                                                                                                                                [
                                                                                                                                  Ty.path
                                                                                                                                    "usize"
                                                                                                                                ];
                                                                                                                              Ty.apply
                                                                                                                                (Ty.path
                                                                                                                                  "&")
                                                                                                                                []
                                                                                                                                [
                                                                                                                                  Ty.path
                                                                                                                                    "usize"
                                                                                                                                ];
                                                                                                                              Ty.apply
                                                                                                                                (Ty.path
                                                                                                                                  "&")
                                                                                                                                []
                                                                                                                                [
                                                                                                                                  F
                                                                                                                                ]
                                                                                                                            ],
                                                                                                                          Value.Tuple
                                                                                                                            [
                                                                                                                              M.borrow (|
                                                                                                                                Pointer.Kind.Ref,
                                                                                                                                M.alloc (|
                                                                                                                                  F,
                                                                                                                                  M.call_closure (|
                                                                                                                                    F,
                                                                                                                                    M.get_trait_method (|
                                                                                                                                      "core::ops::arith::Add",
                                                                                                                                      F,
                                                                                                                                      [],
                                                                                                                                      [
                                                                                                                                        F
                                                                                                                                      ],
                                                                                                                                      "add",
                                                                                                                                      [],
                                                                                                                                      []
                                                                                                                                    |),
                                                                                                                                    [
                                                                                                                                      M.read (|
                                                                                                                                        eval_at_0
                                                                                                                                      |);
                                                                                                                                      M.read (|
                                                                                                                                        eval_at_1
                                                                                                                                      |)
                                                                                                                                    ]
                                                                                                                                  |)
                                                                                                                                |)
                                                                                                                              |);
                                                                                                                              M.borrow (|
                                                                                                                                Pointer.Kind.Ref,
                                                                                                                                round
                                                                                                                              |);
                                                                                                                              M.borrow (|
                                                                                                                                Pointer.Kind.Ref,
                                                                                                                                i
                                                                                                                              |);
                                                                                                                              M.borrow (|
                                                                                                                                Pointer.Kind.Ref,
                                                                                                                                claim
                                                                                                                              |)
                                                                                                                            ]
                                                                                                                        |),
                                                                                                                        [
                                                                                                                          fun
                                                                                                                              γ =>
                                                                                                                            ltac:(M.monadic
                                                                                                                              (let
                                                                                                                                    args :=
                                                                                                                                M.copy (|
                                                                                                                                  Ty.tuple
                                                                                                                                    [
                                                                                                                                      Ty.apply
                                                                                                                                        (Ty.path
                                                                                                                                          "&")
                                                                                                                                        []
                                                                                                                                        [
                                                                                                                                          F
                                                                                                                                        ];
                                                                                                                                      Ty.apply
                                                                                                                                        (Ty.path
                                                                                                                                          "&")
                                                                                                                                        []
                                                                                                                                        [
                                                                                                                                          Ty.path
                                                                                                                                            "usize"
                                                                                                                                        ];
                                                                                                                                      Ty.apply
                                                                                                                                        (Ty.path
                                                                                                                                          "&")
                                                                                                                                        []
                                                                                                                                        [
                                                                                                                                          Ty.path
                                                                                                                                            "usize"
                                                                                                                                        ];
                                                                                                                                      Ty.apply
                                                                                                                                        (Ty.path
                                                                                                                                          "&")
                                                                                                                                        []
                                                                                                                                        [
                                                                                                                                          F
                                                                                                                                        ]
                                                                                                                                    ],
                                                                                                                                  γ
                                                                                                                                |) in
                                                                                                                              Value.Array
                                                                                                                                [
                                                                                                                                  M.call_closure (|
                                                                                                                                    Ty.path
                                                                                                                                      "core::fmt::rt::Argument",
                                                                                                                                    M.get_associated_function (|
                                                                                                                                      Ty.path
                                                                                                                                        "core::fmt::rt::Argument",
                                                                                                                                      "new_display",
                                                                                                                                      [],
                                                                                                                                      [
                                                                                                                                        Ty.path
                                                                                                                                          "usize"
                                                                                                                                      ]
                                                                                                                                    |),
                                                                                                                                    [
                                                                                                                                      M.borrow (|
                                                                                                                                        Pointer.Kind.Ref,
                                                                                                                                        M.deref (|
                                                                                                                                          M.read (|
                                                                                                                                            M.SubPointer.get_tuple_field (|
                                                                                                                                              args,
                                                                                                                                              1
                                                                                                                                            |)
                                                                                                                                          |)
                                                                                                                                        |)
                                                                                                                                      |)
                                                                                                                                    ]
                                                                                                                                  |);
                                                                                                                                  M.call_closure (|
                                                                                                                                    Ty.path
                                                                                                                                      "core::fmt::rt::Argument",
                                                                                                                                    M.get_associated_function (|
                                                                                                                                      Ty.path
                                                                                                                                        "core::fmt::rt::Argument",
                                                                                                                                      "new_display",
                                                                                                                                      [],
                                                                                                                                      [
                                                                                                                                        Ty.path
                                                                                                                                          "usize"
                                                                                                                                      ]
                                                                                                                                    |),
                                                                                                                                    [
                                                                                                                                      M.borrow (|
                                                                                                                                        Pointer.Kind.Ref,
                                                                                                                                        M.deref (|
                                                                                                                                          M.read (|
                                                                                                                                            M.SubPointer.get_tuple_field (|
                                                                                                                                              args,
                                                                                                                                              2
                                                                                                                                            |)
                                                                                                                                          |)
                                                                                                                                        |)
                                                                                                                                      |)
                                                                                                                                    ]
                                                                                                                                  |);
                                                                                                                                  M.call_closure (|
                                                                                                                                    Ty.path
                                                                                                                                      "core::fmt::rt::Argument",
                                                                                                                                    M.get_associated_function (|
                                                                                                                                      Ty.path
                                                                                                                                        "core::fmt::rt::Argument",
                                                                                                                                      "new_display",
                                                                                                                                      [],
                                                                                                                                      [
                                                                                                                                        F
                                                                                                                                      ]
                                                                                                                                    |),
                                                                                                                                    [
                                                                                                                                      M.borrow (|
                                                                                                                                        Pointer.Kind.Ref,
                                                                                                                                        M.deref (|
                                                                                                                                          M.read (|
                                                                                                                                            M.SubPointer.get_tuple_field (|
                                                                                                                                              args,
                                                                                                                                              0
                                                                                                                                            |)
                                                                                                                                          |)
                                                                                                                                        |)
                                                                                                                                      |)
                                                                                                                                    ]
                                                                                                                                  |);
                                                                                                                                  M.call_closure (|
                                                                                                                                    Ty.path
                                                                                                                                      "core::fmt::rt::Argument",
                                                                                                                                    M.get_associated_function (|
                                                                                                                                      Ty.path
                                                                                                                                        "core::fmt::rt::Argument",
                                                                                                                                      "new_display",
                                                                                                                                      [],
                                                                                                                                      [
                                                                                                                                        F
                                                                                                                                      ]
                                                                                                                                    |),
                                                                                                                                    [
                                                                                                                                      M.borrow (|
                                                                                                                                        Pointer.Kind.Ref,
                                                                                                                                        M.deref (|
                                                                                                                                          M.read (|
                                                                                                                                            M.SubPointer.get_tuple_field (|
                                                                                                                                              args,
                                                                                                                                              3
                                                                                                                                            |)
                                                                                                                                          |)
                                                                                                                                        |)
                                                                                                                                      |)
                                                                                                                                    ]
                                                                                                                                  |)
                                                                                                                                ]))
                                                                                                                        ]
                                                                                                                      |)
                                                                                                                    |)
                                                                                                                  |)
                                                                                                                |)
                                                                                                              |)
                                                                                                            ]
                                                                                                          |)
                                                                                                        ]
                                                                                                    ]
                                                                                                  |)
                                                                                                |)
                                                                                              |)
                                                                                            |)));
                                                                                        fun γ =>
                                                                                          ltac:(M.monadic
                                                                                            (Value.Tuple
                                                                                              []))
                                                                                      ]
                                                                                    |)))
                                                                              ]
                                                                            |) in
                                                                          let~ _ : Ty.tuple [] :=
                                                                            M.match_operator (|
                                                                              Ty.tuple [],
                                                                              M.alloc (|
                                                                                Ty.tuple [],
                                                                                Value.Tuple []
                                                                              |),
                                                                              [
                                                                                fun γ =>
                                                                                  ltac:(M.monadic
                                                                                    (let γ :=
                                                                                      M.use
                                                                                        (M.alloc (|
                                                                                          Ty.path
                                                                                            "bool",
                                                                                          UnOp.not (|
                                                                                            M.call_closure (|
                                                                                              Ty.path
                                                                                                "bool",
                                                                                              BinOp.le,
                                                                                              [
                                                                                                M.call_closure (|
                                                                                                  Ty.path
                                                                                                    "usize",
                                                                                                  M.get_associated_function (|
                                                                                                    Ty.apply
                                                                                                      (Ty.path
                                                                                                        "openvm_stark_backend::poly::uni::UnivariatePolynomial")
                                                                                                      []
                                                                                                      [
                                                                                                        F
                                                                                                      ],
                                                                                                    "degree",
                                                                                                    [],
                                                                                                    []
                                                                                                  |),
                                                                                                  [
                                                                                                    M.borrow (|
                                                                                                      Pointer.Kind.Ref,
                                                                                                      round_poly
                                                                                                    |)
                                                                                                  ]
                                                                                                |);
                                                                                                M.read (|
                                                                                                  get_constant (|
                                                                                                    "openvm_stark_backend::sumcheck::MAX_DEGREE",
                                                                                                    Ty.path
                                                                                                      "usize"
                                                                                                  |)
                                                                                                |)
                                                                                              ]
                                                                                            |)
                                                                                          |)
                                                                                        |)) in
                                                                                    let _ :=
                                                                                      is_constant_or_break_match (|
                                                                                        M.read (|
                                                                                          γ
                                                                                        |),
                                                                                        Value.Bool
                                                                                          true
                                                                                      |) in
                                                                                    M.never_to_any (|
                                                                                      M.call_closure (|
                                                                                        Ty.path
                                                                                          "never",
                                                                                        M.get_function (|
                                                                                          "core::panicking::panic_fmt",
                                                                                          [],
                                                                                          []
                                                                                        |),
                                                                                        [
                                                                                          M.call_closure (|
                                                                                            Ty.path
                                                                                              "core::fmt::Arguments",
                                                                                            M.get_associated_function (|
                                                                                              Ty.path
                                                                                                "core::fmt::Arguments",
                                                                                              "new_v1",
                                                                                              [
                                                                                                Value.Integer
                                                                                                  IntegerKind.Usize
                                                                                                  4;
                                                                                                Value.Integer
                                                                                                  IntegerKind.Usize
                                                                                                  4
                                                                                              ],
                                                                                              []
                                                                                            |),
                                                                                            [
                                                                                              M.borrow (|
                                                                                                Pointer.Kind.Ref,
                                                                                                M.deref (|
                                                                                                  M.borrow (|
                                                                                                    Pointer.Kind.Ref,
                                                                                                    M.alloc (|
                                                                                                      Ty.apply
                                                                                                        (Ty.path
                                                                                                          "array")
                                                                                                        [
                                                                                                          Value.Integer
                                                                                                            IntegerKind.Usize
                                                                                                            4
                                                                                                        ]
                                                                                                        [
                                                                                                          Ty.apply
                                                                                                            (Ty.path
                                                                                                              "&")
                                                                                                            []
                                                                                                            [
                                                                                                              Ty.path
                                                                                                                "str"
                                                                                                            ]
                                                                                                        ],
                                                                                                      Value.Array
                                                                                                        [
                                                                                                          mk_str (|
                                                                                                            "Round "
                                                                                                          |);
                                                                                                          mk_str (|
                                                                                                            ", poly "
                                                                                                          |);
                                                                                                          mk_str (|
                                                                                                            ": degree "
                                                                                                          |);
                                                                                                          mk_str (|
                                                                                                            " > max "
                                                                                                          |)
                                                                                                        ]
                                                                                                    |)
                                                                                                  |)
                                                                                                |)
                                                                                              |);
                                                                                              M.borrow (|
                                                                                                Pointer.Kind.Ref,
                                                                                                M.deref (|
                                                                                                  M.borrow (|
                                                                                                    Pointer.Kind.Ref,
                                                                                                    M.alloc (|
                                                                                                      Ty.apply
                                                                                                        (Ty.path
                                                                                                          "array")
                                                                                                        [
                                                                                                          Value.Integer
                                                                                                            IntegerKind.Usize
                                                                                                            4
                                                                                                        ]
                                                                                                        [
                                                                                                          Ty.path
                                                                                                            "core::fmt::rt::Argument"
                                                                                                        ],
                                                                                                      M.match_operator (|
                                                                                                        Ty.apply
                                                                                                          (Ty.path
                                                                                                            "array")
                                                                                                          [
                                                                                                            Value.Integer
                                                                                                              IntegerKind.Usize
                                                                                                              4
                                                                                                          ]
                                                                                                          [
                                                                                                            Ty.path
                                                                                                              "core::fmt::rt::Argument"
                                                                                                          ],
                                                                                                        M.alloc (|
                                                                                                          Ty.tuple
                                                                                                            [
                                                                                                              Ty.apply
                                                                                                                (Ty.path
                                                                                                                  "&")
                                                                                                                []
                                                                                                                [
                                                                                                                  Ty.path
                                                                                                                    "usize"
                                                                                                                ];
                                                                                                              Ty.apply
                                                                                                                (Ty.path
                                                                                                                  "&")
                                                                                                                []
                                                                                                                [
                                                                                                                  Ty.path
                                                                                                                    "usize"
                                                                                                                ];
                                                                                                              Ty.apply
                                                                                                                (Ty.path
                                                                                                                  "&")
                                                                                                                []
                                                                                                                [
                                                                                                                  Ty.path
                                                                                                                    "usize"
                                                                                                                ];
                                                                                                              Ty.apply
                                                                                                                (Ty.path
                                                                                                                  "&")
                                                                                                                []
                                                                                                                [
                                                                                                                  Ty.path
                                                                                                                    "usize"
                                                                                                                ]
                                                                                                            ],
                                                                                                          Value.Tuple
                                                                                                            [
                                                                                                              M.borrow (|
                                                                                                                Pointer.Kind.Ref,
                                                                                                                M.alloc (|
                                                                                                                  Ty.path
                                                                                                                    "usize",
                                                                                                                  M.call_closure (|
                                                                                                                    Ty.path
                                                                                                                      "usize",
                                                                                                                    M.get_associated_function (|
                                                                                                                      Ty.apply
                                                                                                                        (Ty.path
                                                                                                                          "openvm_stark_backend::poly::uni::UnivariatePolynomial")
                                                                                                                        []
                                                                                                                        [
                                                                                                                          F
                                                                                                                        ],
                                                                                                                      "degree",
                                                                                                                      [],
                                                                                                                      []
                                                                                                                    |),
                                                                                                                    [
                                                                                                                      M.borrow (|
                                                                                                                        Pointer.Kind.Ref,
                                                                                                                        round_poly
                                                                                                                      |)
                                                                                                                    ]
                                                                                                                  |)
                                                                                                                |)
                                                                                                              |);
                                                                                                              M.borrow (|
                                                                                                                Pointer.Kind.Ref,
                                                                                                                round
                                                                                                              |);
                                                                                                              M.borrow (|
                                                                                                                Pointer.Kind.Ref,
                                                                                                                i
                                                                                                              |);
                                                                                                              M.borrow (|
                                                                                                                Pointer.Kind.Ref,
                                                                                                                get_constant (|
                                                                                                                  "openvm_stark_backend::sumcheck::MAX_DEGREE",
                                                                                                                  Ty.path
                                                                                                                    "usize"
                                                                                                                |)
                                                                                                              |)
                                                                                                            ]
                                                                                                        |),
                                                                                                        [
                                                                                                          fun
                                                                                                              γ =>
                                                                                                            ltac:(M.monadic
                                                                                                              (let
                                                                                                                    args :=
                                                                                                                M.copy (|
                                                                                                                  Ty.tuple
                                                                                                                    [
                                                                                                                      Ty.apply
                                                                                                                        (Ty.path
                                                                                                                          "&")
                                                                                                                        []
                                                                                                                        [
                                                                                                                          Ty.path
                                                                                                                            "usize"
                                                                                                                        ];
                                                                                                                      Ty.apply
                                                                                                                        (Ty.path
                                                                                                                          "&")
                                                                                                                        []
                                                                                                                        [
                                                                                                                          Ty.path
                                                                                                                            "usize"
                                                                                                                        ];
                                                                                                                      Ty.apply
                                                                                                                        (Ty.path
                                                                                                                          "&")
                                                                                                                        []
                                                                                                                        [
                                                                                                                          Ty.path
                                                                                                                            "usize"
                                                                                                                        ];
                                                                                                                      Ty.apply
                                                                                                                        (Ty.path
                                                                                                                          "&")
                                                                                                                        []
                                                                                                                        [
                                                                                                                          Ty.path
                                                                                                                            "usize"
                                                                                                                        ]
                                                                                                                    ],
                                                                                                                  γ
                                                                                                                |) in
                                                                                                              Value.Array
                                                                                                                [
                                                                                                                  M.call_closure (|
                                                                                                                    Ty.path
                                                                                                                      "core::fmt::rt::Argument",
                                                                                                                    M.get_associated_function (|
                                                                                                                      Ty.path
                                                                                                                        "core::fmt::rt::Argument",
                                                                                                                      "new_display",
                                                                                                                      [],
                                                                                                                      [
                                                                                                                        Ty.path
                                                                                                                          "usize"
                                                                                                                      ]
                                                                                                                    |),
                                                                                                                    [
                                                                                                                      M.borrow (|
                                                                                                                        Pointer.Kind.Ref,
                                                                                                                        M.deref (|
                                                                                                                          M.read (|
                                                                                                                            M.SubPointer.get_tuple_field (|
                                                                                                                              args,
                                                                                                                              1
                                                                                                                            |)
                                                                                                                          |)
                                                                                                                        |)
                                                                                                                      |)
                                                                                                                    ]
                                                                                                                  |);
                                                                                                                  M.call_closure (|
                                                                                                                    Ty.path
                                                                                                                      "core::fmt::rt::Argument",
                                                                                                                    M.get_associated_function (|
                                                                                                                      Ty.path
                                                                                                                        "core::fmt::rt::Argument",
                                                                                                                      "new_display",
                                                                                                                      [],
                                                                                                                      [
                                                                                                                        Ty.path
                                                                                                                          "usize"
                                                                                                                      ]
                                                                                                                    |),
                                                                                                                    [
                                                                                                                      M.borrow (|
                                                                                                                        Pointer.Kind.Ref,
                                                                                                                        M.deref (|
                                                                                                                          M.read (|
                                                                                                                            M.SubPointer.get_tuple_field (|
                                                                                                                              args,
                                                                                                                              2
                                                                                                                            |)
                                                                                                                          |)
                                                                                                                        |)
                                                                                                                      |)
                                                                                                                    ]
                                                                                                                  |);
                                                                                                                  M.call_closure (|
                                                                                                                    Ty.path
                                                                                                                      "core::fmt::rt::Argument",
                                                                                                                    M.get_associated_function (|
                                                                                                                      Ty.path
                                                                                                                        "core::fmt::rt::Argument",
                                                                                                                      "new_display",
                                                                                                                      [],
                                                                                                                      [
                                                                                                                        Ty.path
                                                                                                                          "usize"
                                                                                                                      ]
                                                                                                                    |),
                                                                                                                    [
                                                                                                                      M.borrow (|
                                                                                                                        Pointer.Kind.Ref,
                                                                                                                        M.deref (|
                                                                                                                          M.read (|
                                                                                                                            M.SubPointer.get_tuple_field (|
                                                                                                                              args,
                                                                                                                              0
                                                                                                                            |)
                                                                                                                          |)
                                                                                                                        |)
                                                                                                                      |)
                                                                                                                    ]
                                                                                                                  |);
                                                                                                                  M.call_closure (|
                                                                                                                    Ty.path
                                                                                                                      "core::fmt::rt::Argument",
                                                                                                                    M.get_associated_function (|
                                                                                                                      Ty.path
                                                                                                                        "core::fmt::rt::Argument",
                                                                                                                      "new_display",
                                                                                                                      [],
                                                                                                                      [
                                                                                                                        Ty.path
                                                                                                                          "usize"
                                                                                                                      ]
                                                                                                                    |),
                                                                                                                    [
                                                                                                                      M.borrow (|
                                                                                                                        Pointer.Kind.Ref,
                                                                                                                        M.deref (|
                                                                                                                          M.read (|
                                                                                                                            M.SubPointer.get_tuple_field (|
                                                                                                                              args,
                                                                                                                              3
                                                                                                                            |)
                                                                                                                          |)
                                                                                                                        |)
                                                                                                                      |)
                                                                                                                    ]
                                                                                                                  |)
                                                                                                                ]))
                                                                                                        ]
                                                                                                      |)
                                                                                                    |)
                                                                                                  |)
                                                                                                |)
                                                                                              |)
                                                                                            ]
                                                                                          |)
                                                                                        ]
                                                                                      |)
                                                                                    |)));
                                                                                fun γ =>
                                                                                  ltac:(M.monadic
                                                                                    (Value.Tuple
                                                                                      []))
                                                                              ]
                                                                            |) in
                                                                          round_poly
                                                                        |)))
                                                                  ]
                                                                |)))
                                                            | _ =>
                                                              M.impossible
                                                                "wrong number of arguments"
                                                            end))
                                                    ]
                                                  |)
                                                ]
                                              |) in
                                            let~ round_poly :
                                                Ty.apply
                                                  (Ty.path
                                                    "openvm_stark_backend::poly::uni::UnivariatePolynomial")
                                                  []
                                                  [ F ] :=
                                              M.call_closure (|
                                                Ty.apply
                                                  (Ty.path
                                                    "openvm_stark_backend::poly::uni::UnivariatePolynomial")
                                                  []
                                                  [ F ],
                                                M.get_function (|
                                                  "openvm_stark_backend::sumcheck::random_linear_combination",
                                                  [],
                                                  [ F ]
                                                |),
                                                [
                                                  M.borrow (|
                                                    Pointer.Kind.Ref,
                                                    M.deref (|
                                                      M.call_closure (|
                                                        Ty.apply
                                                          (Ty.path "&")
                                                          []
                                                          [
                                                            Ty.apply
                                                              (Ty.path "slice")
                                                              []
                                                              [
                                                                Ty.apply
                                                                  (Ty.path
                                                                    "openvm_stark_backend::poly::uni::UnivariatePolynomial")
                                                                  []
                                                                  [ F ]
                                                              ]
                                                          ],
                                                        M.get_trait_method (|
                                                          "core::ops::deref::Deref",
                                                          Ty.apply
                                                            (Ty.path "alloc::vec::Vec")
                                                            []
                                                            [
                                                              Ty.apply
                                                                (Ty.path
                                                                  "openvm_stark_backend::poly::uni::UnivariatePolynomial")
                                                                []
                                                                [ F ];
                                                              Ty.path "alloc::alloc::Global"
                                                            ],
                                                          [],
                                                          [],
                                                          "deref",
                                                          [],
                                                          []
                                                        |),
                                                        [
                                                          M.borrow (|
                                                            Pointer.Kind.Ref,
                                                            M.deref (|
                                                              M.borrow (|
                                                                Pointer.Kind.Ref,
                                                                this_round_polys
                                                              |)
                                                            |)
                                                          |)
                                                        ]
                                                      |)
                                                    |)
                                                  |);
                                                  M.read (| lambda |)
                                                ]
                                              |) in
                                            let~ _ : Ty.tuple [] :=
                                              M.call_closure (|
                                                Ty.tuple [],
                                                M.get_trait_method (|
                                                  "p3_challenger::CanObserve",
                                                  impl_FieldChallenger_F_,
                                                  [],
                                                  [ F ],
                                                  "observe_slice",
                                                  [],
                                                  []
                                                |),
                                                [
                                                  M.borrow (|
                                                    Pointer.Kind.MutRef,
                                                    M.deref (| M.read (| challenger |) |)
                                                  |);
                                                  M.borrow (|
                                                    Pointer.Kind.Ref,
                                                    M.deref (|
                                                      M.call_closure (|
                                                        Ty.apply
                                                          (Ty.path "&")
                                                          []
                                                          [ Ty.apply (Ty.path "slice") [] [ F ] ],
                                                        M.get_trait_method (|
                                                          "core::ops::deref::Deref",
                                                          Ty.apply
                                                            (Ty.path
                                                              "openvm_stark_backend::poly::uni::UnivariatePolynomial")
                                                            []
                                                            [ F ],
                                                          [],
                                                          [],
                                                          "deref",
                                                          [],
                                                          []
                                                        |),
                                                        [
                                                          M.borrow (|
                                                            Pointer.Kind.Ref,
                                                            M.deref (|
                                                              M.borrow (|
                                                                Pointer.Kind.Ref,
                                                                round_poly
                                                              |)
                                                            |)
                                                          |)
                                                        ]
                                                      |)
                                                    |)
                                                  |)
                                                ]
                                              |) in
                                            let~ challenge : F :=
                                              M.call_closure (|
                                                F,
                                                M.get_trait_method (|
                                                  "p3_challenger::FieldChallenger",
                                                  impl_FieldChallenger_F_,
                                                  [],
                                                  [ F ],
                                                  "sample_ext_element",
                                                  [],
                                                  [ F ]
                                                |),
                                                [
                                                  M.borrow (|
                                                    Pointer.Kind.MutRef,
                                                    M.deref (| M.read (| challenger |) |)
                                                  |)
                                                ]
                                              |) in
                                            let~ _ : Ty.tuple [] :=
                                              M.write (|
                                                claims,
                                                M.call_closure (|
                                                  Ty.apply
                                                    (Ty.path "alloc::vec::Vec")
                                                    []
                                                    [ F; Ty.path "alloc::alloc::Global" ],
                                                  M.get_trait_method (|
                                                    "core::iter::traits::iterator::Iterator",
                                                    Ty.apply
                                                      (Ty.path "core::iter::adapters::map::Map")
                                                      []
                                                      [
                                                        Ty.apply
                                                          (Ty.path "core::slice::iter::Iter")
                                                          []
                                                          [
                                                            Ty.apply
                                                              (Ty.path
                                                                "openvm_stark_backend::poly::uni::UnivariatePolynomial")
                                                              []
                                                              [ F ]
                                                          ];
                                                        Ty.function
                                                          [
                                                            Ty.apply
                                                              (Ty.path "&")
                                                              []
                                                              [
                                                                Ty.apply
                                                                  (Ty.path
                                                                    "openvm_stark_backend::poly::uni::UnivariatePolynomial")
                                                                  []
                                                                  [ F ]
                                                              ]
                                                          ]
                                                          F
                                                      ],
                                                    [],
                                                    [],
                                                    "collect",
                                                    [],
                                                    [
                                                      Ty.apply
                                                        (Ty.path "alloc::vec::Vec")
                                                        []
                                                        [ F; Ty.path "alloc::alloc::Global" ]
                                                    ]
                                                  |),
                                                  [
                                                    M.call_closure (|
                                                      Ty.apply
                                                        (Ty.path "core::iter::adapters::map::Map")
                                                        []
                                                        [
                                                          Ty.apply
                                                            (Ty.path "core::slice::iter::Iter")
                                                            []
                                                            [
                                                              Ty.apply
                                                                (Ty.path
                                                                  "openvm_stark_backend::poly::uni::UnivariatePolynomial")
                                                                []
                                                                [ F ]
                                                            ];
                                                          Ty.function
                                                            [
                                                              Ty.apply
                                                                (Ty.path "&")
                                                                []
                                                                [
                                                                  Ty.apply
                                                                    (Ty.path
                                                                      "openvm_stark_backend::poly::uni::UnivariatePolynomial")
                                                                    []
                                                                    [ F ]
                                                                ]
                                                            ]
                                                            F
                                                        ],
                                                      M.get_trait_method (|
                                                        "core::iter::traits::iterator::Iterator",
                                                        Ty.apply
                                                          (Ty.path "core::slice::iter::Iter")
                                                          []
                                                          [
                                                            Ty.apply
                                                              (Ty.path
                                                                "openvm_stark_backend::poly::uni::UnivariatePolynomial")
                                                              []
                                                              [ F ]
                                                          ],
                                                        [],
                                                        [],
                                                        "map",
                                                        [],
                                                        [
                                                          F;
                                                          Ty.function
                                                            [
                                                              Ty.apply
                                                                (Ty.path "&")
                                                                []
                                                                [
                                                                  Ty.apply
                                                                    (Ty.path
                                                                      "openvm_stark_backend::poly::uni::UnivariatePolynomial")
                                                                    []
                                                                    [ F ]
                                                                ]
                                                            ]
                                                            F
                                                        ]
                                                      |),
                                                      [
                                                        M.call_closure (|
                                                          Ty.apply
                                                            (Ty.path "core::slice::iter::Iter")
                                                            []
                                                            [
                                                              Ty.apply
                                                                (Ty.path
                                                                  "openvm_stark_backend::poly::uni::UnivariatePolynomial")
                                                                []
                                                                [ F ]
                                                            ],
                                                          M.get_associated_function (|
                                                            Ty.apply
                                                              (Ty.path "slice")
                                                              []
                                                              [
                                                                Ty.apply
                                                                  (Ty.path
                                                                    "openvm_stark_backend::poly::uni::UnivariatePolynomial")
                                                                  []
                                                                  [ F ]
                                                              ],
                                                            "iter",
                                                            [],
                                                            []
                                                          |),
                                                          [
                                                            M.borrow (|
                                                              Pointer.Kind.Ref,
                                                              M.deref (|
                                                                M.call_closure (|
                                                                  Ty.apply
                                                                    (Ty.path "&")
                                                                    []
                                                                    [
                                                                      Ty.apply
                                                                        (Ty.path "slice")
                                                                        []
                                                                        [
                                                                          Ty.apply
                                                                            (Ty.path
                                                                              "openvm_stark_backend::poly::uni::UnivariatePolynomial")
                                                                            []
                                                                            [ F ]
                                                                        ]
                                                                    ],
                                                                  M.get_trait_method (|
                                                                    "core::ops::deref::Deref",
                                                                    Ty.apply
                                                                      (Ty.path "alloc::vec::Vec")
                                                                      []
                                                                      [
                                                                        Ty.apply
                                                                          (Ty.path
                                                                            "openvm_stark_backend::poly::uni::UnivariatePolynomial")
                                                                          []
                                                                          [ F ];
                                                                        Ty.path
                                                                          "alloc::alloc::Global"
                                                                      ],
                                                                    [],
                                                                    [],
                                                                    "deref",
                                                                    [],
                                                                    []
                                                                  |),
                                                                  [
                                                                    M.borrow (|
                                                                      Pointer.Kind.Ref,
                                                                      this_round_polys
                                                                    |)
                                                                  ]
                                                                |)
                                                              |)
                                                            |)
                                                          ]
                                                        |);
                                                        M.closure
                                                          (fun γ =>
                                                            ltac:(M.monadic
                                                              match γ with
                                                              | [ α0 ] =>
                                                                ltac:(M.monadic
                                                                  (M.match_operator (|
                                                                    F,
                                                                    M.alloc (|
                                                                      Ty.apply
                                                                        (Ty.path "&")
                                                                        []
                                                                        [
                                                                          Ty.apply
                                                                            (Ty.path
                                                                              "openvm_stark_backend::poly::uni::UnivariatePolynomial")
                                                                            []
                                                                            [ F ]
                                                                        ],
                                                                      α0
                                                                    |),
                                                                    [
                                                                      fun γ =>
                                                                        ltac:(M.monadic
                                                                          (let round_poly :=
                                                                            M.copy (|
                                                                              Ty.apply
                                                                                (Ty.path "&")
                                                                                []
                                                                                [
                                                                                  Ty.apply
                                                                                    (Ty.path
                                                                                      "openvm_stark_backend::poly::uni::UnivariatePolynomial")
                                                                                    []
                                                                                    [ F ]
                                                                                ],
                                                                              γ
                                                                            |) in
                                                                          M.call_closure (|
                                                                            F,
                                                                            M.get_associated_function (|
                                                                              Ty.apply
                                                                                (Ty.path
                                                                                  "openvm_stark_backend::poly::uni::UnivariatePolynomial")
                                                                                []
                                                                                [ F ],
                                                                              "evaluate",
                                                                              [],
                                                                              []
                                                                            |),
                                                                            [
                                                                              M.borrow (|
                                                                                Pointer.Kind.Ref,
                                                                                M.deref (|
                                                                                  M.read (|
                                                                                    round_poly
                                                                                  |)
                                                                                |)
                                                                              |);
                                                                              M.read (| challenge |)
                                                                            ]
                                                                          |)))
                                                                    ]
                                                                  |)))
                                                              | _ =>
                                                                M.impossible
                                                                  "wrong number of arguments"
                                                              end))
                                                      ]
                                                    |)
                                                  ]
                                                |)
                                              |) in
                                            let~ _ : Ty.tuple [] :=
                                              M.write (|
                                                polys,
                                                M.call_closure (|
                                                  Ty.apply
                                                    (Ty.path "alloc::vec::Vec")
                                                    []
                                                    [ O; Ty.path "alloc::alloc::Global" ],
                                                  M.get_trait_method (|
                                                    "core::iter::traits::iterator::Iterator",
                                                    Ty.apply
                                                      (Ty.path "core::iter::adapters::map::Map")
                                                      []
                                                      [
                                                        Ty.apply
                                                          (Ty.path
                                                            "alloc::vec::into_iter::IntoIter")
                                                          []
                                                          [ O; Ty.path "alloc::alloc::Global" ];
                                                        Ty.function [ O ] O
                                                      ],
                                                    [],
                                                    [],
                                                    "collect",
                                                    [],
                                                    [
                                                      Ty.apply
                                                        (Ty.path "alloc::vec::Vec")
                                                        []
                                                        [ O; Ty.path "alloc::alloc::Global" ]
                                                    ]
                                                  |),
                                                  [
                                                    M.call_closure (|
                                                      Ty.apply
                                                        (Ty.path "core::iter::adapters::map::Map")
                                                        []
                                                        [
                                                          Ty.apply
                                                            (Ty.path
                                                              "alloc::vec::into_iter::IntoIter")
                                                            []
                                                            [ O; Ty.path "alloc::alloc::Global" ];
                                                          Ty.function [ O ] O
                                                        ],
                                                      M.get_trait_method (|
                                                        "core::iter::traits::iterator::Iterator",
                                                        Ty.apply
                                                          (Ty.path
                                                            "alloc::vec::into_iter::IntoIter")
                                                          []
                                                          [ O; Ty.path "alloc::alloc::Global" ],
                                                        [],
                                                        [],
                                                        "map",
                                                        [],
                                                        [ O; Ty.function [ O ] O ]
                                                      |),
                                                      [
                                                        M.call_closure (|
                                                          Ty.apply
                                                            (Ty.path
                                                              "alloc::vec::into_iter::IntoIter")
                                                            []
                                                            [ O; Ty.path "alloc::alloc::Global" ],
                                                          M.get_trait_method (|
                                                            "core::iter::traits::collect::IntoIterator",
                                                            Ty.apply
                                                              (Ty.path "alloc::vec::Vec")
                                                              []
                                                              [ O; Ty.path "alloc::alloc::Global" ],
                                                            [],
                                                            [],
                                                            "into_iter",
                                                            [],
                                                            []
                                                          |),
                                                          [ M.read (| polys |) ]
                                                        |);
                                                        M.closure
                                                          (fun γ =>
                                                            ltac:(M.monadic
                                                              match γ with
                                                              | [ α0 ] =>
                                                                ltac:(M.monadic
                                                                  (M.match_operator (|
                                                                    O,
                                                                    M.alloc (| O, α0 |),
                                                                    [
                                                                      fun γ =>
                                                                        ltac:(M.monadic
                                                                          (let multivariate_poly :=
                                                                            M.copy (| O, γ |) in
                                                                          M.match_operator (|
                                                                            O,
                                                                            M.alloc (|
                                                                              Ty.tuple [],
                                                                              Value.Tuple []
                                                                            |),
                                                                            [
                                                                              fun γ =>
                                                                                ltac:(M.monadic
                                                                                  (let γ :=
                                                                                    M.use
                                                                                      (M.alloc (|
                                                                                        Ty.path
                                                                                          "bool",
                                                                                        M.call_closure (|
                                                                                          Ty.path
                                                                                            "bool",
                                                                                          BinOp.ne,
                                                                                          [
                                                                                            M.read (|
                                                                                              n_remaining_rounds
                                                                                            |);
                                                                                            M.call_closure (|
                                                                                              Ty.path
                                                                                                "usize",
                                                                                              M.get_trait_method (|
                                                                                                "openvm_stark_backend::poly::multi::MultivariatePolyOracle",
                                                                                                O,
                                                                                                [],
                                                                                                [ F
                                                                                                ],
                                                                                                "arity",
                                                                                                [],
                                                                                                []
                                                                                              |),
                                                                                              [
                                                                                                M.borrow (|
                                                                                                  Pointer.Kind.Ref,
                                                                                                  multivariate_poly
                                                                                                |)
                                                                                              ]
                                                                                            |)
                                                                                          ]
                                                                                        |)
                                                                                      |)) in
                                                                                  let _ :=
                                                                                    is_constant_or_break_match (|
                                                                                      M.read (|
                                                                                        γ
                                                                                      |),
                                                                                      Value.Bool
                                                                                        true
                                                                                    |) in
                                                                                  M.read (|
                                                                                    multivariate_poly
                                                                                  |)));
                                                                              fun γ =>
                                                                                ltac:(M.monadic
                                                                                  (M.call_closure (|
                                                                                    O,
                                                                                    M.get_trait_method (|
                                                                                      "openvm_stark_backend::poly::multi::MultivariatePolyOracle",
                                                                                      O,
                                                                                      [],
                                                                                      [ F ],
                                                                                      "partial_evaluation",
                                                                                      [],
                                                                                      []
                                                                                    |),
                                                                                    [
                                                                                      M.read (|
                                                                                        multivariate_poly
                                                                                      |);
                                                                                      M.read (|
                                                                                        challenge
                                                                                      |)
                                                                                    ]
                                                                                  |)))
                                                                            ]
                                                                          |)))
                                                                    ]
                                                                  |)))
                                                              | _ =>
                                                                M.impossible
                                                                  "wrong number of arguments"
                                                              end))
                                                      ]
                                                    |)
                                                  ]
                                                |)
                                              |) in
                                            let~ _ : Ty.tuple [] :=
                                              M.call_closure (|
                                                Ty.tuple [],
                                                M.get_associated_function (|
                                                  Ty.apply
                                                    (Ty.path "alloc::vec::Vec")
                                                    []
                                                    [
                                                      Ty.apply
                                                        (Ty.path
                                                          "openvm_stark_backend::poly::uni::UnivariatePolynomial")
                                                        []
                                                        [ F ];
                                                      Ty.path "alloc::alloc::Global"
                                                    ],
                                                  "push",
                                                  [],
                                                  []
                                                |),
                                                [
                                                  M.borrow (| Pointer.Kind.MutRef, round_polys |);
                                                  M.read (| round_poly |)
                                                ]
                                              |) in
                                            let~ _ : Ty.tuple [] :=
                                              M.call_closure (|
                                                Ty.tuple [],
                                                M.get_associated_function (|
                                                  Ty.apply
                                                    (Ty.path "alloc::vec::Vec")
                                                    []
                                                    [ F; Ty.path "alloc::alloc::Global" ],
                                                  "push",
                                                  [],
                                                  []
                                                |),
                                                [
                                                  M.borrow (|
                                                    Pointer.Kind.MutRef,
                                                    evaluation_point
                                                  |);
                                                  M.read (| challenge |)
                                                ]
                                              |) in
                                            M.alloc (| Ty.tuple [], Value.Tuple [] |)
                                          |)))
                                    ]
                                  |) in
                                M.alloc (| Ty.tuple [], Value.Tuple [] |)))
                            |)
                          |)))
                    ]
                  |)
                |))
            |) in
          let~ proof :
              Ty.apply (Ty.path "openvm_stark_backend::sumcheck::SumcheckProof") [] [ F ] :=
            Value.mkStructRecord
              "openvm_stark_backend::sumcheck::SumcheckProof"
              []
              [ F ]
              [ ("round_polys", M.read (| round_polys |)) ] in
          let~ artifacts :
              Ty.apply (Ty.path "openvm_stark_backend::sumcheck::SumcheckArtifacts") [] [ F; O ] :=
            Value.mkStructRecord
              "openvm_stark_backend::sumcheck::SumcheckArtifacts"
              []
              [ F; O ]
              [
                ("evaluation_point", M.read (| evaluation_point |));
                ("constant_poly_oracles", M.read (| polys |));
                ("claimed_evals", M.read (| claims |))
              ] in
          M.alloc (|
            Ty.tuple
              [
                Ty.apply (Ty.path "openvm_stark_backend::sumcheck::SumcheckProof") [] [ F ];
                Ty.apply (Ty.path "openvm_stark_backend::sumcheck::SumcheckArtifacts") [] [ F; O ]
              ],
            Value.Tuple [ M.read (| proof |); M.read (| artifacts |) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_prove_batch :
    M.IsFunction.C "openvm_stark_backend::sumcheck::prove_batch" prove_batch.
  Admitted.
  Global Typeclasses Opaque prove_batch.
  
  (*
  fn random_linear_combination<F: Field>(
      polys: &[UnivariatePolynomial<F>],
      alpha: F,
  ) -> UnivariatePolynomial<F> {
      polys
          .iter()
          .rfold(UnivariatePolynomial::<F>::zero(), |acc, poly| {
              acc * alpha + poly.clone()
          })
  }
  *)
  Definition random_linear_combination (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ F ], [ polys; alpha ] =>
      ltac:(M.monadic
        (let polys :=
          M.alloc (|
            Ty.apply
              (Ty.path "&")
              []
              [
                Ty.apply
                  (Ty.path "slice")
                  []
                  [
                    Ty.apply
                      (Ty.path "openvm_stark_backend::poly::uni::UnivariatePolynomial")
                      []
                      [ F ]
                  ]
              ],
            polys
          |) in
        let alpha := M.alloc (| F, alpha |) in
        M.call_closure (|
          Ty.apply (Ty.path "openvm_stark_backend::poly::uni::UnivariatePolynomial") [] [ F ],
          M.get_trait_method (|
            "core::iter::traits::double_ended::DoubleEndedIterator",
            Ty.apply
              (Ty.path "core::slice::iter::Iter")
              []
              [ Ty.apply (Ty.path "openvm_stark_backend::poly::uni::UnivariatePolynomial") [] [ F ]
              ],
            [],
            [],
            "rfold",
            [],
            [
              Ty.apply (Ty.path "openvm_stark_backend::poly::uni::UnivariatePolynomial") [] [ F ];
              Ty.function
                [
                  Ty.apply
                    (Ty.path "openvm_stark_backend::poly::uni::UnivariatePolynomial")
                    []
                    [ F ];
                  Ty.apply
                    (Ty.path "&")
                    []
                    [
                      Ty.apply
                        (Ty.path "openvm_stark_backend::poly::uni::UnivariatePolynomial")
                        []
                        [ F ]
                    ]
                ]
                (Ty.apply
                  (Ty.path "openvm_stark_backend::poly::uni::UnivariatePolynomial")
                  []
                  [ F ])
            ]
          |),
          [
            M.call_closure (|
              Ty.apply
                (Ty.path "core::slice::iter::Iter")
                []
                [
                  Ty.apply
                    (Ty.path "openvm_stark_backend::poly::uni::UnivariatePolynomial")
                    []
                    [ F ]
                ],
              M.get_associated_function (|
                Ty.apply
                  (Ty.path "slice")
                  []
                  [
                    Ty.apply
                      (Ty.path "openvm_stark_backend::poly::uni::UnivariatePolynomial")
                      []
                      [ F ]
                  ],
                "iter",
                [],
                []
              |),
              [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| polys |) |) |) ]
            |);
            M.call_closure (|
              Ty.apply (Ty.path "openvm_stark_backend::poly::uni::UnivariatePolynomial") [] [ F ],
              M.get_associated_function (|
                Ty.apply (Ty.path "openvm_stark_backend::poly::uni::UnivariatePolynomial") [] [ F ],
                "zero",
                [],
                []
              |),
              []
            |);
            M.closure
              (fun γ =>
                ltac:(M.monadic
                  match γ with
                  | [ α0; α1 ] =>
                    ltac:(M.monadic
                      (M.match_operator (|
                        Ty.apply
                          (Ty.path "openvm_stark_backend::poly::uni::UnivariatePolynomial")
                          []
                          [ F ],
                        M.alloc (|
                          Ty.apply
                            (Ty.path "openvm_stark_backend::poly::uni::UnivariatePolynomial")
                            []
                            [ F ],
                          α0
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let acc :=
                                M.copy (|
                                  Ty.apply
                                    (Ty.path
                                      "openvm_stark_backend::poly::uni::UnivariatePolynomial")
                                    []
                                    [ F ],
                                  γ
                                |) in
                              M.match_operator (|
                                Ty.apply
                                  (Ty.path "openvm_stark_backend::poly::uni::UnivariatePolynomial")
                                  []
                                  [ F ],
                                M.alloc (|
                                  Ty.apply
                                    (Ty.path "&")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path
                                          "openvm_stark_backend::poly::uni::UnivariatePolynomial")
                                        []
                                        [ F ]
                                    ],
                                  α1
                                |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let poly :=
                                        M.copy (|
                                          Ty.apply
                                            (Ty.path "&")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path
                                                  "openvm_stark_backend::poly::uni::UnivariatePolynomial")
                                                []
                                                [ F ]
                                            ],
                                          γ
                                        |) in
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path
                                            "openvm_stark_backend::poly::uni::UnivariatePolynomial")
                                          []
                                          [ F ],
                                        M.get_trait_method (|
                                          "core::ops::arith::Add",
                                          Ty.apply
                                            (Ty.path
                                              "openvm_stark_backend::poly::uni::UnivariatePolynomial")
                                            []
                                            [ F ],
                                          [],
                                          [
                                            Ty.apply
                                              (Ty.path
                                                "openvm_stark_backend::poly::uni::UnivariatePolynomial")
                                              []
                                              [ F ]
                                          ],
                                          "add",
                                          [],
                                          []
                                        |),
                                        [
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path
                                                "openvm_stark_backend::poly::uni::UnivariatePolynomial")
                                              []
                                              [ F ],
                                            M.get_trait_method (|
                                              "core::ops::arith::Mul",
                                              Ty.apply
                                                (Ty.path
                                                  "openvm_stark_backend::poly::uni::UnivariatePolynomial")
                                                []
                                                [ F ],
                                              [],
                                              [ F ],
                                              "mul",
                                              [],
                                              []
                                            |),
                                            [ M.read (| acc |); M.read (| alpha |) ]
                                          |);
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path
                                                "openvm_stark_backend::poly::uni::UnivariatePolynomial")
                                              []
                                              [ F ],
                                            M.get_trait_method (|
                                              "core::clone::Clone",
                                              Ty.apply
                                                (Ty.path
                                                  "openvm_stark_backend::poly::uni::UnivariatePolynomial")
                                                []
                                                [ F ],
                                              [],
                                              [],
                                              "clone",
                                              [],
                                              []
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.read (| poly |) |)
                                              |)
                                            ]
                                          |)
                                        ]
                                      |)))
                                ]
                              |)))
                        ]
                      |)))
                  | _ => M.impossible "wrong number of arguments"
                  end))
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_random_linear_combination :
    M.IsFunction.C
      "openvm_stark_backend::sumcheck::random_linear_combination"
      random_linear_combination.
  Admitted.
  Global Typeclasses Opaque random_linear_combination.
  
  (*
  pub fn partially_verify<F: Field>(
      mut claim: F,
      proof: &SumcheckProof<F>,
      challenger: &mut impl FieldChallenger<F>,
  ) -> Result<(Vec<F>, F), SumcheckError<F>> {
      let mut assignment = Vec::new();
  
      for (round, round_poly) in proof.round_polys.iter().enumerate() {
          if round_poly.degree() > MAX_DEGREE {
              return Err(SumcheckError::DegreeInvalid { round });
          }
  
          // TODO: optimize this by sending one less coefficient, and computing it from the
          // claim, instead of checking the claim. (Can also be done by quotienting).
          let sum = round_poly.evaluate(F::ZERO) + round_poly.evaluate(F::ONE);
  
          if claim != sum {
              return Err(SumcheckError::SumInvalid { claim, sum, round });
          }
  
          challenger.observe_slice(round_poly);
          let challenge = challenger.sample_ext_element();
  
          claim = round_poly.evaluate(challenge);
          assignment.push(challenge);
      }
  
      Ok((assignment, claim))
  }
  *)
  Definition partially_verify (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ F; impl_FieldChallenger_F_ ], [ claim; proof; challenger ] =>
      ltac:(M.monadic
        (let claim := M.alloc (| F, claim |) in
        let proof :=
          M.alloc (|
            Ty.apply
              (Ty.path "&")
              []
              [ Ty.apply (Ty.path "openvm_stark_backend::sumcheck::SumcheckProof") [] [ F ] ],
            proof
          |) in
        let challenger :=
          M.alloc (| Ty.apply (Ty.path "&mut") [] [ impl_FieldChallenger_F_ ], challenger |) in
        M.catch_return
          (Ty.apply
            (Ty.path "core::result::Result")
            []
            [
              Ty.tuple
                [ Ty.apply (Ty.path "alloc::vec::Vec") [] [ F; Ty.path "alloc::alloc::Global" ]; F
                ];
              Ty.apply (Ty.path "openvm_stark_backend::sumcheck::SumcheckError") [] [ F ]
            ]) (|
          ltac:(M.monadic
            (M.read (|
              let~ assignment :
                  Ty.apply (Ty.path "alloc::vec::Vec") [] [ F; Ty.path "alloc::alloc::Global" ] :=
                M.call_closure (|
                  Ty.apply (Ty.path "alloc::vec::Vec") [] [ F; Ty.path "alloc::alloc::Global" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloc::vec::Vec") [] [ F; Ty.path "alloc::alloc::Global" ],
                    "new",
                    [],
                    []
                  |),
                  []
                |) in
              let~ _ : Ty.tuple [] :=
                M.read (|
                  M.use
                    (M.alloc (|
                      Ty.tuple [],
                      M.match_operator (|
                        Ty.tuple [],
                        M.alloc (|
                          Ty.apply
                            (Ty.path "core::iter::adapters::enumerate::Enumerate")
                            []
                            [
                              Ty.apply
                                (Ty.path "core::slice::iter::Iter")
                                []
                                [
                                  Ty.apply
                                    (Ty.path
                                      "openvm_stark_backend::poly::uni::UnivariatePolynomial")
                                    []
                                    [ F ]
                                ]
                            ],
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "core::iter::adapters::enumerate::Enumerate")
                              []
                              [
                                Ty.apply
                                  (Ty.path "core::slice::iter::Iter")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path
                                        "openvm_stark_backend::poly::uni::UnivariatePolynomial")
                                      []
                                      [ F ]
                                  ]
                              ],
                            M.get_trait_method (|
                              "core::iter::traits::collect::IntoIterator",
                              Ty.apply
                                (Ty.path "core::iter::adapters::enumerate::Enumerate")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "core::slice::iter::Iter")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path
                                          "openvm_stark_backend::poly::uni::UnivariatePolynomial")
                                        []
                                        [ F ]
                                    ]
                                ],
                              [],
                              [],
                              "into_iter",
                              [],
                              []
                            |),
                            [
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::iter::adapters::enumerate::Enumerate")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::slice::iter::Iter")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path
                                            "openvm_stark_backend::poly::uni::UnivariatePolynomial")
                                          []
                                          [ F ]
                                      ]
                                  ],
                                M.get_trait_method (|
                                  "core::iter::traits::iterator::Iterator",
                                  Ty.apply
                                    (Ty.path "core::slice::iter::Iter")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path
                                          "openvm_stark_backend::poly::uni::UnivariatePolynomial")
                                        []
                                        [ F ]
                                    ],
                                  [],
                                  [],
                                  "enumerate",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::slice::iter::Iter")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path
                                            "openvm_stark_backend::poly::uni::UnivariatePolynomial")
                                          []
                                          [ F ]
                                      ],
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "slice")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path
                                              "openvm_stark_backend::poly::uni::UnivariatePolynomial")
                                            []
                                            [ F ]
                                        ],
                                      "iter",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "&")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "slice")
                                                  []
                                                  [
                                                    Ty.apply
                                                      (Ty.path
                                                        "openvm_stark_backend::poly::uni::UnivariatePolynomial")
                                                      []
                                                      [ F ]
                                                  ]
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::deref::Deref",
                                              Ty.apply
                                                (Ty.path "alloc::vec::Vec")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path
                                                      "openvm_stark_backend::poly::uni::UnivariatePolynomial")
                                                    []
                                                    [ F ];
                                                  Ty.path "alloc::alloc::Global"
                                                ],
                                              [],
                                              [],
                                              "deref",
                                              [],
                                              []
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.SubPointer.get_struct_record_field (|
                                                  M.deref (| M.read (| proof |) |),
                                                  "openvm_stark_backend::sumcheck::SumcheckProof",
                                                  "round_polys"
                                                |)
                                              |)
                                            ]
                                          |)
                                        |)
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            ]
                          |)
                        |),
                        [
                          fun γ =>
                            ltac:(M.monadic
                              (let iter :=
                                M.copy (|
                                  Ty.apply
                                    (Ty.path "core::iter::adapters::enumerate::Enumerate")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "core::slice::iter::Iter")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path
                                              "openvm_stark_backend::poly::uni::UnivariatePolynomial")
                                            []
                                            [ F ]
                                        ]
                                    ],
                                  γ
                                |) in
                              M.read (|
                                M.loop (|
                                  Ty.tuple [],
                                  ltac:(M.monadic
                                    (let~ _ : Ty.tuple [] :=
                                      M.match_operator (|
                                        Ty.tuple [],
                                        M.alloc (|
                                          Ty.apply
                                            (Ty.path "core::option::Option")
                                            []
                                            [
                                              Ty.tuple
                                                [
                                                  Ty.path "usize";
                                                  Ty.apply
                                                    (Ty.path "&")
                                                    []
                                                    [
                                                      Ty.apply
                                                        (Ty.path
                                                          "openvm_stark_backend::poly::uni::UnivariatePolynomial")
                                                        []
                                                        [ F ]
                                                    ]
                                                ]
                                            ],
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::option::Option")
                                              []
                                              [
                                                Ty.tuple
                                                  [
                                                    Ty.path "usize";
                                                    Ty.apply
                                                      (Ty.path "&")
                                                      []
                                                      [
                                                        Ty.apply
                                                          (Ty.path
                                                            "openvm_stark_backend::poly::uni::UnivariatePolynomial")
                                                          []
                                                          [ F ]
                                                      ]
                                                  ]
                                              ],
                                            M.get_trait_method (|
                                              "core::iter::traits::iterator::Iterator",
                                              Ty.apply
                                                (Ty.path
                                                  "core::iter::adapters::enumerate::Enumerate")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::slice::iter::Iter")
                                                    []
                                                    [
                                                      Ty.apply
                                                        (Ty.path
                                                          "openvm_stark_backend::poly::uni::UnivariatePolynomial")
                                                        []
                                                        [ F ]
                                                    ]
                                                ],
                                              [],
                                              [],
                                              "next",
                                              [],
                                              []
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.MutRef,
                                                M.deref (|
                                                  M.borrow (| Pointer.Kind.MutRef, iter |)
                                                |)
                                              |)
                                            ]
                                          |)
                                        |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let _ :=
                                                M.is_struct_tuple (|
                                                  γ,
                                                  "core::option::Option::None"
                                                |) in
                                              M.never_to_any (| M.read (| M.break (||) |) |)));
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let γ0_0 :=
                                                M.SubPointer.get_struct_tuple_field (|
                                                  γ,
                                                  "core::option::Option::Some",
                                                  0
                                                |) in
                                              let γ1_0 :=
                                                M.SubPointer.get_tuple_field (| γ0_0, 0 |) in
                                              let γ1_1 :=
                                                M.SubPointer.get_tuple_field (| γ0_0, 1 |) in
                                              let round := M.copy (| Ty.path "usize", γ1_0 |) in
                                              let round_poly :=
                                                M.copy (|
                                                  Ty.apply
                                                    (Ty.path "&")
                                                    []
                                                    [
                                                      Ty.apply
                                                        (Ty.path
                                                          "openvm_stark_backend::poly::uni::UnivariatePolynomial")
                                                        []
                                                        [ F ]
                                                    ],
                                                  γ1_1
                                                |) in
                                              M.read (|
                                                let~ _ : Ty.tuple [] :=
                                                  M.match_operator (|
                                                    Ty.tuple [],
                                                    M.alloc (| Ty.tuple [], Value.Tuple [] |),
                                                    [
                                                      fun γ =>
                                                        ltac:(M.monadic
                                                          (let γ :=
                                                            M.use
                                                              (M.alloc (|
                                                                Ty.path "bool",
                                                                M.call_closure (|
                                                                  Ty.path "bool",
                                                                  BinOp.gt,
                                                                  [
                                                                    M.call_closure (|
                                                                      Ty.path "usize",
                                                                      M.get_associated_function (|
                                                                        Ty.apply
                                                                          (Ty.path
                                                                            "openvm_stark_backend::poly::uni::UnivariatePolynomial")
                                                                          []
                                                                          [ F ],
                                                                        "degree",
                                                                        [],
                                                                        []
                                                                      |),
                                                                      [
                                                                        M.borrow (|
                                                                          Pointer.Kind.Ref,
                                                                          M.deref (|
                                                                            M.read (| round_poly |)
                                                                          |)
                                                                        |)
                                                                      ]
                                                                    |);
                                                                    M.read (|
                                                                      get_constant (|
                                                                        "openvm_stark_backend::sumcheck::MAX_DEGREE",
                                                                        Ty.path "usize"
                                                                      |)
                                                                    |)
                                                                  ]
                                                                |)
                                                              |)) in
                                                          let _ :=
                                                            is_constant_or_break_match (|
                                                              M.read (| γ |),
                                                              Value.Bool true
                                                            |) in
                                                          M.never_to_any (|
                                                            M.read (|
                                                              M.return_ (|
                                                                Value.StructTuple
                                                                  "core::result::Result::Err"
                                                                  []
                                                                  [
                                                                    Ty.tuple
                                                                      [
                                                                        Ty.apply
                                                                          (Ty.path
                                                                            "alloc::vec::Vec")
                                                                          []
                                                                          [
                                                                            F;
                                                                            Ty.path
                                                                              "alloc::alloc::Global"
                                                                          ];
                                                                        F
                                                                      ];
                                                                    Ty.apply
                                                                      (Ty.path
                                                                        "openvm_stark_backend::sumcheck::SumcheckError")
                                                                      []
                                                                      [ F ]
                                                                  ]
                                                                  [
                                                                    Value.mkStructRecord
                                                                      "openvm_stark_backend::sumcheck::SumcheckError::DegreeInvalid"
                                                                      []
                                                                      [ F ]
                                                                      [
                                                                        ("round",
                                                                          M.read (| round |))
                                                                      ]
                                                                  ]
                                                              |)
                                                            |)
                                                          |)));
                                                      fun γ => ltac:(M.monadic (Value.Tuple []))
                                                    ]
                                                  |) in
                                                let~ sum : F :=
                                                  M.call_closure (|
                                                    F,
                                                    M.get_trait_method (|
                                                      "core::ops::arith::Add",
                                                      F,
                                                      [],
                                                      [ F ],
                                                      "add",
                                                      [],
                                                      []
                                                    |),
                                                    [
                                                      M.call_closure (|
                                                        F,
                                                        M.get_associated_function (|
                                                          Ty.apply
                                                            (Ty.path
                                                              "openvm_stark_backend::poly::uni::UnivariatePolynomial")
                                                            []
                                                            [ F ],
                                                          "evaluate",
                                                          [],
                                                          []
                                                        |),
                                                        [
                                                          M.borrow (|
                                                            Pointer.Kind.Ref,
                                                            M.deref (| M.read (| round_poly |) |)
                                                          |);
                                                          M.read (|
                                                            get_constant (|
                                                              "p3_field::field::FieldAlgebra::ZERO",
                                                              F
                                                            |)
                                                          |)
                                                        ]
                                                      |);
                                                      M.call_closure (|
                                                        F,
                                                        M.get_associated_function (|
                                                          Ty.apply
                                                            (Ty.path
                                                              "openvm_stark_backend::poly::uni::UnivariatePolynomial")
                                                            []
                                                            [ F ],
                                                          "evaluate",
                                                          [],
                                                          []
                                                        |),
                                                        [
                                                          M.borrow (|
                                                            Pointer.Kind.Ref,
                                                            M.deref (| M.read (| round_poly |) |)
                                                          |);
                                                          M.read (|
                                                            get_constant (|
                                                              "p3_field::field::FieldAlgebra::ONE",
                                                              F
                                                            |)
                                                          |)
                                                        ]
                                                      |)
                                                    ]
                                                  |) in
                                                let~ _ : Ty.tuple [] :=
                                                  M.match_operator (|
                                                    Ty.tuple [],
                                                    M.alloc (| Ty.tuple [], Value.Tuple [] |),
                                                    [
                                                      fun γ =>
                                                        ltac:(M.monadic
                                                          (let γ :=
                                                            M.use
                                                              (M.alloc (|
                                                                Ty.path "bool",
                                                                M.call_closure (|
                                                                  Ty.path "bool",
                                                                  M.get_trait_method (|
                                                                    "core::cmp::PartialEq",
                                                                    F,
                                                                    [],
                                                                    [ F ],
                                                                    "ne",
                                                                    [],
                                                                    []
                                                                  |),
                                                                  [
                                                                    M.borrow (|
                                                                      Pointer.Kind.Ref,
                                                                      claim
                                                                    |);
                                                                    M.borrow (|
                                                                      Pointer.Kind.Ref,
                                                                      sum
                                                                    |)
                                                                  ]
                                                                |)
                                                              |)) in
                                                          let _ :=
                                                            is_constant_or_break_match (|
                                                              M.read (| γ |),
                                                              Value.Bool true
                                                            |) in
                                                          M.never_to_any (|
                                                            M.read (|
                                                              M.return_ (|
                                                                Value.StructTuple
                                                                  "core::result::Result::Err"
                                                                  []
                                                                  [
                                                                    Ty.tuple
                                                                      [
                                                                        Ty.apply
                                                                          (Ty.path
                                                                            "alloc::vec::Vec")
                                                                          []
                                                                          [
                                                                            F;
                                                                            Ty.path
                                                                              "alloc::alloc::Global"
                                                                          ];
                                                                        F
                                                                      ];
                                                                    Ty.apply
                                                                      (Ty.path
                                                                        "openvm_stark_backend::sumcheck::SumcheckError")
                                                                      []
                                                                      [ F ]
                                                                  ]
                                                                  [
                                                                    Value.mkStructRecord
                                                                      "openvm_stark_backend::sumcheck::SumcheckError::SumInvalid"
                                                                      []
                                                                      [ F ]
                                                                      [
                                                                        ("claim",
                                                                          M.read (| claim |));
                                                                        ("sum", M.read (| sum |));
                                                                        ("round",
                                                                          M.read (| round |))
                                                                      ]
                                                                  ]
                                                              |)
                                                            |)
                                                          |)));
                                                      fun γ => ltac:(M.monadic (Value.Tuple []))
                                                    ]
                                                  |) in
                                                let~ _ : Ty.tuple [] :=
                                                  M.call_closure (|
                                                    Ty.tuple [],
                                                    M.get_trait_method (|
                                                      "p3_challenger::CanObserve",
                                                      impl_FieldChallenger_F_,
                                                      [],
                                                      [ F ],
                                                      "observe_slice",
                                                      [],
                                                      []
                                                    |),
                                                    [
                                                      M.borrow (|
                                                        Pointer.Kind.MutRef,
                                                        M.deref (| M.read (| challenger |) |)
                                                      |);
                                                      M.borrow (|
                                                        Pointer.Kind.Ref,
                                                        M.deref (|
                                                          M.call_closure (|
                                                            Ty.apply
                                                              (Ty.path "&")
                                                              []
                                                              [ Ty.apply (Ty.path "slice") [] [ F ]
                                                              ],
                                                            M.get_trait_method (|
                                                              "core::ops::deref::Deref",
                                                              Ty.apply
                                                                (Ty.path
                                                                  "openvm_stark_backend::poly::uni::UnivariatePolynomial")
                                                                []
                                                                [ F ],
                                                              [],
                                                              [],
                                                              "deref",
                                                              [],
                                                              []
                                                            |),
                                                            [
                                                              M.borrow (|
                                                                Pointer.Kind.Ref,
                                                                M.deref (|
                                                                  M.read (| round_poly |)
                                                                |)
                                                              |)
                                                            ]
                                                          |)
                                                        |)
                                                      |)
                                                    ]
                                                  |) in
                                                let~ challenge : F :=
                                                  M.call_closure (|
                                                    F,
                                                    M.get_trait_method (|
                                                      "p3_challenger::FieldChallenger",
                                                      impl_FieldChallenger_F_,
                                                      [],
                                                      [ F ],
                                                      "sample_ext_element",
                                                      [],
                                                      [ F ]
                                                    |),
                                                    [
                                                      M.borrow (|
                                                        Pointer.Kind.MutRef,
                                                        M.deref (| M.read (| challenger |) |)
                                                      |)
                                                    ]
                                                  |) in
                                                let~ _ : Ty.tuple [] :=
                                                  M.write (|
                                                    claim,
                                                    M.call_closure (|
                                                      F,
                                                      M.get_associated_function (|
                                                        Ty.apply
                                                          (Ty.path
                                                            "openvm_stark_backend::poly::uni::UnivariatePolynomial")
                                                          []
                                                          [ F ],
                                                        "evaluate",
                                                        [],
                                                        []
                                                      |),
                                                      [
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.deref (| M.read (| round_poly |) |)
                                                        |);
                                                        M.read (| challenge |)
                                                      ]
                                                    |)
                                                  |) in
                                                let~ _ : Ty.tuple [] :=
                                                  M.call_closure (|
                                                    Ty.tuple [],
                                                    M.get_associated_function (|
                                                      Ty.apply
                                                        (Ty.path "alloc::vec::Vec")
                                                        []
                                                        [ F; Ty.path "alloc::alloc::Global" ],
                                                      "push",
                                                      [],
                                                      []
                                                    |),
                                                    [
                                                      M.borrow (|
                                                        Pointer.Kind.MutRef,
                                                        assignment
                                                      |);
                                                      M.read (| challenge |)
                                                    ]
                                                  |) in
                                                M.alloc (| Ty.tuple [], Value.Tuple [] |)
                                              |)))
                                        ]
                                      |) in
                                    M.alloc (| Ty.tuple [], Value.Tuple [] |)))
                                |)
                              |)))
                        ]
                      |)
                    |))
                |) in
              M.alloc (|
                Ty.apply
                  (Ty.path "core::result::Result")
                  []
                  [
                    Ty.tuple
                      [
                        Ty.apply
                          (Ty.path "alloc::vec::Vec")
                          []
                          [ F; Ty.path "alloc::alloc::Global" ];
                        F
                      ];
                    Ty.apply (Ty.path "openvm_stark_backend::sumcheck::SumcheckError") [] [ F ]
                  ],
                Value.StructTuple
                  "core::result::Result::Ok"
                  []
                  [
                    Ty.tuple
                      [
                        Ty.apply
                          (Ty.path "alloc::vec::Vec")
                          []
                          [ F; Ty.path "alloc::alloc::Global" ];
                        F
                      ];
                    Ty.apply (Ty.path "openvm_stark_backend::sumcheck::SumcheckError") [] [ F ]
                  ]
                  [ Value.Tuple [ M.read (| assignment |); M.read (| claim |) ] ]
              |)
            |)))
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_partially_verify :
    M.IsFunction.C "openvm_stark_backend::sumcheck::partially_verify" partially_verify.
  Admitted.
  Global Typeclasses Opaque partially_verify.
  
  (* StructRecord
    {
      name := "SumcheckProof";
      const_params := [];
      ty_params := [ "F" ];
      fields :=
        [
          ("round_polys",
            Ty.apply
              (Ty.path "alloc::vec::Vec")
              []
              [
                Ty.apply (Ty.path "openvm_stark_backend::poly::uni::UnivariatePolynomial") [] [ F ];
                Ty.path "alloc::alloc::Global"
              ])
        ];
    } *)
  
  Module Impl_core_fmt_Debug_where_core_fmt_Debug_F_for_openvm_stark_backend_sumcheck_SumcheckProof_F.
    Definition Self (F : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "openvm_stark_backend::sumcheck::SumcheckProof") [] [ F ].
    
    (* Debug *)
    Definition fmt (F : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self F in
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply
                (Ty.path "&")
                []
                [ Ty.apply (Ty.path "openvm_stark_backend::sumcheck::SumcheckProof") [] [ F ] ],
              self
            |) in
          let f :=
            M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "core::fmt::Formatter" ], f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_associated_function (|
              Ty.path "core::fmt::Formatter",
              "debug_struct_field1_finish",
              [],
              []
            |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "SumcheckProof" |) |) |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "round_polys" |) |) |);
              M.call_closure (|
                Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ],
                M.pointer_coercion
                  M.PointerCoercion.Unsize
                  (Ty.apply
                    (Ty.path "&")
                    []
                    [
                      Ty.apply
                        (Ty.path "&")
                        []
                        [
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            []
                            [
                              Ty.apply
                                (Ty.path "openvm_stark_backend::poly::uni::UnivariatePolynomial")
                                []
                                [ F ];
                              Ty.path "alloc::alloc::Global"
                            ]
                        ]
                    ])
                  (Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ]),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          Ty.apply
                            (Ty.path "&")
                            []
                            [
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                []
                                [
                                  Ty.apply
                                    (Ty.path
                                      "openvm_stark_backend::poly::uni::UnivariatePolynomial")
                                    []
                                    [ F ];
                                  Ty.path "alloc::alloc::Global"
                                ]
                            ],
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "openvm_stark_backend::sumcheck::SumcheckProof",
                              "round_polys"
                            |)
                          |)
                        |)
                      |)
                    |)
                  |)
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (F : Ty.t),
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self F)
        (* Instance *) [ ("fmt", InstanceField.Method (fmt F)) ].
  End Impl_core_fmt_Debug_where_core_fmt_Debug_F_for_openvm_stark_backend_sumcheck_SumcheckProof_F.
  
  Module Impl_core_clone_Clone_where_core_clone_Clone_F_for_openvm_stark_backend_sumcheck_SumcheckProof_F.
    Definition Self (F : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "openvm_stark_backend::sumcheck::SumcheckProof") [] [ F ].
    
    (* Clone *)
    Definition clone (F : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self F in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply
                (Ty.path "&")
                []
                [ Ty.apply (Ty.path "openvm_stark_backend::sumcheck::SumcheckProof") [] [ F ] ],
              self
            |) in
          Value.mkStructRecord
            "openvm_stark_backend::sumcheck::SumcheckProof"
            []
            [ F ]
            [
              ("round_polys",
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [
                      Ty.apply
                        (Ty.path "openvm_stark_backend::poly::uni::UnivariatePolynomial")
                        []
                        [ F ];
                      Ty.path "alloc::alloc::Global"
                    ],
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      []
                      [
                        Ty.apply
                          (Ty.path "openvm_stark_backend::poly::uni::UnivariatePolynomial")
                          []
                          [ F ];
                        Ty.path "alloc::alloc::Global"
                      ],
                    [],
                    [],
                    "clone",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "openvm_stark_backend::sumcheck::SumcheckProof",
                            "round_polys"
                          |)
                        |)
                      |)
                    |)
                  ]
                |))
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (F : Ty.t),
      M.IsTraitInstance
        "core::clone::Clone"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self F)
        (* Instance *) [ ("clone", InstanceField.Method (clone F)) ].
  End Impl_core_clone_Clone_where_core_clone_Clone_F_for_openvm_stark_backend_sumcheck_SumcheckProof_F.
  
  Definition value_MAX_DEGREE (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    ltac:(M.monadic (M.alloc (| Ty.path "usize", Value.Integer IntegerKind.Usize 3 |))).
  
  Global Instance Instance_IsConstant_value_MAX_DEGREE :
    M.IsFunction.C "openvm_stark_backend::sumcheck::MAX_DEGREE" value_MAX_DEGREE.
  Admitted.
  Global Typeclasses Opaque value_MAX_DEGREE.
  
  (*
  Enum SumcheckError
  {
    const_params := [];
    ty_params := [ "F" ];
    variants :=
      [
        {
          name := "DegreeInvalid";
          item := StructRecord [ ("round", Ty.path "usize") ];
        };
        {
          name := "SumInvalid";
          item := StructRecord [ ("claim", F); ("sum", F); ("round", Ty.path "usize") ];
        }
      ];
  }
  *)
  
  Axiom IsDiscriminant_SumcheckError_DegreeInvalid :
    M.IsDiscriminant "openvm_stark_backend::sumcheck::SumcheckError::DegreeInvalid" 0.
  Axiom IsDiscriminant_SumcheckError_SumInvalid :
    M.IsDiscriminant "openvm_stark_backend::sumcheck::SumcheckError::SumInvalid" 1.
  
  Module Impl_core_error_Error_where_core_fmt_Debug_openvm_stark_backend_sumcheck_SumcheckError_F_where_core_fmt_Display_openvm_stark_backend_sumcheck_SumcheckError_F_for_openvm_stark_backend_sumcheck_SumcheckError_F.
    Definition Self (F : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "openvm_stark_backend::sumcheck::SumcheckError") [] [ F ].
    
    Axiom Implements :
      forall (F : Ty.t),
      M.IsTraitInstance
        "core::error::Error"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self F)
        (* Instance *) [].
  End Impl_core_error_Error_where_core_fmt_Debug_openvm_stark_backend_sumcheck_SumcheckError_F_where_core_fmt_Display_openvm_stark_backend_sumcheck_SumcheckError_F_for_openvm_stark_backend_sumcheck_SumcheckError_F.
  
  Module Impl_core_fmt_Display_where_core_fmt_Display_F_for_openvm_stark_backend_sumcheck_SumcheckError_F.
    Definition Self (F : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "openvm_stark_backend::sumcheck::SumcheckError") [] [ F ].
    
    (* Error *)
    Definition fmt (F : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self F in
      match ε, τ, α with
      | [], [], [ self; __formatter ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply
                (Ty.path "&")
                []
                [ Ty.apply (Ty.path "openvm_stark_backend::sumcheck::SumcheckError") [] [ F ] ],
              self
            |) in
          let __formatter :=
            M.alloc (|
              Ty.apply (Ty.path "&mut") [] [ Ty.path "core::fmt::Formatter" ],
              __formatter
            |) in
          M.match_operator (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            self,
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ := M.deref (| M.read (| γ |) |) in
                  let γ1_0 :=
                    M.SubPointer.get_struct_record_field (|
                      γ,
                      "openvm_stark_backend::sumcheck::SumcheckError::DegreeInvalid",
                      "round"
                    |) in
                  let round := M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "usize" ], γ1_0 |) in
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                    M.get_associated_function (|
                      Ty.path "core::fmt::Formatter",
                      "write_fmt",
                      [],
                      []
                    |),
                    [
                      M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| __formatter |) |) |);
                      M.call_closure (|
                        Ty.path "core::fmt::Arguments",
                        M.get_associated_function (|
                          Ty.path "core::fmt::Arguments",
                          "new_v1",
                          [ Value.Integer IntegerKind.Usize 2; Value.Integer IntegerKind.Usize 1 ],
                          []
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (|
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.alloc (|
                                  Ty.apply
                                    (Ty.path "array")
                                    [ Value.Integer IntegerKind.Usize 2 ]
                                    [ Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ],
                                  Value.Array
                                    [
                                      mk_str (| "degree of the polynomial in round " |);
                                      mk_str (| " is too high" |)
                                    ]
                                |)
                              |)
                            |)
                          |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (|
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.alloc (|
                                  Ty.apply
                                    (Ty.path "array")
                                    [ Value.Integer IntegerKind.Usize 1 ]
                                    [ Ty.path "core::fmt::rt::Argument" ],
                                  Value.Array
                                    [
                                      M.call_closure (|
                                        Ty.path "core::fmt::rt::Argument",
                                        M.get_associated_function (|
                                          Ty.path "core::fmt::rt::Argument",
                                          "new_display",
                                          [],
                                          [ Ty.apply (Ty.path "&") [] [ Ty.path "usize" ] ]
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (|
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.alloc (|
                                                  Ty.apply (Ty.path "&") [] [ Ty.path "usize" ],
                                                  M.call_closure (|
                                                    Ty.apply (Ty.path "&") [] [ Ty.path "usize" ],
                                                    M.get_trait_method (|
                                                      "thiserror::display::AsDisplay",
                                                      Ty.apply (Ty.path "&") [] [ Ty.path "usize" ],
                                                      [],
                                                      [],
                                                      "as_display",
                                                      [],
                                                      []
                                                    |),
                                                    [ M.borrow (| Pointer.Kind.Ref, round |) ]
                                                  |)
                                                |)
                                              |)
                                            |)
                                          |)
                                        ]
                                      |)
                                    ]
                                |)
                              |)
                            |)
                          |)
                        ]
                      |)
                    ]
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let γ := M.deref (| M.read (| γ |) |) in
                  let γ1_0 :=
                    M.SubPointer.get_struct_record_field (|
                      γ,
                      "openvm_stark_backend::sumcheck::SumcheckError::SumInvalid",
                      "claim"
                    |) in
                  let γ1_1 :=
                    M.SubPointer.get_struct_record_field (|
                      γ,
                      "openvm_stark_backend::sumcheck::SumcheckError::SumInvalid",
                      "sum"
                    |) in
                  let γ1_2 :=
                    M.SubPointer.get_struct_record_field (|
                      γ,
                      "openvm_stark_backend::sumcheck::SumcheckError::SumInvalid",
                      "round"
                    |) in
                  let claim := M.alloc (| Ty.apply (Ty.path "&") [] [ F ], γ1_0 |) in
                  let sum := M.alloc (| Ty.apply (Ty.path "&") [] [ F ], γ1_1 |) in
                  let round := M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "usize" ], γ1_2 |) in
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                    M.get_associated_function (|
                      Ty.path "core::fmt::Formatter",
                      "write_fmt",
                      [],
                      []
                    |),
                    [
                      M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| __formatter |) |) |);
                      M.call_closure (|
                        Ty.path "core::fmt::Arguments",
                        M.get_associated_function (|
                          Ty.path "core::fmt::Arguments",
                          "new_v1",
                          [ Value.Integer IntegerKind.Usize 4; Value.Integer IntegerKind.Usize 3 ],
                          []
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (|
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.alloc (|
                                  Ty.apply
                                    (Ty.path "array")
                                    [ Value.Integer IntegerKind.Usize 4 ]
                                    [ Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ],
                                  Value.Array
                                    [
                                      mk_str (| "sum does not match the claim in round " |);
                                      mk_str (| " (sum " |);
                                      mk_str (| ", claim " |);
                                      mk_str (| ")" |)
                                    ]
                                |)
                              |)
                            |)
                          |);
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (|
                              M.borrow (|
                                Pointer.Kind.Ref,
                                M.alloc (|
                                  Ty.apply
                                    (Ty.path "array")
                                    [ Value.Integer IntegerKind.Usize 3 ]
                                    [ Ty.path "core::fmt::rt::Argument" ],
                                  Value.Array
                                    [
                                      M.call_closure (|
                                        Ty.path "core::fmt::rt::Argument",
                                        M.get_associated_function (|
                                          Ty.path "core::fmt::rt::Argument",
                                          "new_display",
                                          [],
                                          [ Ty.apply (Ty.path "&") [] [ Ty.path "usize" ] ]
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (|
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.alloc (|
                                                  Ty.apply (Ty.path "&") [] [ Ty.path "usize" ],
                                                  M.call_closure (|
                                                    Ty.apply (Ty.path "&") [] [ Ty.path "usize" ],
                                                    M.get_trait_method (|
                                                      "thiserror::display::AsDisplay",
                                                      Ty.apply (Ty.path "&") [] [ Ty.path "usize" ],
                                                      [],
                                                      [],
                                                      "as_display",
                                                      [],
                                                      []
                                                    |),
                                                    [ M.borrow (| Pointer.Kind.Ref, round |) ]
                                                  |)
                                                |)
                                              |)
                                            |)
                                          |)
                                        ]
                                      |);
                                      M.call_closure (|
                                        Ty.path "core::fmt::rt::Argument",
                                        M.get_associated_function (|
                                          Ty.path "core::fmt::rt::Argument",
                                          "new_display",
                                          [],
                                          [ Ty.apply (Ty.path "&") [] [ F ] ]
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (|
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.alloc (|
                                                  Ty.apply (Ty.path "&") [] [ F ],
                                                  M.call_closure (|
                                                    Ty.apply (Ty.path "&") [] [ F ],
                                                    M.get_trait_method (|
                                                      "thiserror::display::AsDisplay",
                                                      Ty.apply (Ty.path "&") [] [ F ],
                                                      [],
                                                      [],
                                                      "as_display",
                                                      [],
                                                      []
                                                    |),
                                                    [ M.borrow (| Pointer.Kind.Ref, sum |) ]
                                                  |)
                                                |)
                                              |)
                                            |)
                                          |)
                                        ]
                                      |);
                                      M.call_closure (|
                                        Ty.path "core::fmt::rt::Argument",
                                        M.get_associated_function (|
                                          Ty.path "core::fmt::rt::Argument",
                                          "new_display",
                                          [],
                                          [ Ty.apply (Ty.path "&") [] [ F ] ]
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (|
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.alloc (|
                                                  Ty.apply (Ty.path "&") [] [ F ],
                                                  M.call_closure (|
                                                    Ty.apply (Ty.path "&") [] [ F ],
                                                    M.get_trait_method (|
                                                      "thiserror::display::AsDisplay",
                                                      Ty.apply (Ty.path "&") [] [ F ],
                                                      [],
                                                      [],
                                                      "as_display",
                                                      [],
                                                      []
                                                    |),
                                                    [ M.borrow (| Pointer.Kind.Ref, claim |) ]
                                                  |)
                                                |)
                                              |)
                                            |)
                                          |)
                                        ]
                                      |)
                                    ]
                                |)
                              |)
                            |)
                          |)
                        ]
                      |)
                    ]
                  |)))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (F : Ty.t),
      M.IsTraitInstance
        "core::fmt::Display"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self F)
        (* Instance *) [ ("fmt", InstanceField.Method (fmt F)) ].
  End Impl_core_fmt_Display_where_core_fmt_Display_F_for_openvm_stark_backend_sumcheck_SumcheckError_F.
  
  Module Impl_core_fmt_Debug_where_core_fmt_Debug_F_for_openvm_stark_backend_sumcheck_SumcheckError_F.
    Definition Self (F : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "openvm_stark_backend::sumcheck::SumcheckError") [] [ F ].
    
    (* Debug *)
    Definition fmt (F : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self F in
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply
                (Ty.path "&")
                []
                [ Ty.apply (Ty.path "openvm_stark_backend::sumcheck::SumcheckError") [] [ F ] ],
              self
            |) in
          let f :=
            M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "core::fmt::Formatter" ], f |) in
          M.match_operator (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            self,
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ := M.deref (| M.read (| γ |) |) in
                  let γ1_0 :=
                    M.SubPointer.get_struct_record_field (|
                      γ,
                      "openvm_stark_backend::sumcheck::SumcheckError::DegreeInvalid",
                      "round"
                    |) in
                  let __self_0 :=
                    M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "usize" ], γ1_0 |) in
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                    M.get_associated_function (|
                      Ty.path "core::fmt::Formatter",
                      "debug_struct_field1_finish",
                      [],
                      []
                    |),
                    [
                      M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                      M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "DegreeInvalid" |) |) |);
                      M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "round" |) |) |);
                      M.call_closure (|
                        Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ],
                        M.pointer_coercion
                          M.PointerCoercion.Unsize
                          (Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.apply (Ty.path "&") [] [ Ty.path "usize" ] ])
                          (Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ]),
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| M.borrow (| Pointer.Kind.Ref, __self_0 |) |)
                          |)
                        ]
                      |)
                    ]
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (let γ := M.deref (| M.read (| γ |) |) in
                  let γ1_0 :=
                    M.SubPointer.get_struct_record_field (|
                      γ,
                      "openvm_stark_backend::sumcheck::SumcheckError::SumInvalid",
                      "claim"
                    |) in
                  let γ1_1 :=
                    M.SubPointer.get_struct_record_field (|
                      γ,
                      "openvm_stark_backend::sumcheck::SumcheckError::SumInvalid",
                      "sum"
                    |) in
                  let γ1_2 :=
                    M.SubPointer.get_struct_record_field (|
                      γ,
                      "openvm_stark_backend::sumcheck::SumcheckError::SumInvalid",
                      "round"
                    |) in
                  let __self_0 := M.alloc (| Ty.apply (Ty.path "&") [] [ F ], γ1_0 |) in
                  let __self_1 := M.alloc (| Ty.apply (Ty.path "&") [] [ F ], γ1_1 |) in
                  let __self_2 :=
                    M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "usize" ], γ1_2 |) in
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                    M.get_associated_function (|
                      Ty.path "core::fmt::Formatter",
                      "debug_struct_field3_finish",
                      [],
                      []
                    |),
                    [
                      M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                      M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "SumInvalid" |) |) |);
                      M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "claim" |) |) |);
                      M.call_closure (|
                        Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ],
                        M.pointer_coercion
                          M.PointerCoercion.Unsize
                          (Ty.apply (Ty.path "&") [] [ F ])
                          (Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ]),
                        [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_0 |) |) |) ]
                      |);
                      M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "sum" |) |) |);
                      M.call_closure (|
                        Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ],
                        M.pointer_coercion
                          M.PointerCoercion.Unsize
                          (Ty.apply (Ty.path "&") [] [ F ])
                          (Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ]),
                        [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| __self_1 |) |) |) ]
                      |);
                      M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "round" |) |) |);
                      M.call_closure (|
                        Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ],
                        M.pointer_coercion
                          M.PointerCoercion.Unsize
                          (Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.apply (Ty.path "&") [] [ Ty.path "usize" ] ])
                          (Ty.apply
                            (Ty.path "&")
                            []
                            [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ]),
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.deref (| M.borrow (| Pointer.Kind.Ref, __self_2 |) |)
                          |)
                        ]
                      |)
                    ]
                  |)))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (F : Ty.t),
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self F)
        (* Instance *) [ ("fmt", InstanceField.Method (fmt F)) ].
  End Impl_core_fmt_Debug_where_core_fmt_Debug_F_for_openvm_stark_backend_sumcheck_SumcheckError_F.
  
  Axiom RoundIndex : (Ty.path "openvm_stark_backend::sumcheck::RoundIndex") = (Ty.path "usize").
End sumcheck.
