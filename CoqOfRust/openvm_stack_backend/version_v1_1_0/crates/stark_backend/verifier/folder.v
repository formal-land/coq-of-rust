(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module verifier.
  Module folder.
    Axiom VerifierConstraintFolder :
      forall (SC : Ty.t),
      (Ty.apply
          (Ty.path "openvm_stark_backend::verifier::folder::VerifierConstraintFolder")
          []
          [ SC ]) =
        (Ty.apply
          (Ty.path "openvm_stark_backend::verifier::folder::GenericVerifierConstraintFolder")
          []
          [
            Ty.associated_in_trait
              "p3_commit::domain::PolynomialSpace"
              []
              []
              (Ty.associated_in_trait
                "p3_commit::pcs::Pcs"
                []
                [
                  Ty.associated_in_trait
                    "openvm_stark_backend::config::StarkGenericConfig"
                    []
                    []
                    SC
                    "Challenge";
                  Ty.associated_in_trait
                    "openvm_stark_backend::config::StarkGenericConfig"
                    []
                    []
                    SC
                    "Challenger"
                ]
                (Ty.associated_in_trait
                  "openvm_stark_backend::config::StarkGenericConfig"
                  []
                  []
                  SC
                  "Pcs")
                "Domain")
              "Val";
            Ty.associated_in_trait
              "openvm_stark_backend::config::StarkGenericConfig"
              []
              []
              SC
              "Challenge";
            Ty.associated_in_trait
              "p3_commit::domain::PolynomialSpace"
              []
              []
              (Ty.associated_in_trait
                "p3_commit::pcs::Pcs"
                []
                [
                  Ty.associated_in_trait
                    "openvm_stark_backend::config::StarkGenericConfig"
                    []
                    []
                    SC
                    "Challenge";
                  Ty.associated_in_trait
                    "openvm_stark_backend::config::StarkGenericConfig"
                    []
                    []
                    SC
                    "Challenger"
                ]
                (Ty.associated_in_trait
                  "openvm_stark_backend::config::StarkGenericConfig"
                  []
                  []
                  SC
                  "Pcs")
                "Domain")
              "Val";
            Ty.associated_in_trait
              "openvm_stark_backend::config::StarkGenericConfig"
              []
              []
              SC
              "Challenge";
            Ty.associated_in_trait
              "openvm_stark_backend::config::StarkGenericConfig"
              []
              []
              SC
              "Challenge"
          ]).
    
    (* StructRecord
      {
        name := "GenericVerifierConstraintFolder";
        const_params := [];
        ty_params := [ "F"; "EF"; "PubVar"; "Var"; "Expr" ];
        fields :=
          [
            ("preprocessed",
              Ty.apply
                (Ty.path "p3_matrix::stack::VerticalPair")
                []
                [
                  Ty.apply
                    (Ty.path "p3_matrix::dense::DenseMatrix")
                    []
                    [ Var; Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Var ] ] ];
                  Ty.apply
                    (Ty.path "p3_matrix::dense::DenseMatrix")
                    []
                    [ Var; Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Var ] ] ]
                ]);
            ("partitioned_main",
              Ty.apply
                (Ty.path "alloc::vec::Vec")
                []
                [
                  Ty.apply
                    (Ty.path "p3_matrix::stack::VerticalPair")
                    []
                    [
                      Ty.apply
                        (Ty.path "p3_matrix::dense::DenseMatrix")
                        []
                        [ Var; Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Var ] ]
                        ];
                      Ty.apply
                        (Ty.path "p3_matrix::dense::DenseMatrix")
                        []
                        [ Var; Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Var ] ] ]
                    ];
                  Ty.path "alloc::alloc::Global"
                ]);
            ("after_challenge",
              Ty.apply
                (Ty.path "alloc::vec::Vec")
                []
                [
                  Ty.apply
                    (Ty.path "p3_matrix::stack::VerticalPair")
                    []
                    [
                      Ty.apply
                        (Ty.path "p3_matrix::dense::DenseMatrix")
                        []
                        [ Var; Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Var ] ]
                        ];
                      Ty.apply
                        (Ty.path "p3_matrix::dense::DenseMatrix")
                        []
                        [ Var; Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Var ] ] ]
                    ];
                  Ty.path "alloc::alloc::Global"
                ]);
            ("challenges",
              Ty.apply
                (Ty.path "&")
                []
                [
                  Ty.apply
                    (Ty.path "slice")
                    []
                    [
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        []
                        [ Var; Ty.path "alloc::alloc::Global" ]
                    ]
                ]);
            ("is_first_row", Var);
            ("is_last_row", Var);
            ("is_transition", Var);
            ("alpha", Var);
            ("accumulator", Expr);
            ("public_values",
              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ PubVar ] ]);
            ("exposed_values_after_challenge",
              Ty.apply
                (Ty.path "&")
                []
                [
                  Ty.apply
                    (Ty.path "slice")
                    []
                    [
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        []
                        [ Var; Ty.path "alloc::alloc::Global" ]
                    ]
                ]);
            ("_marker", Ty.apply (Ty.path "core::marker::PhantomData") [] [ Ty.tuple [ F; EF ] ])
          ];
      } *)
    
    Module Impl_openvm_stark_backend_verifier_folder_GenericVerifierConstraintFolder_F_EF_PubVar_Var_Expr.
      Definition Self (F EF PubVar Var Expr : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "openvm_stark_backend::verifier::folder::GenericVerifierConstraintFolder")
          []
          [ F; EF; PubVar; Var; Expr ].
      
      (*
          pub fn eval_constraints(&mut self, constraints: &SymbolicExpressionDag<F>) {
              let dag = constraints;
              // node_idx -> evaluation
              // We do a simple serial evaluation in topological order.
              // This can be parallelized if necessary.
              let exprs = self.eval_nodes(&dag.nodes);
              for &idx in &dag.constraint_idx {
                  self.assert_zero(exprs[idx].clone());
              }
          }
      *)
      Definition eval_constraints
          (F EF PubVar Var Expr : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self F EF PubVar Var Expr in
        match ε, τ, α with
        | [], [], [ self; constraints ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&mut")
                  []
                  [
                    Ty.apply
                      (Ty.path
                        "openvm_stark_backend::verifier::folder::GenericVerifierConstraintFolder")
                      []
                      [ F; EF; PubVar; Var; Expr ]
                  ],
                self
              |) in
            let constraints :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path
                        "openvm_stark_backend::air_builders::symbolic::dag::SymbolicExpressionDag")
                      []
                      [ F ]
                  ],
                constraints
              |) in
            M.read (|
              let~ dag :
                  Ty.apply
                    (Ty.path "&")
                    []
                    [
                      Ty.apply
                        (Ty.path
                          "openvm_stark_backend::air_builders::symbolic::dag::SymbolicExpressionDag")
                        []
                        [ F ]
                    ] :=
                M.read (| constraints |) in
              let~ exprs :
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [ Expr; Ty.path "alloc::alloc::Global" ] :=
                M.call_closure (|
                  Ty.apply (Ty.path "alloc::vec::Vec") [] [ Expr; Ty.path "alloc::alloc::Global" ],
                  M.get_trait_method (|
                    "openvm_stark_backend::air_builders::symbolic::symbolic_expression::SymbolicEvaluator",
                    Ty.apply
                      (Ty.path
                        "openvm_stark_backend::verifier::folder::GenericVerifierConstraintFolder")
                      []
                      [ F; EF; PubVar; Var; Expr ],
                    [],
                    [ F; Expr ],
                    "eval_nodes",
                    [],
                    []
                  |),
                  [
                    M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "&")
                            []
                            [
                              Ty.apply
                                (Ty.path "slice")
                                []
                                [
                                  Ty.apply
                                    (Ty.path
                                      "openvm_stark_backend::air_builders::symbolic::dag::SymbolicExpressionNode")
                                    []
                                    [ F ]
                                ]
                            ],
                          M.get_trait_method (|
                            "core::ops::deref::Deref",
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              []
                              [
                                Ty.apply
                                  (Ty.path
                                    "openvm_stark_backend::air_builders::symbolic::dag::SymbolicExpressionNode")
                                  []
                                  [ F ];
                                Ty.path "alloc::alloc::Global"
                              ],
                            [],
                            [],
                            "deref",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| dag |) |),
                                    "openvm_stark_backend::air_builders::symbolic::dag::SymbolicExpressionDag",
                                    "nodes"
                                  |)
                                |)
                              |)
                            |)
                          ]
                        |)
                      |)
                    |)
                  ]
                |) in
              M.use
                (M.alloc (|
                  Ty.tuple [],
                  M.match_operator (|
                    Ty.tuple [],
                    M.alloc (|
                      Ty.apply (Ty.path "core::slice::iter::Iter") [] [ Ty.path "usize" ],
                      M.call_closure (|
                        Ty.apply (Ty.path "core::slice::iter::Iter") [] [ Ty.path "usize" ],
                        M.get_trait_method (|
                          "core::iter::traits::collect::IntoIterator",
                          Ty.apply
                            (Ty.path "&")
                            []
                            [
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                []
                                [ Ty.path "usize"; Ty.path "alloc::alloc::Global" ]
                            ],
                          [],
                          [],
                          "into_iter",
                          [],
                          []
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| dag |) |),
                              "openvm_stark_backend::air_builders::symbolic::dag::SymbolicExpressionDag",
                              "constraint_idx"
                            |)
                          |)
                        ]
                      |)
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let iter :=
                            M.copy (|
                              Ty.apply (Ty.path "core::slice::iter::Iter") [] [ Ty.path "usize" ],
                              γ
                            |) in
                          M.read (|
                            M.loop (|
                              Ty.tuple [],
                              ltac:(M.monadic
                                (let~ _ : Ty.tuple [] :=
                                  M.match_operator (|
                                    Ty.tuple [],
                                    M.alloc (|
                                      Ty.apply
                                        (Ty.path "core::option::Option")
                                        []
                                        [ Ty.apply (Ty.path "&") [] [ Ty.path "usize" ] ],
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "core::option::Option")
                                          []
                                          [ Ty.apply (Ty.path "&") [] [ Ty.path "usize" ] ],
                                        M.get_trait_method (|
                                          "core::iter::traits::iterator::Iterator",
                                          Ty.apply
                                            (Ty.path "core::slice::iter::Iter")
                                            []
                                            [ Ty.path "usize" ],
                                          [],
                                          [],
                                          "next",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.MutRef,
                                            M.deref (| M.borrow (| Pointer.Kind.MutRef, iter |) |)
                                          |)
                                        ]
                                      |)
                                    |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let _ :=
                                            M.is_struct_tuple (|
                                              γ,
                                              "core::option::Option::None"
                                            |) in
                                          M.never_to_any (| M.read (| M.break (||) |) |)));
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let γ0_0 :=
                                            M.SubPointer.get_struct_tuple_field (|
                                              γ,
                                              "core::option::Option::Some",
                                              0
                                            |) in
                                          let γ0_0 := M.deref (| M.read (| γ0_0 |) |) in
                                          let idx := M.copy (| Ty.path "usize", γ0_0 |) in
                                          M.read (|
                                            let~ _ : Ty.tuple [] :=
                                              M.call_closure (|
                                                Ty.tuple [],
                                                M.get_associated_function (|
                                                  Ty.apply
                                                    (Ty.path
                                                      "openvm_stark_backend::verifier::folder::GenericVerifierConstraintFolder")
                                                    []
                                                    [ F; EF; PubVar; Var; Expr ],
                                                  "assert_zero",
                                                  [],
                                                  [ Expr ]
                                                |),
                                                [
                                                  M.borrow (|
                                                    Pointer.Kind.MutRef,
                                                    M.deref (| M.read (| self |) |)
                                                  |);
                                                  M.call_closure (|
                                                    Expr,
                                                    M.get_trait_method (|
                                                      "core::clone::Clone",
                                                      Expr,
                                                      [],
                                                      [],
                                                      "clone",
                                                      [],
                                                      []
                                                    |),
                                                    [
                                                      M.borrow (|
                                                        Pointer.Kind.Ref,
                                                        M.deref (|
                                                          M.call_closure (|
                                                            Ty.apply (Ty.path "&") [] [ Expr ],
                                                            M.get_trait_method (|
                                                              "core::ops::index::Index",
                                                              Ty.apply
                                                                (Ty.path "alloc::vec::Vec")
                                                                []
                                                                [
                                                                  Expr;
                                                                  Ty.path "alloc::alloc::Global"
                                                                ],
                                                              [],
                                                              [ Ty.path "usize" ],
                                                              "index",
                                                              [],
                                                              []
                                                            |),
                                                            [
                                                              M.borrow (|
                                                                Pointer.Kind.Ref,
                                                                exprs
                                                              |);
                                                              M.read (| idx |)
                                                            ]
                                                          |)
                                                        |)
                                                      |)
                                                    ]
                                                  |)
                                                ]
                                              |) in
                                            M.alloc (| Ty.tuple [], Value.Tuple [] |)
                                          |)))
                                    ]
                                  |) in
                                M.alloc (| Ty.tuple [], Value.Tuple [] |)))
                            |)
                          |)))
                    ]
                  |)
                |))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_eval_constraints :
        forall (F EF PubVar Var Expr : Ty.t),
        M.IsAssociatedFunction.C
          (Self F EF PubVar Var Expr)
          "eval_constraints"
          (eval_constraints F EF PubVar Var Expr).
      Admitted.
      Global Typeclasses Opaque eval_constraints.
      
      (*
          pub fn assert_zero(&mut self, x: impl Into<Expr>) {
              let x = x.into();
              self.accumulator *= self.alpha;
              self.accumulator += x;
          }
      *)
      Definition assert_zero
          (F EF PubVar Var Expr : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self F EF PubVar Var Expr in
        match ε, τ, α with
        | [], [ impl_Into_Expr_ ], [ self; x ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&mut")
                  []
                  [
                    Ty.apply
                      (Ty.path
                        "openvm_stark_backend::verifier::folder::GenericVerifierConstraintFolder")
                      []
                      [ F; EF; PubVar; Var; Expr ]
                  ],
                self
              |) in
            let x := M.alloc (| impl_Into_Expr_, x |) in
            M.read (|
              let~ x : Expr :=
                M.call_closure (|
                  Expr,
                  M.get_trait_method (|
                    "core::convert::Into",
                    impl_Into_Expr_,
                    [],
                    [ Expr ],
                    "into",
                    [],
                    []
                  |),
                  [ M.read (| x |) ]
                |) in
              let~ _ : Ty.tuple [] :=
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "core::ops::arith::MulAssign",
                    Expr,
                    [],
                    [ Var ],
                    "mul_assign",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "openvm_stark_backend::verifier::folder::GenericVerifierConstraintFolder",
                        "accumulator"
                      |)
                    |);
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "openvm_stark_backend::verifier::folder::GenericVerifierConstraintFolder",
                        "alpha"
                      |)
                    |)
                  ]
                |) in
              let~ _ : Ty.tuple [] :=
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "core::ops::arith::AddAssign",
                    Expr,
                    [],
                    [ Expr ],
                    "add_assign",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "openvm_stark_backend::verifier::folder::GenericVerifierConstraintFolder",
                        "accumulator"
                      |)
                    |);
                    M.read (| x |)
                  ]
                |) in
              M.alloc (| Ty.tuple [], Value.Tuple [] |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_assert_zero :
        forall (F EF PubVar Var Expr : Ty.t),
        M.IsAssociatedFunction.C
          (Self F EF PubVar Var Expr)
          "assert_zero"
          (assert_zero F EF PubVar Var Expr).
      Admitted.
      Global Typeclasses Opaque assert_zero.
    End Impl_openvm_stark_backend_verifier_folder_GenericVerifierConstraintFolder_F_EF_PubVar_Var_Expr.
    
    Module Impl_openvm_stark_backend_air_builders_symbolic_symbolic_expression_SymbolicEvaluator_where_p3_field_field_Field_F_where_p3_field_field_ExtensionField_EF_F_where_p3_field_field_FieldAlgebra_Expr_where_core_convert_From_Expr_F_where_core_marker_Send_Expr_where_core_marker_Sync_Expr_where_core_convert_Into_Var_Expr_where_core_marker_Copy_Var_where_core_marker_Send_Var_where_core_marker_Sync_Var_where_core_convert_Into_PubVar_Expr_where_core_marker_Copy_PubVar_where_core_marker_Send_PubVar_where_core_marker_Sync_PubVar_F_Expr_for_openvm_stark_backend_verifier_folder_GenericVerifierConstraintFolder_F_EF_PubVar_Var_Expr.
      Definition Self (F EF PubVar Var Expr : Ty.t) : Ty.t :=
        Ty.apply
          (Ty.path "openvm_stark_backend::verifier::folder::GenericVerifierConstraintFolder")
          []
          [ F; EF; PubVar; Var; Expr ].
      
      (*
          fn eval_const(&self, c: F) -> Expr {
              c.into()
          }
      *)
      Definition eval_const
          (F EF PubVar Var Expr : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self F EF PubVar Var Expr in
        match ε, τ, α with
        | [], [], [ self; c ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path
                        "openvm_stark_backend::verifier::folder::GenericVerifierConstraintFolder")
                      []
                      [ F; EF; PubVar; Var; Expr ]
                  ],
                self
              |) in
            let c := M.alloc (| F, c |) in
            M.call_closure (|
              Expr,
              M.get_trait_method (| "core::convert::Into", F, [], [ Expr ], "into", [], [] |),
              [ M.read (| c |) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn eval_is_first_row(&self) -> Expr {
              self.is_first_row.into()
          }
      *)
      Definition eval_is_first_row
          (F EF PubVar Var Expr : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self F EF PubVar Var Expr in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path
                        "openvm_stark_backend::verifier::folder::GenericVerifierConstraintFolder")
                      []
                      [ F; EF; PubVar; Var; Expr ]
                  ],
                self
              |) in
            M.call_closure (|
              Expr,
              M.get_trait_method (| "core::convert::Into", Var, [], [ Expr ], "into", [], [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "openvm_stark_backend::verifier::folder::GenericVerifierConstraintFolder",
                    "is_first_row"
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn eval_is_last_row(&self) -> Expr {
              self.is_last_row.into()
          }
      *)
      Definition eval_is_last_row
          (F EF PubVar Var Expr : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self F EF PubVar Var Expr in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path
                        "openvm_stark_backend::verifier::folder::GenericVerifierConstraintFolder")
                      []
                      [ F; EF; PubVar; Var; Expr ]
                  ],
                self
              |) in
            M.call_closure (|
              Expr,
              M.get_trait_method (| "core::convert::Into", Var, [], [ Expr ], "into", [], [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "openvm_stark_backend::verifier::folder::GenericVerifierConstraintFolder",
                    "is_last_row"
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn eval_is_transition(&self) -> Expr {
              self.is_transition.into()
          }
      *)
      Definition eval_is_transition
          (F EF PubVar Var Expr : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self F EF PubVar Var Expr in
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path
                        "openvm_stark_backend::verifier::folder::GenericVerifierConstraintFolder")
                      []
                      [ F; EF; PubVar; Var; Expr ]
                  ],
                self
              |) in
            M.call_closure (|
              Expr,
              M.get_trait_method (| "core::convert::Into", Var, [], [ Expr ], "into", [], [] |),
              [
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "openvm_stark_backend::verifier::folder::GenericVerifierConstraintFolder",
                    "is_transition"
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      (*
          fn eval_var(&self, symbolic_var: SymbolicVariable<F>) -> Expr {
              let index = symbolic_var.index;
              match symbolic_var.entry {
                  Entry::Preprocessed { offset } => self.preprocessed.get(offset, index).into(),
                  Entry::Main { part_index, offset } => {
                      self.partitioned_main[part_index].get(offset, index).into()
                  }
                  Entry::Public => self.public_values[index].into(),
                  Entry::Permutation { offset } => self
                      .after_challenge
                      .first()
                      .expect("Challenge phase not supported")
                      .get(offset, index)
                      .into(),
                  Entry::Challenge => self
                      .challenges
                      .first()
                      .expect("Challenge phase not supported")[index]
                      .into(),
                  Entry::Exposed => self
                      .exposed_values_after_challenge
                      .first()
                      .expect("Challenge phase not supported")[index]
                      .into(),
              }
          }
      *)
      Definition eval_var
          (F EF PubVar Var Expr : Ty.t)
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        let Self : Ty.t := Self F EF PubVar Var Expr in
        match ε, τ, α with
        | [], [], [ self; symbolic_var ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path
                        "openvm_stark_backend::verifier::folder::GenericVerifierConstraintFolder")
                      []
                      [ F; EF; PubVar; Var; Expr ]
                  ],
                self
              |) in
            let symbolic_var :=
              M.alloc (|
                Ty.apply
                  (Ty.path
                    "openvm_stark_backend::air_builders::symbolic::symbolic_variable::SymbolicVariable")
                  []
                  [ F ],
                symbolic_var
              |) in
            M.read (|
              let~ index : Ty.path "usize" :=
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    symbolic_var,
                    "openvm_stark_backend::air_builders::symbolic::symbolic_variable::SymbolicVariable",
                    "index"
                  |)
                |) in
              M.alloc (|
                Expr,
                M.match_operator (|
                  Expr,
                  M.SubPointer.get_struct_record_field (|
                    symbolic_var,
                    "openvm_stark_backend::air_builders::symbolic::symbolic_variable::SymbolicVariable",
                    "entry"
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.SubPointer.get_struct_record_field (|
                            γ,
                            "openvm_stark_backend::air_builders::symbolic::symbolic_variable::Entry::Preprocessed",
                            "offset"
                          |) in
                        let offset := M.copy (| Ty.path "usize", γ0_0 |) in
                        M.call_closure (|
                          Expr,
                          M.get_trait_method (|
                            "core::convert::Into",
                            Var,
                            [],
                            [ Expr ],
                            "into",
                            [],
                            []
                          |),
                          [
                            M.call_closure (|
                              Var,
                              M.get_trait_method (|
                                "p3_matrix::Matrix",
                                Ty.apply
                                  (Ty.path "p3_matrix::stack::VerticalPair")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "p3_matrix::dense::DenseMatrix")
                                      []
                                      [
                                        Var;
                                        Ty.apply
                                          (Ty.path "&")
                                          []
                                          [ Ty.apply (Ty.path "slice") [] [ Var ] ]
                                      ];
                                    Ty.apply
                                      (Ty.path "p3_matrix::dense::DenseMatrix")
                                      []
                                      [
                                        Var;
                                        Ty.apply
                                          (Ty.path "&")
                                          []
                                          [ Ty.apply (Ty.path "slice") [] [ Var ] ]
                                      ]
                                  ],
                                [],
                                [ Var ],
                                "get",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "openvm_stark_backend::verifier::folder::GenericVerifierConstraintFolder",
                                    "preprocessed"
                                  |)
                                |);
                                M.read (| offset |);
                                M.read (| index |)
                              ]
                            |)
                          ]
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.SubPointer.get_struct_record_field (|
                            γ,
                            "openvm_stark_backend::air_builders::symbolic::symbolic_variable::Entry::Main",
                            "part_index"
                          |) in
                        let γ0_1 :=
                          M.SubPointer.get_struct_record_field (|
                            γ,
                            "openvm_stark_backend::air_builders::symbolic::symbolic_variable::Entry::Main",
                            "offset"
                          |) in
                        let part_index := M.copy (| Ty.path "usize", γ0_0 |) in
                        let offset := M.copy (| Ty.path "usize", γ0_1 |) in
                        M.call_closure (|
                          Expr,
                          M.get_trait_method (|
                            "core::convert::Into",
                            Var,
                            [],
                            [ Expr ],
                            "into",
                            [],
                            []
                          |),
                          [
                            M.call_closure (|
                              Var,
                              M.get_trait_method (|
                                "p3_matrix::Matrix",
                                Ty.apply
                                  (Ty.path "p3_matrix::stack::VerticalPair")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "p3_matrix::dense::DenseMatrix")
                                      []
                                      [
                                        Var;
                                        Ty.apply
                                          (Ty.path "&")
                                          []
                                          [ Ty.apply (Ty.path "slice") [] [ Var ] ]
                                      ];
                                    Ty.apply
                                      (Ty.path "p3_matrix::dense::DenseMatrix")
                                      []
                                      [
                                        Var;
                                        Ty.apply
                                          (Ty.path "&")
                                          []
                                          [ Ty.apply (Ty.path "slice") [] [ Var ] ]
                                      ]
                                  ],
                                [],
                                [ Var ],
                                "get",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "&")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "p3_matrix::stack::VerticalPair")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "p3_matrix::dense::DenseMatrix")
                                                []
                                                [
                                                  Var;
                                                  Ty.apply
                                                    (Ty.path "&")
                                                    []
                                                    [ Ty.apply (Ty.path "slice") [] [ Var ] ]
                                                ];
                                              Ty.apply
                                                (Ty.path "p3_matrix::dense::DenseMatrix")
                                                []
                                                [
                                                  Var;
                                                  Ty.apply
                                                    (Ty.path "&")
                                                    []
                                                    [ Ty.apply (Ty.path "slice") [] [ Var ] ]
                                                ]
                                            ]
                                        ],
                                      M.get_trait_method (|
                                        "core::ops::index::Index",
                                        Ty.apply
                                          (Ty.path "alloc::vec::Vec")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "p3_matrix::stack::VerticalPair")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "p3_matrix::dense::DenseMatrix")
                                                  []
                                                  [
                                                    Var;
                                                    Ty.apply
                                                      (Ty.path "&")
                                                      []
                                                      [ Ty.apply (Ty.path "slice") [] [ Var ] ]
                                                  ];
                                                Ty.apply
                                                  (Ty.path "p3_matrix::dense::DenseMatrix")
                                                  []
                                                  [
                                                    Var;
                                                    Ty.apply
                                                      (Ty.path "&")
                                                      []
                                                      [ Ty.apply (Ty.path "slice") [] [ Var ] ]
                                                  ]
                                              ];
                                            Ty.path "alloc::alloc::Global"
                                          ],
                                        [],
                                        [ Ty.path "usize" ],
                                        "index",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.SubPointer.get_struct_record_field (|
                                            M.deref (| M.read (| self |) |),
                                            "openvm_stark_backend::verifier::folder::GenericVerifierConstraintFolder",
                                            "partitioned_main"
                                          |)
                                        |);
                                        M.read (| part_index |)
                                      ]
                                    |)
                                  |)
                                |);
                                M.read (| offset |);
                                M.read (| index |)
                              ]
                            |)
                          ]
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "openvm_stark_backend::air_builders::symbolic::symbolic_variable::Entry::Public"
                          |) in
                        M.call_closure (|
                          Expr,
                          M.get_trait_method (|
                            "core::convert::Into",
                            PubVar,
                            [],
                            [ Expr ],
                            "into",
                            [],
                            []
                          |),
                          [
                            M.read (|
                              M.SubPointer.get_array_field (|
                                M.deref (|
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "openvm_stark_backend::verifier::folder::GenericVerifierConstraintFolder",
                                      "public_values"
                                    |)
                                  |)
                                |),
                                M.read (| index |)
                              |)
                            |)
                          ]
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.SubPointer.get_struct_record_field (|
                            γ,
                            "openvm_stark_backend::air_builders::symbolic::symbolic_variable::Entry::Permutation",
                            "offset"
                          |) in
                        let offset := M.copy (| Ty.path "usize", γ0_0 |) in
                        M.call_closure (|
                          Expr,
                          M.get_trait_method (|
                            "core::convert::Into",
                            Var,
                            [],
                            [ Expr ],
                            "into",
                            [],
                            []
                          |),
                          [
                            M.call_closure (|
                              Var,
                              M.get_trait_method (|
                                "p3_matrix::Matrix",
                                Ty.apply
                                  (Ty.path "p3_matrix::stack::VerticalPair")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "p3_matrix::dense::DenseMatrix")
                                      []
                                      [
                                        Var;
                                        Ty.apply
                                          (Ty.path "&")
                                          []
                                          [ Ty.apply (Ty.path "slice") [] [ Var ] ]
                                      ];
                                    Ty.apply
                                      (Ty.path "p3_matrix::dense::DenseMatrix")
                                      []
                                      [
                                        Var;
                                        Ty.apply
                                          (Ty.path "&")
                                          []
                                          [ Ty.apply (Ty.path "slice") [] [ Var ] ]
                                      ]
                                  ],
                                [],
                                [ Var ],
                                "get",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "&")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "p3_matrix::stack::VerticalPair")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "p3_matrix::dense::DenseMatrix")
                                                []
                                                [
                                                  Var;
                                                  Ty.apply
                                                    (Ty.path "&")
                                                    []
                                                    [ Ty.apply (Ty.path "slice") [] [ Var ] ]
                                                ];
                                              Ty.apply
                                                (Ty.path "p3_matrix::dense::DenseMatrix")
                                                []
                                                [
                                                  Var;
                                                  Ty.apply
                                                    (Ty.path "&")
                                                    []
                                                    [ Ty.apply (Ty.path "slice") [] [ Var ] ]
                                                ]
                                            ]
                                        ],
                                      M.get_associated_function (|
                                        Ty.apply
                                          (Ty.path "core::option::Option")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "&")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "p3_matrix::stack::VerticalPair")
                                                  []
                                                  [
                                                    Ty.apply
                                                      (Ty.path "p3_matrix::dense::DenseMatrix")
                                                      []
                                                      [
                                                        Var;
                                                        Ty.apply
                                                          (Ty.path "&")
                                                          []
                                                          [ Ty.apply (Ty.path "slice") [] [ Var ] ]
                                                      ];
                                                    Ty.apply
                                                      (Ty.path "p3_matrix::dense::DenseMatrix")
                                                      []
                                                      [
                                                        Var;
                                                        Ty.apply
                                                          (Ty.path "&")
                                                          []
                                                          [ Ty.apply (Ty.path "slice") [] [ Var ] ]
                                                      ]
                                                  ]
                                              ]
                                          ],
                                        "expect",
                                        [],
                                        []
                                      |),
                                      [
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "core::option::Option")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "&")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "p3_matrix::stack::VerticalPair")
                                                    []
                                                    [
                                                      Ty.apply
                                                        (Ty.path "p3_matrix::dense::DenseMatrix")
                                                        []
                                                        [
                                                          Var;
                                                          Ty.apply
                                                            (Ty.path "&")
                                                            []
                                                            [ Ty.apply (Ty.path "slice") [] [ Var ]
                                                            ]
                                                        ];
                                                      Ty.apply
                                                        (Ty.path "p3_matrix::dense::DenseMatrix")
                                                        []
                                                        [
                                                          Var;
                                                          Ty.apply
                                                            (Ty.path "&")
                                                            []
                                                            [ Ty.apply (Ty.path "slice") [] [ Var ]
                                                            ]
                                                        ]
                                                    ]
                                                ]
                                            ],
                                          M.get_associated_function (|
                                            Ty.apply
                                              (Ty.path "slice")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "p3_matrix::stack::VerticalPair")
                                                  []
                                                  [
                                                    Ty.apply
                                                      (Ty.path "p3_matrix::dense::DenseMatrix")
                                                      []
                                                      [
                                                        Var;
                                                        Ty.apply
                                                          (Ty.path "&")
                                                          []
                                                          [ Ty.apply (Ty.path "slice") [] [ Var ] ]
                                                      ];
                                                    Ty.apply
                                                      (Ty.path "p3_matrix::dense::DenseMatrix")
                                                      []
                                                      [
                                                        Var;
                                                        Ty.apply
                                                          (Ty.path "&")
                                                          []
                                                          [ Ty.apply (Ty.path "slice") [] [ Var ] ]
                                                      ]
                                                  ]
                                              ],
                                            "first",
                                            [],
                                            []
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.call_closure (|
                                                  Ty.apply
                                                    (Ty.path "&")
                                                    []
                                                    [
                                                      Ty.apply
                                                        (Ty.path "slice")
                                                        []
                                                        [
                                                          Ty.apply
                                                            (Ty.path
                                                              "p3_matrix::stack::VerticalPair")
                                                            []
                                                            [
                                                              Ty.apply
                                                                (Ty.path
                                                                  "p3_matrix::dense::DenseMatrix")
                                                                []
                                                                [
                                                                  Var;
                                                                  Ty.apply
                                                                    (Ty.path "&")
                                                                    []
                                                                    [
                                                                      Ty.apply
                                                                        (Ty.path "slice")
                                                                        []
                                                                        [ Var ]
                                                                    ]
                                                                ];
                                                              Ty.apply
                                                                (Ty.path
                                                                  "p3_matrix::dense::DenseMatrix")
                                                                []
                                                                [
                                                                  Var;
                                                                  Ty.apply
                                                                    (Ty.path "&")
                                                                    []
                                                                    [
                                                                      Ty.apply
                                                                        (Ty.path "slice")
                                                                        []
                                                                        [ Var ]
                                                                    ]
                                                                ]
                                                            ]
                                                        ]
                                                    ],
                                                  M.get_trait_method (|
                                                    "core::ops::deref::Deref",
                                                    Ty.apply
                                                      (Ty.path "alloc::vec::Vec")
                                                      []
                                                      [
                                                        Ty.apply
                                                          (Ty.path "p3_matrix::stack::VerticalPair")
                                                          []
                                                          [
                                                            Ty.apply
                                                              (Ty.path
                                                                "p3_matrix::dense::DenseMatrix")
                                                              []
                                                              [
                                                                Var;
                                                                Ty.apply
                                                                  (Ty.path "&")
                                                                  []
                                                                  [
                                                                    Ty.apply
                                                                      (Ty.path "slice")
                                                                      []
                                                                      [ Var ]
                                                                  ]
                                                              ];
                                                            Ty.apply
                                                              (Ty.path
                                                                "p3_matrix::dense::DenseMatrix")
                                                              []
                                                              [
                                                                Var;
                                                                Ty.apply
                                                                  (Ty.path "&")
                                                                  []
                                                                  [
                                                                    Ty.apply
                                                                      (Ty.path "slice")
                                                                      []
                                                                      [ Var ]
                                                                  ]
                                                              ]
                                                          ];
                                                        Ty.path "alloc::alloc::Global"
                                                      ],
                                                    [],
                                                    [],
                                                    "deref",
                                                    [],
                                                    []
                                                  |),
                                                  [
                                                    M.borrow (|
                                                      Pointer.Kind.Ref,
                                                      M.SubPointer.get_struct_record_field (|
                                                        M.deref (| M.read (| self |) |),
                                                        "openvm_stark_backend::verifier::folder::GenericVerifierConstraintFolder",
                                                        "after_challenge"
                                                      |)
                                                    |)
                                                  ]
                                                |)
                                              |)
                                            |)
                                          ]
                                        |);
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| mk_str (| "Challenge phase not supported" |) |)
                                        |)
                                      ]
                                    |)
                                  |)
                                |);
                                M.read (| offset |);
                                M.read (| index |)
                              ]
                            |)
                          ]
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "openvm_stark_backend::air_builders::symbolic::symbolic_variable::Entry::Challenge"
                          |) in
                        M.call_closure (|
                          Expr,
                          M.get_trait_method (|
                            "core::convert::Into",
                            Var,
                            [],
                            [ Expr ],
                            "into",
                            [],
                            []
                          |),
                          [
                            M.read (|
                              M.deref (|
                                M.call_closure (|
                                  Ty.apply (Ty.path "&") [] [ Var ],
                                  M.get_trait_method (|
                                    "core::ops::index::Index",
                                    Ty.apply
                                      (Ty.path "alloc::vec::Vec")
                                      []
                                      [ Var; Ty.path "alloc::alloc::Global" ],
                                    [],
                                    [ Ty.path "usize" ],
                                    "index",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (|
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "&")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "alloc::vec::Vec")
                                                []
                                                [ Var; Ty.path "alloc::alloc::Global" ]
                                            ],
                                          M.get_associated_function (|
                                            Ty.apply
                                              (Ty.path "core::option::Option")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "&")
                                                  []
                                                  [
                                                    Ty.apply
                                                      (Ty.path "alloc::vec::Vec")
                                                      []
                                                      [ Var; Ty.path "alloc::alloc::Global" ]
                                                  ]
                                              ],
                                            "expect",
                                            [],
                                            []
                                          |),
                                          [
                                            M.call_closure (|
                                              Ty.apply
                                                (Ty.path "core::option::Option")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "&")
                                                    []
                                                    [
                                                      Ty.apply
                                                        (Ty.path "alloc::vec::Vec")
                                                        []
                                                        [ Var; Ty.path "alloc::alloc::Global" ]
                                                    ]
                                                ],
                                              M.get_associated_function (|
                                                Ty.apply
                                                  (Ty.path "slice")
                                                  []
                                                  [
                                                    Ty.apply
                                                      (Ty.path "alloc::vec::Vec")
                                                      []
                                                      [ Var; Ty.path "alloc::alloc::Global" ]
                                                  ],
                                                "first",
                                                [],
                                                []
                                              |),
                                              [
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (|
                                                    M.read (|
                                                      M.SubPointer.get_struct_record_field (|
                                                        M.deref (| M.read (| self |) |),
                                                        "openvm_stark_backend::verifier::folder::GenericVerifierConstraintFolder",
                                                        "challenges"
                                                      |)
                                                    |)
                                                  |)
                                                |)
                                              ]
                                            |);
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                mk_str (| "Challenge phase not supported" |)
                                              |)
                                            |)
                                          ]
                                        |)
                                      |)
                                    |);
                                    M.read (| index |)
                                  ]
                                |)
                              |)
                            |)
                          ]
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let _ :=
                          M.is_struct_tuple (|
                            γ,
                            "openvm_stark_backend::air_builders::symbolic::symbolic_variable::Entry::Exposed"
                          |) in
                        M.call_closure (|
                          Expr,
                          M.get_trait_method (|
                            "core::convert::Into",
                            Var,
                            [],
                            [ Expr ],
                            "into",
                            [],
                            []
                          |),
                          [
                            M.read (|
                              M.deref (|
                                M.call_closure (|
                                  Ty.apply (Ty.path "&") [] [ Var ],
                                  M.get_trait_method (|
                                    "core::ops::index::Index",
                                    Ty.apply
                                      (Ty.path "alloc::vec::Vec")
                                      []
                                      [ Var; Ty.path "alloc::alloc::Global" ],
                                    [],
                                    [ Ty.path "usize" ],
                                    "index",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (|
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "&")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "alloc::vec::Vec")
                                                []
                                                [ Var; Ty.path "alloc::alloc::Global" ]
                                            ],
                                          M.get_associated_function (|
                                            Ty.apply
                                              (Ty.path "core::option::Option")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "&")
                                                  []
                                                  [
                                                    Ty.apply
                                                      (Ty.path "alloc::vec::Vec")
                                                      []
                                                      [ Var; Ty.path "alloc::alloc::Global" ]
                                                  ]
                                              ],
                                            "expect",
                                            [],
                                            []
                                          |),
                                          [
                                            M.call_closure (|
                                              Ty.apply
                                                (Ty.path "core::option::Option")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "&")
                                                    []
                                                    [
                                                      Ty.apply
                                                        (Ty.path "alloc::vec::Vec")
                                                        []
                                                        [ Var; Ty.path "alloc::alloc::Global" ]
                                                    ]
                                                ],
                                              M.get_associated_function (|
                                                Ty.apply
                                                  (Ty.path "slice")
                                                  []
                                                  [
                                                    Ty.apply
                                                      (Ty.path "alloc::vec::Vec")
                                                      []
                                                      [ Var; Ty.path "alloc::alloc::Global" ]
                                                  ],
                                                "first",
                                                [],
                                                []
                                              |),
                                              [
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (|
                                                    M.read (|
                                                      M.SubPointer.get_struct_record_field (|
                                                        M.deref (| M.read (| self |) |),
                                                        "openvm_stark_backend::verifier::folder::GenericVerifierConstraintFolder",
                                                        "exposed_values_after_challenge"
                                                      |)
                                                    |)
                                                  |)
                                                |)
                                              ]
                                            |);
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                mk_str (| "Challenge phase not supported" |)
                                              |)
                                            |)
                                          ]
                                        |)
                                      |)
                                    |);
                                    M.read (| index |)
                                  ]
                                |)
                              |)
                            |)
                          ]
                        |)))
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        forall (F EF PubVar Var Expr : Ty.t),
        M.IsTraitInstance
          "openvm_stark_backend::air_builders::symbolic::symbolic_expression::SymbolicEvaluator"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ F; Expr ]
          (Self F EF PubVar Var Expr)
          (* Instance *)
          [
            ("eval_const", InstanceField.Method (eval_const F EF PubVar Var Expr));
            ("eval_is_first_row", InstanceField.Method (eval_is_first_row F EF PubVar Var Expr));
            ("eval_is_last_row", InstanceField.Method (eval_is_last_row F EF PubVar Var Expr));
            ("eval_is_transition", InstanceField.Method (eval_is_transition F EF PubVar Var Expr));
            ("eval_var", InstanceField.Method (eval_var F EF PubVar Var Expr))
          ].
    End Impl_openvm_stark_backend_air_builders_symbolic_symbolic_expression_SymbolicEvaluator_where_p3_field_field_Field_F_where_p3_field_field_ExtensionField_EF_F_where_p3_field_field_FieldAlgebra_Expr_where_core_convert_From_Expr_F_where_core_marker_Send_Expr_where_core_marker_Sync_Expr_where_core_convert_Into_Var_Expr_where_core_marker_Copy_Var_where_core_marker_Send_Var_where_core_marker_Sync_Var_where_core_convert_Into_PubVar_Expr_where_core_marker_Copy_PubVar_where_core_marker_Send_PubVar_where_core_marker_Sync_PubVar_F_Expr_for_openvm_stark_backend_verifier_folder_GenericVerifierConstraintFolder_F_EF_PubVar_Var_Expr.
  End folder.
End verifier.
