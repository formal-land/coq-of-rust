(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module cpi.
  Definition value_MAX_CPI_ACCOUNTS (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    ltac:(M.monadic (M.alloc (| Ty.path "usize", Value.Integer IntegerKind.Usize 64 |))).
  
  Global Instance Instance_IsConstant_value_MAX_CPI_ACCOUNTS :
    M.IsFunction.C "pinocchio::cpi::MAX_CPI_ACCOUNTS" value_MAX_CPI_ACCOUNTS.
  Admitted.
  Global Typeclasses Opaque value_MAX_CPI_ACCOUNTS.
  
  (*
  pub fn invoke<const ACCOUNTS: usize>(
      instruction: &Instruction,
      account_infos: &[&AccountInfo; ACCOUNTS],
  ) -> ProgramResult {
      invoke_signed::<ACCOUNTS>(instruction, account_infos, &[])
  }
  *)
  Definition invoke (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [ ACCOUNTS ], [], [ instruction; account_infos ] =>
      ltac:(M.monadic
        (let instruction :=
          M.alloc (|
            Ty.apply (Ty.path "&") [] [ Ty.path "pinocchio::instruction::Instruction" ],
            instruction
          |) in
        let account_infos :=
          M.alloc (|
            Ty.apply
              (Ty.path "&")
              []
              [
                Ty.apply
                  (Ty.path "array")
                  [ ACCOUNTS ]
                  [ Ty.apply (Ty.path "&") [] [ Ty.path "pinocchio::account_info::AccountInfo" ] ]
              ],
            account_infos
          |) in
        M.call_closure (|
          Ty.apply
            (Ty.path "core::result::Result")
            []
            [ Ty.tuple []; Ty.path "pinocchio::program_error::ProgramError" ],
          M.get_function (| "pinocchio::cpi::invoke_signed", [ ACCOUNTS ], [] |),
          [
            M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| instruction |) |) |);
            M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| account_infos |) |) |);
            M.call_closure (|
              Ty.apply
                (Ty.path "&")
                []
                [ Ty.apply (Ty.path "slice") [] [ Ty.path "pinocchio::instruction::Signer" ] ],
              M.pointer_coercion
                M.PointerCoercion.Unsize
                (Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path "array")
                      [ Value.Integer IntegerKind.Usize 0 ]
                      [ Ty.path "pinocchio::instruction::Signer" ]
                  ])
                (Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.apply (Ty.path "slice") [] [ Ty.path "pinocchio::instruction::Signer" ] ]),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.alloc (|
                        Ty.apply
                          (Ty.path "array")
                          [ Value.Integer IntegerKind.Usize 0 ]
                          [ Ty.path "pinocchio::instruction::Signer" ],
                        Value.Array []
                      |)
                    |)
                  |)
                |)
              ]
            |)
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_invoke : M.IsFunction.C "pinocchio::cpi::invoke" invoke.
  Admitted.
  Global Typeclasses Opaque invoke.
  
  (*
  pub fn invoke_with_bounds<const MAX_ACCOUNTS: usize>(
      instruction: &Instruction,
      account_infos: &[&AccountInfo],
  ) -> ProgramResult {
      invoke_signed_with_bounds::<MAX_ACCOUNTS>(instruction, account_infos, &[])
  }
  *)
  Definition invoke_with_bounds (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [ MAX_ACCOUNTS ], [], [ instruction; account_infos ] =>
      ltac:(M.monadic
        (let instruction :=
          M.alloc (|
            Ty.apply (Ty.path "&") [] [ Ty.path "pinocchio::instruction::Instruction" ],
            instruction
          |) in
        let account_infos :=
          M.alloc (|
            Ty.apply
              (Ty.path "&")
              []
              [
                Ty.apply
                  (Ty.path "slice")
                  []
                  [ Ty.apply (Ty.path "&") [] [ Ty.path "pinocchio::account_info::AccountInfo" ] ]
              ],
            account_infos
          |) in
        M.call_closure (|
          Ty.apply
            (Ty.path "core::result::Result")
            []
            [ Ty.tuple []; Ty.path "pinocchio::program_error::ProgramError" ],
          M.get_function (| "pinocchio::cpi::invoke_signed_with_bounds", [ MAX_ACCOUNTS ], [] |),
          [
            M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| instruction |) |) |);
            M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| account_infos |) |) |);
            M.call_closure (|
              Ty.apply
                (Ty.path "&")
                []
                [ Ty.apply (Ty.path "slice") [] [ Ty.path "pinocchio::instruction::Signer" ] ],
              M.pointer_coercion
                M.PointerCoercion.Unsize
                (Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path "array")
                      [ Value.Integer IntegerKind.Usize 0 ]
                      [ Ty.path "pinocchio::instruction::Signer" ]
                  ])
                (Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.apply (Ty.path "slice") [] [ Ty.path "pinocchio::instruction::Signer" ] ]),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.alloc (|
                        Ty.apply
                          (Ty.path "array")
                          [ Value.Integer IntegerKind.Usize 0 ]
                          [ Ty.path "pinocchio::instruction::Signer" ],
                        Value.Array []
                      |)
                    |)
                  |)
                |)
              ]
            |)
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_invoke_with_bounds :
    M.IsFunction.C "pinocchio::cpi::invoke_with_bounds" invoke_with_bounds.
  Admitted.
  Global Typeclasses Opaque invoke_with_bounds.
  
  (*
  pub fn slice_invoke(instruction: &Instruction, account_infos: &[&AccountInfo]) -> ProgramResult {
      slice_invoke_signed(instruction, account_infos, &[])
  }
  *)
  Definition slice_invoke (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ instruction; account_infos ] =>
      ltac:(M.monadic
        (let instruction :=
          M.alloc (|
            Ty.apply (Ty.path "&") [] [ Ty.path "pinocchio::instruction::Instruction" ],
            instruction
          |) in
        let account_infos :=
          M.alloc (|
            Ty.apply
              (Ty.path "&")
              []
              [
                Ty.apply
                  (Ty.path "slice")
                  []
                  [ Ty.apply (Ty.path "&") [] [ Ty.path "pinocchio::account_info::AccountInfo" ] ]
              ],
            account_infos
          |) in
        M.call_closure (|
          Ty.apply
            (Ty.path "core::result::Result")
            []
            [ Ty.tuple []; Ty.path "pinocchio::program_error::ProgramError" ],
          M.get_function (| "pinocchio::cpi::slice_invoke_signed", [], [] |),
          [
            M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| instruction |) |) |);
            M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| account_infos |) |) |);
            M.call_closure (|
              Ty.apply
                (Ty.path "&")
                []
                [ Ty.apply (Ty.path "slice") [] [ Ty.path "pinocchio::instruction::Signer" ] ],
              M.pointer_coercion
                M.PointerCoercion.Unsize
                (Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path "array")
                      [ Value.Integer IntegerKind.Usize 0 ]
                      [ Ty.path "pinocchio::instruction::Signer" ]
                  ])
                (Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.apply (Ty.path "slice") [] [ Ty.path "pinocchio::instruction::Signer" ] ]),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.alloc (|
                        Ty.apply
                          (Ty.path "array")
                          [ Value.Integer IntegerKind.Usize 0 ]
                          [ Ty.path "pinocchio::instruction::Signer" ],
                        Value.Array []
                      |)
                    |)
                  |)
                |)
              ]
            |)
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_slice_invoke :
    M.IsFunction.C "pinocchio::cpi::slice_invoke" slice_invoke.
  Admitted.
  Global Typeclasses Opaque slice_invoke.
  
  (*
  pub fn invoke_signed<const ACCOUNTS: usize>(
      instruction: &Instruction,
      account_infos: &[&AccountInfo; ACCOUNTS],
      signers_seeds: &[Signer],
  ) -> ProgramResult {
      // SAFETY: The array of `AccountInfo`s will be checked to ensure that it has
      // the same number of accounts as the instruction – this indirectly validates
      // that the stack allocated account storage `ACCOUNTS` is sufficient for the
      // number of accounts expected by the instruction.
      unsafe {
          inner_invoke_signed_with_bounds::<ACCOUNTS>(instruction, account_infos, signers_seeds)
      }
  }
  *)
  Definition invoke_signed (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [ ACCOUNTS ], [], [ instruction; account_infos; signers_seeds ] =>
      ltac:(M.monadic
        (let instruction :=
          M.alloc (|
            Ty.apply (Ty.path "&") [] [ Ty.path "pinocchio::instruction::Instruction" ],
            instruction
          |) in
        let account_infos :=
          M.alloc (|
            Ty.apply
              (Ty.path "&")
              []
              [
                Ty.apply
                  (Ty.path "array")
                  [ ACCOUNTS ]
                  [ Ty.apply (Ty.path "&") [] [ Ty.path "pinocchio::account_info::AccountInfo" ] ]
              ],
            account_infos
          |) in
        let signers_seeds :=
          M.alloc (|
            Ty.apply
              (Ty.path "&")
              []
              [ Ty.apply (Ty.path "slice") [] [ Ty.path "pinocchio::instruction::Signer" ] ],
            signers_seeds
          |) in
        M.call_closure (|
          Ty.apply
            (Ty.path "core::result::Result")
            []
            [ Ty.tuple []; Ty.path "pinocchio::program_error::ProgramError" ],
          M.get_function (| "pinocchio::cpi::inner_invoke_signed_with_bounds", [ ACCOUNTS ], [] |),
          [
            M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| instruction |) |) |);
            M.call_closure (|
              Ty.apply
                (Ty.path "&")
                []
                [
                  Ty.apply
                    (Ty.path "slice")
                    []
                    [ Ty.apply (Ty.path "&") [] [ Ty.path "pinocchio::account_info::AccountInfo" ] ]
                ],
              M.pointer_coercion
                M.PointerCoercion.Unsize
                (Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path "array")
                      [ ACCOUNTS ]
                      [ Ty.apply (Ty.path "&") [] [ Ty.path "pinocchio::account_info::AccountInfo" ]
                      ]
                  ])
                (Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path "slice")
                      []
                      [ Ty.apply (Ty.path "&") [] [ Ty.path "pinocchio::account_info::AccountInfo" ]
                      ]
                  ]),
              [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| account_infos |) |) |) ]
            |);
            M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| signers_seeds |) |) |)
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_invoke_signed :
    M.IsFunction.C "pinocchio::cpi::invoke_signed" invoke_signed.
  Admitted.
  Global Typeclasses Opaque invoke_signed.
  
  (*
  pub fn invoke_signed_with_bounds<const MAX_ACCOUNTS: usize>(
      instruction: &Instruction,
      account_infos: &[&AccountInfo],
      signers_seeds: &[Signer],
  ) -> ProgramResult {
      // Check that the stack allocated account storage `MAX_ACCOUNTS` is sufficient
      // for the number of accounts expected by the instruction.
      //
      // The check for the slice of `AccountInfo`s not being less than the
      // number of accounts expected by the instruction is done in
      // `invoke_signed_with_bounds`.
      if MAX_ACCOUNTS < instruction.accounts.len() {
          return Err(ProgramError::InvalidArgument);
      }
  
      // SAFETY: The stack allocated account storage `MAX_ACCOUNTS` was validated.
      unsafe {
          inner_invoke_signed_with_bounds::<MAX_ACCOUNTS>(instruction, account_infos, signers_seeds)
      }
  }
  *)
  Definition invoke_signed_with_bounds (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [ MAX_ACCOUNTS ], [], [ instruction; account_infos; signers_seeds ] =>
      ltac:(M.monadic
        (let instruction :=
          M.alloc (|
            Ty.apply (Ty.path "&") [] [ Ty.path "pinocchio::instruction::Instruction" ],
            instruction
          |) in
        let account_infos :=
          M.alloc (|
            Ty.apply
              (Ty.path "&")
              []
              [
                Ty.apply
                  (Ty.path "slice")
                  []
                  [ Ty.apply (Ty.path "&") [] [ Ty.path "pinocchio::account_info::AccountInfo" ] ]
              ],
            account_infos
          |) in
        let signers_seeds :=
          M.alloc (|
            Ty.apply
              (Ty.path "&")
              []
              [ Ty.apply (Ty.path "slice") [] [ Ty.path "pinocchio::instruction::Signer" ] ],
            signers_seeds
          |) in
        M.catch_return
          (Ty.apply
            (Ty.path "core::result::Result")
            []
            [ Ty.tuple []; Ty.path "pinocchio::program_error::ProgramError" ]) (|
          ltac:(M.monadic
            (M.read (|
              let~ _ : Ty.tuple [] :=
                M.match_operator (|
                  Ty.tuple [],
                  M.alloc (| Ty.tuple [], Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              Ty.path "bool",
                              M.call_closure (|
                                Ty.path "bool",
                                BinOp.lt,
                                [
                                  MAX_ACCOUNTS;
                                  M.call_closure (|
                                    Ty.path "usize",
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "slice")
                                        []
                                        [ Ty.path "pinocchio::instruction::AccountMeta" ],
                                      "len",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (|
                                          M.read (|
                                            M.SubPointer.get_struct_record_field (|
                                              M.deref (| M.read (| instruction |) |),
                                              "pinocchio::instruction::Instruction",
                                              "accounts"
                                            |)
                                          |)
                                        |)
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.never_to_any (|
                          M.read (|
                            M.return_ (|
                              Value.StructTuple
                                "core::result::Result::Err"
                                []
                                [ Ty.tuple []; Ty.path "pinocchio::program_error::ProgramError" ]
                                [
                                  Value.StructTuple
                                    "pinocchio::program_error::ProgramError::InvalidArgument"
                                    []
                                    []
                                    []
                                ]
                            |)
                          |)
                        |)));
                    fun γ => ltac:(M.monadic (Value.Tuple []))
                  ]
                |) in
              M.alloc (|
                Ty.apply
                  (Ty.path "core::result::Result")
                  []
                  [ Ty.tuple []; Ty.path "pinocchio::program_error::ProgramError" ],
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [ Ty.tuple []; Ty.path "pinocchio::program_error::ProgramError" ],
                  M.get_function (|
                    "pinocchio::cpi::inner_invoke_signed_with_bounds",
                    [ MAX_ACCOUNTS ],
                    []
                  |),
                  [
                    M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| instruction |) |) |);
                    M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| account_infos |) |) |);
                    M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| signers_seeds |) |) |)
                  ]
                |)
              |)
            |)))
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_invoke_signed_with_bounds :
    M.IsFunction.C "pinocchio::cpi::invoke_signed_with_bounds" invoke_signed_with_bounds.
  Admitted.
  Global Typeclasses Opaque invoke_signed_with_bounds.
  
  (*
  pub fn slice_invoke_signed(
      instruction: &Instruction,
      account_infos: &[&AccountInfo],
      signers_seeds: &[Signer],
  ) -> ProgramResult {
      // Check that the stack allocated account storage `MAX_CPI_ACCOUNTS` is
      // sufficient for the number of accounts expected by the instruction.
      //
      // The check for the slice of `AccountInfo`s not being less than the
      // number of accounts expected by the instruction is done in
      // `invoke_signed_with_bounds`.
      if MAX_CPI_ACCOUNTS < instruction.accounts.len() {
          return Err(ProgramError::InvalidArgument);
      }
  
      // SAFETY: The stack allocated account storage `MAX_CPI_ACCOUNTS` was validated.
      unsafe {
          inner_invoke_signed_with_bounds::<MAX_CPI_ACCOUNTS>(
              instruction,
              account_infos,
              signers_seeds,
          )
      }
  }
  *)
  Definition slice_invoke_signed (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ instruction; account_infos; signers_seeds ] =>
      ltac:(M.monadic
        (let instruction :=
          M.alloc (|
            Ty.apply (Ty.path "&") [] [ Ty.path "pinocchio::instruction::Instruction" ],
            instruction
          |) in
        let account_infos :=
          M.alloc (|
            Ty.apply
              (Ty.path "&")
              []
              [
                Ty.apply
                  (Ty.path "slice")
                  []
                  [ Ty.apply (Ty.path "&") [] [ Ty.path "pinocchio::account_info::AccountInfo" ] ]
              ],
            account_infos
          |) in
        let signers_seeds :=
          M.alloc (|
            Ty.apply
              (Ty.path "&")
              []
              [ Ty.apply (Ty.path "slice") [] [ Ty.path "pinocchio::instruction::Signer" ] ],
            signers_seeds
          |) in
        M.catch_return
          (Ty.apply
            (Ty.path "core::result::Result")
            []
            [ Ty.tuple []; Ty.path "pinocchio::program_error::ProgramError" ]) (|
          ltac:(M.monadic
            (M.read (|
              let~ _ : Ty.tuple [] :=
                M.match_operator (|
                  Ty.tuple [],
                  M.alloc (| Ty.tuple [], Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              Ty.path "bool",
                              M.call_closure (|
                                Ty.path "bool",
                                BinOp.lt,
                                [
                                  M.read (|
                                    get_constant (|
                                      "pinocchio::cpi::MAX_CPI_ACCOUNTS",
                                      Ty.path "usize"
                                    |)
                                  |);
                                  M.call_closure (|
                                    Ty.path "usize",
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "slice")
                                        []
                                        [ Ty.path "pinocchio::instruction::AccountMeta" ],
                                      "len",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (|
                                          M.read (|
                                            M.SubPointer.get_struct_record_field (|
                                              M.deref (| M.read (| instruction |) |),
                                              "pinocchio::instruction::Instruction",
                                              "accounts"
                                            |)
                                          |)
                                        |)
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.never_to_any (|
                          M.read (|
                            M.return_ (|
                              Value.StructTuple
                                "core::result::Result::Err"
                                []
                                [ Ty.tuple []; Ty.path "pinocchio::program_error::ProgramError" ]
                                [
                                  Value.StructTuple
                                    "pinocchio::program_error::ProgramError::InvalidArgument"
                                    []
                                    []
                                    []
                                ]
                            |)
                          |)
                        |)));
                    fun γ => ltac:(M.monadic (Value.Tuple []))
                  ]
                |) in
              M.alloc (|
                Ty.apply
                  (Ty.path "core::result::Result")
                  []
                  [ Ty.tuple []; Ty.path "pinocchio::program_error::ProgramError" ],
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [ Ty.tuple []; Ty.path "pinocchio::program_error::ProgramError" ],
                  M.get_function (|
                    "pinocchio::cpi::inner_invoke_signed_with_bounds",
                    [ Value.Integer IntegerKind.Usize 64 ],
                    []
                  |),
                  [
                    M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| instruction |) |) |);
                    M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| account_infos |) |) |);
                    M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| signers_seeds |) |) |)
                  ]
                |)
              |)
            |)))
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_slice_invoke_signed :
    M.IsFunction.C "pinocchio::cpi::slice_invoke_signed" slice_invoke_signed.
  Admitted.
  Global Typeclasses Opaque slice_invoke_signed.
  
  (*
  unsafe fn inner_invoke_signed_with_bounds<const MAX_ACCOUNTS: usize>(
      instruction: &Instruction,
      account_infos: &[&AccountInfo],
      signers_seeds: &[Signer],
  ) -> ProgramResult {
      // Check that the number of `MAX_ACCOUNTS` provided is not greater than
      // the maximum number of accounts allowed.
      const {
          assert!(
              MAX_ACCOUNTS <= MAX_CPI_ACCOUNTS,
              "MAX_ACCOUNTS is greater than allowed MAX_CPI_ACCOUNTS"
          );
      }
  
      // Check that the number of accounts provided is not less than
      // the number of accounts expected by the instruction.
      if account_infos.len() < instruction.accounts.len() {
          return Err(ProgramError::NotEnoughAccountKeys);
      }
  
      const UNINIT: MaybeUninit<Account> = MaybeUninit::<Account>::uninit();
      let mut accounts = [UNINIT; MAX_ACCOUNTS];
  
      account_infos
          .iter()
          .zip(instruction.accounts.iter())
          .zip(accounts.iter_mut())
          .try_for_each(|((account_info, account_meta), account)| {
              // In order to check whether the borrow state is compatible
              // with the invocation, we need to check that we have the
              // correct account info and meta pair.
              if account_info.key() != account_meta.pubkey {
                  return Err(ProgramError::InvalidArgument);
              }
  
              // Determines the borrow state that would be invalid according
              // to their mutability on the instruction.
              let invalid_state = if account_meta.is_writable {
                  // If the account is required to be writable, it cannot
                  //  be currently borrowed.
                  BorrowState::Borrowed
              } else {
                  // If the account is required to be read-only, it cannot
                  // be currently mutably borrowed.
                  BorrowState::MutablyBorrowed
              };
  
              if account_info.is_borrowed(invalid_state) {
                  return Err(ProgramError::AccountBorrowFailed);
              }
  
              account.write(Account::from( *account_info));
  
              Ok(())
          })?;
  
      // SAFETY: At this point it is guaranteed that account infos are borrowable
      // according to their mutability on the instruction.
      unsafe {
          invoke_signed_unchecked(
              instruction,
              from_raw_parts(accounts.as_ptr() as _, instruction.accounts.len()),
              signers_seeds,
          );
      }
  
      Ok(())
  }
  *)
  Definition inner_invoke_signed_with_bounds
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    match ε, τ, α with
    | [ MAX_ACCOUNTS ], [], [ instruction; account_infos; signers_seeds ] =>
      ltac:(M.monadic
        (let instruction :=
          M.alloc (|
            Ty.apply (Ty.path "&") [] [ Ty.path "pinocchio::instruction::Instruction" ],
            instruction
          |) in
        let account_infos :=
          M.alloc (|
            Ty.apply
              (Ty.path "&")
              []
              [
                Ty.apply
                  (Ty.path "slice")
                  []
                  [ Ty.apply (Ty.path "&") [] [ Ty.path "pinocchio::account_info::AccountInfo" ] ]
              ],
            account_infos
          |) in
        let signers_seeds :=
          M.alloc (|
            Ty.apply
              (Ty.path "&")
              []
              [ Ty.apply (Ty.path "slice") [] [ Ty.path "pinocchio::instruction::Signer" ] ],
            signers_seeds
          |) in
        M.catch_return
          (Ty.apply
            (Ty.path "core::result::Result")
            []
            [ Ty.tuple []; Ty.path "pinocchio::program_error::ProgramError" ]) (|
          ltac:(M.monadic
            (M.read (|
              let~ _ : Ty.tuple [] :=
                M.read (|
                  get_constant (|
                    "pinocchio::cpi::inner_invoke_signed_with_bounds_discriminant",
                    Ty.tuple []
                  |)
                |) in
              let~ _ : Ty.tuple [] :=
                M.match_operator (|
                  Ty.tuple [],
                  M.alloc (| Ty.tuple [], Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              Ty.path "bool",
                              M.call_closure (|
                                Ty.path "bool",
                                BinOp.lt,
                                [
                                  M.call_closure (|
                                    Ty.path "usize",
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "slice")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "&")
                                            []
                                            [ Ty.path "pinocchio::account_info::AccountInfo" ]
                                        ],
                                      "len",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (| M.read (| account_infos |) |)
                                      |)
                                    ]
                                  |);
                                  M.call_closure (|
                                    Ty.path "usize",
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "slice")
                                        []
                                        [ Ty.path "pinocchio::instruction::AccountMeta" ],
                                      "len",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.deref (|
                                          M.read (|
                                            M.SubPointer.get_struct_record_field (|
                                              M.deref (| M.read (| instruction |) |),
                                              "pinocchio::instruction::Instruction",
                                              "accounts"
                                            |)
                                          |)
                                        |)
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.never_to_any (|
                          M.read (|
                            M.return_ (|
                              Value.StructTuple
                                "core::result::Result::Err"
                                []
                                [ Ty.tuple []; Ty.path "pinocchio::program_error::ProgramError" ]
                                [
                                  Value.StructTuple
                                    "pinocchio::program_error::ProgramError::NotEnoughAccountKeys"
                                    []
                                    []
                                    []
                                ]
                            |)
                          |)
                        |)));
                    fun γ => ltac:(M.monadic (Value.Tuple []))
                  ]
                |) in
              let~ accounts :
                  Ty.apply
                    (Ty.path "array")
                    [ MAX_ACCOUNTS ]
                    [
                      Ty.apply
                        (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                        []
                        [ Ty.path "pinocchio::instruction::Account" ]
                    ] :=
                lib.repeat (|
                  M.read (|
                    get_constant (|
                      "pinocchio::cpi::inner_invoke_signed_with_bounds::UNINIT",
                      Ty.apply
                        (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                        []
                        [ Ty.path "pinocchio::instruction::Account" ]
                    |)
                  |),
                  MAX_ACCOUNTS
                |) in
              let~ _ : Ty.tuple [] :=
                M.match_operator (|
                  Ty.tuple [],
                  M.alloc (|
                    Ty.apply
                      (Ty.path "core::ops::control_flow::ControlFlow")
                      []
                      [
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [
                            Ty.path "core::convert::Infallible";
                            Ty.path "pinocchio::program_error::ProgramError"
                          ];
                        Ty.tuple []
                      ],
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::ops::control_flow::ControlFlow")
                        []
                        [
                          Ty.apply
                            (Ty.path "core::result::Result")
                            []
                            [
                              Ty.path "core::convert::Infallible";
                              Ty.path "pinocchio::program_error::ProgramError"
                            ];
                          Ty.tuple []
                        ],
                      M.get_trait_method (|
                        "core::ops::try_trait::Try",
                        Ty.apply
                          (Ty.path "core::result::Result")
                          []
                          [ Ty.tuple []; Ty.path "pinocchio::program_error::ProgramError" ],
                        [],
                        [],
                        "branch",
                        [],
                        []
                      |),
                      [
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::result::Result")
                            []
                            [ Ty.tuple []; Ty.path "pinocchio::program_error::ProgramError" ],
                          M.get_trait_method (|
                            "core::iter::traits::iterator::Iterator",
                            Ty.apply
                              (Ty.path "core::iter::adapters::zip::Zip")
                              []
                              [
                                Ty.apply
                                  (Ty.path "core::iter::adapters::zip::Zip")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::slice::iter::Iter")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "&")
                                          []
                                          [ Ty.path "pinocchio::account_info::AccountInfo" ]
                                      ];
                                    Ty.apply
                                      (Ty.path "core::slice::iter::Iter")
                                      []
                                      [ Ty.path "pinocchio::instruction::AccountMeta" ]
                                  ];
                                Ty.apply
                                  (Ty.path "core::slice::iter::IterMut")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                      []
                                      [ Ty.path "pinocchio::instruction::Account" ]
                                  ]
                              ],
                            [],
                            [],
                            "try_for_each",
                            [],
                            [
                              Ty.function
                                [
                                  Ty.tuple
                                    [
                                      Ty.tuple
                                        [
                                          Ty.apply
                                            (Ty.path "&")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "&")
                                                []
                                                [ Ty.path "pinocchio::account_info::AccountInfo" ]
                                            ];
                                          Ty.apply
                                            (Ty.path "&")
                                            []
                                            [ Ty.path "pinocchio::instruction::AccountMeta" ]
                                        ];
                                      Ty.apply
                                        (Ty.path "&mut")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                            []
                                            [ Ty.path "pinocchio::instruction::Account" ]
                                        ]
                                    ]
                                ]
                                (Ty.apply
                                  (Ty.path "core::result::Result")
                                  []
                                  [ Ty.tuple []; Ty.path "pinocchio::program_error::ProgramError"
                                  ]);
                              Ty.apply
                                (Ty.path "core::result::Result")
                                []
                                [ Ty.tuple []; Ty.path "pinocchio::program_error::ProgramError" ]
                            ]
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.MutRef,
                              M.alloc (|
                                Ty.apply
                                  (Ty.path "core::iter::adapters::zip::Zip")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::iter::adapters::zip::Zip")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "core::slice::iter::Iter")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "&")
                                              []
                                              [ Ty.path "pinocchio::account_info::AccountInfo" ]
                                          ];
                                        Ty.apply
                                          (Ty.path "core::slice::iter::Iter")
                                          []
                                          [ Ty.path "pinocchio::instruction::AccountMeta" ]
                                      ];
                                    Ty.apply
                                      (Ty.path "core::slice::iter::IterMut")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                          []
                                          [ Ty.path "pinocchio::instruction::Account" ]
                                      ]
                                  ],
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "core::iter::adapters::zip::Zip")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "core::iter::adapters::zip::Zip")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "core::slice::iter::Iter")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "&")
                                                []
                                                [ Ty.path "pinocchio::account_info::AccountInfo" ]
                                            ];
                                          Ty.apply
                                            (Ty.path "core::slice::iter::Iter")
                                            []
                                            [ Ty.path "pinocchio::instruction::AccountMeta" ]
                                        ];
                                      Ty.apply
                                        (Ty.path "core::slice::iter::IterMut")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                            []
                                            [ Ty.path "pinocchio::instruction::Account" ]
                                        ]
                                    ],
                                  M.get_trait_method (|
                                    "core::iter::traits::iterator::Iterator",
                                    Ty.apply
                                      (Ty.path "core::iter::adapters::zip::Zip")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "core::slice::iter::Iter")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "&")
                                              []
                                              [ Ty.path "pinocchio::account_info::AccountInfo" ]
                                          ];
                                        Ty.apply
                                          (Ty.path "core::slice::iter::Iter")
                                          []
                                          [ Ty.path "pinocchio::instruction::AccountMeta" ]
                                      ],
                                    [],
                                    [],
                                    "zip",
                                    [],
                                    [
                                      Ty.apply
                                        (Ty.path "core::slice::iter::IterMut")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                            []
                                            [ Ty.path "pinocchio::instruction::Account" ]
                                        ]
                                    ]
                                  |),
                                  [
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::iter::adapters::zip::Zip")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "core::slice::iter::Iter")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "&")
                                                []
                                                [ Ty.path "pinocchio::account_info::AccountInfo" ]
                                            ];
                                          Ty.apply
                                            (Ty.path "core::slice::iter::Iter")
                                            []
                                            [ Ty.path "pinocchio::instruction::AccountMeta" ]
                                        ],
                                      M.get_trait_method (|
                                        "core::iter::traits::iterator::Iterator",
                                        Ty.apply
                                          (Ty.path "core::slice::iter::Iter")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "&")
                                              []
                                              [ Ty.path "pinocchio::account_info::AccountInfo" ]
                                          ],
                                        [],
                                        [],
                                        "zip",
                                        [],
                                        [
                                          Ty.apply
                                            (Ty.path "core::slice::iter::Iter")
                                            []
                                            [ Ty.path "pinocchio::instruction::AccountMeta" ]
                                        ]
                                      |),
                                      [
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "core::slice::iter::Iter")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "&")
                                                []
                                                [ Ty.path "pinocchio::account_info::AccountInfo" ]
                                            ],
                                          M.get_associated_function (|
                                            Ty.apply
                                              (Ty.path "slice")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "&")
                                                  []
                                                  [ Ty.path "pinocchio::account_info::AccountInfo" ]
                                              ],
                                            "iter",
                                            [],
                                            []
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (| M.read (| account_infos |) |)
                                            |)
                                          ]
                                        |);
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "core::slice::iter::Iter")
                                            []
                                            [ Ty.path "pinocchio::instruction::AccountMeta" ],
                                          M.get_associated_function (|
                                            Ty.apply
                                              (Ty.path "slice")
                                              []
                                              [ Ty.path "pinocchio::instruction::AccountMeta" ],
                                            "iter",
                                            [],
                                            []
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.read (|
                                                  M.SubPointer.get_struct_record_field (|
                                                    M.deref (| M.read (| instruction |) |),
                                                    "pinocchio::instruction::Instruction",
                                                    "accounts"
                                                  |)
                                                |)
                                              |)
                                            |)
                                          ]
                                        |)
                                      ]
                                    |);
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::slice::iter::IterMut")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                            []
                                            [ Ty.path "pinocchio::instruction::Account" ]
                                        ],
                                      M.get_associated_function (|
                                        Ty.apply
                                          (Ty.path "slice")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                              []
                                              [ Ty.path "pinocchio::instruction::Account" ]
                                          ],
                                        "iter_mut",
                                        [],
                                        []
                                      |),
                                      [
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "&mut")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "slice")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                                    []
                                                    [ Ty.path "pinocchio::instruction::Account" ]
                                                ]
                                            ],
                                          M.pointer_coercion
                                            M.PointerCoercion.Unsize
                                            (Ty.apply
                                              (Ty.path "&mut")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "array")
                                                  [ MAX_ACCOUNTS ]
                                                  [
                                                    Ty.apply
                                                      (Ty.path
                                                        "core::mem::maybe_uninit::MaybeUninit")
                                                      []
                                                      [ Ty.path "pinocchio::instruction::Account" ]
                                                  ]
                                              ])
                                            (Ty.apply
                                              (Ty.path "&mut")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "slice")
                                                  []
                                                  [
                                                    Ty.apply
                                                      (Ty.path
                                                        "core::mem::maybe_uninit::MaybeUninit")
                                                      []
                                                      [ Ty.path "pinocchio::instruction::Account" ]
                                                  ]
                                              ]),
                                          [ M.borrow (| Pointer.Kind.MutRef, accounts |) ]
                                        |)
                                      ]
                                    |)
                                  ]
                                |)
                              |)
                            |);
                            M.closure
                              (fun γ =>
                                ltac:(M.monadic
                                  match γ with
                                  | [ α0 ] =>
                                    ltac:(M.monadic
                                      (M.match_operator (|
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          []
                                          [
                                            Ty.tuple [];
                                            Ty.path "pinocchio::program_error::ProgramError"
                                          ],
                                        M.alloc (|
                                          Ty.tuple
                                            [
                                              Ty.tuple
                                                [
                                                  Ty.apply
                                                    (Ty.path "&")
                                                    []
                                                    [
                                                      Ty.apply
                                                        (Ty.path "&")
                                                        []
                                                        [
                                                          Ty.path
                                                            "pinocchio::account_info::AccountInfo"
                                                        ]
                                                    ];
                                                  Ty.apply
                                                    (Ty.path "&")
                                                    []
                                                    [ Ty.path "pinocchio::instruction::AccountMeta"
                                                    ]
                                                ];
                                              Ty.apply
                                                (Ty.path "&mut")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                                    []
                                                    [ Ty.path "pinocchio::instruction::Account" ]
                                                ]
                                            ],
                                          α0
                                        |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let γ0_0 :=
                                                M.SubPointer.get_tuple_field (| γ, 0 |) in
                                              let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                              let γ1_0 :=
                                                M.SubPointer.get_tuple_field (| γ0_0, 0 |) in
                                              let γ1_1 :=
                                                M.SubPointer.get_tuple_field (| γ0_0, 1 |) in
                                              let account_info :=
                                                M.copy (|
                                                  Ty.apply
                                                    (Ty.path "&")
                                                    []
                                                    [
                                                      Ty.apply
                                                        (Ty.path "&")
                                                        []
                                                        [
                                                          Ty.path
                                                            "pinocchio::account_info::AccountInfo"
                                                        ]
                                                    ],
                                                  γ1_0
                                                |) in
                                              let account_meta :=
                                                M.copy (|
                                                  Ty.apply
                                                    (Ty.path "&")
                                                    []
                                                    [ Ty.path "pinocchio::instruction::AccountMeta"
                                                    ],
                                                  γ1_1
                                                |) in
                                              let account :=
                                                M.copy (|
                                                  Ty.apply
                                                    (Ty.path "&mut")
                                                    []
                                                    [
                                                      Ty.apply
                                                        (Ty.path
                                                          "core::mem::maybe_uninit::MaybeUninit")
                                                        []
                                                        [ Ty.path "pinocchio::instruction::Account"
                                                        ]
                                                    ],
                                                  γ0_1
                                                |) in
                                              M.read (|
                                                let~ _ : Ty.tuple [] :=
                                                  M.match_operator (|
                                                    Ty.tuple [],
                                                    M.alloc (| Ty.tuple [], Value.Tuple [] |),
                                                    [
                                                      fun γ =>
                                                        ltac:(M.monadic
                                                          (let γ :=
                                                            M.use
                                                              (M.alloc (|
                                                                Ty.path "bool",
                                                                M.call_closure (|
                                                                  Ty.path "bool",
                                                                  M.get_trait_method (|
                                                                    "core::cmp::PartialEq",
                                                                    Ty.apply
                                                                      (Ty.path "&")
                                                                      []
                                                                      [
                                                                        Ty.apply
                                                                          (Ty.path "array")
                                                                          [
                                                                            Value.Integer
                                                                              IntegerKind.Usize
                                                                              32
                                                                          ]
                                                                          [ Ty.path "u8" ]
                                                                      ],
                                                                    [],
                                                                    [
                                                                      Ty.apply
                                                                        (Ty.path "&")
                                                                        []
                                                                        [
                                                                          Ty.apply
                                                                            (Ty.path "array")
                                                                            [
                                                                              Value.Integer
                                                                                IntegerKind.Usize
                                                                                32
                                                                            ]
                                                                            [ Ty.path "u8" ]
                                                                        ]
                                                                    ],
                                                                    "ne",
                                                                    [],
                                                                    []
                                                                  |),
                                                                  [
                                                                    M.borrow (|
                                                                      Pointer.Kind.Ref,
                                                                      M.alloc (|
                                                                        Ty.apply
                                                                          (Ty.path "&")
                                                                          []
                                                                          [
                                                                            Ty.apply
                                                                              (Ty.path "array")
                                                                              [
                                                                                Value.Integer
                                                                                  IntegerKind.Usize
                                                                                  32
                                                                              ]
                                                                              [ Ty.path "u8" ]
                                                                          ],
                                                                        M.call_closure (|
                                                                          Ty.apply
                                                                            (Ty.path "&")
                                                                            []
                                                                            [
                                                                              Ty.apply
                                                                                (Ty.path "array")
                                                                                [
                                                                                  Value.Integer
                                                                                    IntegerKind.Usize
                                                                                    32
                                                                                ]
                                                                                [ Ty.path "u8" ]
                                                                            ],
                                                                          M.get_associated_function (|
                                                                            Ty.path
                                                                              "pinocchio::account_info::AccountInfo",
                                                                            "key",
                                                                            [],
                                                                            []
                                                                          |),
                                                                          [
                                                                            M.borrow (|
                                                                              Pointer.Kind.Ref,
                                                                              M.deref (|
                                                                                M.read (|
                                                                                  M.deref (|
                                                                                    M.read (|
                                                                                      account_info
                                                                                    |)
                                                                                  |)
                                                                                |)
                                                                              |)
                                                                            |)
                                                                          ]
                                                                        |)
                                                                      |)
                                                                    |);
                                                                    M.borrow (|
                                                                      Pointer.Kind.Ref,
                                                                      M.SubPointer.get_struct_record_field (|
                                                                        M.deref (|
                                                                          M.read (| account_meta |)
                                                                        |),
                                                                        "pinocchio::instruction::AccountMeta",
                                                                        "pubkey"
                                                                      |)
                                                                    |)
                                                                  ]
                                                                |)
                                                              |)) in
                                                          let _ :=
                                                            is_constant_or_break_match (|
                                                              M.read (| γ |),
                                                              Value.Bool true
                                                            |) in
                                                          M.never_to_any (|
                                                            M.read (|
                                                              M.return_ (|
                                                                Value.StructTuple
                                                                  "core::result::Result::Err"
                                                                  []
                                                                  [
                                                                    Ty.tuple [];
                                                                    Ty.path
                                                                      "pinocchio::program_error::ProgramError"
                                                                  ]
                                                                  [
                                                                    Value.StructTuple
                                                                      "pinocchio::program_error::ProgramError::InvalidArgument"
                                                                      []
                                                                      []
                                                                      []
                                                                  ]
                                                              |)
                                                            |)
                                                          |)));
                                                      fun γ => ltac:(M.monadic (Value.Tuple []))
                                                    ]
                                                  |) in
                                                let~ invalid_state :
                                                    Ty.path
                                                      "pinocchio::account_info::BorrowState" :=
                                                  M.match_operator (|
                                                    Ty.path "pinocchio::account_info::BorrowState",
                                                    M.alloc (| Ty.tuple [], Value.Tuple [] |),
                                                    [
                                                      fun γ =>
                                                        ltac:(M.monadic
                                                          (let γ :=
                                                            M.use
                                                              (M.SubPointer.get_struct_record_field (|
                                                                M.deref (|
                                                                  M.read (| account_meta |)
                                                                |),
                                                                "pinocchio::instruction::AccountMeta",
                                                                "is_writable"
                                                              |)) in
                                                          let _ :=
                                                            is_constant_or_break_match (|
                                                              M.read (| γ |),
                                                              Value.Bool true
                                                            |) in
                                                          Value.StructTuple
                                                            "pinocchio::account_info::BorrowState::Borrowed"
                                                            []
                                                            []
                                                            []));
                                                      fun γ =>
                                                        ltac:(M.monadic
                                                          (Value.StructTuple
                                                            "pinocchio::account_info::BorrowState::MutablyBorrowed"
                                                            []
                                                            []
                                                            []))
                                                    ]
                                                  |) in
                                                let~ _ : Ty.tuple [] :=
                                                  M.match_operator (|
                                                    Ty.tuple [],
                                                    M.alloc (| Ty.tuple [], Value.Tuple [] |),
                                                    [
                                                      fun γ =>
                                                        ltac:(M.monadic
                                                          (let γ :=
                                                            M.use
                                                              (M.alloc (|
                                                                Ty.path "bool",
                                                                M.call_closure (|
                                                                  Ty.path "bool",
                                                                  M.get_associated_function (|
                                                                    Ty.path
                                                                      "pinocchio::account_info::AccountInfo",
                                                                    "is_borrowed",
                                                                    [],
                                                                    []
                                                                  |),
                                                                  [
                                                                    M.borrow (|
                                                                      Pointer.Kind.Ref,
                                                                      M.deref (|
                                                                        M.read (|
                                                                          M.deref (|
                                                                            M.read (|
                                                                              account_info
                                                                            |)
                                                                          |)
                                                                        |)
                                                                      |)
                                                                    |);
                                                                    M.read (| invalid_state |)
                                                                  ]
                                                                |)
                                                              |)) in
                                                          let _ :=
                                                            is_constant_or_break_match (|
                                                              M.read (| γ |),
                                                              Value.Bool true
                                                            |) in
                                                          M.never_to_any (|
                                                            M.read (|
                                                              M.return_ (|
                                                                Value.StructTuple
                                                                  "core::result::Result::Err"
                                                                  []
                                                                  [
                                                                    Ty.tuple [];
                                                                    Ty.path
                                                                      "pinocchio::program_error::ProgramError"
                                                                  ]
                                                                  [
                                                                    Value.StructTuple
                                                                      "pinocchio::program_error::ProgramError::AccountBorrowFailed"
                                                                      []
                                                                      []
                                                                      []
                                                                  ]
                                                              |)
                                                            |)
                                                          |)));
                                                      fun γ => ltac:(M.monadic (Value.Tuple []))
                                                    ]
                                                  |) in
                                                let~ _ :
                                                    Ty.apply
                                                      (Ty.path "&mut")
                                                      []
                                                      [ Ty.path "pinocchio::instruction::Account"
                                                      ] :=
                                                  M.call_closure (|
                                                    Ty.apply
                                                      (Ty.path "&mut")
                                                      []
                                                      [ Ty.path "pinocchio::instruction::Account" ],
                                                    M.get_associated_function (|
                                                      Ty.apply
                                                        (Ty.path
                                                          "core::mem::maybe_uninit::MaybeUninit")
                                                        []
                                                        [ Ty.path "pinocchio::instruction::Account"
                                                        ],
                                                      "write",
                                                      [],
                                                      []
                                                    |),
                                                    [
                                                      M.borrow (|
                                                        Pointer.Kind.MutRef,
                                                        M.deref (| M.read (| account |) |)
                                                      |);
                                                      M.call_closure (|
                                                        Ty.path "pinocchio::instruction::Account",
                                                        M.get_trait_method (|
                                                          "core::convert::From",
                                                          Ty.path "pinocchio::instruction::Account",
                                                          [],
                                                          [
                                                            Ty.apply
                                                              (Ty.path "&")
                                                              []
                                                              [
                                                                Ty.path
                                                                  "pinocchio::account_info::AccountInfo"
                                                              ]
                                                          ],
                                                          "from",
                                                          [],
                                                          []
                                                        |),
                                                        [
                                                          M.read (|
                                                            M.deref (| M.read (| account_info |) |)
                                                          |)
                                                        ]
                                                      |)
                                                    ]
                                                  |) in
                                                M.alloc (|
                                                  Ty.apply
                                                    (Ty.path "core::result::Result")
                                                    []
                                                    [
                                                      Ty.tuple [];
                                                      Ty.path
                                                        "pinocchio::program_error::ProgramError"
                                                    ],
                                                  Value.StructTuple
                                                    "core::result::Result::Ok"
                                                    []
                                                    [
                                                      Ty.tuple [];
                                                      Ty.path
                                                        "pinocchio::program_error::ProgramError"
                                                    ]
                                                    [ Value.Tuple [] ]
                                                |)
                                              |)))
                                        ]
                                      |)))
                                  | _ => M.impossible "wrong number of arguments"
                                  end))
                          ]
                        |)
                      ]
                    |)
                  |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.SubPointer.get_struct_tuple_field (|
                            γ,
                            "core::ops::control_flow::ControlFlow::Break",
                            0
                          |) in
                        let residual :=
                          M.copy (|
                            Ty.apply
                              (Ty.path "core::result::Result")
                              []
                              [
                                Ty.path "core::convert::Infallible";
                                Ty.path "pinocchio::program_error::ProgramError"
                              ],
                            γ0_0
                          |) in
                        M.never_to_any (|
                          M.read (|
                            M.return_ (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::result::Result")
                                  []
                                  [ Ty.tuple []; Ty.path "pinocchio::program_error::ProgramError" ],
                                M.get_trait_method (|
                                  "core::ops::try_trait::FromResidual",
                                  Ty.apply
                                    (Ty.path "core::result::Result")
                                    []
                                    [ Ty.tuple []; Ty.path "pinocchio::program_error::ProgramError"
                                    ],
                                  [],
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path "pinocchio::program_error::ProgramError"
                                      ]
                                  ],
                                  "from_residual",
                                  [],
                                  []
                                |),
                                [ M.read (| residual |) ]
                              |)
                            |)
                          |)
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (let γ0_0 :=
                          M.SubPointer.get_struct_tuple_field (|
                            γ,
                            "core::ops::control_flow::ControlFlow::Continue",
                            0
                          |) in
                        let val := M.copy (| Ty.tuple [], γ0_0 |) in
                        M.read (| val |)))
                  ]
                |) in
              let~ _ : Ty.tuple [] :=
                M.read (|
                  let~ _ : Ty.tuple [] :=
                    M.call_closure (|
                      Ty.tuple [],
                      M.get_function (| "pinocchio::cpi::invoke_signed_unchecked", [], [] |),
                      [
                        M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| instruction |) |) |);
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (|
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "&")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "slice")
                                    []
                                    [ Ty.path "pinocchio::instruction::Account" ]
                                ],
                              M.get_function (|
                                "core::slice::raw::from_raw_parts",
                                [],
                                [ Ty.path "pinocchio::instruction::Account" ]
                              |),
                              [
                                M.cast
                                  (Ty.apply
                                    (Ty.path "*const")
                                    []
                                    [ Ty.path "pinocchio::instruction::Account" ])
                                  (M.call_closure (|
                                    Ty.apply
                                      (Ty.path "*const")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                          []
                                          [ Ty.path "pinocchio::instruction::Account" ]
                                      ],
                                    M.get_associated_function (|
                                      Ty.apply
                                        (Ty.path "slice")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                            []
                                            [ Ty.path "pinocchio::instruction::Account" ]
                                        ],
                                      "as_ptr",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.apply
                                          (Ty.path "&")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "slice")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                                  []
                                                  [ Ty.path "pinocchio::instruction::Account" ]
                                              ]
                                          ],
                                        M.pointer_coercion
                                          M.PointerCoercion.Unsize
                                          (Ty.apply
                                            (Ty.path "&")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "array")
                                                [ MAX_ACCOUNTS ]
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                                    []
                                                    [ Ty.path "pinocchio::instruction::Account" ]
                                                ]
                                            ])
                                          (Ty.apply
                                            (Ty.path "&")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "slice")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                                    []
                                                    [ Ty.path "pinocchio::instruction::Account" ]
                                                ]
                                            ]),
                                        [ M.borrow (| Pointer.Kind.Ref, accounts |) ]
                                      |)
                                    ]
                                  |));
                                M.call_closure (|
                                  Ty.path "usize",
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "slice")
                                      []
                                      [ Ty.path "pinocchio::instruction::AccountMeta" ],
                                    "len",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (|
                                        M.read (|
                                          M.SubPointer.get_struct_record_field (|
                                            M.deref (| M.read (| instruction |) |),
                                            "pinocchio::instruction::Instruction",
                                            "accounts"
                                          |)
                                        |)
                                      |)
                                    |)
                                  ]
                                |)
                              ]
                            |)
                          |)
                        |);
                        M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| signers_seeds |) |) |)
                      ]
                    |) in
                  M.alloc (| Ty.tuple [], Value.Tuple [] |)
                |) in
              M.alloc (|
                Ty.apply
                  (Ty.path "core::result::Result")
                  []
                  [ Ty.tuple []; Ty.path "pinocchio::program_error::ProgramError" ],
                Value.StructTuple
                  "core::result::Result::Ok"
                  []
                  [ Ty.tuple []; Ty.path "pinocchio::program_error::ProgramError" ]
                  [ Value.Tuple [] ]
              |)
            |)))
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_inner_invoke_signed_with_bounds :
    M.IsFunction.C
      "pinocchio::cpi::inner_invoke_signed_with_bounds"
      inner_invoke_signed_with_bounds.
  Admitted.
  Global Typeclasses Opaque inner_invoke_signed_with_bounds.
  
  Module inner_invoke_signed_with_bounds.
    Definition value_UNINIT (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      ltac:(M.monadic
        (M.alloc (|
          Ty.apply
            (Ty.path "core::mem::maybe_uninit::MaybeUninit")
            []
            [ Ty.path "pinocchio::instruction::Account" ],
          M.call_closure (|
            Ty.apply
              (Ty.path "core::mem::maybe_uninit::MaybeUninit")
              []
              [ Ty.path "pinocchio::instruction::Account" ],
            M.get_associated_function (|
              Ty.apply
                (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                []
                [ Ty.path "pinocchio::instruction::Account" ],
              "uninit",
              [],
              []
            |),
            []
          |)
        |))).
    
    Global Instance Instance_IsConstant_value_UNINIT :
      M.IsFunction.C "pinocchio::cpi::inner_invoke_signed_with_bounds::UNINIT" value_UNINIT.
    Admitted.
    Global Typeclasses Opaque value_UNINIT.
  End inner_invoke_signed_with_bounds.
  
  (*
  pub unsafe fn invoke_unchecked(instruction: &Instruction, accounts: &[Account]) {
      invoke_signed_unchecked(instruction, accounts, &[])
  }
  *)
  Definition invoke_unchecked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ instruction; accounts ] =>
      ltac:(M.monadic
        (let instruction :=
          M.alloc (|
            Ty.apply (Ty.path "&") [] [ Ty.path "pinocchio::instruction::Instruction" ],
            instruction
          |) in
        let accounts :=
          M.alloc (|
            Ty.apply
              (Ty.path "&")
              []
              [ Ty.apply (Ty.path "slice") [] [ Ty.path "pinocchio::instruction::Account" ] ],
            accounts
          |) in
        M.call_closure (|
          Ty.tuple [],
          M.get_function (| "pinocchio::cpi::invoke_signed_unchecked", [], [] |),
          [
            M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| instruction |) |) |);
            M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| accounts |) |) |);
            M.call_closure (|
              Ty.apply
                (Ty.path "&")
                []
                [ Ty.apply (Ty.path "slice") [] [ Ty.path "pinocchio::instruction::Signer" ] ],
              M.pointer_coercion
                M.PointerCoercion.Unsize
                (Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path "array")
                      [ Value.Integer IntegerKind.Usize 0 ]
                      [ Ty.path "pinocchio::instruction::Signer" ]
                  ])
                (Ty.apply
                  (Ty.path "&")
                  []
                  [ Ty.apply (Ty.path "slice") [] [ Ty.path "pinocchio::instruction::Signer" ] ]),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.alloc (|
                        Ty.apply
                          (Ty.path "array")
                          [ Value.Integer IntegerKind.Usize 0 ]
                          [ Ty.path "pinocchio::instruction::Signer" ],
                        Value.Array []
                      |)
                    |)
                  |)
                |)
              ]
            |)
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_invoke_unchecked :
    M.IsFunction.C "pinocchio::cpi::invoke_unchecked" invoke_unchecked.
  Admitted.
  Global Typeclasses Opaque invoke_unchecked.
  
  (*
  pub unsafe fn invoke_signed_unchecked(
      instruction: &Instruction,
      accounts: &[Account],
      signers_seeds: &[Signer],
  ) {
      #[cfg(target_os = "solana")]
      {
          use crate::instruction::AccountMeta;
  
          /// An `Instruction` as expected by `sol_invoke_signed_c`.
          ///
          /// DO NOT EXPOSE THIS STRUCT:
          ///
          /// To ensure pointers are valid upon use, the scope of this struct should
          /// only be limited to the stack where sol_invoke_signed_c happens and then
          /// discarded immediately after.
          #[repr(C)]
          struct CInstruction<'a> {
              /// Public key of the program.
              program_id: *const Pubkey,
  
              /// Accounts expected by the program instruction.
              accounts: *const AccountMeta<'a>,
  
              /// Number of accounts expected by the program instruction.
              accounts_len: u64,
  
              /// Data expected by the program instruction.
              data: *const u8,
  
              /// Length of the data expected by the program instruction.
              data_len: u64,
          }
  
          let cpi_instruction = CInstruction {
              program_id: instruction.program_id,
              accounts: instruction.accounts.as_ptr(),
              accounts_len: instruction.accounts.len() as u64,
              data: instruction.data.as_ptr(),
              data_len: instruction.data.len() as u64,
          };
  
          unsafe {
              crate::syscalls::sol_invoke_signed_c(
                  &cpi_instruction as *const _ as *const u8,
                  accounts as *const _ as *const u8,
                  accounts.len() as u64,
                  signers_seeds as *const _ as *const u8,
                  signers_seeds.len() as u64,
              )
          };
      }
  
      #[cfg(not(target_os = "solana"))]
      core::hint::black_box((instruction, accounts, signers_seeds));
  }
  *)
  Definition invoke_signed_unchecked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ instruction; accounts; signers_seeds ] =>
      ltac:(M.monadic
        (let instruction :=
          M.alloc (|
            Ty.apply (Ty.path "&") [] [ Ty.path "pinocchio::instruction::Instruction" ],
            instruction
          |) in
        let accounts :=
          M.alloc (|
            Ty.apply
              (Ty.path "&")
              []
              [ Ty.apply (Ty.path "slice") [] [ Ty.path "pinocchio::instruction::Account" ] ],
            accounts
          |) in
        let signers_seeds :=
          M.alloc (|
            Ty.apply
              (Ty.path "&")
              []
              [ Ty.apply (Ty.path "slice") [] [ Ty.path "pinocchio::instruction::Signer" ] ],
            signers_seeds
          |) in
        M.read (|
          let~ _ :
              Ty.tuple
                [
                  Ty.apply (Ty.path "&") [] [ Ty.path "pinocchio::instruction::Instruction" ];
                  Ty.apply
                    (Ty.path "&")
                    []
                    [ Ty.apply (Ty.path "slice") [] [ Ty.path "pinocchio::instruction::Account" ] ];
                  Ty.apply
                    (Ty.path "&")
                    []
                    [ Ty.apply (Ty.path "slice") [] [ Ty.path "pinocchio::instruction::Signer" ] ]
                ] :=
            M.call_closure (|
              Ty.tuple
                [
                  Ty.apply (Ty.path "&") [] [ Ty.path "pinocchio::instruction::Instruction" ];
                  Ty.apply
                    (Ty.path "&")
                    []
                    [ Ty.apply (Ty.path "slice") [] [ Ty.path "pinocchio::instruction::Account" ] ];
                  Ty.apply
                    (Ty.path "&")
                    []
                    [ Ty.apply (Ty.path "slice") [] [ Ty.path "pinocchio::instruction::Signer" ] ]
                ],
              M.get_function (|
                "core::hint::black_box",
                [],
                [
                  Ty.tuple
                    [
                      Ty.apply (Ty.path "&") [] [ Ty.path "pinocchio::instruction::Instruction" ];
                      Ty.apply
                        (Ty.path "&")
                        []
                        [
                          Ty.apply
                            (Ty.path "slice")
                            []
                            [ Ty.path "pinocchio::instruction::Account" ]
                        ];
                      Ty.apply
                        (Ty.path "&")
                        []
                        [ Ty.apply (Ty.path "slice") [] [ Ty.path "pinocchio::instruction::Signer" ]
                        ]
                    ]
                ]
              |),
              [
                Value.Tuple
                  [ M.read (| instruction |); M.read (| accounts |); M.read (| signers_seeds |) ]
              ]
            |) in
          M.alloc (| Ty.tuple [], Value.Tuple [] |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_invoke_signed_unchecked :
    M.IsFunction.C "pinocchio::cpi::invoke_signed_unchecked" invoke_signed_unchecked.
  Admitted.
  Global Typeclasses Opaque invoke_signed_unchecked.
  
  Definition value_MAX_RETURN_DATA (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    ltac:(M.monadic (M.alloc (| Ty.path "usize", Value.Integer IntegerKind.Usize 1024 |))).
  
  Global Instance Instance_IsConstant_value_MAX_RETURN_DATA :
    M.IsFunction.C "pinocchio::cpi::MAX_RETURN_DATA" value_MAX_RETURN_DATA.
  Admitted.
  Global Typeclasses Opaque value_MAX_RETURN_DATA.
  
  (*
  pub fn set_return_data(data: &[u8]) {
      #[cfg(target_os = "solana")]
      unsafe {
          crate::syscalls::sol_set_return_data(data.as_ptr(), data.len() as u64)
      };
  
      #[cfg(not(target_os = "solana"))]
      core::hint::black_box(data);
  }
  *)
  Definition set_return_data (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ data ] =>
      ltac:(M.monadic
        (let data :=
          M.alloc (|
            Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
            data
          |) in
        M.read (|
          let~ _ : Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ] :=
            M.call_closure (|
              Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
              M.get_function (|
                "core::hint::black_box",
                [],
                [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ] ]
              |),
              [ M.read (| data |) ]
            |) in
          M.alloc (| Ty.tuple [], Value.Tuple [] |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_set_return_data :
    M.IsFunction.C "pinocchio::cpi::set_return_data" set_return_data.
  Admitted.
  Global Typeclasses Opaque set_return_data.
  
  (*
  pub fn get_return_data() -> Option<ReturnData> {
      #[cfg(target_os = "solana")]
      {
          const UNINIT_BYTE: core::mem::MaybeUninit<u8> = core::mem::MaybeUninit::<u8>::uninit();
          let mut data = [UNINIT_BYTE; MAX_RETURN_DATA];
          let mut program_id = MaybeUninit::<Pubkey>::uninit();
  
          let size = unsafe {
              crate::syscalls::sol_get_return_data(
                  data.as_mut_ptr() as *mut u8,
                  data.len() as u64,
                  program_id.as_mut_ptr() as *mut Pubkey,
              )
          };
  
          if size == 0 {
              None
          } else {
              Some(ReturnData {
                  program_id: unsafe { program_id.assume_init() },
                  data,
                  size: core::cmp::min(size as usize, MAX_RETURN_DATA),
              })
          }
      }
  
      #[cfg(not(target_os = "solana"))]
      core::hint::black_box(None)
  }
  *)
  Definition get_return_data (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [] =>
      ltac:(M.monadic
        (M.call_closure (|
          Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "pinocchio::cpi::ReturnData" ],
          M.get_function (|
            "core::hint::black_box",
            [],
            [ Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "pinocchio::cpi::ReturnData" ]
            ]
          |),
          [
            Value.StructTuple
              "core::option::Option::None"
              []
              [ Ty.path "pinocchio::cpi::ReturnData" ]
              []
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_get_return_data :
    M.IsFunction.C "pinocchio::cpi::get_return_data" get_return_data.
  Admitted.
  Global Typeclasses Opaque get_return_data.
  
  (* StructRecord
    {
      name := "ReturnData";
      const_params := [];
      ty_params := [];
      fields :=
        [
          ("program_id",
            Ty.apply
              (Ty.path "array")
              [ M.unevaluated_const (mk_str (| "pinocchio_pubkey_Pubkey_discriminant" |)) ]
              [ Ty.path "u8" ]);
          ("data",
            Ty.apply
              (Ty.path "array")
              [ M.unevaluated_const (mk_str (| "pinocchio_cpi_ReturnData_data_discriminant" |)) ]
              [ Ty.apply (Ty.path "core::mem::maybe_uninit::MaybeUninit") [] [ Ty.path "u8" ] ]);
          ("size", Ty.path "usize")
        ];
    } *)
  
  Module Impl_pinocchio_cpi_ReturnData.
    Definition Self : Ty.t := Ty.path "pinocchio::cpi::ReturnData".
    
    (*
        pub fn program_id(&self) -> &Pubkey {
            &self.program_id
        }
    *)
    Definition program_id (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply (Ty.path "&") [] [ Ty.path "pinocchio::cpi::ReturnData" ],
              self
            |) in
          M.borrow (|
            Pointer.Kind.Ref,
            M.deref (|
              M.borrow (|
                Pointer.Kind.Ref,
                M.SubPointer.get_struct_record_field (|
                  M.deref (| M.read (| self |) |),
                  "pinocchio::cpi::ReturnData",
                  "program_id"
                |)
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_program_id :
      M.IsAssociatedFunction.C Self "program_id" program_id.
    Admitted.
    Global Typeclasses Opaque program_id.
    
    (*
        pub fn as_slice(&self) -> &[u8] {
            unsafe { from_raw_parts(self.data.as_ptr() as _, self.size) }
        }
    *)
    Definition as_slice (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply (Ty.path "&") [] [ Ty.path "pinocchio::cpi::ReturnData" ],
              self
            |) in
          M.borrow (|
            Pointer.Kind.Ref,
            M.deref (|
              M.call_closure (|
                Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                M.get_function (| "core::slice::raw::from_raw_parts", [], [ Ty.path "u8" ] |),
                [
                  M.cast
                    (Ty.apply (Ty.path "*const") [] [ Ty.path "u8" ])
                    (M.call_closure (|
                      Ty.apply
                        (Ty.path "*const")
                        []
                        [
                          Ty.apply
                            (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                            []
                            [ Ty.path "u8" ]
                        ],
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "slice")
                          []
                          [
                            Ty.apply
                              (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                              []
                              [ Ty.path "u8" ]
                          ],
                        "as_ptr",
                        [],
                        []
                      |),
                      [
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "&")
                            []
                            [
                              Ty.apply
                                (Ty.path "slice")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                    []
                                    [ Ty.path "u8" ]
                                ]
                            ],
                          M.pointer_coercion
                            M.PointerCoercion.Unsize
                            (Ty.apply
                              (Ty.path "&")
                              []
                              [
                                Ty.apply
                                  (Ty.path "array")
                                  [ Value.Integer IntegerKind.Usize 1024 ]
                                  [
                                    Ty.apply
                                      (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                      []
                                      [ Ty.path "u8" ]
                                  ]
                              ])
                            (Ty.apply
                              (Ty.path "&")
                              []
                              [
                                Ty.apply
                                  (Ty.path "slice")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                      []
                                      [ Ty.path "u8" ]
                                  ]
                              ]),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "pinocchio::cpi::ReturnData",
                                "data"
                              |)
                            |)
                          ]
                        |)
                      ]
                    |));
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "pinocchio::cpi::ReturnData",
                      "size"
                    |)
                  |)
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_as_slice : M.IsAssociatedFunction.C Self "as_slice" as_slice.
    Admitted.
    Global Typeclasses Opaque as_slice.
  End Impl_pinocchio_cpi_ReturnData.
  
  Module Impl_core_ops_deref_Deref_for_pinocchio_cpi_ReturnData.
    Definition Self : Ty.t := Ty.path "pinocchio::cpi::ReturnData".
    
    (*     type Target = [u8]; *)
    Definition _Target : Ty.t := Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ].
    
    (*
        fn deref(&self) -> &Self::Target {
            self.as_slice()
        }
    *)
    Definition deref (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self :=
            M.alloc (|
              Ty.apply (Ty.path "&") [] [ Ty.path "pinocchio::cpi::ReturnData" ],
              self
            |) in
          M.borrow (|
            Pointer.Kind.Ref,
            M.deref (|
              M.call_closure (|
                Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                M.get_associated_function (|
                  Ty.path "pinocchio::cpi::ReturnData",
                  "as_slice",
                  [],
                  []
                |),
                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      M.IsTraitInstance
        "core::ops::deref::Deref"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        Self
        (* Instance *)
        [ ("Target", InstanceField.Ty _Target); ("deref", InstanceField.Method deref) ].
  End Impl_core_ops_deref_Deref_for_pinocchio_cpi_ReturnData.
End cpi.
