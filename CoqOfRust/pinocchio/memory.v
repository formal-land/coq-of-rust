(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module memory.
  (*
  pub unsafe fn sol_memcpy(dst: &mut [u8], src: &[u8], n: usize) {
      #[cfg(target_os = "solana")]
      syscalls::sol_memcpy_(dst.as_mut_ptr(), src.as_ptr(), n as u64);
  
      #[cfg(not(target_os = "solana"))]
      core::hint::black_box((dst, src, n));
  }
  *)
  Definition sol_memcpy (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ dst; src; n ] =>
      ltac:(M.monadic
        (let dst :=
          M.alloc (|
            Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
            dst
          |) in
        let src :=
          M.alloc (|
            Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
            src
          |) in
        let n := M.alloc (| Ty.path "usize", n |) in
        M.read (|
          let~ _ :
              Ty.tuple
                [
                  Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ];
                  Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ];
                  Ty.path "usize"
                ] :=
            M.call_closure (|
              Ty.tuple
                [
                  Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ];
                  Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ];
                  Ty.path "usize"
                ],
              M.get_function (|
                "core::hint::black_box",
                [],
                [
                  Ty.tuple
                    [
                      Ty.apply
                        (Ty.path "&mut")
                        []
                        [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ];
                      Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ];
                      Ty.path "usize"
                    ]
                ]
              |),
              [ Value.Tuple [ M.read (| dst |); M.read (| src |); M.read (| n |) ] ]
            |) in
          M.alloc (| Ty.tuple [], Value.Tuple [] |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_sol_memcpy :
    M.IsFunction.C "pinocchio::memory::sol_memcpy" sol_memcpy.
  Admitted.
  Global Typeclasses Opaque sol_memcpy.
  
  (*
  pub fn copy_val<T: Copy>(dst: &mut T, src: &T) {
      #[cfg(target_os = "solana")]
      // SAFETY: `dst` and `src` are of same type therefore the size
      // is the same.
      unsafe {
          syscalls::sol_memcpy_(
              dst as *mut T as *mut u8,
              src as *const T as *const u8,
              core::mem::size_of::<T>() as u64,
          );
      }
  
      #[cfg(not(target_os = "solana"))]
      {
          *dst = *src;
      }
  }
  *)
  Definition copy_val (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ T ], [ dst; src ] =>
      ltac:(M.monadic
        (let dst := M.alloc (| Ty.apply (Ty.path "&mut") [] [ T ], dst |) in
        let src := M.alloc (| Ty.apply (Ty.path "&") [] [ T ], src |) in
        M.read (|
          let~ _ : Ty.tuple [] :=
            M.write (|
              M.deref (| M.read (| dst |) |),
              M.read (| M.deref (| M.read (| src |) |) |)
            |) in
          M.alloc (| Ty.tuple [], Value.Tuple [] |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_copy_val :
    M.IsFunction.C "pinocchio::memory::copy_val" copy_val.
  Admitted.
  Global Typeclasses Opaque copy_val.
  
  (*
  pub unsafe fn sol_memmove(dst: *mut u8, src: *const u8, n: usize) {
      #[cfg(target_os = "solana")]
      syscalls::sol_memmove_(dst, src, n as u64);
  
      #[cfg(not(target_os = "solana"))]
      core::hint::black_box((dst, src, n));
  }
  *)
  Definition sol_memmove (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ dst; src; n ] =>
      ltac:(M.monadic
        (let dst := M.alloc (| Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ], dst |) in
        let src := M.alloc (| Ty.apply (Ty.path "*const") [] [ Ty.path "u8" ], src |) in
        let n := M.alloc (| Ty.path "usize", n |) in
        M.read (|
          let~ _ :
              Ty.tuple
                [
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ];
                  Ty.apply (Ty.path "*const") [] [ Ty.path "u8" ];
                  Ty.path "usize"
                ] :=
            M.call_closure (|
              Ty.tuple
                [
                  Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ];
                  Ty.apply (Ty.path "*const") [] [ Ty.path "u8" ];
                  Ty.path "usize"
                ],
              M.get_function (|
                "core::hint::black_box",
                [],
                [
                  Ty.tuple
                    [
                      Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ];
                      Ty.apply (Ty.path "*const") [] [ Ty.path "u8" ];
                      Ty.path "usize"
                    ]
                ]
              |),
              [ Value.Tuple [ M.read (| dst |); M.read (| src |); M.read (| n |) ] ]
            |) in
          M.alloc (| Ty.tuple [], Value.Tuple [] |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_sol_memmove :
    M.IsFunction.C "pinocchio::memory::sol_memmove" sol_memmove.
  Admitted.
  Global Typeclasses Opaque sol_memmove.
  
  (*
  pub unsafe fn sol_memcmp(s1: &[u8], s2: &[u8], n: usize) -> i32 {
      #[allow(unused_mut)]
      let mut result = 0;
  
      #[cfg(target_os = "solana")]
      syscalls::sol_memcmp_(s1.as_ptr(), s2.as_ptr(), n as u64, &mut result as *mut i32);
  
      #[cfg(not(target_os = "solana"))]
      core::hint::black_box((s1, s2, n, result));
  
      result
  }
  *)
  Definition sol_memcmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ s1; s2; n ] =>
      ltac:(M.monadic
        (let s1 :=
          M.alloc (|
            Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
            s1
          |) in
        let s2 :=
          M.alloc (|
            Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
            s2
          |) in
        let n := M.alloc (| Ty.path "usize", n |) in
        M.read (|
          let~ result : Ty.path "i32" := Value.Integer IntegerKind.I32 0 in
          let~ _ :
              Ty.tuple
                [
                  Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ];
                  Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ];
                  Ty.path "usize";
                  Ty.path "i32"
                ] :=
            M.call_closure (|
              Ty.tuple
                [
                  Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ];
                  Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ];
                  Ty.path "usize";
                  Ty.path "i32"
                ],
              M.get_function (|
                "core::hint::black_box",
                [],
                [
                  Ty.tuple
                    [
                      Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ];
                      Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ];
                      Ty.path "usize";
                      Ty.path "i32"
                    ]
                ]
              |),
              [
                Value.Tuple
                  [ M.read (| s1 |); M.read (| s2 |); M.read (| n |); M.read (| result |) ]
              ]
            |) in
          result
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_sol_memcmp :
    M.IsFunction.C "pinocchio::memory::sol_memcmp" sol_memcmp.
  Admitted.
  Global Typeclasses Opaque sol_memcmp.
  
  (*
  pub unsafe fn sol_memset(s: &mut [u8], c: u8, n: usize) {
      #[cfg(target_os = "solana")]
      syscalls::sol_memset_(s.as_mut_ptr(), c, n as u64);
  
      #[cfg(not(target_os = "solana"))]
      core::hint::black_box((s, c, n));
  }
  *)
  Definition sol_memset (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ s; c; n ] =>
      ltac:(M.monadic
        (let s :=
          M.alloc (|
            Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
            s
          |) in
        let c := M.alloc (| Ty.path "u8", c |) in
        let n := M.alloc (| Ty.path "usize", n |) in
        M.read (|
          let~ _ :
              Ty.tuple
                [
                  Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ];
                  Ty.path "u8";
                  Ty.path "usize"
                ] :=
            M.call_closure (|
              Ty.tuple
                [
                  Ty.apply (Ty.path "&mut") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ];
                  Ty.path "u8";
                  Ty.path "usize"
                ],
              M.get_function (|
                "core::hint::black_box",
                [],
                [
                  Ty.tuple
                    [
                      Ty.apply
                        (Ty.path "&mut")
                        []
                        [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ];
                      Ty.path "u8";
                      Ty.path "usize"
                    ]
                ]
              |),
              [ Value.Tuple [ M.read (| s |); M.read (| c |); M.read (| n |) ] ]
            |) in
          M.alloc (| Ty.tuple [], Value.Tuple [] |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_sol_memset :
    M.IsFunction.C "pinocchio::memory::sol_memset" sol_memset.
  Admitted.
  Global Typeclasses Opaque sol_memset.
End memory.
