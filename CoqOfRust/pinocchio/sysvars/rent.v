(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module sysvars.
  Module rent.
    Definition value_RENT_ID (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      ltac:(M.monadic
        (M.alloc (|
          Ty.apply (Ty.path "array") [ Value.Integer IntegerKind.Usize 32 ] [ Ty.path "u8" ],
          Value.Array
            [
              Value.Integer IntegerKind.U8 6;
              Value.Integer IntegerKind.U8 167;
              Value.Integer IntegerKind.U8 213;
              Value.Integer IntegerKind.U8 23;
              Value.Integer IntegerKind.U8 25;
              Value.Integer IntegerKind.U8 44;
              Value.Integer IntegerKind.U8 92;
              Value.Integer IntegerKind.U8 81;
              Value.Integer IntegerKind.U8 33;
              Value.Integer IntegerKind.U8 140;
              Value.Integer IntegerKind.U8 201;
              Value.Integer IntegerKind.U8 76;
              Value.Integer IntegerKind.U8 61;
              Value.Integer IntegerKind.U8 74;
              Value.Integer IntegerKind.U8 241;
              Value.Integer IntegerKind.U8 127;
              Value.Integer IntegerKind.U8 88;
              Value.Integer IntegerKind.U8 218;
              Value.Integer IntegerKind.U8 238;
              Value.Integer IntegerKind.U8 8;
              Value.Integer IntegerKind.U8 155;
              Value.Integer IntegerKind.U8 161;
              Value.Integer IntegerKind.U8 253;
              Value.Integer IntegerKind.U8 68;
              Value.Integer IntegerKind.U8 227;
              Value.Integer IntegerKind.U8 219;
              Value.Integer IntegerKind.U8 217;
              Value.Integer IntegerKind.U8 138;
              Value.Integer IntegerKind.U8 0;
              Value.Integer IntegerKind.U8 0;
              Value.Integer IntegerKind.U8 0;
              Value.Integer IntegerKind.U8 0
            ]
        |))).
    
    Global Instance Instance_IsConstant_value_RENT_ID :
      M.IsFunction.C "pinocchio::sysvars::rent::RENT_ID" value_RENT_ID.
    Admitted.
    Global Typeclasses Opaque value_RENT_ID.
    
    Definition value_DEFAULT_LAMPORTS_PER_BYTE_YEAR
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      ltac:(M.monadic
        (M.alloc (|
          Ty.path "u64",
          M.call_closure (|
            Ty.path "u64",
            BinOp.Wrap.div,
            [
              M.call_closure (|
                Ty.path "u64",
                BinOp.Wrap.mul,
                [
                  M.call_closure (|
                    Ty.path "u64",
                    BinOp.Wrap.div,
                    [ Value.Integer IntegerKind.U64 1000000000; Value.Integer IntegerKind.U64 100 ]
                  |);
                  Value.Integer IntegerKind.U64 365
                ]
              |);
              M.call_closure (|
                Ty.path "u64",
                BinOp.Wrap.mul,
                [ Value.Integer IntegerKind.U64 1024; Value.Integer IntegerKind.U64 1024 ]
              |)
            ]
          |)
        |))).
    
    Global Instance Instance_IsConstant_value_DEFAULT_LAMPORTS_PER_BYTE_YEAR :
      M.IsFunction.C
        "pinocchio::sysvars::rent::DEFAULT_LAMPORTS_PER_BYTE_YEAR"
        value_DEFAULT_LAMPORTS_PER_BYTE_YEAR.
    Admitted.
    Global Typeclasses Opaque value_DEFAULT_LAMPORTS_PER_BYTE_YEAR.
    
    Definition value_DEFAULT_EXEMPTION_THRESHOLD
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      ltac:(M.monadic UnsupportedLiteral).
    
    Global Instance Instance_IsConstant_value_DEFAULT_EXEMPTION_THRESHOLD :
      M.IsFunction.C
        "pinocchio::sysvars::rent::DEFAULT_EXEMPTION_THRESHOLD"
        value_DEFAULT_EXEMPTION_THRESHOLD.
    Admitted.
    Global Typeclasses Opaque value_DEFAULT_EXEMPTION_THRESHOLD.
    
    Definition value_DEFAULT_EXEMPTION_THRESHOLD_AS_U64
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      ltac:(M.monadic (M.alloc (| Ty.path "u64", Value.Integer IntegerKind.U64 2 |))).
    
    Global Instance Instance_IsConstant_value_DEFAULT_EXEMPTION_THRESHOLD_AS_U64 :
      M.IsFunction.C
        "pinocchio::sysvars::rent::DEFAULT_EXEMPTION_THRESHOLD_AS_U64"
        value_DEFAULT_EXEMPTION_THRESHOLD_AS_U64.
    Admitted.
    Global Typeclasses Opaque value_DEFAULT_EXEMPTION_THRESHOLD_AS_U64.
    
    Definition value_F64_EXEMPTION_THRESHOLD_AS_U64
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      ltac:(M.monadic
        (M.alloc (| Ty.path "u64", Value.Integer IntegerKind.U64 4611686018427387904 |))).
    
    Global Instance Instance_IsConstant_value_F64_EXEMPTION_THRESHOLD_AS_U64 :
      M.IsFunction.C
        "pinocchio::sysvars::rent::F64_EXEMPTION_THRESHOLD_AS_U64"
        value_F64_EXEMPTION_THRESHOLD_AS_U64.
    Admitted.
    Global Typeclasses Opaque value_F64_EXEMPTION_THRESHOLD_AS_U64.
    
    Definition value_DEFAULT_BURN_PERCENT
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      ltac:(M.monadic (M.alloc (| Ty.path "u8", Value.Integer IntegerKind.U8 50 |))).
    
    Global Instance Instance_IsConstant_value_DEFAULT_BURN_PERCENT :
      M.IsFunction.C "pinocchio::sysvars::rent::DEFAULT_BURN_PERCENT" value_DEFAULT_BURN_PERCENT.
    Admitted.
    Global Typeclasses Opaque value_DEFAULT_BURN_PERCENT.
    
    Definition value_ACCOUNT_STORAGE_OVERHEAD
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      ltac:(M.monadic (M.alloc (| Ty.path "u64", Value.Integer IntegerKind.U64 128 |))).
    
    Global Instance Instance_IsConstant_value_ACCOUNT_STORAGE_OVERHEAD :
      M.IsFunction.C
        "pinocchio::sysvars::rent::ACCOUNT_STORAGE_OVERHEAD"
        value_ACCOUNT_STORAGE_OVERHEAD.
    Admitted.
    Global Typeclasses Opaque value_ACCOUNT_STORAGE_OVERHEAD.
    
    (* StructRecord
      {
        name := "Rent";
        const_params := [];
        ty_params := [];
        fields :=
          [
            ("lamports_per_byte_year", Ty.path "u64");
            ("exemption_threshold", Ty.path "f64");
            ("burn_percent", Ty.path "u8")
          ];
      } *)
    
    Module Impl_core_clone_Clone_for_pinocchio_sysvars_rent_Rent.
      Definition Self : Ty.t := Ty.path "pinocchio::sysvars::rent::Rent".
      
      (* Clone *)
      Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "&") [] [ Ty.path "pinocchio::sysvars::rent::Rent" ],
                self
              |) in
            Value.mkStructRecord
              "pinocchio::sysvars::rent::Rent"
              []
              []
              [
                ("lamports_per_byte_year",
                  M.call_closure (|
                    Ty.path "u64",
                    M.get_trait_method (|
                      "core::clone::Clone",
                      Ty.path "u64",
                      [],
                      [],
                      "clone",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "pinocchio::sysvars::rent::Rent",
                              "lamports_per_byte_year"
                            |)
                          |)
                        |)
                      |)
                    ]
                  |));
                ("exemption_threshold",
                  M.call_closure (|
                    Ty.path "f64",
                    M.get_trait_method (|
                      "core::clone::Clone",
                      Ty.path "f64",
                      [],
                      [],
                      "clone",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "pinocchio::sysvars::rent::Rent",
                              "exemption_threshold"
                            |)
                          |)
                        |)
                      |)
                    ]
                  |));
                ("burn_percent",
                  M.call_closure (|
                    Ty.path "u8",
                    M.get_trait_method (|
                      "core::clone::Clone",
                      Ty.path "u8",
                      [],
                      [],
                      "clone",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.deref (|
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "pinocchio::sysvars::rent::Rent",
                              "burn_percent"
                            |)
                          |)
                        |)
                      |)
                    ]
                  |))
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::clone::Clone"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("clone", InstanceField.Method clone) ].
    End Impl_core_clone_Clone_for_pinocchio_sysvars_rent_Rent.
    
    Module Impl_core_fmt_Debug_for_pinocchio_sysvars_rent_Rent.
      Definition Self : Ty.t := Ty.path "pinocchio::sysvars::rent::Rent".
      
      (* Debug *)
      Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "&") [] [ Ty.path "pinocchio::sysvars::rent::Rent" ],
                self
              |) in
            let f :=
              M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "core::fmt::Formatter" ], f |) in
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
              M.get_associated_function (|
                Ty.path "core::fmt::Formatter",
                "debug_struct_field3_finish",
                [],
                []
              |),
              [
                M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "Rent" |) |) |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (| mk_str (| "lamports_per_byte_year" |) |)
                |);
                M.call_closure (|
                  Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ],
                  M.pointer_coercion
                    M.PointerCoercion.Unsize
                    (Ty.apply (Ty.path "&") [] [ Ty.path "u64" ])
                    (Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ]),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "pinocchio::sysvars::rent::Rent",
                            "lamports_per_byte_year"
                          |)
                        |)
                      |)
                    |)
                  ]
                |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "exemption_threshold" |) |) |);
                M.call_closure (|
                  Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ],
                  M.pointer_coercion
                    M.PointerCoercion.Unsize
                    (Ty.apply (Ty.path "&") [] [ Ty.path "f64" ])
                    (Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ]),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "pinocchio::sysvars::rent::Rent",
                            "exemption_threshold"
                          |)
                        |)
                      |)
                    |)
                  ]
                |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "burn_percent" |) |) |);
                M.call_closure (|
                  Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ],
                  M.pointer_coercion
                    M.PointerCoercion.Unsize
                    (Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "&") [] [ Ty.path "u8" ] ])
                    (Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ]),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.alloc (|
                            Ty.apply (Ty.path "&") [] [ Ty.path "u8" ],
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "pinocchio::sysvars::rent::Rent",
                                "burn_percent"
                              |)
                            |)
                          |)
                        |)
                      |)
                    |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Debug"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Debug_for_pinocchio_sysvars_rent_Rent.
    
    Module Impl_core_default_Default_for_pinocchio_sysvars_rent_Rent.
      Definition Self : Ty.t := Ty.path "pinocchio::sysvars::rent::Rent".
      
      (* Default *)
      Definition default (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [] =>
          ltac:(M.monadic
            (Value.mkStructRecord
              "pinocchio::sysvars::rent::Rent"
              []
              []
              [
                ("lamports_per_byte_year",
                  M.call_closure (|
                    Ty.path "u64",
                    M.get_trait_method (|
                      "core::default::Default",
                      Ty.path "u64",
                      [],
                      [],
                      "default",
                      [],
                      []
                    |),
                    []
                  |));
                ("exemption_threshold",
                  M.call_closure (|
                    Ty.path "f64",
                    M.get_trait_method (|
                      "core::default::Default",
                      Ty.path "f64",
                      [],
                      [],
                      "default",
                      [],
                      []
                    |),
                    []
                  |));
                ("burn_percent",
                  M.call_closure (|
                    Ty.path "u8",
                    M.get_trait_method (|
                      "core::default::Default",
                      Ty.path "u8",
                      [],
                      [],
                      "default",
                      [],
                      []
                    |),
                    []
                  |))
              ]))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::default::Default"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("default", InstanceField.Method default) ].
    End Impl_core_default_Default_for_pinocchio_sysvars_rent_Rent.
    
    Module Impl_pinocchio_sysvars_rent_Rent.
      Definition Self : Ty.t := Ty.path "pinocchio::sysvars::rent::Rent".
      
      (*     pub const LEN: usize = 8 + 8 + 1; *)
      (* Ty.path "usize" *)
      Definition value_LEN (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        ltac:(M.monadic
          (M.alloc (|
            Ty.path "usize",
            M.call_closure (|
              Ty.path "usize",
              BinOp.Wrap.add,
              [
                M.call_closure (|
                  Ty.path "usize",
                  BinOp.Wrap.add,
                  [ Value.Integer IntegerKind.Usize 8; Value.Integer IntegerKind.Usize 8 ]
                |);
                Value.Integer IntegerKind.Usize 1
              ]
            |)
          |))).
      
      Global Instance AssociatedConstant_value_LEN : M.IsAssociatedFunction.C Self "LEN" value_LEN.
      Admitted.
      Global Typeclasses Opaque value_LEN.
      
      (*
          pub fn from_account_info(account_info: &AccountInfo) -> Result<Ref<Rent>, ProgramError> {
              if account_info.key() != &RENT_ID {
                  return Err(ProgramError::InvalidArgument);
              }
              Ok(Ref::map(account_info.try_borrow_data()?, |data| unsafe {
                  Self::from_bytes_unchecked(data)
              }))
          }
      *)
      Definition from_account_info (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ account_info ] =>
          ltac:(M.monadic
            (let account_info :=
              M.alloc (|
                Ty.apply (Ty.path "&") [] [ Ty.path "pinocchio::account_info::AccountInfo" ],
                account_info
              |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply
                    (Ty.path "pinocchio::account_info::Ref")
                    []
                    [ Ty.path "pinocchio::sysvars::rent::Rent" ];
                  Ty.path "pinocchio::program_error::ProgramError"
                ]) (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      Ty.tuple [],
                      M.alloc (| Ty.tuple [], Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  Ty.path "bool",
                                  M.call_closure (|
                                    Ty.path "bool",
                                    M.get_trait_method (|
                                      "core::cmp::PartialEq",
                                      Ty.apply
                                        (Ty.path "&")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "array")
                                            [ Value.Integer IntegerKind.Usize 32 ]
                                            [ Ty.path "u8" ]
                                        ],
                                      [],
                                      [
                                        Ty.apply
                                          (Ty.path "&")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "array")
                                              [ Value.Integer IntegerKind.Usize 32 ]
                                              [ Ty.path "u8" ]
                                          ]
                                      ],
                                      "ne",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.alloc (|
                                          Ty.apply
                                            (Ty.path "&")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "array")
                                                [ Value.Integer IntegerKind.Usize 32 ]
                                                [ Ty.path "u8" ]
                                            ],
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "&")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "array")
                                                  [ Value.Integer IntegerKind.Usize 32 ]
                                                  [ Ty.path "u8" ]
                                              ],
                                            M.get_associated_function (|
                                              Ty.path "pinocchio::account_info::AccountInfo",
                                              "key",
                                              [],
                                              []
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.read (| account_info |) |)
                                              |)
                                            ]
                                          |)
                                        |)
                                      |);
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.alloc (|
                                          Ty.apply
                                            (Ty.path "&")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "array")
                                                [ Value.Integer IntegerKind.Usize 32 ]
                                                [ Ty.path "u8" ]
                                            ],
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            get_constant (|
                                              "pinocchio::sysvars::rent::RENT_ID",
                                              Ty.apply
                                                (Ty.path "array")
                                                [ Value.Integer IntegerKind.Usize 32 ]
                                                [ Ty.path "u8" ]
                                            |)
                                          |)
                                        |)
                                      |)
                                    ]
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  Value.StructTuple
                                    "core::result::Result::Err"
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "pinocchio::account_info::Ref")
                                        []
                                        [ Ty.path "pinocchio::sysvars::rent::Rent" ];
                                      Ty.path "pinocchio::program_error::ProgramError"
                                    ]
                                    [
                                      Value.StructTuple
                                        "pinocchio::program_error::ProgramError::InvalidArgument"
                                        []
                                        []
                                        []
                                    ]
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (Value.Tuple []))
                      ]
                    |) in
                  M.alloc (|
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [
                        Ty.apply
                          (Ty.path "pinocchio::account_info::Ref")
                          []
                          [ Ty.path "pinocchio::sysvars::rent::Rent" ];
                        Ty.path "pinocchio::program_error::ProgramError"
                      ],
                    Value.StructTuple
                      "core::result::Result::Ok"
                      []
                      [
                        Ty.apply
                          (Ty.path "pinocchio::account_info::Ref")
                          []
                          [ Ty.path "pinocchio::sysvars::rent::Rent" ];
                        Ty.path "pinocchio::program_error::ProgramError"
                      ]
                      [
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "pinocchio::account_info::Ref")
                            []
                            [ Ty.path "pinocchio::sysvars::rent::Rent" ],
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "pinocchio::account_info::Ref")
                              []
                              [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                            "map",
                            [],
                            [
                              Ty.path "pinocchio::sysvars::rent::Rent";
                              Ty.function
                                [
                                  Ty.apply
                                    (Ty.path "&")
                                    []
                                    [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                                ]
                                (Ty.apply
                                  (Ty.path "&")
                                  []
                                  [ Ty.path "pinocchio::sysvars::rent::Rent" ])
                            ]
                          |),
                          [
                            M.match_operator (|
                              Ty.apply
                                (Ty.path "pinocchio::account_info::Ref")
                                []
                                [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                              M.alloc (|
                                Ty.apply
                                  (Ty.path "core::ops::control_flow::ControlFlow")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "core::convert::Infallible";
                                        Ty.path "pinocchio::program_error::ProgramError"
                                      ];
                                    Ty.apply
                                      (Ty.path "pinocchio::account_info::Ref")
                                      []
                                      [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                                  ],
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "core::ops::control_flow::ControlFlow")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        []
                                        [
                                          Ty.path "core::convert::Infallible";
                                          Ty.path "pinocchio::program_error::ProgramError"
                                        ];
                                      Ty.apply
                                        (Ty.path "pinocchio::account_info::Ref")
                                        []
                                        [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ]
                                    ],
                                  M.get_trait_method (|
                                    "core::ops::try_trait::Try",
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "pinocchio::account_info::Ref")
                                          []
                                          [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ];
                                        Ty.path "pinocchio::program_error::ProgramError"
                                      ],
                                    [],
                                    [],
                                    "branch",
                                    [],
                                    []
                                  |),
                                  [
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "pinocchio::account_info::Ref")
                                            []
                                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ];
                                          Ty.path "pinocchio::program_error::ProgramError"
                                        ],
                                      M.get_associated_function (|
                                        Ty.path "pinocchio::account_info::AccountInfo",
                                        "try_borrow_data",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| account_info |) |)
                                        |)
                                      ]
                                    |)
                                  ]
                                |)
                              |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ0_0 :=
                                      M.SubPointer.get_struct_tuple_field (|
                                        γ,
                                        "core::ops::control_flow::ControlFlow::Break",
                                        0
                                      |) in
                                    let residual :=
                                      M.copy (|
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          []
                                          [
                                            Ty.path "core::convert::Infallible";
                                            Ty.path "pinocchio::program_error::ProgramError"
                                          ],
                                        γ0_0
                                      |) in
                                    M.never_to_any (|
                                      M.read (|
                                        M.return_ (|
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "core::result::Result")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "pinocchio::account_info::Ref")
                                                  []
                                                  [ Ty.path "pinocchio::sysvars::rent::Rent" ];
                                                Ty.path "pinocchio::program_error::ProgramError"
                                              ],
                                            M.get_trait_method (|
                                              "core::ops::try_trait::FromResidual",
                                              Ty.apply
                                                (Ty.path "core::result::Result")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "pinocchio::account_info::Ref")
                                                    []
                                                    [ Ty.path "pinocchio::sysvars::rent::Rent" ];
                                                  Ty.path "pinocchio::program_error::ProgramError"
                                                ],
                                              [],
                                              [
                                                Ty.apply
                                                  (Ty.path "core::result::Result")
                                                  []
                                                  [
                                                    Ty.path "core::convert::Infallible";
                                                    Ty.path "pinocchio::program_error::ProgramError"
                                                  ]
                                              ],
                                              "from_residual",
                                              [],
                                              []
                                            |),
                                            [ M.read (| residual |) ]
                                          |)
                                        |)
                                      |)
                                    |)));
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ0_0 :=
                                      M.SubPointer.get_struct_tuple_field (|
                                        γ,
                                        "core::ops::control_flow::ControlFlow::Continue",
                                        0
                                      |) in
                                    let val :=
                                      M.copy (|
                                        Ty.apply
                                          (Ty.path "pinocchio::account_info::Ref")
                                          []
                                          [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                                        γ0_0
                                      |) in
                                    M.read (| val |)))
                              ]
                            |);
                            M.closure
                              (fun γ =>
                                ltac:(M.monadic
                                  match γ with
                                  | [ α0 ] =>
                                    ltac:(M.monadic
                                      (M.match_operator (|
                                        Ty.apply
                                          (Ty.path "&")
                                          []
                                          [ Ty.path "pinocchio::sysvars::rent::Rent" ],
                                        M.alloc (|
                                          Ty.apply
                                            (Ty.path "&")
                                            []
                                            [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                                          α0
                                        |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let data :=
                                                M.copy (|
                                                  Ty.apply
                                                    (Ty.path "&")
                                                    []
                                                    [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ]
                                                    ],
                                                  γ
                                                |) in
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (|
                                                  M.borrow (|
                                                    Pointer.Kind.Ref,
                                                    M.deref (|
                                                      M.call_closure (|
                                                        Ty.apply
                                                          (Ty.path "&")
                                                          []
                                                          [ Ty.path "pinocchio::sysvars::rent::Rent"
                                                          ],
                                                        M.get_associated_function (|
                                                          Ty.path "pinocchio::sysvars::rent::Rent",
                                                          "from_bytes_unchecked",
                                                          [],
                                                          []
                                                        |),
                                                        [
                                                          M.borrow (|
                                                            Pointer.Kind.Ref,
                                                            M.deref (| M.read (| data |) |)
                                                          |)
                                                        ]
                                                      |)
                                                    |)
                                                  |)
                                                |)
                                              |)))
                                        ]
                                      |)))
                                  | _ => M.impossible "wrong number of arguments"
                                  end))
                          ]
                        |)
                      ]
                  |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_from_account_info :
        M.IsAssociatedFunction.C Self "from_account_info" from_account_info.
      Admitted.
      Global Typeclasses Opaque from_account_info.
      
      (*
          pub unsafe fn from_account_info_unchecked(
              account_info: &AccountInfo,
          ) -> Result<&Self, ProgramError> {
              if account_info.key() != &RENT_ID {
                  return Err(ProgramError::InvalidArgument);
              }
              Ok(Self::from_bytes_unchecked(
                  account_info.borrow_data_unchecked(),
              ))
          }
      *)
      Definition from_account_info_unchecked
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        match ε, τ, α with
        | [], [], [ account_info ] =>
          ltac:(M.monadic
            (let account_info :=
              M.alloc (|
                Ty.apply (Ty.path "&") [] [ Ty.path "pinocchio::account_info::AccountInfo" ],
                account_info
              |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "&") [] [ Ty.path "pinocchio::sysvars::rent::Rent" ];
                  Ty.path "pinocchio::program_error::ProgramError"
                ]) (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      Ty.tuple [],
                      M.alloc (| Ty.tuple [], Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  Ty.path "bool",
                                  M.call_closure (|
                                    Ty.path "bool",
                                    M.get_trait_method (|
                                      "core::cmp::PartialEq",
                                      Ty.apply
                                        (Ty.path "&")
                                        []
                                        [
                                          Ty.apply
                                            (Ty.path "array")
                                            [ Value.Integer IntegerKind.Usize 32 ]
                                            [ Ty.path "u8" ]
                                        ],
                                      [],
                                      [
                                        Ty.apply
                                          (Ty.path "&")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "array")
                                              [ Value.Integer IntegerKind.Usize 32 ]
                                              [ Ty.path "u8" ]
                                          ]
                                      ],
                                      "ne",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.alloc (|
                                          Ty.apply
                                            (Ty.path "&")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "array")
                                                [ Value.Integer IntegerKind.Usize 32 ]
                                                [ Ty.path "u8" ]
                                            ],
                                          M.call_closure (|
                                            Ty.apply
                                              (Ty.path "&")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "array")
                                                  [ Value.Integer IntegerKind.Usize 32 ]
                                                  [ Ty.path "u8" ]
                                              ],
                                            M.get_associated_function (|
                                              Ty.path "pinocchio::account_info::AccountInfo",
                                              "key",
                                              [],
                                              []
                                            |),
                                            [
                                              M.borrow (|
                                                Pointer.Kind.Ref,
                                                M.deref (| M.read (| account_info |) |)
                                              |)
                                            ]
                                          |)
                                        |)
                                      |);
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.alloc (|
                                          Ty.apply
                                            (Ty.path "&")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "array")
                                                [ Value.Integer IntegerKind.Usize 32 ]
                                                [ Ty.path "u8" ]
                                            ],
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            get_constant (|
                                              "pinocchio::sysvars::rent::RENT_ID",
                                              Ty.apply
                                                (Ty.path "array")
                                                [ Value.Integer IntegerKind.Usize 32 ]
                                                [ Ty.path "u8" ]
                                            |)
                                          |)
                                        |)
                                      |)
                                    ]
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  Value.StructTuple
                                    "core::result::Result::Err"
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "&")
                                        []
                                        [ Ty.path "pinocchio::sysvars::rent::Rent" ];
                                      Ty.path "pinocchio::program_error::ProgramError"
                                    ]
                                    [
                                      Value.StructTuple
                                        "pinocchio::program_error::ProgramError::InvalidArgument"
                                        []
                                        []
                                        []
                                    ]
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (Value.Tuple []))
                      ]
                    |) in
                  M.alloc (|
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [
                        Ty.apply (Ty.path "&") [] [ Ty.path "pinocchio::sysvars::rent::Rent" ];
                        Ty.path "pinocchio::program_error::ProgramError"
                      ],
                    Value.StructTuple
                      "core::result::Result::Ok"
                      []
                      [
                        Ty.apply (Ty.path "&") [] [ Ty.path "pinocchio::sysvars::rent::Rent" ];
                        Ty.path "pinocchio::program_error::ProgramError"
                      ]
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (|
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "&")
                                []
                                [ Ty.path "pinocchio::sysvars::rent::Rent" ],
                              M.get_associated_function (|
                                Ty.path "pinocchio::sysvars::rent::Rent",
                                "from_bytes_unchecked",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.deref (|
                                    M.call_closure (|
                                      Ty.apply
                                        (Ty.path "&")
                                        []
                                        [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                                      M.get_associated_function (|
                                        Ty.path "pinocchio::account_info::AccountInfo",
                                        "borrow_data_unchecked",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (| M.read (| account_info |) |)
                                        |)
                                      ]
                                    |)
                                  |)
                                |)
                              ]
                            |)
                          |)
                        |)
                      ]
                  |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_from_account_info_unchecked :
        M.IsAssociatedFunction.C Self "from_account_info_unchecked" from_account_info_unchecked.
      Admitted.
      Global Typeclasses Opaque from_account_info_unchecked.
      
      (*
          pub fn from_bytes(bytes: &[u8]) -> Result<&Self, ProgramError> {
              if bytes.len() < Self::LEN {
                  return Err(ProgramError::InvalidArgument);
              }
              // SAFETY: `bytes` has been validated to be at least `Self::LEN` bytes long; the
              // caller must ensure that `bytes` contains a valid representation of `Rent`.
              Ok(unsafe { Self::from_bytes_unchecked(bytes) })
          }
      *)
      Definition from_bytes (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ bytes ] =>
          ltac:(M.monadic
            (let bytes :=
              M.alloc (|
                Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                bytes
              |) in
            M.catch_return
              (Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.apply (Ty.path "&") [] [ Ty.path "pinocchio::sysvars::rent::Rent" ];
                  Ty.path "pinocchio::program_error::ProgramError"
                ]) (|
              ltac:(M.monadic
                (M.read (|
                  let~ _ : Ty.tuple [] :=
                    M.match_operator (|
                      Ty.tuple [],
                      M.alloc (| Ty.tuple [], Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  Ty.path "bool",
                                  M.call_closure (|
                                    Ty.path "bool",
                                    BinOp.lt,
                                    [
                                      M.call_closure (|
                                        Ty.path "usize",
                                        M.get_associated_function (|
                                          Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                                          "len",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (| M.read (| bytes |) |)
                                          |)
                                        ]
                                      |);
                                      M.read (|
                                        get_associated_constant (|
                                          Ty.path "pinocchio::sysvars::rent::Rent",
                                          "LEN",
                                          Ty.path "usize"
                                        |)
                                      |)
                                    ]
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  Value.StructTuple
                                    "core::result::Result::Err"
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "&")
                                        []
                                        [ Ty.path "pinocchio::sysvars::rent::Rent" ];
                                      Ty.path "pinocchio::program_error::ProgramError"
                                    ]
                                    [
                                      Value.StructTuple
                                        "pinocchio::program_error::ProgramError::InvalidArgument"
                                        []
                                        []
                                        []
                                    ]
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (Value.Tuple []))
                      ]
                    |) in
                  M.alloc (|
                    Ty.apply
                      (Ty.path "core::result::Result")
                      []
                      [
                        Ty.apply (Ty.path "&") [] [ Ty.path "pinocchio::sysvars::rent::Rent" ];
                        Ty.path "pinocchio::program_error::ProgramError"
                      ],
                    Value.StructTuple
                      "core::result::Result::Ok"
                      []
                      [
                        Ty.apply (Ty.path "&") [] [ Ty.path "pinocchio::sysvars::rent::Rent" ];
                        Ty.path "pinocchio::program_error::ProgramError"
                      ]
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (|
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "&")
                                []
                                [ Ty.path "pinocchio::sysvars::rent::Rent" ],
                              M.get_associated_function (|
                                Ty.path "pinocchio::sysvars::rent::Rent",
                                "from_bytes_unchecked",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| bytes |) |) |) ]
                            |)
                          |)
                        |)
                      ]
                  |)
                |)))
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_from_bytes :
        M.IsAssociatedFunction.C Self "from_bytes" from_bytes.
      Admitted.
      Global Typeclasses Opaque from_bytes.
      
      (*
          pub unsafe fn from_bytes_unchecked(bytes: &[u8]) -> &Self {
              &*(bytes.as_ptr() as *const Rent)
          }
      *)
      Definition from_bytes_unchecked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ bytes ] =>
          ltac:(M.monadic
            (let bytes :=
              M.alloc (|
                Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                bytes
              |) in
            M.borrow (|
              Pointer.Kind.Ref,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.cast
                      (Ty.apply (Ty.path "*const") [] [ Ty.path "pinocchio::sysvars::rent::Rent" ])
                      (M.call_closure (|
                        Ty.apply (Ty.path "*const") [] [ Ty.path "u8" ],
                        M.get_associated_function (|
                          Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ],
                          "as_ptr",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| bytes |) |) |) ]
                      |))
                  |)
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_from_bytes_unchecked :
        M.IsAssociatedFunction.C Self "from_bytes_unchecked" from_bytes_unchecked.
      Admitted.
      Global Typeclasses Opaque from_bytes_unchecked.
      
      (*
          pub fn calculate_burn(&self, rent_collected: u64) -> (u64, u64) {
              let burned_portion = (rent_collected * u64::from(self.burn_percent)) / 100;
              (burned_portion, rent_collected - burned_portion)
          }
      *)
      Definition calculate_burn (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; rent_collected ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "&") [] [ Ty.path "pinocchio::sysvars::rent::Rent" ],
                self
              |) in
            let rent_collected := M.alloc (| Ty.path "u64", rent_collected |) in
            M.read (|
              let~ burned_portion : Ty.path "u64" :=
                M.call_closure (|
                  Ty.path "u64",
                  BinOp.Wrap.div,
                  [
                    M.call_closure (|
                      Ty.path "u64",
                      BinOp.Wrap.mul,
                      [
                        M.read (| rent_collected |);
                        M.call_closure (|
                          Ty.path "u64",
                          M.get_trait_method (|
                            "core::convert::From",
                            Ty.path "u64",
                            [],
                            [ Ty.path "u8" ],
                            "from",
                            [],
                            []
                          |),
                          [
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "pinocchio::sysvars::rent::Rent",
                                "burn_percent"
                              |)
                            |)
                          ]
                        |)
                      ]
                    |);
                    Value.Integer IntegerKind.U64 100
                  ]
                |) in
              M.alloc (|
                Ty.tuple [ Ty.path "u64"; Ty.path "u64" ],
                Value.Tuple
                  [
                    M.read (| burned_portion |);
                    M.call_closure (|
                      Ty.path "u64",
                      BinOp.Wrap.sub,
                      [ M.read (| rent_collected |); M.read (| burned_portion |) ]
                    |)
                  ]
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_calculate_burn :
        M.IsAssociatedFunction.C Self "calculate_burn" calculate_burn.
      Admitted.
      Global Typeclasses Opaque calculate_burn.
      
      (*
          pub fn due(&self, balance: u64, data_len: usize, years_elapsed: f64) -> RentDue {
              if self.is_exempt(balance, data_len) {
                  RentDue::Exempt
              } else {
                  RentDue::Paying(self.due_amount(data_len, years_elapsed))
              }
          }
      *)
      Definition due (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; balance; data_len; years_elapsed ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "&") [] [ Ty.path "pinocchio::sysvars::rent::Rent" ],
                self
              |) in
            let balance := M.alloc (| Ty.path "u64", balance |) in
            let data_len := M.alloc (| Ty.path "usize", data_len |) in
            let years_elapsed := M.alloc (| Ty.path "f64", years_elapsed |) in
            M.match_operator (|
              Ty.path "pinocchio::sysvars::rent::RentDue",
              M.alloc (| Ty.tuple [], Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          Ty.path "bool",
                          M.call_closure (|
                            Ty.path "bool",
                            M.get_associated_function (|
                              Ty.path "pinocchio::sysvars::rent::Rent",
                              "is_exempt",
                              [],
                              []
                            |),
                            [
                              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                              M.read (| balance |);
                              M.read (| data_len |)
                            ]
                          |)
                        |)) in
                    let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    Value.StructTuple "pinocchio::sysvars::rent::RentDue::Exempt" [] [] []));
                fun γ =>
                  ltac:(M.monadic
                    (Value.StructTuple
                      "pinocchio::sysvars::rent::RentDue::Paying"
                      []
                      []
                      [
                        M.call_closure (|
                          Ty.path "u64",
                          M.get_associated_function (|
                            Ty.path "pinocchio::sysvars::rent::Rent",
                            "due_amount",
                            [],
                            []
                          |),
                          [
                            M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                            M.read (| data_len |);
                            M.read (| years_elapsed |)
                          ]
                        |)
                      ]))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_due : M.IsAssociatedFunction.C Self "due" due.
      Admitted.
      Global Typeclasses Opaque due.
      
      (*
          pub fn due_amount(&self, data_len: usize, years_elapsed: f64) -> u64 {
              let actual_data_len = data_len as u64 + ACCOUNT_STORAGE_OVERHEAD;
              let lamports_per_year = self.lamports_per_byte_year * actual_data_len;
              (lamports_per_year as f64 * years_elapsed) as u64
          }
      *)
      Definition due_amount (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; data_len; years_elapsed ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "&") [] [ Ty.path "pinocchio::sysvars::rent::Rent" ],
                self
              |) in
            let data_len := M.alloc (| Ty.path "usize", data_len |) in
            let years_elapsed := M.alloc (| Ty.path "f64", years_elapsed |) in
            M.read (|
              let~ actual_data_len : Ty.path "u64" :=
                M.call_closure (|
                  Ty.path "u64",
                  BinOp.Wrap.add,
                  [
                    M.cast (Ty.path "u64") (M.read (| data_len |));
                    M.read (|
                      get_constant (|
                        "pinocchio::sysvars::rent::ACCOUNT_STORAGE_OVERHEAD",
                        Ty.path "u64"
                      |)
                    |)
                  ]
                |) in
              let~ lamports_per_year : Ty.path "u64" :=
                M.call_closure (|
                  Ty.path "u64",
                  BinOp.Wrap.mul,
                  [
                    M.read (|
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "pinocchio::sysvars::rent::Rent",
                        "lamports_per_byte_year"
                      |)
                    |);
                    M.read (| actual_data_len |)
                  ]
                |) in
              M.alloc (|
                Ty.path "u64",
                M.cast
                  (Ty.path "u64")
                  (M.call_closure (|
                    Ty.path "f64",
                    BinOp.Wrap.mul,
                    [
                      M.cast (Ty.path "f64") (M.read (| lamports_per_year |));
                      M.read (| years_elapsed |)
                    ]
                  |))
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_due_amount :
        M.IsAssociatedFunction.C Self "due_amount" due_amount.
      Admitted.
      Global Typeclasses Opaque due_amount.
      
      (*
          pub fn minimum_balance(&self, data_len: usize) -> u64 {
              let bytes = data_len as u64;
      
              if self.is_default_rent_threshold() {
                  ((ACCOUNT_STORAGE_OVERHEAD + bytes) * self.lamports_per_byte_year)
                      * DEFAULT_EXEMPTION_THRESHOLD_AS_U64
              } else {
                  (((ACCOUNT_STORAGE_OVERHEAD + bytes) * self.lamports_per_byte_year) as f64
                      * self.exemption_threshold) as u64
              }
          }
      *)
      Definition minimum_balance (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; data_len ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "&") [] [ Ty.path "pinocchio::sysvars::rent::Rent" ],
                self
              |) in
            let data_len := M.alloc (| Ty.path "usize", data_len |) in
            M.read (|
              let~ bytes : Ty.path "u64" := M.cast (Ty.path "u64") (M.read (| data_len |)) in
              M.alloc (|
                Ty.path "u64",
                M.match_operator (|
                  Ty.path "u64",
                  M.alloc (| Ty.tuple [], Value.Tuple [] |),
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let γ :=
                          M.use
                            (M.alloc (|
                              Ty.path "bool",
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_associated_function (|
                                  Ty.path "pinocchio::sysvars::rent::Rent",
                                  "is_default_rent_threshold",
                                  [],
                                  []
                                |),
                                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                              |)
                            |)) in
                        let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                        M.call_closure (|
                          Ty.path "u64",
                          BinOp.Wrap.mul,
                          [
                            M.call_closure (|
                              Ty.path "u64",
                              BinOp.Wrap.mul,
                              [
                                M.call_closure (|
                                  Ty.path "u64",
                                  BinOp.Wrap.add,
                                  [
                                    M.read (|
                                      get_constant (|
                                        "pinocchio::sysvars::rent::ACCOUNT_STORAGE_OVERHEAD",
                                        Ty.path "u64"
                                      |)
                                    |);
                                    M.read (| bytes |)
                                  ]
                                |);
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "pinocchio::sysvars::rent::Rent",
                                    "lamports_per_byte_year"
                                  |)
                                |)
                              ]
                            |);
                            M.read (|
                              get_constant (|
                                "pinocchio::sysvars::rent::DEFAULT_EXEMPTION_THRESHOLD_AS_U64",
                                Ty.path "u64"
                              |)
                            |)
                          ]
                        |)));
                    fun γ =>
                      ltac:(M.monadic
                        (M.cast
                          (Ty.path "u64")
                          (M.call_closure (|
                            Ty.path "f64",
                            BinOp.Wrap.mul,
                            [
                              M.cast
                                (Ty.path "f64")
                                (M.call_closure (|
                                  Ty.path "u64",
                                  BinOp.Wrap.mul,
                                  [
                                    M.call_closure (|
                                      Ty.path "u64",
                                      BinOp.Wrap.add,
                                      [
                                        M.read (|
                                          get_constant (|
                                            "pinocchio::sysvars::rent::ACCOUNT_STORAGE_OVERHEAD",
                                            Ty.path "u64"
                                          |)
                                        |);
                                        M.read (| bytes |)
                                      ]
                                    |);
                                    M.read (|
                                      M.SubPointer.get_struct_record_field (|
                                        M.deref (| M.read (| self |) |),
                                        "pinocchio::sysvars::rent::Rent",
                                        "lamports_per_byte_year"
                                      |)
                                    |)
                                  ]
                                |));
                              M.read (|
                                M.SubPointer.get_struct_record_field (|
                                  M.deref (| M.read (| self |) |),
                                  "pinocchio::sysvars::rent::Rent",
                                  "exemption_threshold"
                                |)
                              |)
                            ]
                          |))))
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_minimum_balance :
        M.IsAssociatedFunction.C Self "minimum_balance" minimum_balance.
      Admitted.
      Global Typeclasses Opaque minimum_balance.
      
      (*
          pub fn is_exempt(&self, lamports: u64, data_len: usize) -> bool {
              lamports >= self.minimum_balance(data_len)
          }
      *)
      Definition is_exempt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; lamports; data_len ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "&") [] [ Ty.path "pinocchio::sysvars::rent::Rent" ],
                self
              |) in
            let lamports := M.alloc (| Ty.path "u64", lamports |) in
            let data_len := M.alloc (| Ty.path "usize", data_len |) in
            M.call_closure (|
              Ty.path "bool",
              BinOp.ge,
              [
                M.read (| lamports |);
                M.call_closure (|
                  Ty.path "u64",
                  M.get_associated_function (|
                    Ty.path "pinocchio::sysvars::rent::Rent",
                    "minimum_balance",
                    [],
                    []
                  |),
                  [
                    M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                    M.read (| data_len |)
                  ]
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_is_exempt :
        M.IsAssociatedFunction.C Self "is_exempt" is_exempt.
      Admitted.
      Global Typeclasses Opaque is_exempt.
      
      (*
          fn is_default_rent_threshold(&self) -> bool {
              u64::from_le_bytes(self.exemption_threshold.to_le_bytes()) == F64_EXEMPTION_THRESHOLD_AS_U64
          }
      *)
      Definition is_default_rent_threshold
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "&") [] [ Ty.path "pinocchio::sysvars::rent::Rent" ],
                self
              |) in
            M.call_closure (|
              Ty.path "bool",
              BinOp.eq,
              [
                M.call_closure (|
                  Ty.path "u64",
                  M.get_associated_function (| Ty.path "u64", "from_le_bytes", [], [] |),
                  [
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "array")
                        [ Value.Integer IntegerKind.Usize 8 ]
                        [ Ty.path "u8" ],
                      M.get_associated_function (| Ty.path "f64", "to_le_bytes", [], [] |),
                      [
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "pinocchio::sysvars::rent::Rent",
                            "exemption_threshold"
                          |)
                        |)
                      ]
                    |)
                  ]
                |);
                M.read (|
                  get_constant (|
                    "pinocchio::sysvars::rent::F64_EXEMPTION_THRESHOLD_AS_U64",
                    Ty.path "u64"
                  |)
                |)
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_is_default_rent_threshold :
        M.IsAssociatedFunction.C Self "is_default_rent_threshold" is_default_rent_threshold.
      Admitted.
      Global Typeclasses Opaque is_default_rent_threshold.
    End Impl_pinocchio_sysvars_rent_Rent.
    
    Module Impl_pinocchio_sysvars_Sysvar_for_pinocchio_sysvars_rent_Rent.
      Definition Self : Ty.t := Ty.path "pinocchio::sysvars::rent::Rent".
      
      (*
              fn get() -> Result<Self, $crate::program_error::ProgramError> {
                  let mut var = core::mem::MaybeUninit::<Self>::uninit();
                  let var_addr = var.as_mut_ptr() as *mut _ as *mut u8;
      
                  #[cfg(target_os = "solana")]
                  let result = unsafe { $crate::syscalls::$syscall_name(var_addr) };
      
                  #[cfg(not(target_os = "solana"))]
                  let result = core::hint::black_box(var_addr as *const _ as u64);
      
                  match result {
                      // SAFETY: The syscall initialized the memory.
                      $crate::SUCCESS => Ok(unsafe { var.assume_init() }),
                      e => Err(e.into()),
                  }
              }
      *)
      Definition get (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [] =>
          ltac:(M.monadic
            (M.read (|
              let~ var :
                  Ty.apply
                    (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                    []
                    [ Ty.path "pinocchio::sysvars::rent::Rent" ] :=
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                    []
                    [ Ty.path "pinocchio::sysvars::rent::Rent" ],
                  M.get_associated_function (|
                    Ty.apply
                      (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                      []
                      [ Ty.path "pinocchio::sysvars::rent::Rent" ],
                    "uninit",
                    [],
                    []
                  |),
                  []
                |) in
              let~ var_addr : Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ] :=
                M.cast
                  (Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ])
                  (M.cast
                    (Ty.apply (Ty.path "*mut") [] [ Ty.path "pinocchio::sysvars::rent::Rent" ])
                    (M.call_closure (|
                      Ty.apply (Ty.path "*mut") [] [ Ty.path "pinocchio::sysvars::rent::Rent" ],
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                          []
                          [ Ty.path "pinocchio::sysvars::rent::Rent" ],
                        "as_mut_ptr",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.MutRef, var |) ]
                    |))) in
              let~ result : Ty.path "u64" :=
                M.call_closure (|
                  Ty.path "u64",
                  M.get_function (| "core::hint::black_box", [], [ Ty.path "u64" ] |),
                  [
                    M.cast
                      (Ty.path "u64")
                      (M.cast
                        (Ty.apply (Ty.path "*const") [] [ Ty.path "u8" ])
                        (M.call_closure (|
                          Ty.apply (Ty.path "*const") [] [ Ty.path "u8" ],
                          M.pointer_coercion
                            M.PointerCoercion.MutToConstPointer
                            (Ty.apply (Ty.path "*mut") [] [ Ty.path "u8" ])
                            (Ty.apply (Ty.path "*const") [] [ Ty.path "u8" ]),
                          [ M.read (| var_addr |) ]
                        |)))
                  ]
                |) in
              M.alloc (|
                Ty.apply
                  (Ty.path "core::result::Result")
                  []
                  [
                    Ty.path "pinocchio::sysvars::rent::Rent";
                    Ty.path "pinocchio::program_error::ProgramError"
                  ],
                M.match_operator (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [
                      Ty.path "pinocchio::sysvars::rent::Rent";
                      Ty.path "pinocchio::program_error::ProgramError"
                    ],
                  result,
                  [
                    fun γ =>
                      ltac:(M.monadic
                        (let _ :=
                          is_constant_or_break_match (|
                            M.read (| γ |),
                            Value.Integer IntegerKind.U64 0
                          |) in
                        Value.StructTuple
                          "core::result::Result::Ok"
                          []
                          [
                            Ty.path "pinocchio::sysvars::rent::Rent";
                            Ty.path "pinocchio::program_error::ProgramError"
                          ]
                          [
                            M.call_closure (|
                              Ty.path "pinocchio::sysvars::rent::Rent",
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "core::mem::maybe_uninit::MaybeUninit")
                                  []
                                  [ Ty.path "pinocchio::sysvars::rent::Rent" ],
                                "assume_init",
                                [],
                                []
                              |),
                              [ M.read (| var |) ]
                            |)
                          ]));
                    fun γ =>
                      ltac:(M.monadic
                        (let e := M.copy (| Ty.path "u64", γ |) in
                        Value.StructTuple
                          "core::result::Result::Err"
                          []
                          [
                            Ty.path "pinocchio::sysvars::rent::Rent";
                            Ty.path "pinocchio::program_error::ProgramError"
                          ]
                          [
                            M.call_closure (|
                              Ty.path "pinocchio::program_error::ProgramError",
                              M.get_trait_method (|
                                "core::convert::Into",
                                Ty.path "u64",
                                [],
                                [ Ty.path "pinocchio::program_error::ProgramError" ],
                                "into",
                                [],
                                []
                              |),
                              [ M.read (| e |) ]
                            |)
                          ]))
                  ]
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "pinocchio::sysvars::Sysvar"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("get", InstanceField.Method get) ].
    End Impl_pinocchio_sysvars_Sysvar_for_pinocchio_sysvars_rent_Rent.
    
    (*
    Enum RentDue
    {
      const_params := [];
      ty_params := [];
      variants :=
        [
          {
            name := "Exempt";
            item := StructTuple [];
          };
          {
            name := "Paying";
            item := StructTuple [ Ty.path "u64" ];
          }
        ];
    }
    *)
    
    Axiom IsDiscriminant_RentDue_Exempt :
      M.IsDiscriminant "pinocchio::sysvars::rent::RentDue::Exempt" 0.
    Axiom IsDiscriminant_RentDue_Paying :
      M.IsDiscriminant "pinocchio::sysvars::rent::RentDue::Paying" 1.
    
    Module Impl_core_fmt_Debug_for_pinocchio_sysvars_rent_RentDue.
      Definition Self : Ty.t := Ty.path "pinocchio::sysvars::rent::RentDue".
      
      (* Debug *)
      Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; f ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "&") [] [ Ty.path "pinocchio::sysvars::rent::RentDue" ],
                self
              |) in
            let f :=
              M.alloc (| Ty.apply (Ty.path "&mut") [] [ Ty.path "core::fmt::Formatter" ], f |) in
            M.match_operator (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [ Ty.tuple []; Ty.path "core::fmt::Error" ],
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (| γ, "pinocchio::sysvars::rent::RentDue::Exempt" |) in
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                      M.get_associated_function (|
                        Ty.path "core::fmt::Formatter",
                        "write_str",
                        [],
                        []
                      |),
                      [
                        M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                        M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "Exempt" |) |) |)
                      ]
                    |)));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "pinocchio::sysvars::rent::RentDue::Paying",
                        0
                      |) in
                    let __self_0 :=
                      M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "u64" ], γ1_0 |) in
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::result::Result")
                        []
                        [ Ty.tuple []; Ty.path "core::fmt::Error" ],
                      M.get_associated_function (|
                        Ty.path "core::fmt::Formatter",
                        "debug_tuple_field1_finish",
                        [],
                        []
                      |),
                      [
                        M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
                        M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "Paying" |) |) |);
                        M.call_closure (|
                          Ty.apply (Ty.path "&") [] [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ],
                          M.pointer_coercion
                            M.PointerCoercion.Unsize
                            (Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.apply (Ty.path "&") [] [ Ty.path "u64" ] ])
                            (Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.dyn [ ("core::fmt::Debug::Trait", []) ] ]),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (| M.borrow (| Pointer.Kind.Ref, __self_0 |) |)
                            |)
                          ]
                        |)
                      ]
                    |)))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::fmt::Debug"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
    End Impl_core_fmt_Debug_for_pinocchio_sysvars_rent_RentDue.
    
    Module Impl_core_marker_Copy_for_pinocchio_sysvars_rent_RentDue.
      Definition Self : Ty.t := Ty.path "pinocchio::sysvars::rent::RentDue".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::Copy"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [].
    End Impl_core_marker_Copy_for_pinocchio_sysvars_rent_RentDue.
    
    Module Impl_core_clone_Clone_for_pinocchio_sysvars_rent_RentDue.
      Definition Self : Ty.t := Ty.path "pinocchio::sysvars::rent::RentDue".
      
      (* Clone *)
      Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "&") [] [ Ty.path "pinocchio::sysvars::rent::RentDue" ],
                self
              |) in
            M.match_operator (|
              Ty.path "pinocchio::sysvars::rent::RentDue",
              Value.DeclaredButUndefined,
              [ fun γ => ltac:(M.monadic (M.read (| M.deref (| M.read (| self |) |) |))) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::clone::Clone"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [ ("clone", InstanceField.Method clone) ].
    End Impl_core_clone_Clone_for_pinocchio_sysvars_rent_RentDue.
    
    Module Impl_core_cmp_Eq_for_pinocchio_sysvars_rent_RentDue.
      Definition Self : Ty.t := Ty.path "pinocchio::sysvars::rent::RentDue".
      
      (* Eq *)
      Definition assert_receiver_is_total_eq
          (ε : list Value.t)
          (τ : list Ty.t)
          (α : list Value.t)
          : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "&") [] [ Ty.path "pinocchio::sysvars::rent::RentDue" ],
                self
              |) in
            M.match_operator (|
              Ty.tuple [],
              Value.DeclaredButUndefined,
              [ fun γ => ltac:(M.monadic (Value.Tuple [])) ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::Eq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *)
          [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
    End Impl_core_cmp_Eq_for_pinocchio_sysvars_rent_RentDue.
    
    Module Impl_core_marker_StructuralPartialEq_for_pinocchio_sysvars_rent_RentDue.
      Definition Self : Ty.t := Ty.path "pinocchio::sysvars::rent::RentDue".
      
      Axiom Implements :
        M.IsTraitInstance
          "core::marker::StructuralPartialEq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) []
          Self
          (* Instance *) [].
    End Impl_core_marker_StructuralPartialEq_for_pinocchio_sysvars_rent_RentDue.
    
    Module Impl_core_cmp_PartialEq_pinocchio_sysvars_rent_RentDue_for_pinocchio_sysvars_rent_RentDue.
      Definition Self : Ty.t := Ty.path "pinocchio::sysvars::rent::RentDue".
      
      (* PartialEq *)
      Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self; other ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "&") [] [ Ty.path "pinocchio::sysvars::rent::RentDue" ],
                self
              |) in
            let other :=
              M.alloc (|
                Ty.apply (Ty.path "&") [] [ Ty.path "pinocchio::sysvars::rent::RentDue" ],
                other
              |) in
            M.read (|
              let~ __self_discr : Ty.path "isize" :=
                M.call_closure (|
                  Ty.path "isize",
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [],
                    [ Ty.path "pinocchio::sysvars::rent::RentDue" ]
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                |) in
              let~ __arg1_discr : Ty.path "isize" :=
                M.call_closure (|
                  Ty.path "isize",
                  M.get_function (|
                    "core::intrinsics::discriminant_value",
                    [],
                    [ Ty.path "pinocchio::sysvars::rent::RentDue" ]
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |) ]
                |) in
              M.alloc (|
                Ty.path "bool",
                LogicalOp.and (|
                  M.call_closure (|
                    Ty.path "bool",
                    BinOp.eq,
                    [ M.read (| __self_discr |); M.read (| __arg1_discr |) ]
                  |),
                  ltac:(M.monadic
                    (M.match_operator (|
                      Ty.path "bool",
                      M.alloc (|
                        Ty.tuple
                          [
                            Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.path "pinocchio::sysvars::rent::RentDue" ];
                            Ty.apply
                              (Ty.path "&")
                              []
                              [ Ty.path "pinocchio::sysvars::rent::RentDue" ]
                          ],
                        Value.Tuple [ M.read (| self |); M.read (| other |) ]
                      |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                            let γ0_0 := M.read (| γ0_0 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_0,
                                "pinocchio::sysvars::rent::RentDue::Paying",
                                0
                              |) in
                            let __self_0 :=
                              M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "u64" ], γ2_0 |) in
                            let γ0_1 := M.read (| γ0_1 |) in
                            let γ2_0 :=
                              M.SubPointer.get_struct_tuple_field (|
                                γ0_1,
                                "pinocchio::sysvars::rent::RentDue::Paying",
                                0
                              |) in
                            let __arg1_0 :=
                              M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "u64" ], γ2_0 |) in
                            M.call_closure (|
                              Ty.path "bool",
                              M.get_trait_method (|
                                "core::cmp::PartialEq",
                                Ty.apply (Ty.path "&") [] [ Ty.path "u64" ],
                                [],
                                [ Ty.apply (Ty.path "&") [] [ Ty.path "u64" ] ],
                                "eq",
                                [],
                                []
                              |),
                              [
                                M.borrow (| Pointer.Kind.Ref, __self_0 |);
                                M.borrow (| Pointer.Kind.Ref, __arg1_0 |)
                              ]
                            |)));
                        fun γ => ltac:(M.monadic (Value.Bool true))
                      ]
                    |)))
                |)
              |)
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Axiom Implements :
        M.IsTraitInstance
          "core::cmp::PartialEq"
          (* Trait polymorphic consts *) []
          (* Trait polymorphic types *) [ Ty.path "pinocchio::sysvars::rent::RentDue" ]
          Self
          (* Instance *) [ ("eq", InstanceField.Method eq) ].
    End Impl_core_cmp_PartialEq_pinocchio_sysvars_rent_RentDue_for_pinocchio_sysvars_rent_RentDue.
    
    Module Impl_pinocchio_sysvars_rent_RentDue.
      Definition Self : Ty.t := Ty.path "pinocchio::sysvars::rent::RentDue".
      
      (*
          pub fn lamports(&self) -> u64 {
              match self {
                  RentDue::Exempt => 0,
                  RentDue::Paying(x) => *x,
              }
          }
      *)
      Definition lamports (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "&") [] [ Ty.path "pinocchio::sysvars::rent::RentDue" ],
                self
              |) in
            M.match_operator (|
              Ty.path "u64",
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (| γ, "pinocchio::sysvars::rent::RentDue::Exempt" |) in
                    Value.Integer IntegerKind.U64 0));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "pinocchio::sysvars::rent::RentDue::Paying",
                        0
                      |) in
                    let x := M.alloc (| Ty.apply (Ty.path "&") [] [ Ty.path "u64" ], γ1_0 |) in
                    M.read (| M.deref (| M.read (| x |) |) |)))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_lamports :
        M.IsAssociatedFunction.C Self "lamports" lamports.
      Admitted.
      Global Typeclasses Opaque lamports.
      
      (*
          pub fn is_exempt(&self) -> bool {
              match self {
                  RentDue::Exempt => true,
                  RentDue::Paying(_) => false,
              }
          }
      *)
      Definition is_exempt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
        match ε, τ, α with
        | [], [], [ self ] =>
          ltac:(M.monadic
            (let self :=
              M.alloc (|
                Ty.apply (Ty.path "&") [] [ Ty.path "pinocchio::sysvars::rent::RentDue" ],
                self
              |) in
            M.match_operator (|
              Ty.path "bool",
              self,
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let _ :=
                      M.is_struct_tuple (| γ, "pinocchio::sysvars::rent::RentDue::Exempt" |) in
                    Value.Bool true));
                fun γ =>
                  ltac:(M.monadic
                    (let γ := M.read (| γ |) in
                    let γ1_0 :=
                      M.SubPointer.get_struct_tuple_field (|
                        γ,
                        "pinocchio::sysvars::rent::RentDue::Paying",
                        0
                      |) in
                    Value.Bool false))
              ]
            |)))
        | _, _, _ => M.impossible "wrong number of arguments"
        end.
      
      Global Instance AssociatedFunction_is_exempt :
        M.IsAssociatedFunction.C Self "is_exempt" is_exempt.
      Admitted.
      Global Typeclasses Opaque is_exempt.
    End Impl_pinocchio_sysvars_rent_RentDue.
  End rent.
End sysvars.
