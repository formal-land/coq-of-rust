(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module air.
  (* Trait *)
  Module BaseAir.
    Definition preprocessed_trace
        (F Self : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.StructTuple
            "core::option::Option::None"
            []
            [
              Ty.apply
                (Ty.path "p3_matrix::dense::DenseMatrix")
                []
                [ F; Ty.apply (Ty.path "alloc::vec::Vec") [] [ F; Ty.path "alloc::alloc::Global" ] ]
            ]
            []))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_preprocessed_trace :
      forall (F : Ty.t),
      M.IsProvidedMethod "p3_air::air::BaseAir" "preprocessed_trace" (preprocessed_trace F).
  End BaseAir.
  
  (* Trait *)
  Module BaseAirWithPublicValues.
    Definition num_public_values
        (F Self : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.Integer IntegerKind.Usize 0))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_num_public_values :
      forall (F : Ty.t),
      M.IsProvidedMethod
        "p3_air::air::BaseAirWithPublicValues"
        "num_public_values"
        (num_public_values F).
  End BaseAirWithPublicValues.
  
  (* Trait *)
  (* Empty module 'Air' *)
  
  (* Trait *)
  Module AirBuilder.
    Definition is_transition
        (Self : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] Self "Expr",
            M.get_trait_method (|
              "p3_air::air::AirBuilder",
              Self,
              [],
              [],
              "is_transition_window",
              [],
              []
            |),
            [
              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
              Value.Integer IntegerKind.Usize 2
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_is_transition :
      M.IsProvidedMethod "p3_air::air::AirBuilder" "is_transition" is_transition.
    Definition when (Self : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ _ as I ], [ self; condition ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let condition := M.alloc (| condition |) in
          Value.StructRecord
            "p3_air::air::FilteredAirBuilder"
            []
            [ Self ]
            [
              ("inner", M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |));
              ("condition",
                M.call_closure (|
                  Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] Self "Expr",
                  M.get_trait_method (|
                    "core::convert::Into",
                    I,
                    [],
                    [ Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] Self "Expr" ],
                    "into",
                    [],
                    []
                  |),
                  [ M.read (| condition |) ]
                |))
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_when : M.IsProvidedMethod "p3_air::air::AirBuilder" "when" when.
    Definition when_ne (Self : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ I1; I2 ], [ self; x; y ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let x := M.alloc (| x |) in
          let y := M.alloc (| y |) in
          M.call_closure (|
            Ty.apply (Ty.path "p3_air::air::FilteredAirBuilder") [] [ Self ],
            M.get_trait_method (|
              "p3_air::air::AirBuilder",
              Self,
              [],
              [],
              "when",
              [],
              [ Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] Self "Expr" ]
            |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
              M.call_closure (|
                Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] Self "Expr",
                M.get_trait_method (|
                  "core::ops::arith::Sub",
                  Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] Self "Expr",
                  [],
                  [ Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] Self "Expr" ],
                  "sub",
                  [],
                  []
                |),
                [
                  M.call_closure (|
                    Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] Self "Expr",
                    M.get_trait_method (|
                      "core::convert::Into",
                      I1,
                      [],
                      [ Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] Self "Expr" ],
                      "into",
                      [],
                      []
                    |),
                    [ M.read (| x |) ]
                  |);
                  M.call_closure (|
                    Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] Self "Expr",
                    M.get_trait_method (|
                      "core::convert::Into",
                      I2,
                      [],
                      [ Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] Self "Expr" ],
                      "into",
                      [],
                      []
                    |),
                    [ M.read (| y |) ]
                  |)
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_when_ne : M.IsProvidedMethod "p3_air::air::AirBuilder" "when_ne" when_ne.
    Definition when_first_row
        (Self : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            Ty.apply (Ty.path "p3_air::air::FilteredAirBuilder") [] [ Self ],
            M.get_trait_method (|
              "p3_air::air::AirBuilder",
              Self,
              [],
              [],
              "when",
              [],
              [ Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] Self "Expr" ]
            |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
              M.call_closure (|
                Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] Self "Expr",
                M.get_trait_method (|
                  "p3_air::air::AirBuilder",
                  Self,
                  [],
                  [],
                  "is_first_row",
                  [],
                  []
                |),
                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_when_first_row :
      M.IsProvidedMethod "p3_air::air::AirBuilder" "when_first_row" when_first_row.
    Definition when_last_row
        (Self : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            Ty.apply (Ty.path "p3_air::air::FilteredAirBuilder") [] [ Self ],
            M.get_trait_method (|
              "p3_air::air::AirBuilder",
              Self,
              [],
              [],
              "when",
              [],
              [ Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] Self "Expr" ]
            |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
              M.call_closure (|
                Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] Self "Expr",
                M.get_trait_method (|
                  "p3_air::air::AirBuilder",
                  Self,
                  [],
                  [],
                  "is_last_row",
                  [],
                  []
                |),
                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_when_last_row :
      M.IsProvidedMethod "p3_air::air::AirBuilder" "when_last_row" when_last_row.
    Definition when_transition
        (Self : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            Ty.apply (Ty.path "p3_air::air::FilteredAirBuilder") [] [ Self ],
            M.get_trait_method (|
              "p3_air::air::AirBuilder",
              Self,
              [],
              [],
              "when",
              [],
              [ Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] Self "Expr" ]
            |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
              M.call_closure (|
                Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] Self "Expr",
                M.get_trait_method (|
                  "p3_air::air::AirBuilder",
                  Self,
                  [],
                  [],
                  "is_transition",
                  [],
                  []
                |),
                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_when_transition :
      M.IsProvidedMethod "p3_air::air::AirBuilder" "when_transition" when_transition.
    Definition when_transition_window
        (Self : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [], [ self; size ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let size := M.alloc (| size |) in
          M.call_closure (|
            Ty.apply (Ty.path "p3_air::air::FilteredAirBuilder") [] [ Self ],
            M.get_trait_method (|
              "p3_air::air::AirBuilder",
              Self,
              [],
              [],
              "when",
              [],
              [ Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] Self "Expr" ]
            |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
              M.call_closure (|
                Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] Self "Expr",
                M.get_trait_method (|
                  "p3_air::air::AirBuilder",
                  Self,
                  [],
                  [],
                  "is_transition_window",
                  [],
                  []
                |),
                [
                  M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                  M.read (| size |)
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_when_transition_window :
      M.IsProvidedMethod "p3_air::air::AirBuilder" "when_transition_window" when_transition_window.
    Definition assert_zeros
        (Self : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [ N ], [ _ as I ], [ self; array ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let array := M.alloc (| array |) in
          M.read (|
            M.use
              (M.match_operator (|
                Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                M.alloc (|
                  M.call_closure (|
                    Ty.apply (Ty.path "core::array::iter::IntoIter") [ N ] [ I ],
                    M.get_trait_method (|
                      "core::iter::traits::collect::IntoIterator",
                      Ty.apply (Ty.path "array") [ N ] [ I ],
                      [],
                      [],
                      "into_iter",
                      [],
                      []
                    |),
                    [ M.read (| array |) ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let iter := M.copy (| γ |) in
                      M.loop (|
                        Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                        ltac:(M.monadic
                          (let~ _ : Ty.tuple [] :=
                            M.read (|
                              M.match_operator (|
                                Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                                M.alloc (|
                                  M.call_closure (|
                                    Ty.apply (Ty.path "core::option::Option") [] [ I ],
                                    M.get_trait_method (|
                                      "core::iter::traits::iterator::Iterator",
                                      Ty.apply (Ty.path "core::array::iter::IntoIter") [ N ] [ I ],
                                      [],
                                      [],
                                      "next",
                                      [],
                                      []
                                    |),
                                    [
                                      M.borrow (|
                                        Pointer.Kind.MutRef,
                                        M.deref (| M.borrow (| Pointer.Kind.MutRef, iter |) |)
                                      |)
                                    ]
                                  |)
                                |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let _ :=
                                        M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                                      M.alloc (|
                                        M.never_to_any (| M.read (| M.break (||) |) |)
                                      |)));
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ0_0 :=
                                        M.SubPointer.get_struct_tuple_field (|
                                          γ,
                                          "core::option::Option::Some",
                                          0
                                        |) in
                                      let elem := M.copy (| γ0_0 |) in
                                      let~ _ : Ty.tuple [] :=
                                        M.call_closure (|
                                          Ty.tuple [],
                                          M.get_trait_method (|
                                            "p3_air::air::AirBuilder",
                                            Self,
                                            [],
                                            [],
                                            "assert_zero",
                                            [],
                                            [ I ]
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.MutRef,
                                              M.deref (| M.read (| self |) |)
                                            |);
                                            M.read (| elem |)
                                          ]
                                        |) in
                                      M.alloc (| Value.Tuple [] |)))
                                ]
                              |)
                            |) in
                          M.alloc (| Value.Tuple [] |)))
                      |)))
                ]
              |))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_assert_zeros :
      M.IsProvidedMethod "p3_air::air::AirBuilder" "assert_zeros" assert_zeros.
    Definition assert_bools
        (Self : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [ N ], [ _ as I ], [ self; array ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let array := M.alloc (| array |) in
          M.read (|
            let~ zero_array :
                Ty.apply
                  (Ty.path "array")
                  [ N ]
                  [ Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] Self "Expr" ] :=
              M.call_closure (|
                Ty.apply
                  (Ty.path "array")
                  [ N ]
                  [ Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] Self "Expr" ],
                M.get_associated_function (|
                  Ty.apply (Ty.path "array") [ N ] [ I ],
                  "map",
                  [],
                  [
                    Ty.function
                      [ Ty.tuple [ I ] ]
                      (Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] Self "Expr");
                    Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] Self "Expr"
                  ]
                |),
                [
                  M.read (| array |);
                  M.closure
                    (fun γ =>
                      ltac:(M.monadic
                        match γ with
                        | [ α0 ] =>
                          ltac:(M.monadic
                            (M.match_operator (|
                              Ty.apply
                                (Ty.path "*")
                                []
                                [
                                  Ty.function
                                    [ Ty.tuple [ I ] ]
                                    (Ty.associated_in_trait
                                      "p3_air::air::AirBuilder"
                                      []
                                      []
                                      Self
                                      "Expr")
                                ],
                              M.alloc (| α0 |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let x := M.copy (| γ |) in
                                    M.call_closure (|
                                      Ty.associated_in_trait
                                        "p3_air::air::AirBuilder"
                                        []
                                        []
                                        Self
                                        "Expr",
                                      M.get_trait_method (|
                                        "p3_field::field::PrimeCharacteristicRing",
                                        Ty.associated_in_trait
                                          "p3_air::air::AirBuilder"
                                          []
                                          []
                                          Self
                                          "Expr",
                                        [],
                                        [],
                                        "bool_check",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.alloc (|
                                            M.call_closure (|
                                              Ty.associated_in_trait
                                                "p3_air::air::AirBuilder"
                                                []
                                                []
                                                Self
                                                "Expr",
                                              M.get_trait_method (|
                                                "core::convert::Into",
                                                I,
                                                [],
                                                [
                                                  Ty.associated_in_trait
                                                    "p3_air::air::AirBuilder"
                                                    []
                                                    []
                                                    Self
                                                    "Expr"
                                                ],
                                                "into",
                                                [],
                                                []
                                              |),
                                              [ M.read (| x |) ]
                                            |)
                                          |)
                                        |)
                                      ]
                                    |)))
                              ]
                            |)))
                        | _ => M.impossible "wrong number of arguments"
                        end))
                ]
              |) in
            let~ _ : Ty.tuple [] :=
              M.call_closure (|
                Ty.tuple [],
                M.get_trait_method (|
                  "p3_air::air::AirBuilder",
                  Self,
                  [],
                  [],
                  "assert_zeros",
                  [ N ],
                  [ Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] Self "Expr" ]
                |),
                [
                  M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                  M.read (| zero_array |)
                ]
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_assert_bools :
      M.IsProvidedMethod "p3_air::air::AirBuilder" "assert_bools" assert_bools.
    Definition assert_one (Self : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ _ as I ], [ self; x ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let x := M.alloc (| x |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.call_closure (|
                Ty.tuple [],
                M.get_trait_method (|
                  "p3_air::air::AirBuilder",
                  Self,
                  [],
                  [],
                  "assert_zero",
                  [],
                  [ Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] Self "Expr" ]
                |),
                [
                  M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                  M.call_closure (|
                    Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] Self "Expr",
                    M.get_trait_method (|
                      "core::ops::arith::Sub",
                      Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] Self "Expr",
                      [],
                      [ Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] Self "Expr" ],
                      "sub",
                      [],
                      []
                    |),
                    [
                      M.call_closure (|
                        Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] Self "Expr",
                        M.get_trait_method (|
                          "core::convert::Into",
                          I,
                          [],
                          [ Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] Self "Expr" ],
                          "into",
                          [],
                          []
                        |),
                        [ M.read (| x |) ]
                      |);
                      M.read (|
                        get_constant (|
                          "p3_field::field::PrimeCharacteristicRing::ONE",
                          Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] Self "Expr"
                        |)
                      |)
                    ]
                  |)
                ]
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_assert_one :
      M.IsProvidedMethod "p3_air::air::AirBuilder" "assert_one" assert_one.
    Definition assert_eq (Self : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      match ε, τ, α with
      | [], [ I1; I2 ], [ self; x; y ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let x := M.alloc (| x |) in
          let y := M.alloc (| y |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.call_closure (|
                Ty.tuple [],
                M.get_trait_method (|
                  "p3_air::air::AirBuilder",
                  Self,
                  [],
                  [],
                  "assert_zero",
                  [],
                  [ Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] Self "Expr" ]
                |),
                [
                  M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                  M.call_closure (|
                    Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] Self "Expr",
                    M.get_trait_method (|
                      "core::ops::arith::Sub",
                      Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] Self "Expr",
                      [],
                      [ Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] Self "Expr" ],
                      "sub",
                      [],
                      []
                    |),
                    [
                      M.call_closure (|
                        Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] Self "Expr",
                        M.get_trait_method (|
                          "core::convert::Into",
                          I1,
                          [],
                          [ Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] Self "Expr" ],
                          "into",
                          [],
                          []
                        |),
                        [ M.read (| x |) ]
                      |);
                      M.call_closure (|
                        Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] Self "Expr",
                        M.get_trait_method (|
                          "core::convert::Into",
                          I2,
                          [],
                          [ Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] Self "Expr" ],
                          "into",
                          [],
                          []
                        |),
                        [ M.read (| y |) ]
                      |)
                    ]
                  |)
                ]
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_assert_eq :
      M.IsProvidedMethod "p3_air::air::AirBuilder" "assert_eq" assert_eq.
    Definition assert_bool
        (Self : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [ _ as I ], [ self; x ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let x := M.alloc (| x |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.call_closure (|
                Ty.tuple [],
                M.get_trait_method (|
                  "p3_air::air::AirBuilder",
                  Self,
                  [],
                  [],
                  "assert_zero",
                  [],
                  [ Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] Self "Expr" ]
                |),
                [
                  M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                  M.call_closure (|
                    Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] Self "Expr",
                    M.get_trait_method (|
                      "p3_field::field::PrimeCharacteristicRing",
                      Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] Self "Expr",
                      [],
                      [],
                      "bool_check",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.Ref,
                        M.alloc (|
                          M.call_closure (|
                            Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] Self "Expr",
                            M.get_trait_method (|
                              "core::convert::Into",
                              I,
                              [],
                              [ Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] Self "Expr"
                              ],
                              "into",
                              [],
                              []
                            |),
                            [ M.read (| x |) ]
                          |)
                        |)
                      |)
                    ]
                  |)
                ]
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_assert_bool :
      M.IsProvidedMethod "p3_air::air::AirBuilder" "assert_bool" assert_bool.
  End AirBuilder.
  
  (* Trait *)
  (* Empty module 'AirBuilderWithPublicValues' *)
  
  (* Trait *)
  (* Empty module 'PairBuilder' *)
  
  (* Trait *)
  Module ExtensionBuilder.
    Definition assert_eq_ext
        (Self : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [ I1; I2 ], [ self; x; y ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let x := M.alloc (| x |) in
          let y := M.alloc (| y |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.call_closure (|
                Ty.tuple [],
                M.get_trait_method (|
                  "p3_air::air::ExtensionBuilder",
                  Self,
                  [],
                  [],
                  "assert_zero_ext",
                  [],
                  [ Ty.associated_in_trait "p3_air::air::ExtensionBuilder" [] [] Self "ExprEF" ]
                |),
                [
                  M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
                  M.call_closure (|
                    Ty.associated_in_trait "p3_air::air::ExtensionBuilder" [] [] Self "ExprEF",
                    M.get_trait_method (|
                      "core::ops::arith::Sub",
                      Ty.associated_in_trait "p3_air::air::ExtensionBuilder" [] [] Self "ExprEF",
                      [],
                      [ Ty.associated_in_trait "p3_air::air::ExtensionBuilder" [] [] Self "ExprEF"
                      ],
                      "sub",
                      [],
                      []
                    |),
                    [
                      M.call_closure (|
                        Ty.associated_in_trait "p3_air::air::ExtensionBuilder" [] [] Self "ExprEF",
                        M.get_trait_method (|
                          "core::convert::Into",
                          I1,
                          [],
                          [
                            Ty.associated_in_trait
                              "p3_air::air::ExtensionBuilder"
                              []
                              []
                              Self
                              "ExprEF"
                          ],
                          "into",
                          [],
                          []
                        |),
                        [ M.read (| x |) ]
                      |);
                      M.call_closure (|
                        Ty.associated_in_trait "p3_air::air::ExtensionBuilder" [] [] Self "ExprEF",
                        M.get_trait_method (|
                          "core::convert::Into",
                          I2,
                          [],
                          [
                            Ty.associated_in_trait
                              "p3_air::air::ExtensionBuilder"
                              []
                              []
                              Self
                              "ExprEF"
                          ],
                          "into",
                          [],
                          []
                        |),
                        [ M.read (| y |) ]
                      |)
                    ]
                  |)
                ]
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_assert_eq_ext :
      M.IsProvidedMethod "p3_air::air::ExtensionBuilder" "assert_eq_ext" assert_eq_ext.
    Definition assert_one_ext
        (Self : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      match ε, τ, α with
      | [], [ _ as I ], [ self; x ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let x := M.alloc (| x |) in
          M.call_closure (|
            Ty.tuple [],
            M.get_trait_method (|
              "p3_air::air::ExtensionBuilder",
              Self,
              [],
              [],
              "assert_eq_ext",
              [],
              [ I; Ty.associated_in_trait "p3_air::air::ExtensionBuilder" [] [] Self "ExprEF" ]
            |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |);
              M.read (| x |);
              M.read (|
                get_constant (|
                  "p3_field::field::PrimeCharacteristicRing::ONE",
                  Ty.associated_in_trait "p3_air::air::ExtensionBuilder" [] [] Self "ExprEF"
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom ProvidedMethod_assert_one_ext :
      M.IsProvidedMethod "p3_air::air::ExtensionBuilder" "assert_one_ext" assert_one_ext.
  End ExtensionBuilder.
  
  (* Trait *)
  (* Empty module 'PermutationAirBuilder' *)
  
  (* StructRecord
    {
      name := "FilteredAirBuilder";
      const_params := [];
      ty_params := [ "AB" ];
      fields :=
        [
          ("inner", Ty.apply (Ty.path "&mut") [] [ AB ]);
          ("condition", Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr")
        ];
    } *)
  
  Module Impl_core_fmt_Debug_where_core_fmt_Debug_AB_where_p3_air_air_AirBuilder_AB_where_core_fmt_Debug_associated_in_trait_p3_air_air_AirBuilder___AB_Expr_for_p3_air_air_FilteredAirBuilder_AB.
    Definition Self (AB : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "p3_air::air::FilteredAirBuilder") [] [ AB ].
    
    (* Debug *)
    Definition fmt (AB : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self AB in
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_associated_function (|
              Ty.path "core::fmt::Formatter",
              "debug_struct_field2_finish",
              [],
              []
            |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "FilteredAirBuilder" |) |) |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "inner" |) |) |);
              (* Unsize *)
              M.pointer_coercion
                (M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "p3_air::air::FilteredAirBuilder",
                        "inner"
                      |)
                    |)
                  |)
                |));
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "condition" |) |) |);
              (* Unsize *)
              M.pointer_coercion
                (M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.alloc (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "p3_air::air::FilteredAirBuilder",
                            "condition"
                          |)
                        |)
                      |)
                    |)
                  |)
                |))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (AB : Ty.t),
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self AB)
        (* Instance *) [ ("fmt", InstanceField.Method (fmt AB)) ].
  End Impl_core_fmt_Debug_where_core_fmt_Debug_AB_where_p3_air_air_AirBuilder_AB_where_core_fmt_Debug_associated_in_trait_p3_air_air_AirBuilder___AB_Expr_for_p3_air_air_FilteredAirBuilder_AB.
  
  Module Impl_p3_air_air_FilteredAirBuilder_AB.
    Definition Self (AB : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "p3_air::air::FilteredAirBuilder") [] [ AB ].
    
    (*
        pub fn condition(&self) -> AB::Expr {
            self.condition.clone()
        }
    *)
    Definition condition (AB : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self AB in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr",
            M.get_trait_method (|
              "core::clone::Clone",
              Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr",
              [],
              [],
              "clone",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.SubPointer.get_struct_record_field (|
                  M.deref (| M.read (| self |) |),
                  "p3_air::air::FilteredAirBuilder",
                  "condition"
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_condition :
      forall (AB : Ty.t),
      M.IsAssociatedFunction.C (Self AB) "condition" (condition AB).
    Admitted.
    Global Typeclasses Opaque condition.
  End Impl_p3_air_air_FilteredAirBuilder_AB.
  
  Module Impl_p3_air_air_AirBuilder_where_p3_air_air_AirBuilder_AB_for_p3_air_air_FilteredAirBuilder_AB.
    Definition Self (AB : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "p3_air::air::FilteredAirBuilder") [] [ AB ].
    
    (*     type F = AB::F; *)
    Definition _F (AB : Ty.t) : Ty.t :=
      Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "F".
    
    (*     type Expr = AB::Expr; *)
    Definition _Expr (AB : Ty.t) : Ty.t :=
      Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr".
    
    (*     type Var = AB::Var; *)
    Definition _Var (AB : Ty.t) : Ty.t :=
      Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Var".
    
    (*     type M = AB::M; *)
    Definition _M_ (AB : Ty.t) : Ty.t :=
      Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "M".
    
    (*
        fn main(&self) -> Self::M {
            self.inner.main()
        }
    *)
    Definition main (AB : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self AB in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "M",
            M.get_trait_method (| "p3_air::air::AirBuilder", AB, [], [], "main", [], [] |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "p3_air::air::FilteredAirBuilder",
                      "inner"
                    |)
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn is_first_row(&self) -> Self::Expr {
            self.inner.is_first_row()
        }
    *)
    Definition is_first_row (AB : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self AB in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr",
            M.get_trait_method (| "p3_air::air::AirBuilder", AB, [], [], "is_first_row", [], [] |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "p3_air::air::FilteredAirBuilder",
                      "inner"
                    |)
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn is_last_row(&self) -> Self::Expr {
            self.inner.is_last_row()
        }
    *)
    Definition is_last_row (AB : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self AB in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr",
            M.get_trait_method (| "p3_air::air::AirBuilder", AB, [], [], "is_last_row", [], [] |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "p3_air::air::FilteredAirBuilder",
                      "inner"
                    |)
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn is_transition_window(&self, size: usize) -> Self::Expr {
            self.inner.is_transition_window(size)
        }
    *)
    Definition is_transition_window
        (AB : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self AB in
      match ε, τ, α with
      | [], [], [ self; size ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let size := M.alloc (| size |) in
          M.call_closure (|
            Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr",
            M.get_trait_method (|
              "p3_air::air::AirBuilder",
              AB,
              [],
              [],
              "is_transition_window",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "p3_air::air::FilteredAirBuilder",
                      "inner"
                    |)
                  |)
                |)
              |);
              M.read (| size |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn assert_zero<I: Into<Self::Expr>>(&mut self, x: I) {
            self.inner.assert_zero(self.condition() * x.into());
        }
    *)
    Definition assert_zero (AB : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self AB in
      match ε, τ, α with
      | [], [ _ as I ], [ self; x ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let x := M.alloc (| x |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.call_closure (|
                Ty.tuple [],
                M.get_trait_method (|
                  "p3_air::air::AirBuilder",
                  AB,
                  [],
                  [],
                  "assert_zero",
                  [],
                  [ Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr" ]
                |),
                [
                  M.borrow (|
                    Pointer.Kind.MutRef,
                    M.deref (|
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "p3_air::air::FilteredAirBuilder",
                          "inner"
                        |)
                      |)
                    |)
                  |);
                  M.call_closure (|
                    Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr",
                    M.get_trait_method (|
                      "core::ops::arith::Mul",
                      Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr",
                      [],
                      [ Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr" ],
                      "mul",
                      [],
                      []
                    |),
                    [
                      M.call_closure (|
                        Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr",
                        M.get_associated_function (|
                          Ty.apply (Ty.path "p3_air::air::FilteredAirBuilder") [] [ AB ],
                          "condition",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                      |);
                      M.call_closure (|
                        Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr",
                        M.get_trait_method (|
                          "core::convert::Into",
                          I,
                          [],
                          [ Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr" ],
                          "into",
                          [],
                          []
                        |),
                        [ M.read (| x |) ]
                      |)
                    ]
                  |)
                ]
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (AB : Ty.t),
      M.IsTraitInstance
        "p3_air::air::AirBuilder"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self AB)
        (* Instance *)
        [
          ("F", InstanceField.Ty (_F AB));
          ("Expr", InstanceField.Ty (_Expr AB));
          ("Var", InstanceField.Ty (_Var AB));
          ("M_", InstanceField.Ty (_M_ AB));
          ("main", InstanceField.Method (main AB));
          ("is_first_row", InstanceField.Method (is_first_row AB));
          ("is_last_row", InstanceField.Method (is_last_row AB));
          ("is_transition_window", InstanceField.Method (is_transition_window AB));
          ("assert_zero", InstanceField.Method (assert_zero AB))
        ].
  End Impl_p3_air_air_AirBuilder_where_p3_air_air_AirBuilder_AB_for_p3_air_air_FilteredAirBuilder_AB.
  
  Module Impl_p3_air_air_ExtensionBuilder_where_p3_air_air_ExtensionBuilder_AB_for_p3_air_air_FilteredAirBuilder_AB.
    Definition Self (AB : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "p3_air::air::FilteredAirBuilder") [] [ AB ].
    
    (*     type EF = AB::EF; *)
    Definition _EF (AB : Ty.t) : Ty.t :=
      Ty.associated_in_trait "p3_air::air::ExtensionBuilder" [] [] AB "EF".
    
    (*     type ExprEF = AB::ExprEF; *)
    Definition _ExprEF (AB : Ty.t) : Ty.t :=
      Ty.associated_in_trait "p3_air::air::ExtensionBuilder" [] [] AB "ExprEF".
    
    (*     type VarEF = AB::VarEF; *)
    Definition _VarEF (AB : Ty.t) : Ty.t :=
      Ty.associated_in_trait "p3_air::air::ExtensionBuilder" [] [] AB "VarEF".
    
    (*
        fn assert_zero_ext<I>(&mut self, x: I)
        where
            I: Into<Self::ExprEF>,
        {
            self.inner.assert_zero_ext(x.into() * self.condition());
        }
    *)
    Definition assert_zero_ext
        (AB : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self AB in
      match ε, τ, α with
      | [], [ _ as I ], [ self; x ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let x := M.alloc (| x |) in
          M.read (|
            let~ _ : Ty.tuple [] :=
              M.call_closure (|
                Ty.tuple [],
                M.get_trait_method (|
                  "p3_air::air::ExtensionBuilder",
                  AB,
                  [],
                  [],
                  "assert_zero_ext",
                  [],
                  [ Ty.associated_in_trait "p3_air::air::ExtensionBuilder" [] [] AB "ExprEF" ]
                |),
                [
                  M.borrow (|
                    Pointer.Kind.MutRef,
                    M.deref (|
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "p3_air::air::FilteredAirBuilder",
                          "inner"
                        |)
                      |)
                    |)
                  |);
                  M.call_closure (|
                    Ty.associated_in_trait "p3_air::air::ExtensionBuilder" [] [] AB "ExprEF",
                    M.get_trait_method (|
                      "core::ops::arith::Mul",
                      Ty.associated_in_trait "p3_air::air::ExtensionBuilder" [] [] AB "ExprEF",
                      [],
                      [ Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr" ],
                      "mul",
                      [],
                      []
                    |),
                    [
                      M.call_closure (|
                        Ty.associated_in_trait "p3_air::air::ExtensionBuilder" [] [] AB "ExprEF",
                        M.get_trait_method (|
                          "core::convert::Into",
                          I,
                          [],
                          [ Ty.associated_in_trait "p3_air::air::ExtensionBuilder" [] [] AB "ExprEF"
                          ],
                          "into",
                          [],
                          []
                        |),
                        [ M.read (| x |) ]
                      |);
                      M.call_closure (|
                        Ty.associated_in_trait "p3_air::air::AirBuilder" [] [] AB "Expr",
                        M.get_associated_function (|
                          Ty.apply (Ty.path "p3_air::air::FilteredAirBuilder") [] [ AB ],
                          "condition",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                      |)
                    ]
                  |)
                ]
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (AB : Ty.t),
      M.IsTraitInstance
        "p3_air::air::ExtensionBuilder"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self AB)
        (* Instance *)
        [
          ("EF", InstanceField.Ty (_EF AB));
          ("ExprEF", InstanceField.Ty (_ExprEF AB));
          ("VarEF", InstanceField.Ty (_VarEF AB));
          ("assert_zero_ext", InstanceField.Method (assert_zero_ext AB))
        ].
  End Impl_p3_air_air_ExtensionBuilder_where_p3_air_air_ExtensionBuilder_AB_for_p3_air_air_FilteredAirBuilder_AB.
  
  Module Impl_p3_air_air_PermutationAirBuilder_where_p3_air_air_PermutationAirBuilder_AB_for_p3_air_air_FilteredAirBuilder_AB.
    Definition Self (AB : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "p3_air::air::FilteredAirBuilder") [] [ AB ].
    
    (*     type MP = AB::MP; *)
    Definition _MP (AB : Ty.t) : Ty.t :=
      Ty.associated_in_trait "p3_air::air::PermutationAirBuilder" [] [] AB "MP".
    
    (*     type RandomVar = AB::RandomVar; *)
    Definition _RandomVar (AB : Ty.t) : Ty.t :=
      Ty.associated_in_trait "p3_air::air::PermutationAirBuilder" [] [] AB "RandomVar".
    
    (*
        fn permutation(&self) -> Self::MP {
            self.inner.permutation()
        }
    *)
    Definition permutation (AB : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self AB in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            Ty.associated_in_trait "p3_air::air::PermutationAirBuilder" [] [] AB "MP",
            M.get_trait_method (|
              "p3_air::air::PermutationAirBuilder",
              AB,
              [],
              [],
              "permutation",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "p3_air::air::FilteredAirBuilder",
                      "inner"
                    |)
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn permutation_randomness(&self) -> &[Self::RandomVar] {
            self.inner.permutation_randomness()
        }
    *)
    Definition permutation_randomness
        (AB : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self AB in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.borrow (|
            Pointer.Kind.Ref,
            M.deref (|
              M.call_closure (|
                Ty.apply
                  (Ty.path "&")
                  []
                  [
                    Ty.apply
                      (Ty.path "slice")
                      []
                      [
                        Ty.associated_in_trait
                          "p3_air::air::PermutationAirBuilder"
                          []
                          []
                          AB
                          "RandomVar"
                      ]
                  ],
                M.get_trait_method (|
                  "p3_air::air::PermutationAirBuilder",
                  AB,
                  [],
                  [],
                  "permutation_randomness",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (|
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "p3_air::air::FilteredAirBuilder",
                          "inner"
                        |)
                      |)
                    |)
                  |)
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (AB : Ty.t),
      M.IsTraitInstance
        "p3_air::air::PermutationAirBuilder"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self AB)
        (* Instance *)
        [
          ("MP", InstanceField.Ty (_MP AB));
          ("RandomVar", InstanceField.Ty (_RandomVar AB));
          ("permutation", InstanceField.Method (permutation AB));
          ("permutation_randomness", InstanceField.Method (permutation_randomness AB))
        ].
  End Impl_p3_air_air_PermutationAirBuilder_where_p3_air_air_PermutationAirBuilder_AB_for_p3_air_air_FilteredAirBuilder_AB.
End air.
