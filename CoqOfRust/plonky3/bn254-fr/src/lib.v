(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

(* StructRecord
  {
    name := "Bn254Fr";
    const_params := [];
    ty_params := [];
    fields := [ ("value", Ty.path "halo2curves::bn256::fr::Fr") ];
  } *)

Module Impl_core_marker_Copy_for_p3_bn254_fr_Bn254Fr.
  Definition Self : Ty.t := Ty.path "p3_bn254_fr::Bn254Fr".
  
  Axiom Implements :
    M.IsTraitInstance
      "core::marker::Copy"
      (* Trait polymorphic consts *) []
      (* Trait polymorphic types *) []
      Self
      (* Instance *) [].
End Impl_core_marker_Copy_for_p3_bn254_fr_Bn254Fr.

Module Impl_core_clone_Clone_for_p3_bn254_fr_Bn254Fr.
  Definition Self : Ty.t := Ty.path "p3_bn254_fr::Bn254Fr".
  
  (* Clone *)
  Definition clone (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ self ] =>
      ltac:(M.monadic
        (let self := M.alloc (| self |) in
        M.read (|
          M.match_operator (|
            Ty.apply (Ty.path "*") [] [ Ty.path "p3_bn254_fr::Bn254Fr" ],
            Value.DeclaredButUndefined,
            [ fun γ => ltac:(M.monadic (M.deref (| M.read (| self |) |))) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::clone::Clone"
      (* Trait polymorphic consts *) []
      (* Trait polymorphic types *) []
      Self
      (* Instance *) [ ("clone", InstanceField.Method clone) ].
End Impl_core_clone_Clone_for_p3_bn254_fr_Bn254Fr.

Module Impl_core_default_Default_for_p3_bn254_fr_Bn254Fr.
  Definition Self : Ty.t := Ty.path "p3_bn254_fr::Bn254Fr".
  
  (* Default *)
  Definition default (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [] =>
      ltac:(M.monadic
        (Value.StructRecord
          "p3_bn254_fr::Bn254Fr"
          [
            ("value",
              M.call_closure (|
                Ty.path "halo2curves::bn256::fr::Fr",
                M.get_trait_method (|
                  "core::default::Default",
                  Ty.path "halo2curves::bn256::fr::Fr",
                  [],
                  [],
                  "default",
                  [],
                  []
                |),
                []
              |))
          ]))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::default::Default"
      (* Trait polymorphic consts *) []
      (* Trait polymorphic types *) []
      Self
      (* Instance *) [ ("default", InstanceField.Method default) ].
End Impl_core_default_Default_for_p3_bn254_fr_Bn254Fr.

Module Impl_core_cmp_Eq_for_p3_bn254_fr_Bn254Fr.
  Definition Self : Ty.t := Ty.path "p3_bn254_fr::Bn254Fr".
  
  (* Eq *)
  Definition assert_receiver_is_total_eq
      (ε : list Value.t)
      (τ : list Ty.t)
      (α : list Value.t)
      : M :=
    match ε, τ, α with
    | [], [], [ self ] =>
      ltac:(M.monadic
        (let self := M.alloc (| self |) in
        M.read (|
          M.match_operator (|
            Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
            Value.DeclaredButUndefined,
            [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::cmp::Eq"
      (* Trait polymorphic consts *) []
      (* Trait polymorphic types *) []
      Self
      (* Instance *)
      [ ("assert_receiver_is_total_eq", InstanceField.Method assert_receiver_is_total_eq) ].
End Impl_core_cmp_Eq_for_p3_bn254_fr_Bn254Fr.

Module Impl_core_marker_StructuralPartialEq_for_p3_bn254_fr_Bn254Fr.
  Definition Self : Ty.t := Ty.path "p3_bn254_fr::Bn254Fr".
  
  Axiom Implements :
    M.IsTraitInstance
      "core::marker::StructuralPartialEq"
      (* Trait polymorphic consts *) []
      (* Trait polymorphic types *) []
      Self
      (* Instance *) [].
End Impl_core_marker_StructuralPartialEq_for_p3_bn254_fr_Bn254Fr.

Module Impl_core_cmp_PartialEq_p3_bn254_fr_Bn254Fr_for_p3_bn254_fr_Bn254Fr.
  Definition Self : Ty.t := Ty.path "p3_bn254_fr::Bn254Fr".
  
  (* PartialEq *)
  Definition eq (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ self; other ] =>
      ltac:(M.monadic
        (let self := M.alloc (| self |) in
        let other := M.alloc (| other |) in
        M.call_closure (|
          Ty.path "bool",
          M.get_trait_method (|
            "core::cmp::PartialEq",
            Ty.path "halo2curves::bn256::fr::Fr",
            [],
            [ Ty.path "halo2curves::bn256::fr::Fr" ],
            "eq",
            [],
            []
          |),
          [
            M.borrow (|
              Pointer.Kind.Ref,
              M.SubPointer.get_struct_record_field (|
                M.deref (| M.read (| self |) |),
                "p3_bn254_fr::Bn254Fr",
                "value"
              |)
            |);
            M.borrow (|
              Pointer.Kind.Ref,
              M.SubPointer.get_struct_record_field (|
                M.deref (| M.read (| other |) |),
                "p3_bn254_fr::Bn254Fr",
                "value"
              |)
            |)
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::cmp::PartialEq"
      (* Trait polymorphic consts *) []
      (* Trait polymorphic types *) [ Ty.path "p3_bn254_fr::Bn254Fr" ]
      Self
      (* Instance *) [ ("eq", InstanceField.Method eq) ].
End Impl_core_cmp_PartialEq_p3_bn254_fr_Bn254Fr_for_p3_bn254_fr_Bn254Fr.

Module Impl_p3_bn254_fr_Bn254Fr.
  Definition Self : Ty.t := Ty.path "p3_bn254_fr::Bn254Fr".
  
  (*
      pub(crate) const fn new(value: FFBn254Fr) -> Self {
          Self { value }
      }
  *)
  Definition new (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ value ] =>
      ltac:(M.monadic
        (let value := M.alloc (| value |) in
        Value.StructRecord "p3_bn254_fr::Bn254Fr" [ ("value", M.read (| value |)) ]))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance AssociatedFunction_new : M.IsAssociatedFunction.C Self "new" new.
  Admitted.
  Global Typeclasses Opaque new.
End Impl_p3_bn254_fr_Bn254Fr.

Module Impl_serde_ser_Serialize_for_p3_bn254_fr_Bn254Fr.
  Definition Self : Ty.t := Ty.path "p3_bn254_fr::Bn254Fr".
  
  (*
      fn serialize<S: serde::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
          let bytes = self.value.to_raw_bytes();
          serializer.serialize_bytes(&bytes)
      }
  *)
  Definition serialize (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ _ as S ], [ self; serializer ] =>
      ltac:(M.monadic
        (let self := M.alloc (| self |) in
        let serializer := M.alloc (| serializer |) in
        M.read (|
          let~ bytes :
              Ty.apply
                (Ty.path "*")
                []
                [
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                ] :=
            M.alloc (|
              M.call_closure (|
                Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  []
                  [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                M.get_trait_method (|
                  "halo2curves::serde::SerdeObject",
                  Ty.path "halo2curves::bn256::fr::Fr",
                  [],
                  [],
                  "to_raw_bytes",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "p3_bn254_fr::Bn254Fr",
                      "value"
                    |)
                  |)
                ]
              |)
            |) in
          M.alloc (|
            M.call_closure (|
              Ty.apply
                (Ty.path "core::result::Result")
                []
                [
                  Ty.associated_in_trait "serde::ser::Serializer" [] [] S "Ok";
                  Ty.associated_in_trait "serde::ser::Serializer" [] [] S "Error"
                ],
              M.get_trait_method (|
                "serde::ser::Serializer",
                S,
                [],
                [],
                "serialize_bytes",
                [],
                []
              |),
              [
                M.read (| serializer |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                      M.get_trait_method (|
                        "core::ops::deref::Deref",
                        Ty.apply
                          (Ty.path "alloc::vec::Vec")
                          []
                          [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                        [],
                        [],
                        "deref",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (| M.borrow (| Pointer.Kind.Ref, bytes |) |)
                        |)
                      ]
                    |)
                  |)
                |)
              ]
            |)
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "serde::ser::Serialize"
      (* Trait polymorphic consts *) []
      (* Trait polymorphic types *) []
      Self
      (* Instance *) [ ("serialize", InstanceField.Method serialize) ].
End Impl_serde_ser_Serialize_for_p3_bn254_fr_Bn254Fr.

Module Impl_serde_de_Deserialize_for_p3_bn254_fr_Bn254Fr.
  Definition Self : Ty.t := Ty.path "p3_bn254_fr::Bn254Fr".
  
  (*
      fn deserialize<D: Deserializer<'de>>(d: D) -> Result<Self, D::Error> {
          let bytes: Vec<u8> = Deserialize::deserialize(d)?;
  
          FFBn254Fr::from_raw_bytes(&bytes)
              .map(Self::new)
              .ok_or_else(|| serde::de::Error::custom("Invalid field element"))
      }
  *)
  Definition deserialize (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ D ], [ d ] =>
      ltac:(M.monadic
        (let d := M.alloc (| d |) in
        M.catch_return
          (Ty.apply
            (Ty.path "core::result::Result")
            []
            [
              Ty.path "p3_bn254_fr::Bn254Fr";
              Ty.associated_in_trait "serde::de::Deserializer" [] [] D "Error"
            ]) (|
          ltac:(M.monadic
            (M.read (|
              let~ bytes :
                  Ty.apply
                    (Ty.path "*")
                    []
                    [
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        []
                        [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                    ] :=
                M.copy (|
                  M.match_operator (|
                    Ty.apply
                      (Ty.path "*")
                      []
                      [
                        Ty.apply
                          (Ty.path "alloc::vec::Vec")
                          []
                          [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                      ],
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::ops::control_flow::ControlFlow")
                          []
                          [
                            Ty.apply
                              (Ty.path "core::result::Result")
                              []
                              [
                                Ty.path "core::convert::Infallible";
                                Ty.associated_in_trait "serde::de::Deserializer" [] [] D "Error"
                              ];
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              []
                              [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ]
                          ],
                        M.get_trait_method (|
                          "core::ops::try_trait::Try",
                          Ty.apply
                            (Ty.path "core::result::Result")
                            []
                            [
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                []
                                [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ];
                              Ty.associated_in_trait "serde::de::Deserializer" [] [] D "Error"
                            ],
                          [],
                          [],
                          "branch",
                          [],
                          []
                        |),
                        [
                          M.call_closure (|
                            Ty.apply
                              (Ty.path "core::result::Result")
                              []
                              [
                                Ty.apply
                                  (Ty.path "alloc::vec::Vec")
                                  []
                                  [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ];
                                Ty.associated_in_trait "serde::de::Deserializer" [] [] D "Error"
                              ],
                            M.get_trait_method (|
                              "serde::de::Deserialize",
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                []
                                [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                              [],
                              [],
                              "deserialize",
                              [],
                              [ D ]
                            |),
                            [ M.read (| d |) ]
                          |)
                        ]
                      |)
                    |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ,
                              "core::ops::control_flow::ControlFlow::Break",
                              0
                            |) in
                          let residual := M.copy (| γ0_0 |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                M.return_ (|
                                  M.call_closure (|
                                    Ty.apply
                                      (Ty.path "core::result::Result")
                                      []
                                      [
                                        Ty.path "p3_bn254_fr::Bn254Fr";
                                        Ty.associated_in_trait
                                          "serde::de::Deserializer"
                                          []
                                          []
                                          D
                                          "Error"
                                      ],
                                    M.get_trait_method (|
                                      "core::ops::try_trait::FromResidual",
                                      Ty.apply
                                        (Ty.path "core::result::Result")
                                        []
                                        [
                                          Ty.path "p3_bn254_fr::Bn254Fr";
                                          Ty.associated_in_trait
                                            "serde::de::Deserializer"
                                            []
                                            []
                                            D
                                            "Error"
                                        ],
                                      [],
                                      [
                                        Ty.apply
                                          (Ty.path "core::result::Result")
                                          []
                                          [
                                            Ty.path "core::convert::Infallible";
                                            Ty.associated_in_trait
                                              "serde::de::Deserializer"
                                              []
                                              []
                                              D
                                              "Error"
                                          ]
                                      ],
                                      "from_residual",
                                      [],
                                      []
                                    |),
                                    [ M.read (| residual |) ]
                                  |)
                                |)
                              |)
                            |)
                          |)));
                      fun γ =>
                        ltac:(M.monadic
                          (let γ0_0 :=
                            M.SubPointer.get_struct_tuple_field (|
                              γ,
                              "core::ops::control_flow::ControlFlow::Continue",
                              0
                            |) in
                          let val := M.copy (| γ0_0 |) in
                          val))
                    ]
                  |)
                |) in
              M.alloc (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::result::Result")
                    []
                    [
                      Ty.path "p3_bn254_fr::Bn254Fr";
                      Ty.associated_in_trait "serde::de::Deserializer" [] [] D "Error"
                    ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "p3_bn254_fr::Bn254Fr" ],
                    "ok_or_else",
                    [],
                    [
                      Ty.associated_in_trait "serde::de::Deserializer" [] [] D "Error";
                      Ty.function
                        [ Ty.tuple [] ]
                        (Ty.associated_in_trait "serde::de::Deserializer" [] [] D "Error")
                    ]
                  |),
                  [
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::option::Option")
                        []
                        [ Ty.path "p3_bn254_fr::Bn254Fr" ],
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "core::option::Option")
                          []
                          [ Ty.path "halo2curves::bn256::fr::Fr" ],
                        "map",
                        [],
                        [
                          Ty.path "p3_bn254_fr::Bn254Fr";
                          Ty.function
                            [ Ty.path "halo2curves::bn256::fr::Fr" ]
                            (Ty.path "p3_bn254_fr::Bn254Fr")
                        ]
                      |),
                      [
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::option::Option")
                            []
                            [ Ty.path "halo2curves::bn256::fr::Fr" ],
                          M.get_trait_method (|
                            "halo2curves::serde::SerdeObject",
                            Ty.path "halo2curves::bn256::fr::Fr",
                            [],
                            [],
                            "from_raw_bytes",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (|
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "&")
                                    []
                                    [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                                  M.get_trait_method (|
                                    "core::ops::deref::Deref",
                                    Ty.apply
                                      (Ty.path "alloc::vec::Vec")
                                      []
                                      [ Ty.path "u8"; Ty.path "alloc::alloc::Global" ],
                                    [],
                                    [],
                                    "deref",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (| M.borrow (| Pointer.Kind.Ref, bytes |) |)
                                    |)
                                  ]
                                |)
                              |)
                            |)
                          ]
                        |);
                        M.get_associated_function (|
                          Ty.path "p3_bn254_fr::Bn254Fr",
                          "new",
                          [],
                          []
                        |)
                      ]
                    |);
                    M.closure
                      (fun γ =>
                        ltac:(M.monadic
                          match γ with
                          | [ α0 ] =>
                            ltac:(M.monadic
                              (M.match_operator (|
                                Ty.apply
                                  (Ty.path "*")
                                  []
                                  [
                                    Ty.function
                                      [ Ty.tuple [] ]
                                      (Ty.associated_in_trait
                                        "serde::de::Deserializer"
                                        []
                                        []
                                        D
                                        "Error")
                                  ],
                                M.alloc (| α0 |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (M.call_closure (|
                                        Ty.associated_in_trait
                                          "serde::de::Deserializer"
                                          []
                                          []
                                          D
                                          "Error",
                                        M.get_trait_method (|
                                          "serde::de::Error",
                                          Ty.associated_in_trait
                                            "serde::de::Deserializer"
                                            []
                                            []
                                            D
                                            "Error",
                                          [],
                                          [],
                                          "custom",
                                          [],
                                          [ Ty.apply (Ty.path "&") [] [ Ty.path "str" ] ]
                                        |),
                                        [ mk_str (| "Invalid field element" |) ]
                                      |)))
                                ]
                              |)))
                          | _ => M.impossible "wrong number of arguments"
                          end))
                  ]
                |)
              |)
            |)))
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "serde::de::Deserialize"
      (* Trait polymorphic consts *) []
      (* Trait polymorphic types *) []
      Self
      (* Instance *) [ ("deserialize", InstanceField.Method deserialize) ].
End Impl_serde_de_Deserialize_for_p3_bn254_fr_Bn254Fr.

Module Impl_p3_field_packed_Packable_for_p3_bn254_fr_Bn254Fr.
  Definition Self : Ty.t := Ty.path "p3_bn254_fr::Bn254Fr".
  
  Axiom Implements :
    M.IsTraitInstance
      "p3_field::packed::Packable"
      (* Trait polymorphic consts *) []
      (* Trait polymorphic types *) []
      Self
      (* Instance *) [].
End Impl_p3_field_packed_Packable_for_p3_bn254_fr_Bn254Fr.

Module Impl_core_hash_Hash_for_p3_bn254_fr_Bn254Fr.
  Definition Self : Ty.t := Ty.path "p3_bn254_fr::Bn254Fr".
  
  (*
      fn hash<H: Hasher>(&self, state: &mut H) {
          for byte in self.value.to_repr().as_ref() {
              state.write_u8( *byte);
          }
      }
  *)
  Definition hash (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ H ], [ self; state ] =>
      ltac:(M.monadic
        (let self := M.alloc (| self |) in
        let state := M.alloc (| state |) in
        M.read (|
          M.use
            (M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              M.alloc (|
                M.call_closure (|
                  Ty.apply (Ty.path "core::slice::iter::Iter") [] [ Ty.path "u8" ],
                  M.get_trait_method (|
                    "core::iter::traits::collect::IntoIterator",
                    Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                    [],
                    [],
                    "into_iter",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                      M.get_trait_method (|
                        "core::convert::AsRef",
                        Ty.apply
                          (Ty.path "halo2curves::serde::Repr")
                          [ Value.Integer IntegerKind.Usize 32 ]
                          [],
                        [],
                        [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                        "as_ref",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.alloc (|
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "halo2curves::serde::Repr")
                                [ Value.Integer IntegerKind.Usize 32 ]
                                [],
                              M.get_trait_method (|
                                "ff::PrimeField",
                                Ty.path "halo2curves::bn256::fr::Fr",
                                [],
                                [],
                                "to_repr",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "p3_bn254_fr::Bn254Fr",
                                    "value"
                                  |)
                                |)
                              ]
                            |)
                          |)
                        |)
                      ]
                    |)
                  ]
                |)
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let iter := M.copy (| γ |) in
                    M.loop (|
                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                      ltac:(M.monadic
                        (let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                          M.match_operator (|
                            Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply
                                  (Ty.path "core::option::Option")
                                  []
                                  [ Ty.apply (Ty.path "&") [] [ Ty.path "u8" ] ],
                                M.get_trait_method (|
                                  "core::iter::traits::iterator::Iterator",
                                  Ty.apply (Ty.path "core::slice::iter::Iter") [] [ Ty.path "u8" ],
                                  [],
                                  [],
                                  "next",
                                  [],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.MutRef,
                                    M.deref (| M.borrow (| Pointer.Kind.MutRef, iter |) |)
                                  |)
                                ]
                              |)
                            |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let _ :=
                                    M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                                  M.alloc (| M.never_to_any (| M.read (| M.break (||) |) |) |)));
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 :=
                                    M.SubPointer.get_struct_tuple_field (|
                                      γ,
                                      "core::option::Option::Some",
                                      0
                                    |) in
                                  let byte := M.copy (| γ0_0 |) in
                                  let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.tuple [],
                                        M.get_trait_method (|
                                          "core::hash::Hasher",
                                          H,
                                          [],
                                          [],
                                          "write_u8",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.MutRef,
                                            M.deref (| M.read (| state |) |)
                                          |);
                                          M.read (| M.deref (| M.read (| byte |) |) |)
                                        ]
                                      |)
                                    |) in
                                  M.alloc (| Value.Tuple [] |)))
                            ]
                          |) in
                        M.alloc (| Value.Tuple [] |)))
                    |)))
              ]
            |))
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::hash::Hash"
      (* Trait polymorphic consts *) []
      (* Trait polymorphic types *) []
      Self
      (* Instance *) [ ("hash", InstanceField.Method hash) ].
End Impl_core_hash_Hash_for_p3_bn254_fr_Bn254Fr.

Module Impl_core_cmp_Ord_for_p3_bn254_fr_Bn254Fr.
  Definition Self : Ty.t := Ty.path "p3_bn254_fr::Bn254Fr".
  
  (*
      fn cmp(&self, other: &Self) -> core::cmp::Ordering {
          self.value.cmp(&other.value)
      }
  *)
  Definition cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ self; other ] =>
      ltac:(M.monadic
        (let self := M.alloc (| self |) in
        let other := M.alloc (| other |) in
        M.call_closure (|
          Ty.path "core::cmp::Ordering",
          M.get_trait_method (|
            "core::cmp::Ord",
            Ty.path "halo2curves::bn256::fr::Fr",
            [],
            [],
            "cmp",
            [],
            []
          |),
          [
            M.borrow (|
              Pointer.Kind.Ref,
              M.SubPointer.get_struct_record_field (|
                M.deref (| M.read (| self |) |),
                "p3_bn254_fr::Bn254Fr",
                "value"
              |)
            |);
            M.borrow (|
              Pointer.Kind.Ref,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| other |) |),
                    "p3_bn254_fr::Bn254Fr",
                    "value"
                  |)
                |)
              |)
            |)
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::cmp::Ord"
      (* Trait polymorphic consts *) []
      (* Trait polymorphic types *) []
      Self
      (* Instance *) [ ("cmp", InstanceField.Method cmp) ].
End Impl_core_cmp_Ord_for_p3_bn254_fr_Bn254Fr.

Module Impl_core_cmp_PartialOrd_p3_bn254_fr_Bn254Fr_for_p3_bn254_fr_Bn254Fr.
  Definition Self : Ty.t := Ty.path "p3_bn254_fr::Bn254Fr".
  
  (*
      fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {
          Some(self.cmp(other))
      }
  *)
  Definition partial_cmp (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ self; other ] =>
      ltac:(M.monadic
        (let self := M.alloc (| self |) in
        let other := M.alloc (| other |) in
        Value.StructTuple
          "core::option::Option::Some"
          [
            M.call_closure (|
              Ty.path "core::cmp::Ordering",
              M.get_trait_method (|
                "core::cmp::Ord",
                Ty.path "p3_bn254_fr::Bn254Fr",
                [],
                [],
                "cmp",
                [],
                []
              |),
              [
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| other |) |) |)
              ]
            |)
          ]))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::cmp::PartialOrd"
      (* Trait polymorphic consts *) []
      (* Trait polymorphic types *) [ Ty.path "p3_bn254_fr::Bn254Fr" ]
      Self
      (* Instance *) [ ("partial_cmp", InstanceField.Method partial_cmp) ].
End Impl_core_cmp_PartialOrd_p3_bn254_fr_Bn254Fr_for_p3_bn254_fr_Bn254Fr.

Module Impl_core_fmt_Display_for_p3_bn254_fr_Bn254Fr.
  Definition Self : Ty.t := Ty.path "p3_bn254_fr::Bn254Fr".
  
  (*
      fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
          self.value.fmt(f)
      }
  *)
  Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ self; f ] =>
      ltac:(M.monadic
        (let self := M.alloc (| self |) in
        let f := M.alloc (| f |) in
        M.call_closure (|
          Ty.apply (Ty.path "core::result::Result") [] [ Ty.tuple []; Ty.path "core::fmt::Error" ],
          M.get_trait_method (|
            "core::fmt::Debug",
            Ty.path "halo2curves::bn256::fr::Fr",
            [],
            [],
            "fmt",
            [],
            []
          |),
          [
            M.borrow (|
              Pointer.Kind.Ref,
              M.SubPointer.get_struct_record_field (|
                M.deref (| M.read (| self |) |),
                "p3_bn254_fr::Bn254Fr",
                "value"
              |)
            |);
            M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |)
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::fmt::Display"
      (* Trait polymorphic consts *) []
      (* Trait polymorphic types *) []
      Self
      (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
End Impl_core_fmt_Display_for_p3_bn254_fr_Bn254Fr.

Module Impl_core_fmt_Debug_for_p3_bn254_fr_Bn254Fr.
  Definition Self : Ty.t := Ty.path "p3_bn254_fr::Bn254Fr".
  
  (*
      fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
          Debug::fmt(&self.value, f)
      }
  *)
  Definition fmt (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ self; f ] =>
      ltac:(M.monadic
        (let self := M.alloc (| self |) in
        let f := M.alloc (| f |) in
        M.call_closure (|
          Ty.apply (Ty.path "core::result::Result") [] [ Ty.tuple []; Ty.path "core::fmt::Error" ],
          M.get_trait_method (|
            "core::fmt::Debug",
            Ty.path "halo2curves::bn256::fr::Fr",
            [],
            [],
            "fmt",
            [],
            []
          |),
          [
            M.borrow (|
              Pointer.Kind.Ref,
              M.deref (|
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "p3_bn254_fr::Bn254Fr",
                    "value"
                  |)
                |)
              |)
            |);
            M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |)
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::fmt::Debug"
      (* Trait polymorphic consts *) []
      (* Trait polymorphic types *) []
      Self
      (* Instance *) [ ("fmt", InstanceField.Method fmt) ].
End Impl_core_fmt_Debug_for_p3_bn254_fr_Bn254Fr.

Module Impl_p3_field_field_PrimeCharacteristicRing_for_p3_bn254_fr_Bn254Fr.
  Definition Self : Ty.t := Ty.path "p3_bn254_fr::Bn254Fr".
  
  (*     type PrimeSubfield = Self; *)
  Definition _PrimeSubfield : Ty.t := Ty.path "p3_bn254_fr::Bn254Fr".
  
  (*     const ZERO: Self = Self::new(FFBn254Fr::ZERO); *)
  (* Ty.path "p3_bn254_fr::Bn254Fr" *)
  Definition value_ZERO (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    ltac:(M.monadic
      (M.alloc (|
        M.call_closure (|
          Ty.path "p3_bn254_fr::Bn254Fr",
          M.get_associated_function (| Ty.path "p3_bn254_fr::Bn254Fr", "new", [], [] |),
          [ M.read (| get_constant (| "ff::Field::ZERO", Ty.path "halo2curves::bn256::fr::Fr" |) |)
          ]
        |)
      |))).
  
  (*     const ONE: Self = Self::new(FFBn254Fr::ONE); *)
  (* Ty.path "p3_bn254_fr::Bn254Fr" *)
  Definition value_ONE (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    ltac:(M.monadic
      (M.alloc (|
        M.call_closure (|
          Ty.path "p3_bn254_fr::Bn254Fr",
          M.get_associated_function (| Ty.path "p3_bn254_fr::Bn254Fr", "new", [], [] |),
          [ M.read (| get_constant (| "ff::Field::ONE", Ty.path "halo2curves::bn256::fr::Fr" |) |) ]
        |)
      |))).
  
  (*     const TWO: Self = Self::new(FFBn254Fr::from_raw([2u64, 0, 0, 0])); *)
  (* Ty.path "p3_bn254_fr::Bn254Fr" *)
  Definition value_TWO (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    ltac:(M.monadic
      (M.alloc (|
        M.call_closure (|
          Ty.path "p3_bn254_fr::Bn254Fr",
          M.get_associated_function (| Ty.path "p3_bn254_fr::Bn254Fr", "new", [], [] |),
          [
            M.call_closure (|
              Ty.path "halo2curves::bn256::fr::Fr",
              M.get_associated_function (|
                Ty.path "halo2curves::bn256::fr::Fr",
                "from_raw",
                [],
                []
              |),
              [
                Value.Array
                  [
                    Value.Integer IntegerKind.U64 2;
                    Value.Integer IntegerKind.U64 0;
                    Value.Integer IntegerKind.U64 0;
                    Value.Integer IntegerKind.U64 0
                  ]
              ]
            |)
          ]
        |)
      |))).
  
  (*
      const NEG_ONE: Self = Self::new(FFBn254Fr::from_raw([
          0x43e1f593f0000000,
          0x2833e84879b97091,
          0xb85045b68181585d,
          0x30644e72e131a029,
      ]));
  *)
  (* Ty.path "p3_bn254_fr::Bn254Fr" *)
  Definition value_NEG_ONE (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    ltac:(M.monadic
      (M.alloc (|
        M.call_closure (|
          Ty.path "p3_bn254_fr::Bn254Fr",
          M.get_associated_function (| Ty.path "p3_bn254_fr::Bn254Fr", "new", [], [] |),
          [
            M.call_closure (|
              Ty.path "halo2curves::bn256::fr::Fr",
              M.get_associated_function (|
                Ty.path "halo2curves::bn256::fr::Fr",
                "from_raw",
                [],
                []
              |),
              [
                Value.Array
                  [
                    Value.Integer IntegerKind.U64 4891460686036598784;
                    Value.Integer IntegerKind.U64 2896914383306846353;
                    Value.Integer IntegerKind.U64 13281191951274694749;
                    Value.Integer IntegerKind.U64 3486998266802970665
                  ]
              ]
            |)
          ]
        |)
      |))).
  
  (*
      fn from_prime_subfield(f: Self::PrimeSubfield) -> Self {
          f
      }
  *)
  Definition from_prime_subfield (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ f ] =>
      ltac:(M.monadic
        (let f := M.alloc (| f |) in
        M.read (| f |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "p3_field::field::PrimeCharacteristicRing"
      (* Trait polymorphic consts *) []
      (* Trait polymorphic types *) []
      Self
      (* Instance *)
      [
        ("PrimeSubfield", InstanceField.Ty _PrimeSubfield);
        ("value_ZERO", InstanceField.Method value_ZERO);
        ("value_ONE", InstanceField.Method value_ONE);
        ("value_TWO", InstanceField.Method value_TWO);
        ("value_NEG_ONE", InstanceField.Method value_NEG_ONE);
        ("from_prime_subfield", InstanceField.Method from_prime_subfield)
      ].
End Impl_p3_field_field_PrimeCharacteristicRing_for_p3_bn254_fr_Bn254Fr.

Module Impl_p3_field_field_InjectiveMonomial_U64_5_for_p3_bn254_fr_Bn254Fr.
  Definition Self : Ty.t := Ty.path "p3_bn254_fr::Bn254Fr".
  
  Axiom Implements :
    M.IsTraitInstance
      "p3_field::field::InjectiveMonomial"
      (* Trait polymorphic consts *) [ Value.Integer IntegerKind.U64 5 ]
      (* Trait polymorphic types *) []
      Self
      (* Instance *) [].
End Impl_p3_field_field_InjectiveMonomial_U64_5_for_p3_bn254_fr_Bn254Fr.

Module Impl_p3_field_field_Field_for_p3_bn254_fr_Bn254Fr.
  Definition Self : Ty.t := Ty.path "p3_bn254_fr::Bn254Fr".
  
  (*     type Packing = Self; *)
  Definition _Packing : Ty.t := Ty.path "p3_bn254_fr::Bn254Fr".
  
  (*     const GENERATOR: Self = Self::new(FFBn254Fr::from_raw([5u64, 0, 0, 0])); *)
  (* Ty.path "p3_bn254_fr::Bn254Fr" *)
  Definition value_GENERATOR (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    ltac:(M.monadic
      (M.alloc (|
        M.call_closure (|
          Ty.path "p3_bn254_fr::Bn254Fr",
          M.get_associated_function (| Ty.path "p3_bn254_fr::Bn254Fr", "new", [], [] |),
          [
            M.call_closure (|
              Ty.path "halo2curves::bn256::fr::Fr",
              M.get_associated_function (|
                Ty.path "halo2curves::bn256::fr::Fr",
                "from_raw",
                [],
                []
              |),
              [
                Value.Array
                  [
                    Value.Integer IntegerKind.U64 5;
                    Value.Integer IntegerKind.U64 0;
                    Value.Integer IntegerKind.U64 0;
                    Value.Integer IntegerKind.U64 0
                  ]
              ]
            |)
          ]
        |)
      |))).
  
  (*
      fn is_zero(&self) -> bool {
          self.value.is_zero().into()
      }
  *)
  Definition is_zero (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ self ] =>
      ltac:(M.monadic
        (let self := M.alloc (| self |) in
        M.call_closure (|
          Ty.path "bool",
          M.get_trait_method (|
            "core::convert::Into",
            Ty.path "subtle::Choice",
            [],
            [ Ty.path "bool" ],
            "into",
            [],
            []
          |),
          [
            M.call_closure (|
              Ty.path "subtle::Choice",
              M.get_trait_method (|
                "ff::Field",
                Ty.path "halo2curves::bn256::fr::Fr",
                [],
                [],
                "is_zero",
                [],
                []
              |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "p3_bn254_fr::Bn254Fr",
                    "value"
                  |)
                |)
              ]
            |)
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  (*
      fn try_inverse(&self) -> Option<Self> {
          let inverse = self.value.invert();
  
          if inverse.is_some().into() {
              Some(Self::new(inverse.unwrap()))
          } else {
              None
          }
      }
  *)
  Definition try_inverse (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ self ] =>
      ltac:(M.monadic
        (let self := M.alloc (| self |) in
        M.read (|
          let~ inverse :
              Ty.apply
                (Ty.path "*")
                []
                [ Ty.apply (Ty.path "subtle::CtOption") [] [ Ty.path "halo2curves::bn256::fr::Fr" ]
                ] :=
            M.alloc (|
              M.call_closure (|
                Ty.apply (Ty.path "subtle::CtOption") [] [ Ty.path "halo2curves::bn256::fr::Fr" ],
                M.get_trait_method (|
                  "ff::Field",
                  Ty.path "halo2curves::bn256::fr::Fr",
                  [],
                  [],
                  "invert",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "p3_bn254_fr::Bn254Fr",
                      "value"
                    |)
                  |)
                ]
              |)
            |) in
          M.match_operator (|
            Ty.apply
              (Ty.path "*")
              []
              [ Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "p3_bn254_fr::Bn254Fr" ] ],
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        M.call_closure (|
                          Ty.path "bool",
                          M.get_trait_method (|
                            "core::convert::Into",
                            Ty.path "subtle::Choice",
                            [],
                            [ Ty.path "bool" ],
                            "into",
                            [],
                            []
                          |),
                          [
                            M.call_closure (|
                              Ty.path "subtle::Choice",
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "subtle::CtOption")
                                  []
                                  [ Ty.path "halo2curves::bn256::fr::Fr" ],
                                "is_some",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.Ref, inverse |) ]
                            |)
                          ]
                        |)
                      |)) in
                  let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    Value.StructTuple
                      "core::option::Option::Some"
                      [
                        M.call_closure (|
                          Ty.path "p3_bn254_fr::Bn254Fr",
                          M.get_associated_function (|
                            Ty.path "p3_bn254_fr::Bn254Fr",
                            "new",
                            [],
                            []
                          |),
                          [
                            M.call_closure (|
                              Ty.path "halo2curves::bn256::fr::Fr",
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "subtle::CtOption")
                                  []
                                  [ Ty.path "halo2curves::bn256::fr::Fr" ],
                                "unwrap",
                                [],
                                []
                              |),
                              [ M.read (| inverse |) ]
                            |)
                          ]
                        |)
                      ]
                  |)));
              fun γ =>
                ltac:(M.monadic (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
            ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  (*
      fn order() -> BigUint {
          BigUint::from_slice(&[
              0xf0000001, 0x43e1f593, 0x79b97091, 0x2833e848, 0x8181585d, 0xb85045b6, 0xe131a029,
              0x30644e72,
          ])
      }
  *)
  Definition order (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [] =>
      ltac:(M.monadic
        (M.call_closure (|
          Ty.path "num_bigint::biguint::BigUint",
          M.get_associated_function (|
            Ty.path "num_bigint::biguint::BigUint",
            "from_slice",
            [],
            []
          |),
          [
            (* Unsize *)
            M.pointer_coercion
              (M.borrow (|
                Pointer.Kind.Ref,
                M.deref (|
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.alloc (|
                      Value.Array
                        [
                          Value.Integer IntegerKind.U32 4026531841;
                          Value.Integer IntegerKind.U32 1138881939;
                          Value.Integer IntegerKind.U32 2042196113;
                          Value.Integer IntegerKind.U32 674490440;
                          Value.Integer IntegerKind.U32 2172737629;
                          Value.Integer IntegerKind.U32 3092268470;
                          Value.Integer IntegerKind.U32 3778125865;
                          Value.Integer IntegerKind.U32 811880050
                        ]
                    |)
                  |)
                |)
              |))
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "p3_field::field::Field"
      (* Trait polymorphic consts *) []
      (* Trait polymorphic types *) []
      Self
      (* Instance *)
      [
        ("Packing", InstanceField.Ty _Packing);
        ("value_GENERATOR", InstanceField.Method value_GENERATOR);
        ("is_zero", InstanceField.Method is_zero);
        ("try_inverse", InstanceField.Method try_inverse);
        ("order", InstanceField.Method order)
      ].
End Impl_p3_field_field_Field_for_p3_bn254_fr_Bn254Fr.

Module Impl_p3_field_integers_QuotientMap_u128_for_p3_bn254_fr_Bn254Fr.
  Definition Self : Ty.t := Ty.path "p3_bn254_fr::Bn254Fr".
  
  (*
      fn from_int(int: u128) -> Self {
          Self::new(FFBn254Fr::from_raw([int as u64, (int >> 64) as u64, 0, 0]))
      }
  *)
  Definition from_int (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ int ] =>
      ltac:(M.monadic
        (let int := M.alloc (| int |) in
        M.call_closure (|
          Ty.path "p3_bn254_fr::Bn254Fr",
          M.get_associated_function (| Ty.path "p3_bn254_fr::Bn254Fr", "new", [], [] |),
          [
            M.call_closure (|
              Ty.path "halo2curves::bn256::fr::Fr",
              M.get_associated_function (|
                Ty.path "halo2curves::bn256::fr::Fr",
                "from_raw",
                [],
                []
              |),
              [
                Value.Array
                  [
                    M.cast (Ty.path "u64") (M.read (| int |));
                    M.cast
                      (Ty.path "u64")
                      (M.call_closure (|
                        Ty.path "u128",
                        BinOp.Wrap.shr,
                        [ M.read (| int |); Value.Integer IntegerKind.I32 64 ]
                      |));
                    Value.Integer IntegerKind.U64 0;
                    Value.Integer IntegerKind.U64 0
                  ]
              ]
            |)
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  (*
      fn from_canonical_checked(int: u128) -> Option<Self> {
          Some(Self::from_int(int))
      }
  *)
  Definition from_canonical_checked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ int ] =>
      ltac:(M.monadic
        (let int := M.alloc (| int |) in
        Value.StructTuple
          "core::option::Option::Some"
          [
            M.call_closure (|
              Ty.path "p3_bn254_fr::Bn254Fr",
              M.get_trait_method (|
                "p3_field::integers::QuotientMap",
                Ty.path "p3_bn254_fr::Bn254Fr",
                [],
                [ Ty.path "u128" ],
                "from_int",
                [],
                []
              |),
              [ M.read (| int |) ]
            |)
          ]))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  (*
      unsafe fn from_canonical_unchecked(int: u128) -> Self {
          Self::from_int(int)
      }
  *)
  Definition from_canonical_unchecked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ int ] =>
      ltac:(M.monadic
        (let int := M.alloc (| int |) in
        M.call_closure (|
          Ty.path "p3_bn254_fr::Bn254Fr",
          M.get_trait_method (|
            "p3_field::integers::QuotientMap",
            Ty.path "p3_bn254_fr::Bn254Fr",
            [],
            [ Ty.path "u128" ],
            "from_int",
            [],
            []
          |),
          [ M.read (| int |) ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "p3_field::integers::QuotientMap"
      (* Trait polymorphic consts *) []
      (* Trait polymorphic types *) [ Ty.path "u128" ]
      Self
      (* Instance *)
      [
        ("from_int", InstanceField.Method from_int);
        ("from_canonical_checked", InstanceField.Method from_canonical_checked);
        ("from_canonical_unchecked", InstanceField.Method from_canonical_unchecked)
      ].
End Impl_p3_field_integers_QuotientMap_u128_for_p3_bn254_fr_Bn254Fr.

Module Impl_p3_field_integers_QuotientMap_i128_for_p3_bn254_fr_Bn254Fr.
  Definition Self : Ty.t := Ty.path "p3_bn254_fr::Bn254Fr".
  
  (*
      fn from_int(int: i128) -> Self {
          // Nothing better than just branching based on the sign of int.
          if int >= 0 {
              Self::from_int(int as u128)
          } else {
              -Self::from_int((-int) as u128)
          }
      }
  *)
  Definition from_int (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ int ] =>
      ltac:(M.monadic
        (let int := M.alloc (| int |) in
        M.read (|
          M.match_operator (|
            Ty.apply (Ty.path "*") [] [ Ty.path "p3_bn254_fr::Bn254Fr" ],
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        M.call_closure (|
                          Ty.path "bool",
                          BinOp.ge,
                          [ M.read (| int |); Value.Integer IntegerKind.I128 0 ]
                        |)
                      |)) in
                  let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  M.alloc (|
                    M.call_closure (|
                      Ty.path "p3_bn254_fr::Bn254Fr",
                      M.get_trait_method (|
                        "p3_field::integers::QuotientMap",
                        Ty.path "p3_bn254_fr::Bn254Fr",
                        [],
                        [ Ty.path "u128" ],
                        "from_int",
                        [],
                        []
                      |),
                      [ M.cast (Ty.path "u128") (M.read (| int |)) ]
                    |)
                  |)));
              fun γ =>
                ltac:(M.monadic
                  (M.alloc (|
                    M.call_closure (|
                      Ty.path "p3_bn254_fr::Bn254Fr",
                      M.get_trait_method (|
                        "core::ops::arith::Neg",
                        Ty.path "p3_bn254_fr::Bn254Fr",
                        [],
                        [],
                        "neg",
                        [],
                        []
                      |),
                      [
                        M.call_closure (|
                          Ty.path "p3_bn254_fr::Bn254Fr",
                          M.get_trait_method (|
                            "p3_field::integers::QuotientMap",
                            Ty.path "p3_bn254_fr::Bn254Fr",
                            [],
                            [ Ty.path "u128" ],
                            "from_int",
                            [],
                            []
                          |),
                          [ M.cast (Ty.path "u128") (UnOp.neg (| M.read (| int |) |)) ]
                        |)
                      ]
                    |)
                  |)))
            ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  (*
      fn from_canonical_checked(int: i128) -> Option<Self> {
          Some(Self::from_int(int))
      }
  *)
  Definition from_canonical_checked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ int ] =>
      ltac:(M.monadic
        (let int := M.alloc (| int |) in
        Value.StructTuple
          "core::option::Option::Some"
          [
            M.call_closure (|
              Ty.path "p3_bn254_fr::Bn254Fr",
              M.get_trait_method (|
                "p3_field::integers::QuotientMap",
                Ty.path "p3_bn254_fr::Bn254Fr",
                [],
                [ Ty.path "i128" ],
                "from_int",
                [],
                []
              |),
              [ M.read (| int |) ]
            |)
          ]))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  (*
      unsafe fn from_canonical_unchecked(int: i128) -> Self {
          Self::from_int(int)
      }
  *)
  Definition from_canonical_unchecked (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ int ] =>
      ltac:(M.monadic
        (let int := M.alloc (| int |) in
        M.call_closure (|
          Ty.path "p3_bn254_fr::Bn254Fr",
          M.get_trait_method (|
            "p3_field::integers::QuotientMap",
            Ty.path "p3_bn254_fr::Bn254Fr",
            [],
            [ Ty.path "i128" ],
            "from_int",
            [],
            []
          |),
          [ M.read (| int |) ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "p3_field::integers::QuotientMap"
      (* Trait polymorphic consts *) []
      (* Trait polymorphic types *) [ Ty.path "i128" ]
      Self
      (* Instance *)
      [
        ("from_int", InstanceField.Method from_int);
        ("from_canonical_checked", InstanceField.Method from_canonical_checked);
        ("from_canonical_unchecked", InstanceField.Method from_canonical_unchecked)
      ].
End Impl_p3_field_integers_QuotientMap_i128_for_p3_bn254_fr_Bn254Fr.

Module Impl_p3_field_field_PrimeField_for_p3_bn254_fr_Bn254Fr.
  Definition Self : Ty.t := Ty.path "p3_bn254_fr::Bn254Fr".
  
  (*
      fn as_canonical_biguint(&self) -> BigUint {
          let repr = self.value.to_repr();
          let le_bytes = repr.as_ref();
          BigUint::from_bytes_le(le_bytes)
      }
  *)
  Definition as_canonical_biguint (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ self ] =>
      ltac:(M.monadic
        (let self := M.alloc (| self |) in
        M.read (|
          let~ repr :
              Ty.apply
                (Ty.path "*")
                []
                [
                  Ty.apply
                    (Ty.path "halo2curves::serde::Repr")
                    [ Value.Integer IntegerKind.Usize 32 ]
                    []
                ] :=
            M.alloc (|
              M.call_closure (|
                Ty.apply
                  (Ty.path "halo2curves::serde::Repr")
                  [ Value.Integer IntegerKind.Usize 32 ]
                  [],
                M.get_trait_method (|
                  "ff::PrimeField",
                  Ty.path "halo2curves::bn256::fr::Fr",
                  [],
                  [],
                  "to_repr",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "p3_bn254_fr::Bn254Fr",
                      "value"
                    |)
                  |)
                ]
              |)
            |) in
          let~ le_bytes :
              Ty.apply
                (Ty.path "*")
                []
                [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ] ] :=
            M.alloc (|
              M.call_closure (|
                Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                M.get_trait_method (|
                  "core::convert::AsRef",
                  Ty.apply
                    (Ty.path "halo2curves::serde::Repr")
                    [ Value.Integer IntegerKind.Usize 32 ]
                    [],
                  [],
                  [ Ty.apply (Ty.path "slice") [] [ Ty.path "u8" ] ],
                  "as_ref",
                  [],
                  []
                |),
                [ M.borrow (| Pointer.Kind.Ref, repr |) ]
              |)
            |) in
          M.alloc (|
            M.call_closure (|
              Ty.path "num_bigint::biguint::BigUint",
              M.get_associated_function (|
                Ty.path "num_bigint::biguint::BigUint",
                "from_bytes_le",
                [],
                []
              |),
              [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| le_bytes |) |) |) ]
            |)
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "p3_field::field::PrimeField"
      (* Trait polymorphic consts *) []
      (* Trait polymorphic types *) []
      Self
      (* Instance *) [ ("as_canonical_biguint", InstanceField.Method as_canonical_biguint) ].
End Impl_p3_field_field_PrimeField_for_p3_bn254_fr_Bn254Fr.

Module Impl_core_ops_arith_Add_p3_bn254_fr_Bn254Fr_for_p3_bn254_fr_Bn254Fr.
  Definition Self : Ty.t := Ty.path "p3_bn254_fr::Bn254Fr".
  
  (*     type Output = Self; *)
  Definition _Output : Ty.t := Ty.path "p3_bn254_fr::Bn254Fr".
  
  (*
      fn add(self, rhs: Self) -> Self {
          Self::new(self.value + rhs.value)
      }
  *)
  Definition add (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ self; rhs ] =>
      ltac:(M.monadic
        (let self := M.alloc (| self |) in
        let rhs := M.alloc (| rhs |) in
        M.call_closure (|
          Ty.path "p3_bn254_fr::Bn254Fr",
          M.get_associated_function (| Ty.path "p3_bn254_fr::Bn254Fr", "new", [], [] |),
          [
            M.call_closure (|
              Ty.path "halo2curves::bn256::fr::Fr",
              M.get_trait_method (|
                "core::ops::arith::Add",
                Ty.path "halo2curves::bn256::fr::Fr",
                [],
                [ Ty.path "halo2curves::bn256::fr::Fr" ],
                "add",
                [],
                []
              |),
              [
                M.read (|
                  M.SubPointer.get_struct_record_field (| self, "p3_bn254_fr::Bn254Fr", "value" |)
                |);
                M.read (|
                  M.SubPointer.get_struct_record_field (| rhs, "p3_bn254_fr::Bn254Fr", "value" |)
                |)
              ]
            |)
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::ops::arith::Add"
      (* Trait polymorphic consts *) []
      (* Trait polymorphic types *) [ Ty.path "p3_bn254_fr::Bn254Fr" ]
      Self
      (* Instance *) [ ("Output", InstanceField.Ty _Output); ("add", InstanceField.Method add) ].
End Impl_core_ops_arith_Add_p3_bn254_fr_Bn254Fr_for_p3_bn254_fr_Bn254Fr.

Module Impl_core_ops_arith_AddAssign_p3_bn254_fr_Bn254Fr_for_p3_bn254_fr_Bn254Fr.
  Definition Self : Ty.t := Ty.path "p3_bn254_fr::Bn254Fr".
  
  (*
      fn add_assign(&mut self, rhs: Self) {
          self.value += rhs.value;
      }
  *)
  Definition add_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ self; rhs ] =>
      ltac:(M.monadic
        (let self := M.alloc (| self |) in
        let rhs := M.alloc (| rhs |) in
        M.read (|
          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
            M.alloc (|
              M.call_closure (|
                Ty.tuple [],
                M.get_trait_method (|
                  "core::ops::arith::AddAssign",
                  Ty.path "halo2curves::bn256::fr::Fr",
                  [],
                  [ Ty.path "halo2curves::bn256::fr::Fr" ],
                  "add_assign",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.MutRef,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "p3_bn254_fr::Bn254Fr",
                      "value"
                    |)
                  |);
                  M.read (|
                    M.SubPointer.get_struct_record_field (| rhs, "p3_bn254_fr::Bn254Fr", "value" |)
                  |)
                ]
              |)
            |) in
          M.alloc (| Value.Tuple [] |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::ops::arith::AddAssign"
      (* Trait polymorphic consts *) []
      (* Trait polymorphic types *) [ Ty.path "p3_bn254_fr::Bn254Fr" ]
      Self
      (* Instance *) [ ("add_assign", InstanceField.Method add_assign) ].
End Impl_core_ops_arith_AddAssign_p3_bn254_fr_Bn254Fr_for_p3_bn254_fr_Bn254Fr.

Module Impl_core_iter_traits_accum_Sum_p3_bn254_fr_Bn254Fr_for_p3_bn254_fr_Bn254Fr.
  Definition Self : Ty.t := Ty.path "p3_bn254_fr::Bn254Fr".
  
  (*
      fn sum<I: Iterator<Item = Self>>(iter: I) -> Self {
          iter.reduce(|x, y| x + y).unwrap_or(Self::ZERO)
      }
  *)
  Definition sum (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ _ as I ], [ iter ] =>
      ltac:(M.monadic
        (let iter := M.alloc (| iter |) in
        M.call_closure (|
          Ty.path "p3_bn254_fr::Bn254Fr",
          M.get_associated_function (|
            Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "p3_bn254_fr::Bn254Fr" ],
            "unwrap_or",
            [],
            []
          |),
          [
            M.call_closure (|
              Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "p3_bn254_fr::Bn254Fr" ],
              M.get_trait_method (|
                "core::iter::traits::iterator::Iterator",
                I,
                [],
                [],
                "reduce",
                [],
                [
                  Ty.function
                    [ Ty.tuple [ Ty.path "p3_bn254_fr::Bn254Fr"; Ty.path "p3_bn254_fr::Bn254Fr" ] ]
                    (Ty.path "p3_bn254_fr::Bn254Fr")
                ]
              |),
              [
                M.read (| iter |);
                M.closure
                  (fun γ =>
                    ltac:(M.monadic
                      match γ with
                      | [ α0; α1 ] =>
                        ltac:(M.monadic
                          (M.match_operator (|
                            Ty.apply
                              (Ty.path "*")
                              []
                              [
                                Ty.function
                                  [
                                    Ty.tuple
                                      [
                                        Ty.path "p3_bn254_fr::Bn254Fr";
                                        Ty.path "p3_bn254_fr::Bn254Fr"
                                      ]
                                  ]
                                  (Ty.path "p3_bn254_fr::Bn254Fr")
                              ],
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let x := M.copy (| γ |) in
                                  M.match_operator (|
                                    Ty.apply
                                      (Ty.path "*")
                                      []
                                      [
                                        Ty.function
                                          [
                                            Ty.tuple
                                              [
                                                Ty.path "p3_bn254_fr::Bn254Fr";
                                                Ty.path "p3_bn254_fr::Bn254Fr"
                                              ]
                                          ]
                                          (Ty.path "p3_bn254_fr::Bn254Fr")
                                      ],
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let y := M.copy (| γ |) in
                                          M.call_closure (|
                                            Ty.path "p3_bn254_fr::Bn254Fr",
                                            M.get_trait_method (|
                                              "core::ops::arith::Add",
                                              Ty.path "p3_bn254_fr::Bn254Fr",
                                              [],
                                              [ Ty.path "p3_bn254_fr::Bn254Fr" ],
                                              "add",
                                              [],
                                              []
                                            |),
                                            [ M.read (| x |); M.read (| y |) ]
                                          |)))
                                    ]
                                  |)))
                            ]
                          |)))
                      | _ => M.impossible "wrong number of arguments"
                      end))
              ]
            |);
            M.read (|
              get_constant (|
                "p3_field::field::PrimeCharacteristicRing::ZERO",
                Ty.path "p3_bn254_fr::Bn254Fr"
              |)
            |)
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::iter::traits::accum::Sum"
      (* Trait polymorphic consts *) []
      (* Trait polymorphic types *) [ Ty.path "p3_bn254_fr::Bn254Fr" ]
      Self
      (* Instance *) [ ("sum", InstanceField.Method sum) ].
End Impl_core_iter_traits_accum_Sum_p3_bn254_fr_Bn254Fr_for_p3_bn254_fr_Bn254Fr.

Module Impl_core_ops_arith_Sub_p3_bn254_fr_Bn254Fr_for_p3_bn254_fr_Bn254Fr.
  Definition Self : Ty.t := Ty.path "p3_bn254_fr::Bn254Fr".
  
  (*     type Output = Self; *)
  Definition _Output : Ty.t := Ty.path "p3_bn254_fr::Bn254Fr".
  
  (*
      fn sub(self, rhs: Self) -> Self {
          Self::new(self.value.sub(rhs.value))
      }
  *)
  Definition sub (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ self; rhs ] =>
      ltac:(M.monadic
        (let self := M.alloc (| self |) in
        let rhs := M.alloc (| rhs |) in
        M.call_closure (|
          Ty.path "p3_bn254_fr::Bn254Fr",
          M.get_associated_function (| Ty.path "p3_bn254_fr::Bn254Fr", "new", [], [] |),
          [
            M.call_closure (|
              Ty.path "halo2curves::bn256::fr::Fr",
              M.get_trait_method (|
                "core::ops::arith::Sub",
                Ty.path "halo2curves::bn256::fr::Fr",
                [],
                [ Ty.path "halo2curves::bn256::fr::Fr" ],
                "sub",
                [],
                []
              |),
              [
                M.read (|
                  M.SubPointer.get_struct_record_field (| self, "p3_bn254_fr::Bn254Fr", "value" |)
                |);
                M.read (|
                  M.SubPointer.get_struct_record_field (| rhs, "p3_bn254_fr::Bn254Fr", "value" |)
                |)
              ]
            |)
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::ops::arith::Sub"
      (* Trait polymorphic consts *) []
      (* Trait polymorphic types *) [ Ty.path "p3_bn254_fr::Bn254Fr" ]
      Self
      (* Instance *) [ ("Output", InstanceField.Ty _Output); ("sub", InstanceField.Method sub) ].
End Impl_core_ops_arith_Sub_p3_bn254_fr_Bn254Fr_for_p3_bn254_fr_Bn254Fr.

Module Impl_core_ops_arith_SubAssign_p3_bn254_fr_Bn254Fr_for_p3_bn254_fr_Bn254Fr.
  Definition Self : Ty.t := Ty.path "p3_bn254_fr::Bn254Fr".
  
  (*
      fn sub_assign(&mut self, rhs: Self) {
          self.value -= rhs.value;
      }
  *)
  Definition sub_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ self; rhs ] =>
      ltac:(M.monadic
        (let self := M.alloc (| self |) in
        let rhs := M.alloc (| rhs |) in
        M.read (|
          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
            M.alloc (|
              M.call_closure (|
                Ty.tuple [],
                M.get_trait_method (|
                  "core::ops::arith::SubAssign",
                  Ty.path "halo2curves::bn256::fr::Fr",
                  [],
                  [ Ty.path "halo2curves::bn256::fr::Fr" ],
                  "sub_assign",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.MutRef,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "p3_bn254_fr::Bn254Fr",
                      "value"
                    |)
                  |);
                  M.read (|
                    M.SubPointer.get_struct_record_field (| rhs, "p3_bn254_fr::Bn254Fr", "value" |)
                  |)
                ]
              |)
            |) in
          M.alloc (| Value.Tuple [] |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::ops::arith::SubAssign"
      (* Trait polymorphic consts *) []
      (* Trait polymorphic types *) [ Ty.path "p3_bn254_fr::Bn254Fr" ]
      Self
      (* Instance *) [ ("sub_assign", InstanceField.Method sub_assign) ].
End Impl_core_ops_arith_SubAssign_p3_bn254_fr_Bn254Fr_for_p3_bn254_fr_Bn254Fr.

Module Impl_core_ops_arith_Neg_for_p3_bn254_fr_Bn254Fr.
  Definition Self : Ty.t := Ty.path "p3_bn254_fr::Bn254Fr".
  
  (*     type Output = Self; *)
  Definition _Output : Ty.t := Ty.path "p3_bn254_fr::Bn254Fr".
  
  (*
      fn neg(self) -> Self::Output {
          self * Self::NEG_ONE
      }
  *)
  Definition neg (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ self ] =>
      ltac:(M.monadic
        (let self := M.alloc (| self |) in
        M.call_closure (|
          Ty.path "p3_bn254_fr::Bn254Fr",
          M.get_trait_method (|
            "core::ops::arith::Mul",
            Ty.path "p3_bn254_fr::Bn254Fr",
            [],
            [ Ty.path "p3_bn254_fr::Bn254Fr" ],
            "mul",
            [],
            []
          |),
          [
            M.read (| self |);
            M.read (|
              get_constant (|
                "p3_field::field::PrimeCharacteristicRing::NEG_ONE",
                Ty.path "p3_bn254_fr::Bn254Fr"
              |)
            |)
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::ops::arith::Neg"
      (* Trait polymorphic consts *) []
      (* Trait polymorphic types *) []
      Self
      (* Instance *) [ ("Output", InstanceField.Ty _Output); ("neg", InstanceField.Method neg) ].
End Impl_core_ops_arith_Neg_for_p3_bn254_fr_Bn254Fr.

Module Impl_core_ops_arith_Mul_p3_bn254_fr_Bn254Fr_for_p3_bn254_fr_Bn254Fr.
  Definition Self : Ty.t := Ty.path "p3_bn254_fr::Bn254Fr".
  
  (*     type Output = Self; *)
  Definition _Output : Ty.t := Ty.path "p3_bn254_fr::Bn254Fr".
  
  (*
      fn mul(self, rhs: Self) -> Self {
          Self::new(self.value * rhs.value)
      }
  *)
  Definition mul (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ self; rhs ] =>
      ltac:(M.monadic
        (let self := M.alloc (| self |) in
        let rhs := M.alloc (| rhs |) in
        M.call_closure (|
          Ty.path "p3_bn254_fr::Bn254Fr",
          M.get_associated_function (| Ty.path "p3_bn254_fr::Bn254Fr", "new", [], [] |),
          [
            M.call_closure (|
              Ty.path "halo2curves::bn256::fr::Fr",
              M.get_trait_method (|
                "core::ops::arith::Mul",
                Ty.path "halo2curves::bn256::fr::Fr",
                [],
                [ Ty.path "halo2curves::bn256::fr::Fr" ],
                "mul",
                [],
                []
              |),
              [
                M.read (|
                  M.SubPointer.get_struct_record_field (| self, "p3_bn254_fr::Bn254Fr", "value" |)
                |);
                M.read (|
                  M.SubPointer.get_struct_record_field (| rhs, "p3_bn254_fr::Bn254Fr", "value" |)
                |)
              ]
            |)
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::ops::arith::Mul"
      (* Trait polymorphic consts *) []
      (* Trait polymorphic types *) [ Ty.path "p3_bn254_fr::Bn254Fr" ]
      Self
      (* Instance *) [ ("Output", InstanceField.Ty _Output); ("mul", InstanceField.Method mul) ].
End Impl_core_ops_arith_Mul_p3_bn254_fr_Bn254Fr_for_p3_bn254_fr_Bn254Fr.

Module Impl_core_ops_arith_MulAssign_p3_bn254_fr_Bn254Fr_for_p3_bn254_fr_Bn254Fr.
  Definition Self : Ty.t := Ty.path "p3_bn254_fr::Bn254Fr".
  
  (*
      fn mul_assign(&mut self, rhs: Self) {
          self.value *= rhs.value;
      }
  *)
  Definition mul_assign (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ self; rhs ] =>
      ltac:(M.monadic
        (let self := M.alloc (| self |) in
        let rhs := M.alloc (| rhs |) in
        M.read (|
          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
            M.alloc (|
              M.call_closure (|
                Ty.tuple [],
                M.get_trait_method (|
                  "core::ops::arith::MulAssign",
                  Ty.path "halo2curves::bn256::fr::Fr",
                  [],
                  [ Ty.path "halo2curves::bn256::fr::Fr" ],
                  "mul_assign",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.MutRef,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "p3_bn254_fr::Bn254Fr",
                      "value"
                    |)
                  |);
                  M.read (|
                    M.SubPointer.get_struct_record_field (| rhs, "p3_bn254_fr::Bn254Fr", "value" |)
                  |)
                ]
              |)
            |) in
          M.alloc (| Value.Tuple [] |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::ops::arith::MulAssign"
      (* Trait polymorphic consts *) []
      (* Trait polymorphic types *) [ Ty.path "p3_bn254_fr::Bn254Fr" ]
      Self
      (* Instance *) [ ("mul_assign", InstanceField.Method mul_assign) ].
End Impl_core_ops_arith_MulAssign_p3_bn254_fr_Bn254Fr_for_p3_bn254_fr_Bn254Fr.

Module Impl_core_iter_traits_accum_Product_p3_bn254_fr_Bn254Fr_for_p3_bn254_fr_Bn254Fr.
  Definition Self : Ty.t := Ty.path "p3_bn254_fr::Bn254Fr".
  
  (*
      fn product<I: Iterator<Item = Self>>(iter: I) -> Self {
          iter.reduce(|x, y| x * y).unwrap_or(Self::ONE)
      }
  *)
  Definition product (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ _ as I ], [ iter ] =>
      ltac:(M.monadic
        (let iter := M.alloc (| iter |) in
        M.call_closure (|
          Ty.path "p3_bn254_fr::Bn254Fr",
          M.get_associated_function (|
            Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "p3_bn254_fr::Bn254Fr" ],
            "unwrap_or",
            [],
            []
          |),
          [
            M.call_closure (|
              Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "p3_bn254_fr::Bn254Fr" ],
              M.get_trait_method (|
                "core::iter::traits::iterator::Iterator",
                I,
                [],
                [],
                "reduce",
                [],
                [
                  Ty.function
                    [ Ty.tuple [ Ty.path "p3_bn254_fr::Bn254Fr"; Ty.path "p3_bn254_fr::Bn254Fr" ] ]
                    (Ty.path "p3_bn254_fr::Bn254Fr")
                ]
              |),
              [
                M.read (| iter |);
                M.closure
                  (fun γ =>
                    ltac:(M.monadic
                      match γ with
                      | [ α0; α1 ] =>
                        ltac:(M.monadic
                          (M.match_operator (|
                            Ty.apply
                              (Ty.path "*")
                              []
                              [
                                Ty.function
                                  [
                                    Ty.tuple
                                      [
                                        Ty.path "p3_bn254_fr::Bn254Fr";
                                        Ty.path "p3_bn254_fr::Bn254Fr"
                                      ]
                                  ]
                                  (Ty.path "p3_bn254_fr::Bn254Fr")
                              ],
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let x := M.copy (| γ |) in
                                  M.match_operator (|
                                    Ty.apply
                                      (Ty.path "*")
                                      []
                                      [
                                        Ty.function
                                          [
                                            Ty.tuple
                                              [
                                                Ty.path "p3_bn254_fr::Bn254Fr";
                                                Ty.path "p3_bn254_fr::Bn254Fr"
                                              ]
                                          ]
                                          (Ty.path "p3_bn254_fr::Bn254Fr")
                                      ],
                                    M.alloc (| α1 |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let y := M.copy (| γ |) in
                                          M.call_closure (|
                                            Ty.path "p3_bn254_fr::Bn254Fr",
                                            M.get_trait_method (|
                                              "core::ops::arith::Mul",
                                              Ty.path "p3_bn254_fr::Bn254Fr",
                                              [],
                                              [ Ty.path "p3_bn254_fr::Bn254Fr" ],
                                              "mul",
                                              [],
                                              []
                                            |),
                                            [ M.read (| x |); M.read (| y |) ]
                                          |)))
                                    ]
                                  |)))
                            ]
                          |)))
                      | _ => M.impossible "wrong number of arguments"
                      end))
              ]
            |);
            M.read (|
              get_constant (|
                "p3_field::field::PrimeCharacteristicRing::ONE",
                Ty.path "p3_bn254_fr::Bn254Fr"
              |)
            |)
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::iter::traits::accum::Product"
      (* Trait polymorphic consts *) []
      (* Trait polymorphic types *) [ Ty.path "p3_bn254_fr::Bn254Fr" ]
      Self
      (* Instance *) [ ("product", InstanceField.Method product) ].
End Impl_core_iter_traits_accum_Product_p3_bn254_fr_Bn254Fr_for_p3_bn254_fr_Bn254Fr.

Module Impl_core_ops_arith_Div_p3_bn254_fr_Bn254Fr_for_p3_bn254_fr_Bn254Fr.
  Definition Self : Ty.t := Ty.path "p3_bn254_fr::Bn254Fr".
  
  (*     type Output = Self; *)
  Definition _Output : Ty.t := Ty.path "p3_bn254_fr::Bn254Fr".
  
  (*
      fn div(self, rhs: Self) -> Self {
          self * rhs.inverse()
      }
  *)
  Definition div (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ self; rhs ] =>
      ltac:(M.monadic
        (let self := M.alloc (| self |) in
        let rhs := M.alloc (| rhs |) in
        M.call_closure (|
          Ty.path "p3_bn254_fr::Bn254Fr",
          M.get_trait_method (|
            "core::ops::arith::Mul",
            Ty.path "p3_bn254_fr::Bn254Fr",
            [],
            [ Ty.path "p3_bn254_fr::Bn254Fr" ],
            "mul",
            [],
            []
          |),
          [
            M.read (| self |);
            M.call_closure (|
              Ty.path "p3_bn254_fr::Bn254Fr",
              M.get_trait_method (|
                "p3_field::field::Field",
                Ty.path "p3_bn254_fr::Bn254Fr",
                [],
                [],
                "inverse",
                [],
                []
              |),
              [ M.borrow (| Pointer.Kind.Ref, rhs |) ]
            |)
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "core::ops::arith::Div"
      (* Trait polymorphic consts *) []
      (* Trait polymorphic types *) [ Ty.path "p3_bn254_fr::Bn254Fr" ]
      Self
      (* Instance *) [ ("Output", InstanceField.Ty _Output); ("div", InstanceField.Method div) ].
End Impl_core_ops_arith_Div_p3_bn254_fr_Bn254Fr_for_p3_bn254_fr_Bn254Fr.

Module Impl_rand_distr_distribution_Distribution_p3_bn254_fr_Bn254Fr_for_rand_distr_StandardUniform.
  Definition Self : Ty.t := Ty.path "rand::distr::StandardUniform".
  
  (*
      fn sample<R: Rng + ?Sized>(&self, rng: &mut R) -> Bn254Fr {
          // Simple implementation of rejection sampling:
          loop {
              let mut trial_element: [u8; 32] = rng.random();
  
              // Set top 2 bits to 0 as bn254 is a 254-bit field.
              // `from_bytes` expects little endian input, so we adjust byte 31:
              trial_element[31] &= (1_u8 << 6) - 1;
  
              let x = FFBn254Fr::from_bytes(&trial_element);
              if x.is_some().into() {
                  // x.unwrap() is safe because x.is_some() is true
                  return Bn254Fr::new(x.unwrap());
              }
          }
      }
  *)
  Definition sample (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ R ], [ self; rng ] =>
      ltac:(M.monadic
        (let self := M.alloc (| self |) in
        let rng := M.alloc (| rng |) in
        M.catch_return (Ty.path "p3_bn254_fr::Bn254Fr") (|
          ltac:(M.monadic
            (M.never_to_any (|
              M.read (|
                M.loop (|
                  Ty.apply (Ty.path "*") [] [ Ty.path "never" ],
                  ltac:(M.monadic
                    (let~ trial_element :
                        Ty.apply
                          (Ty.path "*")
                          []
                          [
                            Ty.apply
                              (Ty.path "array")
                              [ Value.Integer IntegerKind.Usize 32 ]
                              [ Ty.path "u8" ]
                          ] :=
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "array")
                            [ Value.Integer IntegerKind.Usize 32 ]
                            [ Ty.path "u8" ],
                          M.get_trait_method (|
                            "rand::rng::Rng",
                            R,
                            [],
                            [],
                            "random",
                            [],
                            [
                              Ty.apply
                                (Ty.path "array")
                                [ Value.Integer IntegerKind.Usize 32 ]
                                [ Ty.path "u8" ]
                            ]
                          |),
                          [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| rng |) |) |) ]
                        |)
                      |) in
                    let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                      M.alloc (|
                        let β :=
                          M.SubPointer.get_array_field (|
                            trial_element,
                            Value.Integer IntegerKind.Usize 31
                          |) in
                        M.write (|
                          β,
                          M.call_closure (|
                            Ty.path "u8",
                            BinOp.Wrap.bit_and,
                            [
                              M.read (| β |);
                              M.call_closure (|
                                Ty.path "u8",
                                BinOp.Wrap.sub,
                                [
                                  M.call_closure (|
                                    Ty.path "u8",
                                    BinOp.Wrap.shl,
                                    [
                                      Value.Integer IntegerKind.U8 1;
                                      Value.Integer IntegerKind.I32 6
                                    ]
                                  |);
                                  Value.Integer IntegerKind.U8 1
                                ]
                              |)
                            ]
                          |)
                        |)
                      |) in
                    let~ x :
                        Ty.apply
                          (Ty.path "*")
                          []
                          [
                            Ty.apply
                              (Ty.path "subtle::CtOption")
                              []
                              [ Ty.path "halo2curves::bn256::fr::Fr" ]
                          ] :=
                      M.alloc (|
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "subtle::CtOption")
                            []
                            [ Ty.path "halo2curves::bn256::fr::Fr" ],
                          M.get_associated_function (|
                            Ty.path "halo2curves::bn256::fr::Fr",
                            "from_bytes",
                            [],
                            []
                          |),
                          [
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.deref (| M.borrow (| Pointer.Kind.Ref, trial_element |) |)
                            |)
                          ]
                        |)
                      |) in
                    M.match_operator (|
                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    Ty.path "bool",
                                    M.get_trait_method (|
                                      "core::convert::Into",
                                      Ty.path "subtle::Choice",
                                      [],
                                      [ Ty.path "bool" ],
                                      "into",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.path "subtle::Choice",
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "subtle::CtOption")
                                            []
                                            [ Ty.path "halo2curves::bn256::fr::Fr" ],
                                          "is_some",
                                          [],
                                          []
                                        |),
                                        [ M.borrow (| Pointer.Kind.Ref, x |) ]
                                      |)
                                    ]
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  M.return_ (|
                                    M.call_closure (|
                                      Ty.path "p3_bn254_fr::Bn254Fr",
                                      M.get_associated_function (|
                                        Ty.path "p3_bn254_fr::Bn254Fr",
                                        "new",
                                        [],
                                        []
                                      |),
                                      [
                                        M.call_closure (|
                                          Ty.path "halo2curves::bn256::fr::Fr",
                                          M.get_associated_function (|
                                            Ty.apply
                                              (Ty.path "subtle::CtOption")
                                              []
                                              [ Ty.path "halo2curves::bn256::fr::Fr" ],
                                            "unwrap",
                                            [],
                                            []
                                          |),
                                          [ M.read (| x |) ]
                                        |)
                                      ]
                                    |)
                                  |)
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |)))
                |)
              |)
            |)))
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "rand::distr::distribution::Distribution"
      (* Trait polymorphic consts *) []
      (* Trait polymorphic types *) [ Ty.path "p3_bn254_fr::Bn254Fr" ]
      Self
      (* Instance *) [ ("sample", InstanceField.Method sample) ].
End Impl_rand_distr_distribution_Distribution_p3_bn254_fr_Bn254Fr_for_rand_distr_StandardUniform.

Module Impl_p3_field_field_TwoAdicField_for_p3_bn254_fr_Bn254Fr.
  Definition Self : Ty.t := Ty.path "p3_bn254_fr::Bn254Fr".
  
  (*     const TWO_ADICITY: usize = FFBn254Fr::S as usize; *)
  (* Ty.path "usize" *)
  Definition value_TWO_ADICITY (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    ltac:(M.monadic
      (M.alloc (|
        M.cast
          (Ty.path "usize")
          (M.read (| get_constant (| "ff::PrimeField::S", Ty.path "u32" |) |))
      |))).
  
  (*
      fn two_adic_generator(bits: usize) -> Self {
          let mut omega = FFBn254Fr::ROOT_OF_UNITY;
          for _ in bits..Self::TWO_ADICITY {
              omega = omega.square();
          }
          Self::new(omega)
      }
  *)
  Definition two_adic_generator (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ bits ] =>
      ltac:(M.monadic
        (let bits := M.alloc (| bits |) in
        M.read (|
          let~ omega : Ty.apply (Ty.path "*") [] [ Ty.path "halo2curves::bn256::fr::Fr" ] :=
            M.copy (|
              get_constant (|
                "ff::PrimeField::ROOT_OF_UNITY",
                Ty.path "halo2curves::bn256::fr::Fr"
              |)
            |) in
          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
            M.use
              (M.match_operator (|
                Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                M.alloc (|
                  M.call_closure (|
                    Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                    M.get_trait_method (|
                      "core::iter::traits::collect::IntoIterator",
                      Ty.apply (Ty.path "core::ops::range::Range") [] [ Ty.path "usize" ],
                      [],
                      [],
                      "into_iter",
                      [],
                      []
                    |),
                    [
                      Value.StructRecord
                        "core::ops::range::Range"
                        [
                          ("start", M.read (| bits |));
                          ("end_",
                            M.read (|
                              get_constant (|
                                "p3_field::field::TwoAdicField::TWO_ADICITY",
                                Ty.path "usize"
                              |)
                            |))
                        ]
                    ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let iter := M.copy (| γ |) in
                      M.loop (|
                        Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                        ltac:(M.monadic
                          (let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                            M.match_operator (|
                              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                              M.alloc (|
                                M.call_closure (|
                                  Ty.apply (Ty.path "core::option::Option") [] [ Ty.path "usize" ],
                                  M.get_trait_method (|
                                    "core::iter::traits::iterator::Iterator",
                                    Ty.apply
                                      (Ty.path "core::ops::range::Range")
                                      []
                                      [ Ty.path "usize" ],
                                    [],
                                    [],
                                    "next",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.MutRef,
                                      M.deref (| M.borrow (| Pointer.Kind.MutRef, iter |) |)
                                    |)
                                  ]
                                |)
                              |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let _ :=
                                      M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                                    M.alloc (| M.never_to_any (| M.read (| M.break (||) |) |) |)));
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ0_0 :=
                                      M.SubPointer.get_struct_tuple_field (|
                                        γ,
                                        "core::option::Option::Some",
                                        0
                                      |) in
                                    let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                      M.alloc (|
                                        M.write (|
                                          omega,
                                          M.call_closure (|
                                            Ty.path "halo2curves::bn256::fr::Fr",
                                            M.get_associated_function (|
                                              Ty.path "halo2curves::bn256::fr::Fr",
                                              "square",
                                              [],
                                              []
                                            |),
                                            [ M.borrow (| Pointer.Kind.Ref, omega |) ]
                                          |)
                                        |)
                                      |) in
                                    M.alloc (| Value.Tuple [] |)))
                              ]
                            |) in
                          M.alloc (| Value.Tuple [] |)))
                      |)))
                ]
              |)) in
          M.alloc (|
            M.call_closure (|
              Ty.path "p3_bn254_fr::Bn254Fr",
              M.get_associated_function (| Ty.path "p3_bn254_fr::Bn254Fr", "new", [], [] |),
              [ M.read (| omega |) ]
            |)
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Axiom Implements :
    M.IsTraitInstance
      "p3_field::field::TwoAdicField"
      (* Trait polymorphic consts *) []
      (* Trait polymorphic types *) []
      Self
      (* Instance *)
      [
        ("value_TWO_ADICITY", InstanceField.Method value_TWO_ADICITY);
        ("two_adic_generator", InstanceField.Method two_adic_generator)
      ].
End Impl_p3_field_field_TwoAdicField_for_p3_bn254_fr_Bn254Fr.
