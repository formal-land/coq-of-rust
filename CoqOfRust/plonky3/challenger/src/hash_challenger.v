(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module hash_challenger.
  (* StructRecord
    {
      name := "HashChallenger";
      const_params := [ "OUT_LEN" ];
      ty_params := [ "T"; "H" ];
      fields :=
        [
          ("input_buffer",
            Ty.apply (Ty.path "alloc::vec::Vec") [] [ T; Ty.path "alloc::alloc::Global" ]);
          ("output_buffer",
            Ty.apply (Ty.path "alloc::vec::Vec") [] [ T; Ty.path "alloc::alloc::Global" ]);
          ("hasher", H)
        ];
    } *)
  
  Module Impl_core_clone_Clone_where_core_clone_Clone_T_where_core_clone_Clone_H_where_core_clone_Clone_T_where_p3_symmetric_hasher_CryptographicHasher_H_T_array_OUT_LEN_T_for_p3_challenger_hash_challenger_HashChallenger_OUT_LEN_T_H.
    Definition Self (OUT_LEN : Value.t) (T H : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "p3_challenger::hash_challenger::HashChallenger") [ OUT_LEN ] [ T; H ].
    
    (* Clone *)
    Definition clone
        (OUT_LEN : Value.t)
        (T H : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self OUT_LEN T H in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.StructRecord
            "p3_challenger::hash_challenger::HashChallenger"
            [
              ("input_buffer",
                M.call_closure (|
                  Ty.apply (Ty.path "alloc::vec::Vec") [] [ T; Ty.path "alloc::alloc::Global" ],
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.apply (Ty.path "alloc::vec::Vec") [] [ T; Ty.path "alloc::alloc::Global" ],
                    [],
                    [],
                    "clone",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "p3_challenger::hash_challenger::HashChallenger",
                            "input_buffer"
                          |)
                        |)
                      |)
                    |)
                  ]
                |));
              ("output_buffer",
                M.call_closure (|
                  Ty.apply (Ty.path "alloc::vec::Vec") [] [ T; Ty.path "alloc::alloc::Global" ],
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.apply (Ty.path "alloc::vec::Vec") [] [ T; Ty.path "alloc::alloc::Global" ],
                    [],
                    [],
                    "clone",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "p3_challenger::hash_challenger::HashChallenger",
                            "output_buffer"
                          |)
                        |)
                      |)
                    |)
                  ]
                |));
              ("hasher",
                M.call_closure (|
                  H,
                  M.get_trait_method (| "core::clone::Clone", H, [], [], "clone", [], [] |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "p3_challenger::hash_challenger::HashChallenger",
                            "hasher"
                          |)
                        |)
                      |)
                    |)
                  ]
                |))
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (OUT_LEN : Value.t) (T H : Ty.t),
      M.IsTraitInstance
        "core::clone::Clone"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self OUT_LEN T H)
        (* Instance *) [ ("clone", InstanceField.Method (clone OUT_LEN T H)) ].
  End Impl_core_clone_Clone_where_core_clone_Clone_T_where_core_clone_Clone_H_where_core_clone_Clone_T_where_p3_symmetric_hasher_CryptographicHasher_H_T_array_OUT_LEN_T_for_p3_challenger_hash_challenger_HashChallenger_OUT_LEN_T_H.
  
  Module Impl_core_fmt_Debug_where_core_fmt_Debug_T_where_core_fmt_Debug_H_where_core_clone_Clone_T_where_p3_symmetric_hasher_CryptographicHasher_H_T_array_OUT_LEN_T_for_p3_challenger_hash_challenger_HashChallenger_OUT_LEN_T_H.
    Definition Self (OUT_LEN : Value.t) (T H : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "p3_challenger::hash_challenger::HashChallenger") [ OUT_LEN ] [ T; H ].
    
    (* Debug *)
    Definition fmt
        (OUT_LEN : Value.t)
        (T H : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self OUT_LEN T H in
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_associated_function (|
              Ty.path "core::fmt::Formatter",
              "debug_struct_field3_finish",
              [],
              []
            |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "HashChallenger" |) |) |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "input_buffer" |) |) |);
              (* Unsize *)
              M.pointer_coercion
                (M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "p3_challenger::hash_challenger::HashChallenger",
                        "input_buffer"
                      |)
                    |)
                  |)
                |));
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "output_buffer" |) |) |);
              (* Unsize *)
              M.pointer_coercion
                (M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "p3_challenger::hash_challenger::HashChallenger",
                        "output_buffer"
                      |)
                    |)
                  |)
                |));
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "hasher" |) |) |);
              (* Unsize *)
              M.pointer_coercion
                (M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.alloc (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "p3_challenger::hash_challenger::HashChallenger",
                            "hasher"
                          |)
                        |)
                      |)
                    |)
                  |)
                |))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (OUT_LEN : Value.t) (T H : Ty.t),
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self OUT_LEN T H)
        (* Instance *) [ ("fmt", InstanceField.Method (fmt OUT_LEN T H)) ].
  End Impl_core_fmt_Debug_where_core_fmt_Debug_T_where_core_fmt_Debug_H_where_core_clone_Clone_T_where_p3_symmetric_hasher_CryptographicHasher_H_T_array_OUT_LEN_T_for_p3_challenger_hash_challenger_HashChallenger_OUT_LEN_T_H.
  
  Module Impl_p3_challenger_hash_challenger_HashChallenger_OUT_LEN_T_H.
    Definition Self (OUT_LEN : Value.t) (T H : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "p3_challenger::hash_challenger::HashChallenger") [ OUT_LEN ] [ T; H ].
    
    (*
        pub const fn new(initial_state: Vec<T>, hasher: H) -> Self {
            Self {
                input_buffer: initial_state,
                output_buffer: vec![],
                hasher,
            }
        }
    *)
    Definition new
        (OUT_LEN : Value.t)
        (T H : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self OUT_LEN T H in
      match ε, τ, α with
      | [], [], [ initial_state; hasher ] =>
        ltac:(M.monadic
          (let initial_state := M.alloc (| initial_state |) in
          let hasher := M.alloc (| hasher |) in
          Value.StructRecord
            "p3_challenger::hash_challenger::HashChallenger"
            [
              ("input_buffer", M.read (| initial_state |));
              ("output_buffer",
                M.call_closure (|
                  Ty.apply (Ty.path "alloc::vec::Vec") [] [ T; Ty.path "alloc::alloc::Global" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloc::vec::Vec") [] [ T; Ty.path "alloc::alloc::Global" ],
                    "new",
                    [],
                    []
                  |),
                  []
                |));
              ("hasher", M.read (| hasher |))
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_new :
      forall (OUT_LEN : Value.t) (T H : Ty.t),
      M.IsAssociatedFunction.C (Self OUT_LEN T H) "new" (new OUT_LEN T H).
    Admitted.
    Global Typeclasses Opaque new.
    
    (*
        fn flush(&mut self) {
            let inputs = self.input_buffer.drain(..);
            let output = self.hasher.hash_iter(inputs);
    
            self.output_buffer = output.to_vec();
    
            // Chaining values.
            self.input_buffer.extend(output.to_vec());
        }
    *)
    Definition flush
        (OUT_LEN : Value.t)
        (T H : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self OUT_LEN T H in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let~ inputs :
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "alloc::vec::drain::Drain")
                      []
                      [ T; Ty.path "alloc::alloc::Global" ]
                  ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloc::vec::drain::Drain")
                    []
                    [ T; Ty.path "alloc::alloc::Global" ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloc::vec::Vec") [] [ T; Ty.path "alloc::alloc::Global" ],
                    "drain",
                    [],
                    [ Ty.path "core::ops::range::RangeFull" ]
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "p3_challenger::hash_challenger::HashChallenger",
                        "input_buffer"
                      |)
                    |);
                    Value.StructTuple "core::ops::range::RangeFull" []
                  ]
                |)
              |) in
            let~ output :
                Ty.apply (Ty.path "*") [] [ Ty.apply (Ty.path "array") [ OUT_LEN ] [ T ] ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.apply (Ty.path "array") [ OUT_LEN ] [ T ],
                  M.get_trait_method (|
                    "p3_symmetric::hasher::CryptographicHasher",
                    H,
                    [],
                    [ T; Ty.apply (Ty.path "array") [ OUT_LEN ] [ T ] ],
                    "hash_iter",
                    [],
                    [
                      Ty.apply
                        (Ty.path "alloc::vec::drain::Drain")
                        []
                        [ T; Ty.path "alloc::alloc::Global" ]
                    ]
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "p3_challenger::hash_challenger::HashChallenger",
                        "hasher"
                      |)
                    |);
                    M.read (| inputs |)
                  ]
                |)
              |) in
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.alloc (|
                M.write (|
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "p3_challenger::hash_challenger::HashChallenger",
                    "output_buffer"
                  |),
                  M.call_closure (|
                    Ty.apply (Ty.path "alloc::vec::Vec") [] [ T; Ty.path "alloc::alloc::Global" ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "slice") [] [ T ],
                      "to_vec",
                      [],
                      []
                    |),
                    [ (* Unsize *) M.pointer_coercion (M.borrow (| Pointer.Kind.Ref, output |)) ]
                  |)
                |)
              |) in
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "core::iter::traits::collect::Extend",
                    Ty.apply (Ty.path "alloc::vec::Vec") [] [ T; Ty.path "alloc::alloc::Global" ],
                    [],
                    [ T ],
                    "extend",
                    [],
                    [ Ty.apply (Ty.path "alloc::vec::Vec") [] [ T; Ty.path "alloc::alloc::Global" ]
                    ]
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "p3_challenger::hash_challenger::HashChallenger",
                        "input_buffer"
                      |)
                    |);
                    M.call_closure (|
                      Ty.apply (Ty.path "alloc::vec::Vec") [] [ T; Ty.path "alloc::alloc::Global" ],
                      M.get_associated_function (|
                        Ty.apply (Ty.path "slice") [] [ T ],
                        "to_vec",
                        [],
                        []
                      |),
                      [ (* Unsize *) M.pointer_coercion (M.borrow (| Pointer.Kind.Ref, output |)) ]
                    |)
                  ]
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_flush :
      forall (OUT_LEN : Value.t) (T H : Ty.t),
      M.IsAssociatedFunction.C (Self OUT_LEN T H) "flush" (flush OUT_LEN T H).
    Admitted.
    Global Typeclasses Opaque flush.
  End Impl_p3_challenger_hash_challenger_HashChallenger_OUT_LEN_T_H.
  
  Module Impl_p3_challenger_CanObserve_where_core_clone_Clone_T_where_p3_symmetric_hasher_CryptographicHasher_H_T_array_OUT_LEN_T_T_for_p3_challenger_hash_challenger_HashChallenger_OUT_LEN_T_H.
    Definition Self (OUT_LEN : Value.t) (T H : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "p3_challenger::hash_challenger::HashChallenger") [ OUT_LEN ] [ T; H ].
    
    (*
        fn observe(&mut self, value: T) {
            // Any buffered output is now invalid.
            self.output_buffer.clear();
    
            self.input_buffer.push(value);
        }
    *)
    Definition observe
        (OUT_LEN : Value.t)
        (T H : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self OUT_LEN T H in
      match ε, τ, α with
      | [], [], [ self; value ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let value := M.alloc (| value |) in
          M.read (|
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloc::vec::Vec") [] [ T; Ty.path "alloc::alloc::Global" ],
                    "clear",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "p3_challenger::hash_challenger::HashChallenger",
                        "output_buffer"
                      |)
                    |)
                  ]
                |)
              |) in
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "alloc::vec::Vec") [] [ T; Ty.path "alloc::alloc::Global" ],
                    "push",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.MutRef,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "p3_challenger::hash_challenger::HashChallenger",
                        "input_buffer"
                      |)
                    |);
                    M.read (| value |)
                  ]
                |)
              |) in
            M.alloc (| Value.Tuple [] |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (OUT_LEN : Value.t) (T H : Ty.t),
      M.IsTraitInstance
        "p3_challenger::CanObserve"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ T ]
        (Self OUT_LEN T H)
        (* Instance *) [ ("observe", InstanceField.Method (observe OUT_LEN T H)) ].
  End Impl_p3_challenger_CanObserve_where_core_clone_Clone_T_where_p3_symmetric_hasher_CryptographicHasher_H_T_array_OUT_LEN_T_T_for_p3_challenger_hash_challenger_HashChallenger_OUT_LEN_T_H.
  
  Module Impl_p3_challenger_CanObserve_where_core_clone_Clone_T_where_p3_symmetric_hasher_CryptographicHasher_H_T_array_OUT_LEN_T_array_N_T_for_p3_challenger_hash_challenger_HashChallenger_OUT_LEN_T_H.
    Definition Self (N OUT_LEN : Value.t) (T H : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "p3_challenger::hash_challenger::HashChallenger") [ OUT_LEN ] [ T; H ].
    
    (*
        fn observe(&mut self, values: [T; N]) {
            for value in values {
                self.observe(value);
            }
        }
    *)
    Definition observe
        (N OUT_LEN : Value.t)
        (T H : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self N OUT_LEN T H in
      match ε, τ, α with
      | [], [], [ self; values ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let values := M.alloc (| values |) in
          M.read (|
            M.use
              (M.match_operator (|
                Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                M.alloc (|
                  M.call_closure (|
                    Ty.apply (Ty.path "core::array::iter::IntoIter") [ N ] [ T ],
                    M.get_trait_method (|
                      "core::iter::traits::collect::IntoIterator",
                      Ty.apply (Ty.path "array") [ N ] [ T ],
                      [],
                      [],
                      "into_iter",
                      [],
                      []
                    |),
                    [ M.read (| values |) ]
                  |)
                |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let iter := M.copy (| γ |) in
                      M.loop (|
                        Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                        ltac:(M.monadic
                          (let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                            M.match_operator (|
                              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                              M.alloc (|
                                M.call_closure (|
                                  Ty.apply (Ty.path "core::option::Option") [] [ T ],
                                  M.get_trait_method (|
                                    "core::iter::traits::iterator::Iterator",
                                    Ty.apply (Ty.path "core::array::iter::IntoIter") [ N ] [ T ],
                                    [],
                                    [],
                                    "next",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.MutRef,
                                      M.deref (| M.borrow (| Pointer.Kind.MutRef, iter |) |)
                                    |)
                                  ]
                                |)
                              |),
                              [
                                fun γ =>
                                  ltac:(M.monadic
                                    (let _ :=
                                      M.is_struct_tuple (| γ, "core::option::Option::None" |) in
                                    M.alloc (| M.never_to_any (| M.read (| M.break (||) |) |) |)));
                                fun γ =>
                                  ltac:(M.monadic
                                    (let γ0_0 :=
                                      M.SubPointer.get_struct_tuple_field (|
                                        γ,
                                        "core::option::Option::Some",
                                        0
                                      |) in
                                    let value := M.copy (| γ0_0 |) in
                                    let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                      M.alloc (|
                                        M.call_closure (|
                                          Ty.tuple [],
                                          M.get_trait_method (|
                                            "p3_challenger::CanObserve",
                                            Ty.apply
                                              (Ty.path
                                                "p3_challenger::hash_challenger::HashChallenger")
                                              [ OUT_LEN ]
                                              [ T; H ],
                                            [],
                                            [ T ],
                                            "observe",
                                            [],
                                            []
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.MutRef,
                                              M.deref (| M.read (| self |) |)
                                            |);
                                            M.read (| value |)
                                          ]
                                        |)
                                      |) in
                                    M.alloc (| Value.Tuple [] |)))
                              ]
                            |) in
                          M.alloc (| Value.Tuple [] |)))
                      |)))
                ]
              |))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (N OUT_LEN : Value.t) (T H : Ty.t),
      M.IsTraitInstance
        "p3_challenger::CanObserve"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ Ty.apply (Ty.path "array") [ N ] [ T ] ]
        (Self N OUT_LEN T H)
        (* Instance *) [ ("observe", InstanceField.Method (observe N OUT_LEN T H)) ].
  End Impl_p3_challenger_CanObserve_where_core_clone_Clone_T_where_p3_symmetric_hasher_CryptographicHasher_H_T_array_OUT_LEN_T_array_N_T_for_p3_challenger_hash_challenger_HashChallenger_OUT_LEN_T_H.
  
  Module Impl_p3_challenger_CanSample_where_core_clone_Clone_T_where_p3_symmetric_hasher_CryptographicHasher_H_T_array_OUT_LEN_T_T_for_p3_challenger_hash_challenger_HashChallenger_OUT_LEN_T_H.
    Definition Self (OUT_LEN : Value.t) (T H : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "p3_challenger::hash_challenger::HashChallenger") [ OUT_LEN ] [ T; H ].
    
    (*
        fn sample(&mut self) -> T {
            if self.output_buffer.is_empty() {
                self.flush();
            }
            self.output_buffer
                .pop()
                .expect("Output buffer should be non-empty")
        }
    *)
    Definition sample
        (OUT_LEN : Value.t)
        (T H : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self OUT_LEN T H in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.match_operator (|
                Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            M.call_closure (|
                              Ty.path "bool",
                              M.get_associated_function (|
                                Ty.apply
                                  (Ty.path "alloc::vec::Vec")
                                  []
                                  [ T; Ty.path "alloc::alloc::Global" ],
                                "is_empty",
                                [],
                                []
                              |),
                              [
                                M.borrow (|
                                  Pointer.Kind.Ref,
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "p3_challenger::hash_challenger::HashChallenger",
                                    "output_buffer"
                                  |)
                                |)
                              ]
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                        M.alloc (|
                          M.call_closure (|
                            Ty.tuple [],
                            M.get_associated_function (|
                              Ty.apply
                                (Ty.path "p3_challenger::hash_challenger::HashChallenger")
                                [ OUT_LEN ]
                                [ T; H ],
                              "flush",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| self |) |) |) ]
                          |)
                        |) in
                      M.alloc (| Value.Tuple [] |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            M.alloc (|
              M.call_closure (|
                T,
                M.get_associated_function (|
                  Ty.apply (Ty.path "core::option::Option") [] [ T ],
                  "expect",
                  [],
                  []
                |),
                [
                  M.call_closure (|
                    Ty.apply (Ty.path "core::option::Option") [] [ T ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "alloc::vec::Vec") [] [ T; Ty.path "alloc::alloc::Global" ],
                      "pop",
                      [],
                      []
                    |),
                    [
                      M.borrow (|
                        Pointer.Kind.MutRef,
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "p3_challenger::hash_challenger::HashChallenger",
                          "output_buffer"
                        |)
                      |)
                    ]
                  |);
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.deref (| mk_str (| "Output buffer should be non-empty" |) |)
                  |)
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (OUT_LEN : Value.t) (T H : Ty.t),
      M.IsTraitInstance
        "p3_challenger::CanSample"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ T ]
        (Self OUT_LEN T H)
        (* Instance *) [ ("sample", InstanceField.Method (sample OUT_LEN T H)) ].
  End Impl_p3_challenger_CanSample_where_core_clone_Clone_T_where_p3_symmetric_hasher_CryptographicHasher_H_T_array_OUT_LEN_T_T_for_p3_challenger_hash_challenger_HashChallenger_OUT_LEN_T_H.
End hash_challenger.
