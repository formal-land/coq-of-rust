(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module domain.
  (* StructRecord
    {
      name := "CircleDomain";
      const_params := [];
      ty_params := [ "F" ];
      fields :=
        [
          ("log_n", Ty.path "usize");
          ("shift", Ty.apply (Ty.path "p3_circle::point::Point") [] [ F ])
        ];
    } *)
  
  Module Impl_core_marker_Copy_where_core_marker_Copy_F_for_p3_circle_domain_CircleDomain_F.
    Definition Self (F : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "p3_circle::domain::CircleDomain") [] [ F ].
    
    Axiom Implements :
      forall (F : Ty.t),
      M.IsTraitInstance
        "core::marker::Copy"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self F)
        (* Instance *) [].
  End Impl_core_marker_Copy_where_core_marker_Copy_F_for_p3_circle_domain_CircleDomain_F.
  
  Module Impl_core_clone_Clone_where_core_clone_Clone_F_for_p3_circle_domain_CircleDomain_F.
    Definition Self (F : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "p3_circle::domain::CircleDomain") [] [ F ].
    
    (* Clone *)
    Definition clone (F : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self F in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.StructRecord
            "p3_circle::domain::CircleDomain"
            [
              ("log_n",
                M.call_closure (|
                  Ty.path "usize",
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.path "usize",
                    [],
                    [],
                    "clone",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "p3_circle::domain::CircleDomain",
                            "log_n"
                          |)
                        |)
                      |)
                    |)
                  ]
                |));
              ("shift",
                M.call_closure (|
                  Ty.apply (Ty.path "p3_circle::point::Point") [] [ F ],
                  M.get_trait_method (|
                    "core::clone::Clone",
                    Ty.apply (Ty.path "p3_circle::point::Point") [] [ F ],
                    [],
                    [],
                    "clone",
                    [],
                    []
                  |),
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.deref (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "p3_circle::domain::CircleDomain",
                            "shift"
                          |)
                        |)
                      |)
                    |)
                  ]
                |))
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (F : Ty.t),
      M.IsTraitInstance
        "core::clone::Clone"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self F)
        (* Instance *) [ ("clone", InstanceField.Method (clone F)) ].
  End Impl_core_clone_Clone_where_core_clone_Clone_F_for_p3_circle_domain_CircleDomain_F.
  
  Module Impl_core_marker_StructuralPartialEq_for_p3_circle_domain_CircleDomain_F.
    Definition Self (F : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "p3_circle::domain::CircleDomain") [] [ F ].
    
    Axiom Implements :
      forall (F : Ty.t),
      M.IsTraitInstance
        "core::marker::StructuralPartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self F)
        (* Instance *) [].
  End Impl_core_marker_StructuralPartialEq_for_p3_circle_domain_CircleDomain_F.
  
  Module Impl_core_cmp_PartialEq_where_core_cmp_PartialEq_F_p3_circle_domain_CircleDomain_F_for_p3_circle_domain_CircleDomain_F.
    Definition Self (F : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "p3_circle::domain::CircleDomain") [] [ F ].
    
    (* PartialEq *)
    Definition eq (F : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self F in
      match ε, τ, α with
      | [], [], [ self; other ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let other := M.alloc (| other |) in
          LogicalOp.and (|
            M.call_closure (|
              Ty.path "bool",
              BinOp.eq,
              [
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| self |) |),
                    "p3_circle::domain::CircleDomain",
                    "log_n"
                  |)
                |);
                M.read (|
                  M.SubPointer.get_struct_record_field (|
                    M.deref (| M.read (| other |) |),
                    "p3_circle::domain::CircleDomain",
                    "log_n"
                  |)
                |)
              ]
            |),
            ltac:(M.monadic
              (M.call_closure (|
                Ty.path "bool",
                M.get_trait_method (|
                  "core::cmp::PartialEq",
                  Ty.apply (Ty.path "p3_circle::point::Point") [] [ F ],
                  [],
                  [ Ty.apply (Ty.path "p3_circle::point::Point") [] [ F ] ],
                  "eq",
                  [],
                  []
                |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "p3_circle::domain::CircleDomain",
                      "shift"
                    |)
                  |);
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| other |) |),
                      "p3_circle::domain::CircleDomain",
                      "shift"
                    |)
                  |)
                ]
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (F : Ty.t),
      M.IsTraitInstance
        "core::cmp::PartialEq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *)
        [ Ty.apply (Ty.path "p3_circle::domain::CircleDomain") [] [ F ] ]
        (Self F)
        (* Instance *) [ ("eq", InstanceField.Method (eq F)) ].
  End Impl_core_cmp_PartialEq_where_core_cmp_PartialEq_F_p3_circle_domain_CircleDomain_F_for_p3_circle_domain_CircleDomain_F.
  
  Module Impl_core_cmp_Eq_where_core_cmp_Eq_F_for_p3_circle_domain_CircleDomain_F.
    Definition Self (F : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "p3_circle::domain::CircleDomain") [] [ F ].
    
    (* Eq *)
    Definition assert_receiver_is_total_eq
        (F : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self F in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              Value.DeclaredButUndefined,
              [
                fun γ =>
                  ltac:(M.monadic
                    (M.match_operator (|
                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                      Value.DeclaredButUndefined,
                      [ fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |))) ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (F : Ty.t),
      M.IsTraitInstance
        "core::cmp::Eq"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self F)
        (* Instance *)
        [ ("assert_receiver_is_total_eq", InstanceField.Method (assert_receiver_is_total_eq F)) ].
  End Impl_core_cmp_Eq_where_core_cmp_Eq_F_for_p3_circle_domain_CircleDomain_F.
  
  Module Impl_core_fmt_Debug_where_core_fmt_Debug_F_for_p3_circle_domain_CircleDomain_F.
    Definition Self (F : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "p3_circle::domain::CircleDomain") [] [ F ].
    
    (* Debug *)
    Definition fmt (F : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self F in
      match ε, τ, α with
      | [], [], [ self; f ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let f := M.alloc (| f |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "core::result::Result")
              []
              [ Ty.tuple []; Ty.path "core::fmt::Error" ],
            M.get_associated_function (|
              Ty.path "core::fmt::Formatter",
              "debug_struct_field2_finish",
              [],
              []
            |),
            [
              M.borrow (| Pointer.Kind.MutRef, M.deref (| M.read (| f |) |) |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "CircleDomain" |) |) |);
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "log_n" |) |) |);
              (* Unsize *)
              M.pointer_coercion
                (M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.SubPointer.get_struct_record_field (|
                        M.deref (| M.read (| self |) |),
                        "p3_circle::domain::CircleDomain",
                        "log_n"
                      |)
                    |)
                  |)
                |));
              M.borrow (| Pointer.Kind.Ref, M.deref (| mk_str (| "shift" |) |) |);
              (* Unsize *)
              M.pointer_coercion
                (M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.alloc (|
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "p3_circle::domain::CircleDomain",
                            "shift"
                          |)
                        |)
                      |)
                    |)
                  |)
                |))
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (F : Ty.t),
      M.IsTraitInstance
        "core::fmt::Debug"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self F)
        (* Instance *) [ ("fmt", InstanceField.Method (fmt F)) ].
  End Impl_core_fmt_Debug_where_core_fmt_Debug_F_for_p3_circle_domain_CircleDomain_F.
  
  Module Impl_p3_circle_domain_CircleDomain_F.
    Definition Self (F : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "p3_circle::domain::CircleDomain") [] [ F ].
    
    (*
        pub const fn new(log_n: usize, shift: Point<F>) -> Self {
            Self { log_n, shift }
        }
    *)
    Definition new (F : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self F in
      match ε, τ, α with
      | [], [], [ log_n; shift ] =>
        ltac:(M.monadic
          (let log_n := M.alloc (| log_n |) in
          let shift := M.alloc (| shift |) in
          Value.StructRecord
            "p3_circle::domain::CircleDomain"
            [ ("log_n", M.read (| log_n |)); ("shift", M.read (| shift |)) ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_new :
      forall (F : Ty.t),
      M.IsAssociatedFunction.C (Self F) "new" (new F).
    Admitted.
    Global Typeclasses Opaque new.
    
    (*
        pub fn standard(log_n: usize) -> Self {
            Self {
                log_n,
                shift: Point::generator(log_n + 1),
            }
        }
    *)
    Definition standard (F : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self F in
      match ε, τ, α with
      | [], [], [ log_n ] =>
        ltac:(M.monadic
          (let log_n := M.alloc (| log_n |) in
          Value.StructRecord
            "p3_circle::domain::CircleDomain"
            [
              ("log_n", M.read (| log_n |));
              ("shift",
                M.call_closure (|
                  Ty.apply (Ty.path "p3_circle::point::Point") [] [ F ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "p3_circle::point::Point") [] [ F ],
                    "generator",
                    [],
                    []
                  |),
                  [
                    M.call_closure (|
                      Ty.path "usize",
                      BinOp.Wrap.add,
                      [ M.read (| log_n |); Value.Integer IntegerKind.Usize 1 ]
                    |)
                  ]
                |))
            ]))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_standard :
      forall (F : Ty.t),
      M.IsAssociatedFunction.C (Self F) "standard" (standard F).
    Admitted.
    Global Typeclasses Opaque standard.
    
    (*
        fn is_standard(&self) -> bool {
            self.shift == Point::generator(self.log_n + 1)
        }
    *)
    Definition is_standard (F : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self F in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            Ty.path "bool",
            M.get_trait_method (|
              "core::cmp::PartialEq",
              Ty.apply (Ty.path "p3_circle::point::Point") [] [ F ],
              [],
              [ Ty.apply (Ty.path "p3_circle::point::Point") [] [ F ] ],
              "eq",
              [],
              []
            |),
            [
              M.borrow (|
                Pointer.Kind.Ref,
                M.SubPointer.get_struct_record_field (|
                  M.deref (| M.read (| self |) |),
                  "p3_circle::domain::CircleDomain",
                  "shift"
                |)
              |);
              M.borrow (|
                Pointer.Kind.Ref,
                M.alloc (|
                  M.call_closure (|
                    Ty.apply (Ty.path "p3_circle::point::Point") [] [ F ],
                    M.get_associated_function (|
                      Ty.apply (Ty.path "p3_circle::point::Point") [] [ F ],
                      "generator",
                      [],
                      []
                    |),
                    [
                      M.call_closure (|
                        Ty.path "usize",
                        BinOp.Wrap.add,
                        [
                          M.read (|
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "p3_circle::domain::CircleDomain",
                              "log_n"
                            |)
                          |);
                          Value.Integer IntegerKind.Usize 1
                        ]
                      |)
                    ]
                  |)
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_is_standard :
      forall (F : Ty.t),
      M.IsAssociatedFunction.C (Self F) "is_standard" (is_standard F).
    Admitted.
    Global Typeclasses Opaque is_standard.
    
    (*
        pub(crate) fn subgroup_generator(&self) -> Point<F> {
            Point::generator(self.log_n - 1)
        }
    *)
    Definition subgroup_generator
        (F : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self F in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            Ty.apply (Ty.path "p3_circle::point::Point") [] [ F ],
            M.get_associated_function (|
              Ty.apply (Ty.path "p3_circle::point::Point") [] [ F ],
              "generator",
              [],
              []
            |),
            [
              M.call_closure (|
                Ty.path "usize",
                BinOp.Wrap.sub,
                [
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "p3_circle::domain::CircleDomain",
                      "log_n"
                    |)
                  |);
                  Value.Integer IntegerKind.Usize 1
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_subgroup_generator :
      forall (F : Ty.t),
      M.IsAssociatedFunction.C (Self F) "subgroup_generator" (subgroup_generator F).
    Admitted.
    Global Typeclasses Opaque subgroup_generator.
    
    (*
        pub(crate) fn coset0(&self) -> impl Iterator<Item = Point<F>> {
            let g = self.subgroup_generator();
            iterate(self.shift, move |&p| p + g).take(1 << (self.log_n - 1))
        }
    *)
    Definition coset0 (F : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self F in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let~ g :
                Ty.apply
                  (Ty.path "*")
                  []
                  [ Ty.apply (Ty.path "p3_circle::point::Point") [] [ F ] ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.apply (Ty.path "p3_circle::point::Point") [] [ F ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "p3_circle::domain::CircleDomain") [] [ F ],
                    "subgroup_generator",
                    [],
                    []
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                Ty.apply
                  (Ty.path "core::iter::adapters::take::Take")
                  []
                  [
                    Ty.apply
                      (Ty.path "itertools::sources::Iterate")
                      []
                      [
                        Ty.apply (Ty.path "p3_circle::point::Point") [] [ F ];
                        Ty.function
                          [
                            Ty.tuple
                              [
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [ Ty.apply (Ty.path "p3_circle::point::Point") [] [ F ] ]
                              ]
                          ]
                          (Ty.apply (Ty.path "p3_circle::point::Point") [] [ F ])
                      ]
                  ],
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  Ty.apply
                    (Ty.path "itertools::sources::Iterate")
                    []
                    [
                      Ty.apply (Ty.path "p3_circle::point::Point") [] [ F ];
                      Ty.function
                        [
                          Ty.tuple
                            [
                              Ty.apply
                                (Ty.path "&")
                                []
                                [ Ty.apply (Ty.path "p3_circle::point::Point") [] [ F ] ]
                            ]
                        ]
                        (Ty.apply (Ty.path "p3_circle::point::Point") [] [ F ])
                    ],
                  [],
                  [],
                  "take",
                  [],
                  []
                |),
                [
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "itertools::sources::Iterate")
                      []
                      [
                        Ty.apply (Ty.path "p3_circle::point::Point") [] [ F ];
                        Ty.function
                          [
                            Ty.tuple
                              [
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [ Ty.apply (Ty.path "p3_circle::point::Point") [] [ F ] ]
                              ]
                          ]
                          (Ty.apply (Ty.path "p3_circle::point::Point") [] [ F ])
                      ],
                    M.get_function (|
                      "itertools::sources::iterate",
                      [],
                      [
                        Ty.apply (Ty.path "p3_circle::point::Point") [] [ F ];
                        Ty.function
                          [
                            Ty.tuple
                              [
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [ Ty.apply (Ty.path "p3_circle::point::Point") [] [ F ] ]
                              ]
                          ]
                          (Ty.apply (Ty.path "p3_circle::point::Point") [] [ F ])
                      ]
                    |),
                    [
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "p3_circle::domain::CircleDomain",
                          "shift"
                        |)
                      |);
                      M.closure
                        (fun γ =>
                          ltac:(M.monadic
                            match γ with
                            | [ α0 ] =>
                              ltac:(M.monadic
                                (M.match_operator (|
                                  Ty.apply
                                    (Ty.path "*")
                                    []
                                    [
                                      Ty.function
                                        [
                                          Ty.tuple
                                            [
                                              Ty.apply
                                                (Ty.path "&")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "p3_circle::point::Point")
                                                    []
                                                    [ F ]
                                                ]
                                            ]
                                        ]
                                        (Ty.apply (Ty.path "p3_circle::point::Point") [] [ F ])
                                    ],
                                  M.alloc (| α0 |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ := M.read (| γ |) in
                                        let p := M.copy (| γ |) in
                                        M.call_closure (|
                                          Ty.apply (Ty.path "p3_circle::point::Point") [] [ F ],
                                          M.get_trait_method (|
                                            "core::ops::arith::Add",
                                            Ty.apply (Ty.path "p3_circle::point::Point") [] [ F ],
                                            [],
                                            [ Ty.apply (Ty.path "p3_circle::point::Point") [] [ F ]
                                            ],
                                            "add",
                                            [],
                                            []
                                          |),
                                          [ M.read (| p |); M.read (| g |) ]
                                        |)))
                                  ]
                                |)))
                            | _ => M.impossible "wrong number of arguments"
                            end))
                    ]
                  |);
                  M.call_closure (|
                    Ty.path "usize",
                    BinOp.Wrap.shl,
                    [
                      Value.Integer IntegerKind.Usize 1;
                      M.call_closure (|
                        Ty.path "usize",
                        BinOp.Wrap.sub,
                        [
                          M.read (|
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "p3_circle::domain::CircleDomain",
                              "log_n"
                            |)
                          |);
                          Value.Integer IntegerKind.Usize 1
                        ]
                      |)
                    ]
                  |)
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_coset0 :
      forall (F : Ty.t),
      M.IsAssociatedFunction.C (Self F) "coset0" (coset0 F).
    Admitted.
    Global Typeclasses Opaque coset0.
    
    (*
        fn coset1(&self) -> impl Iterator<Item = Point<F>> {
            let g = self.subgroup_generator();
            iterate(g - self.shift, move |&p| p + g).take(1 << (self.log_n - 1))
        }
    *)
    Definition coset1 (F : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self F in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.read (|
            let~ g :
                Ty.apply
                  (Ty.path "*")
                  []
                  [ Ty.apply (Ty.path "p3_circle::point::Point") [] [ F ] ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.apply (Ty.path "p3_circle::point::Point") [] [ F ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "p3_circle::domain::CircleDomain") [] [ F ],
                    "subgroup_generator",
                    [],
                    []
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                Ty.apply
                  (Ty.path "core::iter::adapters::take::Take")
                  []
                  [
                    Ty.apply
                      (Ty.path "itertools::sources::Iterate")
                      []
                      [
                        Ty.apply (Ty.path "p3_circle::point::Point") [] [ F ];
                        Ty.function
                          [
                            Ty.tuple
                              [
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [ Ty.apply (Ty.path "p3_circle::point::Point") [] [ F ] ]
                              ]
                          ]
                          (Ty.apply (Ty.path "p3_circle::point::Point") [] [ F ])
                      ]
                  ],
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  Ty.apply
                    (Ty.path "itertools::sources::Iterate")
                    []
                    [
                      Ty.apply (Ty.path "p3_circle::point::Point") [] [ F ];
                      Ty.function
                        [
                          Ty.tuple
                            [
                              Ty.apply
                                (Ty.path "&")
                                []
                                [ Ty.apply (Ty.path "p3_circle::point::Point") [] [ F ] ]
                            ]
                        ]
                        (Ty.apply (Ty.path "p3_circle::point::Point") [] [ F ])
                    ],
                  [],
                  [],
                  "take",
                  [],
                  []
                |),
                [
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "itertools::sources::Iterate")
                      []
                      [
                        Ty.apply (Ty.path "p3_circle::point::Point") [] [ F ];
                        Ty.function
                          [
                            Ty.tuple
                              [
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [ Ty.apply (Ty.path "p3_circle::point::Point") [] [ F ] ]
                              ]
                          ]
                          (Ty.apply (Ty.path "p3_circle::point::Point") [] [ F ])
                      ],
                    M.get_function (|
                      "itertools::sources::iterate",
                      [],
                      [
                        Ty.apply (Ty.path "p3_circle::point::Point") [] [ F ];
                        Ty.function
                          [
                            Ty.tuple
                              [
                                Ty.apply
                                  (Ty.path "&")
                                  []
                                  [ Ty.apply (Ty.path "p3_circle::point::Point") [] [ F ] ]
                              ]
                          ]
                          (Ty.apply (Ty.path "p3_circle::point::Point") [] [ F ])
                      ]
                    |),
                    [
                      M.call_closure (|
                        Ty.apply (Ty.path "p3_circle::point::Point") [] [ F ],
                        M.get_trait_method (|
                          "core::ops::arith::Sub",
                          Ty.apply (Ty.path "p3_circle::point::Point") [] [ F ],
                          [],
                          [ Ty.apply (Ty.path "p3_circle::point::Point") [] [ F ] ],
                          "sub",
                          [],
                          []
                        |),
                        [
                          M.read (| g |);
                          M.read (|
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "p3_circle::domain::CircleDomain",
                              "shift"
                            |)
                          |)
                        ]
                      |);
                      M.closure
                        (fun γ =>
                          ltac:(M.monadic
                            match γ with
                            | [ α0 ] =>
                              ltac:(M.monadic
                                (M.match_operator (|
                                  Ty.apply
                                    (Ty.path "*")
                                    []
                                    [
                                      Ty.function
                                        [
                                          Ty.tuple
                                            [
                                              Ty.apply
                                                (Ty.path "&")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "p3_circle::point::Point")
                                                    []
                                                    [ F ]
                                                ]
                                            ]
                                        ]
                                        (Ty.apply (Ty.path "p3_circle::point::Point") [] [ F ])
                                    ],
                                  M.alloc (| α0 |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let γ := M.read (| γ |) in
                                        let p := M.copy (| γ |) in
                                        M.call_closure (|
                                          Ty.apply (Ty.path "p3_circle::point::Point") [] [ F ],
                                          M.get_trait_method (|
                                            "core::ops::arith::Add",
                                            Ty.apply (Ty.path "p3_circle::point::Point") [] [ F ],
                                            [],
                                            [ Ty.apply (Ty.path "p3_circle::point::Point") [] [ F ]
                                            ],
                                            "add",
                                            [],
                                            []
                                          |),
                                          [ M.read (| p |); M.read (| g |) ]
                                        |)))
                                  ]
                                |)))
                            | _ => M.impossible "wrong number of arguments"
                            end))
                    ]
                  |);
                  M.call_closure (|
                    Ty.path "usize",
                    BinOp.Wrap.shl,
                    [
                      Value.Integer IntegerKind.Usize 1;
                      M.call_closure (|
                        Ty.path "usize",
                        BinOp.Wrap.sub,
                        [
                          M.read (|
                            M.SubPointer.get_struct_record_field (|
                              M.deref (| M.read (| self |) |),
                              "p3_circle::domain::CircleDomain",
                              "log_n"
                            |)
                          |);
                          Value.Integer IntegerKind.Usize 1
                        ]
                      |)
                    ]
                  |)
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_coset1 :
      forall (F : Ty.t),
      M.IsAssociatedFunction.C (Self F) "coset1" (coset1 F).
    Admitted.
    Global Typeclasses Opaque coset1.
    
    (*
        pub(crate) fn points(&self) -> impl Iterator<Item = Point<F>> {
            self.coset0().interleave(self.coset1())
        }
    *)
    Definition points (F : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self F in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            Ty.apply
              (Ty.path "itertools::adaptors::Interleave")
              []
              [ Ty.associated_unknown; Ty.associated_unknown ],
            M.get_trait_method (|
              "itertools::Itertools",
              Ty.associated_unknown,
              [],
              [],
              "interleave",
              [],
              [ Ty.associated_unknown ]
            |),
            [
              M.call_closure (|
                Ty.associated_unknown,
                M.get_associated_function (|
                  Ty.apply (Ty.path "p3_circle::domain::CircleDomain") [] [ F ],
                  "coset0",
                  [],
                  []
                |),
                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
              |);
              M.call_closure (|
                Ty.associated_unknown,
                M.get_associated_function (|
                  Ty.apply (Ty.path "p3_circle::domain::CircleDomain") [] [ F ],
                  "coset1",
                  [],
                  []
                |),
                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_points :
      forall (F : Ty.t),
      M.IsAssociatedFunction.C (Self F) "points" (points F).
    Admitted.
    Global Typeclasses Opaque points.
    
    (*
        pub(crate) fn nth_point(&self, idx: usize) -> Point<F> {
            let (idx, lsb) = (idx >> 1, idx & 1);
            if lsb == 0 {
                self.shift + self.subgroup_generator() * idx
            } else {
                -self.shift + self.subgroup_generator() * (idx + 1)
            }
        }
    *)
    Definition nth_point (F : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self F in
      match ε, τ, α with
      | [], [], [ self; idx ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let idx := M.alloc (| idx |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.apply (Ty.path "p3_circle::point::Point") [] [ F ] ],
              M.alloc (|
                Value.Tuple
                  [
                    M.call_closure (|
                      Ty.path "usize",
                      BinOp.Wrap.shr,
                      [ M.read (| idx |); Value.Integer IntegerKind.I32 1 ]
                    |);
                    M.call_closure (|
                      Ty.path "usize",
                      BinOp.Wrap.bit_and,
                      [ M.read (| idx |); Value.Integer IntegerKind.Usize 1 ]
                    |)
                  ]
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let idx := M.copy (| γ0_0 |) in
                    let lsb := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      Ty.apply
                        (Ty.path "*")
                        []
                        [ Ty.apply (Ty.path "p3_circle::point::Point") [] [ F ] ],
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    Ty.path "bool",
                                    BinOp.eq,
                                    [ M.read (| lsb |); Value.Integer IntegerKind.Usize 0 ]
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply (Ty.path "p3_circle::point::Point") [] [ F ],
                                M.get_trait_method (|
                                  "core::ops::arith::Add",
                                  Ty.apply (Ty.path "p3_circle::point::Point") [] [ F ],
                                  [],
                                  [ Ty.apply (Ty.path "p3_circle::point::Point") [] [ F ] ],
                                  "add",
                                  [],
                                  []
                                |),
                                [
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "p3_circle::domain::CircleDomain",
                                      "shift"
                                    |)
                                  |);
                                  M.call_closure (|
                                    Ty.apply (Ty.path "p3_circle::point::Point") [] [ F ],
                                    M.get_trait_method (|
                                      "core::ops::arith::Mul",
                                      Ty.apply (Ty.path "p3_circle::point::Point") [] [ F ],
                                      [],
                                      [ Ty.path "usize" ],
                                      "mul",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.apply (Ty.path "p3_circle::point::Point") [] [ F ],
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "p3_circle::domain::CircleDomain")
                                            []
                                            [ F ],
                                          "subgroup_generator",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (| M.read (| self |) |)
                                          |)
                                        ]
                                      |);
                                      M.read (| idx |)
                                    ]
                                  |)
                                ]
                              |)
                            |)));
                        fun γ =>
                          ltac:(M.monadic
                            (M.alloc (|
                              M.call_closure (|
                                Ty.apply (Ty.path "p3_circle::point::Point") [] [ F ],
                                M.get_trait_method (|
                                  "core::ops::arith::Add",
                                  Ty.apply (Ty.path "p3_circle::point::Point") [] [ F ],
                                  [],
                                  [ Ty.apply (Ty.path "p3_circle::point::Point") [] [ F ] ],
                                  "add",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.apply (Ty.path "p3_circle::point::Point") [] [ F ],
                                    M.get_trait_method (|
                                      "core::ops::arith::Neg",
                                      Ty.apply (Ty.path "p3_circle::point::Point") [] [ F ],
                                      [],
                                      [],
                                      "neg",
                                      [],
                                      []
                                    |),
                                    [
                                      M.read (|
                                        M.SubPointer.get_struct_record_field (|
                                          M.deref (| M.read (| self |) |),
                                          "p3_circle::domain::CircleDomain",
                                          "shift"
                                        |)
                                      |)
                                    ]
                                  |);
                                  M.call_closure (|
                                    Ty.apply (Ty.path "p3_circle::point::Point") [] [ F ],
                                    M.get_trait_method (|
                                      "core::ops::arith::Mul",
                                      Ty.apply (Ty.path "p3_circle::point::Point") [] [ F ],
                                      [],
                                      [ Ty.path "usize" ],
                                      "mul",
                                      [],
                                      []
                                    |),
                                    [
                                      M.call_closure (|
                                        Ty.apply (Ty.path "p3_circle::point::Point") [] [ F ],
                                        M.get_associated_function (|
                                          Ty.apply
                                            (Ty.path "p3_circle::domain::CircleDomain")
                                            []
                                            [ F ],
                                          "subgroup_generator",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.deref (| M.read (| self |) |)
                                          |)
                                        ]
                                      |);
                                      M.call_closure (|
                                        Ty.path "usize",
                                        BinOp.Wrap.add,
                                        [ M.read (| idx |); Value.Integer IntegerKind.Usize 1 ]
                                      |)
                                    ]
                                  |)
                                ]
                              |)
                            |)))
                      ]
                    |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_nth_point :
      forall (F : Ty.t),
      M.IsAssociatedFunction.C (Self F) "nth_point" (nth_point F).
    Admitted.
    Global Typeclasses Opaque nth_point.
    
    (*
        pub(crate) fn vanishing_poly<EF: ExtensionField<F>>(&self, at: Point<EF>) -> EF {
            at.v_n(self.log_n) - self.shift.v_n(self.log_n)
        }
    *)
    Definition vanishing_poly
        (F : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self F in
      match ε, τ, α with
      | [], [ EF ], [ self; at_ ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let at_ := M.alloc (| at_ |) in
          M.call_closure (|
            EF,
            M.get_trait_method (| "core::ops::arith::Sub", EF, [], [ F ], "sub", [], [] |),
            [
              M.call_closure (|
                EF,
                M.get_associated_function (|
                  Ty.apply (Ty.path "p3_circle::point::Point") [] [ EF ],
                  "v_n",
                  [],
                  []
                |),
                [
                  M.read (| at_ |);
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "p3_circle::domain::CircleDomain",
                      "log_n"
                    |)
                  |)
                ]
              |);
              M.call_closure (|
                F,
                M.get_associated_function (|
                  Ty.apply (Ty.path "p3_circle::point::Point") [] [ F ],
                  "v_n",
                  [],
                  []
                |),
                [
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "p3_circle::domain::CircleDomain",
                      "shift"
                    |)
                  |);
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "p3_circle::domain::CircleDomain",
                      "log_n"
                    |)
                  |)
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_vanishing_poly :
      forall (F : Ty.t),
      M.IsAssociatedFunction.C (Self F) "vanishing_poly" (vanishing_poly F).
    Admitted.
    Global Typeclasses Opaque vanishing_poly.
    
    (*
        pub(crate) fn s_p<EF: ExtensionField<F>>(&self, p: Point<F>, at: Point<EF>) -> EF {
            self.vanishing_poly(at) / p.v_tilde_p(at)
        }
    *)
    Definition s_p (F : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self F in
      match ε, τ, α with
      | [], [ EF ], [ self; p; at_ ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let p := M.alloc (| p |) in
          let at_ := M.alloc (| at_ |) in
          M.call_closure (|
            EF,
            M.get_trait_method (| "core::ops::arith::Div", EF, [], [ EF ], "div", [], [] |),
            [
              M.call_closure (|
                EF,
                M.get_associated_function (|
                  Ty.apply (Ty.path "p3_circle::domain::CircleDomain") [] [ F ],
                  "vanishing_poly",
                  [],
                  [ EF ]
                |),
                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |); M.read (| at_ |)
                ]
              |);
              M.call_closure (|
                EF,
                M.get_associated_function (|
                  Ty.apply (Ty.path "p3_circle::point::Point") [] [ F ],
                  "v_tilde_p",
                  [],
                  [ EF ]
                |),
                [ M.read (| p |); M.read (| at_ |) ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_s_p :
      forall (F : Ty.t),
      M.IsAssociatedFunction.C (Self F) "s_p" (s_p F).
    Admitted.
    Global Typeclasses Opaque s_p.
    
    (*
        pub(crate) fn s_p_normalized<EF: ExtensionField<F>>(&self, p: Point<F>, at: Point<EF>) -> EF {
            self.vanishing_poly(at) / (p.v_tilde_p(at) * p.s_p_at_p(self.log_n))
        }
    *)
    Definition s_p_normalized
        (F : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self F in
      match ε, τ, α with
      | [], [ EF ], [ self; p; at_ ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let p := M.alloc (| p |) in
          let at_ := M.alloc (| at_ |) in
          M.call_closure (|
            EF,
            M.get_trait_method (| "core::ops::arith::Div", EF, [], [ EF ], "div", [], [] |),
            [
              M.call_closure (|
                EF,
                M.get_associated_function (|
                  Ty.apply (Ty.path "p3_circle::domain::CircleDomain") [] [ F ],
                  "vanishing_poly",
                  [],
                  [ EF ]
                |),
                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |); M.read (| at_ |)
                ]
              |);
              M.call_closure (|
                EF,
                M.get_trait_method (| "core::ops::arith::Mul", EF, [], [ F ], "mul", [], [] |),
                [
                  M.call_closure (|
                    EF,
                    M.get_associated_function (|
                      Ty.apply (Ty.path "p3_circle::point::Point") [] [ F ],
                      "v_tilde_p",
                      [],
                      [ EF ]
                    |),
                    [ M.read (| p |); M.read (| at_ |) ]
                  |);
                  M.call_closure (|
                    F,
                    M.get_associated_function (|
                      Ty.apply (Ty.path "p3_circle::point::Point") [] [ F ],
                      "s_p_at_p",
                      [],
                      []
                    |),
                    [
                      M.read (| p |);
                      M.read (|
                        M.SubPointer.get_struct_record_field (|
                          M.deref (| M.read (| self |) |),
                          "p3_circle::domain::CircleDomain",
                          "log_n"
                        |)
                      |)
                    ]
                  |)
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Global Instance AssociatedFunction_s_p_normalized :
      forall (F : Ty.t),
      M.IsAssociatedFunction.C (Self F) "s_p_normalized" (s_p_normalized F).
    Admitted.
    Global Typeclasses Opaque s_p_normalized.
  End Impl_p3_circle_domain_CircleDomain_F.
  
  Module Impl_p3_commit_domain_PolynomialSpace_where_p3_field_extension_complex_ComplexExtendable_F_for_p3_circle_domain_CircleDomain_F.
    Definition Self (F : Ty.t) : Ty.t :=
      Ty.apply (Ty.path "p3_circle::domain::CircleDomain") [] [ F ].
    
    (*     type Val = F; *)
    Definition _Val (F : Ty.t) : Ty.t := F.
    
    (*
        fn size(&self) -> usize {
            1 << self.log_n
        }
    *)
    Definition size (F : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self F in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            Ty.path "usize",
            BinOp.Wrap.shl,
            [
              Value.Integer IntegerKind.Usize 1;
              M.read (|
                M.SubPointer.get_struct_record_field (|
                  M.deref (| M.read (| self |) |),
                  "p3_circle::domain::CircleDomain",
                  "log_n"
                |)
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn first_point(&self) -> Self::Val {
            self.shift.to_projective_line().unwrap()
        }
    *)
    Definition first_point (F : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self F in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          M.call_closure (|
            F,
            M.get_associated_function (|
              Ty.apply (Ty.path "core::option::Option") [] [ F ],
              "unwrap",
              [],
              []
            |),
            [
              M.call_closure (|
                Ty.apply (Ty.path "core::option::Option") [] [ F ],
                M.get_associated_function (|
                  Ty.apply (Ty.path "p3_circle::point::Point") [] [ F ],
                  "to_projective_line",
                  [],
                  []
                |),
                [
                  M.read (|
                    M.SubPointer.get_struct_record_field (|
                      M.deref (| M.read (| self |) |),
                      "p3_circle::domain::CircleDomain",
                      "shift"
                    |)
                  |)
                ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn next_point<Ext: ExtensionField<Self::Val>>(&self, x: Ext) -> Option<Ext> {
            // Only in standard position do we have an algebraic expression to access the next point.
            if self.is_standard() {
                (Point::from_projective_line(x) + Point::generator(self.log_n)).to_projective_line()
            } else {
                None
            }
        }
    *)
    Definition next_point (F : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self F in
      match ε, τ, α with
      | [], [ Ext ], [ self; x ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let x := M.alloc (| x |) in
          M.read (|
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.apply (Ty.path "core::option::Option") [] [ Ext ] ],
              M.alloc (| Value.Tuple [] |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ :=
                      M.use
                        (M.alloc (|
                          M.call_closure (|
                            Ty.path "bool",
                            M.get_associated_function (|
                              Ty.apply (Ty.path "p3_circle::domain::CircleDomain") [] [ F ],
                              "is_standard",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                          |)
                        |)) in
                    let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                    M.alloc (|
                      M.call_closure (|
                        Ty.apply (Ty.path "core::option::Option") [] [ Ext ],
                        M.get_associated_function (|
                          Ty.apply (Ty.path "p3_circle::point::Point") [] [ Ext ],
                          "to_projective_line",
                          [],
                          []
                        |),
                        [
                          M.call_closure (|
                            Ty.apply (Ty.path "p3_circle::point::Point") [] [ Ext ],
                            M.get_trait_method (|
                              "core::ops::arith::Add",
                              Ty.apply (Ty.path "p3_circle::point::Point") [] [ Ext ],
                              [],
                              [ Ty.apply (Ty.path "p3_circle::point::Point") [] [ F ] ],
                              "add",
                              [],
                              []
                            |),
                            [
                              M.call_closure (|
                                Ty.apply (Ty.path "p3_circle::point::Point") [] [ Ext ],
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "p3_circle::point::Point") [] [ Ext ],
                                  "from_projective_line",
                                  [],
                                  []
                                |),
                                [ M.read (| x |) ]
                              |);
                              M.call_closure (|
                                Ty.apply (Ty.path "p3_circle::point::Point") [] [ F ],
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "p3_circle::point::Point") [] [ F ],
                                  "generator",
                                  [],
                                  []
                                |),
                                [
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "p3_circle::domain::CircleDomain",
                                      "log_n"
                                    |)
                                  |)
                                ]
                              |)
                            ]
                          |)
                        ]
                      |)
                    |)));
                fun γ =>
                  ltac:(M.monadic (M.alloc (| Value.StructTuple "core::option::Option::None" [] |)))
              ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn create_disjoint_domain(&self, min_size: usize) -> Self {
            // Right now we simply guarantee the domain is disjoint by returning a
            // larger standard position coset, which is fine because we always ask for a larger
            // domain. If we wanted good performance for a disjoint domain of the same size,
            // we could change the shift. Also we could support nonstandard twin cosets.
            assert!(
                self.is_standard(),
                "create_disjoint_domain not currently supported for nonstandard twin cosets"
            );
            let log_n = log2_ceil_usize(min_size);
            // Any standard position coset that is not the same size as us will be disjoint.
            Self::standard(if log_n == self.log_n {
                log_n + 1
            } else {
                log_n
            })
        }
    *)
    Definition create_disjoint_domain
        (F : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self F in
      match ε, τ, α with
      | [], [], [ self; min_size ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let min_size := M.alloc (| min_size |) in
          M.read (|
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.match_operator (|
                Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            UnOp.not (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "p3_circle::domain::CircleDomain") [] [ F ],
                                  "is_standard",
                                  [],
                                  []
                                |),
                                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                              |)
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        M.never_to_any (|
                          M.call_closure (|
                            Ty.path "never",
                            M.get_function (| "core::panicking::panic_fmt", [], [] |),
                            [
                              M.call_closure (|
                                Ty.path "core::fmt::Arguments",
                                M.get_associated_function (|
                                  Ty.path "core::fmt::Arguments",
                                  "new_const",
                                  [ Value.Integer IntegerKind.Usize 1 ],
                                  []
                                |),
                                [
                                  M.borrow (|
                                    Pointer.Kind.Ref,
                                    M.deref (|
                                      M.borrow (|
                                        Pointer.Kind.Ref,
                                        M.alloc (|
                                          Value.Array
                                            [
                                              mk_str (|
                                                "create_disjoint_domain not currently supported for nonstandard twin cosets"
                                              |)
                                            ]
                                        |)
                                      |)
                                    |)
                                  |)
                                ]
                              |)
                            ]
                          |)
                        |)
                      |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            let~ log_n : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "usize",
                  M.get_function (| "p3_util::log2_ceil_usize", [], [] |),
                  [ M.read (| min_size |) ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                Ty.apply (Ty.path "p3_circle::domain::CircleDomain") [] [ F ],
                M.get_associated_function (|
                  Ty.apply (Ty.path "p3_circle::domain::CircleDomain") [] [ F ],
                  "standard",
                  [],
                  []
                |),
                [
                  M.read (|
                    M.match_operator (|
                      Ty.apply (Ty.path "*") [] [ Ty.path "usize" ],
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  M.call_closure (|
                                    Ty.path "bool",
                                    BinOp.eq,
                                    [
                                      M.read (| log_n |);
                                      M.read (|
                                        M.SubPointer.get_struct_record_field (|
                                          M.deref (| M.read (| self |) |),
                                          "p3_circle::domain::CircleDomain",
                                          "log_n"
                                        |)
                                      |)
                                    ]
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.call_closure (|
                                Ty.path "usize",
                                BinOp.Wrap.add,
                                [ M.read (| log_n |); Value.Integer IntegerKind.Usize 1 ]
                              |)
                            |)));
                        fun γ => ltac:(M.monadic log_n)
                      ]
                    |)
                  |)
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn split_domains(&self, num_chunks: usize) -> Vec<Self> {
            assert!(self.is_standard());
            let log_chunks = log2_strict_usize(num_chunks);
            assert!(log_chunks <= self.log_n);
            self.points()
                .take(num_chunks)
                .map(|shift| Self {
                    log_n: self.log_n - log_chunks,
                    shift,
                })
                .collect()
        }
    *)
    Definition split_domains (F : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self F in
      match ε, τ, α with
      | [], [], [ self; num_chunks ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let num_chunks := M.alloc (| num_chunks |) in
          M.read (|
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.match_operator (|
                Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            UnOp.not (|
                              M.call_closure (|
                                Ty.path "bool",
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "p3_circle::domain::CircleDomain") [] [ F ],
                                  "is_standard",
                                  [],
                                  []
                                |),
                                [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                              |)
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        M.never_to_any (|
                          M.call_closure (|
                            Ty.path "never",
                            M.get_function (| "core::panicking::panic", [], [] |),
                            [ mk_str (| "assertion failed: self.is_standard()" |) ]
                          |)
                        |)
                      |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            let~ log_chunks : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "usize",
                  M.get_function (| "p3_util::log2_strict_usize", [], [] |),
                  [ M.read (| num_chunks |) ]
                |)
              |) in
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.match_operator (|
                Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            UnOp.not (|
                              M.call_closure (|
                                Ty.path "bool",
                                BinOp.le,
                                [
                                  M.read (| log_chunks |);
                                  M.read (|
                                    M.SubPointer.get_struct_record_field (|
                                      M.deref (| M.read (| self |) |),
                                      "p3_circle::domain::CircleDomain",
                                      "log_n"
                                    |)
                                  |)
                                ]
                              |)
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        M.never_to_any (|
                          M.call_closure (|
                            Ty.path "never",
                            M.get_function (| "core::panicking::panic", [], [] |),
                            [ mk_str (| "assertion failed: log_chunks <= self.log_n" |) ]
                          |)
                        |)
                      |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            M.alloc (|
              M.call_closure (|
                Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  []
                  [
                    Ty.apply (Ty.path "p3_circle::domain::CircleDomain") [] [ F ];
                    Ty.path "alloc::alloc::Global"
                  ],
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  Ty.apply
                    (Ty.path "core::iter::adapters::map::Map")
                    []
                    [
                      Ty.apply
                        (Ty.path "core::iter::adapters::take::Take")
                        []
                        [ Ty.associated_unknown ];
                      Ty.function
                        [ Ty.tuple [ Ty.apply (Ty.path "p3_circle::point::Point") [] [ F ] ] ]
                        (Ty.apply (Ty.path "p3_circle::domain::CircleDomain") [] [ F ])
                    ],
                  [],
                  [],
                  "collect",
                  [],
                  [
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      []
                      [
                        Ty.apply (Ty.path "p3_circle::domain::CircleDomain") [] [ F ];
                        Ty.path "alloc::alloc::Global"
                      ]
                  ]
                |),
                [
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::iter::adapters::map::Map")
                      []
                      [
                        Ty.apply
                          (Ty.path "core::iter::adapters::take::Take")
                          []
                          [ Ty.associated_unknown ];
                        Ty.function
                          [ Ty.tuple [ Ty.apply (Ty.path "p3_circle::point::Point") [] [ F ] ] ]
                          (Ty.apply (Ty.path "p3_circle::domain::CircleDomain") [] [ F ])
                      ],
                    M.get_trait_method (|
                      "core::iter::traits::iterator::Iterator",
                      Ty.apply
                        (Ty.path "core::iter::adapters::take::Take")
                        []
                        [ Ty.associated_unknown ],
                      [],
                      [],
                      "map",
                      [],
                      [
                        Ty.apply (Ty.path "p3_circle::domain::CircleDomain") [] [ F ];
                        Ty.function
                          [ Ty.tuple [ Ty.apply (Ty.path "p3_circle::point::Point") [] [ F ] ] ]
                          (Ty.apply (Ty.path "p3_circle::domain::CircleDomain") [] [ F ])
                      ]
                    |),
                    [
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "core::iter::adapters::take::Take")
                          []
                          [ Ty.associated_unknown ],
                        M.get_trait_method (|
                          "core::iter::traits::iterator::Iterator",
                          Ty.associated_unknown,
                          [],
                          [],
                          "take",
                          [],
                          []
                        |),
                        [
                          M.call_closure (|
                            Ty.associated_unknown,
                            M.get_associated_function (|
                              Ty.apply (Ty.path "p3_circle::domain::CircleDomain") [] [ F ],
                              "points",
                              [],
                              []
                            |),
                            [ M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |) ]
                          |);
                          M.read (| num_chunks |)
                        ]
                      |);
                      M.closure
                        (fun γ =>
                          ltac:(M.monadic
                            match γ with
                            | [ α0 ] =>
                              ltac:(M.monadic
                                (M.match_operator (|
                                  Ty.apply
                                    (Ty.path "*")
                                    []
                                    [
                                      Ty.function
                                        [
                                          Ty.tuple
                                            [ Ty.apply (Ty.path "p3_circle::point::Point") [] [ F ]
                                            ]
                                        ]
                                        (Ty.apply
                                          (Ty.path "p3_circle::domain::CircleDomain")
                                          []
                                          [ F ])
                                    ],
                                  M.alloc (| α0 |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let shift := M.copy (| γ |) in
                                        Value.StructRecord
                                          "p3_circle::domain::CircleDomain"
                                          [
                                            ("log_n",
                                              M.call_closure (|
                                                Ty.path "usize",
                                                BinOp.Wrap.sub,
                                                [
                                                  M.read (|
                                                    M.SubPointer.get_struct_record_field (|
                                                      M.deref (| M.read (| self |) |),
                                                      "p3_circle::domain::CircleDomain",
                                                      "log_n"
                                                    |)
                                                  |);
                                                  M.read (| log_chunks |)
                                                ]
                                              |));
                                            ("shift", M.read (| shift |))
                                          ]))
                                  ]
                                |)))
                            | _ => M.impossible "wrong number of arguments"
                            end))
                    ]
                  |)
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn split_evals(
            &self,
            num_chunks: usize,
            evals: RowMajorMatrix<Self::Val>,
        ) -> Vec<RowMajorMatrix<Self::Val>> {
            let log_chunks = log2_strict_usize(num_chunks);
            assert!(evals.height() >> (log_chunks + 1) >= 1);
            let width = evals.width();
            let mut values: Vec<Vec<Self::Val>> = vec![vec![]; num_chunks];
            evals
                .rows()
                .enumerate()
                .for_each(|(i, row)| values[forward_backward_index(i, num_chunks)].extend(row));
            values
                .into_iter()
                .map(|v| RowMajorMatrix::new(v, width))
                .collect()
        }
    *)
    Definition split_evals (F : Ty.t) (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
      let Self : Ty.t := Self F in
      match ε, τ, α with
      | [], [], [ self; num_chunks; evals ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let num_chunks := M.alloc (| num_chunks |) in
          let evals := M.alloc (| evals |) in
          M.read (|
            let~ log_chunks : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "usize",
                  M.get_function (| "p3_util::log2_strict_usize", [], [] |),
                  [ M.read (| num_chunks |) ]
                |)
              |) in
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.match_operator (|
                Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                M.alloc (| Value.Tuple [] |),
                [
                  fun γ =>
                    ltac:(M.monadic
                      (let γ :=
                        M.use
                          (M.alloc (|
                            UnOp.not (|
                              M.call_closure (|
                                Ty.path "bool",
                                BinOp.ge,
                                [
                                  M.call_closure (|
                                    Ty.path "usize",
                                    BinOp.Wrap.shr,
                                    [
                                      M.call_closure (|
                                        Ty.path "usize",
                                        M.get_trait_method (|
                                          "p3_matrix::Matrix",
                                          Ty.apply
                                            (Ty.path "p3_matrix::dense::DenseMatrix")
                                            []
                                            [
                                              F;
                                              Ty.apply
                                                (Ty.path "alloc::vec::Vec")
                                                []
                                                [ F; Ty.path "alloc::alloc::Global" ]
                                            ],
                                          [],
                                          [ F ],
                                          "height",
                                          [],
                                          []
                                        |),
                                        [ M.borrow (| Pointer.Kind.Ref, evals |) ]
                                      |);
                                      M.call_closure (|
                                        Ty.path "usize",
                                        BinOp.Wrap.add,
                                        [ M.read (| log_chunks |); Value.Integer IntegerKind.Usize 1
                                        ]
                                      |)
                                    ]
                                  |);
                                  Value.Integer IntegerKind.Usize 1
                                ]
                              |)
                            |)
                          |)) in
                      let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                      M.alloc (|
                        M.never_to_any (|
                          M.call_closure (|
                            Ty.path "never",
                            M.get_function (| "core::panicking::panic", [], [] |),
                            [
                              mk_str (|
                                "assertion failed: evals.height() >> (log_chunks + 1) >= 1"
                              |)
                            ]
                          |)
                        |)
                      |)));
                  fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                ]
              |) in
            let~ width : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.path "usize",
                  M.get_trait_method (|
                    "p3_matrix::Matrix",
                    Ty.apply
                      (Ty.path "p3_matrix::dense::DenseMatrix")
                      []
                      [
                        F;
                        Ty.apply
                          (Ty.path "alloc::vec::Vec")
                          []
                          [ F; Ty.path "alloc::alloc::Global" ]
                      ],
                    [],
                    [ F ],
                    "width",
                    [],
                    []
                  |),
                  [ M.borrow (| Pointer.Kind.Ref, evals |) ]
                |)
              |) in
            let~ values :
                Ty.apply
                  (Ty.path "*")
                  []
                  [
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      []
                      [
                        Ty.apply
                          (Ty.path "alloc::vec::Vec")
                          []
                          [ F; Ty.path "alloc::alloc::Global" ];
                        Ty.path "alloc::alloc::Global"
                      ]
                  ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.apply
                    (Ty.path "alloc::vec::Vec")
                    []
                    [
                      Ty.apply (Ty.path "alloc::vec::Vec") [] [ F; Ty.path "alloc::alloc::Global" ];
                      Ty.path "alloc::alloc::Global"
                    ],
                  M.get_function (|
                    "alloc::vec::from_elem",
                    [],
                    [ Ty.apply (Ty.path "alloc::vec::Vec") [] [ F; Ty.path "alloc::alloc::Global" ]
                    ]
                  |),
                  [
                    M.call_closure (|
                      Ty.apply (Ty.path "alloc::vec::Vec") [] [ F; Ty.path "alloc::alloc::Global" ],
                      M.get_associated_function (|
                        Ty.apply
                          (Ty.path "alloc::vec::Vec")
                          []
                          [ F; Ty.path "alloc::alloc::Global" ],
                        "new",
                        [],
                        []
                      |),
                      []
                    |);
                    M.read (| num_chunks |)
                  ]
                |)
              |) in
            let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.tuple [],
                  M.get_trait_method (|
                    "core::iter::traits::iterator::Iterator",
                    Ty.apply
                      (Ty.path "core::iter::adapters::enumerate::Enumerate")
                      []
                      [ Ty.associated_unknown ],
                    [],
                    [],
                    "for_each",
                    [],
                    [
                      Ty.function
                        [
                          Ty.tuple
                            [
                              Ty.tuple
                                [
                                  Ty.path "usize";
                                  Ty.apply
                                    (Ty.path "core::iter::adapters::cloned::Cloned")
                                    []
                                    [ Ty.apply (Ty.path "core::slice::iter::Iter") [] [ F ] ]
                                ]
                            ]
                        ]
                        (Ty.tuple [])
                    ]
                  |),
                  [
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "core::iter::adapters::enumerate::Enumerate")
                        []
                        [ Ty.associated_unknown ],
                      M.get_trait_method (|
                        "core::iter::traits::iterator::Iterator",
                        Ty.associated_unknown,
                        [],
                        [],
                        "enumerate",
                        [],
                        []
                      |),
                      [
                        M.call_closure (|
                          Ty.associated_unknown,
                          M.get_trait_method (|
                            "p3_matrix::Matrix",
                            Ty.apply
                              (Ty.path "p3_matrix::dense::DenseMatrix")
                              []
                              [
                                F;
                                Ty.apply
                                  (Ty.path "alloc::vec::Vec")
                                  []
                                  [ F; Ty.path "alloc::alloc::Global" ]
                              ],
                            [],
                            [ F ],
                            "rows",
                            [],
                            []
                          |),
                          [ M.borrow (| Pointer.Kind.Ref, evals |) ]
                        |)
                      ]
                    |);
                    M.closure
                      (fun γ =>
                        ltac:(M.monadic
                          match γ with
                          | [ α0 ] =>
                            ltac:(M.monadic
                              (M.match_operator (|
                                Ty.apply
                                  (Ty.path "*")
                                  []
                                  [
                                    Ty.function
                                      [
                                        Ty.tuple
                                          [
                                            Ty.tuple
                                              [
                                                Ty.path "usize";
                                                Ty.apply
                                                  (Ty.path "core::iter::adapters::cloned::Cloned")
                                                  []
                                                  [
                                                    Ty.apply
                                                      (Ty.path "core::slice::iter::Iter")
                                                      []
                                                      [ F ]
                                                  ]
                                              ]
                                          ]
                                      ]
                                      (Ty.tuple [])
                                  ],
                                M.alloc (| α0 |),
                                [
                                  fun γ =>
                                    ltac:(M.monadic
                                      (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                      let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                      let i := M.copy (| γ0_0 |) in
                                      let row := M.copy (| γ0_1 |) in
                                      M.call_closure (|
                                        Ty.tuple [],
                                        M.get_trait_method (|
                                          "core::iter::traits::collect::Extend",
                                          Ty.apply
                                            (Ty.path "alloc::vec::Vec")
                                            []
                                            [ F; Ty.path "alloc::alloc::Global" ],
                                          [],
                                          [ F ],
                                          "extend",
                                          [],
                                          [
                                            Ty.apply
                                              (Ty.path "core::iter::adapters::cloned::Cloned")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "core::slice::iter::Iter")
                                                  []
                                                  [ F ]
                                              ]
                                          ]
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.MutRef,
                                            M.deref (|
                                              M.call_closure (|
                                                Ty.apply
                                                  (Ty.path "&mut")
                                                  []
                                                  [
                                                    Ty.apply
                                                      (Ty.path "alloc::vec::Vec")
                                                      []
                                                      [ F; Ty.path "alloc::alloc::Global" ]
                                                  ],
                                                M.get_trait_method (|
                                                  "core::ops::index::IndexMut",
                                                  Ty.apply
                                                    (Ty.path "alloc::vec::Vec")
                                                    []
                                                    [
                                                      Ty.apply
                                                        (Ty.path "alloc::vec::Vec")
                                                        []
                                                        [ F; Ty.path "alloc::alloc::Global" ];
                                                      Ty.path "alloc::alloc::Global"
                                                    ],
                                                  [],
                                                  [ Ty.path "usize" ],
                                                  "index_mut",
                                                  [],
                                                  []
                                                |),
                                                [
                                                  M.borrow (| Pointer.Kind.MutRef, values |);
                                                  M.call_closure (|
                                                    Ty.path "usize",
                                                    M.get_function (|
                                                      "p3_circle::domain::forward_backward_index",
                                                      [],
                                                      []
                                                    |),
                                                    [ M.read (| i |); M.read (| num_chunks |) ]
                                                  |)
                                                ]
                                              |)
                                            |)
                                          |);
                                          M.read (| row |)
                                        ]
                                      |)))
                                ]
                              |)))
                          | _ => M.impossible "wrong number of arguments"
                          end))
                  ]
                |)
              |) in
            M.alloc (|
              M.call_closure (|
                Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  []
                  [
                    Ty.apply
                      (Ty.path "p3_matrix::dense::DenseMatrix")
                      []
                      [
                        F;
                        Ty.apply
                          (Ty.path "alloc::vec::Vec")
                          []
                          [ F; Ty.path "alloc::alloc::Global" ]
                      ];
                    Ty.path "alloc::alloc::Global"
                  ],
                M.get_trait_method (|
                  "core::iter::traits::iterator::Iterator",
                  Ty.apply
                    (Ty.path "core::iter::adapters::map::Map")
                    []
                    [
                      Ty.apply
                        (Ty.path "alloc::vec::into_iter::IntoIter")
                        []
                        [
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            []
                            [ F; Ty.path "alloc::alloc::Global" ];
                          Ty.path "alloc::alloc::Global"
                        ];
                      Ty.function
                        [
                          Ty.tuple
                            [
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                []
                                [ F; Ty.path "alloc::alloc::Global" ]
                            ]
                        ]
                        (Ty.apply
                          (Ty.path "p3_matrix::dense::DenseMatrix")
                          []
                          [
                            F;
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              []
                              [ F; Ty.path "alloc::alloc::Global" ]
                          ])
                    ],
                  [],
                  [],
                  "collect",
                  [],
                  [
                    Ty.apply
                      (Ty.path "alloc::vec::Vec")
                      []
                      [
                        Ty.apply
                          (Ty.path "p3_matrix::dense::DenseMatrix")
                          []
                          [
                            F;
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              []
                              [ F; Ty.path "alloc::alloc::Global" ]
                          ];
                        Ty.path "alloc::alloc::Global"
                      ]
                  ]
                |),
                [
                  M.call_closure (|
                    Ty.apply
                      (Ty.path "core::iter::adapters::map::Map")
                      []
                      [
                        Ty.apply
                          (Ty.path "alloc::vec::into_iter::IntoIter")
                          []
                          [
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              []
                              [ F; Ty.path "alloc::alloc::Global" ];
                            Ty.path "alloc::alloc::Global"
                          ];
                        Ty.function
                          [
                            Ty.tuple
                              [
                                Ty.apply
                                  (Ty.path "alloc::vec::Vec")
                                  []
                                  [ F; Ty.path "alloc::alloc::Global" ]
                              ]
                          ]
                          (Ty.apply
                            (Ty.path "p3_matrix::dense::DenseMatrix")
                            []
                            [
                              F;
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                []
                                [ F; Ty.path "alloc::alloc::Global" ]
                            ])
                      ],
                    M.get_trait_method (|
                      "core::iter::traits::iterator::Iterator",
                      Ty.apply
                        (Ty.path "alloc::vec::into_iter::IntoIter")
                        []
                        [
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            []
                            [ F; Ty.path "alloc::alloc::Global" ];
                          Ty.path "alloc::alloc::Global"
                        ],
                      [],
                      [],
                      "map",
                      [],
                      [
                        Ty.apply
                          (Ty.path "p3_matrix::dense::DenseMatrix")
                          []
                          [
                            F;
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              []
                              [ F; Ty.path "alloc::alloc::Global" ]
                          ];
                        Ty.function
                          [
                            Ty.tuple
                              [
                                Ty.apply
                                  (Ty.path "alloc::vec::Vec")
                                  []
                                  [ F; Ty.path "alloc::alloc::Global" ]
                              ]
                          ]
                          (Ty.apply
                            (Ty.path "p3_matrix::dense::DenseMatrix")
                            []
                            [
                              F;
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                []
                                [ F; Ty.path "alloc::alloc::Global" ]
                            ])
                      ]
                    |),
                    [
                      M.call_closure (|
                        Ty.apply
                          (Ty.path "alloc::vec::into_iter::IntoIter")
                          []
                          [
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              []
                              [ F; Ty.path "alloc::alloc::Global" ];
                            Ty.path "alloc::alloc::Global"
                          ],
                        M.get_trait_method (|
                          "core::iter::traits::collect::IntoIterator",
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            []
                            [
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                []
                                [ F; Ty.path "alloc::alloc::Global" ];
                              Ty.path "alloc::alloc::Global"
                            ],
                          [],
                          [],
                          "into_iter",
                          [],
                          []
                        |),
                        [ M.read (| values |) ]
                      |);
                      M.closure
                        (fun γ =>
                          ltac:(M.monadic
                            match γ with
                            | [ α0 ] =>
                              ltac:(M.monadic
                                (M.match_operator (|
                                  Ty.apply
                                    (Ty.path "*")
                                    []
                                    [
                                      Ty.function
                                        [
                                          Ty.tuple
                                            [
                                              Ty.apply
                                                (Ty.path "alloc::vec::Vec")
                                                []
                                                [ F; Ty.path "alloc::alloc::Global" ]
                                            ]
                                        ]
                                        (Ty.apply
                                          (Ty.path "p3_matrix::dense::DenseMatrix")
                                          []
                                          [
                                            F;
                                            Ty.apply
                                              (Ty.path "alloc::vec::Vec")
                                              []
                                              [ F; Ty.path "alloc::alloc::Global" ]
                                          ])
                                    ],
                                  M.alloc (| α0 |),
                                  [
                                    fun γ =>
                                      ltac:(M.monadic
                                        (let v := M.copy (| γ |) in
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "p3_matrix::dense::DenseMatrix")
                                            []
                                            [
                                              F;
                                              Ty.apply
                                                (Ty.path "alloc::vec::Vec")
                                                []
                                                [ F; Ty.path "alloc::alloc::Global" ]
                                            ],
                                          M.get_associated_function (|
                                            Ty.apply
                                              (Ty.path "p3_matrix::dense::DenseMatrix")
                                              []
                                              [
                                                F;
                                                Ty.apply
                                                  (Ty.path "alloc::vec::Vec")
                                                  []
                                                  [ F; Ty.path "alloc::alloc::Global" ]
                                              ],
                                            "new",
                                            [],
                                            []
                                          |),
                                          [ M.read (| v |); M.read (| width |) ]
                                        |)))
                                  ]
                                |)))
                            | _ => M.impossible "wrong number of arguments"
                            end))
                    ]
                  |)
                ]
              |)
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn vanishing_poly_at_point<Ext: ExtensionField<Self::Val>>(&self, point: Ext) -> Ext {
            self.vanishing_poly(Point::from_projective_line(point))
        }
    *)
    Definition vanishing_poly_at_point
        (F : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self F in
      match ε, τ, α with
      | [], [ Ext ], [ self; point ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let point := M.alloc (| point |) in
          M.call_closure (|
            Ext,
            M.get_associated_function (|
              Ty.apply (Ty.path "p3_circle::domain::CircleDomain") [] [ F ],
              "vanishing_poly",
              [],
              [ Ext ]
            |),
            [
              M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
              M.call_closure (|
                Ty.apply (Ty.path "p3_circle::point::Point") [] [ Ext ],
                M.get_associated_function (|
                  Ty.apply (Ty.path "p3_circle::point::Point") [] [ Ext ],
                  "from_projective_line",
                  [],
                  []
                |),
                [ M.read (| point |) ]
              |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn selectors_at_point<Ext: ExtensionField<Self::Val>>(
            &self,
            point: Ext,
        ) -> LagrangeSelectors<Ext> {
            let point = Point::from_projective_line(point);
            LagrangeSelectors {
                is_first_row: self.s_p(self.shift, point),
                is_last_row: self.s_p(-self.shift, point),
                is_transition: Ext::ONE - self.s_p_normalized(-self.shift, point),
                inv_vanishing: self.vanishing_poly(point).inverse(),
            }
        }
    *)
    Definition selectors_at_point
        (F : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self F in
      match ε, τ, α with
      | [], [ Ext ], [ self; point ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let point := M.alloc (| point |) in
          M.read (|
            let~ point :
                Ty.apply
                  (Ty.path "*")
                  []
                  [ Ty.apply (Ty.path "p3_circle::point::Point") [] [ Ext ] ] :=
              M.alloc (|
                M.call_closure (|
                  Ty.apply (Ty.path "p3_circle::point::Point") [] [ Ext ],
                  M.get_associated_function (|
                    Ty.apply (Ty.path "p3_circle::point::Point") [] [ Ext ],
                    "from_projective_line",
                    [],
                    []
                  |),
                  [ M.read (| point |) ]
                |)
              |) in
            M.alloc (|
              Value.StructRecord
                "p3_commit::domain::LagrangeSelectors"
                [
                  ("is_first_row",
                    M.call_closure (|
                      Ext,
                      M.get_associated_function (|
                        Ty.apply (Ty.path "p3_circle::domain::CircleDomain") [] [ F ],
                        "s_p",
                        [],
                        [ Ext ]
                      |),
                      [
                        M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                        M.read (|
                          M.SubPointer.get_struct_record_field (|
                            M.deref (| M.read (| self |) |),
                            "p3_circle::domain::CircleDomain",
                            "shift"
                          |)
                        |);
                        M.read (| point |)
                      ]
                    |));
                  ("is_last_row",
                    M.call_closure (|
                      Ext,
                      M.get_associated_function (|
                        Ty.apply (Ty.path "p3_circle::domain::CircleDomain") [] [ F ],
                        "s_p",
                        [],
                        [ Ext ]
                      |),
                      [
                        M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                        M.call_closure (|
                          Ty.apply (Ty.path "p3_circle::point::Point") [] [ F ],
                          M.get_trait_method (|
                            "core::ops::arith::Neg",
                            Ty.apply (Ty.path "p3_circle::point::Point") [] [ F ],
                            [],
                            [],
                            "neg",
                            [],
                            []
                          |),
                          [
                            M.read (|
                              M.SubPointer.get_struct_record_field (|
                                M.deref (| M.read (| self |) |),
                                "p3_circle::domain::CircleDomain",
                                "shift"
                              |)
                            |)
                          ]
                        |);
                        M.read (| point |)
                      ]
                    |));
                  ("is_transition",
                    M.call_closure (|
                      Ext,
                      M.get_trait_method (|
                        "core::ops::arith::Sub",
                        Ext,
                        [],
                        [ Ext ],
                        "sub",
                        [],
                        []
                      |),
                      [
                        M.read (|
                          get_constant (| "p3_field::field::PrimeCharacteristicRing::ONE", Ext |)
                        |);
                        M.call_closure (|
                          Ext,
                          M.get_associated_function (|
                            Ty.apply (Ty.path "p3_circle::domain::CircleDomain") [] [ F ],
                            "s_p_normalized",
                            [],
                            [ Ext ]
                          |),
                          [
                            M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                            M.call_closure (|
                              Ty.apply (Ty.path "p3_circle::point::Point") [] [ F ],
                              M.get_trait_method (|
                                "core::ops::arith::Neg",
                                Ty.apply (Ty.path "p3_circle::point::Point") [] [ F ],
                                [],
                                [],
                                "neg",
                                [],
                                []
                              |),
                              [
                                M.read (|
                                  M.SubPointer.get_struct_record_field (|
                                    M.deref (| M.read (| self |) |),
                                    "p3_circle::domain::CircleDomain",
                                    "shift"
                                  |)
                                |)
                              ]
                            |);
                            M.read (| point |)
                          ]
                        |)
                      ]
                    |));
                  ("inv_vanishing",
                    M.call_closure (|
                      Ext,
                      M.get_trait_method (|
                        "p3_field::field::Field",
                        Ext,
                        [],
                        [],
                        "inverse",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.alloc (|
                            M.call_closure (|
                              Ext,
                              M.get_associated_function (|
                                Ty.apply (Ty.path "p3_circle::domain::CircleDomain") [] [ F ],
                                "vanishing_poly",
                                [],
                                [ Ext ]
                              |),
                              [
                                M.borrow (| Pointer.Kind.Ref, M.deref (| M.read (| self |) |) |);
                                M.read (| point |)
                              ]
                            |)
                          |)
                        |)
                      ]
                    |))
                ]
            |)
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*     #[instrument(skip_all, fields(log_n = %coset.log_n))] *)
    Definition selectors_on_coset
        (F : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self F in
      match ε, τ, α with
      | [], [], [ self; coset ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let coset := M.alloc (| coset |) in
          M.catch_return
            (Ty.apply
              (Ty.path "p3_commit::domain::LagrangeSelectors")
              []
              [
                Ty.apply
                  (Ty.path "alloc::vec::Vec")
                  []
                  [
                    Ty.associated_in_trait
                      "p3_commit::domain::PolynomialSpace"
                      []
                      []
                      (Ty.apply (Ty.path "p3_circle::domain::CircleDomain") [] [ F ])
                      "Val";
                    Ty.path "alloc::alloc::Global"
                  ]
              ]) (|
            ltac:(M.monadic
              (M.read (|
                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                  M.alloc (| Value.Tuple [] |) in
                let __tracing_attr_span := M.copy (| Value.DeclaredButUndefined |) in
                let __tracing_attr_guard := M.copy (| Value.DeclaredButUndefined |) in
                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                  M.match_operator (|
                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ :=
                            M.use
                              (M.alloc (|
                                LogicalOp.or (|
                                  LogicalOp.and (|
                                    M.call_closure (|
                                      Ty.path "bool",
                                      M.get_trait_method (|
                                        "core::cmp::PartialOrd",
                                        Ty.path "tracing_core::metadata::Level",
                                        [],
                                        [ Ty.path "tracing_core::metadata::LevelFilter" ],
                                        "le",
                                        [],
                                        []
                                      |),
                                      [
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          get_associated_constant (|
                                            Ty.path "tracing_core::metadata::Level",
                                            "INFO",
                                            Ty.path "tracing_core::metadata::Level"
                                          |)
                                        |);
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          get_constant (|
                                            "tracing::level_filters::STATIC_MAX_LEVEL",
                                            Ty.path "tracing_core::metadata::LevelFilter"
                                          |)
                                        |)
                                      ]
                                    |),
                                    ltac:(M.monadic
                                      (M.call_closure (|
                                        Ty.path "bool",
                                        M.get_trait_method (|
                                          "core::cmp::PartialOrd",
                                          Ty.path "tracing_core::metadata::Level",
                                          [],
                                          [ Ty.path "tracing_core::metadata::LevelFilter" ],
                                          "le",
                                          [],
                                          []
                                        |),
                                        [
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            get_associated_constant (|
                                              Ty.path "tracing_core::metadata::Level",
                                              "INFO",
                                              Ty.path "tracing_core::metadata::Level"
                                            |)
                                          |);
                                          M.borrow (|
                                            Pointer.Kind.Ref,
                                            M.alloc (|
                                              M.call_closure (|
                                                Ty.path "tracing_core::metadata::LevelFilter",
                                                M.get_associated_function (|
                                                  Ty.path "tracing_core::metadata::LevelFilter",
                                                  "current",
                                                  [],
                                                  []
                                                |),
                                                []
                                              |)
                                            |)
                                          |)
                                        ]
                                      |)))
                                  |),
                                  ltac:(M.monadic (Value.Bool false))
                                |)
                              |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                            M.alloc (|
                              M.write (|
                                __tracing_attr_span,
                                M.read (|
                                  let~ interest :
                                      Ty.apply
                                        (Ty.path "*")
                                        []
                                        [ Ty.path "tracing_core::subscriber::Interest" ] :=
                                    M.alloc (|
                                      M.call_closure (|
                                        Ty.path "tracing_core::subscriber::Interest",
                                        M.get_associated_function (|
                                          Ty.path "tracing_core::subscriber::Interest",
                                          "never",
                                          [],
                                          []
                                        |),
                                        []
                                      |)
                                    |) in
                                  M.match_operator (|
                                    Ty.apply (Ty.path "*") [] [ Ty.path "tracing::span::Span" ],
                                    M.alloc (| Value.Tuple [] |),
                                    [
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let γ :=
                                            M.use
                                              (M.alloc (|
                                                LogicalOp.and (|
                                                  LogicalOp.and (|
                                                    LogicalOp.and (|
                                                      M.call_closure (|
                                                        Ty.path "bool",
                                                        M.get_trait_method (|
                                                          "core::cmp::PartialOrd",
                                                          Ty.path "tracing_core::metadata::Level",
                                                          [],
                                                          [
                                                            Ty.path
                                                              "tracing_core::metadata::LevelFilter"
                                                          ],
                                                          "le",
                                                          [],
                                                          []
                                                        |),
                                                        [
                                                          M.borrow (|
                                                            Pointer.Kind.Ref,
                                                            get_associated_constant (|
                                                              Ty.path
                                                                "tracing_core::metadata::Level",
                                                              "INFO",
                                                              Ty.path
                                                                "tracing_core::metadata::Level"
                                                            |)
                                                          |);
                                                          M.borrow (|
                                                            Pointer.Kind.Ref,
                                                            get_constant (|
                                                              "tracing::level_filters::STATIC_MAX_LEVEL",
                                                              Ty.path
                                                                "tracing_core::metadata::LevelFilter"
                                                            |)
                                                          |)
                                                        ]
                                                      |),
                                                      ltac:(M.monadic
                                                        (M.call_closure (|
                                                          Ty.path "bool",
                                                          M.get_trait_method (|
                                                            "core::cmp::PartialOrd",
                                                            Ty.path "tracing_core::metadata::Level",
                                                            [],
                                                            [
                                                              Ty.path
                                                                "tracing_core::metadata::LevelFilter"
                                                            ],
                                                            "le",
                                                            [],
                                                            []
                                                          |),
                                                          [
                                                            M.borrow (|
                                                              Pointer.Kind.Ref,
                                                              get_associated_constant (|
                                                                Ty.path
                                                                  "tracing_core::metadata::Level",
                                                                "INFO",
                                                                Ty.path
                                                                  "tracing_core::metadata::Level"
                                                              |)
                                                            |);
                                                            M.borrow (|
                                                              Pointer.Kind.Ref,
                                                              M.alloc (|
                                                                M.call_closure (|
                                                                  Ty.path
                                                                    "tracing_core::metadata::LevelFilter",
                                                                  M.get_associated_function (|
                                                                    Ty.path
                                                                      "tracing_core::metadata::LevelFilter",
                                                                    "current",
                                                                    [],
                                                                    []
                                                                  |),
                                                                  []
                                                                |)
                                                              |)
                                                            |)
                                                          ]
                                                        |)))
                                                    |),
                                                    ltac:(M.monadic
                                                      (M.read (|
                                                        let~ _ :
                                                            Ty.apply
                                                              (Ty.path "*")
                                                              []
                                                              [ Ty.tuple [] ] :=
                                                          M.alloc (|
                                                            M.write (|
                                                              interest,
                                                              M.call_closure (|
                                                                Ty.path
                                                                  "tracing_core::subscriber::Interest",
                                                                M.get_associated_function (|
                                                                  Ty.path
                                                                    "tracing_core::callsite::DefaultCallsite",
                                                                  "interest",
                                                                  [],
                                                                  []
                                                                |),
                                                                [
                                                                  M.borrow (|
                                                                    Pointer.Kind.Ref,
                                                                    M.deref (|
                                                                      M.read (|
                                                                        get_constant (|
                                                                          "p3_circle::domain::selectors_on_coset::__CALLSITE",
                                                                          Ty.apply
                                                                            (Ty.path "&")
                                                                            []
                                                                            [
                                                                              Ty.path
                                                                                "tracing_core::callsite::DefaultCallsite"
                                                                            ]
                                                                        |)
                                                                      |)
                                                                    |)
                                                                  |)
                                                                ]
                                                              |)
                                                            |)
                                                          |) in
                                                        M.alloc (|
                                                          UnOp.not (|
                                                            M.call_closure (|
                                                              Ty.path "bool",
                                                              M.get_associated_function (|
                                                                Ty.path
                                                                  "tracing_core::subscriber::Interest",
                                                                "is_never",
                                                                [],
                                                                []
                                                              |),
                                                              [
                                                                M.borrow (|
                                                                  Pointer.Kind.Ref,
                                                                  interest
                                                                |)
                                                              ]
                                                            |)
                                                          |)
                                                        |)
                                                      |)))
                                                  |),
                                                  ltac:(M.monadic
                                                    (M.call_closure (|
                                                      Ty.path "bool",
                                                      M.get_function (|
                                                        "tracing::__macro_support::__is_enabled",
                                                        [],
                                                        []
                                                      |),
                                                      [
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.deref (|
                                                            M.call_closure (|
                                                              Ty.apply
                                                                (Ty.path "&")
                                                                []
                                                                [
                                                                  Ty.path
                                                                    "tracing_core::metadata::Metadata"
                                                                ],
                                                              M.get_trait_method (|
                                                                "tracing_core::callsite::Callsite",
                                                                Ty.path
                                                                  "tracing_core::callsite::DefaultCallsite",
                                                                [],
                                                                [],
                                                                "metadata",
                                                                [],
                                                                []
                                                              |),
                                                              [
                                                                M.borrow (|
                                                                  Pointer.Kind.Ref,
                                                                  M.deref (|
                                                                    M.read (|
                                                                      get_constant (|
                                                                        "p3_circle::domain::selectors_on_coset::__CALLSITE",
                                                                        Ty.apply
                                                                          (Ty.path "&")
                                                                          []
                                                                          [
                                                                            Ty.path
                                                                              "tracing_core::callsite::DefaultCallsite"
                                                                          ]
                                                                      |)
                                                                    |)
                                                                  |)
                                                                |)
                                                              ]
                                                            |)
                                                          |)
                                                        |);
                                                        M.read (| interest |)
                                                      ]
                                                    |)))
                                                |)
                                              |)) in
                                          let _ :=
                                            is_constant_or_break_match (|
                                              M.read (| γ |),
                                              Value.Bool true
                                            |) in
                                          let~ meta :
                                              Ty.apply
                                                (Ty.path "*")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "&")
                                                    []
                                                    [ Ty.path "tracing_core::metadata::Metadata" ]
                                                ] :=
                                            M.alloc (|
                                              M.call_closure (|
                                                Ty.apply
                                                  (Ty.path "&")
                                                  []
                                                  [ Ty.path "tracing_core::metadata::Metadata" ],
                                                M.get_trait_method (|
                                                  "tracing_core::callsite::Callsite",
                                                  Ty.path "tracing_core::callsite::DefaultCallsite",
                                                  [],
                                                  [],
                                                  "metadata",
                                                  [],
                                                  []
                                                |),
                                                [
                                                  M.borrow (|
                                                    Pointer.Kind.Ref,
                                                    M.deref (|
                                                      M.read (|
                                                        get_constant (|
                                                          "p3_circle::domain::selectors_on_coset::__CALLSITE",
                                                          Ty.apply
                                                            (Ty.path "&")
                                                            []
                                                            [
                                                              Ty.path
                                                                "tracing_core::callsite::DefaultCallsite"
                                                            ]
                                                        |)
                                                      |)
                                                    |)
                                                  |)
                                                ]
                                              |)
                                            |) in
                                          M.alloc (|
                                            M.call_closure (|
                                              Ty.path "tracing::span::Span",
                                              M.get_associated_function (|
                                                Ty.path "tracing::span::Span",
                                                "new",
                                                [],
                                                []
                                              |),
                                              [
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (| M.read (| meta |) |)
                                                |);
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.deref (|
                                                    M.borrow (|
                                                      Pointer.Kind.Ref,
                                                      let~ iter :
                                                          Ty.apply
                                                            (Ty.path "*")
                                                            []
                                                            [ Ty.path "tracing_core::field::Iter"
                                                            ] :=
                                                        M.alloc (|
                                                          M.call_closure (|
                                                            Ty.path "tracing_core::field::Iter",
                                                            M.get_associated_function (|
                                                              Ty.path
                                                                "tracing_core::field::FieldSet",
                                                              "iter",
                                                              [],
                                                              []
                                                            |),
                                                            [
                                                              M.borrow (|
                                                                Pointer.Kind.Ref,
                                                                M.deref (|
                                                                  M.call_closure (|
                                                                    Ty.apply
                                                                      (Ty.path "&")
                                                                      []
                                                                      [
                                                                        Ty.path
                                                                          "tracing_core::field::FieldSet"
                                                                      ],
                                                                    M.get_associated_function (|
                                                                      Ty.path
                                                                        "tracing_core::metadata::Metadata",
                                                                      "fields",
                                                                      [],
                                                                      []
                                                                    |),
                                                                    [
                                                                      M.borrow (|
                                                                        Pointer.Kind.Ref,
                                                                        M.deref (|
                                                                          M.read (| meta |)
                                                                        |)
                                                                      |)
                                                                    ]
                                                                  |)
                                                                |)
                                                              |)
                                                            ]
                                                          |)
                                                        |) in
                                                      M.alloc (|
                                                        M.call_closure (|
                                                          Ty.path "tracing_core::field::ValueSet",
                                                          M.get_associated_function (|
                                                            Ty.path "tracing_core::field::FieldSet",
                                                            "value_set",
                                                            [],
                                                            [
                                                              Ty.apply
                                                                (Ty.path "array")
                                                                [ Value.Integer IntegerKind.Usize 1
                                                                ]
                                                                [
                                                                  Ty.tuple
                                                                    [
                                                                      Ty.apply
                                                                        (Ty.path "&")
                                                                        []
                                                                        [
                                                                          Ty.path
                                                                            "tracing_core::field::Field"
                                                                        ];
                                                                      Ty.apply
                                                                        (Ty.path
                                                                          "core::option::Option")
                                                                        []
                                                                        [
                                                                          Ty.apply
                                                                            (Ty.path "&")
                                                                            []
                                                                            [
                                                                              Ty.dyn
                                                                                [
                                                                                  ("tracing_core::field::Value::Trait",
                                                                                    [])
                                                                                ]
                                                                            ]
                                                                        ]
                                                                    ]
                                                                ]
                                                            ]
                                                          |),
                                                          [
                                                            M.borrow (|
                                                              Pointer.Kind.Ref,
                                                              M.deref (|
                                                                M.call_closure (|
                                                                  Ty.apply
                                                                    (Ty.path "&")
                                                                    []
                                                                    [
                                                                      Ty.path
                                                                        "tracing_core::field::FieldSet"
                                                                    ],
                                                                  M.get_associated_function (|
                                                                    Ty.path
                                                                      "tracing_core::metadata::Metadata",
                                                                    "fields",
                                                                    [],
                                                                    []
                                                                  |),
                                                                  [
                                                                    M.borrow (|
                                                                      Pointer.Kind.Ref,
                                                                      M.deref (|
                                                                        M.read (| meta |)
                                                                      |)
                                                                    |)
                                                                  ]
                                                                |)
                                                              |)
                                                            |);
                                                            M.borrow (|
                                                              Pointer.Kind.Ref,
                                                              M.deref (|
                                                                M.borrow (|
                                                                  Pointer.Kind.Ref,
                                                                  M.alloc (|
                                                                    Value.Array
                                                                      [
                                                                        Value.Tuple
                                                                          [
                                                                            M.borrow (|
                                                                              Pointer.Kind.Ref,
                                                                              M.alloc (|
                                                                                M.call_closure (|
                                                                                  Ty.path
                                                                                    "tracing_core::field::Field",
                                                                                  M.get_associated_function (|
                                                                                    Ty.apply
                                                                                      (Ty.path
                                                                                        "core::option::Option")
                                                                                      []
                                                                                      [
                                                                                        Ty.path
                                                                                          "tracing_core::field::Field"
                                                                                      ],
                                                                                    "expect",
                                                                                    [],
                                                                                    []
                                                                                  |),
                                                                                  [
                                                                                    M.call_closure (|
                                                                                      Ty.apply
                                                                                        (Ty.path
                                                                                          "core::option::Option")
                                                                                        []
                                                                                        [
                                                                                          Ty.path
                                                                                            "tracing_core::field::Field"
                                                                                        ],
                                                                                      M.get_trait_method (|
                                                                                        "core::iter::traits::iterator::Iterator",
                                                                                        Ty.path
                                                                                          "tracing_core::field::Iter",
                                                                                        [],
                                                                                        [],
                                                                                        "next",
                                                                                        [],
                                                                                        []
                                                                                      |),
                                                                                      [
                                                                                        M.borrow (|
                                                                                          Pointer.Kind.MutRef,
                                                                                          M.deref (|
                                                                                            M.borrow (|
                                                                                              Pointer.Kind.MutRef,
                                                                                              iter
                                                                                            |)
                                                                                          |)
                                                                                        |)
                                                                                      ]
                                                                                    |);
                                                                                    M.borrow (|
                                                                                      Pointer.Kind.Ref,
                                                                                      M.deref (|
                                                                                        mk_str (|
                                                                                          "FieldSet corrupted (this is a bug)"
                                                                                        |)
                                                                                      |)
                                                                                    |)
                                                                                  ]
                                                                                |)
                                                                              |)
                                                                            |);
                                                                            Value.StructTuple
                                                                              "core::option::Option::Some"
                                                                              [
                                                                                M.read (|
                                                                                  M.use
                                                                                    (M.alloc (|
                                                                                      (* Unsize *)
                                                                                      M.pointer_coercion
                                                                                        (M.borrow (|
                                                                                          Pointer.Kind.Ref,
                                                                                          M.deref (|
                                                                                            M.borrow (|
                                                                                              Pointer.Kind.Ref,
                                                                                              M.alloc (|
                                                                                                M.call_closure (|
                                                                                                  Ty.apply
                                                                                                    (Ty.path
                                                                                                      "tracing_core::field::DisplayValue")
                                                                                                    []
                                                                                                    [
                                                                                                      Ty.apply
                                                                                                        (Ty.path
                                                                                                          "&")
                                                                                                        []
                                                                                                        [
                                                                                                          Ty.path
                                                                                                            "usize"
                                                                                                        ]
                                                                                                    ],
                                                                                                  M.get_function (|
                                                                                                    "tracing_core::field::display",
                                                                                                    [],
                                                                                                    [
                                                                                                      Ty.apply
                                                                                                        (Ty.path
                                                                                                          "&")
                                                                                                        []
                                                                                                        [
                                                                                                          Ty.path
                                                                                                            "usize"
                                                                                                        ]
                                                                                                    ]
                                                                                                  |),
                                                                                                  [
                                                                                                    M.borrow (|
                                                                                                      Pointer.Kind.Ref,
                                                                                                      M.SubPointer.get_struct_record_field (|
                                                                                                        coset,
                                                                                                        "p3_circle::domain::CircleDomain",
                                                                                                        "log_n"
                                                                                                      |)
                                                                                                    |)
                                                                                                  ]
                                                                                                |)
                                                                                              |)
                                                                                            |)
                                                                                          |)
                                                                                        |))
                                                                                    |))
                                                                                |)
                                                                              ]
                                                                          ]
                                                                      ]
                                                                  |)
                                                                |)
                                                              |)
                                                            |)
                                                          ]
                                                        |)
                                                      |)
                                                    |)
                                                  |)
                                                |)
                                              ]
                                            |)
                                          |)));
                                      fun γ =>
                                        ltac:(M.monadic
                                          (let~ span :
                                              Ty.apply
                                                (Ty.path "*")
                                                []
                                                [ Ty.path "tracing::span::Span" ] :=
                                            M.alloc (|
                                              M.call_closure (|
                                                Ty.path "tracing::span::Span",
                                                M.get_function (|
                                                  "tracing::__macro_support::__disabled_span",
                                                  [],
                                                  []
                                                |),
                                                [
                                                  M.borrow (|
                                                    Pointer.Kind.Ref,
                                                    M.deref (|
                                                      M.call_closure (|
                                                        Ty.apply
                                                          (Ty.path "&")
                                                          []
                                                          [
                                                            Ty.path
                                                              "tracing_core::metadata::Metadata"
                                                          ],
                                                        M.get_trait_method (|
                                                          "tracing_core::callsite::Callsite",
                                                          Ty.path
                                                            "tracing_core::callsite::DefaultCallsite",
                                                          [],
                                                          [],
                                                          "metadata",
                                                          [],
                                                          []
                                                        |),
                                                        [
                                                          M.borrow (|
                                                            Pointer.Kind.Ref,
                                                            M.deref (|
                                                              M.read (|
                                                                get_constant (|
                                                                  "p3_circle::domain::selectors_on_coset::__CALLSITE",
                                                                  Ty.apply
                                                                    (Ty.path "&")
                                                                    []
                                                                    [
                                                                      Ty.path
                                                                        "tracing_core::callsite::DefaultCallsite"
                                                                    ]
                                                                |)
                                                              |)
                                                            |)
                                                          |)
                                                        ]
                                                      |)
                                                    |)
                                                  |)
                                                ]
                                              |)
                                            |) in
                                          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                                            M.alloc (| Value.Tuple [] |) in
                                          span))
                                    ]
                                  |)
                                |)
                              |)
                            |) in
                          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                            M.alloc (|
                              M.write (|
                                __tracing_attr_guard,
                                M.call_closure (|
                                  Ty.path "tracing::span::Entered",
                                  M.get_associated_function (|
                                    Ty.path "tracing::span::Span",
                                    "enter",
                                    [],
                                    []
                                  |),
                                  [ M.borrow (| Pointer.Kind.Ref, __tracing_attr_span |) ]
                                |)
                              |)
                            |) in
                          M.alloc (| Value.Tuple [] |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
                  M.match_operator (|
                    Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                    M.alloc (| Value.Tuple [] |),
                    [
                      fun γ =>
                        ltac:(M.monadic
                          (let γ := M.use (M.alloc (| Value.Bool false |)) in
                          let _ :=
                            is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                          M.alloc (|
                            M.never_to_any (|
                              M.read (|
                                let~ __tracing_attr_fake_return :
                                    Ty.apply
                                      (Ty.path "*")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "p3_commit::domain::LagrangeSelectors")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "alloc::vec::Vec")
                                              []
                                              [ F; Ty.path "alloc::alloc::Global" ]
                                          ]
                                      ] :=
                                  M.alloc (|
                                    M.never_to_any (|
                                      M.read (|
                                        M.loop (|
                                          Ty.apply (Ty.path "*") [] [ Ty.path "never" ],
                                          ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                                        |)
                                      |)
                                    |)
                                  |) in
                                M.return_ (| M.read (| __tracing_attr_fake_return |) |)
                              |)
                            |)
                          |)));
                      fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                    ]
                  |) in
                let~ sels :
                    Ty.apply
                      (Ty.path "*")
                      []
                      [
                        Ty.apply
                          (Ty.path "alloc::vec::Vec")
                          []
                          [
                            Ty.apply (Ty.path "p3_commit::domain::LagrangeSelectors") [] [ F ];
                            Ty.path "alloc::alloc::Global"
                          ]
                      ] :=
                  M.alloc (|
                    M.call_closure (|
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        []
                        [
                          Ty.apply (Ty.path "p3_commit::domain::LagrangeSelectors") [] [ F ];
                          Ty.path "alloc::alloc::Global"
                        ],
                      M.get_trait_method (|
                        "itertools::Itertools",
                        Ty.apply
                          (Ty.path "core::iter::adapters::map::Map")
                          []
                          [
                            Ty.associated_unknown;
                            Ty.function
                              [ Ty.tuple [ Ty.apply (Ty.path "p3_circle::point::Point") [] [ F ] ] ]
                              (Ty.apply (Ty.path "p3_commit::domain::LagrangeSelectors") [] [ F ])
                          ],
                        [],
                        [],
                        "collect_vec",
                        [],
                        []
                      |),
                      [
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "core::iter::adapters::map::Map")
                            []
                            [
                              Ty.associated_unknown;
                              Ty.function
                                [ Ty.tuple [ Ty.apply (Ty.path "p3_circle::point::Point") [] [ F ] ]
                                ]
                                (Ty.apply (Ty.path "p3_commit::domain::LagrangeSelectors") [] [ F ])
                            ],
                          M.get_trait_method (|
                            "core::iter::traits::iterator::Iterator",
                            Ty.associated_unknown,
                            [],
                            [],
                            "map",
                            [],
                            [
                              Ty.apply (Ty.path "p3_commit::domain::LagrangeSelectors") [] [ F ];
                              Ty.function
                                [ Ty.tuple [ Ty.apply (Ty.path "p3_circle::point::Point") [] [ F ] ]
                                ]
                                (Ty.apply (Ty.path "p3_commit::domain::LagrangeSelectors") [] [ F ])
                            ]
                          |),
                          [
                            M.call_closure (|
                              Ty.associated_unknown,
                              M.get_associated_function (|
                                Ty.apply (Ty.path "p3_circle::domain::CircleDomain") [] [ F ],
                                "points",
                                [],
                                []
                              |),
                              [ M.borrow (| Pointer.Kind.Ref, coset |) ]
                            |);
                            M.closure
                              (fun γ =>
                                ltac:(M.monadic
                                  match γ with
                                  | [ α0 ] =>
                                    ltac:(M.monadic
                                      (M.match_operator (|
                                        Ty.apply
                                          (Ty.path "*")
                                          []
                                          [
                                            Ty.function
                                              [
                                                Ty.tuple
                                                  [
                                                    Ty.apply
                                                      (Ty.path "p3_circle::point::Point")
                                                      []
                                                      [ F ]
                                                  ]
                                              ]
                                              (Ty.apply
                                                (Ty.path "p3_commit::domain::LagrangeSelectors")
                                                []
                                                [ F ])
                                          ],
                                        M.alloc (| α0 |),
                                        [
                                          fun γ =>
                                            ltac:(M.monadic
                                              (let p := M.copy (| γ |) in
                                              M.call_closure (|
                                                Ty.apply
                                                  (Ty.path "p3_commit::domain::LagrangeSelectors")
                                                  []
                                                  [ F ],
                                                M.get_trait_method (|
                                                  "p3_commit::domain::PolynomialSpace",
                                                  Ty.apply
                                                    (Ty.path "p3_circle::domain::CircleDomain")
                                                    []
                                                    [ F ],
                                                  [],
                                                  [],
                                                  "selectors_at_point",
                                                  [],
                                                  [ F ]
                                                |),
                                                [
                                                  M.borrow (|
                                                    Pointer.Kind.Ref,
                                                    M.deref (| M.read (| self |) |)
                                                  |);
                                                  M.call_closure (|
                                                    F,
                                                    M.get_associated_function (|
                                                      Ty.apply
                                                        (Ty.path "core::option::Option")
                                                        []
                                                        [ F ],
                                                      "unwrap",
                                                      [],
                                                      []
                                                    |),
                                                    [
                                                      M.call_closure (|
                                                        Ty.apply
                                                          (Ty.path "core::option::Option")
                                                          []
                                                          [ F ],
                                                        M.get_associated_function (|
                                                          Ty.apply
                                                            (Ty.path "p3_circle::point::Point")
                                                            []
                                                            [ F ],
                                                          "to_projective_line",
                                                          [],
                                                          []
                                                        |),
                                                        [ M.read (| p |) ]
                                                      |)
                                                    ]
                                                  |)
                                                ]
                                              |)))
                                        ]
                                      |)))
                                  | _ => M.impossible "wrong number of arguments"
                                  end))
                          ]
                        |)
                      ]
                    |)
                  |) in
                M.alloc (|
                  Value.StructRecord
                    "p3_commit::domain::LagrangeSelectors"
                    [
                      ("is_first_row",
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            []
                            [ F; Ty.path "alloc::alloc::Global" ],
                          M.get_trait_method (|
                            "core::iter::traits::iterator::Iterator",
                            Ty.apply
                              (Ty.path "core::iter::adapters::map::Map")
                              []
                              [
                                Ty.apply
                                  (Ty.path "core::slice::iter::Iter")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "p3_commit::domain::LagrangeSelectors")
                                      []
                                      [ F ]
                                  ];
                                Ty.function
                                  [
                                    Ty.tuple
                                      [
                                        Ty.apply
                                          (Ty.path "&")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "p3_commit::domain::LagrangeSelectors")
                                              []
                                              [ F ]
                                          ]
                                      ]
                                  ]
                                  F
                              ],
                            [],
                            [],
                            "collect",
                            [],
                            [
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                []
                                [ F; Ty.path "alloc::alloc::Global" ]
                            ]
                          |),
                          [
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "core::iter::adapters::map::Map")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "core::slice::iter::Iter")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "p3_commit::domain::LagrangeSelectors")
                                        []
                                        [ F ]
                                    ];
                                  Ty.function
                                    [
                                      Ty.tuple
                                        [
                                          Ty.apply
                                            (Ty.path "&")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "p3_commit::domain::LagrangeSelectors")
                                                []
                                                [ F ]
                                            ]
                                        ]
                                    ]
                                    F
                                ],
                              M.get_trait_method (|
                                "core::iter::traits::iterator::Iterator",
                                Ty.apply
                                  (Ty.path "core::slice::iter::Iter")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "p3_commit::domain::LagrangeSelectors")
                                      []
                                      [ F ]
                                  ],
                                [],
                                [],
                                "map",
                                [],
                                [
                                  F;
                                  Ty.function
                                    [
                                      Ty.tuple
                                        [
                                          Ty.apply
                                            (Ty.path "&")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "p3_commit::domain::LagrangeSelectors")
                                                []
                                                [ F ]
                                            ]
                                        ]
                                    ]
                                    F
                                ]
                              |),
                              [
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "core::slice::iter::Iter")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "p3_commit::domain::LagrangeSelectors")
                                        []
                                        [ F ]
                                    ],
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "slice")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "p3_commit::domain::LagrangeSelectors")
                                          []
                                          [ F ]
                                      ],
                                    "iter",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (|
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "&")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "slice")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "p3_commit::domain::LagrangeSelectors")
                                                    []
                                                    [ F ]
                                                ]
                                            ],
                                          M.get_trait_method (|
                                            "core::ops::deref::Deref",
                                            Ty.apply
                                              (Ty.path "alloc::vec::Vec")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "p3_commit::domain::LagrangeSelectors")
                                                  []
                                                  [ F ];
                                                Ty.path "alloc::alloc::Global"
                                              ],
                                            [],
                                            [],
                                            "deref",
                                            [],
                                            []
                                          |),
                                          [ M.borrow (| Pointer.Kind.Ref, sels |) ]
                                        |)
                                      |)
                                    |)
                                  ]
                                |);
                                M.closure
                                  (fun γ =>
                                    ltac:(M.monadic
                                      match γ with
                                      | [ α0 ] =>
                                        ltac:(M.monadic
                                          (M.match_operator (|
                                            Ty.apply
                                              (Ty.path "*")
                                              []
                                              [
                                                Ty.function
                                                  [
                                                    Ty.tuple
                                                      [
                                                        Ty.apply
                                                          (Ty.path "&")
                                                          []
                                                          [
                                                            Ty.apply
                                                              (Ty.path
                                                                "p3_commit::domain::LagrangeSelectors")
                                                              []
                                                              [ F ]
                                                          ]
                                                      ]
                                                  ]
                                                  F
                                              ],
                                            M.alloc (| α0 |),
                                            [
                                              fun γ =>
                                                ltac:(M.monadic
                                                  (let s := M.copy (| γ |) in
                                                  M.read (|
                                                    M.SubPointer.get_struct_record_field (|
                                                      M.deref (| M.read (| s |) |),
                                                      "p3_commit::domain::LagrangeSelectors",
                                                      "is_first_row"
                                                    |)
                                                  |)))
                                            ]
                                          |)))
                                      | _ => M.impossible "wrong number of arguments"
                                      end))
                              ]
                            |)
                          ]
                        |));
                      ("is_last_row",
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            []
                            [ F; Ty.path "alloc::alloc::Global" ],
                          M.get_trait_method (|
                            "core::iter::traits::iterator::Iterator",
                            Ty.apply
                              (Ty.path "core::iter::adapters::map::Map")
                              []
                              [
                                Ty.apply
                                  (Ty.path "core::slice::iter::Iter")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "p3_commit::domain::LagrangeSelectors")
                                      []
                                      [ F ]
                                  ];
                                Ty.function
                                  [
                                    Ty.tuple
                                      [
                                        Ty.apply
                                          (Ty.path "&")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "p3_commit::domain::LagrangeSelectors")
                                              []
                                              [ F ]
                                          ]
                                      ]
                                  ]
                                  F
                              ],
                            [],
                            [],
                            "collect",
                            [],
                            [
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                []
                                [ F; Ty.path "alloc::alloc::Global" ]
                            ]
                          |),
                          [
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "core::iter::adapters::map::Map")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "core::slice::iter::Iter")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "p3_commit::domain::LagrangeSelectors")
                                        []
                                        [ F ]
                                    ];
                                  Ty.function
                                    [
                                      Ty.tuple
                                        [
                                          Ty.apply
                                            (Ty.path "&")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "p3_commit::domain::LagrangeSelectors")
                                                []
                                                [ F ]
                                            ]
                                        ]
                                    ]
                                    F
                                ],
                              M.get_trait_method (|
                                "core::iter::traits::iterator::Iterator",
                                Ty.apply
                                  (Ty.path "core::slice::iter::Iter")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "p3_commit::domain::LagrangeSelectors")
                                      []
                                      [ F ]
                                  ],
                                [],
                                [],
                                "map",
                                [],
                                [
                                  F;
                                  Ty.function
                                    [
                                      Ty.tuple
                                        [
                                          Ty.apply
                                            (Ty.path "&")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "p3_commit::domain::LagrangeSelectors")
                                                []
                                                [ F ]
                                            ]
                                        ]
                                    ]
                                    F
                                ]
                              |),
                              [
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "core::slice::iter::Iter")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "p3_commit::domain::LagrangeSelectors")
                                        []
                                        [ F ]
                                    ],
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "slice")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "p3_commit::domain::LagrangeSelectors")
                                          []
                                          [ F ]
                                      ],
                                    "iter",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (|
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "&")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "slice")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "p3_commit::domain::LagrangeSelectors")
                                                    []
                                                    [ F ]
                                                ]
                                            ],
                                          M.get_trait_method (|
                                            "core::ops::deref::Deref",
                                            Ty.apply
                                              (Ty.path "alloc::vec::Vec")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "p3_commit::domain::LagrangeSelectors")
                                                  []
                                                  [ F ];
                                                Ty.path "alloc::alloc::Global"
                                              ],
                                            [],
                                            [],
                                            "deref",
                                            [],
                                            []
                                          |),
                                          [ M.borrow (| Pointer.Kind.Ref, sels |) ]
                                        |)
                                      |)
                                    |)
                                  ]
                                |);
                                M.closure
                                  (fun γ =>
                                    ltac:(M.monadic
                                      match γ with
                                      | [ α0 ] =>
                                        ltac:(M.monadic
                                          (M.match_operator (|
                                            Ty.apply
                                              (Ty.path "*")
                                              []
                                              [
                                                Ty.function
                                                  [
                                                    Ty.tuple
                                                      [
                                                        Ty.apply
                                                          (Ty.path "&")
                                                          []
                                                          [
                                                            Ty.apply
                                                              (Ty.path
                                                                "p3_commit::domain::LagrangeSelectors")
                                                              []
                                                              [ F ]
                                                          ]
                                                      ]
                                                  ]
                                                  F
                                              ],
                                            M.alloc (| α0 |),
                                            [
                                              fun γ =>
                                                ltac:(M.monadic
                                                  (let s := M.copy (| γ |) in
                                                  M.read (|
                                                    M.SubPointer.get_struct_record_field (|
                                                      M.deref (| M.read (| s |) |),
                                                      "p3_commit::domain::LagrangeSelectors",
                                                      "is_last_row"
                                                    |)
                                                  |)))
                                            ]
                                          |)))
                                      | _ => M.impossible "wrong number of arguments"
                                      end))
                              ]
                            |)
                          ]
                        |));
                      ("is_transition",
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            []
                            [ F; Ty.path "alloc::alloc::Global" ],
                          M.get_trait_method (|
                            "core::iter::traits::iterator::Iterator",
                            Ty.apply
                              (Ty.path "core::iter::adapters::map::Map")
                              []
                              [
                                Ty.apply
                                  (Ty.path "core::slice::iter::Iter")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "p3_commit::domain::LagrangeSelectors")
                                      []
                                      [ F ]
                                  ];
                                Ty.function
                                  [
                                    Ty.tuple
                                      [
                                        Ty.apply
                                          (Ty.path "&")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "p3_commit::domain::LagrangeSelectors")
                                              []
                                              [ F ]
                                          ]
                                      ]
                                  ]
                                  F
                              ],
                            [],
                            [],
                            "collect",
                            [],
                            [
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                []
                                [ F; Ty.path "alloc::alloc::Global" ]
                            ]
                          |),
                          [
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "core::iter::adapters::map::Map")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "core::slice::iter::Iter")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "p3_commit::domain::LagrangeSelectors")
                                        []
                                        [ F ]
                                    ];
                                  Ty.function
                                    [
                                      Ty.tuple
                                        [
                                          Ty.apply
                                            (Ty.path "&")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "p3_commit::domain::LagrangeSelectors")
                                                []
                                                [ F ]
                                            ]
                                        ]
                                    ]
                                    F
                                ],
                              M.get_trait_method (|
                                "core::iter::traits::iterator::Iterator",
                                Ty.apply
                                  (Ty.path "core::slice::iter::Iter")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "p3_commit::domain::LagrangeSelectors")
                                      []
                                      [ F ]
                                  ],
                                [],
                                [],
                                "map",
                                [],
                                [
                                  F;
                                  Ty.function
                                    [
                                      Ty.tuple
                                        [
                                          Ty.apply
                                            (Ty.path "&")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "p3_commit::domain::LagrangeSelectors")
                                                []
                                                [ F ]
                                            ]
                                        ]
                                    ]
                                    F
                                ]
                              |),
                              [
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "core::slice::iter::Iter")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "p3_commit::domain::LagrangeSelectors")
                                        []
                                        [ F ]
                                    ],
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "slice")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "p3_commit::domain::LagrangeSelectors")
                                          []
                                          [ F ]
                                      ],
                                    "iter",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (|
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "&")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "slice")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "p3_commit::domain::LagrangeSelectors")
                                                    []
                                                    [ F ]
                                                ]
                                            ],
                                          M.get_trait_method (|
                                            "core::ops::deref::Deref",
                                            Ty.apply
                                              (Ty.path "alloc::vec::Vec")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "p3_commit::domain::LagrangeSelectors")
                                                  []
                                                  [ F ];
                                                Ty.path "alloc::alloc::Global"
                                              ],
                                            [],
                                            [],
                                            "deref",
                                            [],
                                            []
                                          |),
                                          [ M.borrow (| Pointer.Kind.Ref, sels |) ]
                                        |)
                                      |)
                                    |)
                                  ]
                                |);
                                M.closure
                                  (fun γ =>
                                    ltac:(M.monadic
                                      match γ with
                                      | [ α0 ] =>
                                        ltac:(M.monadic
                                          (M.match_operator (|
                                            Ty.apply
                                              (Ty.path "*")
                                              []
                                              [
                                                Ty.function
                                                  [
                                                    Ty.tuple
                                                      [
                                                        Ty.apply
                                                          (Ty.path "&")
                                                          []
                                                          [
                                                            Ty.apply
                                                              (Ty.path
                                                                "p3_commit::domain::LagrangeSelectors")
                                                              []
                                                              [ F ]
                                                          ]
                                                      ]
                                                  ]
                                                  F
                                              ],
                                            M.alloc (| α0 |),
                                            [
                                              fun γ =>
                                                ltac:(M.monadic
                                                  (let s := M.copy (| γ |) in
                                                  M.read (|
                                                    M.SubPointer.get_struct_record_field (|
                                                      M.deref (| M.read (| s |) |),
                                                      "p3_commit::domain::LagrangeSelectors",
                                                      "is_transition"
                                                    |)
                                                  |)))
                                            ]
                                          |)))
                                      | _ => M.impossible "wrong number of arguments"
                                      end))
                              ]
                            |)
                          ]
                        |));
                      ("inv_vanishing",
                        M.call_closure (|
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            []
                            [ F; Ty.path "alloc::alloc::Global" ],
                          M.get_trait_method (|
                            "core::iter::traits::iterator::Iterator",
                            Ty.apply
                              (Ty.path "core::iter::adapters::map::Map")
                              []
                              [
                                Ty.apply
                                  (Ty.path "core::slice::iter::Iter")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "p3_commit::domain::LagrangeSelectors")
                                      []
                                      [ F ]
                                  ];
                                Ty.function
                                  [
                                    Ty.tuple
                                      [
                                        Ty.apply
                                          (Ty.path "&")
                                          []
                                          [
                                            Ty.apply
                                              (Ty.path "p3_commit::domain::LagrangeSelectors")
                                              []
                                              [ F ]
                                          ]
                                      ]
                                  ]
                                  F
                              ],
                            [],
                            [],
                            "collect",
                            [],
                            [
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                []
                                [ F; Ty.path "alloc::alloc::Global" ]
                            ]
                          |),
                          [
                            M.call_closure (|
                              Ty.apply
                                (Ty.path "core::iter::adapters::map::Map")
                                []
                                [
                                  Ty.apply
                                    (Ty.path "core::slice::iter::Iter")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "p3_commit::domain::LagrangeSelectors")
                                        []
                                        [ F ]
                                    ];
                                  Ty.function
                                    [
                                      Ty.tuple
                                        [
                                          Ty.apply
                                            (Ty.path "&")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "p3_commit::domain::LagrangeSelectors")
                                                []
                                                [ F ]
                                            ]
                                        ]
                                    ]
                                    F
                                ],
                              M.get_trait_method (|
                                "core::iter::traits::iterator::Iterator",
                                Ty.apply
                                  (Ty.path "core::slice::iter::Iter")
                                  []
                                  [
                                    Ty.apply
                                      (Ty.path "p3_commit::domain::LagrangeSelectors")
                                      []
                                      [ F ]
                                  ],
                                [],
                                [],
                                "map",
                                [],
                                [
                                  F;
                                  Ty.function
                                    [
                                      Ty.tuple
                                        [
                                          Ty.apply
                                            (Ty.path "&")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "p3_commit::domain::LagrangeSelectors")
                                                []
                                                [ F ]
                                            ]
                                        ]
                                    ]
                                    F
                                ]
                              |),
                              [
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "core::slice::iter::Iter")
                                    []
                                    [
                                      Ty.apply
                                        (Ty.path "p3_commit::domain::LagrangeSelectors")
                                        []
                                        [ F ]
                                    ],
                                  M.get_associated_function (|
                                    Ty.apply
                                      (Ty.path "slice")
                                      []
                                      [
                                        Ty.apply
                                          (Ty.path "p3_commit::domain::LagrangeSelectors")
                                          []
                                          [ F ]
                                      ],
                                    "iter",
                                    [],
                                    []
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (|
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "&")
                                            []
                                            [
                                              Ty.apply
                                                (Ty.path "slice")
                                                []
                                                [
                                                  Ty.apply
                                                    (Ty.path "p3_commit::domain::LagrangeSelectors")
                                                    []
                                                    [ F ]
                                                ]
                                            ],
                                          M.get_trait_method (|
                                            "core::ops::deref::Deref",
                                            Ty.apply
                                              (Ty.path "alloc::vec::Vec")
                                              []
                                              [
                                                Ty.apply
                                                  (Ty.path "p3_commit::domain::LagrangeSelectors")
                                                  []
                                                  [ F ];
                                                Ty.path "alloc::alloc::Global"
                                              ],
                                            [],
                                            [],
                                            "deref",
                                            [],
                                            []
                                          |),
                                          [ M.borrow (| Pointer.Kind.Ref, sels |) ]
                                        |)
                                      |)
                                    |)
                                  ]
                                |);
                                M.closure
                                  (fun γ =>
                                    ltac:(M.monadic
                                      match γ with
                                      | [ α0 ] =>
                                        ltac:(M.monadic
                                          (M.match_operator (|
                                            Ty.apply
                                              (Ty.path "*")
                                              []
                                              [
                                                Ty.function
                                                  [
                                                    Ty.tuple
                                                      [
                                                        Ty.apply
                                                          (Ty.path "&")
                                                          []
                                                          [
                                                            Ty.apply
                                                              (Ty.path
                                                                "p3_commit::domain::LagrangeSelectors")
                                                              []
                                                              [ F ]
                                                          ]
                                                      ]
                                                  ]
                                                  F
                                              ],
                                            M.alloc (| α0 |),
                                            [
                                              fun γ =>
                                                ltac:(M.monadic
                                                  (let s := M.copy (| γ |) in
                                                  M.read (|
                                                    M.SubPointer.get_struct_record_field (|
                                                      M.deref (| M.read (| s |) |),
                                                      "p3_commit::domain::LagrangeSelectors",
                                                      "inv_vanishing"
                                                    |)
                                                  |)))
                                            ]
                                          |)))
                                      | _ => M.impossible "wrong number of arguments"
                                      end))
                              ]
                            |)
                          ]
                        |))
                    ]
                |)
              |)))
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (F : Ty.t),
      M.IsTraitInstance
        "p3_commit::domain::PolynomialSpace"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) []
        (Self F)
        (* Instance *)
        [
          ("Val", InstanceField.Ty (_Val F));
          ("size", InstanceField.Method (size F));
          ("first_point", InstanceField.Method (first_point F));
          ("next_point", InstanceField.Method (next_point F));
          ("create_disjoint_domain", InstanceField.Method (create_disjoint_domain F));
          ("split_domains", InstanceField.Method (split_domains F));
          ("split_evals", InstanceField.Method (split_evals F));
          ("vanishing_poly_at_point", InstanceField.Method (vanishing_poly_at_point F));
          ("selectors_at_point", InstanceField.Method (selectors_at_point F));
          ("selectors_on_coset", InstanceField.Method (selectors_on_coset F))
        ].
  End Impl_p3_commit_domain_PolynomialSpace_where_p3_field_extension_complex_ComplexExtendable_F_for_p3_circle_domain_CircleDomain_F.
  
  (*
  const fn forward_backward_index(mut i: usize, len: usize) -> usize {
      i %= 2 * len;
      if i < len { i } else { 2 * len - 1 - i }
  }
  *)
  Definition forward_backward_index (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [], [ i; len ] =>
      ltac:(M.monadic
        (let i := M.alloc (| i |) in
        let len := M.alloc (| len |) in
        M.read (|
          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
            M.alloc (|
              let β := i in
              M.write (|
                β,
                M.call_closure (|
                  Ty.path "usize",
                  BinOp.Wrap.rem,
                  [
                    M.read (| β |);
                    M.call_closure (|
                      Ty.path "usize",
                      BinOp.Wrap.mul,
                      [ Value.Integer IntegerKind.Usize 2; M.read (| len |) ]
                    |)
                  ]
                |)
              |)
            |) in
          M.match_operator (|
            Ty.apply (Ty.path "*") [] [ Ty.path "usize" ],
            M.alloc (| Value.Tuple [] |),
            [
              fun γ =>
                ltac:(M.monadic
                  (let γ :=
                    M.use
                      (M.alloc (|
                        M.call_closure (|
                          Ty.path "bool",
                          BinOp.lt,
                          [ M.read (| i |); M.read (| len |) ]
                        |)
                      |)) in
                  let _ := is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                  i));
              fun γ =>
                ltac:(M.monadic
                  (M.alloc (|
                    M.call_closure (|
                      Ty.path "usize",
                      BinOp.Wrap.sub,
                      [
                        M.call_closure (|
                          Ty.path "usize",
                          BinOp.Wrap.sub,
                          [
                            M.call_closure (|
                              Ty.path "usize",
                              BinOp.Wrap.mul,
                              [ Value.Integer IntegerKind.Usize 2; M.read (| len |) ]
                            |);
                            Value.Integer IntegerKind.Usize 1
                          ]
                        |);
                        M.read (| i |)
                      ]
                    |)
                  |)))
            ]
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_forward_backward_index :
    M.IsFunction.C "p3_circle::domain::forward_backward_index" forward_backward_index.
  Admitted.
  Global Typeclasses Opaque forward_backward_index.
End domain.
