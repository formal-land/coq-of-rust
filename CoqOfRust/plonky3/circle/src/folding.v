(* Generated by coq-of-rust *)
Require Import CoqOfRust.CoqOfRust.

Module folding.
  (* StructTuple
    {
      name := "CircleFriGenericConfig";
      const_params := [];
      ty_params := [ "F"; "InputProof"; "InputError" ];
      fields :=
        [
          Ty.apply
            (Ty.path "core::marker::PhantomData")
            []
            [ Ty.tuple [ F; InputProof; InputError ] ]
        ];
    } *)
  
  Axiom CircleFriConfig :
    forall (Val Challenge InputMmcs FriMmcs : Ty.t),
    (Ty.apply
        (Ty.path "p3_circle::folding::CircleFriConfig")
        []
        [ Val; Challenge; InputMmcs; FriMmcs ]) =
      (Ty.apply
        (Ty.path "p3_circle::folding::CircleFriGenericConfig")
        []
        [
          Val;
          Ty.apply
            (Ty.path "p3_circle::pcs::CircleInputProof")
            []
            [ Val; Challenge; InputMmcs; FriMmcs ];
          Ty.apply
            (Ty.path "p3_circle::pcs::InputError")
            []
            [
              Ty.associated_in_trait "p3_commit::mmcs::Mmcs" [] [ Val ] InputMmcs "Error";
              Ty.associated_in_trait "p3_commit::mmcs::Mmcs" [] [ Challenge ] FriMmcs "Error"
            ]
        ]).
  
  Module Impl_p3_fri_config_FriGenericConfig_where_p3_field_extension_complex_ComplexExtendable_F_where_p3_field_field_ExtensionField_EF_F_where_core_fmt_Debug_InputError_EF_for_p3_circle_folding_CircleFriGenericConfig_F_InputProof_InputError.
    Definition Self (F EF InputProof InputError : Ty.t) : Ty.t :=
      Ty.apply
        (Ty.path "p3_circle::folding::CircleFriGenericConfig")
        []
        [ F; InputProof; InputError ].
    
    (*     type InputProof = InputProof; *)
    Definition _InputProof (F EF InputProof InputError : Ty.t) : Ty.t := InputProof.
    
    (*     type InputError = InputError; *)
    Definition _InputError (F EF InputProof InputError : Ty.t) : Ty.t := InputError.
    
    (*
        fn extra_query_index_bits(&self) -> usize {
            1
        }
    *)
    Definition extra_query_index_bits
        (F EF InputProof InputError : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self F EF InputProof InputError in
      match ε, τ, α with
      | [], [], [ self ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          Value.Integer IntegerKind.Usize 1))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn fold_row(
            &self,
            index: usize,
            log_folded_height: usize,
            beta: EF,
            evals: impl Iterator<Item = EF>,
        ) -> EF {
            fold_x_row(index, log_folded_height, beta, evals)
        }
    *)
    Definition fold_row
        (F EF InputProof InputError : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self F EF InputProof InputError in
      match ε, τ, α with
      | [], [ impl_Iterator_Item___EF_ ], [ self; index; log_folded_height; beta; evals ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let index := M.alloc (| index |) in
          let log_folded_height := M.alloc (| log_folded_height |) in
          let beta := M.alloc (| beta |) in
          let evals := M.alloc (| evals |) in
          M.call_closure (|
            EF,
            M.get_function (|
              "p3_circle::folding::fold_x_row",
              [],
              [ F; EF; impl_Iterator_Item___EF_ ]
            |),
            [
              M.read (| index |);
              M.read (| log_folded_height |);
              M.read (| beta |);
              M.read (| evals |)
            ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    (*
        fn fold_matrix<M: Matrix<EF>>(&self, beta: EF, m: M) -> Vec<EF> {
            fold_x(beta, m)
        }
    *)
    Definition fold_matrix
        (F EF InputProof InputError : Ty.t)
        (ε : list Value.t)
        (τ : list Ty.t)
        (α : list Value.t)
        : M :=
      let Self : Ty.t := Self F EF InputProof InputError in
      match ε, τ, α with
      | [], [ M_ ], [ self; beta; m ] =>
        ltac:(M.monadic
          (let self := M.alloc (| self |) in
          let beta := M.alloc (| beta |) in
          let m := M.alloc (| m |) in
          M.call_closure (|
            Ty.apply (Ty.path "alloc::vec::Vec") [] [ EF; Ty.path "alloc::alloc::Global" ],
            M.get_function (| "p3_circle::folding::fold_x", [], [ F; EF; M_ ] |),
            [ M.read (| beta |); M.read (| m |) ]
          |)))
      | _, _, _ => M.impossible "wrong number of arguments"
      end.
    
    Axiom Implements :
      forall (F EF InputProof InputError : Ty.t),
      M.IsTraitInstance
        "p3_fri::config::FriGenericConfig"
        (* Trait polymorphic consts *) []
        (* Trait polymorphic types *) [ EF ]
        (Self F EF InputProof InputError)
        (* Instance *)
        [
          ("InputProof", InstanceField.Ty (_InputProof F EF InputProof InputError));
          ("InputError", InstanceField.Ty (_InputError F EF InputProof InputError));
          ("extra_query_index_bits",
            InstanceField.Method (extra_query_index_bits F EF InputProof InputError));
          ("fold_row", InstanceField.Method (fold_row F EF InputProof InputError));
          ("fold_matrix", InstanceField.Method (fold_matrix F EF InputProof InputError))
        ].
  End Impl_p3_fri_config_FriGenericConfig_where_p3_field_extension_complex_ComplexExtendable_F_where_p3_field_field_ExtensionField_EF_F_where_core_fmt_Debug_InputError_EF_for_p3_circle_folding_CircleFriGenericConfig_F_InputProof_InputError.
  
  (*
  fn fold<F: ComplexExtendable, EF: ExtensionField<F>>(
      evals: impl Matrix<EF>,
      beta: EF,
      twiddles: &[F],
  ) -> Vec<EF> {
      evals
          .rows()
          .zip(twiddles)
          .map(|(mut row, &t)| {
              let (lo, hi) = row.next_tuple().unwrap();
              let sum = lo + hi;
              let diff = (lo - hi) * t;
              (sum + beta * diff).halve()
          })
          .collect_vec()
  }
  *)
  Definition fold (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ F; EF; impl_Matrix_EF_ ], [ evals; beta; twiddles ] =>
      ltac:(M.monadic
        (let evals := M.alloc (| evals |) in
        let beta := M.alloc (| beta |) in
        let twiddles := M.alloc (| twiddles |) in
        M.call_closure (|
          Ty.apply (Ty.path "alloc::vec::Vec") [] [ EF; Ty.path "alloc::alloc::Global" ],
          M.get_trait_method (|
            "itertools::Itertools",
            Ty.apply
              (Ty.path "core::iter::adapters::map::Map")
              []
              [
                Ty.apply
                  (Ty.path "core::iter::adapters::zip::Zip")
                  []
                  [
                    Ty.associated_in_trait
                      "p3_matrix::Matrix"
                      []
                      [ EF ]
                      impl_Matrix_EF_
                      "{{synthetic}}";
                    Ty.apply (Ty.path "core::slice::iter::Iter") [] [ F ]
                  ];
                Ty.function
                  [
                    Ty.tuple
                      [
                        Ty.tuple
                          [
                            Ty.associated_in_trait
                              "p3_matrix::Matrix"
                              []
                              [ EF ]
                              impl_Matrix_EF_
                              "Row";
                            Ty.apply (Ty.path "&") [] [ F ]
                          ]
                      ]
                  ]
                  EF
              ],
            [],
            [],
            "collect_vec",
            [],
            []
          |),
          [
            M.call_closure (|
              Ty.apply
                (Ty.path "core::iter::adapters::map::Map")
                []
                [
                  Ty.apply
                    (Ty.path "core::iter::adapters::zip::Zip")
                    []
                    [
                      Ty.associated_in_trait
                        "p3_matrix::Matrix"
                        []
                        [ EF ]
                        impl_Matrix_EF_
                        "{{synthetic}}";
                      Ty.apply (Ty.path "core::slice::iter::Iter") [] [ F ]
                    ];
                  Ty.function
                    [
                      Ty.tuple
                        [
                          Ty.tuple
                            [
                              Ty.associated_in_trait
                                "p3_matrix::Matrix"
                                []
                                [ EF ]
                                impl_Matrix_EF_
                                "Row";
                              Ty.apply (Ty.path "&") [] [ F ]
                            ]
                        ]
                    ]
                    EF
                ],
              M.get_trait_method (|
                "core::iter::traits::iterator::Iterator",
                Ty.apply
                  (Ty.path "core::iter::adapters::zip::Zip")
                  []
                  [
                    Ty.associated_in_trait
                      "p3_matrix::Matrix"
                      []
                      [ EF ]
                      impl_Matrix_EF_
                      "{{synthetic}}";
                    Ty.apply (Ty.path "core::slice::iter::Iter") [] [ F ]
                  ],
                [],
                [],
                "map",
                [],
                [
                  EF;
                  Ty.function
                    [
                      Ty.tuple
                        [
                          Ty.tuple
                            [
                              Ty.associated_in_trait
                                "p3_matrix::Matrix"
                                []
                                [ EF ]
                                impl_Matrix_EF_
                                "Row";
                              Ty.apply (Ty.path "&") [] [ F ]
                            ]
                        ]
                    ]
                    EF
                ]
              |),
              [
                M.call_closure (|
                  Ty.apply
                    (Ty.path "core::iter::adapters::zip::Zip")
                    []
                    [
                      Ty.associated_in_trait
                        "p3_matrix::Matrix"
                        []
                        [ EF ]
                        impl_Matrix_EF_
                        "{{synthetic}}";
                      Ty.apply (Ty.path "core::slice::iter::Iter") [] [ F ]
                    ],
                  M.get_trait_method (|
                    "core::iter::traits::iterator::Iterator",
                    Ty.associated_in_trait
                      "p3_matrix::Matrix"
                      []
                      [ EF ]
                      impl_Matrix_EF_
                      "{{synthetic}}",
                    [],
                    [],
                    "zip",
                    [],
                    [ Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ F ] ] ]
                  |),
                  [
                    M.call_closure (|
                      Ty.associated_in_trait
                        "p3_matrix::Matrix"
                        []
                        [ EF ]
                        impl_Matrix_EF_
                        "{{synthetic}}",
                      M.get_trait_method (|
                        "p3_matrix::Matrix",
                        impl_Matrix_EF_,
                        [],
                        [ EF ],
                        "rows",
                        [],
                        []
                      |),
                      [ M.borrow (| Pointer.Kind.Ref, evals |) ]
                    |);
                    M.read (| twiddles |)
                  ]
                |);
                M.closure
                  (fun γ =>
                    ltac:(M.monadic
                      match γ with
                      | [ α0 ] =>
                        ltac:(M.monadic
                          (M.match_operator (|
                            Ty.apply
                              (Ty.path "*")
                              []
                              [
                                Ty.function
                                  [
                                    Ty.tuple
                                      [
                                        Ty.tuple
                                          [
                                            Ty.associated_in_trait
                                              "p3_matrix::Matrix"
                                              []
                                              [ EF ]
                                              impl_Matrix_EF_
                                              "Row";
                                            Ty.apply (Ty.path "&") [] [ F ]
                                          ]
                                      ]
                                  ]
                                  EF
                              ],
                            M.alloc (| α0 |),
                            [
                              fun γ =>
                                ltac:(M.monadic
                                  (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                  let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                  let row := M.copy (| γ0_0 |) in
                                  let γ0_1 := M.read (| γ0_1 |) in
                                  let t := M.copy (| γ0_1 |) in
                                  M.read (|
                                    M.match_operator (|
                                      Ty.apply (Ty.path "*") [] [ EF ],
                                      M.alloc (|
                                        M.call_closure (|
                                          Ty.tuple [ EF; EF ],
                                          M.get_associated_function (|
                                            Ty.apply
                                              (Ty.path "core::option::Option")
                                              []
                                              [ Ty.tuple [ EF; EF ] ],
                                            "unwrap",
                                            [],
                                            []
                                          |),
                                          [
                                            M.call_closure (|
                                              Ty.apply
                                                (Ty.path "core::option::Option")
                                                []
                                                [ Ty.tuple [ EF; EF ] ],
                                              M.get_trait_method (|
                                                "itertools::Itertools",
                                                Ty.associated_in_trait
                                                  "p3_matrix::Matrix"
                                                  []
                                                  [ EF ]
                                                  impl_Matrix_EF_
                                                  "Row",
                                                [],
                                                [],
                                                "next_tuple",
                                                [],
                                                [ Ty.tuple [ EF; EF ] ]
                                              |),
                                              [ M.borrow (| Pointer.Kind.MutRef, row |) ]
                                            |)
                                          ]
                                        |)
                                      |),
                                      [
                                        fun γ =>
                                          ltac:(M.monadic
                                            (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                                            let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                                            let lo := M.copy (| γ0_0 |) in
                                            let hi := M.copy (| γ0_1 |) in
                                            let~ sum : Ty.apply (Ty.path "*") [] [ EF ] :=
                                              M.alloc (|
                                                M.call_closure (|
                                                  EF,
                                                  M.get_trait_method (|
                                                    "core::ops::arith::Add",
                                                    EF,
                                                    [],
                                                    [ EF ],
                                                    "add",
                                                    [],
                                                    []
                                                  |),
                                                  [ M.read (| lo |); M.read (| hi |) ]
                                                |)
                                              |) in
                                            let~ diff : Ty.apply (Ty.path "*") [] [ EF ] :=
                                              M.alloc (|
                                                M.call_closure (|
                                                  EF,
                                                  M.get_trait_method (|
                                                    "core::ops::arith::Mul",
                                                    EF,
                                                    [],
                                                    [ F ],
                                                    "mul",
                                                    [],
                                                    []
                                                  |),
                                                  [
                                                    M.call_closure (|
                                                      EF,
                                                      M.get_trait_method (|
                                                        "core::ops::arith::Sub",
                                                        EF,
                                                        [],
                                                        [ EF ],
                                                        "sub",
                                                        [],
                                                        []
                                                      |),
                                                      [ M.read (| lo |); M.read (| hi |) ]
                                                    |);
                                                    M.read (| t |)
                                                  ]
                                                |)
                                              |) in
                                            M.alloc (|
                                              M.call_closure (|
                                                EF,
                                                M.get_trait_method (|
                                                  "p3_field::field::Field",
                                                  EF,
                                                  [],
                                                  [],
                                                  "halve",
                                                  [],
                                                  []
                                                |),
                                                [
                                                  M.borrow (|
                                                    Pointer.Kind.Ref,
                                                    M.alloc (|
                                                      M.call_closure (|
                                                        EF,
                                                        M.get_trait_method (|
                                                          "core::ops::arith::Add",
                                                          EF,
                                                          [],
                                                          [ EF ],
                                                          "add",
                                                          [],
                                                          []
                                                        |),
                                                        [
                                                          M.read (| sum |);
                                                          M.call_closure (|
                                                            EF,
                                                            M.get_trait_method (|
                                                              "core::ops::arith::Mul",
                                                              EF,
                                                              [],
                                                              [ EF ],
                                                              "mul",
                                                              [],
                                                              []
                                                            |),
                                                            [ M.read (| beta |); M.read (| diff |) ]
                                                          |)
                                                        ]
                                                      |)
                                                    |)
                                                  |)
                                                ]
                                              |)
                                            |)))
                                      ]
                                    |)
                                  |)))
                            ]
                          |)))
                      | _ => M.impossible "wrong number of arguments"
                      end))
              ]
            |)
          ]
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_fold : M.IsFunction.C "p3_circle::folding::fold" fold.
  Admitted.
  Global Typeclasses Opaque fold.
  
  (*
  pub(crate) fn fold_y<F: ComplexExtendable, EF: ExtensionField<F>>(
      beta: EF,
      evals: impl Matrix<EF>,
  ) -> Vec<EF> {
      assert_eq!(evals.width(), 2);
      let log_n = log2_strict_usize(evals.height()) + 1;
      fold(
          evals,
          beta,
          &batch_multiplicative_inverse(&CircleDomain::standard(log_n).y_twiddles()),
      )
  }
  *)
  Definition fold_y (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ F; EF; impl_Matrix_EF_ ], [ beta; evals ] =>
      ltac:(M.monadic
        (let beta := M.alloc (| beta |) in
        let evals := M.alloc (| evals |) in
        M.read (|
          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              M.alloc (|
                Value.Tuple
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.alloc (|
                        M.call_closure (|
                          Ty.path "usize",
                          M.get_trait_method (|
                            "p3_matrix::Matrix",
                            impl_Matrix_EF_,
                            [],
                            [ EF ],
                            "width",
                            [],
                            []
                          |),
                          [ M.borrow (| Pointer.Kind.Ref, evals |) ]
                        |)
                      |)
                    |);
                    M.borrow (| Pointer.Kind.Ref, M.alloc (| Value.Integer IntegerKind.Usize 2 |) |)
                  ]
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let left_val := M.copy (| γ0_0 |) in
                    let right_val := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  UnOp.not (|
                                    M.call_closure (|
                                      Ty.path "bool",
                                      BinOp.eq,
                                      [
                                        M.read (| M.deref (| M.read (| left_val |) |) |);
                                        M.read (| M.deref (| M.read (| right_val |) |) |)
                                      ]
                                    |)
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  let~ kind :
                                      Ty.apply
                                        (Ty.path "*")
                                        []
                                        [ Ty.path "core::panicking::AssertKind" ] :=
                                    M.alloc (|
                                      Value.StructTuple "core::panicking::AssertKind::Eq" []
                                    |) in
                                  M.alloc (|
                                    M.call_closure (|
                                      Ty.path "never",
                                      M.get_function (|
                                        "core::panicking::assert_failed",
                                        [],
                                        [ Ty.path "usize"; Ty.path "usize" ]
                                      |),
                                      [
                                        M.read (| kind |);
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (|
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (| M.read (| left_val |) |)
                                            |)
                                          |)
                                        |);
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (|
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (| M.read (| right_val |) |)
                                            |)
                                          |)
                                        |);
                                        Value.StructTuple "core::option::Option::None" []
                                      ]
                                    |)
                                  |)
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |)))
              ]
            |) in
          let~ log_n : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
            M.alloc (|
              M.call_closure (|
                Ty.path "usize",
                BinOp.Wrap.add,
                [
                  M.call_closure (|
                    Ty.path "usize",
                    M.get_function (| "p3_util::log2_strict_usize", [], [] |),
                    [
                      M.call_closure (|
                        Ty.path "usize",
                        M.get_trait_method (|
                          "p3_matrix::Matrix",
                          impl_Matrix_EF_,
                          [],
                          [ EF ],
                          "height",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.Ref, evals |) ]
                      |)
                    ]
                  |);
                  Value.Integer IntegerKind.Usize 1
                ]
              |)
            |) in
          M.alloc (|
            M.call_closure (|
              Ty.apply (Ty.path "alloc::vec::Vec") [] [ EF; Ty.path "alloc::alloc::Global" ],
              M.get_function (| "p3_circle::folding::fold", [], [ F; EF; impl_Matrix_EF_ ] |),
              [
                M.read (| evals |);
                M.read (| beta |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ F ] ],
                      M.get_trait_method (|
                        "core::ops::deref::Deref",
                        Ty.apply
                          (Ty.path "alloc::vec::Vec")
                          []
                          [ F; Ty.path "alloc::alloc::Global" ],
                        [],
                        [],
                        "deref",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (|
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.alloc (|
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "alloc::vec::Vec")
                                    []
                                    [ F; Ty.path "alloc::alloc::Global" ],
                                  M.get_function (|
                                    "p3_field::batch_inverse::batch_multiplicative_inverse",
                                    [],
                                    [ F ]
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (|
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "&")
                                            []
                                            [ Ty.apply (Ty.path "slice") [] [ F ] ],
                                          M.get_trait_method (|
                                            "core::ops::deref::Deref",
                                            Ty.apply
                                              (Ty.path "alloc::vec::Vec")
                                              []
                                              [ F; Ty.path "alloc::alloc::Global" ],
                                            [],
                                            [],
                                            "deref",
                                            [],
                                            []
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.alloc (|
                                                    M.call_closure (|
                                                      Ty.apply
                                                        (Ty.path "alloc::vec::Vec")
                                                        []
                                                        [ F; Ty.path "alloc::alloc::Global" ],
                                                      M.get_associated_function (|
                                                        Ty.apply
                                                          (Ty.path
                                                            "p3_circle::domain::CircleDomain")
                                                          []
                                                          [ F ],
                                                        "y_twiddles",
                                                        [],
                                                        []
                                                      |),
                                                      [
                                                        M.borrow (|
                                                          Pointer.Kind.Ref,
                                                          M.alloc (|
                                                            M.call_closure (|
                                                              Ty.apply
                                                                (Ty.path
                                                                  "p3_circle::domain::CircleDomain")
                                                                []
                                                                [ F ],
                                                              M.get_associated_function (|
                                                                Ty.apply
                                                                  (Ty.path
                                                                    "p3_circle::domain::CircleDomain")
                                                                  []
                                                                  [ F ],
                                                                "standard",
                                                                [],
                                                                []
                                                              |),
                                                              [ M.read (| log_n |) ]
                                                            |)
                                                          |)
                                                        |)
                                                      ]
                                                    |)
                                                  |)
                                                |)
                                              |)
                                            |)
                                          ]
                                        |)
                                      |)
                                    |)
                                  ]
                                |)
                              |)
                            |)
                          |)
                        |)
                      ]
                    |)
                  |)
                |)
              ]
            |)
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_fold_y : M.IsFunction.C "p3_circle::folding::fold_y" fold_y.
  Admitted.
  Global Typeclasses Opaque fold_y.
  
  (*
  pub(crate) fn fold_y_row<F: ComplexExtendable, EF: ExtensionField<F>>(
      index: usize,
      log_folded_height: usize,
      beta: EF,
      evals: impl Iterator<Item = EF>,
  ) -> EF {
      let evals = evals.collect_vec();
      assert_eq!(evals.len(), 2);
      let t = CircleDomain::<F>::standard(log_folded_height + 1)
          .nth_y_twiddle(index)
          .inverse();
      let sum = evals[0] + evals[1];
      let diff = (evals[0] - evals[1]) * t;
      (sum + beta * diff).halve()
  }
  *)
  Definition fold_y_row (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ F; EF; impl_Iterator_Item___EF_ ], [ index; log_folded_height; beta; evals ] =>
      ltac:(M.monadic
        (let index := M.alloc (| index |) in
        let log_folded_height := M.alloc (| log_folded_height |) in
        let beta := M.alloc (| beta |) in
        let evals := M.alloc (| evals |) in
        M.read (|
          let~ evals :
              Ty.apply
                (Ty.path "*")
                []
                [ Ty.apply (Ty.path "alloc::vec::Vec") [] [ EF; Ty.path "alloc::alloc::Global" ]
                ] :=
            M.alloc (|
              M.call_closure (|
                Ty.apply (Ty.path "alloc::vec::Vec") [] [ EF; Ty.path "alloc::alloc::Global" ],
                M.get_trait_method (|
                  "itertools::Itertools",
                  impl_Iterator_Item___EF_,
                  [],
                  [],
                  "collect_vec",
                  [],
                  []
                |),
                [ M.read (| evals |) ]
              |)
            |) in
          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              M.alloc (|
                Value.Tuple
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.alloc (|
                        M.call_closure (|
                          Ty.path "usize",
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              []
                              [ EF; Ty.path "alloc::alloc::Global" ],
                            "len",
                            [],
                            []
                          |),
                          [ M.borrow (| Pointer.Kind.Ref, evals |) ]
                        |)
                      |)
                    |);
                    M.borrow (| Pointer.Kind.Ref, M.alloc (| Value.Integer IntegerKind.Usize 2 |) |)
                  ]
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let left_val := M.copy (| γ0_0 |) in
                    let right_val := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  UnOp.not (|
                                    M.call_closure (|
                                      Ty.path "bool",
                                      BinOp.eq,
                                      [
                                        M.read (| M.deref (| M.read (| left_val |) |) |);
                                        M.read (| M.deref (| M.read (| right_val |) |) |)
                                      ]
                                    |)
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  let~ kind :
                                      Ty.apply
                                        (Ty.path "*")
                                        []
                                        [ Ty.path "core::panicking::AssertKind" ] :=
                                    M.alloc (|
                                      Value.StructTuple "core::panicking::AssertKind::Eq" []
                                    |) in
                                  M.alloc (|
                                    M.call_closure (|
                                      Ty.path "never",
                                      M.get_function (|
                                        "core::panicking::assert_failed",
                                        [],
                                        [ Ty.path "usize"; Ty.path "usize" ]
                                      |),
                                      [
                                        M.read (| kind |);
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (|
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (| M.read (| left_val |) |)
                                            |)
                                          |)
                                        |);
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (|
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (| M.read (| right_val |) |)
                                            |)
                                          |)
                                        |);
                                        Value.StructTuple "core::option::Option::None" []
                                      ]
                                    |)
                                  |)
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |)))
              ]
            |) in
          let~ t : Ty.apply (Ty.path "*") [] [ F ] :=
            M.alloc (|
              M.call_closure (|
                F,
                M.get_trait_method (| "p3_field::field::Field", F, [], [], "inverse", [], [] |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.alloc (|
                      M.call_closure (|
                        F,
                        M.get_associated_function (|
                          Ty.apply (Ty.path "p3_circle::domain::CircleDomain") [] [ F ],
                          "nth_y_twiddle",
                          [],
                          []
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply (Ty.path "p3_circle::domain::CircleDomain") [] [ F ],
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "p3_circle::domain::CircleDomain") [] [ F ],
                                  "standard",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.path "usize",
                                    BinOp.Wrap.add,
                                    [
                                      M.read (| log_folded_height |);
                                      Value.Integer IntegerKind.Usize 1
                                    ]
                                  |)
                                ]
                              |)
                            |)
                          |);
                          M.read (| index |)
                        ]
                      |)
                    |)
                  |)
                ]
              |)
            |) in
          let~ sum : Ty.apply (Ty.path "*") [] [ EF ] :=
            M.alloc (|
              M.call_closure (|
                EF,
                M.get_trait_method (| "core::ops::arith::Add", EF, [], [ EF ], "add", [], [] |),
                [
                  M.read (|
                    M.deref (|
                      M.call_closure (|
                        Ty.apply (Ty.path "&") [] [ EF ],
                        M.get_trait_method (|
                          "core::ops::index::Index",
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            []
                            [ EF; Ty.path "alloc::alloc::Global" ],
                          [],
                          [ Ty.path "usize" ],
                          "index",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.Ref, evals |); Value.Integer IntegerKind.Usize 0
                        ]
                      |)
                    |)
                  |);
                  M.read (|
                    M.deref (|
                      M.call_closure (|
                        Ty.apply (Ty.path "&") [] [ EF ],
                        M.get_trait_method (|
                          "core::ops::index::Index",
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            []
                            [ EF; Ty.path "alloc::alloc::Global" ],
                          [],
                          [ Ty.path "usize" ],
                          "index",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.Ref, evals |); Value.Integer IntegerKind.Usize 1
                        ]
                      |)
                    |)
                  |)
                ]
              |)
            |) in
          let~ diff : Ty.apply (Ty.path "*") [] [ EF ] :=
            M.alloc (|
              M.call_closure (|
                EF,
                M.get_trait_method (| "core::ops::arith::Mul", EF, [], [ F ], "mul", [], [] |),
                [
                  M.call_closure (|
                    EF,
                    M.get_trait_method (| "core::ops::arith::Sub", EF, [], [ EF ], "sub", [], [] |),
                    [
                      M.read (|
                        M.deref (|
                          M.call_closure (|
                            Ty.apply (Ty.path "&") [] [ EF ],
                            M.get_trait_method (|
                              "core::ops::index::Index",
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                []
                                [ EF; Ty.path "alloc::alloc::Global" ],
                              [],
                              [ Ty.path "usize" ],
                              "index",
                              [],
                              []
                            |),
                            [
                              M.borrow (| Pointer.Kind.Ref, evals |);
                              Value.Integer IntegerKind.Usize 0
                            ]
                          |)
                        |)
                      |);
                      M.read (|
                        M.deref (|
                          M.call_closure (|
                            Ty.apply (Ty.path "&") [] [ EF ],
                            M.get_trait_method (|
                              "core::ops::index::Index",
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                []
                                [ EF; Ty.path "alloc::alloc::Global" ],
                              [],
                              [ Ty.path "usize" ],
                              "index",
                              [],
                              []
                            |),
                            [
                              M.borrow (| Pointer.Kind.Ref, evals |);
                              Value.Integer IntegerKind.Usize 1
                            ]
                          |)
                        |)
                      |)
                    ]
                  |);
                  M.read (| t |)
                ]
              |)
            |) in
          M.alloc (|
            M.call_closure (|
              EF,
              M.get_trait_method (| "p3_field::field::Field", EF, [], [], "halve", [], [] |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.alloc (|
                    M.call_closure (|
                      EF,
                      M.get_trait_method (|
                        "core::ops::arith::Add",
                        EF,
                        [],
                        [ EF ],
                        "add",
                        [],
                        []
                      |),
                      [
                        M.read (| sum |);
                        M.call_closure (|
                          EF,
                          M.get_trait_method (|
                            "core::ops::arith::Mul",
                            EF,
                            [],
                            [ EF ],
                            "mul",
                            [],
                            []
                          |),
                          [ M.read (| beta |); M.read (| diff |) ]
                        |)
                      ]
                    |)
                  |)
                |)
              ]
            |)
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_fold_y_row :
    M.IsFunction.C "p3_circle::folding::fold_y_row" fold_y_row.
  Admitted.
  Global Typeclasses Opaque fold_y_row.
  
  (*
  pub(crate) fn fold_x<F: ComplexExtendable, EF: ExtensionField<F>>(
      beta: EF,
      evals: impl Matrix<EF>,
  ) -> Vec<EF> {
      let log_n = log2_strict_usize(evals.width() * evals.height());
      // +1 because twiddles after the first layer come from the x coordinates of the larger domain.
      let domain = CircleDomain::standard(log_n + 1);
      fold(
          evals,
          beta,
          &batch_multiplicative_inverse(&domain.x_twiddles(0)),
      )
  }
  *)
  Definition fold_x (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ F; EF; impl_Matrix_EF_ ], [ beta; evals ] =>
      ltac:(M.monadic
        (let beta := M.alloc (| beta |) in
        let evals := M.alloc (| evals |) in
        M.read (|
          let~ log_n : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
            M.alloc (|
              M.call_closure (|
                Ty.path "usize",
                M.get_function (| "p3_util::log2_strict_usize", [], [] |),
                [
                  M.call_closure (|
                    Ty.path "usize",
                    BinOp.Wrap.mul,
                    [
                      M.call_closure (|
                        Ty.path "usize",
                        M.get_trait_method (|
                          "p3_matrix::Matrix",
                          impl_Matrix_EF_,
                          [],
                          [ EF ],
                          "width",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.Ref, evals |) ]
                      |);
                      M.call_closure (|
                        Ty.path "usize",
                        M.get_trait_method (|
                          "p3_matrix::Matrix",
                          impl_Matrix_EF_,
                          [],
                          [ EF ],
                          "height",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.Ref, evals |) ]
                      |)
                    ]
                  |)
                ]
              |)
            |) in
          let~ domain :
              Ty.apply
                (Ty.path "*")
                []
                [ Ty.apply (Ty.path "p3_circle::domain::CircleDomain") [] [ F ] ] :=
            M.alloc (|
              M.call_closure (|
                Ty.apply (Ty.path "p3_circle::domain::CircleDomain") [] [ F ],
                M.get_associated_function (|
                  Ty.apply (Ty.path "p3_circle::domain::CircleDomain") [] [ F ],
                  "standard",
                  [],
                  []
                |),
                [
                  M.call_closure (|
                    Ty.path "usize",
                    BinOp.Wrap.add,
                    [ M.read (| log_n |); Value.Integer IntegerKind.Usize 1 ]
                  |)
                ]
              |)
            |) in
          M.alloc (|
            M.call_closure (|
              Ty.apply (Ty.path "alloc::vec::Vec") [] [ EF; Ty.path "alloc::alloc::Global" ],
              M.get_function (| "p3_circle::folding::fold", [], [ F; EF; impl_Matrix_EF_ ] |),
              [
                M.read (| evals |);
                M.read (| beta |);
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.deref (|
                    M.call_closure (|
                      Ty.apply (Ty.path "&") [] [ Ty.apply (Ty.path "slice") [] [ F ] ],
                      M.get_trait_method (|
                        "core::ops::deref::Deref",
                        Ty.apply
                          (Ty.path "alloc::vec::Vec")
                          []
                          [ F; Ty.path "alloc::alloc::Global" ],
                        [],
                        [],
                        "deref",
                        [],
                        []
                      |),
                      [
                        M.borrow (|
                          Pointer.Kind.Ref,
                          M.deref (|
                            M.borrow (|
                              Pointer.Kind.Ref,
                              M.alloc (|
                                M.call_closure (|
                                  Ty.apply
                                    (Ty.path "alloc::vec::Vec")
                                    []
                                    [ F; Ty.path "alloc::alloc::Global" ],
                                  M.get_function (|
                                    "p3_field::batch_inverse::batch_multiplicative_inverse",
                                    [],
                                    [ F ]
                                  |),
                                  [
                                    M.borrow (|
                                      Pointer.Kind.Ref,
                                      M.deref (|
                                        M.call_closure (|
                                          Ty.apply
                                            (Ty.path "&")
                                            []
                                            [ Ty.apply (Ty.path "slice") [] [ F ] ],
                                          M.get_trait_method (|
                                            "core::ops::deref::Deref",
                                            Ty.apply
                                              (Ty.path "alloc::vec::Vec")
                                              []
                                              [ F; Ty.path "alloc::alloc::Global" ],
                                            [],
                                            [],
                                            "deref",
                                            [],
                                            []
                                          |),
                                          [
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (|
                                                M.borrow (|
                                                  Pointer.Kind.Ref,
                                                  M.alloc (|
                                                    M.call_closure (|
                                                      Ty.apply
                                                        (Ty.path "alloc::vec::Vec")
                                                        []
                                                        [ F; Ty.path "alloc::alloc::Global" ],
                                                      M.get_associated_function (|
                                                        Ty.apply
                                                          (Ty.path
                                                            "p3_circle::domain::CircleDomain")
                                                          []
                                                          [ F ],
                                                        "x_twiddles",
                                                        [],
                                                        []
                                                      |),
                                                      [
                                                        M.borrow (| Pointer.Kind.Ref, domain |);
                                                        Value.Integer IntegerKind.Usize 0
                                                      ]
                                                    |)
                                                  |)
                                                |)
                                              |)
                                            |)
                                          ]
                                        |)
                                      |)
                                    |)
                                  ]
                                |)
                              |)
                            |)
                          |)
                        |)
                      ]
                    |)
                  |)
                |)
              ]
            |)
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_fold_x : M.IsFunction.C "p3_circle::folding::fold_x" fold_x.
  Admitted.
  Global Typeclasses Opaque fold_x.
  
  (*
  pub(crate) fn fold_x_row<F: ComplexExtendable, EF: ExtensionField<F>>(
      index: usize,
      log_folded_height: usize,
      beta: EF,
      evals: impl Iterator<Item = EF>,
  ) -> EF {
      let evals = evals.collect_vec();
      assert_eq!(evals.len(), 2);
      let log_arity = log2_strict_usize(evals.len());
  
      let t = CircleDomain::<F>::standard(log_folded_height + log_arity + 1)
          .nth_x_twiddle(reverse_bits_len(index, log_folded_height))
          .inverse();
  
      let sum = evals[0] + evals[1];
      let diff = (evals[0] - evals[1]) * t;
      (sum + beta * diff).halve()
  }
  *)
  Definition fold_x_row (ε : list Value.t) (τ : list Ty.t) (α : list Value.t) : M :=
    match ε, τ, α with
    | [], [ F; EF; impl_Iterator_Item___EF_ ], [ index; log_folded_height; beta; evals ] =>
      ltac:(M.monadic
        (let index := M.alloc (| index |) in
        let log_folded_height := M.alloc (| log_folded_height |) in
        let beta := M.alloc (| beta |) in
        let evals := M.alloc (| evals |) in
        M.read (|
          let~ evals :
              Ty.apply
                (Ty.path "*")
                []
                [ Ty.apply (Ty.path "alloc::vec::Vec") [] [ EF; Ty.path "alloc::alloc::Global" ]
                ] :=
            M.alloc (|
              M.call_closure (|
                Ty.apply (Ty.path "alloc::vec::Vec") [] [ EF; Ty.path "alloc::alloc::Global" ],
                M.get_trait_method (|
                  "itertools::Itertools",
                  impl_Iterator_Item___EF_,
                  [],
                  [],
                  "collect_vec",
                  [],
                  []
                |),
                [ M.read (| evals |) ]
              |)
            |) in
          let~ _ : Ty.apply (Ty.path "*") [] [ Ty.tuple [] ] :=
            M.match_operator (|
              Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
              M.alloc (|
                Value.Tuple
                  [
                    M.borrow (|
                      Pointer.Kind.Ref,
                      M.alloc (|
                        M.call_closure (|
                          Ty.path "usize",
                          M.get_associated_function (|
                            Ty.apply
                              (Ty.path "alloc::vec::Vec")
                              []
                              [ EF; Ty.path "alloc::alloc::Global" ],
                            "len",
                            [],
                            []
                          |),
                          [ M.borrow (| Pointer.Kind.Ref, evals |) ]
                        |)
                      |)
                    |);
                    M.borrow (| Pointer.Kind.Ref, M.alloc (| Value.Integer IntegerKind.Usize 2 |) |)
                  ]
              |),
              [
                fun γ =>
                  ltac:(M.monadic
                    (let γ0_0 := M.SubPointer.get_tuple_field (| γ, 0 |) in
                    let γ0_1 := M.SubPointer.get_tuple_field (| γ, 1 |) in
                    let left_val := M.copy (| γ0_0 |) in
                    let right_val := M.copy (| γ0_1 |) in
                    M.match_operator (|
                      Ty.apply (Ty.path "*") [] [ Ty.tuple [] ],
                      M.alloc (| Value.Tuple [] |),
                      [
                        fun γ =>
                          ltac:(M.monadic
                            (let γ :=
                              M.use
                                (M.alloc (|
                                  UnOp.not (|
                                    M.call_closure (|
                                      Ty.path "bool",
                                      BinOp.eq,
                                      [
                                        M.read (| M.deref (| M.read (| left_val |) |) |);
                                        M.read (| M.deref (| M.read (| right_val |) |) |)
                                      ]
                                    |)
                                  |)
                                |)) in
                            let _ :=
                              is_constant_or_break_match (| M.read (| γ |), Value.Bool true |) in
                            M.alloc (|
                              M.never_to_any (|
                                M.read (|
                                  let~ kind :
                                      Ty.apply
                                        (Ty.path "*")
                                        []
                                        [ Ty.path "core::panicking::AssertKind" ] :=
                                    M.alloc (|
                                      Value.StructTuple "core::panicking::AssertKind::Eq" []
                                    |) in
                                  M.alloc (|
                                    M.call_closure (|
                                      Ty.path "never",
                                      M.get_function (|
                                        "core::panicking::assert_failed",
                                        [],
                                        [ Ty.path "usize"; Ty.path "usize" ]
                                      |),
                                      [
                                        M.read (| kind |);
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (|
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (| M.read (| left_val |) |)
                                            |)
                                          |)
                                        |);
                                        M.borrow (|
                                          Pointer.Kind.Ref,
                                          M.deref (|
                                            M.borrow (|
                                              Pointer.Kind.Ref,
                                              M.deref (| M.read (| right_val |) |)
                                            |)
                                          |)
                                        |);
                                        Value.StructTuple "core::option::Option::None" []
                                      ]
                                    |)
                                  |)
                                |)
                              |)
                            |)));
                        fun γ => ltac:(M.monadic (M.alloc (| Value.Tuple [] |)))
                      ]
                    |)))
              ]
            |) in
          let~ log_arity : Ty.apply (Ty.path "*") [] [ Ty.path "usize" ] :=
            M.alloc (|
              M.call_closure (|
                Ty.path "usize",
                M.get_function (| "p3_util::log2_strict_usize", [], [] |),
                [
                  M.call_closure (|
                    Ty.path "usize",
                    M.get_associated_function (|
                      Ty.apply
                        (Ty.path "alloc::vec::Vec")
                        []
                        [ EF; Ty.path "alloc::alloc::Global" ],
                      "len",
                      [],
                      []
                    |),
                    [ M.borrow (| Pointer.Kind.Ref, evals |) ]
                  |)
                ]
              |)
            |) in
          let~ t : Ty.apply (Ty.path "*") [] [ F ] :=
            M.alloc (|
              M.call_closure (|
                F,
                M.get_trait_method (| "p3_field::field::Field", F, [], [], "inverse", [], [] |),
                [
                  M.borrow (|
                    Pointer.Kind.Ref,
                    M.alloc (|
                      M.call_closure (|
                        F,
                        M.get_associated_function (|
                          Ty.apply (Ty.path "p3_circle::domain::CircleDomain") [] [ F ],
                          "nth_x_twiddle",
                          [],
                          []
                        |),
                        [
                          M.borrow (|
                            Pointer.Kind.Ref,
                            M.alloc (|
                              M.call_closure (|
                                Ty.apply (Ty.path "p3_circle::domain::CircleDomain") [] [ F ],
                                M.get_associated_function (|
                                  Ty.apply (Ty.path "p3_circle::domain::CircleDomain") [] [ F ],
                                  "standard",
                                  [],
                                  []
                                |),
                                [
                                  M.call_closure (|
                                    Ty.path "usize",
                                    BinOp.Wrap.add,
                                    [
                                      M.call_closure (|
                                        Ty.path "usize",
                                        BinOp.Wrap.add,
                                        [ M.read (| log_folded_height |); M.read (| log_arity |) ]
                                      |);
                                      Value.Integer IntegerKind.Usize 1
                                    ]
                                  |)
                                ]
                              |)
                            |)
                          |);
                          M.call_closure (|
                            Ty.path "usize",
                            M.get_function (| "p3_util::reverse_bits_len", [], [] |),
                            [ M.read (| index |); M.read (| log_folded_height |) ]
                          |)
                        ]
                      |)
                    |)
                  |)
                ]
              |)
            |) in
          let~ sum : Ty.apply (Ty.path "*") [] [ EF ] :=
            M.alloc (|
              M.call_closure (|
                EF,
                M.get_trait_method (| "core::ops::arith::Add", EF, [], [ EF ], "add", [], [] |),
                [
                  M.read (|
                    M.deref (|
                      M.call_closure (|
                        Ty.apply (Ty.path "&") [] [ EF ],
                        M.get_trait_method (|
                          "core::ops::index::Index",
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            []
                            [ EF; Ty.path "alloc::alloc::Global" ],
                          [],
                          [ Ty.path "usize" ],
                          "index",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.Ref, evals |); Value.Integer IntegerKind.Usize 0
                        ]
                      |)
                    |)
                  |);
                  M.read (|
                    M.deref (|
                      M.call_closure (|
                        Ty.apply (Ty.path "&") [] [ EF ],
                        M.get_trait_method (|
                          "core::ops::index::Index",
                          Ty.apply
                            (Ty.path "alloc::vec::Vec")
                            []
                            [ EF; Ty.path "alloc::alloc::Global" ],
                          [],
                          [ Ty.path "usize" ],
                          "index",
                          [],
                          []
                        |),
                        [ M.borrow (| Pointer.Kind.Ref, evals |); Value.Integer IntegerKind.Usize 1
                        ]
                      |)
                    |)
                  |)
                ]
              |)
            |) in
          let~ diff : Ty.apply (Ty.path "*") [] [ EF ] :=
            M.alloc (|
              M.call_closure (|
                EF,
                M.get_trait_method (| "core::ops::arith::Mul", EF, [], [ F ], "mul", [], [] |),
                [
                  M.call_closure (|
                    EF,
                    M.get_trait_method (| "core::ops::arith::Sub", EF, [], [ EF ], "sub", [], [] |),
                    [
                      M.read (|
                        M.deref (|
                          M.call_closure (|
                            Ty.apply (Ty.path "&") [] [ EF ],
                            M.get_trait_method (|
                              "core::ops::index::Index",
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                []
                                [ EF; Ty.path "alloc::alloc::Global" ],
                              [],
                              [ Ty.path "usize" ],
                              "index",
                              [],
                              []
                            |),
                            [
                              M.borrow (| Pointer.Kind.Ref, evals |);
                              Value.Integer IntegerKind.Usize 0
                            ]
                          |)
                        |)
                      |);
                      M.read (|
                        M.deref (|
                          M.call_closure (|
                            Ty.apply (Ty.path "&") [] [ EF ],
                            M.get_trait_method (|
                              "core::ops::index::Index",
                              Ty.apply
                                (Ty.path "alloc::vec::Vec")
                                []
                                [ EF; Ty.path "alloc::alloc::Global" ],
                              [],
                              [ Ty.path "usize" ],
                              "index",
                              [],
                              []
                            |),
                            [
                              M.borrow (| Pointer.Kind.Ref, evals |);
                              Value.Integer IntegerKind.Usize 1
                            ]
                          |)
                        |)
                      |)
                    ]
                  |);
                  M.read (| t |)
                ]
              |)
            |) in
          M.alloc (|
            M.call_closure (|
              EF,
              M.get_trait_method (| "p3_field::field::Field", EF, [], [], "halve", [], [] |),
              [
                M.borrow (|
                  Pointer.Kind.Ref,
                  M.alloc (|
                    M.call_closure (|
                      EF,
                      M.get_trait_method (|
                        "core::ops::arith::Add",
                        EF,
                        [],
                        [ EF ],
                        "add",
                        [],
                        []
                      |),
                      [
                        M.read (| sum |);
                        M.call_closure (|
                          EF,
                          M.get_trait_method (|
                            "core::ops::arith::Mul",
                            EF,
                            [],
                            [ EF ],
                            "mul",
                            [],
                            []
                          |),
                          [ M.read (| beta |); M.read (| diff |) ]
                        |)
                      ]
                    |)
                  |)
                |)
              ]
            |)
          |)
        |)))
    | _, _, _ => M.impossible "wrong number of arguments"
    end.
  
  Global Instance Instance_IsFunction_fold_x_row :
    M.IsFunction.C "p3_circle::folding::fold_x_row" fold_x_row.
  Admitted.
  Global Typeclasses Opaque fold_x_row.
End folding.
